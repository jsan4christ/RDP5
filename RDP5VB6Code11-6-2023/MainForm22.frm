VERSION 5.00
Object = "{F9043C88-F6F2-101A-A3C9-08002B2F49FB}#1.2#0"; "COMDLG32.OCX"
Object = "{6B7E6392-850A-101B-AFC0-4210102A8DA7}#1.3#0"; "COMCTL32.OCX"
Object = "{0BA686C6-F7D3-101A-993E-0000C0EF6F5E}#1.0#0"; "THREED32.OCX"
Begin VB.Form Form1 
   Caption         =   "Recombimation Detection Program"
   ClientHeight    =   10035
   ClientLeft      =   1740
   ClientTop       =   -1.34100e5
   ClientWidth     =   15960
   BeginProperty Font 
      Name            =   "Arial"
      Size            =   8.25
      Charset         =   0
      Weight          =   400
      Underline       =   0   'False
      Italic          =   0   'False
      Strikethrough   =   0   'False
   EndProperty
   Icon            =   "MainForm22.frx":0000
   LinkTopic       =   "Form1"
   PaletteMode     =   1  'UseZOrder
   ScaleHeight     =   10035
   ScaleWidth      =   15960
   WhatsThisHelp   =   -1  'True
   WindowState     =   2  'Maximized
   Begin VB.Timer Timer7 
      Enabled         =   0   'False
      Index           =   1
      Interval        =   4000
      Left            =   360
      Top             =   7440
   End
   Begin VB.Timer Timer2 
      Left            =   0
      Top             =   0
   End
   Begin VB.Timer Timer7 
      Enabled         =   0   'False
      Index           =   0
      Interval        =   10
      Left            =   16080
      Top             =   1440
   End
   Begin VB.PictureBox Picture24 
      Height          =   855
      Left            =   14280
      ScaleHeight     =   795
      ScaleWidth      =   1035
      TabIndex        =   136
      Top             =   120
      Visible         =   0   'False
      Width           =   1095
   End
   Begin VB.TextBox Text2 
      Height          =   375
      Left            =   20160
      TabIndex        =   135
      Text            =   "10"
      Top             =   0
      Visible         =   0   'False
      Width           =   375
   End
   Begin VB.CommandButton Command14 
      Caption         =   "Arvind"
      Height          =   375
      Left            =   17640
      TabIndex        =   134
      Top             =   120
      Visible         =   0   'False
      Width           =   1455
   End
   Begin VB.Timer Timer6 
      Enabled         =   0   'False
      Interval        =   100
      Left            =   480
      Top             =   360
   End
   Begin Threed.SSPanel SSPanel4 
      Height          =   705
      Left            =   1680
      TabIndex        =   44
      Top             =   1440
      Width           =   7935
      _Version        =   65536
      _ExtentX        =   13991
      _ExtentY        =   1249
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "System"
         Size            =   9.75
         Charset         =   0
         Weight          =   700
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Enabled         =   0   'False
      Begin VB.PictureBox Picture11 
         Height          =   255
         Left            =   4500
         ScaleHeight     =   195
         ScaleWidth      =   345
         TabIndex        =   60
         Top             =   90
         Visible         =   0   'False
         Width           =   405
      End
      Begin Threed.SSPanel SSPanel11 
         Height          =   555
         Left            =   360
         TabIndex        =   57
         Top             =   120
         Width           =   1455
         _Version        =   65536
         _ExtentX        =   2566
         _ExtentY        =   979
         _StockProps     =   15
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "Arial"
            Size            =   8.25
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Begin VB.Label Label15 
            Alignment       =   2  'Center
            Height          =   255
            Left            =   -930
            TabIndex        =   58
            Top             =   510
            Width           =   555
         End
      End
      Begin VB.PictureBox Picture4 
         AutoRedraw      =   -1  'True
         Enabled         =   0   'False
         FillStyle       =   0  'Solid
         BeginProperty Font 
            Name            =   "Courier"
            Size            =   9.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   345
         Left            =   2280
         ScaleHeight     =   285
         ScaleWidth      =   5715
         TabIndex        =   45
         TabStop         =   0   'False
         Top             =   240
         Width           =   5775
      End
      Begin VB.CommandButton Command6 
         Enabled         =   0   'False
         BeginProperty Font 
            Name            =   "Symbol"
            Size            =   9.75
            Charset         =   2
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   315
         Index           =   1
         Left            =   6960
         MouseIcon       =   "MainForm22.frx":030A
         Picture         =   "MainForm22.frx":045C
         Style           =   1  'Graphical
         TabIndex        =   14
         ToolTipText     =   "Cycle through sequence similarity overview graphs"
         Top             =   120
         Width           =   315
      End
   End
   Begin VB.CommandButton Command15 
      Caption         =   "Command15"
      Height          =   375
      Left            =   12480
      MouseIcon       =   "MainForm22.frx":0766
      TabIndex        =   102
      Top             =   120
      Visible         =   0   'False
      Width           =   1815
   End
   Begin VB.Timer Timer4 
      Enabled         =   0   'False
      Interval        =   20
      Left            =   1440
      Top             =   960
   End
   Begin Threed.SSPanel SSPanel14 
      Height          =   495
      Left            =   15480
      TabIndex        =   85
      Top             =   120
      Visible         =   0   'False
      Width           =   855
      _Version        =   65536
      _ExtentX        =   1508
      _ExtentY        =   873
      _StockProps     =   15
      Caption         =   "SSPanel14"
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Arial"
         Size            =   8.25
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
   End
   Begin VB.Frame Frame17 
      Appearance      =   0  'Flat
      BorderStyle     =   0  'None
      ClipControls    =   0   'False
      ForeColor       =   &H80000008&
      Height          =   2835
      Left            =   10320
      TabIndex        =   73
      Top             =   3480
      Visible         =   0   'False
      Width           =   5055
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   15
         Left            =   3960
         TabIndex        =   125
         Top             =   2160
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   14
         Left            =   2760
         TabIndex        =   124
         Top             =   2280
         Width           =   735
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "3Seq"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   9
         Left            =   1440
         TabIndex        =   123
         Top             =   2280
         Width           =   825
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "Total"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   8
         Left            =   480
         TabIndex        =   122
         Top             =   2160
         Width           =   825
      End
      Begin VB.Label Label54 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Unique Events (Recombination signals)"
         ForeColor       =   &H00000000&
         Height          =   615
         Index           =   7
         Left            =   360
         TabIndex        =   121
         Top             =   1200
         Width           =   2025
      End
      Begin VB.Label Label54 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Time Elapsed"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   6
         Left            =   0
         TabIndex        =   120
         Top             =   960
         Width           =   1425
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "SiScan"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   5
         Left            =   600
         TabIndex        =   119
         Top             =   720
         Width           =   825
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "Chimaera"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   4
         Left            =   600
         TabIndex        =   118
         Top             =   840
         Width           =   825
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "MaxChi"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   3
         Left            =   1080
         TabIndex        =   117
         Top             =   480
         Width           =   825
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "BootScan"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   2
         Left            =   120
         TabIndex        =   116
         Top             =   360
         Width           =   825
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "GENECONV"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   1
         Left            =   840
         TabIndex        =   115
         Top             =   0
         Width           =   825
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   13
         Left            =   3600
         TabIndex        =   114
         Top             =   720
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   12
         Left            =   4200
         TabIndex        =   113
         Top             =   360
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   11
         Left            =   4200
         TabIndex        =   112
         Top             =   960
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   10
         Left            =   3240
         TabIndex        =   111
         Top             =   1080
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   9
         Left            =   2400
         TabIndex        =   110
         Top             =   1440
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   8
         Left            =   1800
         TabIndex        =   109
         Top             =   1560
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   7
         Left            =   1560
         TabIndex        =   108
         Top             =   840
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   6
         Left            =   3720
         TabIndex        =   107
         Top             =   240
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   5
         Left            =   3600
         TabIndex        =   106
         Top             =   240
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   4
         Left            =   3600
         TabIndex        =   105
         Top             =   240
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   3
         Left            =   3960
         TabIndex        =   104
         Top             =   1920
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   2
         Left            =   3960
         TabIndex        =   103
         Top             =   1440
         Width           =   735
      End
      Begin VB.Line Line44 
         BorderColor     =   &H00000000&
         Index           =   2
         X1              =   0
         X2              =   3540
         Y1              =   1800
         Y2              =   1800
      End
      Begin VB.Line Line44 
         BorderColor     =   &H00000000&
         Index           =   1
         X1              =   240
         X2              =   3780
         Y1              =   2040
         Y2              =   2040
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   1
         Left            =   3360
         TabIndex        =   77
         Top             =   240
         Width           =   735
      End
      Begin VB.Label Label50 
         Alignment       =   2  'Center
         BackStyle       =   0  'Transparent
         Caption         =   "Label50"
         ForeColor       =   &H00000000&
         Height          =   315
         Index           =   0
         Left            =   2400
         TabIndex        =   76
         Top             =   960
         Width           =   735
      End
      Begin VB.Label Label54 
         BackStyle       =   0  'Transparent
         Caption         =   "RDP"
         ForeColor       =   &H00000000&
         Height          =   255
         Index           =   0
         Left            =   120
         TabIndex        =   75
         Top             =   0
         Width           =   825
      End
      Begin VB.Line Line44 
         BorderColor     =   &H00000000&
         Index           =   0
         X1              =   60
         X2              =   3600
         Y1              =   300
         Y2              =   300
      End
      Begin VB.Label Label3 
         BackStyle       =   0  'Transparent
         Height          =   345
         Left            =   1320
         TabIndex        =   74
         Top             =   2160
         Width           =   1005
      End
   End
   Begin VB.Timer Timer3 
      Interval        =   2000
      Left            =   3480
      Top             =   240
   End
   Begin Threed.SSPanel SSPanel6 
      Height          =   4965
      Index           =   2
      Left            =   22560
      TabIndex        =   69
      Top             =   1800
      Visible         =   0   'False
      Width           =   6615
      _Version        =   65536
      _ExtentX        =   11668
      _ExtentY        =   8758
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command4 
         Caption         =   "Overview"
         Enabled         =   0   'False
         Height          =   285
         Index           =   2
         Left            =   0
         MouseIcon       =   "MainForm22.frx":08B8
         MousePointer    =   99  'Custom
         TabIndex        =   149
         ToolTipText     =   "Press for a summary of recombination events"
         Top             =   0
         Width           =   1635
      End
      Begin VB.CommandButton Command39 
         Caption         =   "+"
         Enabled         =   0   'False
         Height          =   255
         Index           =   1
         Left            =   0
         TabIndex        =   143
         ToolTipText     =   "Zoom in"
         Top             =   960
         Width           =   255
      End
      Begin VB.CheckBox Check1 
         Caption         =   "Show P-vals"
         Height          =   375
         Left            =   3720
         TabIndex        =   101
         Top             =   2880
         Width           =   1695
      End
      Begin VB.CommandButton Command39 
         Caption         =   "-"
         Enabled         =   0   'False
         Height          =   255
         Index           =   0
         Left            =   0
         TabIndex        =   22
         ToolTipText     =   "Zoom out"
         Top             =   0
         Width           =   255
      End
      Begin Threed.SSPanel SSPanel15 
         Height          =   855
         Left            =   2400
         TabIndex        =   95
         Top             =   2760
         Width           =   615
         _Version        =   65536
         _ExtentX        =   1085
         _ExtentY        =   1508
         _StockProps     =   15
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "Arial"
            Size            =   8.25
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Begin VB.Label Label7 
            Alignment       =   2  'Center
            BackStyle       =   0  'Transparent
            Caption         =   "--"
            Height          =   255
            Index           =   2
            Left            =   0
            TabIndex        =   98
            Top             =   600
            Width           =   615
         End
         Begin VB.Label Label7 
            Alignment       =   2  'Center
            BackStyle       =   0  'Transparent
            Caption         =   "--"
            Height          =   255
            Index           =   1
            Left            =   -240
            TabIndex        =   97
            Top             =   0
            Width           =   615
         End
         Begin VB.Label Label7 
            Alignment       =   2  'Center
            BackStyle       =   0  'Transparent
            Caption         =   "--"
            Height          =   255
            Index           =   0
            Left            =   0
            TabIndex        =   96
            Top             =   120
            Width           =   615
         End
      End
      Begin VB.VScrollBar VScroll5 
         Height          =   1335
         Left            =   3120
         MousePointer    =   1  'Arrow
         TabIndex        =   94
         Top             =   3120
         Width           =   255
      End
      Begin VB.HScrollBar HScroll4 
         Height          =   255
         Left            =   480
         TabIndex        =   93
         Top             =   2760
         Width           =   975
      End
      Begin VB.PictureBox Picture18 
         Appearance      =   0  'Flat
         BackColor       =   &H80000005&
         BorderStyle     =   0  'None
         ForeColor       =   &H80000008&
         Height          =   1815
         Left            =   3720
         ScaleHeight     =   1815
         ScaleWidth      =   255
         TabIndex        =   92
         Top             =   840
         Width           =   255
      End
      Begin VB.PictureBox Picture17 
         Height          =   1815
         Left            =   2400
         ScaleHeight     =   1755
         ScaleWidth      =   195
         TabIndex        =   86
         Top             =   960
         Width           =   255
      End
      Begin VB.PictureBox Picture29 
         Height          =   1635
         Left            =   390
         ScaleHeight     =   1575
         ScaleWidth      =   1455
         TabIndex        =   71
         Top             =   1020
         Width           =   1515
         Begin VB.PictureBox Picture26 
            Appearance      =   0  'Flat
            BackColor       =   &H80000004&
            BorderStyle     =   0  'None
            ForeColor       =   &H80000008&
            Height          =   1485
            Left            =   120
            ScaleHeight     =   1485
            ScaleWidth      =   2265
            TabIndex        =   72
            ToolTipText     =   "Right click for options"
            Top             =   120
            Width           =   2265
         End
      End
      Begin VB.CommandButton Command4 
         Caption         =   "Trees"
         Enabled         =   0   'False
         Height          =   285
         Index           =   1
         Left            =   1680
         MouseIcon       =   "MainForm22.frx":0A0A
         MousePointer    =   99  'Custom
         TabIndex        =   24
         ToolTipText     =   "Go to tree window"
         Top             =   240
         Width           =   1635
      End
      Begin VB.CommandButton Command4 
         Caption         =   "Recombination info"
         Enabled         =   0   'False
         Height          =   285
         Index           =   0
         Left            =   120
         MouseIcon       =   "MainForm22.frx":0B5C
         MousePointer    =   99  'Custom
         TabIndex        =   23
         ToolTipText     =   "Go to recombination information window"
         Top             =   360
         Width           =   1635
      End
      Begin VB.Label Label6 
         AutoSize        =   -1  'True
         Caption         =   "Label6"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   150
         Index           =   4
         Left            =   3120
         TabIndex        =   91
         Top             =   1440
         Visible         =   0   'False
         Width           =   330
      End
      Begin VB.Line Line1 
         Index           =   4
         X1              =   0
         X2              =   120
         Y1              =   240
         Y2              =   240
      End
      Begin VB.Label Label6 
         AutoSize        =   -1  'True
         Caption         =   "Label6"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   150
         Index           =   1
         Left            =   3000
         TabIndex        =   88
         Top             =   2640
         Visible         =   0   'False
         Width           =   330
      End
      Begin VB.Label Label6 
         AutoSize        =   -1  'True
         Caption         =   "Label6"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   150
         Index           =   3
         Left            =   3000
         TabIndex        =   90
         Top             =   1800
         Visible         =   0   'False
         Width           =   330
      End
      Begin VB.Label Label6 
         AutoSize        =   -1  'True
         Caption         =   "Label6"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   150
         Index           =   2
         Left            =   3000
         TabIndex        =   89
         Top             =   2160
         Visible         =   0   'False
         Width           =   330
      End
      Begin VB.Label Label6 
         AutoSize        =   -1  'True
         Caption         =   "Label6"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   150
         Index           =   0
         Left            =   3120
         TabIndex        =   87
         Top             =   1080
         Visible         =   0   'False
         Width           =   330
      End
      Begin VB.Line Line1 
         Index           =   3
         X1              =   0
         X2              =   120
         Y1              =   0
         Y2              =   0
      End
      Begin VB.Line Line1 
         Index           =   2
         X1              =   0
         X2              =   120
         Y1              =   0
         Y2              =   0
      End
      Begin VB.Line Line1 
         Index           =   1
         X1              =   0
         X2              =   120
         Y1              =   0
         Y2              =   0
      End
      Begin VB.Line Line1 
         Index           =   0
         X1              =   3120
         X2              =   3240
         Y1              =   960
         Y2              =   960
      End
      Begin VB.Label Label4 
         Alignment       =   2  'Center
         Caption         =   "Compatibility Matrix"
         Height          =   255
         Left            =   600
         TabIndex        =   70
         Top             =   540
         Width           =   2415
      End
   End
   Begin VB.Timer Timer1 
      Enabled         =   0   'False
      Interval        =   100
      Left            =   11280
      Top             =   1080
   End
   Begin VB.PictureBox Picture12 
      Appearance      =   0  'Flat
      BeginProperty Font 
         Name            =   "Arial"
         Size            =   6.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      ForeColor       =   &H80000008&
      Height          =   315
      Left            =   4920
      ScaleHeight     =   285
      ScaleWidth      =   435
      TabIndex        =   33
      Top             =   840
      Visible         =   0   'False
      Width           =   465
   End
   Begin Threed.SSPanel SSPanel8 
      Height          =   5472
      Left            =   2520
      TabIndex        =   51
      Top             =   6600
      Width           =   11472
      _Version        =   65536
      _ExtentX        =   20241
      _ExtentY        =   9657
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin Threed.SSPanel SSPanel10 
         Height          =   5385
         Left            =   8760
         TabIndex        =   56
         Top             =   120
         Width           =   4395
         _Version        =   65536
         _ExtentX        =   7752
         _ExtentY        =   9499
         _StockProps     =   15
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "Courier"
            Size            =   9.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Begin VB.PictureBox Picture23 
            Appearance      =   0  'Flat
            BackColor       =   &H80000003&
            BorderStyle     =   0  'None
            ForeColor       =   &H80000008&
            Height          =   3855
            Index           =   2
            Left            =   240
            ScaleHeight     =   3855
            ScaleWidth      =   4095
            TabIndex        =   126
            Top             =   960
            Width           =   4095
            Begin VB.Frame Frame7 
               Caption         =   "Check Using"
               Enabled         =   0   'False
               Height          =   1695
               Left            =   2400
               TabIndex        =   141
               Top             =   3000
               Width           =   675
            End
            Begin VB.Frame Frame6 
               ClipControls    =   0   'False
               Height          =   945
               Left            =   0
               TabIndex        =   140
               ToolTipText     =   "Change Lowest Acceptable Probability"
               Top             =   960
               Width           =   1695
            End
            Begin VB.Frame Frame5 
               Caption         =   "Window"
               Height          =   1155
               Left            =   1680
               TabIndex        =   138
               Top             =   1440
               Visible         =   0   'False
               Width           =   1455
               Begin VB.TextBox Text5 
                  Alignment       =   1  'Right Justify
                  Height          =   315
                  Left            =   120
                  TabIndex        =   139
                  ToolTipText     =   "Change Window Size"
                  Top             =   270
                  Width           =   585
               End
            End
            Begin VB.CommandButton Command25 
               BackColor       =   &H80000004&
               Caption         =   "STOP "
               Height          =   270
               Left            =   1560
               TabIndex        =   137
               Top             =   240
               Width           =   705
            End
            Begin VB.PictureBox Picture23 
               Appearance      =   0  'Flat
               BackColor       =   &H80000005&
               BorderStyle     =   0  'None
               ForeColor       =   &H80000008&
               Height          =   1695
               Index           =   1
               Left            =   360
               ScaleHeight     =   1695
               ScaleWidth      =   855
               TabIndex        =   129
               Top             =   2040
               Width           =   855
               Begin VB.CommandButton Command29 
                  BackColor       =   &H80000004&
                  Caption         =   "Accept"
                  Height          =   270
                  Index           =   1
                  Left            =   0
                  TabIndex        =   142
                  ToolTipText     =   "Click to accept recombination event and move onto the next"
                  Top             =   1320
                  Width           =   705
               End
               Begin VB.ComboBox Combo1 
                  Height          =   288
                  Left            =   120
                  MouseIcon       =   "MainForm22.frx":0CAE
                  MousePointer    =   99  'Custom
                  Style           =   2  'Dropdown List
                  TabIndex        =   131
                  Top             =   360
                  Width           =   720
               End
               Begin VB.CommandButton Command29 
                  BackColor       =   &H80000004&
                  Caption         =   "Options"
                  Height          =   270
                  Index           =   0
                  Left            =   0
                  TabIndex        =   130
                  Top             =   960
                  Width           =   705
               End
            End
            Begin VB.PictureBox Picture23 
               Appearance      =   0  'Flat
               BackColor       =   &H80000005&
               BorderStyle     =   0  'None
               ForeColor       =   &H80000008&
               Height          =   615
               Index           =   0
               Left            =   240
               ScaleHeight     =   615
               ScaleWidth      =   1455
               TabIndex        =   127
               Top             =   600
               Width           =   1455
               Begin VB.TextBox Text1 
                  Alignment       =   1  'Right Justify
                  Height          =   285
                  Left            =   240
                  TabIndex        =   128
                  Text            =   "0.05"
                  ToolTipText     =   "Highest Acceptable Probability"
                  Top             =   120
                  Width           =   945
               End
            End
            Begin Threed.SSPanel SSPanel9 
               Height          =   465
               Left            =   0
               TabIndex        =   132
               Top             =   0
               Width           =   825
               _Version        =   65536
               _ExtentX        =   1455
               _ExtentY        =   820
               _StockProps     =   15
               BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
                  Name            =   "Courier"
                  Size            =   9.75
                  Charset         =   0
                  Weight          =   400
                  Underline       =   0   'False
                  Italic          =   0   'False
                  Strikethrough   =   0   'False
               EndProperty
               Begin VB.Label Label1 
                  Alignment       =   2  'Center
                  Height          =   225
                  Left            =   240
                  TabIndex        =   133
                  Top             =   240
                  Width           =   585
               End
            End
         End
      End
      Begin VB.PictureBox Picture10 
         AutoRedraw      =   -1  'True
         Height          =   3585
         Left            =   480
         ScaleHeight     =   235
         ScaleMode       =   3  'Pixel
         ScaleWidth      =   489
         TabIndex        =   52
         Top             =   360
         Width           =   7395
         Begin VB.PictureBox Picture7 
            Appearance      =   0  'Flat
            BorderStyle     =   0  'None
            BeginProperty Font 
               Name            =   "Arial"
               Size            =   6.75
               Charset         =   0
               Weight          =   700
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            ForeColor       =   &H80000008&
            Height          =   2655
            Left            =   240
            ScaleHeight     =   2655
            ScaleWidth      =   6945
            TabIndex        =   53
            ToolTipText     =   "Pairwise Identity Plots"
            Top             =   1080
            Width           =   6945
            Begin VB.PictureBox Picture21 
               Height          =   765
               Left            =   1080
               ScaleHeight     =   705
               ScaleWidth      =   2025
               TabIndex        =   63
               Top             =   840
               Visible         =   0   'False
               Width           =   2085
            End
         End
         Begin VB.PictureBox Picture20 
            Appearance      =   0  'Flat
            BorderStyle     =   0  'None
            ForeColor       =   &H80000008&
            Height          =   495
            Left            =   1560
            ScaleHeight     =   495
            ScaleWidth      =   1725
            TabIndex        =   62
            Top             =   1560
            Visible         =   0   'False
            Width           =   1725
         End
         Begin VB.PictureBox Picture19 
            Appearance      =   0  'Flat
            BackColor       =   &H8000000D&
            ForeColor       =   &H80000008&
            Height          =   315
            Left            =   1320
            ScaleHeight     =   285
            ScaleWidth      =   525
            TabIndex        =   61
            Top             =   360
            Visible         =   0   'False
            Width           =   555
         End
      End
   End
   Begin Threed.SSPanel SSPanel7 
      Height          =   465
      Left            =   4080
      TabIndex        =   49
      Top             =   9960
      Width           =   11715
      _Version        =   65536
      _ExtentX        =   20664
      _ExtentY        =   820
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      FloodShowPct    =   0   'False
      Begin Threed.SSPanel SSPanel12 
         Height          =   345
         Left            =   2640
         TabIndex        =   66
         Top             =   60
         Width           =   3075
         _Version        =   65536
         _ExtentX        =   5424
         _ExtentY        =   609
         _StockProps     =   15
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "Arial"
            Size            =   8.25
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Alignment       =   1
         Begin Threed.SSPanel SSPanel13 
            Height          =   255
            Left            =   120
            TabIndex        =   68
            Top             =   90
            Width           =   1815
            _Version        =   65536
            _ExtentX        =   3201
            _ExtentY        =   450
            _StockProps     =   15
            BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
               Name            =   "Arial"
               Size            =   8.25
               Charset         =   0
               Weight          =   400
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            BorderWidth     =   1
            BevelOuter      =   0
            Font3D          =   1
         End
         Begin ComctlLib.ProgressBar ProgressBar1 
            Height          =   315
            Left            =   900
            TabIndex        =   67
            Top             =   30
            Width           =   9165
            _ExtentX        =   16166
            _ExtentY        =   556
            _Version        =   327682
            Appearance      =   1
         End
      End
      Begin Threed.SSPanel SSPanel1 
         Height          =   345
         Left            =   60
         TabIndex        =   50
         Top             =   60
         Width           =   2355
         _Version        =   65536
         _ExtentX        =   4154
         _ExtentY        =   609
         _StockProps     =   15
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "MS Sans Serif"
            Size            =   8.25
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Font3D          =   1
      End
   End
   Begin Threed.SSPanel SSPanel5 
      Height          =   4455
      Left            =   14520
      TabIndex        =   46
      Top             =   7440
      Width           =   3855
      _Version        =   65536
      _ExtentX        =   6800
      _ExtentY        =   7858
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command6 
         Enabled         =   0   'False
         BeginProperty Font 
            Name            =   "Symbol"
            Size            =   9.75
            Charset         =   2
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   315
         Index           =   2
         Left            =   2760
         MouseIcon       =   "MainForm22.frx":0E00
         Picture         =   "MainForm22.frx":0F52
         Style           =   1  'Graphical
         TabIndex        =   8
         ToolTipText     =   "Cycle through schematic sequence display options "
         Top             =   3240
         Width           =   315
      End
      Begin VB.CommandButton Command10 
         Caption         =   "Re-scan"
         Height          =   255
         Left            =   1320
         Style           =   1  'Graphical
         TabIndex        =   11
         ToolTipText     =   "You should now re-identify recombinant sequences for all unaccepted events"
         Top             =   3960
         Width           =   1215
      End
      Begin VB.CommandButton Command9 
         Height          =   255
         Left            =   840
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":125C
         Style           =   1  'Graphical
         TabIndex        =   10
         ToolTipText     =   "Go to next unaccepted event"
         Top             =   3840
         Width           =   255
      End
      Begin VB.CommandButton Command5 
         Height          =   255
         Left            =   360
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":169E
         Style           =   1  'Graphical
         TabIndex        =   9
         ToolTipText     =   "Go to previous unaccepted event"
         Top             =   3720
         Width           =   255
      End
      Begin VB.HScrollBar HScroll2 
         Enabled         =   0   'False
         Height          =   225
         Left            =   -240
         MousePointer    =   1  'Arrow
         TabIndex        =   31
         Top             =   3090
         Width           =   1185
      End
      Begin VB.VScrollBar VScroll2 
         Enabled         =   0   'False
         Height          =   3075
         Left            =   3390
         MousePointer    =   1  'Arrow
         TabIndex        =   30
         Top             =   120
         Width           =   255
      End
      Begin VB.PictureBox Picture5 
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   2925
         Left            =   120
         ScaleHeight     =   191
         ScaleMode       =   3  'Pixel
         ScaleWidth      =   209
         TabIndex        =   47
         Top             =   150
         Width           =   3195
         Begin VB.PictureBox Picture6 
            BorderStyle     =   0  'None
            Enabled         =   0   'False
            BeginProperty Font 
               Name            =   "Arial"
               Size            =   6.75
               Charset         =   0
               Weight          =   400
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            Height          =   225
            Left            =   360
            MouseIcon       =   "MainForm22.frx":1AE0
            ScaleHeight     =   15
            ScaleMode       =   3  'Pixel
            ScaleWidth      =   500
            TabIndex        =   48
            Top             =   780
            Width           =   7500
         End
      End
      Begin VB.Label Label58 
         Alignment       =   2  'Center
         Caption         =   "Label58"
         Height          =   285
         Left            =   960
         TabIndex        =   65
         Top             =   3150
         Width           =   975
      End
   End
   Begin Threed.SSPanel SSPanel3 
      Height          =   4245
      Left            =   0
      TabIndex        =   37
      Top             =   2160
      Width           =   9945
      _Version        =   65536
      _ExtentX        =   17542
      _ExtentY        =   7488
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command33 
         Caption         =   "+"
         Enabled         =   0   'False
         Height          =   255
         Index           =   1
         Left            =   7080
         TabIndex        =   13
         ToolTipText     =   "Zoom in"
         Top             =   3360
         Width           =   255
      End
      Begin VB.PictureBox Picture14 
         BeginProperty Font 
            Name            =   "Courier"
            Size            =   9.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   345
         Left            =   720
         ScaleHeight     =   285
         ScaleWidth      =   6375
         TabIndex        =   38
         Top             =   240
         Width           =   6435
         Begin VB.PictureBox Picture13 
            AutoRedraw      =   -1  'True
            BorderStyle     =   0  'None
            BeginProperty Font 
               Name            =   "Arial"
               Size            =   9.75
               Charset         =   0
               Weight          =   400
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            Height          =   255
            Left            =   -360
            ScaleHeight     =   17
            ScaleMode       =   3  'Pixel
            ScaleWidth      =   427
            TabIndex        =   39
            Top             =   0
            Width           =   6405
         End
      End
      Begin VB.PictureBox Picture22 
         Height          =   495
         Left            =   1080
         ScaleHeight     =   435
         ScaleWidth      =   5955
         TabIndex        =   100
         Top             =   1920
         Visible         =   0   'False
         Width           =   6015
      End
      Begin VB.CommandButton Command33 
         Caption         =   "-"
         Enabled         =   0   'False
         Height          =   255
         Index           =   0
         Left            =   6600
         TabIndex        =   12
         ToolTipText     =   "Zoom out"
         Top             =   3360
         Width           =   255
      End
      Begin VB.CommandButton Command6 
         Enabled         =   0   'False
         BeginProperty Font 
            Name            =   "Symbol"
            Size            =   9.75
            Charset         =   2
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   315
         Index           =   0
         Left            =   7530
         MouseIcon       =   "MainForm22.frx":1C32
         Picture         =   "MainForm22.frx":1D84
         Style           =   1  'Graphical
         TabIndex        =   28
         ToolTipText     =   "Cycle through sequence display options "
         Top             =   60
         Width           =   315
      End
      Begin VB.VScrollBar VScroll3 
         Enabled         =   0   'False
         Height          =   2865
         Left            =   8520
         MousePointer    =   1  'Arrow
         TabIndex        =   27
         Top             =   480
         Width           =   255
      End
      Begin VB.PictureBox Picture8 
         BeginProperty Font 
            Name            =   "Courier"
            Size            =   9.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   1635
         Left            =   7440
         ScaleHeight     =   1575
         ScaleWidth      =   975
         TabIndex        =   42
         Top             =   480
         Width           =   1035
         Begin VB.PictureBox Picture3 
            BorderStyle     =   0  'None
            Enabled         =   0   'False
            Height          =   3135
            Left            =   120
            MouseIcon       =   "MainForm22.frx":208E
            ScaleHeight     =   3135
            ScaleWidth      =   1095
            TabIndex        =   43
            ToolTipText     =   "Click to Mask/Unmask"
            Top             =   240
            Width           =   1095
         End
      End
      Begin VB.HScrollBar HScroll1 
         Enabled         =   0   'False
         Height          =   225
         LargeChange     =   25
         Left            =   480
         MousePointer    =   1  'Arrow
         TabIndex        =   26
         Top             =   3120
         Value           =   1
         Width           =   6465
      End
      Begin VB.PictureBox Picture9 
         BeginProperty Font 
            Name            =   "Courier"
            Size            =   9.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   1515
         Left            =   600
         ScaleHeight     =   1455
         ScaleWidth      =   6375
         TabIndex        =   40
         Top             =   1080
         Width           =   6435
         Begin VB.PictureBox Picture1 
            AutoRedraw      =   -1  'True
            BorderStyle     =   0  'None
            BeginProperty Font 
               Name            =   "Courier New"
               Size            =   9.75
               Charset         =   0
               Weight          =   400
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            Height          =   3165
            Left            =   960
            ScaleHeight     =   3165
            ScaleWidth      =   7185
            TabIndex        =   41
            Top             =   360
            Width           =   7185
         End
      End
      Begin VB.Label Label21 
         Alignment       =   2  'Center
         Caption         =   "Show All Sequences"
         BeginProperty Font 
            Name            =   "Arial"
            Size            =   6.75
            Charset         =   0
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   345
         Left            =   6480
         TabIndex        =   59
         Top             =   60
         Width           =   975
      End
   End
   Begin Threed.SSPanel SSPanel2 
      Height          =   465
      Left            =   3840
      TabIndex        =   36
      Top             =   240
      Width           =   6285
      _Version        =   65536
      _ExtentX        =   11086
      _ExtentY        =   820
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "System"
         Size            =   9.75
         Charset         =   0
         Weight          =   700
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command2 
         Height          =   345
         Index           =   4
         Left            =   4440
         MouseIcon       =   "MainForm22.frx":21E0
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":2332
         Style           =   1  'Graphical
         TabIndex        =   147
         ToolTipText     =   "Make specific matrix types"
         Top             =   0
         Width           =   225
      End
      Begin VB.CommandButton Command2 
         Height          =   345
         Index           =   3
         Left            =   3360
         MouseIcon       =   "MainForm22.frx":263C
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":278E
         Style           =   1  'Graphical
         TabIndex        =   146
         ToolTipText     =   "Make specific tree types"
         Top             =   120
         Width           =   225
      End
      Begin VB.CommandButton Command2 
         Height          =   345
         Index           =   2
         Left            =   2400
         MouseIcon       =   "MainForm22.frx":2A98
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":2BEA
         Style           =   1  'Graphical
         TabIndex        =   145
         ToolTipText     =   "Run specific recombination analyses"
         Top             =   120
         Width           =   225
      End
      Begin VB.CommandButton Command2 
         Height          =   345
         Index           =   1
         Left            =   1800
         MouseIcon       =   "MainForm22.frx":2EF4
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":3046
         Style           =   1  'Graphical
         TabIndex        =   144
         ToolTipText     =   "Save alignments and .rdp project files"
         Top             =   120
         Width           =   225
      End
      Begin VB.CommandButton Command12 
         Caption         =   "Exit"
         Height          =   345
         Index           =   1
         Left            =   5280
         MouseIcon       =   "MainForm22.frx":3350
         MousePointer    =   99  'Custom
         TabIndex        =   7
         ToolTipText     =   "Exit the program"
         Top             =   120
         Width           =   765
      End
      Begin VB.CommandButton Command38 
         Caption         =   "Matrices"
         Enabled         =   0   'False
         Height          =   345
         Left            =   3840
         MouseIcon       =   "MainForm22.frx":34A2
         MousePointer    =   99  'Custom
         TabIndex        =   5
         ToolTipText     =   "Make IJ compatibility matrix"
         Top             =   0
         Width           =   915
      End
      Begin VB.CommandButton Command2 
         Height          =   345
         Index           =   0
         Left            =   600
         MouseIcon       =   "MainForm22.frx":35F4
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":3746
         Style           =   1  'Graphical
         TabIndex        =   1
         ToolTipText     =   "Open recent files"
         Top             =   150
         Width           =   225
      End
      Begin VB.CommandButton Command12 
         Caption         =   "Options"
         Height          =   345
         Index           =   0
         Left            =   4800
         MouseIcon       =   "MainForm22.frx":3A50
         MousePointer    =   99  'Custom
         TabIndex        =   6
         ToolTipText     =   "Change analysis settings"
         Top             =   120
         Width           =   765
      End
      Begin VB.CommandButton Command1 
         Caption         =   "Open"
         Height          =   315
         Left            =   0
         MouseIcon       =   "MainForm22.frx":3BA2
         Style           =   1  'Graphical
         TabIndex        =   0
         ToolTipText     =   "Open alignment or RDP project files"
         Top             =   120
         Width           =   585
      End
      Begin VB.CommandButton Command18 
         Appearance      =   0  'Flat
         Caption         =   "Save"
         Enabled         =   0   'False
         Height          =   375
         Left            =   960
         MouseIcon       =   "MainForm22.frx":3CF4
         MousePointer    =   99  'Custom
         TabIndex        =   2
         ToolTipText     =   "Save project information"
         Top             =   30
         Width           =   975
      End
      Begin VB.CommandButton Command7 
         Caption         =   "Trees"
         Enabled         =   0   'False
         Height          =   345
         Left            =   2880
         MouseIcon       =   "MainForm22.frx":3E46
         MousePointer    =   99  'Custom
         TabIndex        =   4
         ToolTipText     =   "MakeUPGMA tree"
         Top             =   60
         Width           =   915
      End
      Begin VB.CommandButton Command22 
         Caption         =   "Run"
         Enabled         =   0   'False
         Height          =   345
         Left            =   1920
         MouseIcon       =   "MainForm22.frx":3F98
         MousePointer    =   99  'Custom
         TabIndex        =   3
         ToolTipText     =   "Do a full exploratory recombination scan using all methods selected in the General Options tab"
         Top             =   120
         Width           =   975
      End
   End
   Begin VB.PictureBox Picture15 
      BeginProperty Font 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Height          =   465
      Left            =   3600
      ScaleHeight     =   405
      ScaleWidth      =   6585
      TabIndex        =   35
      Top             =   960
      Visible         =   0   'False
      Width           =   6645
   End
   Begin VB.CommandButton Command24 
      Caption         =   "Command24"
      BeginProperty Font 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Height          =   195
      Left            =   5880
      TabIndex        =   34
      Top             =   240
      Visible         =   0   'False
      Width           =   225
   End
   Begin MSComDlg.CommonDialog CommonDialog1 
      Left            =   8040
      Top             =   0
      _ExtentX        =   847
      _ExtentY        =   847
      _Version        =   393216
      FilterIndex     =   481
   End
   Begin Threed.SSPanel SSPanel6 
      Height          =   3645
      Index           =   1
      Left            =   17520
      TabIndex        =   54
      Top             =   1560
      Visible         =   0   'False
      Width           =   3495
      _Version        =   65536
      _ExtentX        =   6165
      _ExtentY        =   6429
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command8 
         Caption         =   "Overview"
         Enabled         =   0   'False
         Height          =   255
         Index           =   2
         Left            =   0
         MouseIcon       =   "MainForm22.frx":40EA
         MousePointer    =   99  'Custom
         TabIndex        =   148
         ToolTipText     =   "Press for a summary of recombination events"
         Top             =   840
         Width           =   1005
      End
      Begin VB.CommandButton Command33 
         Caption         =   "+"
         Enabled         =   0   'False
         Height          =   255
         Index           =   3
         Left            =   480
         TabIndex        =   16
         ToolTipText     =   "Zoom in"
         Top             =   1080
         Width           =   255
      End
      Begin VB.CommandButton Command33 
         Caption         =   "-"
         Enabled         =   0   'False
         Height          =   255
         Index           =   2
         Left            =   120
         TabIndex        =   15
         ToolTipText     =   "Zoom out"
         Top             =   1080
         Width           =   255
      End
      Begin VB.CommandButton Command6 
         Enabled         =   0   'False
         BeginProperty Font 
            Name            =   "Symbol"
            Size            =   9.75
            Charset         =   2
            Weight          =   400
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         Height          =   315
         Index           =   3
         Left            =   2880
         MouseIcon       =   "MainForm22.frx":423C
         Picture         =   "MainForm22.frx":438E
         Style           =   1  'Graphical
         TabIndex        =   17
         ToolTipText     =   "Cycle through trees "
         Top             =   840
         Width           =   315
      End
      Begin VB.PictureBox Picture31 
         BorderStyle     =   0  'None
         Height          =   855
         Left            =   1560
         ScaleHeight     =   855
         ScaleWidth      =   375
         TabIndex        =   84
         Top             =   1200
         Visible         =   0   'False
         Width           =   375
      End
      Begin VB.PictureBox Picture16 
         Height          =   2175
         Left            =   1080
         ScaleHeight     =   2115
         ScaleWidth      =   1035
         TabIndex        =   82
         Top             =   600
         Width           =   1095
         Begin VB.CommandButton Command28 
            Caption         =   "STOP"
            Height          =   375
            Left            =   0
            TabIndex        =   83
            ToolTipText     =   "Stop calculation"
            Top             =   0
            Visible         =   0   'False
            Width           =   915
         End
      End
      Begin VB.CommandButton Command8 
         Caption         =   "Matrices"
         Enabled         =   0   'False
         Height          =   255
         Index           =   1
         Left            =   1710
         MouseIcon       =   "MainForm22.frx":4698
         MousePointer    =   99  'Custom
         TabIndex        =   21
         ToolTipText     =   "Go to matrix window"
         Top             =   60
         Width           =   1965
      End
      Begin VB.CommandButton Command17 
         Height          =   315
         Left            =   2904
         MouseIcon       =   "MainForm22.frx":47EA
         MousePointer    =   99  'Custom
         Picture         =   "MainForm22.frx":493C
         Style           =   1  'Graphical
         TabIndex        =   32
         ToolTipText     =   "Show trees in new window"
         Top             =   300
         Width           =   375
      End
      Begin VB.VScrollBar VScroll1 
         Enabled         =   0   'False
         Height          =   2535
         Left            =   2520
         MousePointer    =   1  'Arrow
         TabIndex        =   29
         Top             =   600
         Width           =   255
      End
      Begin VB.CommandButton Command8 
         Caption         =   "Recombination Info"
         Enabled         =   0   'False
         Height          =   255
         Index           =   0
         Left            =   0
         MouseIcon       =   "MainForm22.frx":4C46
         MousePointer    =   99  'Custom
         TabIndex        =   20
         ToolTipText     =   "Go to recombination information window"
         Top             =   120
         Width           =   1965
      End
      Begin VB.Label Label14 
         Alignment       =   2  'Center
         Height          =   255
         Left            =   -420
         TabIndex        =   55
         Top             =   405
         Width           =   2415
      End
   End
   Begin Threed.SSPanel SSPanel6 
      Height          =   1728
      Index           =   0
      Left            =   10440
      TabIndex        =   64
      Top             =   1440
      Width           =   4572
      _Version        =   65536
      _ExtentX        =   8070
      _ExtentY        =   3043
      _StockProps     =   15
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Courier"
         Size            =   9.75
         Charset         =   0
         Weight          =   400
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Begin VB.CommandButton Command13 
         Caption         =   "Overview"
         Enabled         =   0   'False
         Height          =   285
         Index           =   2
         Left            =   480
         MouseIcon       =   "MainForm22.frx":4D98
         MousePointer    =   99  'Custom
         TabIndex        =   150
         ToolTipText     =   "Go to tree window"
         Top             =   240
         Width           =   2055
      End
      Begin Threed.SSPanel SSPanel16 
         Height          =   855
         Left            =   480
         TabIndex        =   99
         Top             =   2280
         Width           =   2055
         _Version        =   65536
         _ExtentX        =   3625
         _ExtentY        =   1508
         _StockProps     =   15
         Caption         =   "SSPanel16"
         ForeColor       =   12632256
         BackColor       =   8421504
         BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
            Name            =   "Arial"
            Size            =   15
            Charset         =   0
            Weight          =   700
            Underline       =   0   'False
            Italic          =   0   'False
            Strikethrough   =   0   'False
         EndProperty
         BevelOuter      =   0
      End
      Begin VB.VScrollBar VScroll4 
         Height          =   735
         Left            =   2910
         TabIndex        =   80
         Top             =   600
         Width           =   225
      End
      Begin VB.PictureBox Picture32 
         Height          =   885
         Left            =   990
         ScaleHeight     =   825
         ScaleWidth      =   1785
         TabIndex        =   78
         Top             =   570
         Width           =   1848
         Begin VB.PictureBox Picture2 
            Appearance      =   0  'Flat
            AutoRedraw      =   -1  'True
            BorderStyle     =   0  'None
            BeginProperty Font 
               Name            =   "Arial"
               Size            =   6
               Charset         =   0
               Weight          =   400
               Underline       =   0   'False
               Italic          =   0   'False
               Strikethrough   =   0   'False
            EndProperty
            ForeColor       =   &H80000008&
            Height          =   2985
            Left            =   120
            ScaleHeight     =   2985
            ScaleWidth      =   3495
            TabIndex        =   79
            Top             =   120
            Width           =   3495
            Begin VB.CommandButton Command13 
               Appearance      =   0  'Flat
               Enabled         =   0   'False
               Height          =   285
               Index           =   3
               Left            =   480
               MouseIcon       =   "MainForm22.frx":4EEA
               MousePointer    =   99  'Custom
               Style           =   1  'Graphical
               TabIndex        =   151
               ToolTipText     =   "Go to tree window"
               Top             =   240
               UseMaskColor    =   -1  'True
               Visible         =   0   'False
               Width           =   372
            End
         End
      End
      Begin VB.CommandButton Command13 
         Caption         =   " Matrices"
         Enabled         =   0   'False
         Height          =   285
         Index           =   1
         Left            =   2640
         MouseIcon       =   "MainForm22.frx":503C
         MousePointer    =   99  'Custom
         TabIndex        =   19
         ToolTipText     =   "Go to matrix window"
         Top             =   360
         Width           =   2055
      End
      Begin VB.CommandButton Command13 
         Caption         =   "Trees"
         Enabled         =   0   'False
         Height          =   285
         Index           =   0
         Left            =   2400
         MouseIcon       =   "MainForm22.frx":518E
         MousePointer    =   99  'Custom
         TabIndex        =   18
         ToolTipText     =   "Go to tree window"
         Top             =   1320
         Width           =   2055
      End
   End
   Begin VB.CommandButton Command3 
      Caption         =   "Command3"
      Height          =   255
      Left            =   11520
      TabIndex        =   25
      Top             =   360
      Width           =   255
   End
   Begin VB.HScrollBar HScroll3 
      Height          =   75
      Left            =   6840
      TabIndex        =   81
      Top             =   600
      Width           =   255
   End
   Begin VB.Menu LoadHWSitesetMnuX 
      Caption         =   "Load Siteset"
      Visible         =   0   'False
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Change to histogram view"
         Index           =   0
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Change window size"
         Index           =   1
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   2
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Display average identity"
         Index           =   3
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Display average Tajima's D"
         Index           =   4
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Display average GC content"
         Index           =   5
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Load as site set (to test for association with recombination breakpoint distribution)"
         Index           =   6
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   7
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   8
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Save gene alignment"
         Index           =   9
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Save gene alignments"
         Index           =   10
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   11
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Test for selection at individual codon sites (using FUBAR)"
         Index           =   12
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   13
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   ""
         Index           =   14
         Visible         =   0   'False
      End
      Begin VB.Menu LoadHWSitesetMnu 
         Caption         =   "Test for selection disfavoring protein folding disruption (using SCHEMA)"
         Index           =   15
         Visible         =   0   'False
      End
   End
   Begin VB.Menu AncMnu 
      Caption         =   "Save ancestral sequence"
      Visible         =   0   'False
      Begin VB.Menu SaveAncSeq 
         Caption         =   "Save ancestral sequence"
      End
   End
   Begin VB.Menu SeqMnu 
      Caption         =   "Sequence Menu"
      Visible         =   0   'False
      Begin VB.Menu FindSeqmnu4 
         Caption         =   "Find sequence"
      End
      Begin VB.Menu PlaceABBPMnu 
         Caption         =   "Place beginning breakpoint here"
      End
      Begin VB.Menu PlaceAEBPMnu 
         Caption         =   "Place ending breakpoint here"
      End
      Begin VB.Menu SaveEAlignMnu 
         Caption         =   "Save entire alignment"
      End
      Begin VB.Menu SaveARRSMnu 
         Caption         =   "Save distributed alignment (with recombinant regions separated)"
      End
      Begin VB.Menu SaveARSRMnu 
         Caption         =   "Save alignment with recombinant sequences removed"
         Enabled         =   0   'False
      End
      Begin VB.Menu SaveARRRMnu 
         Caption         =   "Save alignment with recombinant regions removed"
         Enabled         =   0   'False
      End
      Begin VB.Menu VertAlignSplitMnu 
         Caption         =   "Split alignment into multiple new alignments based on detected breakpoint positions"
      End
      Begin VB.Menu SplitAliMnu 
         Caption         =   "Split the alignment into multiple new alignments based on detected recombinants"
      End
      Begin VB.Menu SaveEnMnu 
         Caption         =   "Save only enabled sequences"
      End
      Begin VB.Menu SaveDisMnu 
         Caption         =   "Save only disabled sequences"
      End
   End
   Begin VB.Menu XOverMnu 
      Caption         =   "XOVer Menu"
      Visible         =   0   'False
      Begin VB.Menu XOverGoToEventMnu 
         Caption         =   "Go to event"
      End
      Begin VB.Menu RecMnu 
         Caption         =   "Do a full exploratory recombination scan using all methods selected in the General Options tab"
         Index           =   0
      End
      Begin VB.Menu RecMnu 
         Caption         =   "Do a full query vs reference recombination scan using all methods selected in the General Options tab"
         Index           =   1
      End
      Begin VB.Menu RecMnu 
         Caption         =   "Quickly test for over-all evidence of recombination with PHI test"
         Index           =   2
      End
      Begin VB.Menu RDPScanMnu 
         Caption         =   "Automated RDP"
      End
      Begin VB.Menu GENECONVScanMnu 
         Caption         =   "Automated GENECONV"
      End
      Begin VB.Menu BootscanMnu 
         Caption         =   "Automated Bootscan"
      End
      Begin VB.Menu MaxChiScanMnu 
         Caption         =   "Automated MaxChi"
      End
      Begin VB.Menu AutoChimMnu 
         Caption         =   "Automated Chimaera"
      End
      Begin VB.Menu ASisMnu 
         Caption         =   "Automated SiScan"
      End
      Begin VB.Menu A3Seq 
         Caption         =   "Automated 3Seq"
      End
      Begin VB.Menu ManGCMnu 
         Caption         =   "Manual GENECONV"
      End
      Begin VB.Menu ManBootscanMnu 
         Caption         =   "Manual Bootscan"
      End
      Begin VB.Menu ManMaxChiMnu 
         Caption         =   "Manual MaxChi"
      End
      Begin VB.Menu ManSis 
         Caption         =   "Manual Siscan"
         Visible         =   0   'False
      End
      Begin VB.Menu ManLARDMnu 
         Caption         =   "Manual LARD"
      End
      Begin VB.Menu Man3Seq 
         Caption         =   "Manual 3Seq"
      End
      Begin VB.Menu ManDistPltMnu 
         Caption         =   "Manual distance plot"
      End
      Begin VB.Menu ManTOPALMnu 
         Caption         =   "Manual TOPAL"
      End
      Begin VB.Menu RecRateMnu 
         Caption         =   "Recombination rate plot"
      End
      Begin VB.Menu BPDistPltMnu 
         Caption         =   "Breakpoint distribution plot"
      End
      Begin VB.Menu BPDistPltMnu2 
         Caption         =   "Breakpoint p-val distribution plot "
      End
      Begin VB.Menu SCHEMAMnu 
         Caption         =   "SCHEMA (protein fold disruption test)"
      End
      Begin VB.Menu DNASCHEMAMnu 
         Caption         =   "SCHEMA (nucleic acid fold disruption test)"
      End
   End
   Begin VB.Menu Tree2Mnu 
      Caption         =   "Tree Menu 2"
      Visible         =   0   'False
      Begin VB.Menu UPGMAMnu 
         Caption         =   "UPGMA"
      End
      Begin VB.Menu FastNJMnu3 
         Caption         =   "Fast NJ"
      End
      Begin VB.Menu NJMnu 
         Caption         =   "Neighbor joining"
      End
      Begin VB.Menu MLMnu 
         Caption         =   "Maximum likelihood"
      End
      Begin VB.Menu BayesMnu 
         Caption         =   "Bayesian"
      End
      Begin VB.Menu MLMnuAL2 
         Caption         =   "Maximum likelihood (using RaxML) with recombinant regions removed"
      End
      Begin VB.Menu MLMnuAR 
         Caption         =   "Maximum likelihood (using RaxML) with recombinant regions separated"
      End
      Begin VB.Menu TreeOptMnu2 
         Caption         =   "Tree Options"
      End
   End
   Begin VB.Menu SchemEditMnu 
      Caption         =   "Scheme Edit Menu"
      Visible         =   0   'False
      Begin VB.Menu EMergeMnu 
         Caption         =   "Merge events"
      End
      Begin VB.Menu RCheckMnu 
         Caption         =   "Re-Check all identified events with all detection methods "
      End
      Begin VB.Menu RSortMnu2 
         Caption         =   "Re-identify recombinant sequences for all unaccepted events"
      End
      Begin VB.Menu AcceptMnu 
         Caption         =   "Accept this event only in this sequence"
      End
      Begin VB.Menu AcceptSMnu 
         Caption         =   "Accept this event in all sequences where it is found"
      End
      Begin VB.Menu RejectMnu 
         Caption         =   "Reject this event only in this sequence"
      End
      Begin VB.Menu RejectSMnu 
         Caption         =   "Reject this event in all sequences where it is found"
      End
      Begin VB.Menu ReassignMinorMnu 
         Caption         =   "Swap daughter and minor parent"
      End
      Begin VB.Menu ReassignMajorMnu 
         Caption         =   "Swap daughter and major parent"
      End
      Begin VB.Menu SwapMajorMinorMnu 
         Caption         =   "Swap major and minor parent"
      End
   End
   Begin VB.Menu MatrixMnu 
      Caption         =   "Matrix Menu"
      Visible         =   0   'False
      Begin VB.Menu CopyMatrixMnu 
         Caption         =   "Copy graphic to clipboard"
      End
      Begin VB.Menu MatrixSaveMnu 
         Caption         =   "Save graphic to .bmp file"
      End
      Begin VB.Menu SaveMatrixCsvMnu 
         Caption         =   "Save matrix data to .csv file"
      End
      Begin VB.Menu CHMatMnu 
         Caption         =   "Change matrix type"
         Begin VB.Menu CMMnu 
            Caption         =   "Compatibility matrix (Ingrid Jakobsen)"
            Index           =   0
         End
         Begin VB.Menu CMMnu 
            Caption         =   "Compatibility matrix (Trevor Bruen)"
            Index           =   1
         End
         Begin VB.Menu RFMatrixMnu 
            Caption         =   "Compatibility matrix (Robinson-Foulds)"
         End
         Begin VB.Menu SHMatrixMnu 
            Caption         =   "Compatibility matrix (Shimodaira-Hasegawa)"
         End
         Begin VB.Menu ModMatMnu 
            Caption         =   "Modularity matrix"
         End
         Begin VB.Menu RecMatMnu 
            Caption         =   "Recombination matrix"
         End
         Begin VB.Menu RecRCMnu 
            Caption         =   "Recombinant region count matrix"
         End
         Begin VB.Menu RecBPMnu 
            Caption         =   "Recombination breakpoint matrix"
         End
         Begin VB.Menu RMinMnu2 
            Caption         =   "RMin (HK) matrix"
         End
         Begin VB.Menu RminDMnu2 
            Caption         =   "RMin (HK)/Distance matrix"
         End
         Begin VB.Menu LDMnu 
            Caption         =   "McVean's LD matrix"
         End
         Begin VB.Menu MCMatMnu 
            Caption         =   "MaxChi breakpoint matrix"
         End
         Begin VB.Menu LMatMnu 
            Caption         =   "LARD breakpoint matrix"
         End
         Begin VB.Menu MatrixOptMnu2 
            Caption         =   "Matrix options"
         End
      End
      Begin VB.Menu ColMnu 
         Caption         =   "Change colour scheme"
         Begin VB.Menu C0Mnu 
            Caption         =   "Full spectrum"
            Index           =   0
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Grey scale 1"
            Index           =   1
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Grey scale 2"
            Index           =   2
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Red scale"
            Index           =   3
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Green scale"
            Index           =   4
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Blue scale"
            Index           =   5
         End
         Begin VB.Menu C0Mnu 
            Caption         =   "Heat Scale"
            Index           =   6
         End
      End
      Begin VB.Menu PABPMnu 
         Caption         =   "Place breakpoint pair here"
      End
      Begin VB.Menu MatrixOptMnu 
         Caption         =   "Matrix options"
      End
   End
   Begin VB.Menu FileMnu 
      Caption         =   "File Menu"
      Visible         =   0   'False
      Begin VB.Menu File1Mnu 
         Caption         =   "--"
      End
      Begin VB.Menu File2Mnu 
         Caption         =   "--"
      End
      Begin VB.Menu File3Mnu 
         Caption         =   "--"
      End
      Begin VB.Menu File4Mnu 
         Caption         =   "--"
      End
   End
   Begin VB.Menu SchemMnu 
      Caption         =   "Scheme Menu"
      NegotiatePosition=   2  'Middle
      Visible         =   0   'False
      Begin VB.Menu FindSeqMnu3 
         Caption         =   "Find sequence"
      End
      Begin VB.Menu CopySchmMnu 
         Caption         =   "Copy graphic to clipboard"
      End
      Begin VB.Menu SaveSchemBMPMnu 
         Caption         =   "Save graphic to .emf file"
      End
      Begin VB.Menu RSortMnu 
         Caption         =   "Re-Scan and re-identify recombinant sequences for all unaccepted events"
      End
      Begin VB.Menu RCheckMnu2 
         Caption         =   "Re-Check all identified events with all detection methods "
      End
      Begin VB.Menu GoToEventMnu 
         Caption         =   "Go to event"
         Begin VB.Menu SelEventMnu 
            Caption         =   "Select number"
         End
         Begin VB.Menu GoToBestMnu 
            Caption         =   "Go to best unaccepted event    Space"
         End
         Begin VB.Menu GoToNextEventMnu 
            Caption         =   "Go to next event                        Pg Dn"
         End
         Begin VB.Menu GoToPreviousEventMnu 
            Caption         =   "Go to previous event                  Pg Up"
         End
         Begin VB.Menu SkipAcceptedMnu 
            Caption         =   "Skip accepted"
            Checked         =   -1  'True
         End
         Begin VB.Menu SkipRejectedMnu 
            Caption         =   "Skip rejected"
            Checked         =   -1  'True
         End
      End
      Begin VB.Menu MethodMnu 
         Caption         =   "Show only events detected by..."
         Begin VB.Menu Detect1Mnu 
            Caption         =   "any method"
         End
         Begin VB.Menu Detect2Mnu 
            Caption         =   ">1 method"
         End
         Begin VB.Menu Detect3Mnu 
            Caption         =   ">2 methods"
         End
         Begin VB.Menu Detect4Mnu 
            Caption         =   ">3 methods"
         End
         Begin VB.Menu Detect5Mnu 
            Caption         =   ">4 methods"
         End
         Begin VB.Menu Detect6Mnu 
            Caption         =   ">5 methods"
         End
         Begin VB.Menu Detect7Mnu 
            Caption         =   ">6 methods"
         End
      End
      Begin VB.Menu ShowAllMnu 
         Caption         =   "Show all events"
      End
      Begin VB.Menu ShowBestAllMnu 
         Caption         =   "Show only best evidence for all sequences"
      End
      Begin VB.Menu ShowAllAllMnu 
         Caption         =   "Show all evidence for all sequnces"
      End
   End
   Begin VB.Menu TreeMnu 
      Caption         =   "Tree Menu"
      NegotiatePosition=   2  'Middle
      Visible         =   0   'False
      Begin VB.Menu FastNJMnu2 
         Caption         =   "Make FastNJ the default tree"
      End
      Begin VB.Menu SelGrpMnu 
         Caption         =   "Select Group"
      End
      Begin VB.Menu Automaskmnu2 
         Caption         =   "Auto mask for optimal recombination detection "
      End
      Begin VB.Menu UnmaskAllMnu2 
         Caption         =   "Enable all"
      End
      Begin VB.Menu MaskAllMnu2 
         Caption         =   "Mask all"
      End
      Begin VB.Menu DisableAllMnu2 
         Caption         =   "Disable all"
      End
      Begin VB.Menu CpyTreeMnu 
         Caption         =   "Copy graphic to clipboard"
      End
      Begin VB.Menu SaveNHFMnu 
         Caption         =   "Save tree in Newick format"
      End
      Begin VB.Menu SaveTreeBmpMnu 
         Caption         =   "Save graphic to .bmp file"
      End
      Begin VB.Menu SaveTreeEmfMnu 
         Caption         =   "Save graphic to .emf file"
      End
      Begin VB.Menu TreeOptMnu 
         Caption         =   "Tree Options"
      End
   End
   Begin VB.Menu SaveMnu 
      Caption         =   "Save Menu"
      NegotiatePosition=   2  'Middle
      Visible         =   0   'False
      Begin VB.Menu PlaceABBPMnu4 
         Caption         =   "Place beginning breakpoint here"
      End
      Begin VB.Menu PlaceAEBPMnu4 
         Caption         =   "Place ending breakpoint here"
      End
      Begin VB.Menu CpyEMFMnu 
         Caption         =   "Copy graphic to clipboard"
      End
      Begin VB.Menu SaveTxtMnu 
         Caption         =   "Save plot data to .csv file"
      End
      Begin VB.Menu SaveBMPMnu 
         Caption         =   "Save graphic to .bmp file"
      End
      Begin VB.Menu SaveEMFMnu 
         Caption         =   "Save graphic to .emf file"
      End
   End
   Begin VB.Menu MaskMnu 
      Caption         =   "Mask Menu"
      Visible         =   0   'False
      Begin VB.Menu FindSeqmnu 
         Caption         =   "Find sequence"
      End
      Begin VB.Menu SelRefMnu 
         Caption         =   "Select references (for query vs reference scan)"
      End
      Begin VB.Menu SelGrpMniu 
         Caption         =   "Select group"
      End
      Begin VB.Menu Automaskmnu 
         Caption         =   "Auto mask for optimal recombination detection "
      End
      Begin VB.Menu UnmaskAllMnu 
         Caption         =   "Enable all"
         Visible         =   0   'False
      End
      Begin VB.Menu MaskAllMnu 
         Caption         =   "Mask all"
      End
      Begin VB.Menu DisableAllMnu 
         Caption         =   "Disable all"
         Visible         =   0   'False
      End
      Begin VB.Menu GoToSeqMnu 
         Caption         =   "Go to"
      End
   End
   Begin VB.Menu TransSeqMnu 
      Caption         =   "Save translated sequence"
      Visible         =   0   'False
      Begin VB.Menu SAASeqMnu 
         Caption         =   "Save amino acid sequence"
      End
   End
End
Attribute VB_Name = "Form1"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Private Sub SplitThingsUp10()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long, FF2 As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1
'XX = StrainSeq(0)
Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long
'NextNo = 74062
NextnoBak = NextNo
Dim oDirX As String, ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long
NextNo = NextnoBak
ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextnoBak + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others

If (Len(StrainSeq(0)) * MemPoc) > 40000000 Then
    MemPoc = (40000000 / Len(StrainSeq(0)))
End If
NextNo = NextnoBak
'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
NumToExclude = (NextnoBak + 1) - MemPoc
NextNo = NextnoBak


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
Dim DropSeqsToDisk As Byte
DropSeqsToDisk = 0
Dim TempBig As String
LTS = GetTickCount
If Len(StrainSeq(NextnoBak)) = 0 Then DropSeqsToDisk = 1
If DropSeqsToDisk = 1 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SequencesForSaving" + UFTag For Binary As #FF
    UB = Len(StrainSeq(0))
    For x = 0 To NextnoBak
        If StrainSeq(x) = "" Then
            
            StrainSeq(x) = String(UB, " ")
            Pos = (x - 1) * UB + 1
            Get #FF, Pos, StrainSeq(x)
            
        Else
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(x)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
        Pos = 1
        If StrainSeq(x) <> String(Len(StrainSeq(x)), "-") Then
            Do While Pos > 0
                Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StrainSeq(x), Pos, 1) = "T"
                Else
                    Exit Do
                End If
            Loop
            For Y = 1 To 255
                If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
                    Pos = 1
                    Do While Pos > 0
                        Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                        If Pos > 0 Then
                            Mid$(StrainSeq(x), Pos, 1) = "-"
                        Else
                            Exit Do
                        End If
                    Loop
                End If
            Next
        
        End If
        SSS = Abs(GetTickCount)
        
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
            DoEvents
        End If
        If x > 0 Then
            'FF = FreeFile
            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
            Put #FF, Pos, StrainSeq(x)
            StrainSeq(x) = ""
        End If
    Next x
    Close #FF
    'StrainSeq(x) = TempBig
    ChDrive oDirX
    ChDir oDirX
    DropSeqsToDisk = 1
Else
    For x = 0 To NextnoBak
        If StrainSeq(x) = "" Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            '*'*
            FF = FreeFile
            'XX = PermNextno
           
            UB = Len(StrainSeq(0))
            StrainSeq(x) = String(UB, " ")
            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
            'XX = CurDir
            '*'*
            Open "SequencesForSaving" + UFTag For Binary As #FF
            '*
            Get #FF, Pos, StrainSeq(x)
            Close #FF
            'StrainSeq(x) = TempBig
            ChDrive oDirX
            '*
            ChDir oDirX
            DropSeqsToDisk = 1
        Else
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(x)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
        Pos = 1
        If StrainSeq(x) <> String(Len(StrainSeq(x)), "-") Then
            Do While Pos > 0
                Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StrainSeq(x), Pos, 1) = "T"
                Else
                    Exit Do
                End If
            Loop
            'XX = MemPoc
            For Y = 1 To 255
                If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
                    Pos = 1
                    Do While Pos > 0
                        '*
                        Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                        If Pos > 0 Then
                            Mid$(StrainSeq(x), Pos, 1) = "-"
                        Else
                            Exit Do
                        End If
                    Loop
                Else
    '                If Y = 65 Or Y = 71 Or Y = 84 Or Y = 67 Then
    '                    x = x
    '                    Pos = InStr(1, StrainSeq(x), Chr(Y), vbBinaryCompare)
    '                    If Pos > 0 Then
    '                        x = x
    '                    End If
    '                End If
                End If
            Next
        Else
            x = x
        End If
        SSS = Abs(GetTickCount)
        
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
            DoEvents
        End If
        If DropSeqsToDisk = 1 And x > 0 Then
            oDirX = CurDir
            '*
            ChDrive App.Path
            '*'*
            ChDir App.Path
            FF = FreeFile
            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
            '*
            Open "SequencesForSaving" + UFTag For Binary As #FF
            Put #FF, Pos, StrainSeq(x)
            '*
            Close #FF
            ChDrive oDirX
            '*'*
            ChDir oDirX
            StrainSeq(x) = ""
        End If
    Next x
End If
lte = GetTickCount
TT = lte - LTS 'new=58172; old=194750
NextNo = NextnoBak

If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextnoBak
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextnoBak
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextnoBak
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextnoBak
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextnoBak
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextnoBak
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
If DropSeqsToDisk = 0 Then
    For x = 0 To NextnoBak
        
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x
End If




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   NextNo = NextnoBak
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextnoBak
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextnoBak + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextnoBak + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 16 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    If NumSeeds > 1500 Then NumSeeds = 1500
    'NumSeeds = 1500
    If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    NextNo = NextnoBak
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    NextNo = NextnoBak
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    
    
    'Covert strainseq to a compressed byte array (each element = 4 nts using the seqcompressor14)
    SS = Abs(GetTickCount)
    
    If DropSeqsToDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF
        FF2 = FreeFile
        Open "CSequencesForSaving" + UFTag For Binary As FF2
    End If
    
    Dim CStrainseq() As Integer, CStrainseqA() As Integer, CStrainseqB() As Integer
    If DropSeqsToDisk = 1 Then
        ReDim CStrainseqA(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        ReDim CStrainseqB(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        For x = 0 To NextnoBak
            If x > 0 Then
                UB = Len(StrainSeq(0))
                StrainSeq(x) = String(UB, " ")
                Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                Get #FF, Pos, StrainSeq(x)
            End If
            Call CompressString(StrainSeq(x), CStrainseqA(), 0)
            If x > 0 Then
               StrainSeq(x) = ""
            End If
            
            Put #FF2, , CStrainseqA()
            
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
        Close #FF
    Else
        NextNo = NextnoBak
        ReDim CStrainseq(CLng((Len(StrainSeq(0))) / 4) + 2, NextNo)
   
        For x = 0 To NextnoBak
            Call CompressString(StrainSeq(x), CStrainseq(), x)
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
     End If
    EE = Abs(GetTickCount)
    TT = EE - SS '4.202 seconds - all VB convert one sequence at a time
    
    
    
    A = 0
    Dim TValid As Long, TDiffs As Long, TVD(1) As Long
    
    Do While A <= NumSeeds
        If DropSeqsToDisk = 1 Then
            
            UB = Len(StrainSeq(0))
            'Z = 0
            Pos = (Z) * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
            
            Get #FF2, Pos, CStrainseqA()
'            X = X
'            For X = 0 To UBound(CStrainseqA, 1)
'                If CStrainseqA(X, 0) <> 0 Then
'                    X = X
'                End If
'            Next X
        End If
        
        Miss = 0
        
        For x = 0 To NextnoBak
            If x <> Z And Dist(x, A) = 0 Then
                
                    
                    
                    If x = x Then
                        If x = x Then
                            TVD(0) = 0
                            TVD(1) = 0
                            If DropSeqsToDisk = 1 Then
            
                                 UB = Len(StrainSeq(0))
                                 
                                 Pos = x * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
                                 
                                 Get #FF2, Pos, CStrainseqB()
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseqA, 1), TVD(0), CStrainseqA(0, 0), CStrainseqB(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0))
                            Else
                            
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseq, 1), TVD(0), CStrainseq(0, x), CStrainseq(0, Z), CompressValid14(0, 0), CompressDiffs14(0, 0))
                                'XX = StrainSeq(2)
                            End If
                            Valid(x) = TVD(0)
                            Diffs(x) = TVD(1)
                        Else
                            TValid = 0
                            TDiffs = 0
                            '14
                            For Y = 0 To UBound(CStrainseq, 1)
                                TValid = TValid + CompressValid14(CStrainseq(Y, x), CStrainseq(Y, Z))
                                TDiffs = TDiffs + CompressDiffs14(CStrainseq(Y, x), CStrainseq(Y, Z))
                            Next Y
                            Valid(x) = TValid
                            Diffs(x) = TDiffs
                        End If
                    Else
                        If DropSeqsToDisk = 1 And x <> 0 Then
                            
                            
                            UB = Len(StrainSeq(0))
                            StrainSeq(x) = String(UB, " ")
                            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                            '@'@
                            
                            Get #FF, Pos, StrainSeq(x)
                            
                            
                            
                        End If
                        If Len(S1) <> Len(StrainSeq(x)) Then
                            If Len(StrainSeq(x)) < Len(S1) Then
                                StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                            End If
                        End If
                        Valid(x) = 0
                        Diffs(x) = 0
                        Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                        
    '                Else
    '                    For Y = 1 To Len(StrainSeq(0))
    '                        CharZ = Mid(StrainSeq(Z), Y, 1)
    '                        If CharZ <> "-" Then
    '                            CharX = Mid(StrainSeq(x), Y, 1)
    '                            If CharX <> "-" Then
    '                                Valid(x) = Valid(x) + 1
    '                                If CharX <> CharZ Then
    '                                    Diffs(x) = Diffs(x) + 1
    '                                End If
    '                            End If
    '                        End If
    '                    Next Y
    '                End If
                    
                    'XX = Mid$(StrainSeq(0), 60, 10)
                    'YY = Mid$(StrainSeq(1), 95, 10)
                End If
                
                If Valid(x) > Len(StrainSeq(0)) / 10 And Valid(x) > 50 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                    Miss = Miss + 1
                End If
'                If Diffs(x) > 100 Then
'                    XX = Mid$(StrainSeq(x), 110, 20)
'                    x = x '493, 4108 is out of frame
'                    '
'                End If
                
                If DropSeqsToDisk = 1 And x > 0 Then
                    StrainSeq(x) = ""
                End If
                
            End If
            x = x
        Next x
        NextNo = NextnoBak
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextnoBak
            ClosestTo(x) = NextnoBak
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        If A > NumSeeds Then
            '@'@'@'@'@'@
            If x = x Then 'NumSeeds / 2 = Int(NumSeeds / 2) Or x = x Then 'finds first best match
                Winner = -1
                Dummy = GetBestMatch(NextnoBak, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
            Else 'finds last nestmatch
                
                For x = 0 To NextnoBak
                    Lowest = NextnoBak
                    Winner = -1
                    For Y = 0 To NumSeeds
                        If Lowest >= Dist(x, Y) Then
                            Lowest = Dist(x, Y)
                            BestMatch(x) = Y
                        
                        End If
                    Next Y
                Next x
            End If
            x = x
            ReDim NIY(NumSeeds)
            For x = 0 To NextnoBak
                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
            Next x
            
'            If NumSeeds > 2000 Then
'                Exit Do
'            End If
            If NumSeeds >= MemPoc Then
                Exit Do
            End If
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    Form1.Caption = Str(NIY(x))
                    NumSeeds = NumSeeds + 1
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then
                Exit Do
            End If
            '@1756 with mempoc/3 5667 in niy(0)
            NextNo = NextnoBak
            UBD = UBound(Dist, 2)
            On Error Resume Next
            ReDim Preserve Dist(NextNo, NumSeeds)
            
            On Error GoTo 0
            If UBD = UBound(Dist, 2) Then
                NumSeeds = NumSeeds - 1
                A = A - 1
            End If
            
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        GoOn = 0
        If A > MemPoc / 5 Then '1500 is the upper soft cap on what A can reach based on the capacity of 32-bit programs (the hard cap is ~4000)
        'find the NIY with the most entries
            Highest = 0
            Winner = -1
            For x = 0 To NumSeeds - 1
            'XX = MemPoc
                If Highest < NIY(x) Then
                    Highest = NIY(x) '5150(m),2146(r),3196(o), 2145(m), 3150(r), 2145(o), 3148(m), 2144 (r), 3146(o), 2142(m),
                    '3082(r), 2140(o), 3070(m), 2139(r), 3034 (o), 2138(m), 5166(r), 2138(o)
                    Winner = x
                End If
            Next x
            x = x
    'End If
            If Winner = -1 Then
            
                GoOn = 1
                
            Else
            If (NumSeeds / 2) = Int(NumSeeds / 2) Then  'picks a random sequence from the biggest group
                Winner3 = CLng(Rnd * (NIY(Winner)))
                Dim CountX As Long
                CountX = 0
                Do
                    For Y = 0 To NextnoBak
                        If Done(Y) = 0 Then
                            If BestMatch(Y) = Winner Then
                                CountX = CountX + 1
                                If CountX >= Winner3 Then
                                    XX = Dist(Y, Winner)
                                    Winner = Y
                                    Exit Do
                                End If
                            End If
                        End If
                    Next Y
                Loop
'            ElseIf ((NumSeeds + 1) / 3) = Int((NumSeeds + 1) / 3) Then 'picks the middle sequence from the biggest group
'                Highest = 0
'                Lowest = NextnoBak
'                For Y = 0 To NextnoBak
'                    If Done(Y) = 0 Then
'                        If BestMatch(Y) = Winner Then
'                            If Dist(Y, Winner) > Highest Then Highest = Dist(Y, Winner)
'                            If Dist(Y, Winner) < Lowest And Dist(Y, Winner) <> 0 Then Lowest = Dist(Y, Winner)
'
'                        End If
'                    End If
'                Next Y
'                midpoint = ((Highest - Lowest) / 2 + Lowest)
'                mostmid = -1
'                lowmid = NextnoBak
'
'                For Y = 0 To NextnoBak
''                    If TraceA(Winner) = Y Then
''                        x = x
''                    End If
'                    If Done(Y) = 0 Then
'                        If BestMatch(Y) = Winner Then 'And TraceA(Winner) <> Y Then
'                            If Abs(Dist(Y, Winner) - midpoint) <= lowmid Then
'                                mostmid = Y
'                                lowmid = Abs(Dist(Y, Winner) - midpoint)
'                            End If
'
'                        End If
'                    End If
'                Next Y
'                'XX = Dist(mostmid, Winner)
'                Winner = mostmid
'                'Lowest = 0.1
'                x = x
            Else 'picks an outlyer of the biggest group
        'Now focus on just the biggest group
                HighestDist = 0
                x = Winner
                For Y = 0 To NextnoBak
                    If Done(Y) = 0 Then
                        If BestMatch(Y) = x Then
                        
                            If Dist(Y, x) < ClosestTo(Y) Then
                                ClosestTo(Y) = Dist(Y, x)
                            
                            End If
                        End If
                        
                    End If
                Next Y
                
                HighestDist = 0
                
                'for y = 0 to next
                Winner = -1
                For Y = 0 To NextnoBak
                    If Done(Y) = 0 Then
                        If ClosestTo(Y) < 1 And BestMatch(Y) = x Then
                            If HighestDist < ClosestTo(Y) Then
                                HighestDist = ClosestTo(Y)
                                Winner = Y
                            End If
                        End If
                    End If
                Next Y
            End If
            
            End If
            x = x
            
'            For x = 0 To NextNo '2,4,5,80,445,446
'                If StrainSeq(x) = String(Len(StrainSeq(x)), "-") Then
'                    x = x
'                End If
'            Next x
            
            Z = Winner
        Else
            GoOn = 1
        End If
        
        If GoOn = 1 Then
            If A <= MemPoc / 5 Then
            
                If A <= NumSeeds Then
                    HighestDist = 0
                    '@'@'@'@'@'@
                    If x = x Then
                       
                        Dummy = GetClosestTo(CLng(A), NextnoBak, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                        
                    Else
                        For Y = 0 To NextnoBak
                            If Done(Y) = 0 Then
                               
                                For x = 0 To A - 1
                                    If Dist(Y, x) < ClosestTo(Y) Then
                                        ClosestTo(Y) = Dist(Y, x)
                                        
                                    End If
                                Next x
                                
                            End If
                        Next Y
                    End If
                    HighestDist = 0
                    
                    'for y = 0 to next
                    Winner = -1
                    For Y = 0 To NextnoBak
                        If Done(Y) = 0 Then
                            If ClosestTo(Y) < 1 Then
                                If HighestDist < ClosestTo(Y) Then
                                    HighestDist = ClosestTo(Y)
                                    Winner = Y
                                End If
                            End If
                        End If
                    Next Y
                    
                    Z = Winner
                
                
                End If
            End If
        End If
            
       
            '116,106,113,86
        If Z = -1 Then
            NumSeeds = NumSeeds - 1
            Exit Do
        End If
'        If NumSeeds > MemPoc * 0.75 And x = 123456 Then
'           Dim LoNIY As Long, LoseNIY As Long
'           LoNIY = Nextno
'           For x = 0 To A - 2
'                If NIY(x) < LoNIY Then
'                    LoNIY = NIY(x)
'                    LoseNIY = x
'                End If
'           Next x
'           If LoseNIY < A - 1 Then
'                For x = 0 To A - 1
'                    Dist(TraceA(LoseNIY), x) = Dist(TraceA(A - 1), x)
'                Next x
'                TraceA(LoseNIY) = TraceA(A - 1)
'                NIY(LoseNIY) = NIY(A - 1)
'                A = A - 1
'           End If
'        End If
        Done(Z) = 1
        TraceA(A) = Z
        'fill in the alerady calculated distances
        For x = 0 To A - 1
            Dist(TraceA(x), A) = Dist(Winner, x)
        Next x
        
    Loop
    
    If DropSeqsToDisk = 1 Then
        Close #FF2
        ChDrive oDirX
        ChDir oDirX
    End If
    
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    '815.109 VB compressed seq
    '224.00 c++ stringdist
    '56.531 with c++ compressed seq
    
    
    
    'find the clusters before

    'make backup of bestmatch
    NextNo = NextnoBak
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextnoBak
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        
        
        'If x = x Then
            Dim W1(0) As Long, W2(0) As Long
            Lowest = NumSeeds
            W1(0) = 0
            W2(0) = 0
            Dummy = FindWinners(NumSeeds, UBound(Dist, 1), W1(0), W2(0), Done(0), TraceA(0), Dist(0, 0))
            x = x
            Winner = W1(0)
            Winner2 = W2(0)
            'XX = Done(5)
'        Else
'            Lowest = NumSeeds
'            '@'@'@'@'@'@'@
'            Winner2 = 0
'            Winner = 0
'            For x = 0 To NumSeeds - 1
'                If Done(x) = 0 Then
'
'                    For Y = x + 1 To NumSeeds
'                        If Done(Y) = 0 Then
'                            If Lowest > Dist(TraceA(Y), x) Then
'                                Lowest = Dist(TraceA(Y), x)
'                                Winner = Y
'                                Winner2 = x
'                            End If
'                        End If
'                    Next Y
'                End If
'            Next x
''            If Winner <> W1(0) Or Winner2 <> W2(0) Then
''                x = x
''            End If
'        End If
        If NIY(Winner2) + NIY(Winner) < (MemPoc * MemPocMod) And Winner <> Winner2 Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextnoBak
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then 'niy5=9, niy8=3, niy8=4, niy7=8, niy1=10, niy3=2, niy2=2,niy2=4, niy0=6, niy0=12
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextnoBak - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partition
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextnoBak
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        ElseIf Winner = Winner2 Then
            Done(Winner) = 1
        Else
            If NIY(Winner2) > NIY(Winner) Then 'niy1, niy5 done
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
'            If Winner = Winner2 Then
'                x = x
'            End If
        End If
        DoEvents
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(NumSeeds)) + " seed sequences merged"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
    
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    Dim tNIY() As Long, Segments As Single
    ReDim tNIY(NextnoBak)
    x = -1
    Dim NumInSeg As Long
    Dim GoOnA As Long
    Do While x <= NumSeeds
    'For x = 0 To NumSeeds
        x = x + 1
        If x > NumSeeds Then Exit Do
        If NIY(x) > 0 Then 'niy1=10,niy5=9
            'x = 1674
            DSN = DSN + 1
            
            If NIY(x) > MemPoc Then 'need to split the dataset into 2
                Segments = Int(NIY(x) / MemPoc) + 1
                Segments = NIY(x) / Segments
                MapX(x) = DSN
                tNIY(DSN) = Segments 'NIY(x)
                NumInSeg = 0
                
                GoOnA = 0
                For Y = 0 To NextnoBak
                    If BestMatch(Y) = x Then
                        If GoOnA = 0 Then
                            TraceA(x) = Y
                        End If
                        GoOnA = 1
                        NumInSeg = NumInSeg + 1
                        ReDim Preserve TraceA(NumSeeds)
                        If NumInSeg >= Segments Then
                            NumSeeds = NumSeeds + 1
                            ReDim Preserve NIY(NumSeeds)
                            ReDim Preserve MapX(NumSeeds)
                            ReDim Preserve TraceA(NumSeeds)
                            NIY(NumSeeds) = NIY(x) - NumSeeds
                            GoOnA = 0
                            For Z = Y + 1 To NextnoBak
                                
                                If BestMatch(Z) = x Then
                                    If GoOnA = 0 Then
                                        TraceA(NumSeeds) = Z
                                    End If
                                    GoOnA = 1
                                    BestMatch(Z) = NumSeeds
                                End If
                            Next Z
                            Exit For
                        End If
                    End If
                Next Y
                x = x
            Else
                MapX(x) = DSN
                tNIY(DSN) = NIY(x)
            End If
        End If
    'Next x
    Loop
    For x = 0 To DSN
        NIY(x) = tNIY(x)
    Next x
    If DSN <= 0 Then 'no datasets found
    ' just randomly make datasets
        Y = -1
        For x = 0 To NextnoBak
            Y = Y + 1
            If Y > NumSeeds Then Y = 0
            NIY(Y) = NIY(Y) + 1
            BestMatch(x) = Y
            
        Next x
        For x = 0 To NumSeeds
            If NIY(x) > 0 Then 'niy1=10,niy5=9
                DSN = DSN + 1
'                If DSN = 8 Then
'                    x = x
'                End If
                MapX(x) = DSN
                NIY(DSN) = NIY(x)
                
            Else
                x = x
            End If
        Next x
    End If
    If DSN > -1 Then
    
    
    ReDim Preserve NIY(DSN)
    End If
    
    For x = 0 To NextnoBak
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    NextNo = NextnoBak
    'XX = UBound(SeqLen)
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextnoBak
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    NextNo = NextnoBak
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    NextNo = NextnoBak
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    NextNo = NextnoBak
    ReDim NumDTP(NextNo)
    ReDim NIY(NumSeeds)
    For x = 0 To NextnoBak
        NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
    Next x
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A) + 1), tSeqS(LS)
        C = -1
        If DropSeqsToDisk = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "SequencesForSaving" + UFTag For Binary As #FF
        End If
        For b = 0 To NextnoBak
            If BestMatch(b) = A Then
                If DropSeqsToDisk = 1 And b > 0 Then
                    'grab the sequence off the disk
                    
                    UB = Len(StrainSeq(0))
                    StrainSeq(b) = String(UB, " ")
                    Pos = (b - 1) * (Len(StrainSeq(0))) + 1
                    Get #FF, Pos, StrainSeq(b)
                    
                End If
                If Len(StrainSeq(b)) = LS Then  'if it is a big alignment file then all but the first sequence or offloaded onto the disk
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
                If DropSeqsToDisk = 1 And b > 0 Then
                    StrainSeq(b) = ""
                End If
            End If
        Next b
        If DropSeqsToDisk = 1 Then
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        If C > -1 Then
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        End If
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextnoBak
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
'        XX = DSN
'        XX = UBound(MaskSeq)
'XX = DSN
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
                             '1665 with 29 sections and new more focused seed finding
            'unmask all the seed sequences
            For x = 0 To NumSeeds
'                If x <= UBound(TraceA) Then
                    If TraceA(x) <= UBound(MaskSeq) Then
                        MaskSeq(TraceA(x)) = 0
                    End If
'                Else
'                    ReDim Preserve TraceA(x)
'                    For Y = 0 To NextnoBak
'                        If BestMatch(Y) = x Then
'                            TraceA(x) = Y
'                            MaskSeq(Y) = 0
'                            Exit For
'                        End If
'                    Next Y
'
'                End If
            Next x
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextnoBak
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                If Winner > -1 Then
                MaskSeq(Winner) = 1
                End If
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextnoBak
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextnoBak
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    NextNo = NextnoBak
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NextNo = NextnoBak
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextnoBak
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX
    IncNumX = -1
    If DropSeqsToDisk = 1 Then
        FF2 = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF2
    End If
    For Y = 0 To NextnoBak
       If Y = NextnoBak Then
        x = x
       End If
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            'XX = OriginalName(0)
            For Z = 0 To NextnoBak
                If MaskSeq(Z) = 2 Then
                    If Z = NextnoBak Then
                        x = x
                    End If
                    
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        'grab the sequence off the disk
                        
                        UB = Len(StrainSeq(0))
                        StrainSeq(EList(Z)) = String(UB, " ")
                        Pos = (EList(Z) - 1) * (Len(StrainSeq(0))) + 1
                        Get #FF2, Pos, StrainSeq(EList(Z))
                        x = x
                    End If
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                
                    Put #FF, , StrainSeq(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        StrainSeq(EList(Z)) = ""
                    End If
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
    
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    If MaskSeq(0) <> 2 Then
        Y = 1
        OriginalPos(0) = 0
    Else
       Y = 0
    End If
    For x = 1 To NextnoBak
'        If x = NextnoBak Then
'            x = x
'        End If
        If MaskSeq(x) <> 2 Then
            If DropSeqsToDisk = 1 Then
                If Y * Len(StrainSeq(0)) < 200000000 Or Y = 0 Then ' there may be enough room in memory to hold the sequences on disk
                                                                'load the sequences up - remember that regardless, Y=0 needs to be loaded up
                    UB = Len(StrainSeq(0))
                     StrainSeq(x) = String(UB, " ")
                     Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                     Get #FF2, Pos, StrainSeq(x)
                End If
            End If
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    
    If DropSeqsToDisk = 1 Then
        
        Close #FF2
    End If
    
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    If BigFileFlag = 1 And DropSeqsToDisk = 1 Then
        If (NextNo + 1) * Len(StrainSeq(0)) < 200000000 Then 'will no longer need the bigfileflag. For mugsy the limit is 100Megs maybe change to 100megs
            BigFileFlag = 0
        End If
    End If
    
    
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub
Private Sub SplitThingsUp9()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long, FF2 As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1
'XX = StrainSeq(0)
Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long
'NextNo = 74062
NextnoBak = NextNo
Dim oDirX As String, ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long
NextNo = NextnoBak
ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextnoBak + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others

If (Len(StrainSeq(0)) * MemPoc) > 40000000 Then
    MemPoc = (40000000 / Len(StrainSeq(0)))
End If
NextNo = NextnoBak
'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
NumToExclude = (NextnoBak + 1) - MemPoc
NextNo = NextnoBak


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
Dim DropSeqsToDisk As Byte
DropSeqsToDisk = 0
Dim TempBig As String
For x = 0 To NextnoBak
    If StrainSeq(x) = "" Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        'XX = PermNextno
       
        UB = Len(StrainSeq(0))
        StrainSeq(x) = String(UB, " ")
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        'XX = CurDir
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Get #FF, Pos, StrainSeq(x)
        Close #FF
        'StrainSeq(x) = TempBig
        ChDrive oDirX
        ChDir oDirX
        DropSeqsToDisk = 1
    Else
        StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(x)), "-")
        StrainSeq(x) = StrConv(StrainSeq(x), 1)
    End If
    Pos = 1
    If StrainSeq(x) <> String(Len(StrainSeq(x)), "-") Then
        Do While Pos > 0
            Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StrainSeq(x), Pos, 1) = "T"
            Else
                Exit Do
            End If
        Loop
        'XX = MemPoc
        For Y = 1 To 255
            If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
                Pos = 1
                Do While Pos > 0
                    Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                    If Pos > 0 Then
                        Mid$(StrainSeq(x), Pos, 1) = "-"
                    Else
                        Exit Do
                    End If
                Loop
            Else
'                If Y = 65 Or Y = 71 Or Y = 84 Or Y = 67 Then
'                    x = x
'                    Pos = InStr(1, StrainSeq(x), Chr(Y), vbBinaryCompare)
'                    If Pos > 0 Then
'                        x = x
'                    End If
'                End If
            End If
        Next
    Else
        x = x
    End If
    SSS = Abs(GetTickCount)
    
    If Abs(SSS - LSSS) > 500 Then
        LSSS = SSS
        Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
        DoEvents
    End If
    If DropSeqsToDisk = 1 And x > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Put #FF, Pos, StrainSeq(x)
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        StrainSeq(x) = ""
    End If
Next x


NextNo = NextnoBak

If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextnoBak
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextnoBak
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextnoBak
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextnoBak
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextnoBak
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextnoBak
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
If DropSeqsToDisk = 0 Then
    For x = 0 To NextnoBak
        
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x
End If




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   NextNo = NextnoBak
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextnoBak
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextnoBak + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextnoBak + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 16 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    If NumSeeds > 1500 Then NumSeeds = 1500
    'NumSeeds = 1500
    If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    NextNo = NextnoBak
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    NextNo = NextnoBak
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    
    
    'Covert strainseq to a compressed byte array (each element = 4 nts using the seqcompressor14)
    SS = Abs(GetTickCount)
    
    If DropSeqsToDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF
        FF2 = FreeFile
        Open "CSequencesForSaving" + UFTag For Binary As FF2
    End If
    
    Dim CStrainseq() As Integer, CStrainseqA() As Integer, CStrainseqB() As Integer
    If DropSeqsToDisk = 1 Then
        ReDim CStrainseqA(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        ReDim CStrainseqB(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        For x = 0 To NextnoBak
            If x > 0 Then
                UB = Len(StrainSeq(0))
                StrainSeq(x) = String(UB, " ")
                Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                Get #FF, Pos, StrainSeq(x)
            End If
            Call CompressString(StrainSeq(x), CStrainseqA(), 0)
            If x > 0 Then
               StrainSeq(x) = ""
            End If
            
            Put #FF2, , CStrainseqA()
            
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
        Close #FF
    Else
        NextNo = NextnoBak
        ReDim CStrainseq(CLng((Len(StrainSeq(0))) / 4) + 2, NextNo)
   
        For x = 0 To NextnoBak
            Call CompressString(StrainSeq(x), CStrainseq(), x)
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
     End If
    EE = Abs(GetTickCount)
    TT = EE - SS '4.202 seconds - all VB convert one sequence at a time
    
    
    
    A = 0
    Dim TValid As Long, TDiffs As Long, TVD(1) As Long
    
    Do While A <= NumSeeds
        If DropSeqsToDisk = 1 Then
            
            UB = Len(StrainSeq(0))
            'Z = 0
            Pos = (Z) * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
            
            Get #FF2, Pos, CStrainseqA()
'            X = X
'            For X = 0 To UBound(CStrainseqA, 1)
'                If CStrainseqA(X, 0) <> 0 Then
'                    X = X
'                End If
'            Next X
        End If
        
        Miss = 0
        
        For x = 0 To NextnoBak
            If x <> Z And Dist(x, A) = 0 Then
                
                    
                    
                    If x = x Then
                        If x = x Then
                            TVD(0) = 0
                            TVD(1) = 0
                            If DropSeqsToDisk = 1 Then
            
                                 UB = Len(StrainSeq(0))
                                 
                                 Pos = x * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
                                 
                                 Get #FF2, Pos, CStrainseqB()
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseqA, 1), TVD(0), CStrainseqA(0, 0), CStrainseqB(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0))
                            Else
                            
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseq, 1), TVD(0), CStrainseq(0, x), CStrainseq(0, Z), CompressValid14(0, 0), CompressDiffs14(0, 0))
                                'XX = StrainSeq(2)
                            End If
                            Valid(x) = TVD(0)
                            Diffs(x) = TVD(1)
                        Else
                            TValid = 0
                            TDiffs = 0
                            '14
                            For Y = 0 To UBound(CStrainseq, 1)
                                TValid = TValid + CompressValid14(CStrainseq(Y, x), CStrainseq(Y, Z))
                                TDiffs = TDiffs + CompressDiffs14(CStrainseq(Y, x), CStrainseq(Y, Z))
                            Next Y
                            Valid(x) = TValid
                            Diffs(x) = TDiffs
                        End If
                    Else
                        If DropSeqsToDisk = 1 And x <> 0 Then
                            
                            
                            UB = Len(StrainSeq(0))
                            StrainSeq(x) = String(UB, " ")
                            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                            '@'@
                            
                            Get #FF, Pos, StrainSeq(x)
                            
                            
                            
                        End If
                        If Len(S1) <> Len(StrainSeq(x)) Then
                            If Len(StrainSeq(x)) < Len(S1) Then
                                StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                            End If
                        End If
                        Valid(x) = 0
                        Diffs(x) = 0
                        Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                        
    '                Else
    '                    For Y = 1 To Len(StrainSeq(0))
    '                        CharZ = Mid(StrainSeq(Z), Y, 1)
    '                        If CharZ <> "-" Then
    '                            CharX = Mid(StrainSeq(x), Y, 1)
    '                            If CharX <> "-" Then
    '                                Valid(x) = Valid(x) + 1
    '                                If CharX <> CharZ Then
    '                                    Diffs(x) = Diffs(x) + 1
    '                                End If
    '                            End If
    '                        End If
    '                    Next Y
    '                End If
                    
                    'XX = Mid$(StrainSeq(0), 60, 10)
                    'YY = Mid$(StrainSeq(1), 95, 10)
                End If
                
                If Valid(x) > Len(StrainSeq(0)) / 10 And Valid(x) > 50 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                    Miss = Miss + 1
                End If
'                If Diffs(x) > 100 Then
'                    XX = Mid$(StrainSeq(x), 110, 20)
'                    x = x '493, 4108 is out of frame
'                    '
'                End If
                
                If DropSeqsToDisk = 1 And x > 0 Then
                    StrainSeq(x) = ""
                End If
                
            End If
            x = x
        Next x
        NextNo = NextnoBak
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextnoBak
            ClosestTo(x) = NextnoBak
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        If A > NumSeeds Then
            '@'@'@'@'@'@
            If x = x Then 'NumSeeds / 2 = Int(NumSeeds / 2) Or x = x Then 'finds first best match
                Winner = -1
                Dummy = GetBestMatch(NextnoBak, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
            Else 'finds last nestmatch
                
                For x = 0 To NextnoBak
                    Lowest = NextnoBak
                    Winner = -1
                    For Y = 0 To NumSeeds
                        If Lowest >= Dist(x, Y) Then
                            Lowest = Dist(x, Y)
                            BestMatch(x) = Y
                        
                        End If
                    Next Y
                Next x
            End If
            x = x
            ReDim NIY(NumSeeds)
            For x = 0 To NextnoBak
                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
            Next x
            
'            If NumSeeds > 2000 Then
'                Exit Do
'            End If
            If NumSeeds >= MemPoc Then
                Exit Do
            End If
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    Form1.Caption = Str(NIY(x))
                    NumSeeds = NumSeeds + 1
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then
                Exit Do
            End If
            '@1756 with mempoc/3 5667 in niy(0)
            NextNo = NextnoBak
            UBD = UBound(Dist, 2)
            On Error Resume Next
            ReDim Preserve Dist(NextNo, NumSeeds)
            
            On Error GoTo 0
            If UBD = UBound(Dist, 2) Then
                NumSeeds = NumSeeds - 1
                A = A - 1
            End If
            
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        GoOn = 0
        If A > MemPoc / 5 Then '1500 is the upper soft cap on what A can reach based on the capacity of 32-bit programs (the hard cap is ~4000)
        'find the NIY with the most entries
            Highest = 0
            Winner = -1
            For x = 0 To NumSeeds - 1
            'XX = MemPoc
                If Highest < NIY(x) Then
                    Highest = NIY(x) '5150(m),2146(r),3196(o), 2145(m), 3150(r), 2145(o), 3148(m), 2144 (r), 3146(o), 2142(m),
                    '3082(r), 2140(o), 3070(m), 2139(r), 3034 (o), 2138(m), 5166(r), 2138(o)
                    Winner = x
                End If
            Next x
            x = x
    'End If
            If Winner = -1 Then
            
                GoOn = 1
                
            Else
            If (NumSeeds / 2) = Int(NumSeeds / 2) Then  'picks a random sequence from the biggest group
                Winner3 = CLng(Rnd * (NIY(Winner)))
                Dim CountX As Long
                CountX = 0
                Do
                    For Y = 0 To NextnoBak
                        If Done(Y) = 0 Then
                            If BestMatch(Y) = Winner Then
                                CountX = CountX + 1
                                If CountX >= Winner3 Then
                                    XX = Dist(Y, Winner)
                                    Winner = Y
                                    Exit Do
                                End If
                            End If
                        End If
                    Next Y
                Loop
'            ElseIf ((NumSeeds + 1) / 3) = Int((NumSeeds + 1) / 3) Then 'picks the middle sequence from the biggest group
'                Highest = 0
'                Lowest = NextnoBak
'                For Y = 0 To NextnoBak
'                    If Done(Y) = 0 Then
'                        If BestMatch(Y) = Winner Then
'                            If Dist(Y, Winner) > Highest Then Highest = Dist(Y, Winner)
'                            If Dist(Y, Winner) < Lowest And Dist(Y, Winner) <> 0 Then Lowest = Dist(Y, Winner)
'
'                        End If
'                    End If
'                Next Y
'                midpoint = ((Highest - Lowest) / 2 + Lowest)
'                mostmid = -1
'                lowmid = NextnoBak
'
'                For Y = 0 To NextnoBak
''                    If TraceA(Winner) = Y Then
''                        x = x
''                    End If
'                    If Done(Y) = 0 Then
'                        If BestMatch(Y) = Winner Then 'And TraceA(Winner) <> Y Then
'                            If Abs(Dist(Y, Winner) - midpoint) <= lowmid Then
'                                mostmid = Y
'                                lowmid = Abs(Dist(Y, Winner) - midpoint)
'                            End If
'
'                        End If
'                    End If
'                Next Y
'                'XX = Dist(mostmid, Winner)
'                Winner = mostmid
'                'Lowest = 0.1
'                x = x
            Else 'picks an outlyer of the biggest group
        'Now focus on just the biggest group
                HighestDist = 0
                x = Winner
                For Y = 0 To NextnoBak
                    If Done(Y) = 0 Then
                        If BestMatch(Y) = x Then
                        
                            If Dist(Y, x) < ClosestTo(Y) Then
                                ClosestTo(Y) = Dist(Y, x)
                            
                            End If
                        End If
                        
                    End If
                Next Y
                
                HighestDist = 0
                
                'for y = 0 to next
                Winner = -1
                For Y = 0 To NextnoBak
                    If Done(Y) = 0 Then
                        If ClosestTo(Y) < 1 And BestMatch(Y) = x Then
                            If HighestDist < ClosestTo(Y) Then
                                HighestDist = ClosestTo(Y)
                                Winner = Y
                            End If
                        End If
                    End If
                Next Y
            End If
            
            End If
            x = x
            
'            For x = 0 To NextNo '2,4,5,80,445,446
'                If StrainSeq(x) = String(Len(StrainSeq(x)), "-") Then
'                    x = x
'                End If
'            Next x
            
            Z = Winner
        Else
            GoOn = 1
        End If
        
        If GoOn = 1 Then
            If A <= MemPoc / 5 Then
            
                If A <= NumSeeds Then
                    HighestDist = 0
                    '@'@'@'@'@'@
                    If x = x Then
                       
                        Dummy = GetClosestTo(CLng(A), NextnoBak, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                        
                    Else
                        For Y = 0 To NextnoBak
                            If Done(Y) = 0 Then
                               
                                For x = 0 To A - 1
                                    If Dist(Y, x) < ClosestTo(Y) Then
                                        ClosestTo(Y) = Dist(Y, x)
                                        
                                    End If
                                Next x
                                
                            End If
                        Next Y
                    End If
                    HighestDist = 0
                    
                    'for y = 0 to next
                    Winner = -1
                    For Y = 0 To NextnoBak
                        If Done(Y) = 0 Then
                            If ClosestTo(Y) < 1 Then
                                If HighestDist < ClosestTo(Y) Then
                                    HighestDist = ClosestTo(Y)
                                    Winner = Y
                                End If
                            End If
                        End If
                    Next Y
                    
                    Z = Winner
                
                
                End If
            End If
        End If
            
       
            '116,106,113,86
        If Z = -1 Then
            NumSeeds = NumSeeds - 1
            Exit Do
        End If
'        If NumSeeds > MemPoc * 0.75 And x = 123456 Then
'           Dim LoNIY As Long, LoseNIY As Long
'           LoNIY = Nextno
'           For x = 0 To A - 2
'                If NIY(x) < LoNIY Then
'                    LoNIY = NIY(x)
'                    LoseNIY = x
'                End If
'           Next x
'           If LoseNIY < A - 1 Then
'                For x = 0 To A - 1
'                    Dist(TraceA(LoseNIY), x) = Dist(TraceA(A - 1), x)
'                Next x
'                TraceA(LoseNIY) = TraceA(A - 1)
'                NIY(LoseNIY) = NIY(A - 1)
'                A = A - 1
'           End If
'        End If
        Done(Z) = 1
        TraceA(A) = Z
        'fill in the alerady calculated distances
        For x = 0 To A - 1
            Dist(TraceA(x), A) = Dist(Winner, x)
        Next x
        
    Loop
    
    If DropSeqsToDisk = 1 Then
        Close #FF2
        ChDrive oDirX
        ChDir oDirX
    End If
    
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    '815.109 VB compressed seq
    '224.00 c++ stringdist
    '56.531 with c++ compressed seq
    
    
    
    'find the clusters before

    'make backup of bestmatch
    NextNo = NextnoBak
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextnoBak
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        
        
        'If x = x Then
            Dim W1(0) As Long, W2(0) As Long
            Lowest = NumSeeds
            W1(0) = 0
            W2(0) = 0
            Dummy = FindWinners(NumSeeds, UBound(Dist, 1), W1(0), W2(0), Done(0), TraceA(0), Dist(0, 0))
            x = x
            Winner = W1(0)
            Winner2 = W2(0)
            'XX = Done(5)
'        Else
'            Lowest = NumSeeds
'            '@'@'@'@'@'@'@
'            Winner2 = 0
'            Winner = 0
'            For x = 0 To NumSeeds - 1
'                If Done(x) = 0 Then
'
'                    For Y = x + 1 To NumSeeds
'                        If Done(Y) = 0 Then
'                            If Lowest > Dist(TraceA(Y), x) Then
'                                Lowest = Dist(TraceA(Y), x)
'                                Winner = Y
'                                Winner2 = x
'                            End If
'                        End If
'                    Next Y
'                End If
'            Next x
''            If Winner <> W1(0) Or Winner2 <> W2(0) Then
''                x = x
''            End If
'        End If
        If NIY(Winner2) + NIY(Winner) < (MemPoc * MemPocMod) And Winner <> Winner2 Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextnoBak
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then 'niy5=9, niy8=3, niy8=4, niy7=8, niy1=10, niy3=2, niy2=2,niy2=4, niy0=6, niy0=12
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextnoBak - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partition
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextnoBak
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        ElseIf Winner = Winner2 Then
            Done(Winner) = 1
        Else
            If NIY(Winner2) > NIY(Winner) Then 'niy1, niy5 done
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
'            If Winner = Winner2 Then
'                x = x
'            End If
        End If
        DoEvents
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(NumSeeds)) + " seed sequences merged"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
    
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    Dim tNIY() As Long, Segments As Single
    ReDim tNIY(NextnoBak)
    x = -1
    Dim NumInSeg As Long
    Dim GoOnA As Long
    Do While x <= NumSeeds
    'For x = 0 To NumSeeds
        x = x + 1
        If x > NumSeeds Then Exit Do
        If NIY(x) > 0 Then 'niy1=10,niy5=9
            'x = 1674
            DSN = DSN + 1
            
            If NIY(x) > MemPoc Then 'need to split the dataset into 2
                Segments = Int(NIY(x) / MemPoc) + 1
                Segments = NIY(x) / Segments
                MapX(x) = DSN
                tNIY(DSN) = Segments 'NIY(x)
                NumInSeg = 0
                
                GoOnA = 0
                For Y = 0 To NextnoBak
                    If BestMatch(Y) = x Then
                        If GoOnA = 0 Then
                            TraceA(x) = Y
                        End If
                        GoOnA = 1
                        NumInSeg = NumInSeg + 1
                        ReDim Preserve TraceA(NumSeeds)
                        If NumInSeg >= Segments Then
                            NumSeeds = NumSeeds + 1
                            ReDim Preserve NIY(NumSeeds)
                            ReDim Preserve MapX(NumSeeds)
                            ReDim Preserve TraceA(NumSeeds)
                            NIY(NumSeeds) = NIY(x) - NumSeeds
                            GoOnA = 0
                            For Z = Y + 1 To NextnoBak
                                
                                If BestMatch(Z) = x Then
                                    If GoOnA = 0 Then
                                        TraceA(NumSeeds) = Z
                                    End If
                                    GoOnA = 1
                                    BestMatch(Z) = NumSeeds
                                End If
                            Next Z
                            Exit For
                        End If
                    End If
                Next Y
                x = x
            Else
                MapX(x) = DSN
                tNIY(DSN) = NIY(x)
            End If
        End If
    'Next x
    Loop
    For x = 0 To DSN
        NIY(x) = tNIY(x)
    Next x
    If DSN <= 0 Then 'no datasets found
    ' just randomly make datasets
        Y = -1
        For x = 0 To NextnoBak
            Y = Y + 1
            If Y > NumSeeds Then Y = 0
            NIY(Y) = NIY(Y) + 1
            BestMatch(x) = Y
            
        Next x
        For x = 0 To NumSeeds
            If NIY(x) > 0 Then 'niy1=10,niy5=9
                DSN = DSN + 1
'                If DSN = 8 Then
'                    x = x
'                End If
                MapX(x) = DSN
                NIY(DSN) = NIY(x)
                
            Else
                x = x
            End If
        Next x
    End If
    If DSN > -1 Then
    
    
    ReDim Preserve NIY(DSN)
    End If
    
    For x = 0 To NextnoBak
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    NextNo = NextnoBak
    'XX = UBound(SeqLen)
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextnoBak
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    NextNo = NextnoBak
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    NextNo = NextnoBak
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    NextNo = NextnoBak
    ReDim NumDTP(NextNo)
    ReDim NIY(NumSeeds)
    For x = 0 To NextnoBak
        NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
    Next x
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A) + 1), tSeqS(LS)
        C = -1
        If DropSeqsToDisk = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "SequencesForSaving" + UFTag For Binary As #FF
        End If
        For b = 0 To NextnoBak
            If BestMatch(b) = A Then
                If DropSeqsToDisk = 1 And b > 0 Then
                    'grab the sequence off the disk
                    
                    UB = Len(StrainSeq(0))
                    StrainSeq(b) = String(UB, " ")
                    Pos = (b - 1) * (Len(StrainSeq(0))) + 1
                    Get #FF, Pos, StrainSeq(b)
                    
                End If
                If Len(StrainSeq(b)) = LS Then  'if it is a big alignment file then all but the first sequence or offloaded onto the disk
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
                If DropSeqsToDisk = 1 And b > 0 Then
                    StrainSeq(b) = ""
                End If
            End If
        Next b
        If DropSeqsToDisk = 1 Then
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        If C > -1 Then
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        End If
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextnoBak
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
'        XX = DSN
'        XX = UBound(MaskSeq)
'XX = DSN
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
                             '1665 with 29 sections and new more focused seed finding
            'unmask all the seed sequences
            For x = 0 To NumSeeds
'                If x <= UBound(TraceA) Then
                    If TraceA(x) <= UBound(MaskSeq) Then
                        MaskSeq(TraceA(x)) = 0
                    End If
'                Else
'                    ReDim Preserve TraceA(x)
'                    For Y = 0 To NextnoBak
'                        If BestMatch(Y) = x Then
'                            TraceA(x) = Y
'                            MaskSeq(Y) = 0
'                            Exit For
'                        End If
'                    Next Y
'
'                End If
            Next x
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextnoBak
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                If Winner > -1 Then
                MaskSeq(Winner) = 1
                End If
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextnoBak
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextnoBak
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    NextNo = NextnoBak
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NextNo = NextnoBak
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextnoBak
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX
    IncNumX = -1
    If DropSeqsToDisk = 1 Then
        FF2 = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF2
    End If
    For Y = 0 To NextnoBak
       If Y = NextnoBak Then
        x = x
       End If
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            'XX = OriginalName(0)
            For Z = 0 To NextnoBak
                If MaskSeq(Z) = 2 Then
                    If Z = NextnoBak Then
                        x = x
                    End If
                    
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        'grab the sequence off the disk
                        
                        UB = Len(StrainSeq(0))
                        StrainSeq(EList(Z)) = String(UB, " ")
                        Pos = (EList(Z) - 1) * (Len(StrainSeq(0))) + 1
                        Get #FF2, Pos, StrainSeq(EList(Z))
                        x = x
                    End If
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                
                    Put #FF, , StrainSeq(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        StrainSeq(EList(Z)) = ""
                    End If
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
    
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    If MaskSeq(0) <> 2 Then
        Y = 1
        OriginalPos(0) = 0
    Else
       Y = 0
    End If
    For x = 1 To NextnoBak
'        If x = NextnoBak Then
'            x = x
'        End If
        If MaskSeq(x) <> 2 Then
            If DropSeqsToDisk = 1 Then
                If Y * Len(StrainSeq(0)) < 200000000 Or Y = 0 Then ' there may be enough room in memory to hold the sequences on disk
                                                                'load the sequences up - remember that regardless, Y=0 needs to be loaded up
                    UB = Len(StrainSeq(0))
                     StrainSeq(x) = String(UB, " ")
                     Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                     Get #FF2, Pos, StrainSeq(x)
                End If
            End If
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    
    If DropSeqsToDisk = 1 Then
        
        Close #FF2
    End If
    
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    If BigFileFlag = 1 And DropSeqsToDisk = 1 Then
        If (NextNo + 1) * Len(StrainSeq(0)) < 200000000 Then 'will no longer need the bigfileflag. For mugsy the limit is 100Megs maybe change to 100megs
            BigFileFlag = 0
        End If
    End If
    
    
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub
Private Sub SplitThingsUp9b()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long, FF2 As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1
XX = StrainSeq(0)
Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long
'NextNo = 74062
NextnoBak = NextNo
Dim oDirX As String, ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long
NextNo = NextnoBak
ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextnoBak + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others

If (Len(StrainSeq(0)) * MemPoc) > 50000000 Then
    MemPoc = (50000000 / Len(StrainSeq(0)))
End If
NextNo = NextnoBak
'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
NumToExclude = (NextnoBak + 1) - MemPoc
NextNo = NextnoBak


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
Dim DropSeqsToDisk As Byte
DropSeqsToDisk = 0
Dim TempBig As String
For x = 0 To NextnoBak
    If StrainSeq(x) = "" Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        'XX = PermNextno
       
        UB = Len(StrainSeq(0))
        StrainSeq(x) = String(UB, " ")
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        'XX = CurDir
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Get #FF, Pos, StrainSeq(x)
        Close #FF
        'StrainSeq(x) = TempBig
        ChDrive oDirX
        ChDir oDirX
        DropSeqsToDisk = 1
    Else
        StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(x)), "-")
        StrainSeq(x) = StrConv(StrainSeq(x), 1)
    End If
    Pos = 1
    If StrainSeq(x) <> String(Len(StrainSeq(x)), "-") Then
        Do While Pos > 0
            Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StrainSeq(x), Pos, 1) = "T"
            Else
                Exit Do
            End If
        Loop
        'XX = MemPoc
        For Y = 1 To 255
            If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
                Pos = 1
                Do While Pos > 0
                    Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                    If Pos > 0 Then
                        Mid$(StrainSeq(x), Pos, 1) = "-"
                    Else
                        Exit Do
                    End If
                Loop
            Else
'                If Y = 65 Or Y = 71 Or Y = 84 Or Y = 67 Then
'                    x = x
'                    Pos = InStr(1, StrainSeq(x), Chr(Y), vbBinaryCompare)
'                    If Pos > 0 Then
'                        x = x
'                    End If
'                End If
            End If
        Next
    Else
        x = x
    End If
    SSS = Abs(GetTickCount)
    
    If Abs(SSS - LSSS) > 500 Then
        LSSS = SSS
        Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
        DoEvents
    End If
    If DropSeqsToDisk = 1 And x > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Put #FF, Pos, StrainSeq(x)
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        StrainSeq(x) = ""
    End If
Next x


NextNo = NextnoBak

If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextnoBak
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextnoBak
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextnoBak
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextnoBak
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextnoBak
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextnoBak
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



Longest = 0
For x = 0 To NextnoBak
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
If DropSeqsToDisk = 0 Then
    For x = 0 To NextnoBak
        
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x
End If




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   NextNo = NextnoBak
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextnoBak
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextnoBak + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextnoBak + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 16 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    If NumSeeds > 1500 Then NumSeeds = 1500
    'NumSeeds = 1500
    If NumSeeds > MemPoc * 0.75 Then NumSeeds = MemPoc * 0.75
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    NextNo = NextnoBak
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    NextNo = NextnoBak
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    
    
    'Covert strainseq to a compressed byte array (each element = 4 nts using the seqcompressor14)
    SS = Abs(GetTickCount)
    
    If DropSeqsToDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF
        FF2 = FreeFile
        Open "CSequencesForSaving" + UFTag For Binary As FF2
    End If
    
    Dim CStrainseq() As Integer, CStrainseqA() As Integer, CStrainseqB() As Integer
    If DropSeqsToDisk = 1 Then
        ReDim CStrainseqA(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        ReDim CStrainseqB(CLng((Len(StrainSeq(0))) / 4) + 2, 0)
        For x = 0 To NextnoBak
            If x > 0 Then
                UB = Len(StrainSeq(0))
                StrainSeq(x) = String(UB, " ")
                Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                Get #FF, Pos, StrainSeq(x)
            End If
            Call CompressString(StrainSeq(x), CStrainseqA(), 0)
            If x > 0 Then
               StrainSeq(x) = ""
            End If
            
            Put #FF2, , CStrainseqA()
            
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
        Close #FF
    Else
        NextNo = NextnoBak
        ReDim CStrainseq(CLng((Len(StrainSeq(0))) / 4) + 2, NextNo)
   
        For x = 0 To NextnoBak
            Call CompressString(StrainSeq(x), CStrainseq(), x)
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextnoBak)) + " sequences"
                DoEvents
            End If
        Next x
     End If
    EE = Abs(GetTickCount)
    TT = EE - SS '4.202 seconds - all VB convert one sequence at a time
    
    
    
    A = 0
    Dim TValid As Long, TDiffs As Long, TVD(1) As Long
    
    Do While A <= NumSeeds
    
            
        If DropSeqsToDisk = 1 Then
            
            UB = Len(StrainSeq(0))
            'Z = 0
            Pos = (Z) * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
            
            Get #FF2, Pos, CStrainseqA()
'            X = X
'            For X = 0 To UBound(CStrainseqA, 1)
'                If CStrainseqA(X, 0) <> 0 Then
'                    X = X
'                End If
'            Next X
        End If
        
        Miss = 0
        
        For x = 0 To NextnoBak
            'XX = UBound(Dist, 2)
'            If x = 10801 Then
'                x = x
'                XX = Dist(10801, 23)
'            End If
            If x <> Z And Dist(x, A) = 0 Then
                
                    
                    
                    If x = x Then
                        If x = x Then
                            
                            TVD(0) = 0
                            TVD(1) = 0
                            If DropSeqsToDisk = 1 Then
            
                                 UB = Len(StrainSeq(0))
                                 
                                 Pos = x * ((UBound(CStrainseqA, 1)) + 1) * 2 + 1 'need to *2 because cstrainseqa is an integer
                                 
                                 Get #FF2, Pos, CStrainseqB()
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseqA, 1), TVD(0), CStrainseqA(0, 0), CStrainseqB(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0))
                            Else
                            
                                
                                Dummy = SuperDist14(x, Z, UBound(CStrainseq, 1), TVD(0), CStrainseq(0, x), CStrainseq(0, Z), CompressValid14(0, 0), CompressDiffs14(0, 0))
                                'XX = StrainSeq(2)
                            End If
                            Valid(x) = TVD(0)
                            Diffs(x) = TVD(1)
                        Else
                            TValid = 0
                            TDiffs = 0
                            '14
                            For Y = 0 To UBound(CStrainseq, 1)
                                TValid = TValid + CompressValid14(CStrainseq(Y, x), CStrainseq(Y, Z))
                                TDiffs = TDiffs + CompressDiffs14(CStrainseq(Y, x), CStrainseq(Y, Z))
                            Next Y
                            Valid(x) = TValid
                            Diffs(x) = TDiffs
                        End If
                    Else
                        If DropSeqsToDisk = 1 And x <> 0 Then
                            
                            
                            UB = Len(StrainSeq(0))
                            StrainSeq(x) = String(UB, " ")
                            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                            '@'@
                            
                            Get #FF, Pos, StrainSeq(x)
                            
                            
                            
                        End If
                        If Len(S1) <> Len(StrainSeq(x)) Then
                            If Len(StrainSeq(x)) < Len(S1) Then
                                StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                            End If
                        End If
                        Valid(x) = 0
                        Diffs(x) = 0
                        Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                        
    '                Else
    '                    For Y = 1 To Len(StrainSeq(0))
    '                        CharZ = Mid(StrainSeq(Z), Y, 1)
    '                        If CharZ <> "-" Then
    '                            CharX = Mid(StrainSeq(x), Y, 1)
    '                            If CharX <> "-" Then
    '                                Valid(x) = Valid(x) + 1
    '                                If CharX <> CharZ Then
    '                                    Diffs(x) = Diffs(x) + 1
    '                                End If
    '                            End If
    '                        End If
    '                    Next Y
    '                End If
                    
                    'XX = Mid$(StrainSeq(0), 60, 10)
                    'YY = Mid$(StrainSeq(1), 95, 10)
                End If
                
                If Valid(x) > Len(StrainSeq(0)) / 10 And Valid(x) > 50 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                    Miss = Miss + 1
                End If
'                If Diffs(x) > 100 Then
'                    XX = Mid$(StrainSeq(x), 110, 20)
'                    x = x '493, 4108 is out of frame
'                    '
'                End If
                
                If DropSeqsToDisk = 1 And x > 0 Then
                    StrainSeq(x) = ""
                End If
                
            End If
            x = x
        Next x
        If x = 10801 Then
                x = x
                XX = Dist(10801, 23)
            End If
        NextNo = NextnoBak
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextnoBak
            ClosestTo(x) = NextnoBak
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        
        XX = BestMatch(8369)
        If A > NumSeeds Then
            '@'@'@'@'@'@
            ReDim NIY(NumSeeds)
            If x = 12345 Then
                Winner = -1
                'Dummy = GetBestMatch(NextnoBak, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
                Dummy = GetBestMatch2(NextnoBak, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0), NIY(0))
            Else
                For x = 0 To NextnoBak
                    If x = 10801 Then
                        x = x
                    End If
                    Lowest = NextnoBak
                    Winner = -1
                    For Y = 0 To NumSeeds 'find which seed this sequence is closest to
'                        If Y = 46 Then
'                            x = x
'                        End If
                        If Lowest > Dist(x, Y) Then
'                            If Y = 250 Then
'                                x = x
'                            End If
                            Lowest = Dist(x, Y)
                            
                            BestMatch(x) = Y
                            
                        ElseIf Lowest = Dist(x, Y) Then
                            'XX = TraceA(250)
                            If NIY(BestMatch(x)) > NIY(Y) Then
                                'NIY(BestMatch(x)) = NIY(BestMatch(x)) - 1
'                                If Y = 250 Then
'                                    x = x
'                                End If
                                BestMatch(x) = Y
                                
                            End If
                        End If
                    Next Y
                    NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
                    
                Next x
            End If
            If NumSeeds >= 250 Then ' MemPoc Then 'need to merge small seeds
                Lowest = NextnoBak
                Winner = -1
                For x = 0 To NumSeeds - 1
                    If NIY(x) <= Lowest Then
                        Lowest = NIY(x)
                        Winner = x
                    End If
                Next x
                XX = TraceA(Winner) '10801, 15075, 8369
                'XX = BestMatch(8369)
                '248,246, 240, 238
                'XX = NIY(246)
                If NIY(NumSeeds) <> 1 Then
                    x = x
                End If
'                XX = NIY(Winner)
                
                'XX = NIY(250)
                'XX = TraceA(Winner)
                'find nearest match seqs in niy(x)
                Lowest = NextnoBak
                Dim Winner3 As Long
                Winner3 = -1
                For Y = 0 To NextnoBak
                    If BestMatch(Y) = Winner Then
'                        If Y = TraceA(Winner) And BestMatch(Y) <> Winner Then
'                            x = x
'                        End If
                        
                        For x = 0 To NumSeeds
                        
                            If x <> Winner Then
                                
                                If Dist(Y, x) < Lowest And NIY(x) + NIY(Winner) < MemPoc Then
                                    Lowest = Dist(Y, x)
                                    Winner3 = x
                                End If
                            End If
                        Next x
                    End If
                Next Y
                'XX = NIY(Winner3)
                For Y = 0 To NextnoBak
                    If BestMatch(Y) = Winner Then
                        BestMatch(Y) = Winner3
                        Dist(Y, Winner3) = 0.000000001 'Dist(Y, Winner)
                    End If
                Next Y
                'XX = BestMatch(TraceA(Winner))
                'XX = Dist(TraceA(Winner), Winner3)
                'XXX = NIY(86) '1517, 1518, 1517
                'xx=, 86 = 13, 46 = 176
                NIY(Winner3) = NIY(Winner3) + NIY(Winner) 'niy(winner)=xx,3
                NIY(Winner) = NIY(NumSeeds)
                
                If Winner < NumSeeds Then
                    For Y = 0 To NextnoBak
                        If BestMatch(Y) = NumSeeds Then
                            BestMatch(Y) = Winner
                            'Dist(Y, Winner) = Dist(Y, NumSeeds)
                        End If
                    Next Y
                    For Y = 0 To NextnoBak
                        Dist(Y, Winner) = Dist(Y, NumSeeds)
                    Next Y
                    For Y = 0 To NumSeeds
                        
                        Dist(TraceA(Winner), Y) = Dist(TraceA(NumSeeds), Y)
                    Next Y
                    x = x
                    XX = Dist(TraceA(Winner), Winner)
                    XX = Dist(TraceA(NumSeeds), NumSeeds)
                    XX = Dist(TraceA(Winner), NumSeeds)
                    XX = Dist(TraceA(NumSeeds), Winner)
                    NIY(Winner) = NIY(NumSeeds)
                    Dist(TraceA(NumSeeds), Winner) = 0.000000001
                    
                    TraceA(Winner) = TraceA(NumSeeds)
                    x = x
                Else
                    
                End If
                NIY(NumSeeds) = 0
                NumSeeds = NumSeeds - 1
                A = A - 1
            End If
'            For x = 0 To NextnoBak
'                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
'            Next x
            
'            If NumSeeds > 2000 Then
'                Exit Do
'            End If
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    NumSeeds = NumSeeds + 1
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then
                Exit Do
            End If
            '@
            NextNo = NextnoBak
            ReDim Preserve Dist(NextNo, NumSeeds)
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        If A > 1500 Then '1500 is the upper soft cap on what A can reach based on the capacity of 32-bit programs (the hard cap is ~4000)
        'find the NIY with the most entries
            Highest = 0
            Winner = -1
            For x = 0 To NumSeeds - 1
                If Highest < NIY(x) Then
                    Highest = NIY(x)
                    Winner = x
                End If
            Next x
            x = x
    'End If
    
    
        'Now focus on just the biggest group
            HighestDist = 0
            x = Winner
            For Y = 0 To NextnoBak
                If Done(Y) = 0 Then
                    If BestMatch(Y) = x Then
                    
                        If Dist(Y, x) < ClosestTo(Y) Then
                            ClosestTo(Y) = Dist(Y, x)
                        End If
                    End If
                    
                End If
            Next Y
            
            HighestDist = 0
            
            'for y = 0 to next
            Winner = -1
            For Y = 0 To NextnoBak
                If Done(Y) = 0 Then
                    If ClosestTo(Y) < 1 And BestMatch(Y) = x Then
                        If HighestDist < ClosestTo(Y) Then
                            HighestDist = ClosestTo(Y)
                            Winner = Y
                        End If
                    End If
                End If
            Next Y
'            For x = 0 To NextNo '2,4,5,80,445,446
'                If StrainSeq(x) = String(Len(StrainSeq(x)), "-") Then
'                    x = x
'                End If
'            Next x
            
            Z = Winner
            
        ElseIf A <= 1500 Then
        
            If A <= NumSeeds Then
                HighestDist = 0
                '@'@'@'@'@'@
                If x = x Then
                   
                    Dummy = GetClosestTo(CLng(A), NextnoBak, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                    
                Else
                    For Y = 0 To NextnoBak
                        If Done(Y) = 0 Then
                           
                            For x = 0 To A - 1
                                If Dist(Y, x) < ClosestTo(Y) Then
                                    ClosestTo(Y) = Dist(Y, x)
                                    
                                End If
                            Next x
                            
                        End If
                    Next Y
                End If
                HighestDist = 0
                
                'for y = 0 to next
                Winner = -1
                For Y = 0 To NextnoBak
                    If Done(Y) = 0 Then
                        If ClosestTo(Y) < 1 Then
                            If HighestDist < ClosestTo(Y) Then
                                HighestDist = ClosestTo(Y)
                                Winner = Y
                            End If
                        End If
                    End If
                Next Y
                
                Z = Winner
            
            
            End If
        End If
        
        
       
            '116,106,113,86
        If Z = -1 Then
            NumSeeds = NumSeeds - 1
            Exit Do
        End If
'        If NumSeeds > MemPoc * 0.75 And x = 123456 Then
'           Dim LoNIY As Long, LoseNIY As Long
'           LoNIY = Nextno
'           For x = 0 To A - 2
'                If NIY(x) < LoNIY Then
'                    LoNIY = NIY(x)
'                    LoseNIY = x
'                End If
'           Next x
'           If LoseNIY < A - 1 Then
'                For x = 0 To A - 1
'                    Dist(TraceA(LoseNIY), x) = Dist(TraceA(A - 1), x)
'                Next x
'                TraceA(LoseNIY) = TraceA(A - 1)
'                NIY(LoseNIY) = NIY(A - 1)
'                A = A - 1
'           End If
'        End If
        Done(Z) = 1
        TraceA(A) = Z
        'fill in the alerady calculated distances
        For x = 0 To A - 1
            Dist(TraceA(x), A) = Dist(Winner, x)
        Next x
        
    Loop
    
    If DropSeqsToDisk = 1 Then
        Close #FF2
        ChDrive oDirX
        ChDir oDirX
    End If
    
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    '815.109 VB compressed seq
    '224.00 c++ stringdist
    '56.531 with c++ compressed seq
    
    
    
    'find the clusters before

    'make backup of bestmatch
    NextNo = NextnoBak
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextnoBak
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        
        
        'If x = x Then
            Dim W1(0) As Long, W2(0) As Long
            Lowest = NumSeeds
            W1(0) = 0
            W2(0) = 0
            Dummy = FindWinners(NumSeeds, UBound(Dist, 1), W1(0), W2(0), Done(0), TraceA(0), Dist(0, 0))
            x = x
            Winner = W1(0)
            Winner2 = W2(0)
            'XX = Done(5)
'        Else
'            Lowest = NumSeeds
'            '@'@'@'@'@'@'@
'            Winner2 = 0
'            Winner = 0
'            For x = 0 To NumSeeds - 1
'                If Done(x) = 0 Then
'
'                    For Y = x + 1 To NumSeeds
'                        If Done(Y) = 0 Then
'                            If Lowest > Dist(TraceA(Y), x) Then
'                                Lowest = Dist(TraceA(Y), x)
'                                Winner = Y
'                                Winner2 = x
'                            End If
'                        End If
'                    Next Y
'                End If
'            Next x
''            If Winner <> W1(0) Or Winner2 <> W2(0) Then
''                x = x
''            End If
'        End If
        If NIY(Winner2) + NIY(Winner) < (MemPoc * MemPocMod) And Winner <> Winner2 Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextnoBak
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then 'niy5=9, niy8=3, niy8=4, niy7=8, niy1=10, niy3=2, niy2=2,niy2=4, niy0=6, niy0=12
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextnoBak - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partition
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextnoBak
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        ElseIf Winner = Winner2 Then
            Done(Winner) = 1
        Else
            If NIY(Winner2) > NIY(Winner) Then 'niy1, niy5 done
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
'            If Winner = Winner2 Then
'                x = x
'            End If
        End If
        DoEvents
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(NumSeeds)) + " seed sequences merged"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
    
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    For x = 0 To NumSeeds
        If NIY(x) > 0 Then 'niy1=10,niy5=9
            DSN = DSN + 1
            MapX(x) = DSN
            NIY(DSN) = NIY(x)
            
        Else
            x = x
        End If
    Next x
    
    If DSN <= 0 Then 'no datasets found
    ' just randomly make datasets
        Y = -1
        For x = 0 To NextnoBak
            Y = Y + 1
            If Y > NumSeeds Then Y = 0
            NIY(Y) = NIY(Y) + 1
            BestMatch(x) = Y
            
        Next x
        For x = 0 To NumSeeds
            If NIY(x) > 0 Then 'niy1=10,niy5=9
                DSN = DSN + 1
                MapX(x) = DSN
                NIY(DSN) = NIY(x)
                
            Else
                x = x
            End If
        Next x
    End If
    If DSN > -1 Then
    
    
    ReDim Preserve NIY(DSN)
    End If
    
    For x = 0 To NextnoBak
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    NextNo = NextnoBak
    'XX = UBound(SeqLen)
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextnoBak
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    NextNo = NextnoBak
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    NextNo = NextnoBak
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    NextNo = NextnoBak
    ReDim NumDTP(NextNo)
    
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A) + 1), tSeqS(LS)
        C = -1
        If DropSeqsToDisk = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "SequencesForSaving" + UFTag For Binary As #FF
        End If
        For b = 0 To NextnoBak
            If BestMatch(b) = A Then
                If DropSeqsToDisk = 1 And b > 0 Then
                    'grab the sequence off the disk
                    
                    UB = Len(StrainSeq(0))
                    StrainSeq(b) = String(UB, " ")
                    Pos = (b - 1) * (Len(StrainSeq(0))) + 1
                    Get #FF, Pos, StrainSeq(b)
                    
                End If
                If Len(StrainSeq(b)) = LS Then  'if it is a big alignment file then all but the first sequence or offloaded onto the disk
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
                If DropSeqsToDisk = 1 And b > 0 Then
                    StrainSeq(b) = ""
                End If
            End If
        Next b
        If DropSeqsToDisk = 1 Then
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        If C > -1 Then
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        End If
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextnoBak
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
'        XX = DSN
'        XX = UBound(MaskSeq)
'XX = DSN
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
                             '1665 with 29 sections and new more focused seed finding
            'unmask all the seed sequences
            For x = 0 To NumSeeds
                If TraceA(x) <= UBound(MaskSeq) Then
                    MaskSeq(TraceA(x)) = 0
                End If
            Next x
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextnoBak
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextnoBak
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextnoBak
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextnoBak
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                If Winner > -1 Then
                MaskSeq(Winner) = 1
                End If
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextnoBak
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextnoBak
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    NextNo = NextnoBak
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextnoBak
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NextNo = NextnoBak
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextnoBak
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX
    IncNumX = -1
    If DropSeqsToDisk = 1 Then
        FF2 = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF2
    End If
    For Y = 0 To NextnoBak
       If Y = NextnoBak Then
        x = x
       End If
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            'XX = OriginalName(0)
            For Z = 0 To NextnoBak
                If MaskSeq(Z) = 2 Then
                    If Z = NextnoBak Then
                        x = x
                    End If
                    
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        'grab the sequence off the disk
                        
                        UB = Len(StrainSeq(0))
                        StrainSeq(EList(Z)) = String(UB, " ")
                        Pos = (EList(Z) - 1) * (Len(StrainSeq(0))) + 1
                        Get #FF2, Pos, StrainSeq(EList(Z))
                        x = x
                    End If
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                
                    Put #FF, , StrainSeq(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        StrainSeq(EList(Z)) = ""
                    End If
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
    
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    If MaskSeq(0) <> 2 Then
        Y = 1
        OriginalPos(0) = 0
    Else
       Y = 0
    End If
    For x = 1 To NextnoBak
'        If x = NextnoBak Then
'            x = x
'        End If
        If MaskSeq(x) <> 2 Then
            If DropSeqsToDisk = 1 Then
                If Y * Len(StrainSeq(0)) < 200000000 Or Y = 0 Then ' there may be enough room in memory to hold the sequences on disk
                                                                'load the sequences up - remember that regardless, Y=0 needs to be loaded up
                    UB = Len(StrainSeq(0))
                     StrainSeq(x) = String(UB, " ")
                     Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                     Get #FF2, Pos, StrainSeq(x)
                End If
            End If
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    
    If DropSeqsToDisk = 1 Then
        
        Close #FF2
    End If
    
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    If BigFileFlag = 1 And DropSeqsToDisk = 1 Then
        If (NextNo + 1) * Len(StrainSeq(0)) < 200000000 Then 'will no longer need the bigfileflag. For mugsy the limit is 100Megs maybe change to 100megs
            BigFileFlag = 0
        End If
    End If
    
    
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub
Private Sub SplitThingsUp8()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1

Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long

Dim oDirX As String, ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long

ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextNo + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others

If (Len(StrainSeq(0)) * MemPoc) > 50000000 Then
    MemPoc = (50000000 / Len(StrainSeq(0)))
End If

'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
NumToExclude = (NextNo + 1) - MemPoc
NextnoBak = NextNo


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextNo
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
Dim DropSeqsToDisk As Byte
DropSeqsToDisk = 0
Dim TempBig As String
For x = 0 To NextNo
    If StrainSeq(x) = "" Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        UB = Len(StrainSeq(0))
        StrainSeq(x) = String(UB, " ")
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        'XX = CurDir
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Get #FF, Pos, StrainSeq(x)
        Close #FF
        'StrainSeq(x) = TempBig
        ChDrive oDirX
        ChDir oDirX
        DropSeqsToDisk = 1
    Else
        StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(x)), "-")
        StrainSeq(x) = StrConv(StrainSeq(x), 1)
    End If
    Pos = 1
    Do While Pos > 0
        Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(StrainSeq(x), Pos, 1) = "T"
        Else
            Exit Do
        End If
    Loop
    For Y = 1 To 255
        If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
            Pos = 1
            Do While Pos > 0
                Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StrainSeq(x), Pos, 1) = "-"
                Else
                    Exit Do
                End If
            Loop
        End If
    Next
    SSS = Abs(GetTickCount)
    If Abs(SSS - LSSS) > 500 Then
        LSSS = SSS
        Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextNo)) + " sequences"
        DoEvents
    End If
    If DropSeqsToDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Pos = (x - 1) * (Len(StrainSeq(0))) + 1
        Open "SequencesForSaving" + UFTag For Binary As #FF
        Put #FF, Pos, StrainSeq(x)
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        StrainSeq(x) = ""
    End If
Next x




If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextNo
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextNo
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextNo
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextNo
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextNo
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextNo
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



Longest = 0
For x = 0 To NextNo
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x
If DropSeqsToDisk = 0 Then
    For x = 0 To NextNo
        
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x
End If




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextNo
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextNo + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextNo + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 16 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    If NumSeeds > 1500 Then NumSeeds = 1500
    NumSeeds = 1500
    
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    
    
    'Covert strainseq to a compressed byte array (each element = 4 nts using the seqcompressor14)
    SS = Abs(GetTickCount)
    Dim CStrainseq() As Integer
    ReDim CStrainseq(CLng((Len(StrainSeq(0))) / 4) + 2, NextNo)
    For x = 0 To NextNo
        Call CompressString(StrainSeq(x), CStrainseq(), x)
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = "Compressed " + Str(x) + " of " + Trim(Str(NextNo)) + " sequences"
            DoEvents
        End If
    Next x
    EE = Abs(GetTickCount)
    TT = EE - SS '4.202 seconds - all VB convert one sequence at a time
    If DropSeqsToDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF
        
    End If
    A = 0
    Dim TValid As Long, TDiffs As Long, TVD(1) As Long
    
    Do While A <= NumSeeds
        If DropSeqsToDisk = 1 And Z > 0 Then
            
            UB = Len(StrainSeq(0))
            S1 = String(UB, " ")
            Pos = (Z - 1) * (Len(StrainSeq(0))) + 1
            
            Get #FF, Pos, S1
            
            
        Else
        
        
            S1 = StrainSeq(Z)
        End If
        
'        For x = 0 To Nextno
'            If StrainSeq(x) = String(Len(StrainSeq(0)), "-") Then
'                x = x
'            End If
'        Next x
        Miss = 0
        
        For x = 0 To NextNo
'            If Dist(A, x) <> 0 Then
'                x = x
'            End If
            If x <> Z And Dist(x, A) = 0 Then
                
               
                '
                'If x = x Then
                    
                    
                    
                    
                    If x = x Then
                        If x = x Then
                            TVD(0) = 0
                            TVD(1) = 0
                            Dummy = SuperDist14(x, Z, UBound(CStrainseq, 1), TVD(0), CStrainseq(0, x), CStrainseq(0, Z), CompressValid14(0, 0), CompressDiffs14(0, 0))
                            Valid(x) = TVD(0)
                            Diffs(x) = TVD(1)
                        
                        Else
                            TValid = 0
                            TDiffs = 0
                            '14
                            For Y = 0 To UBound(CStrainseq, 1)
                                TValid = TValid + CompressValid14(CStrainseq(Y, x), CStrainseq(Y, Z))
                                TDiffs = TDiffs + CompressDiffs14(CStrainseq(Y, x), CStrainseq(Y, Z))
                            Next Y
                            Valid(x) = TValid
                            Diffs(x) = TDiffs
                        End If
                    Else
                        If DropSeqsToDisk = 1 And x <> 0 Then
                            
                            
                            UB = Len(StrainSeq(0))
                            StrainSeq(x) = String(UB, " ")
                            Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                            '@'@
                            
                            Get #FF, Pos, StrainSeq(x)
                            
                            
                            
                        End If
                        If Len(S1) <> Len(StrainSeq(x)) Then
                            If Len(StrainSeq(x)) < Len(S1) Then
                                StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                            End If
                        End If
                        Valid(x) = 0
                        Diffs(x) = 0
                        Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                        
    '                Else
    '                    For Y = 1 To Len(StrainSeq(0))
    '                        CharZ = Mid(StrainSeq(Z), Y, 1)
    '                        If CharZ <> "-" Then
    '                            CharX = Mid(StrainSeq(x), Y, 1)
    '                            If CharX <> "-" Then
    '                                Valid(x) = Valid(x) + 1
    '                                If CharX <> CharZ Then
    '                                    Diffs(x) = Diffs(x) + 1
    '                                End If
    '                            End If
    '                        End If
    '                    Next Y
    '                End If
                    
                    'XX = Mid$(StrainSeq(0), 60, 10)
                    'YY = Mid$(StrainSeq(1), 95, 10)
                End If
                If Valid(x) <> TVD(0) Then
                    x = x
                ElseIf Diffs(x) <> TVD(1) Then
                    x = x
                End If
                If Valid(x) > Len(StrainSeq(0)) / 10 And Valid(x) > 50 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                    Miss = Miss + 1
                End If
                If Diffs(x) > 100 Then
                    XX = Mid$(StrainSeq(x), 110, 20)
                    x = x '493, 4108 is out of frame
                    '
                End If
                
                If DropSeqsToDisk = 1 And x > 0 Then
                    StrainSeq(x) = ""
                End If
                
            End If
            x = x
        Next x
        
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextNo
            ClosestTo(x) = NextNo
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        If A > NumSeeds Then
            '@'@'@'@'@'@
            If x = x Then
                Winner = -1
                Dummy = GetBestMatch(NextNo, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
            Else
                For x = 0 To NextNo
                    Lowest = NextNo
                    Winner = -1
                    For Y = 0 To NumSeeds
                        If Lowest > Dist(x, Y) Then
                            Lowest = Dist(x, Y)
                            BestMatch(x) = Y
                            
                        End If
                    Next Y
                Next x
            End If
            ReDim NIY(NumSeeds)
            For x = 0 To NextNo
                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
            Next x
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    NumSeeds = NumSeeds + 1
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then
                Exit Do
            End If
            '@
            ReDim Preserve Dist(NextNo, NumSeeds)
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        If A > 1500 Then
        'find the NIY with the most entries
            Highest = 0
            Winner = -1
            For x = 0 To NumSeeds - 1
                If Highest < NIY(x) Then
                    Highest = NIY(x)
                    Winner = x
                End If
            Next x
            x = x
    'End If
    
    
        'Now focus on just the biggest group
            HighestDist = 0
            x = Winner
            For Y = 0 To NextNo
                If Done(Y) = 0 Then
                    If BestMatch(Y) = x Then
                    
                        If Dist(Y, x) < ClosestTo(Y) Then
                            ClosestTo(Y) = Dist(Y, x)
                        End If
                    End If
                    
                End If
            Next Y
            
            HighestDist = 0
            
            'for y = 0 to next
            Winner = -1
            For Y = 0 To NextNo
                If Done(Y) = 0 Then
                    If ClosestTo(Y) < 1 And BestMatch(Y) = x Then
                        If HighestDist < ClosestTo(Y) Then
                            HighestDist = ClosestTo(Y)
                            Winner = Y
                        End If
                    End If
                End If
            Next Y
            
            Z = Winner
            
        ElseIf A <= 1500 Then
        
            If A <= NumSeeds Then
                HighestDist = 0
                '@'@'@'@'@'@
                If x = x Then
                   
                    Dummy = GetClosestTo(CLng(A), NextNo, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                    
                Else
                    For Y = 0 To NextNo
                        If Done(Y) = 0 Then
                           
                            For x = 0 To A - 1
                                If Dist(Y, x) < ClosestTo(Y) Then
                                    ClosestTo(Y) = Dist(Y, x)
                                    
                                End If
                            Next x
                            
                        End If
                    Next Y
                End If
                HighestDist = 0
                
                'for y = 0 to next
                Winner = -1
                For Y = 0 To NextNo
                    If Done(Y) = 0 Then
                        If ClosestTo(Y) < 1 Then
                            If HighestDist < ClosestTo(Y) Then
                                HighestDist = ClosestTo(Y)
                                Winner = Y
                            End If
                        End If
                    End If
                Next Y
                
                Z = Winner
            
            
            End If
        End If
        
            
       
            '116,106,113,86
        If Z = -1 Then
            NumSeeds = NumSeeds - 1
            Exit Do
        End If
'        If NumSeeds > MemPoc * 0.75 And x = 123456 Then
'           Dim LoNIY As Long, LoseNIY As Long
'           LoNIY = Nextno
'           For x = 0 To A - 2
'                If NIY(x) < LoNIY Then
'                    LoNIY = NIY(x)
'                    LoseNIY = x
'                End If
'           Next x
'           If LoseNIY < A - 1 Then
'                For x = 0 To A - 1
'                    Dist(TraceA(LoseNIY), x) = Dist(TraceA(A - 1), x)
'                Next x
'                TraceA(LoseNIY) = TraceA(A - 1)
'                NIY(LoseNIY) = NIY(A - 1)
'                A = A - 1
'           End If
'        End If
        Done(Z) = 1
        TraceA(A) = Z
        'fill in the alerady calculated distances
        For x = 0 To A - 1
            Dist(TraceA(x), A) = Dist(Winner, x)
        Next x
        
    Loop
    
    If DropSeqsToDisk = 1 Then
        Close #FF
        ChDrive oDirX
        '@'@'@
        ChDir oDirX
    End If
    
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    '815.109 VB compressed seq
    '224.00 c++ stringdist
    '56.531 with c++ compressed seq
    
    
    
    'find the clusters before

    'make backup of bestmatch
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextNo
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        
        
        If x = x Then
            Dim W1(0) As Long, W2(0) As Long
            Lowest = NumSeeds
            W1(0) = 0
            W2(0) = 0
            Dummy = FindWinners(NumSeeds, UBound(Dist, 1), W1(0), W2(0), Done(0), TraceA(0), Dist(0, 0))
            x = x
            Winner = W1(0)
            Winner2 = W2(0)
        Else
            Lowest = NumSeeds
            '@'@'@'@'@'@'@
            Winner2 = 0
            Winner = 0
            For x = 0 To NumSeeds - 1
                If Done(x) = 0 Then
                    
                    For Y = x + 1 To NumSeeds
                        If Done(Y) = 0 Then
                            If Lowest > Dist(TraceA(Y), x) Then
                                Lowest = Dist(TraceA(Y), x)
                                Winner = Y
                                Winner2 = x
                            End If
                        End If
                    Next Y
                End If
            Next x
'            If Winner <> W1(0) Or Winner2 <> W2(0) Then
'                x = x
'            End If
        End If
        If NIY(Winner2) + NIY(Winner) < MemPoc * MemPocMod Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextNo
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextNo - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partitiom
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextNo
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        Else
            If NIY(Winner2) > NIY(Winner) Then
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
'            If Winner = Winner2 Then
'                x = x
'            End If
        End If
        DoEvents
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(NumSeeds)) + " seed sequences merged"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
    
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    For x = 0 To NumSeeds
        If NIY(x) > 0 Then
            DSN = DSN + 1
            MapX(x) = DSN
            NIY(DSN) = NIY(x)
            
        Else
            x = x
        End If
    Next x
    
    ReDim Preserve NIY(DSN)
    For x = 0 To NextNo
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextNo
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    ReDim NumDTP(NextNo)
    
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A)), tSeqS(LS)
        C = -1
        If DropSeqsToDisk = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "SequencesForSaving" + UFTag For Binary As #FF
        End If
        For b = 0 To NextNo
            If BestMatch(b) = A Then
                If DropSeqsToDisk = 1 And b > 0 Then
                    'grab the sequence off the disk
                    
                    UB = Len(StrainSeq(0))
                    StrainSeq(b) = String(UB, " ")
                    Pos = (b - 1) * (Len(StrainSeq(0))) + 1
                    Get #FF, Pos, StrainSeq(b)
                    
                End If
                If Len(StrainSeq(b)) = LS Then  'if it is a big alignment file then all but the first sequence or offloaded onto the disk
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
                If DropSeqsToDisk = 1 And b > 0 Then
                    StrainSeq(b) = ""
                End If
            End If
        Next b
        If DropSeqsToDisk = 1 Then
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextNo
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
'        XX = DSN
'        XX = UBound(MaskSeq)
XX = DSN
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
                             '1665 with 29 sections and new more focused seed finding
            'unmask all the seed sequences
            For x = 0 To NumSeeds
                If TraceA(x) <= UBound(MaskSeq) Then
                    MaskSeq(TraceA(x)) = 0
                End If
            Next x
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextNo
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                MaskSeq(Winner) = 1
                
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextNo
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextNo
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextNo
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX, FF2 As Long
    IncNumX = -1
    If DropSeqsToDisk = 1 Then
        FF2 = FreeFile
        Open "SequencesForSaving" + UFTag For Binary As #FF2
    End If
    For Y = 0 To NextNo
       
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            For Z = 0 To NextNo
                If MaskSeq(Z) = 2 Then
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        'grab the sequence off the disk
                        
                        UB = Len(StrainSeq(0))
                        StrainSeq(EList(Z)) = String(UB, " ")
                        Pos = (EList(Z) - 1) * (Len(StrainSeq(0))) + 1
                        Get #FF2, Pos, StrainSeq(EList(Z))
                        x = x
                    End If
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                
                    Put #FF, , StrainSeq(EList(Z))
                    If DropSeqsToDisk = 1 And EList(Z) > 0 Then
                        StrainSeq(EList(Z)) = ""
                    End If
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
    Y = 0
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then
            If DropSeqsToDisk = 1 Then
                If Y * Len(StrainSeq(0)) < 200000000 Or Y = 0 Then ' there may be enough room in memory to hold the sequences on disk
                                                                'load the sequences up - remember that regardless, Y=0 needs to be loaded up
                    UB = Len(StrainSeq(0))
                     StrainSeq(x) = String(UB, " ")
                     Pos = (x - 1) * (Len(StrainSeq(0))) + 1
                     Get #FF2, Pos, StrainSeq(x)
                End If
            End If
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    
    If DropSeqsToDisk = 1 Then
        
        Close #FF2
    End If
    
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    If BigFileFlag = 1 And DropSeqsToDisk = 1 Then
        If (NextNo + 1) * Len(StrainSeq(0)) < 200000000 Then 'will no longer need the bigfileflag. For mugsy the limit is 100Megs maybe change to 100megs
            BigFileFlag = 0
        End If
    End If
    
    
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub

Private Sub SplitThingsUp7()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1

Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long

Dim ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long

ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextNo + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others
'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
NumToExclude = (NextNo + 1) - MemPoc
NextnoBak = NextNo


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextNo
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x

For x = 0 To NextNo
    StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
    StrainSeq(x) = StrConv(StrainSeq(x), 1)
    Pos = 1
    Do While Pos > 0
        Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(StrainSeq(x), Pos, 1) = "T"
        Else
            Exit Do
        End If
    Loop
    For Y = 1 To 255
        If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
            Pos = 1
            Do While Pos > 0
                Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StrainSeq(x), Pos, 1) = "-"
                Else
                    Exit Do
                End If
            Loop
        End If
    Next
    SSS = Abs(GetTickCount)
    If Abs(SSS - LSSS) > 500 Then
        LSSS = SSS
        Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextNo)) + " sequences"
        DoEvents
    End If
    
Next x




If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextNo
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextNo
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextNo
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextNo
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextNo
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextNo
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



    Longest = 0
    For x = 0 To NextNo
        If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
    Next x
    
    For x = 0 To NextNo
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextNo
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextNo + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextNo + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 4 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    Do While A <= NumSeeds
        S1 = StrainSeq(Z)
        For x = 0 To NextNo
'            If Dist(A, x) <> 0 Then
'                x = x
'            End If
            If x <> Z And Dist(x, A) = 0 Then
                
                Valid(x) = 0
                Diffs(x) = 0
                '
                'If X = X Then
                    '@'@'@'@'@'@'@'@'@'@'@'@'@
'                    If x = 3214 Then
'                        x = x
'                        XX = Right(s1, 20)
'                        XX = Right(StrainSeq(x), 20)
'                    End If
                    If Len(S1) <> Len(StrainSeq(x)) Then
                        
                        If Len(StrainSeq(x)) < Len(S1) Then
                            StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                        End If
                    End If
                    If Len(S1) <> Len(StrainSeq(x)) Then
                        x = x
                    End If
                    Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                    
'                Else
'                    For Y = 1 To Len(StrainSeq(0))
'                        CharZ = Mid(StrainSeq(Z), Y, 1)
'                        If CharZ <> "-" Then
'                            CharX = Mid(StrainSeq(X), Y, 1)
'                            If CharX <> "-" Then
'                                Valid(X) = Valid(X) + 1
'                                If CharX <> CharZ Then
'                                    Diffs(X) = Diffs(X) + 1
'                                End If
'                            End If
'                        End If
'                    Next Y
'                End If
                If Valid(x) > 0 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                End If
            End If
            x = x
        Next x
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextNo
            ClosestTo(x) = NextNo
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        If A > NumSeeds Then
            '@'@'@'@'@'@
            If x = x Then
                Winner = -1
                Dummy = GetBestMatch(NextNo, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
            Else
                For x = 0 To NextNo
                    Lowest = NextNo
                    Winner = -1
                    For Y = 0 To NumSeeds
                        If Lowest > Dist(x, Y) Then
                            Lowest = Dist(x, Y)
                            BestMatch(x) = Y
                            
                        End If
                    Next Y
                Next x
            End If
            ReDim NIY(NumSeeds)
            For x = 0 To NextNo
                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
            Next x
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    NumSeeds = NumSeeds + 1
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then Exit Do
            '@
            ReDim Preserve Dist(NextNo, NumSeeds)
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        If A <= NumSeeds Then
            HighestDist = 0
            '@'@'@'@'@'@
            If x = x Then
               
                Dummy = GetClosestTo(CLng(A), NextNo, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                
            Else
                For Y = 0 To NextNo
                    If Done(Y) = 0 Then
                       
                        For x = 0 To A - 1
                            If Dist(Y, x) < ClosestTo(Y) Then
                                ClosestTo(Y) = Dist(Y, x)
                                
                            End If
                        Next x
                        
                    End If
                Next Y
            End If
            HighestDist = 0
            For Y = 0 To NextNo
                If Done(Y) = 0 Then
                    If HighestDist < ClosestTo(Y) Then
                        HighestDist = ClosestTo(Y)
                        Winner = Y
                    End If
                End If
            Next Y
            
            Z = Winner '116,106,113,86
            If Z = -1 Then
                NumSeeds = NumSeeds - 1
                Exit Do
            End If
            Done(Z) = 1
            TraceA(A) = Z
            'fill in the alerady calculated distances
            For x = 0 To A - 1
                Dist(TraceA(x), A) = Dist(Winner, x)
            Next x
        End If
    Loop
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    'find the clusters before

    'make backup of bestmatch
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextNo
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        Lowest = NumSeeds
        For x = 0 To NumSeeds - 1
            If Done(x) = 0 Then
                For Y = x + 1 To NumSeeds
                    If Done(Y) = 0 Then
                        If Lowest > Dist(TraceA(Y), x) Then
                            Lowest = Dist(TraceA(Y), x)
                            Winner = Y
                            Winner2 = x
                        End If
                    End If
                Next Y
            End If
        Next x
        If NIY(Winner2) + NIY(Winner) < MemPoc * MemPocMod Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextNo
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextNo - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partitiom
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextNo
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        Else
            If NIY(Winner2) > NIY(Winner) Then
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
            
        End If
        DoEvents
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    For x = 0 To NumSeeds
        If NIY(x) > 0 Then
            DSN = DSN + 1
            MapX(x) = DSN
            NIY(DSN) = NIY(x)
            
        Else
            x = x
        End If
    Next x
    
    ReDim Preserve NIY(DSN)
    For x = 0 To NextNo
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextNo
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    ReDim NumDTP(NextNo)
    
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A)), tSeqS(LS)
        C = -1
        For b = 0 To NextNo
            If BestMatch(b) = A Then
                If Len(StrainSeq(b)) = LS Then
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
            End If
        Next b
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextNo
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
        XX = DSN
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
            'unmask all the seed sequences
            For x = 0 To NumSeeds
                MaskSeq(TraceA(x)) = 0
            Next x
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextNo
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                MaskSeq(Winner) = 1
                
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextNo
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextNo
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim oDirX As String, DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextNo
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX As Long
    IncNumX = -1
    For Y = 0 To NextNo
       
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            For Z = 0 To NextNo
                If MaskSeq(Z) = 2 Then
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                    Put #FF, , StrainSeq(EList(Z))
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
   ' XX = CurDir
   XX = numadds '6618,5666
   XX = MaxEListLen
  ' XX = NewPos(3279)
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    Y = 0
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    For x = 0 To NextNo
'        If x = 20 Then
'            x = x
'        End If
        If MaskSeq(x) <> 2 Then
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub
Private Sub SplitThingsUp7messedup()
'This is where datasets with large numbers of sequenecs are handled
Dim x As Long, Y As Long, Z As Long, A As Long
'Form1.Enabled = False
'Form1.Enabled = True
LoadBusy = 1

Dim Pos As Long
'At this point all there is to workwith is nextno, strainseq and strainanme
'Everything needs to be done using the character strings

Dim NumDatasets As Long

Dim ClosestRelative() As Long, tSeqnum() As Integer, ClosestTo() As Single, Valid() As Long, Diffs() As Long, Dist() As Single, CharZ As String, CharX As String, TotD As Single, TraceA() As Long, NumAdded As Long
Dim CurA As Long, NumToRemove As Long, HighestDist As Single, LowestDist As Single, Winner As Long, Done() As Long, SubDataset() As Long, AlreadyAdded() As Long

ReDim SubDataset(NumDatasets, NextNo), AlreadyAdded(NextNo)


Dim Dataset() As Long, NumInDataset() As Long
'full ordered exclusion but remembering nearest relatives of those excluded
Dim NumToExclude As Long, NumSeeds As Long

NumSeeds = ((MemPoc ^ 2) / (NextNo + 1)) * 2 '1.25 'number of sequences for which pairwise distances will be calculated with all others
'If NumSeeds = 0 Then NumSeeds = 1
If NumSeeds < 10 Then NumSeeds = 10
If NumSeeds > NextNo Then NumSeeds = NextNo
NumToExclude = (NextNo + 1) - MemPoc
NextnoBak = NextNo


Dim MarkForRemoval() As Byte
ReDim MarkForRemoval(NextNo)

'need to make sure all the sequences are the same length
Dim Longest As Long, MaskSeq() As Long
ReDim MaskSeq(NextNo)
Longest = 0
For x = 0 To NextNo
    If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
Next x

For x = 0 To NextNo
    StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
    StrainSeq(x) = StrConv(StrainSeq(x), 1)
    Pos = 1
    Do While Pos > 0
        Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(StrainSeq(x), Pos, 1) = "T"
        Else
            Exit Do
        End If
    Loop
    For Y = 1 To 255
        If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
            Pos = 1
            Do While Pos > 0
                Pos = InStr(Pos, StrainSeq(x), Chr(Y), vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StrainSeq(x), Pos, 1) = "-"
                Else
                    Exit Do
                End If
            Loop
        End If
    Next
    SSS = Abs(GetTickCount)
    If Abs(SSS - LSSS) > 500 Then
        LSSS = SSS
        Form1.SSPanel1.Caption = "Unwanted characters stripped from " + Str(x) + " of " + Trim(Str(NextNo)) + " sequences"
        DoEvents
    End If
    
Next x




If x = x Then 'Mske strainame (i.e. the name with all bad characters removed and where no names are substrings of other names
        'XX = UBound(StrainSeq)
    ReDim StraiName(NextNo)
    For x = 0 To NextNo
        StraiName(x) = OriginalName(x)
    Next x
    For x = 0 To NextNo
            
        'Crop to 40 characters if longer
        If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
        
        'Replace Gaps in sequence names with "_"
        
        Do
            Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(StraiName(x), Pos, 1) = "_"
            Else
                Exit Do
            End If
        Loop
    Next x
    For Y = 0 To 5
        If Y = 0 Then
            RT = Chr(9)
            RW = " "
        ElseIf Y = 1 Then
            RT = "("
            RW = "{"
        ElseIf Y = 2 Then
            RT = ")"
            RW = "}"
        ElseIf Y = 3 Then
            RT = Chr(34)
            RW = " "
        ElseIf Y = 4 Then
            RT = ","
            RW = "_"
        ElseIf Y = 5 Then
            RT = "."
            RW = "_"
        End If
        For x = 0 To NextNo
            Do
                Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            StraiName(x) = Trim(StraiName(x))
            
        Next x
    Next Y
    
    'replace "'" characters in first position of sequence names (messes up geneconv)
    
    For x = 0 To NextNo
        If Left$(StraiName(x), 1) = "'" Then
            StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
        End If
    Next x
    
    
        '0.469 seconds for a 1100 sequence file
    'Tidy up any odd characters at the end of sequences
    
    'Tidy up unacceptable characters in sequence names
    For x = 0 To NextNo
        Do
            Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
            If Pos > 0 Then
                Mid(StraiName(x), Pos, 1) = " "
            Else
                Exit Do
            End If
        Loop
    Next x
    'Make sure sequence names are acceptable
    For x = 0 To NextNo
        If StraiName(x) = "" Then
            StraiName(x) = "S" + Str(x)
            'Exit Sub
        End If
        If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
            StraiName(x) = "SN" + StraiName(x)
        End If
    Next x
    
    'makes sure no names are nested within other names
    Call NameCheckX

    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If



    Longest = 0
    For x = 0 To NextNo
        If Longest < Len(StrainSeq(x)) Then Longest = Len(StrainSeq(x))
    Next x
    
    For x = 0 To NextNo
        If Len(StrainSeq(0)) < Longest Then
            StrainSeq(x) = StrainSeq(x) + String(Longest - Len(StrainSeq(0)), "-")
            StrainSeq(x) = StrConv(StrainSeq(x), 1)
        End If
    Next x




    
    
   
    Dim S1 As String
    Dim s2 As String
    SS = Abs(GetTickCount)
    
    
   
    ReDim OriginalPos(NextNo), FullOName(NextNo)
    For x = 0 To NextNo
        OriginalPos(x) = x
        FullOName(x) = OriginalName(x)
    Next x
    
    Dim SortedNo As Long, C As Long, tAV As Double, TU As Double, b As Long, NumSections As Long, TargetSeqs As Long, tSeqS() As Long, tRedo() As Integer, tPD() As Single, tPV() As Single, TD() As Single
    Dim DistMap() As Single, WinningX() As Long, tDB() As Single, XInstance() As Integer
    Dim TreeX() As Integer, TreeY() As Integer, NumX() As Long, Check() As Long, NodeYPos() As Integer
    Dim TreeDistance() As Single, PairSort() As Long, SeqLen() As Long
    Dim CR As Long, Winner2 As Long, SSBak() As Long, TDist() As Single
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'All this stuff needed for the fast recombination check2
    Dim XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
    Dim XoverWindow As Long, XOverWindowX As Integer
    XOverWindowX = 30
    XoverWindow = XOverWindowX / 2
    LenStrainSeq = Len(StrainSeq(0)) + 1
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(2)
    ReDim SpacerSeqs(2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    
    HWindowWidth = CLng(MCWinSize / 2)
    pHWindowWidth = HWindowWidth
    lHWindowWidth = HWindowWidth
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    'Dim Decompress() As Long
    '
    'XX = UBound(TreeRX, 1)
    
    'Work out how many pieces the dataset needs to be split into and how many sequences need to go into each section
    Dim MemPocMod As Single
    
    MemPocMod = 1 'use this to constrain the maximum seqnumber in a partition so that it is a proportion of mempoc
    NumSections = CLng(((NextNo + 1) / (MemPoc * MemPocMod)) + 0.5)
    TargetSeqs = CLng((NextNo + 1) / NumSections + 0.5)
    
    'Try to make it that the sequences in each section are all within a subtree of the big tree -
    'Need to resort the seqeunecs based on their similarity to a set of seed sequences
    
    NumSeeds = NumSections * 4 'this number of seeds hopefully ensure that it is possible to split dataset up neatly
    
    'pick the first sequence and calculate ham distance to all the rest
    'need to
    '(1) find the "numdatasets" number of sequences that best represent the diversity
    '(2) starting with the least unique sequence build aound each of these representative sequences
    ' a dataset including < mempoc/3 number of sequences
    'start with sequence 0
    ReDim Valid(NextNo), Diffs(NextNo), Dist(NextNo, NumSeeds), Done(NextNo), TraceA(NumSeeds)
     Z = 0
    Done(0) = 1
    TraceA(0) = 0
    Dim BestMatch() As Long, NIY() As Long
    ReDim BestMatch(NextNo), NIY(NumSeeds)
    SSSS = Abs(GetTickCount)
    Do While A <= NumSeeds
        S1 = StrainSeq(Z)
        
'        For x = 0 To Nextno
'            If StrainSeq(x) = String(Len(StrainSeq(0)), "-") Then
'                x = x
'            End If
'        Next x
        
        For x = 0 To NextNo
'            If Dist(A, x) <> 0 Then
'                x = x
'            End If
            If x <> Z And Dist(x, A) = 0 Then
                
                Valid(x) = 0
                Diffs(x) = 0
                '
                'If X = X Then
                    '@'@'@'@'@'@'@'@'@'@'@'@'@
'                    If x = 3214 Then
'                        x = x
'                        XX = Right(s1, 20)
'                        XX = Right(StrainSeq(x), 20)
'                    End If
                    If Len(S1) <> Len(StrainSeq(x)) Then
                        
                        If Len(StrainSeq(x)) < Len(S1) Then
                            StrainSeq(x) = StrainSeq(x) + String((Len(S1) - Len(StrainSeq(x))), "-")
                        End If
                    End If
                    
                    Dummy = StringDist(CLng(Len(StrainSeq(0))), x, Valid(0), Diffs(0), S1, StrainSeq(x))
                    
'                Else
'                    For Y = 1 To Len(StrainSeq(0))
'                        CharZ = Mid(StrainSeq(Z), Y, 1)
'                        If CharZ <> "-" Then
'                            CharX = Mid(StrainSeq(X), Y, 1)
'                            If CharX <> "-" Then
'                                Valid(X) = Valid(X) + 1
'                                If CharX <> CharZ Then
'                                    Diffs(X) = Diffs(X) + 1
'                                End If
'                            End If
'                        End If
'                    Next Y
'                End If
                If Valid(x) > 0 Then
                    Dist(x, A) = Diffs(x) / Valid(x) '3596,9373
                Else
                    Dist(x, A) = 1
                End If
            End If
            x = x
        Next x
        'find the sequence with the highest average distance to all others and choose that one as the next "A"
        ReDim ClosestTo(NextNo)
        For x = 0 To NextNo
            ClosestTo(x) = NextNo
        Next x
        
'        For x = 0 To Nextno
'            If Left(OriginalName(x), 8) = "MN683596" Then
'                x = x
'            End If
'        Next x
        
        
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(A) + " of " + Trim(Str(NumSeeds)) + " seed sequences found"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
        
        A = A + 1
        If A > NumSeeds Then
            '@'@'@'@'@'@
            If x = x Then
                Winner = -1
                Dummy = GetBestMatch(NextNo, CLng(NumSeeds), UBound(Dist, 1), Dist(0, 0), BestMatch(0))
            Else
                For x = 0 To NextNo
                    Lowest = NextNo
                    Winner = -1
                    For Y = 0 To NumSeeds
                        If Lowest > Dist(x, Y) Then
                            Lowest = Dist(x, Y)
                            BestMatch(x) = Y
                            
                        End If
                    Next Y
                Next x
            End If
            ReDim NIY(NumSeeds)
            For x = 0 To NextNo
                NIY(BestMatch(x)) = NIY(BestMatch(x)) + 1
            Next x
            For x = 0 To NumSeeds
                If NIY(x) > MemPoc * MemPocMod Then
                    NumSeeds = NumSeeds + 1
                    
                    
                    Exit For
                End If
            Next x
            If x = NumSeeds + 1 Then Exit Do
            '@
            ReDim Preserve Dist(NextNo, NumSeeds)
            ReDim Preserve TraceA(NumSeeds)
        End If
        
        If A <= NumSeeds Then
            HighestDist = 0
            '@'@'@'@'@'@
            If x = x Then
               
                Dummy = GetClosestTo(CLng(A), NextNo, UBound(Dist, 1), Done(0), ClosestTo(0), Dist(0, 0))
                
            Else
                For Y = 0 To NextNo
                    If Done(Y) = 0 Then
                       
                        For x = 0 To A - 1
                            If Dist(Y, x) < ClosestTo(Y) Then
                                ClosestTo(Y) = Dist(Y, x)
                                
                            End If
                        Next x
                        
                    End If
                Next Y
            End If
            HighestDist = 0
            
            'for y = 0 to next
            
            For Y = 0 To NextNo
                If Done(Y) = 0 Then
                    If ClosestTo(Y) < 1 Then
                        If HighestDist < ClosestTo(Y) Then
                            HighestDist = ClosestTo(Y)
                            Winner = Y
                        End If
                    End If
                End If
            Next Y
            
            Z = Winner '116,106,113,86
            If Z = -1 Then
                NumSeeds = NumSeeds - 1
                Exit Do
            End If
            If NumSeeds > MemPoc * 0.75 And x = 123456 Then
               Dim LoNIY As Long, LoseNIY As Long
               LoNIY = NextNo
               For x = 0 To A - 2
                    If NIY(x) < LoNIY Then
                        LoNIY = NIY(x)
                        LoseNIY = x
                    End If
               Next x
               If LoseNIY < A - 1 Then
                    For x = 0 To A - 1
                        Dist(TraceA(LoseNIY), x) = Dist(TraceA(A - 1), x)
                    Next x
                    TraceA(LoseNIY) = TraceA(A - 1)
                    NIY(LoseNIY) = NIY(A - 1)
                    A = A - 1
               End If
            End If
            Done(Z) = 1
            TraceA(A) = Z
            'fill in the alerady calculated distances
            For x = 0 To A - 1
                Dist(TraceA(x), A) = Dist(Winner, x)
            Next x
        End If
    Loop
    EE = Abs(GetTickCount)
    ttt = EE - SSSS '156.360,99.078
    'find the clusters before

    'make backup of bestmatch
    Dim BestMatchBak() As Long
    ReDim BestMatchBak(NextNo)
    For x = 0 To NextNo
        BestMatchBak(x) = BestMatch(x)
    Next x
    
    x = NumSeeds
    'find the most similar seeds and merge their sets trying to get between target and mempoc for a merged set size - anything in that range
    'will ensure that the different groups will be within the acceptable size range
    Lowest = NumSeeds
    Dim NTS As Long
    NTS = 0
    ReDim Done(NumSeeds)
    For Z = 0 To NumSeeds
        
        
        If x = x Then
            Dim W1(0) As Long, W2(0) As Long
            Lowest = NumSeeds
            Dummy = FindWinners(NumSeeds, UBound(Dist, 1), W1(0), W2(0), Done(0), TraceA(0), Dist(0, 0))
            x = x
            Winner = W1(0)
            winnwer2 = W2(0)
        Else
            Lowest = NumSeeds
            '@'@'@'@'@'@'@
            For x = 0 To NumSeeds - 1
                If Done(x) = 0 Then
                    
                    For Y = x + 1 To NumSeeds
                        If Done(Y) = 0 Then
                            If Lowest > Dist(TraceA(Y), x) Then
                                Lowest = Dist(TraceA(Y), x)
                                Winner = Y
                                Winner2 = x
                            End If
                        End If
                    Next Y
                End If
            Next x
        End If
        If NIY(Winner2) + NIY(Winner) < MemPoc * MemPocMod Then
            'merge then
            NIY(Winner2) = NIY(Winner2) + NIY(Winner)
            For A = 0 To NextNo
                If BestMatch(A) = Winner Then BestMatch(A) = Winner2
            Next A
            Done(Winner) = 1
            NIY(Winner) = 0
            If NIY(Winner2) >= TargetSeqs Then
                Done(Winner2) = 1
                NTS = NTS + NIY(Winner2)
                If (NextNo - NTS) <= TargetSeqs Then 'there sre few enough remianing sequences to construct the final partitiom
                    For x = 0 To NumSeeds
                        If Done(x) = 0 Then
                            'NIY(x) = 0
                            For Y = x + 1 To NumSeeds
                                If Done(Y) = 0 Then
                                    NIY(x) = NIY(x) + NIY(Y)
                                    NIY(Y) = 0
                                    For A = 0 To NextNo
                                        If BestMatch(A) = Y Then
                                            BestMatch(A) = x
                                            
                                        End If
                                    Next A
                                End If
                                
                            Next Y
                            Exit For
                        End If
                    Next x
                    Exit For
                End If
            End If
        Else
            If NIY(Winner2) > NIY(Winner) Then
                Done(Winner2) = 1
            Else
                Done(Winner) = 1
            End If
            
        End If
        DoEvents
        SSS = Abs(GetTickCount)
        If Abs(SSS - LSSS) > 500 Then
            LSSS = SSS
            Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(NumSeeds)) + " seed sequences merged"
            DoEvents
            'Form1.WindowState = Form1.WindowState
        End If
    
    Next Z
    x = x
    '''''''''''''''''''''''''''''''''''''''''''
    'reorder the sequences based on the sets they belong to
    ''''''''''''''''''''''''''''''''''''''''''
    Dim DSN As Long, DS() As Long, MapX() As Long
    DSN = -1
    ReDim MapX(NumSeeds)
    For x = 0 To NumSeeds
        If NIY(x) > 0 Then
            DSN = DSN + 1
            MapX(x) = DSN
            NIY(DSN) = NIY(x)
            
        Else
            x = x
        End If
    Next x
    
    ReDim Preserve NIY(DSN)
    For x = 0 To NextNo
        BestMatch(x) = MapX(BestMatch(x))
    Next x
    Highest = 0
    For x = 0 To DSN
        If Highest < NIY(x) Then
            Highest = NIY(x)
        End If
    Next x
    ReDim tRedo(Highest)
    For x = 0 To Highest
        tRedo(x) = 1
    Next x
    LS = Len(StrainSeq(0))
    ReDim Decompress(LS)
    For x = 0 To LS
        Decompress(x) = x
    Next x
    ReDim SeqLen(NextNo)
    ReDim MaskSeq(NextNo)
    ReDim ClosestRelative(NextNo)
    Dim MC As Variant
    
    MC = MemPoc
    MC = MC * (MemPoc + 1)
    MC = MC * (MemPoc - 1)
    MC = MC / 6
    
    MCCorrection = MC
    
    
    If MCCorrection > MaxAnalNo Then MCCorrection = MaxAnalNo
    
    MCCorrection = MCCorrection ' / 10
    
    
    UCThresh = LowestProb / MCCorrection
    
    For x = 0 To NextNo
        ClosestRelative(x) = -1
    Next x
    Dim MTN() As Long, MT As Long
    MT = 0
    ReDim MTN(NextNo, DSN)
    Dim MTNS2 As Long, MTNS1 As Long
    
    Dim DNode() As Byte
    Dim NDout As Long
    NDout = 0
    
    
    Dim SDA() As Single, SDAN() As Long, SDB() As Single, SDBN() As Long
    ReDim SDA(NextNo), SDAN(NextNo), SDB(NextNo), SDBN(NextNo)
'    For x = 0 To NextNo
'        SDA(x) = 1
'        SDB(x) = 1
'    Next x
    Dim DTHresh As Single, NumRemove As Long, NumRemain As Long
    NumRemove = 0
    Dim NumDTP() As Long
    ReDim NumDTP(NextNo)
    
    SSSS = Abs(GetTickCount)
    For A = 0 To DSN
    
        DTHresh = 0
        ReDim tSeqnum(LS, NIY(A)), tSeqS(LS)
        C = -1
        For b = 0 To NextNo
            If BestMatch(b) = A Then
                If Len(StrainSeq(b)) = LS Then
                    C = C + 1
                    MTN(C, A) = b
                    Dummy = CopyString(LS, tSeqnum(0, C), StrainSeq(b), tSeqS(0))
                    SeqLen(b) = LS - tSeqS(LS)
                End If
            End If
        Next b
        ReDim tPD(C, C), tPV(C, C), TD(C, C)
        
        
        
        Call FastDistanceCalcZ(0, 0, 1, LS, C, tPD(), tPV(), tSeqnum(), TD(), tAV, TU, tRedo())
        ReDim tDB(C, C)
        Dummy = MakeDistanceBakB(C, C, C, TD(0, 0), tDB(0, 0))
        ReDim DistMap(C), WinningX(C)
        Dummy = MakeDistMapX(C, DistMap(0), tDB(0, 0), WinningX(0))
        'now make a upgma (it will be encoded in treedist)
        SortedNo = 0
        ReDim TreeX(C, C), TreeY(C), Check(C), NodeYPos(C), XInstance(C + 1), TreeDistance(C, C), PairSort(1, C)
         '@
         For x = 0 To C

            For Y = 0 To C
                TreeX(x, Y) = -1
            Next 'Y
            
        Next 'X
        Do Until SortedNo = C
            ShortestDistance = ShortestDistB(C, SortedNo, DistMap(0), WinningX(0), tDB(0, 0), TreeX(0, 0), TreeY(0))
            'treex(sortedno,0) = x coord
            'treey(sortedno)=ycoord
            TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
            TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            Dummy = AddSeqToUPGMA(C, SortedNo, XInstance(0), tDB(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
            
            x = TreeX(SortedNo, 0)
            Z = TreeY(SortedNo)
            PairSort(0, SortedNo) = x
            PairSort(1, SortedNo) = Z
            DistMap(x) = 100
            DistMap(Z) = 100
            
            Dummy = UpdateDistMapX(x, Z, C, DistMap(0), tDB(0, 0), WinningX(0))
            
            SortedNo = SortedNo + 1
        Loop
        XX = UBound(TreeDistance, 1)
        
        'XX = tDB(0, 0)
        'XX = UBound(TreeDistance, 1)
        Dummy = TreeDist2(C, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
'        XX = TreeDistance(6, 9) '0.9938
'        XX = TreeDistance(0, 1) '0.8237346
'        XX = TreeDistance(1, 0)
'        XX = TreeDistance(0, 2) '0
'        XX = TreeDistance(2, 0) '0
'        XX = TreeDistance(0, 3) '0
'        XX = TreeDistance(0, 0) '0
'        XX = TreeDistance(1, 1) '0
        
        For x = 0 To C
            For Y = 0 To C
                TreeDistance(x, Y) = 1 - TreeDistance(x, Y)
            Next Y
        Next x
       
       
       'Find closest pair and do quick check for recombination with all others
        
        Dim DoneThisPair() As Integer
        ReDim DoneThisPair(C, C)
        Dim CSS() As Long
        ReDim CSS(1)
        Dim NPC As Long
        Dim BPVX As Double, BS3 As Long, NGO As Long, TD1Tot As Double, TD2Tot As Double
        NPC = 0
        
        Dim ColHigh() As Single
        ReDim ColHigh(C)
        Call MakeScanCompressArrays(C, tSeqnum())
        
        For x = 0 To C
            Highest = 0
            For Y = 0 To C
                If Highest < TD(x, Y) Then
                    Highest = TD(x, Y)
                End If
            Next Y
            ColHigh(x) = Highest
            x = x
        Next x
        Dim Highest2 As Single
        For Z = 0 To C - (200 / (DSN + 1))
            Highest = -1
            TD1Tot = 0
            TD2Tot = 0
            If x = x Then
                
                CSS(0) = 0 '785,501
                CSS(1) = 0
                Highest = GetHighest2(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), ColHigh(0), MaskSeq(0), DoneThisPair(0, 0))
'                Highest = GetHighest(C, A, CSS(0), UBound(MTN, 1), MTN(0, 0), TD(0, 0), MaskSeq(0), DoneThisPair(0, 0))
                Seq1 = CSS(0)
                Seq2 = CSS(1)
                NPC = NPC + 1
            Else
                Highest = 0
                For x = 0 To C
                    If MaskSeq(MTN(x, A)) = 0 Then
                        For Y = x + 1 To C
                            If MaskSeq(MTN(Y, A)) = 0 Then
                                If Highest < TD(x, Y) And DoneThisPair(x, Y) = 0 Then
                                    Highest = TD(x, Y)
                                    Seq1 = x
                                    Seq2 = Y
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            
            If Highest = 0 Then '
                Exit For
            End If
            
            BPVX = 100
            NGO = 0
            If Highest < 1 Then
                
                
                For x = 0 To C
                    '@
                    If MaskSeq(MTN(x, A)) < 2 Then
                        If x <> Seq1 And x <> Seq2 Then
                            GoOn = 0
                            Seq3 = x
                            GoOn = FastRecCheck(C, tSeqnum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                            x = x
                            If GoOn = 0 Then
                                '@'@'@
                                GoOn = FastRecCheck2(C, 0, 0, 0, tPD(), XDiffPos(), XPosDiff(), tSeqnum()) 'this is the maxchi check
                            x = x
                            End If
                            If GoOn = 1 Then
                                nrcf = nrcf + 1
                                NGO = NGO + 1
                                If BPVX > BQPV Then
                                    BPVX = BQPV
                                    BS3 = Seq3
                                End If
                                TD1Tot = TD1Tot + TD(Seq1, Seq3) 'keeps track which of the pair is on avergae most similar to seq3
                                TD2Tot = TD2Tot + TD(Seq2, Seq3) 'keeps track which of the pair is on average most similar to seq3
                                
                            End If
                            
                        End If
                    
                    End If
                
                Next x
                x = x
            
            End If
            If BPVX < 100 Then
                
                DoneThisPair(Seq1, Seq2) = 1
                DoneThisPair(Seq2, Seq1) = 1
                If NGO = 1 Then 'if only one sequence is a suitable s3 for the current pair it means this sequence is likely the recombinant
                    MaskSeq(MTN(BS3, A)) = 3
                    
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = Seq2
                    
                    'If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                    x = BS3
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    If TD1Tot > TD2Tot Then
                        MaskSeq(MTN(Seq1, A)) = 3
                        Highest = 0
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    Else
                        
                        MaskSeq(MTN(Seq2, A)) = 3
                        Highest = 0
                        x = Seq2
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                        x = Seq1
'                        If x = x Then
                             Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                        Else
'                            For Y = 0 To C
'                                If MaskSeq(MTN(Y, A)) = 0 Then
'                                    If ColHigh(Y) = TD(x, Y) Then
'                                        Highest = 0
'                                        For ZZ = 0 To C
'                                            If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                                Highest = TD(ZZ, Y)
'
'                                            End If
'                                        Next ZZ
'                                        ColHigh(Y) = Highest
'                                    End If
'                                End If
'                            Next Y
'                        End If
                    End If
                End If
                
                
            Else
            
                'mask the shorter of seq1 and seq2
'                If MTN(Seq2, A) = 2132 Or MTN(Seq1, A) = 2132 Then
'                    x = x
'                End If
                If SeqLen(MTN(Seq1, A)) >= SeqLen(MTN(Seq2, A)) Then
                    MaskSeq(MTN(Seq2, A)) = 2
                    Highest = 0
                    x = Seq2
                    
'                    If x = x Then
                        Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                Else
                    MaskSeq(MTN(Seq1, A)) = 2
                    Highest = 0
                    x = Seq1
'                    If x = x Then
                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
'                    Else
'                        For Y = 0 To C
'                            If MaskSeq(MTN(Y, A)) = 0 Then
'                                If ColHigh(Y) = TD(x, Y) Then
'                                    Highest = 0
'                                    For ZZ = 0 To C
'                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
'                                            Highest = TD(ZZ, Y)
'
'                                        End If
'                                    Next ZZ
'                                    ColHigh(Y) = Highest
'                                End If
'                            End If
'                        Next Y
'                    End If
                End If
                NumRemove = NumRemove + 1
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                Form1.SSPanel1.Caption = Str(NumRemove) + " sequence pairs with no evidence of recombination"
                DoEvents
            End If
        Next Z
        Y = 0
        For x = 0 To C
            If MaskSeq(MTN(x, A)) <> 2 And MaskSeq(MTN(x, A)) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        NumRemain = Y
        
        For x = 0 To C
            'If MaskSeq(MTN(x, A)) = 2 Then
                For Y = 0 To C
                     'remember that in TD "1" is identical
                    If x <> Y Then
                        If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If TD(x, Y) > SDA(MTN(x, A)) Then
                                SDA(MTN(x, A)) = TD(x, Y)
                                SDAN(MTN(x, A)) = MTN(Y, A)
                                
                            End If
                        
                        End If
                    End If
                Next Y
                
                'need to do all the closestrelatives
                
            x = x
            'End If
        Next x
        '@
        If NumRemain > (200 / (DSN + 1)) And x = 12345678 Then
            For x = 0 To C
                For Y = x + 1 To C
                    
                    NumDTP(MTN(x, A)) = NumDTP(MTN(x, A)) + DoneThisPair(x, Y)
                    NumDTP(MTN(Y, A)) = NumDTP(MTN(Y, A)) + DoneThisPair(x, Y)
                Next Y
            Next x
            
            For x = 0 To C
    '            If MTN(x, A) = 2132 Or MTN(x, A) = 5535 Or MTN(x, A) = 2200 Then
    '                x = x
    '            End If
                If MaskSeq(MTN(x, A)) = 0 Then
                    If NumDTP(MTN(x, A)) = 0 Then '23,33,39,42,55,62,66
                         MaskSeq(MTN(x, A)) = 2
                         NumRemain = NumRemain - 1
                         If NumRemain <= (200 / (DSN + 1)) Then
                         
                            Exit For
                         End If
    '                     Highest = 0
    '                    If x = x Then
    '                         Dummy = UpdateColHigh(A, C, x, UBound(MTN, 1), MTN(0, 0), MaskSeq(0), ColHigh(0), UBound(TD, 1), TD(0, 0), UBound(DoneThisPair, 1), DoneThisPair(0, 0))
    '                    Else
    '                        For Y = 0 To C
    '                            If MaskSeq(MTN(Y, A)) = 0 Then
    '                                If ColHigh(Y) = TD(x, Y) Then
    '                                    Highest = 0
    '                                    For ZZ = 0 To C
    '                                        If Highest < TD(ZZ, Y) And DoneThisPair(ZZ, Y) = 0 And MaskSeq(MTN(ZZ, A)) = 0 And Y <> ZZ Then
    '                                            Highest = TD(ZZ, Y)
    '
    '                                        End If
    '                                    Next ZZ
    '                                    ColHigh(Y) = Highest
    '                                End If
    '                            End If
    '                        Next Y
    '                    End If
                    End If
                End If
            Next x
        End If
        For x = 0 To C
            Highest = 0
            If MaskSeq(MTN(x, A)) = 2 Or MaskSeq(MTN(x, A)) = 4 Then
                For Y = 0 To C
                      If MaskSeq(MTN(Y, A)) <> 2 And MaskSeq(MTN(Y, A)) <> 4 Then
                            If Highest < TD(x, Y) Then
                                Highest = TD(x, Y)
                                ClosestRelative(MTN(x, A)) = MTN(Y, A)
                            End If
                            
                      End If
                Next Y
                x = x
            End If
        Next x
        
        x = x
    Next A
    eeee = Abs(GetTickCount)
    tttt = eeee - SSSS '192.485 using findsubseqp 1485
                        '174.218 using finsubseqpb 1485
                        '156.781 using colhigh
                        '148.265 using updatecolhigh
                        '142.797 using findsubseqmcpb
                        '129.375 with finsubseqpb2
                        '120.421 with cleanXOSNW
                        '127.640
                        '83.84 with just fastreccheck2
                        '41.265 with just fastcheck
                        '92 with both fastreccheck 1 and 2 but with 6 sections (instead of 4)
                        '65.812 with both fastreccheck 1 and 2 but with 8 sections (instead of 4)
                        '28.219 with 18 sections
                        '69.547
                        
    x = x
'    XX = MaskSeq(577) '2
'    XX = MaskSeq(1319)
'    XX = MaskSeq(4090)
'    XX = ClosestRelative(577)
'    XX = ClosestRelative(1319)
'    XX = ClosestRelative(4090)
'    XX = MaskSeq(ClosestRelative(577)) '2
'    XX = MaskSeq(ClosestRelative(1319))
'    XX = MaskSeq(ClosestRelative(4090))
'    XX = SDA(577): XX = SDAN(577)
'     XX = SDA(1319): XX = SDAN(1319)
'      XX = SDA(4090): XX = SDAN(4090)
'    XX = OriginalName(6148)cr=6147
'    XX = OriginalName(2371)cr=1210
'    XX = OriginalName(1310)cr=1323
'    XX = MaskSeq(1323)
'    XX = ClosestRelative(1310) '
    EE = Abs(GetTickCount)
'    XX = SDA(1310)
'    XX = SDAN(1310)
    TT = EE - SS '161141 for 7309 sequences
    XX = NextNo
    XX = nrcf
   ' XX = Dist(1, 20)
    'XX = Dist(10, 1000)
   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
   'This is where I can addback up to mempoc sequences if necessary (or mask sequences if the number is over mempoc)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'How many unmasked sequences are left?
    If x = x Then
        Y = 0
        For x = 0 To NextNo
            If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                 Y = Y + 1
            End If
        Next x
        
        Dim DSM As Long
        'MemPoc = 1000
        '899 with just fastreccheck2
'        XX = DSN
'        XX = UBound(MaskSeq)
        If Y < NumSeeds Then '2502 with fastreccheck alone
                             '898 with fastreckcheck2 alone
                             '2491 with fastreccheck and fastreccheck2
                             '2256 with fastreccheck and fastreccheck2 and 8 sections
                             '1697 with 18 sections
            'unmask all the seed sequences
            For x = 0 To NumSeeds
                If TraceA(x) <= UBound(MaskSeq) Then
                    MaskSeq(TraceA(x)) = 0
                End If
            Next x
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            
            
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
        ElseIf Y < MemPoc * 0.25 Then
            For x = 0 To NextNo
                If ClosestRelative(x) = -1 Then
                    MaskSeq(TraceA(BestMatchBak(x))) = 0
                    ClosestRelative(x) = TraceA(BestMatchBak(x))
                End If
            Next x
            Y = 0
            For x = 0 To NextNo
                If MaskSeq(x) <> 2 And MaskSeq(x) <> 4 Then
                     Y = Y + 1
                End If
            Next x
            x = x
        End If
        If Y > MemPoc * 0.75 - 1 Then 'MemPoc - 1 Then
            DSM = Y - (MemPoc * 0.75)
            For x = 1 To DSM
                Highest = 0
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) <> 2 And MaskSeq(Z) <> 4 Then
                        If Highest < SDA(Z) Then
                            Highest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
    '            If Winner = 793 Or Winner2 = 793 Then
    '                x = x
    '            End If
                If Winner = -1 Then Exit For
                MaskSeq(Winner) = 2
    '            If MaskSeq(Winner2) = 2 Then
    '                x = x
    '            End If
                ClosestRelative(Winner) = Winner2
                
                For Z = 0 To NextNo
                    If Z <> Winner2 Then
                        If ClosestRelative(Z) = Winner Then
                            ClosestRelative(Z) = Winner2
                            'XX = SDBN(Winner2)
                            'xx=xlosestrelative(winner)
                        End If
                        If SDAN(Z) = Winner Then
                            
                            SDAN(Z) = Winner2
                        End If
                    End If
                Next Z
                If SDAN(Winner2) = Winner Then
                    SDA(Winner2) = 0
                End If
                'SDB(Winner2) = 0
            Next x
        ElseIf Y < MemPoc * 0.5 - 1 Then
            DSM = (MemPoc * 0.5) - Y
            For x = 1 To DSM
                Lowest = 1
                Winner = -1
                Winner2 = -1
                For Z = 0 To NextNo
                    If MaskSeq(Z) = 2 Then
                        If Lowest > SDA(Z) Then
                            Lowest = SDA(Z)
                            Winner = Z
                            Winner2 = SDAN(Z)
                        End If
                    End If
                Next Z
                MaskSeq(Winner) = 1
                
            Next x
        End If
    End If
    NN = 0
    For x = 0 To NextNo
    
    
    
        If MaskSeq(x) = 2 Then
            If ClosestRelative(x) > -1 Then
                If MaskSeq(ClosestRelative(x)) = 2 Then
                    x = x
                ElseIf ClosestRelative(x) = -1 Then
                    x = x
                End If
            Else
                x = x
                MaskSeq(x) = 0
                NN = NN + 1
            End If
        End If
    Next x
    
    'XX = MaskSeq(3428)
    'Now get the number of sequences up to mempoc-1
    
    
    For x = 0 To NextNo
        If MaskSeq(x) = 4 Then
             MaskSeq(x) = 2
        End If
    Next x
    'Save sequences to disk in order of their closest relatives'
    
    'make a map of sequence positions in final file
    
     x = x
   ' Lowest = 10000 ' = 0
    
    'XX = MaskSeq(584)
    'XX = ClosestRelative(584)
    'XX = MaskSeq(582)
    Dim NewPos() As Long
    ReDim NewPos(NextNo)
    sureins = 0
    Y = -1
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then
             Y = Y + 1
             NewPos(x) = Y
             If MaskSeq(x) = 1 Then
                sureins = sureins + 1
             End If
        'ElseIf MaskSeq(x) = 1 Then
            'sureins = sureins + 1
        End If
    Next x
    
 '5060 with mc/10k
 '4540 with mc/1k
 '4124 with mc/100
 '3745 with mc/10
 '3474 with mc
 '3213 with mc and knot removal
'   x = x
'   Lowest = 10000 ' = 0
'   For x = 0 To NextNo
'        If MaskSeq(x) = 0 Then
'            If NumDTP(x) <= Lowest Then
'                x = x
'                Lowest = NumDTP(x)
'            End If
'        End If
'   Next x
'   x = x
    
    
    
    FF = FreeFile
    Dim oDirX As String, DiscardNum As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    DiscardNum = 0
    MaxEListLen = 0
    Open "RDP5ExcludeList" + UFTag For Binary As FF
    DoExcludes = 1
    Dim EList() As Long, EListNum As Long, Unmasked As Long
    Unmasked = 0
    For x = 0 To NextNo
        If MaskSeq(x) <> 2 Then Unmasked = Unmasked + 1
    Next x
    
    ReDim ExcludeCoords(Unmasked + 5)
    numadds = 0
    NumToExclude = NextNo
    ReDim WhereIsExclude(NextNo)
    For x = 0 To NextNo
        WhereIsExclude(x) = x
    Next x
    Dim IncNumX As Long
    IncNumX = -1
    For Y = 0 To NextNo
       
        If MaskSeq(Y) <> 2 Then
             IncNumX = IncNumX + 1
            ReDim EList(NumToExclude * 2)
            EListNum = 0
            For Z = 0 To NextNo
                If MaskSeq(Z) = 2 Then
                    If ClosestRelative(Z) = Y Then
                         EListNum = EListNum + 1
                         EList(EListNum) = Z
                         WhereIsExclude(Z) = IncNumX
                         'OriginalPos(z) = x
                    End If
                End If
            Next Z
            'This is where you could late test to make sure this is an appropriate list
            If EListNum > 0 Then
                If MaxEListLen < EListNum Then MaxEListLen = EListNum
                Pos = Seek(FF)
                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
                '3428 (793,213),5883 (2601,727),1947 (359,93), *3279 (3279,869), 6659(2460,689)
                Put #FF, , EListNum
                For Z = 1 To EListNum
                    numadds = numadds + 1
'                    If OriginalPos(EList(Z)) = 3428 Or OriginalPos(EList(Z)) = 5883 Or OriginalPos(EList(Z)) = 1947 Or OriginalPos(EList(Z)) = 3279 Or OriginalPos(EList(Z)) = 6659 Then
'                        x = x
'                        XX = NewPos(Y)
'                    End If
                    DiscardNum = DiscardNum + 1
                    Put #FF, , CLng(Y)
                    Put #FF, , OriginalPos(EList(Z))
                    Put #FF, , DiscardNum
                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
                    Put #FF, , OriginalName(EList(Z))
                    Put #FF, , CLng(Len(StraiName(EList(Z))))
                    Put #FF, , StraiName(EList(Z))
                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
                    Put #FF, , StrainSeq(EList(Z))
                Next Z
            Else
                ExcludeCoords(NewPos(Y)) = -1
            End If
        End If
    Next Y
   ' XX = CurDir
   XX = numadds '6618,5666
   XX = MaxEListLen
  ' XX = NewPos(3279)
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    Y = 0
    
    ReDim EventsInExcludeds(5, 1000)
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    For x = 0 To NextNo
'        If x = 20 Then
'            x = x
'        End If
        If MaskSeq(x) <> 2 Then
            StrainSeq(Y) = StrainSeq(x)
            OriginalName(Y) = OriginalName(x)
            OriginalPos(Y) = x
            Y = Y + 1
        End If
    Next x
    NextNo = Y - 1
    ReDim Preserve StrainSeq(NextNo)
    ReDim Preserve OriginalName(NextNo)
    ReDim MaskSeq(NextNo)
    
    Form1.Enabled = True
    LoadBusy = 0
    Exit Sub

End Sub




Public Sub DataFeed()
Dim x As Long, Y As Long, FF As Long, A As Long, b As Long
JumpInFlag = 1
FF = 100
oDirX = CurDir
ChDrive App.Path
ChDir App.Path




Dim tOriginalname() As String, LongestN As Long, tDaught() As Byte, tMajorpar() As Byte, tMinorpar() As Byte, tMaskseq() As Integer, tXoverlist() As XOverDefine, tBestxolistmi() As XOverDefine, ElementX As XOverDefine, tBestxolistma() As XOverDefine, tNopini() As Long, tSeventnumber As Long, tEventnumber As Long
Dim tBestevent() As Long, tSupereventlist() As Long, tDscores() As Double
Dim tConfirm() As Integer, tConfirmMi() As Integer, tConfirmMa() As Integer
Dim tConfirmp() As Double, tConfirmpMi() As Double, tConfirmpMa() As Double
Dim tSteps() As Long, tBpcis() As Long
Dim tStepno As Long
Dim tCurrentxover() As Long, tBcurrentxoverma() As Long, tBcurrentxovermi() As Long
ReDim tDscores(25, 2, 0)
ReDim tCurrentxover(NextnoBak), tBcurrentxovermi(NextnoBak), tBcurrentxoverma(NextnoBak)

ReDim tSteps(4, 0) 'second element is stepno
ReDim tBpcis(9, 0) 'second element is seventnumber

ReDim tXoverlist(NextnoBak, 0), tBestxolistmi(NextnoBak, 0), tBestxolistma(NextnoBak, 0)

ReDim tNopini(2, 0)
ReDim tMaskseq(NextnoBak)
ReDim tSupereventlist(0)
ReDim tMajorpar(NextnoBak), tMinorpar(NextnoBak), tDaught(NextnoBak)
ReDim tOriginalname(NextnoBak)
ReDim tDaught(NextnoBak, 0), tMajorpar(NextnoBak, 0), tMinorpar(NextnoBak, 0)

tSeventnumber = 0
tEventnumber = 0
For x = 0 To DatasetNumber
    If SeqnumCoords(x, 1) <> 0 Then
        ReDim OriginalName(NumInDataset(x))
        ReDim PermOriginalName(NumInDataset(x))
        ReDim StraiName(NumInDataset(x))
        ReDim StrainSeq(NumInDataset(x))
        NextNo = NumInDataset(x)
        For Y = 0 To NumInDataset(x)
            OriginalName(Y) = OriginalNameBak(Dataset(x, Y))
            PermOriginalName(Y) = OriginalName(Y)
            StraiName(Y) = StraiNameBak(Dataset(x, Y))
            StrainSeq(Y) = StrainSeqBak(Dataset(x, Y))
        Next Y
        
        'save stuff for later retrieval'
        
        Call GetDatasetPerms(x)
        
        Call PutPerms
        Call Command22_Click
        'process everything
        
        ReDim Preserve tXoverlist(NextnoBak, UBound(tXoverlist, 2) + UBound(XoverList, 2))
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            
            For Y = 1 To CurrentXOver(Z)
                tXoverlist(A, Y + tCurrentxover(A)) = XoverList(Z, Y)
                tXoverlist(A, Y + tCurrentxover(A)).Daughter = Dataset(x, tXoverlist(A, Y + tCurrentxover(A)).Daughter)
                tXoverlist(A, Y + tCurrentxover(A)).MajorP = Dataset(x, tXoverlist(A, Y + tCurrentxover(A)).MajorP)
                tXoverlist(A, Y + tCurrentxover(A)).MinorP = Dataset(x, tXoverlist(A, Y + tCurrentxover(A)).MinorP)
                tXoverlist(A, Y + tCurrentxover(A)).Eventnumber = tXoverlist(A, Y + tCurrentxover(A)).Eventnumber + tEventnumber
            Next Y
        Next Z
        ReDim Preserve tBestxolistmi(NextnoBak, UBound(tBestxolistmi, 2) + UBound(BestXOListMi, 2))
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            For Y = 1 To BCurrentXoverMi(Z)
                tBestxolistmi(A, Y + tBcurrentxovermi(A)) = BestXOListMi(Z, Y)
                tBestxolistmi(A, Y + tBcurrentxovermi(A)).Daughter = Dataset(x, tBestxolistmi(A, Y + tBcurrentxovermi(A)).Daughter)
                tBestxolistmi(A, Y + tBcurrentxovermi(A)).MajorP = Dataset(x, tBestxolistmi(A, Y + tBcurrentxovermi(A)).MajorP)
                tBestxolistmi(A, Y + tBcurrentxovermi(A)).MinorP = Dataset(x, tBestxolistmi(A, Y + tBcurrentxovermi(A)).MinorP)
                tBestxolistmi(A, Y + tBcurrentxovermi(A)).Eventnumber = tBestxolistmi(A, Y + tBcurrentxovermi(A)).Eventnumber + tEventnumber
            Next Y
        Next Z
        ReDim Preserve tBestxolistma(NextnoBak, UBound(tBestxolistma, 2) + UBound(BestXOListMa, 2))
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            For Y = 1 To BCurrentXoverMa(Z)
                tBestxolistma(A, Y + tBcurrentxoverma(A)) = BestXOListMa(Z, Y)
                tBestxolistma(A, Y + tBcurrentxoverma(A)).Daughter = Dataset(x, tBestxolistma(A, Y + tBcurrentxoverma(A)).Daughter)
                tBestxolistma(A, Y + tBcurrentxoverma(A)).MajorP = Dataset(x, tBestxolistma(A, Y + tBcurrentxoverma(A)).MajorP)
                tBestxolistma(A, Y + tBcurrentxoverma(A)).MinorP = Dataset(x, tBestxolistma(A, Y + tBcurrentxoverma(A)).MinorP)
                tBestxolistma(A, Y + tBcurrentxoverma(A)).Eventnumber = tBestxolistma(A, Y + tBcurrentxoverma(A)).Eventnumber + tEventnumber
            Next Y
        Next Z
        
        For Y = 0 To NextNo
            tCurrentxover(Dataset(x, Y)) = tCurrentxover(Dataset(x, Y)) + CurrentXOver(Y)
            tBcurrentxovermi(Dataset(x, Y)) = tBcurrentxovermi(Dataset(x, Y)) + BCurrentXoverMi(Y)
            tBcurrentxoverma(Dataset(x, Y)) = tBcurrentxoverma(Dataset(x, Y)) + BCurrentXoverMa(Y)
        Next Y
        ReDim Preserve tNopini(2, UBound(tNopini, 2) + UBound(NOPINI, 2))
'        For Z = 0 To Nextno
'            For Y = 1 To CurrentXOver(Z)
'                If SuperEventList(XOverlist(Z, Y).Eventnumber) = 2 Then '14=4,15=4,16=4,18=5,2=1,9=3(3,2),10=3(3,3),11=3(3,4),12=3, 3=2(4,1),4=2,5=2,7=2,8=2
'                    'dataset(x,3) = 12
'                    'dataset(x,4) = 16
'                    'XX = Dataset(X, 4)
'                    X = X
'                End If
'            Next Y
'        Next Z
        
        
        For Z = 1 To SEventNumber
            A = Z + tSeventnumber
            For Y = 0 To 2
                tNopini(Y, A) = NOPINI(Y, Z)
            Next Y
        Next Z
        
        ReDim Preserve tDscores(25, 2, UBound(tDscores, 3) + UBound(DScores, 3))
        For Z = 1 To SEventNumber
            A = Z + tSeventnumber
            For Y = 0 To 2
                For b = 0 To 25
                    tDscores(b, Y, A) = DScores(b, Y, Z)
                Next b
            Next Y
        Next Z
        ReDim Preserve tSupereventlist(UBound(tSupereventlist, 1) + UBound(SuperEventList, 1))
        'XX = Eventnumber
        For Z = 1 To UBound(SuperEventList)
            A = Z + tEventnumber
            If SuperEventList(Z) > 0 Then
                tSupereventlist(A) = SuperEventList(Z) + tSeventnumber '20=6,21=6,22=6,23=6
                x = x
                
'            ElseIf tSeventnumber > 0 Then
'                tSeventnumber = tSeventnumber - 1
            End If
        Next Z
'        For Z = 0 To Nextno
'            For Y = 1 To CurrentXOver(Z)
'                If tSupereventlist(XOverlist(Z, Y).Eventnumber) = 6 Then
'                    X = X
'                    XX = Dataset(X, 4)
'                End If
'            Next Y
'        Next Z
        'XX = SuperEventList(14)
        'XX = tSupereventlist(14)
        ReDim Preserve tDaught(NextnoBak, UBound(tDaught, 2) + UBound(Daught, 1)) 'remember I switched the dimensions so that I could redim preserve
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            For Y = 1 To SEventNumber
                b = Y + tSeventnumber
                tDaught(A, b) = Daught(Y, Z)
            Next Y
        Next Z
        ReDim Preserve tMinorpar(NextnoBak, UBound(tMinorpar, 2) + UBound(MinorPar, 1)) 'remember I switched the dimensions so that I could redim preserve
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            For Y = 1 To SEventNumber
                b = Y + tSeventnumber
                tMinorpar(A, b) = MinorPar(Y, Z)
            Next Y
        Next Z
        ReDim Preserve tMajorpar(NextnoBak, UBound(tMajorpar, 2) + UBound(MajorPar, 1)) 'remember I switched the dimensions so that I could redim preserve
        For Z = 0 To NextNo
            A = Dataset(x, Z)
            For Y = 1 To SEventNumber
                b = Y + tSeventnumber
                tMajorpar(A, b) = MajorPar(Y, Z)
            Next Y
        Next Z
        
        'Put #FF, , BestEvent() 'need to make bestevent with makebestevent at the end - it cannot be redimmed
        'Put #FF, , Confirm()'need to at at the end - first dim is eventnumber
'        Put #FF, , ConfirmP() '
'        Put #FF, , ConfirmMi() '
'        Put #FF, , ConfirmPMi() '
'        Put #FF, , ConfirmMa() '
'        Put #FF, , ConfirmPMa() '
        
 '       Put #FF, , StepNo
 
        ReDim Preserve tSteps(4, tStepno + UBound(Steps, 2))
        For Z = 0 To StepNo
            A = Z + tStepno
            For Y = 0 To 4
                tSteps(Y, A) = Steps(Y, Z)
            Next Y
        Next Z
        
        ReDim Preserve tBpcis(9, UBound(tBpcis, 2) + UBound(BPCIs, 2))
        For Z = 0 To UBound(BPCIs, 2)
            A = Z + tSeventnumber
            For Y = 0 To 9
                tBpcis(Y, A) = BPCIs(Y, Z)
            Next Y
        Next Z
        
        tSeventnumber = tSeventnumber + SEventNumber
        tEventnumber = tEventnumber + Eventnumber
        tStepno = tStepno + StepNo
        
        
    End If
Next x


'Close #FF
'ChDrive oDirX
'ChDir oDirX

JumpInFlag = 0
PermNextno = NextnoBak
NextNo = NextnoBak

'Now replace all the actual arrays with their tversions
ReDim OriginalName(NextNo)
ReDim PermOriginalName(NextNo)
ReDim StraiName(NextNo)
For x = 0 To NextNo
    OriginalName(x) = OriginalNameBak(x)
    PermOriginalName(x) = OriginalNameBak(x)
    StraiName(x) = StraiNameBak(x)
Next x


ReDim Daught(SEventNumber, NextNo), MinorPar(SEventNumber, NextNo), MajorPar(SEventNumber, NextNo), uDaught(SEventNumber, NextNo)

For x = 0 To SEventNumber
    For Y = 0 To NextNo
        Daught(x, Y) = tDaught(Y, x)
        uDaught(x, Y) = tDaught(Y, x)
        MinorPar(x, Y) = tMinorpar(Y, x)
        MajorPar(x, Y) = tMajorpar(Y, x)
    Next Y
Next x

ReDim CurrentXOver(NextNo)
ReDim XoverList(NextNo, UBound(tXoverlist, 2))
For x = 0 To NextNo
    CurrentXOver(x) = tCurrentxover(x)
    For Y = 1 To tCurrentxover(x)
        XoverList(x, Y) = tXoverlist(x, Y)
    Next Y
Next x

ReDim BCurrentXoverMi(NextNo)
ReDim BestXOListMi(NextNo, UBound(tBestxolistmi, 2))
For x = 0 To NextNo
    BCurrentXoverMi(x) = tBcurrentxovermi(x)
    For Y = 1 To tBcurrentxovermi(x)
        BestXOListMi(x, Y) = tBestxolistmi(x, Y)
    Next Y
Next x
ReDim BCurrentXoverMa(NextNo)
ReDim BestXOListMa(NextNo, UBound(tBestxolistma, 2))
For x = 0 To NextNo
    BCurrentXoverMa(x) = tBcurrentxoverma(x)
    For Y = 1 To tBcurrentxoverma(x)
        BestXOListMa(x, Y) = tBestxolistma(x, Y)
    Next Y
Next x
Eventnumber = tEventnumber
SEventNumber = tSeventnumber
StepNo = tStepno
ReDim SuperEventList(Eventnumber)
For x = 0 To Eventnumber
    SuperEventList(x) = tSupereventlist(x)
'    If X = 20 Then
'        X = X
'    End If
Next x
'XX = Dataset(1, 4)
Call MakeBestEvent

'otherthings that neee to be sorted out above
'sequence names
ReDim Preserve SeqCol(NextNo)
ReDim Preserve FFillCol(NextNo)
ReDim Preserve PrintCharLen(NextNo)
For x = 0 To NextNo
    PrintCharLen(x) = Len(OriginalName(x))
Next x

'needed for integratexovers
ReDim ShowAllHits(NextNo)
ReDim Preserve OriginalName(NextNo)

Call IntegrateXOvers(1)
End Sub


Private Sub ReassortmentMarker(tTYF As Double, XConA As Double)
 Dim PolyPoints() As POINTAPI
Dim SeqFeaturemap2() As Byte, XX1 As Long, XX2 As Long, XX3 As Long, X1 As Long, X2 As Long, Y1 As Long, x As Long, Y As Long, LineBottom As Long
LineBottom = Picture13.ScaleHeight
ReDim SeqFeaturemap2(-2 To Len(StrainSeq(0)) * 2)
For x = 1 To RBPNum
    SeqFeaturemap2(RBPPos(x)) = 40
Next x

ReDim PolyPoints(5)
For x = -2 To PrintSeqLen + 2
    
    If SeqFeaturemap2(WinLeft + x) = 40 Then 'segment boundary
            XX1 = ((x - 2) * 8 + 6) * tTYF * XConA
            XX2 = ((x) * 8 + 6) * tTYF * XConA
            XX3 = ((x + 2) * 8 + 6) * tTYF * XConA
            For Y = XX1 To XX3
                SEPosMap(Y) = GeneNumber + 3
            Next Y
            
            Y1 = 0
            Y2 = LineBottom
            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 * 0.66
            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 * 0.66
            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
            
            Form1.Picture13.FillStyle = 0
            Form1.Picture13.FillColor = RGB(190, 190, 190)
            Form1.Picture13.ForeColor = RGB(160, 160, 160)
            '@
            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
        
    End If
Next x
End Sub

Private Sub DoP13Stuff(tTYF As Double)
    'Dim XX1 As Long, XX2 As Long, XX3 As Long, Y1 As Long, Y2 As Long, X As Long, Y As Long
    
    Dim YOff As Long, XX1 As Long, XX2 As Long, XX3 As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, Y As Long, Z As Long, DS As Long, ES As Long, LineBottom As Long, LineTop As Long, X3 As Long
    Dim GoOn As Long, UB As Long, xBak As Long, x As Long, FSX As Single, TL As Long, C As Long, Target As Long, GG As Long

    
    
    Dim PolyPoints() As POINTAPI, PAP As POINTAPI
    'dim LineBottom As Long, LineTop As Long
    
    'Dim TL As Integer, FSX As Integer
    FSX = Form1.Picture1.FontSize
    If FSX > 10 Then
        TL = 5
    ElseIf FSX > 6 Then
        TL = 10
    ElseIf FSX > 3 Then
        TL = 20
    Else
        TL = 50
    End If
    
    LineBottom = Picture13.ScaleHeight
    LineTop = LineBottom - 2
    '@
    Picture13.FillColor = BackColours
    Picture13.ForeColor = BackColours
    Picture13.FillStyle = 0
    
    
    If OnlyDoPositionIndicator = 0 Then
        Rectangle Picture13.hdc, 0, 0, Picture13.ScaleWidth, Picture13.ScaleHeight
    End If
    
    
    '        XX = Picture13.Width
    '        XX = Picture13.ScaleWidth
        If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
            Dim ColbumpX As Long
            ReDim SEPosMap(-100 To Form1.Picture13.ScaleWidth * 4)
            If ReassortmentFlag = 1 Then
                'mark segmant boundaries on seqfeaturemap
                Call ReassortmentMarker(tTYF, XConA)
            
            End If
                
            
                
                
                ReDim PolyPoints(5)
            If ORFFlag = 1 Then
                For x = -2 To PrintSeqLen + 2
                    
                    If WinLeft + x <= UBound(SeqFeatureTrace, 1) Then
                        ColbumpX = ColBump(SeqFeatureTrace(WinLeft + x))
                        If SeqFeatureMap(WinLeft + x) = 20 Or SeqFeatureMap(WinLeft + x) = 35 Then 'start of exon in - ori
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                        ElseIf SeqFeatureMap(WinLeft + x) = 22 Then 'start of exon in + ori
                            XX1 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            For Y = XX2 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX1: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 230, 64)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                        ElseIf SeqFeatureMap(WinLeft + x) = 24 Then 'start of exon in - ori
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                    ElseIf SeqFeatureMap(WinLeft + x) = 26 Then  'end of exon in - ori (donor)
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 230, 64)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                           
                    ElseIf SeqFeatureMap(WinLeft + x) = 1 Then
                            
                            
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 3.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3 '25:375-383
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(128, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 6 Then
                            
                            
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            
                            For Y = XX1 To XX3 '24:369-375
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 164, 164)
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 9 Then
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X)
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 1)
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 2)
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX = LBound(SEPosMap, 1)
                            For Y = XX1 To XX3 '26:755-763
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            '@
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(128, 255, 128)
                            
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 10 Then
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX2: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 164, 164)
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        
                        End If
                    End If
                Next x
                Form1.Picture13.ForeColor = 0
            End If
           
            
            If DebuggingFlag < 2 Then On Error Resume Next
            
            UB = UBound(RememberBPs, 2)
            
            On Error GoTo 0
            'If X = X Then ' OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
                If (RelX > 0 Or RelY > 0) And UB > 0 Then
                    Dim BPPos As Long, WLPS As Long, TriCol As Long
                    WLPS = WinLeft + PrintSeqLen
                    
                    For Z = NumberBPs To 0 Step -1 ' just makes sur that the "main event" is done last
                        xBak = RememberBPs(1, Z) - CLng((AddNum - 2) / 2)
                        BPPos = RememberBPs(0, Z)
                        If RememberBPs(1, Z) >= AddNum Then
                            TriCol = ProgcolourB((RememberBPs(1, Z) - AddNum))
                        Else
                            TriCol = ProgcolourB(RememberBPs(1, Z))
                        End If
                        If BPPos > WinLeft And BPPos < WLPS And TriCol <> 0 Then
                            x = BPPos - WinLeft
                            x = (x * 8 + 6) * tTYF * XConA
                            If Z <= 1 Then
                                    
                               
                                
                                Picture13.DrawWidth = 1
                                Picture13.FillStyle = 0
                                
                                Picture13.FillColor = P13BPFC(0)
                                Picture13.ForeColor = P13BPFC(1)
                                PolyPoints(0).x = x - 5 + xBak: PolyPoints(0).Y = LineTop - 10
                                PolyPoints(1).x = x + xBak: PolyPoints(1).Y = LineBottom - 4
                                PolyPoints(2).x = x + 5 + xBak: PolyPoints(2).Y = LineTop - 10
                                PolyPoints(3).x = x - 5 + xBak: PolyPoints(3).Y = LineTop - 10
                                Polygon Form1.Picture13.hdc, PolyPoints(0), 3
                                
                                Picture13.DrawWidth = 1
                                Picture13.FillStyle = 1
                                
                                Picture13.ForeColor = ProgColour(rBP) 'RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                PolyPoints(0).x = x - 5 + xBak: PolyPoints(0).Y = LineTop - 10
                                PolyPoints(1).x = x + xBak: PolyPoints(1).Y = LineBottom - 4
                                PolyPoints(2).x = x + 5 + xBak: PolyPoints(2).Y = LineTop - 10
                                PolyPoints(3).x = x - 5 + xBak: PolyPoints(3).Y = LineTop - 10
                                Polygon Form1.Picture13.hdc, PolyPoints(0), 3
                                BPFlashed = 1
                                'Picture13.Line ((X * 8 + 6) * tTYF * XConA - 9, LineTop - 15)-((X * 8 + 6) * tTYF * XConA, LineBottom - 4), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                'Picture13.Line ((X * 8 + 6) * tTYF * XConA, LineBottom - 4)-((X * 8 + 6) * tTYF * XConA + 9, LineTop - 15), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                'Picture13.Line ((X * 8 + 6) * tTYF * XConA + 9, LineTop - 15)-((X * 8 + 6) * tTYF * XConA - 9, LineTop - 15), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                Picture13.DrawWidth = 1
                                Picture13.ForeColor = 0
                                Picture13.FillStyle = 1
                                GoOn = 1
                            Else
                                Picture13.Line (x - 5 + xBak, LineTop - 10)-(x + xBak, LineBottom - 4), TriCol
                                Picture13.Line (x + xBak, LineBottom - 4)-(x + 5 + xBak, LineTop - 10), TriCol
                                Picture13.Line (x + 5 + xBak, LineTop - 10)-(x - 5 + xBak, LineTop - 10), TriCol
                            End If
                        End If
                    Next Z
                    p1TTYF = tTYF
                End If
            'End If
            '@
             
           'Picture13.FillStyle = 1
            Picture13.ForeColor = 0
            Pict = Picture13.hdc
            Dim OS As String, TX As Single, LV As Single, DC As Long
            DC = Decompress(Len(StrainSeq(0)))
            TX = tTYF * XConA
            LV = (LineTop * VAddjust) - (16 * VAddjust)
            'If X = X Then
                '@
                For x = 0 To PrintSeqLen
                    '@
                    YCon = WinLeft + x
                    If YCon <= DC Then
                        
                        X3 = (x * 8 + 6) * TX
                        
                        If (YCon) / TL = Int((YCon) / TL) Then
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                            '@
                            
                            Dummy = MoveToEx(Pict, X3, LineTop - 2, PAP)
                            Dummy = LineTo(Pict, X3, LineBottom)
                            '@
                            'Picture13.Refresh'
                            '@'@'@
                            C = (Picture13.TextWidth(Trim$(CStr(YCon)))) / 2
                            X3 = X3 - C
                            'Y1 = (LineTop * VAddjust) - (16 * VAddjust)
                            
                            OS = Trim$(CStr(YCon))
                            '@'@
                            
                            Picture13.ForeColor = BackColours
                            Pict = Picture13.hdc
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
'
                            Picture13.ForeColor = 0
                            Pict = Picture13.hdc
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                            
                        Else
                            '@
                            Dummy = MoveToEx(Pict, X3, LineTop, PAP)
                            
                            Dummy = LineTo(Pict, X3, LineBottom)
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
        
                    Else
                        Exit For
                    End If
        
                Next 'X
            'End If
            
        Else
            Form1.Picture13.ForeColor = 0
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(MCXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 * XConA + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF * XConA - (Picture13.TextWidth(Trim$(CStr(Decompress(MCXDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(MCXDiffPos) Then Picture13.Print Decompress(MCXDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(GCXDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(GCXDiffPos) Then Picture13.Print Decompress(GCXDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                Else
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(SSSubSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(CXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            Else
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(XOverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Form1.Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Form1.Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Form1.Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Form1.Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then
                                Form1.Picture13.Print Decompress(XDiffPos(WinLeft + x))
                                x = x
                            End If
                        Else
                            'XX = Form1.Picture13.AutoRedraw
                            'Form1.Picture13.ScaleMode = 3
                            Form1.Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            'Form1.Picture13.Refresh
'                            Form1.Picture13.CurrentY = 50
'                            Form1.Picture13.CurrentX = 50
'                            Form1.Picture1.ForeColor = 0
'                            Form1.Picture13.Print "10000000000"
'                            X = X
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            End If
        End If
End Sub

Private Sub SaveAASeqs()
Dim Response As Long, Response2 As Long, UB As Long, StripOLFlag As Long, RealignFlag As Long, StripPartFlag As Long, AName As String
 On Error Resume Next
        UB = -1
        UB = UBound(OverlapList, 1)
        On Error GoTo 0
        If UB = -1 Then Call MakeOverlapList
        If GenesWithOverlaps(CurGeneNo) = 1 Then
            Response = MsgBox("You should note that nucleotides within some of the codons in " + GeneList(CurGeneNo).Name + " are expressed in two different frames. If you are intending to use the saved gene alignment to analyse natural selection using dN/dS based approaches you should discard these codons. Would you like to save only the codon positions in " + GeneList(CurGeneNo).Name + " that do not overlap with codon positions in other genes?", vbYesNo)
            '6=yes, 7=no
            If Response = 6 Then
                StripOLFlag = 1
            Else
                StripOLFlag = 0
            End If
        End If
        
        Response = MsgBox("Would you like to separate out portions of the gene that have potentially been aquired from different parents following recombination? It would be a good idea to do this if, for example, you are intending to use the codon alignment to detect positive selection using dN/dS based methods", vbYesNo)
        '6=yes, 7=no
        If Response = 6 Then
            AccountREcombFlag = 1
        Else
            AccountREcombFlag = 0
        End If
        RealignFlag = 1
'        Response = MsgBox("Would you like me to save codon alignments of the gene sequences (I will realign the codons using Muscle)?", vbYesNo)
'        '6=yes, 7=no
'        If Response = 6 Then
'            RealignFlag = 1
'        Else
'            RealignFlag = 0
'        End If
        StripPartFlag = 1
        Response = MsgBox("Would you like me to strip stop codons and partial codons from the saved alignment?", vbYesNo)
        '6=yes, 7=no
        If Response = 6 Then
            StripPartFlag = 1
        Else
            StripPartFlag = 0
        End If
        With Form1.CommonDialog1
            .FileName = ""
            .DefaultExt = "fas"
            .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
            .FilterIndex = 1
            .Action = 2 'Specify that the "open file" action is required.
            AName = .FileName  'Stores selected file name in the
            ANameII = .FileTitle
            
        End With
        If AccountREcombFlag = 1 And SEventNumber = 0 Then
            Call Command22_Click
        End If
        Call SaveGeneAlignment(AName, CurGeneNo, StripOLFlag, RealignFlag, StripPartFlag, AccountREcombFlag, 0, 0)
End Sub
Private Sub MakeP7Tooltip(r As Long, g As Long, b As Long)

Dim CP As Long

Picture7.ToolTipText = ""
If ManFlag = -1 Then
    If CurrentCheck = -1 Then
        CP = XoverList(RelX, RelY).ProgramFlag
        If CP > AddNum Then CP = CP - AddNum
        If CP = 8 Then
            If r = g And g = b And r < 128 Then
                
                Picture7.ToolTipText = "Random walk height variable - should reach maximum or minimum value near a breakpoint position"
            End If
        
        
        ElseIf CP = 5 Then
            If (r = 5 And g = 5 And b = 5) Or (r = 255 And g = 5 And b = 5) Then
                
                Picture7.ToolTipText = "Upper Z-score threshold equivalent to a p-value = 0.05"
            ElseIf (r = 6 And g = 6 And b = 6) Or (r = 255 And g = 6 And b = 6) Then
                
                Picture7.ToolTipText = "Lower Z-score threshold equivalent to a p-value = 0.05"
            ElseIf (r = g And r = b And r < 100) Then
                Picture7.ToolTipText = "Z-score = 0"
            End If
        ElseIf CP = 1 Then
            If r = 1 And g = 1 And b = 1 Then
                
                Picture7.ToolTipText = "Multiple testing corrected KA-like p-value = 0.05"
            End If
        ElseIf CP = 2 Then
        
            
               If r = 1 And g = 1 And b = 1 Then
                    Picture7.ToolTipText = "Bootstrap support threshold"
               End If
        ElseIf CP = 3 Or CP = 4 Then
            If r = 1 And g = 1 And b = 1 Then
                Picture7.ToolTipText = "Multiple testing corrected Chi squared p-value = 0.05"
            ElseIf r = 2 And g = 2 And b = 2 Then
                Picture7.ToolTipText = "Uncorrected Chi squared p-value = 0.05"
            ElseIf r = g And r = b And r < 100 Then
                Picture7.ToolTipText = "Chi-square p-value plot"
            
            End If
        End If
    Else
        If r = 1 And g = 1 And b = 1 Then
                
                    
            If CurrentCheck = 9 Then 'topal
                Picture7.ToolTipText = "99% of DSS scores are expected to be below this bound in the absense of recombination"
            ElseIf CurrentCheck = 1 Then
               
                Picture7.ToolTipText = "Multiple testing corrected KA-like p-value = 0.05"
            ElseIf CurrentCheck = 2 Or CurrentCheck = 3 Then
               
                Picture7.ToolTipText = "Bootstrap support threshold"
            ElseIf CurrentCheck = 4 Or CurrentCheck = 10 Then
               
                Picture7.ToolTipText = "Multiple testing corrected Chi squared p-value = 0.05"
                
            
            End If
        ElseIf r = 2 And g = 2 And b = 2 Then
            If CurrentCheck = 4 Or CurrentCheck = 10 Then
               
                Picture7.ToolTipText = "Uncorrected Chi squared p-value = 0.05"
                
            ElseIf CurrentCheck = 9 Then
                Picture7.ToolTipText = "95% of DSS scores are expected to be below this bound in the absense of recombination"
            End If
        ElseIf (r = 5 And g = 5 And b = 5) Or (r = 255 And g = 5 And b = 5) Then
            If CurrentCheck = 9 Then
                Picture7.ToolTipText = "Upper Z-score threshold equivalent to a p-value = 0.05"
            End If
        ElseIf (r = 6 And g = 6 And b = 6) Or (r = 255 And g = 6 And b = 6) Then
            If CurrentCheck = 9 Then
                Picture7.ToolTipText = "Lower Z-score threshold equivalent to a p-value = 0.05"
            End If
        End If
    End If
Else
    Picture7.ToolTipText = ""
End If


End Sub
Private Sub hscroll1_changeOld2()

Dim PolyPoints() As POINTAPI, Response As Long, xBak As Long, UB3 As Long, UB2 As Long, GoOn As Long, SEN As Long, Z As Long, num As Long, UB As Long, MinParPos As Long, Overhang As Long, Mu As Long, Kx As Long, Kh As Long, NF As Long, oDir As String, oDirX As String, FF As Long
Dim X0 As String, X1 As String, X2 As String, X3 As Long, PAP As POINTAPI
Dim Pict4 As Long
Dim Pict4SH As Long
If PermNextno <= 0 Then Exit Sub
If HScroll1.Value < HScroll1.Min And PermNextno > 0 Then
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        If HScroll1.Max > 0 Then
            HScroll1.Value = HScroll1.Min + 1
            Exit Sub
        End If
    End If
End If

If DontRedoQuickDistFlag = 1 Then
    Exit Sub
End If
Form1.Timer3.Enabled = True
Form1.Timer3.Interval = 2000
'445628


If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If sHSCroll1Down = 0 Then
    sHSCroll1Down = Abs(GetTickCount)
    HSCrollInc = 1
End If
If CurrentlyRunningFlag = 1 Then
    Exit Sub
End If
'XX = Decompress(Len(StrainSeq(0)))
If NextNo <> PermNextno Then UnModNextno





Dim RecompX As Long
If F2ontop = 1 Then
    
    'ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - Form1.VScroll2.Value)
    Form1.Enabled = True
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(ProxButton, ProxShift, ProxX, ProxY)
    DontPutForm2Ontop = 0
    Form1.Enabled = False
    'F2ontop = 0
End If
'432616
If NextNo = 0 Then Exit Sub
ReDim Preserve PltCol3(15)
'If F1MDF = 1 Then Exit Sub
    'Call SaveAncSeq_Click
    If AncSeqFlag = 0 And LastAncSeqFlag = 1 Then
        VScroll3.Height = HScroll1.Top - VScroll3.Top - 4 * Screen.TwipsPerPixelX
        
        
        Picture8.Height = VScroll3.Height
        
        Picture9.Height = VScroll3.Height
        
        'Picture1.Height = Picture9.Height
        
        Picture22.Visible = False
    Else
        LastAncSeqFlag = 1
    End If
    
    SSS = Abs(GetTickCount)
    'this gets rid of the cursor on the sequence display
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -20
        ltPosX = -20
    End If
    'Command3.SetFocus
    Dim FS As Double, SLen As Long, Pict As Long, x As Long, Y As Long, LineBottom As Long, LineTop As Long, LastY As Long, CountHits As Long
    Dim P1 As Integer, P2 As Integer, A As Integer, C As Integer, g As Integer, T As Integer, S As Integer
    Dim tTYF As Double, TYFM As Integer, Test As String
    'tTYF = 0.45
    If DontRefreshP1 = 1 Then
        
        Exit Sub
    End If
    '@
    ReDim Output(PermNextno + 2)
    
    'If the current selection is not an RDP derived result then don't print
    'reference sequences
    
    
    SLen = UBound(Decompress, 1)
    If TYF = 0 Then TYF = 1
    If P1FontSize <> 0 Then
        
        Picture1.FontSize = P1FontSize * TYF
    End If
    If PermNextno < PermNextno Then
        UnModNextno
    End If
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -1
        ltPosX = -1
        '@
        ReDim SeqLines(5, PermNextno * 3), SeqText(PermNextno + 2): NumSeqLines = 0: NumSeqText = 0
    End If
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        
    
    '432616
    'tTYF = tTYF * 1.08
    PrintSeqLen = MakePrintSeqLen '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G"))
    'XX = Form1.Picture1.TextWidth("C") * WinLeft
    If RunFlag = 1 Then
        If AllowExtraSeqsFlag = 0 Then
            If XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then SpacerNo = 0
        End If
    End If

    If RLFlag = 1 Then
        On Error GoTo UnknownFormat
    End If

    'Picture1.Picture = LoadPicture() 'Clears picture
    Overhang = Int(PrintSeqLen - (SLen - (0.99 * SLen))) - 1
    'OverHang = 0

    Dim THold As Long

    'THold = HScroll1.Value
    XX = WinLeft
    If Decompress(Len(StrainSeq(0))) - (PrintSeqLen - 5) > HScroll1.Max And DontDoH1Inc = 0 Then 'Len(StrainSeq(0)) - (PrintSeqLen - 5)
        If HScroll1.Value >= HScroll1.Min Then
            If HScroll1.Value = HScroll1.Min + 1 And LastH1Val = HScroll1.Min Then
                H1M = -HScroll1Mod + 1
                 LastH1Dir = 1 'right movement
            ElseIf HScroll1.Value = HScroll1.Max And LastH1Val = HScroll1.Max - 1 Then
                H1M = H1M + 1
            ElseIf HScroll1.Value = HScroll1.Max - 1 And LastH1Val = HScroll1.Max Then
                H1M = H1M - 1
                
                 LastH1Dir = 2 'left
            Else
                If LastH1Val < HScroll1.Value Then
                    H1M = H1M + HSCrollInc
                    LastH1Dir = 1 'right movement
                ElseIf LastH1Val > HScroll1.Value Then
                    H1M = H1M - HSCrollInc
                    LastH1Dir = 2 'left movement
                End If
            End If
            If H1M >= HScroll1Mod Then
                If HScroll1.Value = HScroll1.Max Then
                    H1M = HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Max - 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            ElseIf H1M <= -HScroll1Mod Then
                
                If HScroll1.Value < HScroll1.Min Then
                    H1M = -HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Min + 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            Else
                H1C = 1 'this stops the hscroll updating
                
                
                If HScroll1.Value > HScroll1.Min And LastH1Dir = 1 And LastH1Val > HScroll1.Min Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 1 Then
                    HScroll1.Value = HScroll1.Value + 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 2 Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value < HScroll1.Max - 1 And LastH1Dir = 2 Then
                    'HScroll1.Value = HScroll1.Value + 1
                    'HScroll1.Value = HScroll1.Value - 1
                End If
                
                LastH1Val = HScroll1.Value
                H1C = 0
            End If
        Else
            
            LastH1Val = 0
        End If
    Else
        If Decompress(Len(StrainSeq(0))) - (PrintSeqLen - 5) > HScroll1.Max Then
            If HScroll1.Value = 1 Then
                H1M = -HScroll1Mod + 1
            End If
        Else
            H1M = 0
        End If
    End If
    If HScroll1.Value = HScroll1.Min Then
        LastH1Val = HScroll1.Min
        If Decompress(Len(StrainSeq(0))) > HScroll1.Max Then
            'If HScroll1.Value = 1 Then
                H1M = -HScroll1Mod + 1
            'End If
        End If
    End If
    If HScroll1.Value = HScroll1.Max Then
        LastH1Val = HScroll1.Max
        
    End If
    THold = HScroll1.Value
    XX = HScroll1.Value
    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
        WinLeft = THold * HScroll1Mod + H1M
    Else

        If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
            WinLeft = (THold * (Len(MCXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            WinLeft = (THold * (Len(GCXOverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            WinLeft = (THold * (Len(SSSubSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
            WinLeft = (THold * (Len(CXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
            WinLeft = (THold * (Len(PPXOSeq(0)) / SLen)) * HScroll1Mod
        Else
            WinLeft = (THold * (Len(XOverSeq(0)) / SLen)) * HScroll1Mod
        End If

    End If
'432620
    If PermNextno < 0 Then PermNextno = 0

    If WinLeft < 1 Then
        WinLeft = 1
    End If
    Picture1.ScaleMode = 3
    Picture1.CurrentX = 0
    Picture1.CurrentY = 0
    'Set up text output
    
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If AncSeqFlag = 1 Then
            Dim TestString As String, PrintString As String, ColWid As Double, ColCol As Long, MaxY As Long, MinY As Long, StartX, EndY, StartY
            
            Form1.Picture22.AutoRedraw = True
            Form1.Picture22.BackColor = Form1.Picture1.BackColor
            Form1.Picture22.Font = Form1.Picture1.Font
            Form1.Picture22.FontSize = Form1.Picture1.FontSize
            Form1.Picture22.CurrentX = 0
            Form1.Picture22.CurrentY = 0
            
            
            'draw bars
            TestString = String(PrintSeqLen, "A")
            ColWid = Picture22.TextWidth(TestString)
            ColWid = ColWid / PrintSeqLen
            Dim TH As Single, Ya As Single
            TH = Picture22.TextHeight("A") '- 1
            Ya = tTYF * Screen.TwipsPerPixelY
            'draw the sequence blocks
            For Y = 0 To 26 Step 13
                If Y = 0 Then
                    PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
                ElseIf Y = 13 Then
                    PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
                Else
                    PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
                End If
                
                
                For x = 1 To PrintSeqLen
                    'For Y = 0 To nruns
                    If x + WinLeft <= Len(StrainSeq(0)) Then
                        If x + WinLeft < UBound(AncPVals, 2) Then
                            StartX = (x - 1) * ColWid
                            If Mid$(PrintString, x, 1) = "A" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 128, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "C" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 255, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "G" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 128, 255), BF
                            ElseIf Mid$(PrintString, x, 1) = "T" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 255, 128), BF
                            End If
                        End If
                        'Next Y
                        
                        
                    End If
                Next x
                
                Form1.Picture22.CurrentX = 0
                Form1.Picture22.CurrentY = Y * tTYF * Screen.TwipsPerPixelY
                Form1.Picture22.Print PrintString
            Next Y
            
    '        'Write the sequences
    '        PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '        PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.CurrentY = 13 * tTYF * Screen.TwipsPerPixelY
    '        Form1.Picture22.Print PrintString
    '        Form1.Picture22.CurrentY = 26 * tTYF * Screen.TwipsPerPixelY
    '        PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '
    '
            
            
            
            'ColWid = ColWid / (nruns + 1)
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            For x = 0 To PrintSeqLen
                'For Y = 0 To nruns
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    If x + WinLeft < UBound(AncPVals, 2) Then
                        StartX = x * ColWid '+ Y * ColWid
                        EndY = AncPVals(0, x + WinLeft) * MaxY
                        If AncPVals(0, x + WinLeft) > 0.95 Then
                            Form1.Picture22.ForeColor = RGB(0, 0, 255)
                        ElseIf AncPVals(0, x + WinLeft) > 0.75 Then
                            Form1.Picture22.ForeColor = RGB(0, 255, 0)
                        Else
                            Form1.Picture22.ForeColor = RGB(255, 0, 0)
                        End If
                    End If
                    'Next Y
                    Form1.Picture22.Line (StartX + 10, MinY)-(StartX + ColWid, StartY + EndY), , BF
                    
                End If
            Next x
            MinY = MinY + MaxY + 50
            MaxY = Picture22.Height - MinY - 100 'MinY + ((Picture22.Height) - MinY) / 2
            'MaxY = MaxY / 2
            For x = 0 To PrintSeqLen
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    StartX = x * ColWid
                    EndY = 0
                    StartY = MinY
                    For Y = 1 To 4
                        
                            If x + WinLeft < UBound(AncPVals, 2) Then
                                EndY = (AncPVals(Y, x + WinLeft) * (MaxY))
                                If Y = 1 Then
                                    Form1.Picture22.ForeColor = RGB(255, 128, 128)
                                ElseIf Y = 2 Then
                                    Form1.Picture22.ForeColor = RGB(128, 255, 128)
                                ElseIf Y = 3 Then
                                    Form1.Picture22.ForeColor = RGB(128, 128, 255)
                                ElseIf Y = 4 Then
                                    Form1.Picture22.ForeColor = RGB(255, 255, 128)
                                End If
                            End If
                            'Next Y
                            If EndY >= 0 Then
                                Form1.Picture22.Line (StartX + 10, StartY)-(StartX + ColWid, StartY + EndY), , BF
                            Else
                                EndY = 0
                            End If
                            StartY = StartY + EndY
                    Next Y
                End If
            Next x
            
            Form1.Picture22.ForeColor = Form1.Picture1.BackColor
            Form1.Picture22.Line (Picture9.Width - 10, 0)-(Picture22.Width, Picture22.Height), , BF
            Form1.Picture22.ForeColor = 0
            
            
            'Draw Axes and Key
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            'Axes
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 10, StartY + MaxY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 60, MinY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY + (StartY + MaxY - MinY) / 2)-(Picture9.Width + 60, MinY + (StartY + MaxY - MinY) / 2)
            Form1.Picture22.Line (Picture9.Width + 10, StartY + MaxY)-(Picture9.Width + 60, StartY + MaxY)
            
            Form1.Picture22.Font = Picture3.Font
            Form1.Picture22.FontSize = Form1.Picture3.FontSize
            'Draw sequence labels
            
            'P3.CurrentY = -VSV + (X + 1) * 13 * tTYF
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = 2 * Screen.TwipsPerPixelY
            
            Form1.Picture22.Print "Max. parsimony"
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = (13 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.Print "Max. likelihood"
            Form1.Picture22.CurrentY = (26 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.Print "Bayesian"
            
            
            
            
            
            If Picture22.FontSize < 6 Then Picture22.FontSize = 6
            If Picture22.FontSize > 10 Then Picture22.FontSize = 10
            
            
            
            'Do Tick labels
            Mu = Picture22.TextHeight("O") / 2
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu: Form1.Picture22.Print "0.0"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu + (StartY + MaxY - MinY) / 2: Form1.Picture22.Print "0.5"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = StartY + MaxY - Mu: Form1.Picture22.Print "1.0"
            
            'Draw keys
            Kx = Picture9.Width + 80 + Form1.Picture22.TextWidth("0.0") + 280
            Kh = Form1.Picture22.TextHeight("0.0")
            
            'Form1.Picture22.Print (kx, MinY + (MaxY - MinY) / 2 - mu)-(kx + kh, MinY + (MaxY - MinY) / 2 - mu + kh), RGB(0, 255, 0), BF
            Form1.Picture22.FontSize = Form1.Picture22.FontSize - 1
            Form1.Picture22.CurrentX = Kx
            Form1.Picture22.CurrentY = MinY + ((StartY + MaxY - MinY) - Picture22.TextWidth("Prob.")) / 2 - Mu * 0.5
            
            
            Call DoText(Form1.Picture22, Form1.Picture22.Font, "Prob.", 270)
            
            Kx = Picture9.Width + 80
            Kh = Form1.Picture22.TextHeight("0.0") / 1.5
            MaxY = MaxY + 100
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu)-(Kx + Kh, StartY + MaxY + Mu + Kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx, StartY + MaxY + mu * 2 + kh)-(kx + kh, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu)-(kx + kh + 500, StartY + MaxY + mu + kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu * 2 + kh)-(kx + kh + 500, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "A"
            
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh, StartY + MaxY + Mu * 2 + Kh * 2), RGB(128, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "C"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu)-(Kx + Kh + 500, StartY + MaxY + Mu + Kh), RGB(128, 128, 255), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "G"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh + 500, StartY + MaxY + Mu * 2 + Kh * 2), RGB(255, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "T"
            
            
            Form1.Picture22.Refresh
            Form1.Picture22.Visible = True
        End If
    End If
    
 '432596
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If ShowSeqFlag = 0 Then
            
            If (WinLeft + PrintSeqLen) > UBound(Decompress, 1) Then ReDim Preserve Decompress(WinLeft + PrintSeqLen)
            If Decompress(WinLeft) = WinLeft And (Decompress(WinLeft + PrintSeqLen) = WinLeft + PrintSeqLen Or Decompress(WinLeft + PrintSeqLen) = 0) Then
                For x = 0 To PermNextno
                    '@
                    If x <= UBound(StrainSeq, 1) Then
                        Output(x) = Mid$(StrainSeq(x), WinLeft, PrintSeqLen)
                    End If
                Next
            Else
                ' reads the full sequence from file
                    NF = FreeFile
                    Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                    
                    ReadLen = PrintSeqLen * (NextNo + 1)
                    ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                    FileSeqString = String(ReadLen, " ")
                     oDir = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "RDP5Longseq" + UFTag For Binary As #NF
                        Get #NF, ReadStart, FileSeqString
                    Close #NF
                     
                    ChDrive oDir
                    ChDir oDir
                    'reconfigure and add to output
                    For x = 0 To PermNextno
                        Output(x) = String(PrintSeqLen + 1, " ")
                    Next x
                    PosInString = 0
                    For Y = 1 To PrintSeqLen
                        For x = 0 To PermNextno
                            PosInString = PosInString + 1
                            Mid$(Output(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                        Next x
                    Next Y
                   
    '                XX = 0
                
            End If
    
        Else
    
            If ShowSeqFlag = 1 Then
                'Take the known SpacerSeqs and transfer these to SpacerSeqs
                
                If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                    RecompX = Recompress(WinLeft - 1 + Y)
                    If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                 
                        If pGCTripletflag = 0 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) Then
                            If pGCTripletflag = 0 Then
                                If Seq1 <> Seq2 Then
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                    Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x + 1) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        End If
                                    Next 'X
                
                                Else
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        End If
                                    Next 'X
                
                                End If
                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                Else
                                    Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen)
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen)
                                Else
                                    Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen)
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    MinParPos = 2
                                Else
                                    Output(2) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen)
                                    MinParPos = 2
                                End If
                                If SpacerNo + 2 > UBound(Output, 1) Then
                                    ReDim Preserve Output(SpacerNo + 2)
                                End If
                                If SpacerNo > 0 Then
    '                                If DebuggingFlag < 2 Then On Error Resume Next
    '                                UB = -1
    '                                UB = UBound(XOverSeq, 1)
    '                                On Error GoTo 0
                                    If AllowExtraSeqsFlag = 1 And ShowSeqFlag = 1 Then
                                        UB = UBound(SpacerSeqs, 1)
                                        For x = 1 To SpacerNo
                                            If x <= UB Then
                                                Output(x + 2) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                            'Else
                                            '    Exit For
                                            End If
                                        Next 'X
                                    End If
                                End If
                                
                            End If
    '                        XX = Output(3)
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen)
                                Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = Mid$(StrainSeq(RevSeq(x)), WinLeft, PrintSeqLen)
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                            Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
            
                        Else 'If XOverlist(RelX, RelY).ProgramFlag <> 1 And XOverlist(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen)
                            If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen)
                            End If
                            Z = 1
                            SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                            For x = 0 To PermNextno
                                If x <> Seq3 Then
                                    If Daught(SEN, TreeTrace(x)) > 0 Then
                                        Z = Z + 1
                                        Output(Z) = Mid$(StrainSeq(TreeTrace(x)), WinLeft, PrintSeqLen)
                                        
                                    End If
                                End If
                            Next x
                            Z = Z + 1
                            Output(Z) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen)
                            MinParPos = Z
                            If SpacerNo > 0 And (XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Or AllowExtraSeqsFlag = 1) Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    
                                    If x <= UB Then
                                        If SpacerSeqs(x) <= UBound(StrainSeq, 1) Then
                                            Output(x + Z) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        Else
                                            If TreeTrace(SpacerSeqs(x)) <= UBound(StrainSeq, 1) Then
                                                Output(x + Z) = Mid$(StrainSeq(TreeTrace(SpacerSeqs(x))), WinLeft, PrintSeqLen)
                                            Else
                                                Output(x + Z) = ""
                                            End If
                                        End If
                                    Else
                                    
                                    End If
                                Next 'X
'                            ElseIf XOverlist(RelX, RelY).ProgramFlag <> 5 And XOverlist(RelX, RelY).ProgramFlag <> 5 + AddNum Then
'                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
'            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
'                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                Output(Z + 1) = Mid$(SSOLSeq, WinLeft, PrintSeqLen)
                            End If
                        End If
                    Else
                        NF = FreeFile
                        'Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                        
                        ReadLen = PrintSeqLen * (NextNo + 1)
                        ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                        FileSeqString = String(ReadLen, " ")
                         oDir = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        Open "RDP5Longseq" + UFTag For Binary As #NF
                            Get #NF, ReadStart, FileSeqString
                        Close #NF
                        Dim TempOutput() As String
                        ReDim TempOutput(PermNextno)
                        ChDrive oDir
                        ChDir oDir
                        'reconfigure and add to output
                        
                        
                        
                        For x = 0 To PermNextno
                            TempOutput(x) = String(PrintSeqLen + 1, " ")
                        Next x
                        'XX = Len(TempOutput(0))
                        PosInString = 0
                        For Y = 1 To PrintSeqLen
                            For x = 0 To PermNextno
                                PosInString = PosInString + 1
                                Mid$(TempOutput(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                            Next x
                        Next Y
                        
                        If XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                            If pGCTripletflag = 0 Then
                                If Seq1 <> Seq2 Then
                                    Output(0) = TempOutput(Seq1)
                                    Output(1) = TempOutput(Seq2)
                                    MinParPos = 1
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x + 1) = TempOutput(SpacerSeqs(x))
                                        End If
                                    Next 'X
                
                                Else
                                    Output(0) = TempOutput(Seq1)
                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x) = TempOutput(SpacerSeqs(x))
                                        End If
                                    Next 'X
                
                                End If
                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = TempOutput(Seq1)
                                Else
                                    Output(0) = TempOutput(TreeTrace(Seq1))
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = TempOutput(TreeTrace(Seq3))
                                Else
                                    Output(1) = TempOutput(Seq3)
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = TempOutput(Seq2)
                                    MinParPos = 2
                                Else
                                    Output(2) = TempOutput(TreeTrace(Seq2))
                                    MinParPos = 2
                                End If
                            End If
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = TempOutput(Seq1)
                                Output(1) = TempOutput(Seq3)
                                Output(2) = TempOutput(Seq2)
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = TempOutput(RevSeq(x))
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = TempOutput(Seq1)
                            Output(1) = TempOutput(Seq2)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = TempOutput(SpacerSeqs(x))
                                End If
                            Next 'X
                            
                        ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = TempOutput(TreeTrace(Seq1))
                            'XX = Len(Output(0))
                            If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                Output(1) = TempOutput(TreeTrace(Seq3))
                            End If
                            Output(2) = TempOutput(TreeTrace(Seq2))
                            MinParPos = 2
                            If SpacerNo > 0 And XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    If x <= UB Then
                                        Output(x + 2) = TempOutput(SpacerSeqs(x))
                                    End If
                                Next 'X
                            ElseIf XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                'XX = Len(SSOLSeq)
                                'XX = XOverlist(RelX, RelY).DHolder
                                Output(3) = TempOutput(XoverList(RelX, RelY).DHolder) 'Mid$(SSOLSeq, WinLeft, PrintSeqLen)
                            End If
                        End If
                        
                        
                    End If
                End If
    
            Else
    
                If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                    If WinLeft < 1 Then WinLeft = 1
                    Output(0) = Mid$(MCXoverSeq(Seq1), WinLeft, PrintSeqLen)
                    'Exit Sub
                    Output(1) = Mid$(MCXoverSeq(Seq2), WinLeft, PrintSeqLen)
                    MinParPos = 1
                    If SpacerNo > 0 Then
                        UB = UBound(SpacerSeqs, 1)
                        For x = 1 To SpacerNo
                            If x <= UB Then
                                Output(x + 1) = Mid$(MCXoverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                            End If
                        Next 'X
                    
                    End If
    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
                    If pGCTripletflag = 0 Then
                        
        
                        If Seq1 <> Seq2 Then
                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen)
                            Output(1) = Mid$(GCXOverSeq(Seq2), WinLeft, PrintSeqLen)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = Mid$(GCXOverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
        
                        Else
                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen)
                            'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x) = Mid$(GCXOverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
        
                        End If
                    Else
                        Output(0) = Mid$(GCXOverSeq(0), WinLeft, PrintSeqLen)
                        Output(1) = Mid$(GCXOverSeq(2), WinLeft, PrintSeqLen)
                        Output(2) = Mid$(GCXOverSeq(1), WinLeft, PrintSeqLen)
                        MinParPos = 2
                    End If
                ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
        
                    
                        Output(0) = Mid$(PPXOSeq(Seq1), WinLeft, PrintSeqLen)
                        Output(1) = Mid$(PPXOSeq(Seq3), WinLeft, PrintSeqLen)
                        Output(2) = Mid$(PPXOSeq(Seq2), WinLeft, PrintSeqLen)
                        MinParPos = 2
                        num = 3
                        For x = 0 To NumberOfSeqs
                            If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                Output(num) = Mid$(PPXOSeq(RevSeq(x)), WinLeft, PrintSeqLen)
                                num = num + 1
                            End If
                        Next 'X
                    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                    Output(0) = Mid$(SSSubSeq(1), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(SSSubSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(SSSubSeq(0), WinLeft, PrintSeqLen)
                    MinParPos = 2
                    Output(3) = Mid$(SSSubSeq(3), WinLeft, PrintSeqLen)
                ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                    Output(0) = Mid$(CXoverSeq(0), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(CXoverSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(CXoverSeq(1), WinLeft, PrintSeqLen)
                    MinParPos = 2
                Else
                    Output(0) = Mid$(XOverSeq(0), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(XOverSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(XOverSeq(1), WinLeft, PrintSeqLen)
                    MinParPos = 2
                    If SpacerNo + 2 > UBound(Output, 1) Then
                        ReDim Preserve Output(SpacerNo + 2)
                    End If
                    If SpacerNo > 0 Then
                        If DebuggingFlag < 2 Then On Error Resume Next
                        UB = -1
                        UB = UBound(XOverSeq, 1)
                        On Error GoTo 0
                        If UB > 2 Then
                            For x = 1 To SpacerNo
                                If x + 2 <= UB Then
                                    Output(x + 2) = Mid$(XOverSeq(x + 2), WinLeft, PrintSeqLen)
                                Else
                                    Exit For
                                End If
                            Next 'X
                        End If
                    End If
    
                End If
    
            End If
    
        End If
    End If
    '437080
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
    Dim YCon As Long
    
    'XX = Form1.Picture1.TextWidth(Output(0))
    If Form1.Picture1.FontSize = P1FontSize Then 'some systems have fonts with different basic sizes
        'XConA = Form1.Picture1.TextWidth("A")
        
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
    Else
       ' XConA = Form1.Picture1.TextWidth("A")
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
        'XConA = 1
'        XX = Form1.Picture1.TextHeight("A") / Form1.Picture1.TextWidth("A")
        YConA = 1.1
    End If
    
    'Picture1.Width
    PrintSeqLen = MakePrintSeqLen '* YConA '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G")) * YConA
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        
        TopPosY = (Form1.VScroll3.Value / ScrollSF) / tTYF
        BottomPosY = (Form1.Picture9.ScaleHeight + 20 + (Form1.VScroll3.Value / ScrollSF)) / tTYF
        
        Dim XS As Long, XE As Long
        
        If FlashntNum > 0 Or ShowSeqFlag <> 0 Or (Abs(LastLeftPos - WinLeft) >= PrintSeqLen Or ((PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) And (LastTop <> TopPosY Or LastBottom <> BottomPosY))) Then
            XS = 1
            XE = Len(Output(1))
        
        ElseIf (PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) Then ' just do left right thing
            If WinLeft > LastLeftPos Then
                XS = PrintSeqLen - (WinLeft - LastLeftPos)
                XE = Len(Output(1))
            ElseIf WinLeft < LastLeftPos Then
                XS = 1
                XE = LastLeftPos - WinLeft
            Else
                XS = 1
                XE = Len(Output(1))
            End If
            If XS > XE Then XS = XE
        ElseIf (LastTop <> TopPosY Or LastBottom <> BottomPosY) Then ' just do up down thing
            XS = 1
            XE = Len(Output(1))
        Else
            XS = 1
            XE = Len(Output(1))
        End If
        SubPrintlen = XE - XS
        If ShowSeqFlag = 0 Then 'If the current selection is "show all sequences"
    '        SS = Abs(GetTickCount)
                'XX = Picture1.ScaleWidth
                
                If ColDistInFile = 1 Then
                    If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
                        'redim SubValid(0,0)
                        ReDim SubDiffs(0, 0)
                        'redim sMat(0,0)
                        ReDim FubValid(0, 0)
                        'Erase FMat
                    End If
                    Timer7(1).Enabled = False
                    If DebuggingFlag < 2 Then On Error Resume Next
                    
                    UB = UBound(ColDist2, 1)
                    On Error GoTo 0
                    '@
                    If UB = 0 Then
                        ReDim ColDist2(UBCD2)
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                        Open "RDP5CDFile" + UFTag For Binary As #FF
                        Get #FF, , ColDist2
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    End If
                    
                End If
                '591168
                Picture1.FillStyle = 0
                
                ''For zzz = 1 To 10
                Dim NSL As Long, DRSN1 As Long, UBSL2 As Long, UBI As Long, UBR As Long, StoreNum1 As Long, RSN1 As Long, Offset1 As Long, Offset2 As Long, Offset3 As Long, Offset4 As Long, Col1 As Long, Col2 As Long, Col3 As Long, Col4 As Long, Col5 As Long
                
    '            SS = Abs(GetTickCount)
                
'                Col1 = RGB(128, 128, 255)
'                Col2 = RGB(255, 128, 128)
'                Col3 = RGB(255, 0, 0)
'                Col4 = RGB(128, 0, 0)
'                Col5 = RGB(64, 64, 255)
                
                'ReDim ColX(255)
                'ColX (1)
                
                UBI = UBound(Identical)
                UBR = UBound(Recompress)
                UBSL2 = UBound(SeqLines, 2)
                
                
                
                
                For Y = XS To XE
                    StoreNum1 = WinLeft + Y - 1
    '                If StoreNum1 >= 870 Then
    '                    X = X
    '                End If
                    If StoreNum1 <= UBR Then
                        RSN1 = Recompress(StoreNum1)
                        
                        If UBI >= RSN1 Then
                            '@
                            YCon = StoreNum1 - WinLeft + 1
                            Offset1 = YCon * 8
                            Offset2 = YConA * 13
                            Offset3 = (PermNextno) * 13 + Offset2
                            Offset4 = Offset1 - 8
                            If StoreNum1 <= Decompress(Len(StrainSeq(0))) Then
                                If StoreNum1 - WinLeft > PrintSeqLen Then Exit For
                                RecompX = RSN1
                                
                                If UBI >= RSN1 Then
                                    '@
                                    If StoreNum1 = Decompress(RSN1) Then
                                        If UBSL2 < NumSeqLines + PermNextno Then
                                            UBSL2 = NumSeqLines + PermNextno * 3
                                            ReDim Preserve SeqLines(5, UBSL2)
                                        End If
                                        
                                        If Identical(RSN1) = 0 Then
                                            '@
                                            If x = 1234567 Then
                                                NSL = NumSeqLines
                                                NumSeqLines = FillSeqLines2(NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqLines, 1), ColDist2(0), SeqLines(0, 0), SeqColRef2(0), ColPos2(0))
                                            Else
                                                Dim StartP As Long, EndP As Long, SeqCol As Long
                                                
                                                StartP = ColPos2(RSN1)
                                                EndP = ColPos2(RSN1 + 1) - 2
                                                'If StartP <> EndP Or X = X Then
                                                    'If SeqColRef2(RSN1) = 1 Then
                                                    SeqCol = ColX(SeqColRef2(RSN1))
'                                                    ElseIf SeqColRef2(RSN1) = 2 Then
'                                                        SeqCol = Col2 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 3 Then
'                                                        SeqCol = Col3 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 4 Then
'                                                        SeqCol = Col4 'colour of thing to draw
'                                                    End If
                                                    For x = StartP To EndP Step 2
                                                        '@
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(2, NumSeqLines) = Offset4 'X1
                                                        SeqLines(3, NumSeqLines) = CLng(ColDist2(x)) * 13 'Y1,7,9,13-16,18,21,23-24,8
                                                        SeqLines(4, NumSeqLines) = Offset1 'X2
                                                        SeqLines(5, NumSeqLines) = (CLng(ColDist2(x + 1))) * 13 + Offset2 'Y2
                                                        '@
                                                        SeqLines(1, NumSeqLines) = SeqCol
                                                        NumSeqLines = NumSeqLines + 1
                                                    Next 'X
                                                'End If
                                            'End If
    '                                        ElseIf X = X Then
    '                                            NSL = NumSeqLines
    '                                            NumSeqLines = FillSeqLines(PermNextno, NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqColRef, 1), UBound(SeqLines, 1), UBound(ColDist, 1), ColDist(0, 0), SeqLines(0, 0), SeqColRef(0, 0))
    '                                            'X = X
    '                                        Else
    '                                        ''If X = 12345 Then
    '                                            For X = 0 To PermNextno
    '                                                ''Offset4 = X * 13
    '                                                If SeqColRef(RSN1, X) > 0 Then
    '                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
    '                                                    SeqLines(2, NumSeqLines) = Offset4 'X1
    '                                                    SeqLines(3, NumSeqLines) = X * 13 'Y1
    '                                                    SeqLines(4, NumSeqLines) = Offset1 'X2
    '                                                    SeqLines(5, NumSeqLines) = (X + ColDist(RSN1, X) - 1) * 13 + Offset2 'Y2
    '                                                    If SeqColRef(RSN1, X) = 1 Then
    '                                                        SeqLines(1, NumSeqLines) = Col1
    '                                                    ElseIf SeqColRef(RSN1, X) = 2 Then
    '                                                        SeqLines(1, NumSeqLines) = Col2 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 3 Then
    '                                                        SeqLines(1, NumSeqLines) = Col3 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 4 Then
    '                                                        SeqLines(1, NumSeqLines) = Col4 'colour of thing to draw
    '                                                    End If
    '                                                    NumSeqLines = NumSeqLines + 1
    '                                                    X = X + ColDist(RSN1, X)
    '                                                Else
    '                                                    X = X
    '                                                End If
    '                                            Next 'X
    '                                            ''End If
                                            End If
                
                                        Else '
                                            
                                            'Picture1.FillColor = RGB(64, 64, 255)
                                            'Picture1.ForeColor = RGB(64, 64, 255)
                                            'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = ColX(0)  'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = Offset4 'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Offset1 'X2
                                            SeqLines(5, NumSeqLines) = Offset3 'Y2
                                            NumSeqLines = NumSeqLines + 1
            '                                If UBound(SeqLines, 2) < NumSeqLines Then
            '                                    ReDim Preserve SeqLines(5, NumSeqLines + 2000)
            '                                End If
                                            
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                Next 'Y
                If FlashntNum > 0 Then
                    'add in the flashing nts
                    For x = 1 To FlashntNum
                        If Flashnt(0, x) >= WinLeft And Flashnt(0, x) < WinLeft + PrintSeqLen Then
                            If UBSL2 < NumSeqLines + PermNextno Then
                                UBSL2 = NumSeqLines + PermNextno * 3
                                ReDim Preserve SeqLines(5, UBSL2)
                            End If
                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                            SeqLines(1, NumSeqLines) = Flashnt(3, x) 'colour of thing to draw
                            SeqLines(2, NumSeqLines) = (Flashnt(0, x) - WinLeft) * 8 'X1
                            SeqLines(3, NumSeqLines) = Flashnt(1, x) * 13 'Y1
                            SeqLines(4, NumSeqLines) = SeqLines(2, NumSeqLines) + 8 'X2
                            SeqLines(5, NumSeqLines) = SeqLines(3, NumSeqLines) + Offset2
                            NumSeqLines = NumSeqLines + 1
                        End If
                    Next x
                
                End If
                
                
                
                
    '            EE = Abs(GetTickCount)
    '            TT = EE - SS
    '            X = X ''687,703,719
                ''0.610,609,0.625 with rsn1
                '0.609 offset1
                '0.578 with 2000 redim
                
                ''Next zzz
                If ColDistInFile = 1 Then
                    Timer7(1).Enabled = True
                End If
                If WinLeft + PrintSeqLen < UBound(Recompress, 1) Then
                    If Recompress(WinLeft + PrintSeqLen) <> WinLeft + PrintSeqLen Then GoOn = 1
                End If
                If WinLeft <= UBound(Recompress, 1) Then
                If GoOn = 1 Or Recompress(WinLeft) <> WinLeft Then
                    For Y = WinLeft + XS - 1 To WinLeft + XE
                        YCon = Y - WinLeft + 1
                        'XX = UBound(ABCons, 1)
                        If Y <= UBound(ABCons, 1) Then
                            If ABCons(Y) <> 0 Then
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            ElseIf Y <> Decompress(Recompress(Y)) Then    'these sites are ignored
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 128, 64) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            End If
                        End If
                    Next Y
                End If
                End If
                
                
                Picture1.ForeColor = 0
    '        EE = Abs(GetTickCount)
    '        TT = EE - SS
    '        X = X
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            Pict = 0
            Pict = Picture1.hdc
            If Pict = 0 Then
               Picture1.Height = Picture1.Width * 2
               Pict = Picture1.hdc
               Set Form1.Picture1.Picture = Form1.Picture1.Image
                Set sPic = Form1.Picture1.Picture
                cDib.CreateFromPicture sPic
            End If
            On Error GoTo 0
            Dim OutputNum As Long
            For x = 0 To UBound(Output)
                If Output(x) = "" Then Exit For
            Next x
            OutputNum = x
            If XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                            RecompX = WinLeft + Y - 1
                            If ShowSeqFlag = 1 Then
                                
                                If (XPosDiff(Recompress(WinLeft - 2 + Y)) <> XPosDiff(RecompX)) Then 'And SeqNum(WinLeft + Y - 1, Seq3) <> 46 Then
                                    If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 12  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 12 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        
                                    End If
                                    If SeqNum(RecompX, Seq2) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 26  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    End If
                                    'ElseIf SeqNum(WinLeft + Y - 1, Seq1) = SeqNum(WinLeft + Y - 1, Seq2) And SeqNum(WinLeft + Y - 1, Seq1) <> 46 Then
                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                    '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                    'End If
                                    num = 2
                                    If SeqNum(RecompX, Seq3) <> 46 Then
                                        For Z = 0 To OutputNum
                                            If RevSeq(Z) <> Seq1 And RevSeq(Z) <> Seq2 And RevSeq(Z) <> Seq3 Then
                                                num = num + 1
                                                If SeqNum(RecompX, RevSeq(Z)) = SeqNum(RecompX, Seq3) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), mPurple, BF
                                                ElseIf SeqNum(RecompX, RevSeq(Z)) <> 46 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), Yellow, BF
                                                End If
                                                    'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'Else
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'End If
                    
                                                
                                                    
                                            End If
                                            
                                            
                                        Next Z
                                    End If
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((NumberOfSeqs) * 13 + 13) * tTYF), RGB(92, 92, 92), BF
                                End If
                               
                            Else
            
                                If WinLeft + Y - 1 < Len(PPXOSeq(0)) + 1 Then
                                        If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 12  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line ((Y * 8) - 7, 0)-((Y * 8), 12 * tTYF), Yellow, BF
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            
                                            
                                        End If
                                        If Mid$(Output(MinParPos), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 26  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        End If
                                        'ElseIf mid$(output(0),y,1) = mid$(output(2),y,1) And mid$(output(0),y,1) <> 46 Then
                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                        '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                        'End If
                                        num = 2
                                        If Mid$(Output(1), Y, 1) <> "-" Then
                                            For Z = 3 To OutputNum
                                                
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), mPurple, BF
                                                    ElseIf Mid$(Output(Z), Y, 1) <> "-" Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), Yellow, BF
                                                    End If
                                                        'If mid$(output(0),y,1) <> 46 And mid$(output(0),y,1) <> 47 Then
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'Else
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'End If
                        
                                                    
                                                
                                                
                                            Next Z
                                        End If
                                End If
            
                            End If
                        End If
                    End If
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                
                If pGCTripletflag = 0 Then
                    If ShowSeqFlag = 1 Then
        
                        For Y = XS To XE
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If GCIdentical(RecompX) = 0 Then 'Or GCMonoSiteFlag = 1
        
                                
                                    If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            'Else
                                            '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), LPurple, BF
                                            'End If
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq1) Or SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq2) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                            End If
            
                                        Next 'Z
                                    End If
        
                                
        
                                ElseIf GCIdentical(RecompX) = 2 And GCIndelFlag = 1 Then
                                    StartY = Y
            
                                    Do While GCIdentical(RecompX) = 2
                                        Y = Y + 1
                                    Loop
            
                                    Y = Y - 1
            
                                    If Y = StartY Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                    Else
                                        'Teststring = Mid$(StrainSeq(Seq1), WinLeft + starty - 1, Y - starty)
            
                                        If Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) = Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                            End If
            
                                        Next 'Z
            
                                    End If
            
                                Else
            
                                    If GCMonoSiteFlag = 1 And SeqNum(RecompX, Seq1) > 60 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = ((NumEnabledSeqs) * 13 + 12)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), mPurple, BF
                                    Else
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), RGB(92, 92, 92), BF
                                    End If
            
                                End If
                            End If
                            
                        Next 'Y
        
                    Else
        
                        For Y = XS To XE
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                                    RecompX = Recompress(WinLeft - 1 + Y)
                                    If GCIndelFlag <> 1 Then
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                            End If
                
                                        End If
                
                                    Else
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If GCIdentical(GCXDiffPos(RecompX)) = 2 Then
                                                StartY = Y
                
                                                Do While GCIdentical(GCXDiffPos(RecompX)) = 2
                                                    Y = Y + 1
                                                Loop
                
                                                Y = Y - 1
                
                                                If Y = StartY Then
                
                                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8)) * tTYF, 25 * tTYF), mPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                Else
                                                    'TestString = Mid$(Output(0), StartY, Y - StartY + 1)
                
                                                    If Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) = Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                End If
                
                                            Else
                
                                                If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                                Else
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                End If
                
                                                For Z = 1 To OutputNum
                
                                                    If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                    End If
                
                                                Next 'Z
                
                                            End If
                
                                        End If
                
                                    End If
                                'End If
                            End If
                        Next 'Y
        
                    End If
                Else ' ie gctriplrtflag=1
                   
                    LastY = -1
                    
                    For Y = XS To XE
                        If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                            'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If (RecompX) > UBound(XPosDiff, 1) Then Exit For
                                If RecompX > 0 Then
                                
                                    If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX - 1) <> XPosDiff(RecompX)) Or ShowSeqFlag = 2 Then
                                        If LastY > -1 And ShowSeqFlag = 1 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (LastY * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y - 1) * 8  'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                        End If
                                        LastY = -1
                                        Test$ = Mid$(Output$(0), Y, 1)
                    
                                        If Test$ <> "*" And Test$ <> "" Then
                                            CountHits = 0
                    
                                            For x = 0 To 2
                                                If x = 2 Then x = MinParPos
                                                If Mid$(Output(x), Y, 1) = Test$ Then
                                                    CountHits = CountHits + 1
                                                End If
                    
                                            Next 'X
                    
                                            If CountHits < 3 Then
                                                A = 0
                                                C = 0
                                                g = 0
                                                T = 0
                                                S = 0
                    
                                                For Z = 0 To 2
                                                    If Z = 2 Then Z = MinParPos
                                                    If Mid$(Output(Z), Y, 1) = "A" Then
                                                        A = A + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                        C = C + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                        g = g + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                        T = T + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                        S = S + 1
                                                    End If
                    
                                                Next 'Z
                    
                                                If A >= g And A >= T And A >= C Then
                                                    CountHits = A
                                                    Test$ = "A"
                                                ElseIf C >= g And C >= T And C >= A Then
                                                    CountHits = C
                                                    Test$ = "C"
                                                ElseIf g >= A And g >= T And g >= C Then
                                                    CountHits = g
                                                    Test$ = "G"
                                                ElseIf T >= g And T >= A And T >= C Then
                                                    CountHits = T
                                                    Test$ = "T"
                                                End If
                    
                                            End If
                    
                                            If CountHits / (2 + 1) = 1 Or S > 0 Or CountHits = 1 Then
                                                If CountHits <> 1 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                
                                                End If
                                            ElseIf CountHits / (3) >= 0.75 Then
                    
                                                For Z = 0 To OutputNum
                    
                                                    If Mid$(Output(Z), Y, 1) = Test$ Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(128, 128, 128) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        
                                                    End If
                    
                                                Next 'Z
                    
                                            Else
                    
                                                For Z = 0 To OutputNum
                    
                                                    If ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0 Then
                    
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13 - 1) * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And XPosDiff(RecompX) = 0 Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                    End If
                    
                                                Next 'Z
                    
                                            End If
                    
                                        End If
                    
                                    Else
                    
                                        If LastY = -1 Then
                                            LastY = Y
                                        End If
                    
                                    End If
                                End If
                            'End If
                        End If
        
                    Next 'Y
        
                    If LastY > -1 And ShowSeqFlag = 1 Then
                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)   'X1
                        SeqLines(3, NumSeqLines) = 0 'Y1
                        SeqLines(4, NumSeqLines) = Y * 8   'X2
                        SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                        NumSeqLines = NumSeqLines + 1
                        If UBound(SeqLines, 2) < NumSeqLines Then
                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                        End If
                    End If
                End If
                Picture1.ForeColor = 0
            ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                    
                        If ShowSeqFlag = 1 Then
                            If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If MCIdentical(RecompX) = 0 Then
            
                                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
            
                                            If SeqNum(RecompX, Seq1) <> 46 And SeqNum(RecompX, Seq1) <> 47 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            End If
            
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        End If
            
                                    End If
            
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                End If
            
                            Else
            
                                If WinLeft + Y - 1 < Len(MCXoverSeq(0)) + 1 Then
                                    'teststring = Mid$(Output(0), Y, 1)
            
                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
            
                                        If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(0), Y, 1) <> "." Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        End If
            
                                    Else
                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                    End If
            
                                End If
                            End If
        
                        End If
                    End If
    
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                LastY = -1
    
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                            If Recompress(Y + WinLeft - 1) < UBound(XPosDiff, 1) Then
                                RecompX = Recompress(WinLeft + Y - 1)
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = ((Y - 1) * 8)  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        If CountHits / (3) <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        End If
                
                                        If CountHits / 3 = 1 Then
                                            If ShowSeqFlag = 1 Then
                                                If DebuggingFlag < 2 Then On Error Resume Next
                                                UB2 = 0
                                                UB2 = UBound(PScores, 1)
                                                On Error GoTo 0
                                                If UB2 > 0 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                End If
                                            ElseIf ShowSeqFlag = 2 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                            End If
                                        ElseIf CountHits / (3) >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                
                                            For Z = 0 To OutputNum
                
                                                If (ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0) And Output(Z) <> "" Then
                                                     If DebuggingFlag < 2 Then On Error Resume Next
                                                    UB2 = 0
                                                    UB2 = UBound(PScores, 1)
                                                    On Error GoTo 0
                                                    
                                                    
                                                    If UB2 = 15 Then
                                                        ReDim Preserve PScores(Len(StrainSeq(0))) 'Exit Sub
                                                        ReDim Preserve PltCol3(15)
                                                        'XX = UBound(PltCol3, 1)
                                                        'Exit Sub
                                                    End If
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                        
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                            ReDim Preserve PltCol3(15)
                                                            
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB3 = 0
                                                            UB3 = UBound(PScores, 1)
                                                            UB2 = UBound(PltCol3, 1)
                                                            On Error GoTo 0
                                                            
                                                            If UB2 > 0 And UB3 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13) * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf CountHits = 1 Then
                                                        'Picture1.Line ((Y * 8) - 8, (Z) * 13)-((Y * 8), (Z) * 13 + 12), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    End If
                
                                                ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or PScores(RecompX) = 0) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                ElseIf ShowSeqFlag = 1 And PScores(RecompX) > 0 And Output(Z) <> "" Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))   'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), PltCol3(PScores(WinLeft + Y - 1)), B
                                                End If
                
                                            Next 'Z
                
                                        End If
                
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            End If
                        'End If
                    End If
                Next 'Y
    
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                    'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-(((Y - 1) * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                End If
    
            
            ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 Or XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                LastY = -1
                
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                         RecompX = Recompress(WinLeft + Y - 1)
                        If RecompX <= UBound(XDiffPos, 1) Then
                            'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                               
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And (XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2)) Or XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft)))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        If x = x Then 'CountHits / 3 <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        End If
                
                                        If CountHits / 3 = 1 Or S > 0 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        ElseIf CountHits / 3 >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (z) * 13 * tTYF)-((Y * 8) * tTYF, (z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                                            GoOn = 0
                                            If (WinLeft + Y - 1) >= 1 Then
                                                'If XPosDiff(WinLeft + Y + 1) <> XPosDiff(WinLeft + Y) Then
                                                    X0 = Mid$(Output(0), Y, 1)
                                                    X1 = Mid$(Output(1), Y, 1)
                                                    X2 = Mid$(Output(MinParPos), Y, 1)
                                                    If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(1), Y, 1) <> "-" And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                                        GoOn = 1
                                                    End If
                                                'End If
                                            End If
                                           
                                            If GoOn = 1 Then
                                                For Z = 0 To OutputNum
                                                    
                                                    If ShowSeqFlag = 2 Or (XPosDiff(RecompX) <> 0 And GoOn = 1) Then
                                                        
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mGreen, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mPurple, BF
                                                            'X = X
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or GoOn = 0) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                    
                                                    End If
                    
                                                Next 'Z
                                            Else
                                                
                                                'SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                'SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                'SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                                'SeqLines(3, NumSeqLines) = 0 'Y1
                                                'SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                                'SeqLines(5, NumSeqLines) = ((3 + SpacerNo) * 13)  'Y2
                                                'NumSeqLines = NumSeqLines + 1
                                                'If UBound(SeqLines, 2) < NumSeqLines Then
                                                '    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                'End If
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0  'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            
                                            End If
                                        End If
                                        
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            'End If
                        End If
                    End If
                Next 'Y
                
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                End If
    
            End If
    
        End If
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
 'XX = Len(Output(0))
'593248
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If WinLeft > Decompress(Len(StrainSeq(0))) - 58 Then
    
            For x = 0 To PermNextno
    
                If Len(Output(x)) > 0 Then
                    Output(x) = Output(x) + String$(58 - (Decompress(Len(StrainSeq(0))) - WinLeft), " ")
                End If
    
            Next 'X
    
        End If
    End If
    'XX = Picture1.TextHeight("A") - 3
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        Dim LOut As Long
        LOut = XE - XS + 1
        'XX = Mid$(StrainSeq(0), 208, 20)
        SeqText2 = String(LOut * (PermNextno + 2), " ")
        PrintStartY = XS
       
        
        
        If Picture1.FontSize > 3 Or x = x Then
       
            For x = 0 To UBound(Output, 1) 'PermNextno
        
                If Len(Output(x)) > 0 Then
                    If UBound(SeqText, 1) < NumSeqText Then
                        ReDim Preserve SeqText(NumSeqText + 20)
                    End If
                    'If Len(Output(X)) > 0 Then
                        SeqText(NumSeqText) = Mid$(Output(x), XS, LOut)
                        Mid$(SeqText2, 1 + (x * LOut), LOut) = Mid$(Output(x), XS, LOut)
                        '@
                        SeqLines(0, NumSeqLines) = 1 'this is text
                        '@
                        SeqLines(1, NumSeqLines) = NumSeqText 'position of string in seqtext
                        SeqLines(2, NumSeqLines) = 0 'xposition
                        SeqLines(3, NumSeqLines) = x * 13 'yposition
                        NumSeqText = NumSeqText + 1
                        NumSeqLines = NumSeqLines + 1
                        If UBound(SeqLines, 2) < NumSeqLines Then
                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                        End If
                    'Else
                    '   X = X
                    'End If
                    'TextOut Pict, 0, (((X * 13 - TYFM) * tTYF)), Output(X), Len(Output(X))
                End If
        
            Next 'X
        End If
    
        'XX = Len(Output(1))
        '596996
        'If OnlyDoPosBar = 1 Then GoTo PosBarBit
        Dim SectionLen As Long, OverlapX As Long, XPrintseqlen As Long
        If DSDFlag = 0 Then
            Call DoSeqDisplay
            
        ElseIf DSDFlag = 1 Then
'            Dim sPic As StdPicture, cDib As New cDibSection, hdcHolder As Long
'            '@
           
            hdcHolder = cDib.hdc
            Call DoSeqDisplayDIB(hdcHolder)
            'Form1.Picture1.Top = -300
            'Form1.Picture1.Left = -300
            BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            'cDib.PaintPicture Form1.Picture1.hdc
        ElseIf DSDFlag = 2 Then
            XLenPerColumn = tTYF * XConA
            XPrintseqlen = PrintSeqLen * tTYF * XConA * 8 - 1 'PrintSeqLen * XLenPerColumn * 8
            
            If FlashntNum > 0 Or ShowSeqFlag <> 0 Or (Abs(WinLeft - LastLeftPos) >= PrintSeqLen Or ((PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) And (LastTop <> TopPosY Or LastBottom <> BottomPosY))) Then
                hdcHolder = cDib.hdc
                
                Call DoSeqDisplayDIB2(hdcHolder)
                'Form1.Picture1.Top = -300
                'Form1.Picture1.Left = -300
                BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                'cDib.PaintPicture Form1.Picture1.hdc
            
            ElseIf (PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) Then ' just do left right thing
                hdcHolder = cDib.hdc
                
                'BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                
                
                OverlapX = CLng(XLenPerColumn * (2) * 8)
                'XX = Form1.Picture9.ScaleWidth
                If WinLeft > LastLeftPos Then
                    SectionLen = CLng(XLenPerColumn * (WinLeft - LastLeftPos) * 8)
                    'SectionLen = 400
                    '@
                    BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen - SectionLen, Form1.Picture9.ScaleHeight, Form1.Picture1.hdc, SectionLen, 0, vbSrcCopy
                    'Picture1.Refresh
                    Call DoSeqDisplayDIB2(hdcHolder)
                    '@
                    BitBlt Form1.Picture1.hdc, XPrintseqlen - SectionLen, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, XPrintseqlen - SectionLen, 0, vbSrcCopy
                Else
                    SectionLen = CLng(XLenPerColumn * (LastLeftPos - WinLeft) * 8)
                    BitBlt Form1.Picture1.hdc, SectionLen, 0, XPrintseqlen - SectionLen, Form1.Picture9.ScaleHeight, Form1.Picture1.hdc, 0, 0, vbSrcCopy
                    Call DoSeqDisplayDIB2(hdcHolder)
                    BitBlt Form1.Picture1.hdc, 0, 0, SectionLen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                End If
                
                
            ElseIf (LastTop <> TopPosY Or LastBottom <> BottomPosY) Then ' just do up down thing
                hdcHolder = cDib.hdc
                
                'BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                Call DoSeqDisplayDIB2(hdcHolder)
                BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            
            End If
        
        
            LastPrintSeqLen = PrintSeqLen
            LastLeftPos = WinLeft
            LastTop = TopPosY
            LastBottom = BottomPosY
            
        End If
        '601668
        If VScroll3.Value <> LastVScroll3Value Then
            If ShowSeqFlag = 0 Then
                Call PrintNames
            Else
                Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
            End If
             LastVScroll3Value = VScroll3.Value
        End If
    End If
    

   
    
    Picture1.DrawMode = 13
    Picture1.ForeColor = 0
    
    
    'If ShowSeqFlag = 1 Then
    '    Picture7.Refresh
    '    Picture7.AutoRedraw = False
    '    Picture7.DrawMode = 12
    '    Picture7.Line (P1, 5)-(P2, 10 - 1), QuaterColour, BF ' QBColor(7), BF
    '    Picture7.DrawMode = 13
    '    Picture7.AutoRedraw = True
    'End If

    
    'do the scalebar
    LineBottom = Picture13.ScaleHeight
    LineTop = LineBottom - 2
    '@
    Picture13.FillColor = BackColours
    Picture13.ForeColor = BackColours
    Picture13.FillStyle = 0
    'Picture13.AutoRedraw = True
    'Picture13.Picture = LoadPicture()
    Dim TL As Integer, FSX As Integer
    FSX = Form1.Picture1.FontSize
    If FSX > 10 Then
        TL = 5
    ElseIf FSX > 6 Then
        TL = 10
    ElseIf FSX > 3 Then
        TL = 20
    Else
        TL = 50
    End If
    
    PrintSeqLen = MakePrintSeqLen
    
    Picture4.AutoRedraw = False
    Picture11.AutoRedraw = False
    If OnlyDoPosBar = 0 Or OnlyDoPositionIndicator = 1 Then
        
        Form1.Picture4.BorderStyle = 1
        P1 = CLng(((THold * HScroll1Mod) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        If ShowSeqFlag < 2 Then
            
            P2 = P1 + CLng(((PrintSeqLen - 5) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        Else
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                If (WinLeft + PrintSeqLen - 5) < Len(MCXoverSeq(0)) Then
                        P2 = CLng((Decompress(MCXDiffPos(WinLeft + PrintSeqLen - 5)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(MCXDiffPos(WinLeft)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                Else
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                   
                    End If
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(SSSubSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(CXoverSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            Else
                If WinLeft <= UBound(XDiffPos, 1) Then
                    If Recompress(WinLeft + PrintSeqLen - 5) < Len(XOverSeq(0)) And Decompress(XDiffPos((Recompress(WinLeft + PrintSeqLen - 5)))) > 0 Then
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                End If
            End If
            
        End If
        If P2 = P1 Then P2 = P1 + 1
        
        
        If HomologyIndicator = 2 Then
            
            Picture11.DrawMode = 12
            'Picture11.ForeColor = HalfColour 'QuaterColour
            Picture11.Refresh
            Picture11.Line (P1, 0)-(P2, Picture11.ScaleHeight - 1), QuaterColour, BF ' QBColor(7), BF
        ElseIf HomologyIndicator = 1 Then
            
            
            Picture4.DrawMode = 6
            '
            
            
            Pict4 = Picture4.hdc
            Pict4SH = Picture4.ScaleHeight - 1
            '@
            'Picture4.ForeColor = QBColor(7)
            '~10% of the time is spent drawing this rectangle
             'Picture4.FillStyle = 1
             '@
             Picture4.Refresh
'            ReDim PolyPoints(5)
'            PolyPoints(0).x = P1: PolyPoints(0).y = 0
'            PolyPoints(1).x = P2: PolyPoints(1).y = 0
'            PolyPoints(2).x = P2: PolyPoints(2).y = Pict4SH
'            PolyPoints(3).x = P1: PolyPoints(3).y = Pict4SH
'            PolyPoints(4).x = P1: PolyPoints(4).y = 0
'            Polygon Picture4.hdc, PolyPoints(0), 4
             
            
             'Rectangle Pict4, P1, 0, P2, Picture4.ScaleHeight - 1
            
            MoveToEx Pict4, P1, 0, PAP
            LineTo Pict4, P2, 0
            LineTo Pict4, P2, Pict4SH
            LineTo Pict4, P1, Pict4SH
            LineTo Pict4, P1, 0
        End If
        PositionIndicaterOn = 1
        'If OnlyDoPositionIndicator = 1 And OnlyDoPosBar = 0 Then Exit Sub
    End If
    
    
    If OnlyDoPositionIndicator = 0 And (Timer1.Enabled = False Or BPFlashed = 0) Then
        If OnlyDoPositionIndicator = 0 Then
            Rectangle Picture13.hdc, 0, 0, Picture13.ScaleWidth, Picture13.ScaleHeight
        End If

        'XX = Picture13.AutoRedraw
        If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
            Dim XX1 As Long, XX2 As Long, XX3 As Long, Y1 As Long, Y2 As Long
    '        XX = Picture13.Width
    '        XX = Picture13.ScaleWidth
            Dim ColbumpX As Long
            ReDim SEPosMap(-100 To Form1.Picture13.ScaleWidth * 4)
            If ORFFlag = 1 Then
                
                
                ReDim PolyPoints(5)
                For x = -2 To PrintSeqLen + 2
                    
                    If WinLeft + x <= UBound(SeqFeatureTrace, 1) Then
                        ColbumpX = ColBump(SeqFeatureTrace(WinLeft + x))
                        If SeqFeatureMap(WinLeft + x) = 20 Then 'start of exon in - ori
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                        ElseIf SeqFeatureMap(WinLeft + x) = 22 Then 'start of exon in + ori
                            XX1 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            For Y = XX2 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX1: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 230, 64)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                        ElseIf SeqFeatureMap(WinLeft + x) = 24 Then 'start of exon in - ori
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                            
                    ElseIf SeqFeatureMap(WinLeft + x) = 26 Then  'end of exon in - ori (donor)
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 230, 64)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                           
                    ElseIf SeqFeatureMap(WinLeft + x) = 1 Then
                            
                            
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 3.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3 '25:375-383
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            
                        
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(128, 255, 128)
                            '@
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 6 Then
                            
                            
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            
                            For Y = XX1 To XX3 '24:369-375
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 164, 164)
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 9 Then
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X)
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 1)
'                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 2)
                            XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            XX = LBound(SEPosMap, 1)
                            For Y = XX1 To XX3 '26:755-763
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                            PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                            '@
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                            PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(128, 255, 128)
                            
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        ElseIf SeqFeatureMap(WinLeft + x) = 10 Then
                            XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                            XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                            XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                            For Y = XX1 To XX3
                                SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                            Next Y
                            Y1 = 0
                            Y2 = LineBottom
                            PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                            PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                            PolyPoints(2).x = XX2: PolyPoints(2).Y = Y2 / 2
                            PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                            PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                            PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                            
                            Form1.Picture13.FillStyle = 0
                            Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                            Form1.Picture13.ForeColor = RGB(255, 164, 164)
                            Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        
                        End If
                    End If
                Next x
                Form1.Picture13.ForeColor = 0
            End If
           
            
            If DebuggingFlag < 2 Then On Error Resume Next
            
            UB = UBound(RememberBPs, 2)
            
            On Error GoTo 0
            If (RelX > 0 Or RelY > 0) And UB > 0 Then
                Dim BPPos As Long, WLPS As Long
                WLPS = WinLeft + PrintSeqLen
                
                For Z = NumberBPs To 0 Step -1 ' just makes sur that the "main event" is done last
                   ' If Z = 0 Then
                   ' X = X
                   ' End If
                    xBak = RememberBPs(1, Z) - CLng((AddNum - 2) / 2)
                    BPPos = RememberBPs(0, Z)
                    If BPPos > WinLeft And BPPos < WLPS Then
                        x = BPPos - WinLeft
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA - 5 + xBak, LineTop - 10)-((x * 8 + 6) * tTYF * XConA + xBak, LineBottom - 4), ProgcolourB(RememberBPs(1, Z))
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA + xBak, LineBottom - 4)-((x * 8 + 6) * tTYF * XConA + 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA + 5 + xBak, LineTop - 10)-((x * 8 + 6) * tTYF * XConA - 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
                    End If
                Next Z
                p1TTYF = tTYF
            End If
            '@
             
           'Picture13.FillStyle = 1
            Picture13.ForeColor = 0
            Pict = Picture13.hdc
            Dim OS As String, TX As Single, LV As Single, DC As Long
            DC = Decompress(Len(StrainSeq(0)))
            TX = tTYF * XConA
            LV = (LineTop * VAddjust) - (16 * VAddjust)
            If x = x Then
                '@
                For x = 0 To PrintSeqLen
                    '@
                    YCon = WinLeft + x
                    If YCon <= DC Then
                        
                        X3 = (x * 8 + 6) * TX
                        
                        If (YCon) / TL = Int((YCon) / TL) Then
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                            '@
                            
                            Dummy = MoveToEx(Pict, X3, LineTop - 2, PAP)
                            Dummy = LineTo(Pict, X3, LineBottom)
                            '@
                            'Picture13.Refresh'
                            '@
                            C = (Picture13.TextWidth(Trim$(CStr(YCon)))) / 2
                            X3 = X3 - C
                            'Y1 = (LineTop * VAddjust) - (16 * VAddjust)
                            
                            OS = Trim$(CStr(YCon))
                            
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                        Else
                            '@
                            Dummy = MoveToEx(Pict, X3, LineTop, PAP)
                            
                            Dummy = LineTo(Pict, X3, LineBottom)
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
        
                    Else
                        Exit For
                    End If
        
                Next 'X
            End If
            
        Else
    
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(MCXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 * XConA + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF * XConA - (Picture13.TextWidth(Trim$(CStr(Decompress(MCXDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(MCXDiffPos) Then Picture13.Print Decompress(MCXDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(GCXDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(GCXDiffPos) Then Picture13.Print Decompress(GCXDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                Else
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(SSSubSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(CXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            Else
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(XOverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            End If
    
        End If
    End If
'601580

    
    
    
    
    
    
    
    Picture1.Refresh
    '@
    Picture13.Refresh
    
    RLFlag = 0

    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
        Picture3.Enabled = True
    Else
        Picture3.Enabled = False
    End If
    
    
    
    
    
    
'    If HorstFlag = 1 Then
'
'        Call DrawHorstInterval(WinLeft, PrintSeqLen)
'    End If
    Exit Sub
UnknownFormat:

    If RunFlag = 0 And ManFlag = -1 Then
        Picture1.BackColor = Form1.BackColor
        Picture3.BackColor = Form1.BackColor
        Picture4.BackColor = Form1.BackColor
        Picture11.BackColor = Form1.BackColor
        Picture13.BackColor = Form1.BackColor
    End If

    Response = MsgBox("I could not recognise this DNA alignment file format" + Chr$(13) + "Send it as an attatchment to darrenpatrickmartin@gmail.com", 32)
    ErrorFlag = 1
    RLFlag = 0
    Screen.MousePointer = 0
End Sub

'option explicit
'44.27
' Here you can add scrolling support to controls that don't normally respond.
' This Sub could always be moved to a module to make scrollwheel behaviour
' generic across forms.
' ===========================================================================
Public Sub MouseWheel(ByVal MouseKeys As Long, ByVal Rotation As Long, ByVal Xpos As Long, ByVal YPos As Long)
  'Exit Sub
  
  Dim ctl As Control
  Dim bHandled As Boolean
  Dim bOver As Boolean
  If Rotation < 0 Then 'down
        Call DoKeydown(vbKeyDown)
  Else
    Call DoKeydown(vbKeyUp)
  End If
'  For Each ctl In Controls
'    ' Is the mouse over the control
'    If DebuggingFlag < 2 Then On Error Resume Next
'    bOver = (ctl.Visible And IsOver(ctl.hWnd, Xpos, Ypos))
'    On Error GoTo 0
'
'    If bOver Then
'      ' If so, respond accordingly
'      bHandled = True
'      Select Case True
'
''        Case TypeOf ctl Is MSFlexGrid
''          FlexGridScroll ctl, MouseKeys, Rotation, Xpos, Ypos
'
''        Case ctl = Form1.Picture7.hDC
''          PictureBox7Zoom ctl, MouseKeys, Rotation, Xpos, Ypos
'
'        Case TypeOf ctl Is PictureBox
'          PictureBoxZoom ctl, MouseKeys, Rotation, Xpos, Ypos
'
'        Case TypeOf ctl Is ListBox, TypeOf ctl Is TextBox, TypeOf ctl Is ComboBox
'          ' These controls already handle the mousewheel themselves, so allow them to:
'          If ctl.Enabled Then ctl.SetFocus
'
'        Case Else
'          bHandled = False
'
'      End Select
'      If bHandled Then Exit Sub
'    End If
'    bOver = False
'  Next ctl
  
End Sub

Private Sub GotoSeqInSchem(GTCS)
DontFlash = 0
FlafinshY = -1
Dim OldVal As Long, NewVal As Long
For Y = 0 To UBound(PermArray, 2)
    If PermArray(0, Y) = GTCS Then
        
        OldVal = VScroll2.Value
        Y = ((Y * 12 + 3) * SpaceAdjust)
        If VScroll2.Max > 0 Then
            If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
                If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
                    NewVal = CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
                    'CLng((y - Picture6.ScaleHeight / 2) / F1VS2Adj)
                Else
                    NewVal = 0
                End If
            Else
                NewVal = VScroll2.Max
            End If
        End If
        Call ScrollToVSPos(VScroll2, OldVal, NewVal)
        
        
        
        PermFlashY = Y
        Y = CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
        
        
        
        Picture6.Refresh
        
        If x = 12345 Then
            
            Picture6.AutoRedraw = False
            Picture6.DrawMode = 13
            Picture6.DrawWidth = 2
            For Z = 0 To 510 Step 5
                If Z > 255 Then
                    CVal = 510 - Z
                Else
                    CVal = Z
                End If
                'Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 12), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255)), B
                Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 11), RGB(BkR + (255 - BkR) * (CVal / 255), BkG - BkG * (CVal / 255), BkB - BkB * (CVal / 255)), B
                
                DS = Abs(GetTickCount)
                Do
                    ES = Abs(GetTickCount)
                    If ES - DS <> 0 Then Exit Do
                    
                Loop
            Next Z
            'VScroll2.Value = (((Y * 12 + 3) * SpaceAdjust + 10) / Picture6.ScaleHeight) * VScroll2.Max
            Picture6.AutoRedraw = True
            Picture6.DrawMode = 13
            Picture6.DrawWidth = 1
        Else
            FlashCol = 510
        End If
        FlashY = Y 'CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
        Timer1.Enabled = True
        Call Timer1_Timer
        Exit For
    End If
Next Y
End Sub


Private Sub A3Seq_Click()
Call DeactivateScans
DoScans(0, 8) = 1
Call Command22_Click

End Sub

Private Sub AcceptMnu_Click()



oxrelx = RelX
oxrely = RelY
Dim NFD As Byte, NFMi As Byte, NFMa As Byte, TBegin As Long, DSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
    'DoEvents
    XX = TRelX
    If DontSaveUndo = 0 Then
        Call SaveUndo
    End If
    MenuUpFlag = 0
    
     
    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        Screen.MousePointer = 11
        Form1.ProgressBar1 = 2
        Form1.SSPanel1.Caption = "Loading minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        Form1.ProgressBar1 = 20
        Form1.SSPanel1.Caption = "Loading major parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
        Form1.ProgressBar1 = 40
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
        
    End If
    
    
    If x = x Then
        
        DSeq = XoverList(SERecSeq, SEPAVal).Daughter
        TSeq = XoverList(SERecSeq, SEPAVal).Daughter
        TProg = XoverList(SERecSeq, SEPAVal).ProgramFlag
       
        'TBegin = XOverlist(SERecSeq, SEPAVal).Beginning
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
        ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
        AXONo = SERecSeq
        'XX = CurrentXover(3)
        
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
        
        Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())
        
        For TProg = 0 To AddNum * 2
        
            Call IndvAcceptEvent(NFMi, DSeq, TProg, TraceNumbMi, TraceMi(), BestXOListMi())
            Call IndvAcceptEvent(NFMa, DSeq, TProg, TraceNumbMa, TraceMa(), BestXOListMa())
            Call IndvAcceptEvent(NFD, DSeq, TProg, TraceNumbD, TraceD(), XoverList())
        
        Next TProg
        'XX = XOverlist(RelX, RelY).Accept
        If NFMa = 0 Then
            Ma = XoverList(SERecSeq, SEPAVal).MajorP
            Mi = XoverList(SERecSeq, SEPAVal).MinorP
            If Ma <= PermNextno Then
                BCurrentXoverMa(Ma) = BCurrentXoverMa(Ma) + 1
                UB = UBound(BestXOListMa, 2)
                If UB < BCurrentXoverMa(Ma) Then
                    UB = BCurrentXoverMa(Ma) + 10
                    UB2 = UBound(BestXOListMa, 1)
                    'Exit Sub
                    ReDim Preserve BestXOListMa(UB2, UB + 10)
                End If
                BestXOListMa(Ma, BCurrentXoverMa(Ma)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMa(Ma, BCurrentXoverMa(Ma)).Daughter = Ma
                
                If NOPINI(0, ENumb) = 2 Then
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MinorP = DSeq
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MajorP = Mi
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 2
                Else
                    If NOPINI(0, ENumb) = 0 Then
                        BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 0
                    Else
                        BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 2
                    End If
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MajorP = DSeq
                End If
            Else
                BCurrentXoverMa(SERecSeq) = BCurrentXoverMa(SERecSeq) + 1
                UB = UBound(BestXOListMa, 2)
                If UB < BCurrentXoverMa(SERecSeq) Then
                    UB = BCurrentXoverMa(SERecSeq) + 10
                    UB2 = UBound(BestXOListMa, 1)
                    ReDim Preserve BestXOListMa(UB2, UB + 10)
                End If
                BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 2 Then
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MinorP = DSeq
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MajorP = Mi
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 2
                Else
                    If NOPINI(0, ENumb) = 0 Then
                        BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 0
                    Else
                        BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 2
                    End If
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MajorP = DSeq
                End If
            End If
            
            
        End If
        
        If NFMi = 0 Then
            Ma = XoverList(SERecSeq, SEPAVal).MajorP
            Mi = XoverList(SERecSeq, SEPAVal).MinorP
            If Mi <= PermNextno Then
                BCurrentXoverMi(Mi) = BCurrentXoverMi(Mi) + 1
                UB = UBound(BestXOListMi, 2)
                If UB < BCurrentXoverMi(Mi) Then
                    UB = BCurrentXoverMi(Mi) + 10
                    UB2 = UBound(BestXOListMi, 1)
                    ReDim Preserve BestXOListMi(UB2, UB)
                End If
                BestXOListMi(Mi, BCurrentXoverMi(Mi)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMi(Mi, BCurrentXoverMi(Mi)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 0 Then
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MinorP = Ma
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MajorP = DSeq
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 1
                Else
                    If NOPINI(0, ENumb) = 1 Then
                        BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 1
                    Else
                        BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 0
                    End If
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MinorP = DSeq
                End If
            Else
                BCurrentXoverMi(SERecSeq) = BCurrentXoverMi(SERecSeq) + 1
                UB = UBound(BestXOListMi, 2)
                If UB < BCurrentXoverMi(SERecSeq) Then
                    UB = BCurrentXoverMi(SERecSeq) + 10
                    UB2 = UBound(BestXOListMi, 1)
                    ReDim Preserve BestXOListMi(UB2, UB + 10)
                End If
                BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 0 Then
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MinorP = Ma
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MajorP = DSeq
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 1
                Else
                    If NOPINI(0, ENumb) = 1 Then
                        BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 1
                    Else
                        BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 0
                    End If
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MinorP = DSeq
                End If
            End If
            
            
            
        End If
        '*****************Need to rearrange NOPINI***********************
       ' For X = 0 To 2
       '     If NOPINI(X, Enumb) = 1 Then
       '         NOPINI(X, Enumb) = 2
       '     ElseIf NOPINI(X, Enumb) = 2 Then
       '         NOPINI(X, Enumb) = 1
       '     End If
       ' Next X
        AXONo = SEPAVal
        RecSeq = DSeq
        'Call UpdateScheme
        Call UpdateEvents(ENumb)
        
        If ItsFinished = 0 Then
            Call IntegrateXOvers(0)
        End If
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        SSPanel6(2).Visible = False
        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        'modify daught, majorp and minorp
        'Use NOPINI to determine which sequences should be Mi and Ma parents
    
        'SEPAVal = AXONo
    
        'Call UpdateConfirm(ActiveSeq)
        'Call UpdateConfirm(ActiveMinorP)
        If DontSaveUndo = 0 Then
            If DSeq = RelX And OSEPAVal = RelY And (RelX > 0 Or RelY > 0) Then
                HighlightFlag = 0
                
                OSEPAVal = AXONo
                PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
                RelX = TSeq
                RelY = AXONo
                exRelX = RelX
                exRely = RelY
                Timer1.Enabled = True
            Else
        
                PermXVal = 0
                PermYVal = 0
                If oxrelx > 0 Or oxrely > 0 Then
                    Call GoToThis(0, RelX, RelY, PermXVal, PermYVal)
                Else
                
                    RelX = 0: RelY = 0
                End If
                Timer1.Enabled = True
            End If
        End If
        Form1.Command10.Enabled = True
        If AcceptChangeFlag = 1 Then AcceptChangeFlag = 2
        If ItsFinished = 0 Then
            If Form2.Visible = True Then
            
                Call UnModNextno
                    
                For x = 0 To 3
                    If x = 1 Then
                        Call ModNextno
                    Else
                        If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                            Call UnModNextno
                        End If
                    End If
                    Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
                    x = x
                Next x
            End If
        End If
        If XOMiMaInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            Form1.ProgressBar1 = 60
            Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            UBXOMi = UBound(BestXOListMi, 2)
            UBXoMa = UBound(BestXOListMa, 2)
            
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Put #FF, , BestXOListMi()
            Close #FF
            MiRec = MiRec - 1
            
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Form1.ProgressBar1 = 80
            Call UpdateF2Prog
            Form1.SSPanel1.Caption = "Writing major parent lists to disk"
            Form1.Refresh: Form2.Refresh
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Put #FF, , BestXOListMa()
            Close #FF
            MaRec = MaRec - 1
            ChDrive oDirX
            ChDir oDirX
            Erase BestXOListMi
            Erase BestXOListMa
            Form1.ProgressBar1 = 100
            
            Form1.SSPanel1.Caption = ""
            
            Form1.ProgressBar1 = 0
            Form1.Refresh: Form2.Refresh
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Screen.MousePointer = 0
        End If
        If RIMode = 1 Then
            Call MakeSummary
            x = x
        End If
        'Timer1.Enabled = True
        Exit Sub
        'DoneTree(1, 3) = 0
        'DoneTree(2, 3) = 0
        'DoneTree(3, 3) = 0
        'DoneTree(4, 3) = 0
        
    End If
     If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
    'DoneTree(0, 3) = 0

    'DoneTree(1, 3) = 0
    'DoneTree(2, 3) = 0
    'DoneTree(3, 3) = 0
    'DoneTree(4, 3) = 0
    If ItsFinished = 0 Then
        If Form2.Visible = True Then
            Call UnModNextno
                
            For x = 0 To 3
                If x = 1 Then
                    Call ModNextno
                Else
                    If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                        Call UnModNextno
                    End If
                End If
                Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
                x = x
            Next x
        End If
    End If
    DoneMatX(1) = 0
    DoneMatX(2) = 0
    DoneMatX(3) = 0
    DoneMatX(4) = 0
    SSPanel6(2).Visible = False
    SSPanel6(0).Visible = True
    SSPanel6(1).Visible = False
    If RIMode = 1 Then
        Call MakeSummary
    End If
    
   If XOMiMaInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        Form1.ProgressBar1 = 60
        Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        UBXOMi = UBound(BestXOListMi, 2)
        UBXoMa = UBound(BestXOListMa, 2)
        
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
        MiRec = MiRec - 1
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Form1.ProgressBar1 = 80
        Call UpdateF2Prog
        Form1.SSPanel1.Caption = "Writing major parent lists to disk"
        Form1.Refresh: Form2.Refresh
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
        MaRec = MaRec - 1
        ChDrive oDirX
        ChDir oDirX
        Erase BestXOListMi
        Erase BestXOListMa
        Form1.ProgressBar1 = 100
        
        Form1.SSPanel1.Caption = ""
        
        Form1.ProgressBar1 = 0
        Form1.Refresh: Form2.Refresh
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Screen.MousePointer = 0
    End If
    
    
    x = x
End Sub

Private Sub AcceptSMnu_Click()




If DontSaveUndo = 0 Then
    
    Form1.SSPanel1.Caption = "Accepting evidence of recombination"
    Form1.ProgressBar1 = 2
    Call UpdateF2Prog
    Call SaveUndo
End If

MenuUpFlag = 0
'doevents
Form1.WindowState = Form1.WindowState
oxrelx = RelX
oxrely = RelY

    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
       Screen.MousePointer = 11
        
        Form1.SSPanel1.Caption = "Loading minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        Form1.ProgressBar1 = 20
        Form1.SSPanel1.Caption = "Loading major parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
        Form1.ProgressBar1 = 40
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
    End If

Dim TBegin As Long, DSeq As Long, TSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
    If x = x Then
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
        ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
        AXONo = SERecSeq
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Daughter >= 0 And XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Daughter <= UBound(Daught, 1) Then
            If Daught(ENumb, XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Daughter) = 0 And XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Accept <> 2 Then
                Daught(ENumb, XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Daughter) = 1
            End If
        End If
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
        Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())
        
        
        Call GroupAcceptEvent(TraceNumbD, TraceD(), XoverList())
        Call GroupAcceptEvent(TraceNumbMi, TraceMi(), BestXOListMi())
        Call GroupAcceptEvent(TraceNumbMa, TraceMa(), BestXOListMa())
        
        
        '*****************Need to rearrange NOPINI***********************
       ' For X = 0 To 2
       '     If NOPINI(X, Enumb) = 1 Then
       '         NOPINI(X, Enumb) = 2
       '     ElseIf NOPINI(X, Enumb) = 2 Then
       '         NOPINI(X, Enumb) = 1
       '     End If
       ' Next X
        AXONo = SEPAVal
        TarSeq = SERecSeq
        AXONoY = -1
        'For X = 0 To NextNo
        '    If Daught(ENumb, X) > 0 And Daught(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    End If
        '    Form1.ProgressBar1 = (X / NextNo) * 100
        'Next X
        Call IntegrateXOvers(0)
        
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        SSPanel6(2).Visible = False
        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        'modify daught, majorp and minorp
        'Use NOPINI to determine which sequences should be Mi and Ma parents
    
        SEPAVal = AXONo
    
        'Call UpdateConfirm(ActiveSeq)
        'Call UpdateConfirm(ActiveMinorP)
        
        If DSeq = RelX And OSEPAVal = RelY And (RelX > 0 Or RelY > 0) Then
            HighlightFlag = 0
            
            OSEPAVal = AXONo
            PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            RelX = TSeq
            RelY = AXONo
            exRelX = RelX
            exRely = RelY
            Timer1.Enabled = True
        Else
    
            PermXVal = 0
            PermYVal = 0
            If oxrelx > 0 Or oxrely > 0 Then
                Call GoToThis(0, RelX, RelY, PermXVal, PermYVal)
            Else
            
                RelX = 0: RelY = 0
            End If
            Timer1.Enabled = True
        End If
        Form1.Command10.Enabled = True
        If AcceptChangeFlag = 1 Then AcceptChangeFlag = 2
'         DoneTree(1, 3) = 0
'        DoneTree(2, 3) = 0
'        DoneTree(3, 3) = 0
'        DoneTree(4, 3) = 0
        'Exit Sub
    End If
     If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
    Form1.Command10.Enabled = True
'    DoneTree(1, 3) = 0
'    DoneTree(2, 3) = 0
'    DoneTree(3, 3) = 0
'    DoneTree(4, 3) = 0
    If Form2.Visible = True Then
        Call UnModNextno
            
        For x = 0 To 3
            If x = 1 Then
                Call ModNextno
            Else
                If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                    Call UnModNextno
                End If
            End If
            Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
            x = x
        Next x
    End If
    DoneMatX(1) = 0
    DoneMatX(2) = 0
    DoneMatX(3) = 0
    DoneMatX(4) = 0
    SSPanel6(2).Visible = False
    SSPanel6(0).Visible = True
    SSPanel6(1).Visible = False
    If RIMode = 1 Then
        Call MakeSummary
    End If
    x = x
    If XOMiMaInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        Form1.ProgressBar1 = 60
        Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        UBXOMi = UBound(BestXOListMi, 2)
        UBXoMa = UBound(BestXOListMa, 2)
        
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
        MiRec = MiRec - 1
        Form1.SSPanel1.Caption = "Writing major parent lists to disk"
        
        Form1.ProgressBar1 = 80
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
        MaRec = MaRec - 1
        ChDrive oDirX
        ChDir oDirX
        Erase BestXOListMi
        Erase BestXOListMa
        Form1.ProgressBar1 = 100
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Screen.MousePointer = 0
    End If
    
End Sub

Private Sub ASisMnu_Click()
    Call DeactivateScans
    DoScans(0, 5) = 1
    Call Command22_Click

End Sub

Private Sub AutoChimMnu_Click()
    Call DeactivateScans
    DoScans(0, 4) = 1
    Call Command22_Click
End Sub


Private Sub AutoMaskmnu_Click()
Dim b As Long, A As Long, Z As Long, x As Long, Y As Double, MAxD As Double, WInD(1) As Double, TotD(1) As Double, CycleC As Long
Form1.SSPanel1.Caption = "Auto-masking to maximise recombination detection power"
CycleC = 0
Screen.MousePointer = 11

Dim SumDist() As Single, DoneDist() As Byte
ReDim SimDist(NextNo) ', DoneDist(Nextno, Nextno)

TripListLen = 0

Dim SimSeq() As Long
ReDim SimSeq(NextNo)

For x = 0 To NextNo
    For Y = 0 To NextNo
        If x <> Y Then
            If Distance(x, Y) > SimDist(x) Then
                SimDist(x) = Distance(x, Y)
                SimSeq(x) = Y
            End If
        End If
    Next Y
Next x


'SS = Abs(GetTickCount)
Do
    CycleC = CycleC + 1
    MAxD = 0
    x = 0
    For Z = 0 To NextNo
        If MaskSeq(Z) = 0 Then
            x = x + 1
        End If
    Next Z
    If x < 4 Then Exit Sub
    
    Dim Correx, AA
    AA = x
    
    Correx = ((AA * (AA - 1) * (AA - 2)) / 6) * (Len(StrainSeq(0)) / XOverWindowX)
    
    If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     Y = Correx / Len(StrainSeq(0))
    
    For A = 0 To NextNo
        If MaskSeq(A) = 0 Then
            If SimDist(A) > MAxD Then
                MAxD = SimDist(A)
                WInD(0) = A
                WInD(1) = SimSeq(A)
            End If
        End If
    Next A
    'XX = Distance(WInD(0), WInD(1))
    If (1 - MAxD) < Y Then 'Or AA > 1200 Then
        'find whichever of wind(0) and wind(1) have the smallest distance on average to other sequences in the alignment
        TotD(0) = 0
        TotD(1) = 0
        
        'first check if both fragments are approximately equal length - if they are not then automatically choose the larger one
        Dim ntPos0 As Long, ntPos1 As Long, Spos As Long
        Spos = Len(StrainSeq(0))
        If SeqSpacesInFileFlag = 0 Then
            If Recompress(Spos) <= UBound(SeqSpaces, 1) And CSeq <= UBound(SeqSpaces, 2) Then
                ntPos0 = (Spos - SeqSpaces(Recompress(Spos), WInD(0)))
                ntPos1 = (Spos - SeqSpaces(Recompress(Spos), WInD(1)))
            Else
                ntPos0 = Len(StrainSeq(0))
                ntPos1 = Len(StrainSeq(0))
                
            End If
        Else
            
            '*********************
            'SeqSpaces single value read from file
            '*********************8
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Dim OS1 As Long, SSX As Long
'            SS = Abs(GetTickCount)
            Spos = Len(StrainSeq(0))
            Open "RDP5SSFile" + UFTag For Binary As #FF
            'ssx = SeqSpaces(recompress(spos),cseq)
            OS1 = WInD(0) * (Len(StrainSeq(0)) + 3)
            If ((((Recompress(Spos) + OS1) - 1) * 4) + 1) > -1 Then
                
                Get #FF, ((((Recompress(Spos) + OS1) - 1) * 4) + 1), SSX
                ntPos0 = Spos - SSX
                
            End If
            'Get #FF, 5, SSX
            'SSVal(1) = SeqSpaces(bb1, RecSeq)
            
            
            
            
            OS1 = WInD(1) * (Len(StrainSeq(0)) + 3)
            If ((((Recompress(Spos) + OS1) - 1) * 4) + 1) > -1 Then
                
                Get #FF, ((((Recompress(Spos) + OS1) - 1) * 4) + 1), SSX
                ntPos1 = Spos - SSX
                
            End If
            Close #FF
'            EE = Abs(GetTickCount)
'            TT = EE - SS
'            x = x
            ChDrive oDirX
            ChDir oDirX
        End If
        If ntPos1 > ntPos0 * 0.95 And ntPos0 > ntPos1 * 0.95 Then
            For A = 0 To NextNo
                TotD(0) = TotD(0) + (1 - Distance(WInD(0), A))
                TotD(1) = TotD(1) + (1 - Distance(WInD(1), A))
            Next A
            If TotD(0) > TotD(1) Then
                A = WInD(1)
                b = WInD(0)
                'MaskSeq(WinD(1)) = 1
                
            Else
                A = WInD(0)
                b = WInD(1)
                'MaskSeq(WinD(0)) = 1
            End If
        Else
            If ntPos0 > ntPos1 Then
                A = WInD(1)
                b = WInD(0)
            Else
                A = WInD(0)
                b = WInD(1)
            End If
        
        End If
        MaskSeq(A) = 1
        'DoneDist(WinD(1), WinD(0)) = 1
        'DoneDist(WinD(0), WinD(1)) = 1
        
        For Y = 0 To NextNo
            If SimSeq(Y) = A Then
                SimDist(Y) = 0
                For x = 0 To NextNo
                    If MaskSeq(x) = 0 And x <> Y Then
                        If SimDist(Y) < Distance(x, Y) Then
                            SimDist(Y) = Distance(x, Y)
                            SimSeq(Y) = x
                        End If
                    End If
                Next x
            End If
        Next Y
        
        
        
    Else
        Exit Do
    End If
    If CycleC <= NextNo Then
        Form1.ProgressBar1 = (Log(CycleC) / Log(NextNo)) * 100
        'Form1.ProgressBar1 = (CycleC / Nextno) * 100
    Else
        Form1.ProgressBar1 = 100
    End If
    Call UpdateF2Prog
Loop






' X = 0
'    For Z = 0 To Nextno
'        If Maskseq(Z) = 0 Then
'            X = X + 1
'        End If
'    Next Z

If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If
'ReDim pMaskSeq(Nextno)
'For X = 0 To Nextno
'    pMaskSeq(X) = Maskseq(X)
'Next X
'EE = Abs(GetTickCount)
'TT = EE - SS '17901 seconds for nextno = 4715
'
''convert to c++
'X = X 'if maxd = 0 then
                    '   exit for
                    'end if
Form1.ProgressBar1 = 100
Call UpdateF2Prog
If TreeTypeFlag = 0 And CLine = "" Then
    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
End If
Screen.MousePointer = 0
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog


End Sub



Private Sub Automaskmnu2_Click()
Call AutoMaskmnu_Click
End Sub

Private Sub BayesMnu_Click()
    TSeqLen = Len(StrainSeq(0))
    TreeTypeFlag = 0
    tTF = CTF
    CTF = 4
    Picture16.AutoRedraw = True
    Form1.SSPanel1.Caption = "Drawing Tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    Command28.Visible = True

    Call Deactivate
    Call GetOutie

    F2TreeIndex = 0
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Form1.Refresh

    If DoneTree(4, 0) = 1 Then
        
    Else

        Call NJTree2(4)

        If AbortFlag = 1 Then
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Screen.MousePointer = 0
            CTF = tTF
            AbortFlag = 0
            Form2.Command2.Enabled = False

            Call Reactivate

            Exit Sub
        End If

    End If

     'Call NJTree(1)
    Picture16.ScaleMode = 3
    Form1.Picture16.ForeColor = 0

    For x = 0 To NextNo
        'If X <> Seq1 And X <> Seq2 And X <> Seq3 Then
        Form1.Picture16.CurrentX = XCord(4, F2TreeIndex, x)
        Form1.Picture16.CurrentY = YCord(4, F2TreeIndex, x)
        Form1.Picture16.Print (OriginalName(x))
        'End If
    Next 'X

    Form1.Label14 = "Bayesian tree ignoring recombination"
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Call Reactivate

    Picture16.Refresh
    Picture16.Enabled = True
    If RelX > 0 Or RelY > 0 Then
        DoTreeColour Picture16, CTF, TreeTypeFlag
    End If
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    'Picture17.Enabled = True
    Command28.Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
End Sub

Private Sub BootscanMnu_Click()
    Call DeactivateScans
    DoScans(0, 2) = 1
    
    Call Command22_Click

End Sub


Private Sub BPDistPltMnu_Click()
Dim OV As Boolean
OV = Form1.Combo1.Enabled
If Combo1.ListCount = 0 Then
    Call DoCombo(0)
End If

If RelX = 0 And RelY = 0 Then
    Command29(1).Enabled = False
ElseIf XoverList(RelX, RelY).Accept = 1 Then
    Command29(1).Enabled = False
End If
If SEventNumber = 0 Then
    Call Command22_Click
    If SEventNumber > 0 Then
        
        Form1.Combo1.Enabled = True
        
        DontDoComboFlag = 1
        If Combo1.ListCount < 17 Then
            Call DoCombo(0)
        End If
        Combo1.ListIndex = 17
        DontDoComboFlag = 0
        CurrentCheck = 15
        Form1.Combo1.Enabled = OV
        
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
        VisFrame = 8
        OptFlag = 41
       ' Form1.Combo1.Enabled = True
    Else
        MsgBox ("There were no detectable recombination events in this alignment")
    End If
Else
    Form1.Combo1.Enabled = True
    DontDoComboFlag = 1
    Combo1.ListIndex = 17
    'XX = Combo1.ListCount
    DontDoComboFlag = 0
    CurrentCheck = 15
    Form1.Combo1.Enabled = OV
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        Call RecombMapIIIS
    Else
        Call RecombMapIII
    End If
    OptFlag = 41
    'Form1.Combo1.Enabled = True
End If
If RelX = 0 And RelY = 0 Then
    Command29(1).Enabled = False
    Combo1.Enabled = False
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub BPDistPltMnu2_Click()
Dim OV As Boolean
OV = Form1.Combo1.Enabled
If Combo1.ListCount = 0 Then
    Call DoCombo(0)
End If

If RelX = 0 And RelY = 0 Then
    Command29(1).Enabled = False
ElseIf XoverList(RelX, RelY).Accept = 1 Then
    Command29(1).Enabled = False
End If
If SEventNumber = 0 Then
    Call Command22_Click
    If SEventNumber > 0 Then
       
        Form1.Combo1.Enabled = True
        DontDoComboFlag = 1
        If Combo1.ListCount < 18 Then
            Call DoCombo(0)
        End If
        Combo1.ListIndex = 18
        DontDoComboFlag = 0
        CurrentCheck = 15
        Form1.Combo1.Enabled = OV
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
        VisFrame = 8
        OptFlag = 41
    Else
        MsgBox ("There were no detectable recombination events in this alignment")
    End If
Else
    Form1.Combo1.Enabled = True
    DontDoComboFlag = 1
    Combo1.ListIndex = 18
    DontDoComboFlag = 0
    CurrentCheck = 15
    Form1.Combo1.Enabled = OV
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        Call RecombMapIIIS
    Else
        Call RecombMapIII
    End If
    VisFrame = 8
    OptFlag = 41
    
End If
If RelX = 0 And RelY = 0 Then
    Command29(1).Enabled = False
    Combo1.Enabled = False
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub C0Mnu_Click(Index As Integer)
DontDoKey = 0
ButtonScrollFlag = 1
GoOn = 0
If Index = 0 Then
    
    If CurScale <> 0 Then
        CurScale = 0
        GoOn = 1
        
    End If
ElseIf Index = 1 Then
    If CurScale <> 1 Then
        CurScale = 1
        GoOn = 1
        
    End If
ElseIf Index = 2 Then
    If CurScale <> 2 Then
        CurScale = 2
        GoOn = 1
        
    End If
ElseIf Index = 3 Then
    If CurScale <> 3 Then
        CurScale = 3
        GoOn = 1
        
    End If
ElseIf Index = 4 Then
    If CurScale <> 4 Then
        CurScale = 4
        GoOn = 1
        
    End If
ElseIf Index = 5 Then
    If CurScale <> 5 Then
        CurScale = 5
        GoOn = 1
    End If
ElseIf Index = 6 Then
    If CurScale <> 6 Then
        CurScale = 6
        GoOn = 1
        
    End If
End If
If GoOn = 1 Then
    If CurMatrixFlag = 2 Then
        Call ModMatMnu_Click
    ElseIf CurMatrixFlag = 1 Then
        Call RecMatMnu_Click
    ElseIf CurMatrixFlag = 14 Then
        Call CMMnu_Click(1)
    ElseIf CurMatrixFlag = 3 Then
        Call RecRCMnu_Click
    ElseIf CurMatrixFlag = 4 Then
        Call RecBPMnu_Click
    ElseIf CurMatrixFlag = 5 Then
        Call LDMatMnu_Click
    ElseIf CurMatrixFlag = 6 Then
        Call RMinMnu_Click
    ElseIf CurMatrixFlag = 7 Then
        Call RMinDMnu_Click
    ElseIf CurMatrixFlag = 8 Then
        
        Call MCMatMnu_Click
        
        
    ElseIf CurMatrixFlag = 11 Then
        Call LMatMnu_Click
    ElseIf CurMatrixFlag = 12 Then
        Call SHMatrixMnu_Click
    ElseIf CurMatrixFlag = 13 Then
        Call RFMatrixMnu_Click
        x = x
    End If
End If
ButtonScrollFlag = 0

End Sub



Private Sub Check1_Click()
ButtonScrollFlag = 1
If CurMatrixFlag = 3 Then
    Call RecRCMnu_Click
End If
ButtonScrollFlag = 0
End Sub

Private Sub CMMnu_Click(Index As Integer)
If NextNo >= 3 Then
    
    If Index = 0 Then
    
        If ButtonScrollFlag = 0 And CurMatrixFlag = 0 Then DoneMatX(0) = 0
        CurMatrixFlag = 0
        Call DrawCompatMat
    
    ElseIf Index = 1 Then
        If ButtonScrollFlag = 0 And CurMatrixFlag = 14 Then DoneMatX(14) = 0
        CurMatrixFlag = 14
        'XX = MatCoord(CurMatrixFlag, 1)
        Call DrawCompatMatTB
        x = x
    End If
    Form1.Check1.Enabled = False
    Call DoMatCap
    SSPanel6(2).Enabled = True
    SSPanel6(2).Enabled = True
    If F1MDF = 0 And OKPress = 0 Then
        SSPanel6(2).Visible = True
        SSPanel6(0).Visible = False
        SSPanel6(1).Visible = False
    End If
    If CurMatrixFlag < 255 Then
        If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
            Command39(1).Enabled = True
        End If
    End If
    Command39(0).Enabled = True
End If

OKPress = 0
x = x
'Call DoMatCap
End Sub

Private Sub CMMnu2_Click()


Call CMMnu_Click(0)
Form1.SSPanel6(2).Enabled = True
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
        Command39(1).Enabled = True
    End If
    Command39(0).Enabled = True
End Sub

Private Sub Combo1_Click()
AllCheckFlag = 0
GDPCFlag = 0

If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
OPAVal = -1
    If RunFlag = 1 And (RelX <> RecSeq Or RelY <> PAVal Or x = x) Then
        If F2ontop <> 1 Then
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
        End If
    End If

    'Command29(0).Enabled = True
    If DontDoComboFlag = 0 Then
        Dim tSeqnum() As Integer
        If LongWindedFlag = 1 Then
           Call ModSeqNum(1, 1, 0)
           
        End If
        Form1.Refresh
        Picture7.ScaleMode = 3
        
        If XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then
            If Combo1.ListIndex < 5 Then
                CurrentCheck = Combo1.ListIndex
            ElseIf Combo1.ListIndex = 5 Then
                CurrentCheck = 10
            ElseIf Combo1.ListIndex = 6 Then
                CurrentCheck = 5
            ElseIf Combo1.ListIndex = 9 Then
                CurrentCheck = 13
            ElseIf Combo1.ListIndex = 8 Then
                CurrentCheck = 55
                Command29(0).Enabled = False
            ElseIf Combo1.ListIndex = 14 Then
                CurrentCheck = 6
            ElseIf Combo1.ListIndex = 15 Then
                CurrentCheck = 11
                Command29(0).Enabled = False
                x = x
            ElseIf Combo1.ListIndex = 16 Then
                CurrentCheck = 12
                Command29(0).Enabled = False
            ElseIf Combo1.ListIndex = 13 Then
                CurrentCheck = 8
            ElseIf Combo1.ListIndex = 17 Or Combo1.ListIndex = 18 Then
                CurrentCheck = 15
            ElseIf Combo1.ListIndex = 12 Then
                CurrentCheck = 9
            ElseIf Combo1.ListIndex = 7 Then
                CurrentCheck = 16
            ElseIf Combo1.ListIndex = 10 Then
                CurrentCheck = 40
            ElseIf Combo1.ListIndex = 11 Then
                CurrentCheck = 41
            Else
                CurrentCheck = Combo1.ListIndex - 2
            End If
        Else 'If CurrentCheck > -1 Then
            If Combo1.ListIndex = 0 Then
                CurrentCheck = 20
            ElseIf Combo1.ListIndex = 1 Then
                CurrentCheck = 21
            ElseIf Combo1.ListIndex = 2 Then
                CurrentCheck = 25
            'ElseIf Combo1.ListIndex = 3 Then
            '    CurrentCheck = 22
                
            ElseIf Combo1.ListIndex = 3 Then
                CurrentCheck = 23
            ElseIf Combo1.ListIndex = 4 Then
                CurrentCheck = 24
            End If
            'CurrentCheck = Combo1.ListIndex + 20
            
            If Combo1.ListIndex = -1 Then
            End If

        End If

        ExeCheckFlag = 1

        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
'            SS = abs(gettickcount)
            'For X = 0 To 80
                Call RDPChecking
'            Next X
'            EE = abs(gettickcount)
'            TT = EE - SS
'            X = X
            '3seq 8062, 5297
            'siscan 16922
            
            'siscan (20 reps) on new 8750, 6031 (cached vrand), 5204 no progressbar, 4891 dopermsxp,2953 with parallelized dopermsxp
            'siscan (80 reps) on new 10266
        ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
            Call TSChecking
        ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            If pGCTripletflag = 0 Then
                Call GCChecking
            Else
                Call GCChecking2
            End If

        ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then

            Call BootscanChecking
        ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then

            Call ChimaeraChecking
        ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then

            Call SiScanChecking
        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then

            Call PhylProChecking
        ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then

            If MCTripletFlag = 0 Then

                Call MaxChiChecking

            Else

                Call MaxChiCheckingII

            End If

        End If

        Dim LineStart As Double
        Dim LineEnd As Double

        If ORFFlag = 1 And ManFlag <> 161 Then
            Picture20.BorderStyle = 0
            LineStart = (Picture20.ScaleWidth / Len(StrainSeq(0))) * RecStart
            LineEnd = (Picture20.ScaleWidth / Len(StrainSeq(0))) * RecEnd

            If LineEnd > LineStart Then
                Picture20.DrawMode = 15
                Picture20.Line (LineStart, 0)-(LineEnd, Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Picture20.DrawMode = 13
            Else
                Picture20.DrawMode = 15
                Picture20.Line (0, 0)-(LineEnd, Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Picture20.Line (LineStart, 0)-(Picture20.ScaleWidth, Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Picture20.DrawMode = 13
            End If

        End If
        
        If LongWindedFlag = 1 Then
            Call UnModNextno
            Call UnModSeqNum(0)
           
            'Seq1 = TreeTraceSeqs(0, Seq1)
            'Seq2 = TreeTraceSeqs(0, Seq2)
            'Seq3 = TreeTraceSeqs(0, Seq3)
            
            'For X = 1 To Len(StrainSeq(0))
            '    SeqNum(X, Seq1) = tSeqNum(X, 0)
            '    SeqNum(X, Seq2) = tSeqNum(X, 1)
            '    SeqNum(X, Seq3) = tSeqNum(X, 2)
            'Next X
        End If
        Form1.ProgressBar1 = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
    End If
    
    
    
    Combo1.Enabled = True
    If CurrentCheck <> 12 And CurrentCheck <> 55 And CurrentCheck <> 11 And CurrentCheck <> 20 And CurrentCheck <> 9 And CurrentCheck <> -1 And CurrentCheck <> 21 And CurrentCheck <> 22 And CurrentCheck <> 24 Then
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    End If
    ExeCheckFlag = 0
    If RIMode = 1 Then Call MakeSummary
End Sub

Private Sub Combo1_DropDown()
'XX = Screen.MousePointer
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub Combo1_GotFocus()
XX = Screen.MousePointer
End Sub

Private Sub Command1_Click()
'XX = Distance(10, 19)

If Skiploadflag = 1 Then GoTo Skipload
StillLoadingFlag = 1
CombinedFileFlag = 0
'SSSS = Abs(GetTickCount)
    Dim FFY As Long, FFX As Long, oDir As String, GoOn As Long, oDirX As String, FF As Long, Dummy As Long, RW As String, RT As String, A As Long, TString As String, Z As Long, ResFlag As Byte, SecondPass As Byte, LPos As Long, PosCx As Long, MaxLen As Long, TestString As String
    Dim AdjustAlign() As Long, SNNextNo As Long, x As Long, oNextno As Long, ShortestLen As Long, Y As Long, PosMSF As Long, PosMeg As Long, PosAlX As Long, PosF As Long, PosGB As Long, PosG As Long, PosGD As Long, PosC As Long, PosNE As Long, PosDM As Long, PosDMB As Long, PosXF As Long, PosPIR As Long
    Dim tStrainseq() As String, TStraiName() As String, ToOriginalName() As String
    Dim OldSeqFile As String, OName As String, PosMugsy As Long
    Dim AFN As Long, NF As Integer, Response As Integer
    '80.7Megs
    x = x
    SecondPass = 0
    On Error GoTo 0
    If (CLine = "" Or CLine = " ") And Form1.Visible = True Then
        Command3.SetFocus
    End If
    Form1.Enabled = False
    If CurrentlyRunningFlag = 1 Then
        Form1.Enabled = True
        StillLoadingFlag = 0
        Exit Sub
    End If
    
    
    Dim oFTag As Long
    oFTag = UFTag
    UFTag = Trim(Str(Abs(GetTickCount)))
    If DatasetNo = 0 Then
        
        oNextno = 0
    
        If NextNo > 0 Then
            ReDim Preserve BusyFlashing(NextNo)
            ReDim Preserve TStraiName(NextNo)
            ReDim Preserve ToOriginalName(NextNo)
            ReDim Preserve tStrainseq(NextNo)
            ReDim Preserve OriginalName(NextNo)
            ReDim Preserve StraiName(NextNo)
            ReDim Preserve StrainSeq(NextNo)
            For x = 0 To NextNo
                TStraiName(x) = OriginalName(x)
                ToOriginalName(x) = OriginalName(x)
                tStrainseq(x) = StrainSeq(x)
            Next
    
            oNextno = NextNo
        End If
    
        ErrorFlag = 0
        OName$ = FName$
        FName$ = ""
        
        If OldFileFlag > 0 And FileList(OldFileFlag) <> "" Then
            FName$ = FileList(OldFileFlag)
            x = Len(FName)
    
            Do While x > 0
    
                If Mid$(FName$, x, 1) = "\" Then Exit Do
                x = x - 1
            Loop
    
            FNameII = Right$(FName, Len(FName) - x)
            
        Else
    
            If CLine <> "" And CLine <> " " Then
                FName$ = InFileX
                If CLine = "EXCEPTION18102001" Then
                    CLine = ""
                End If
                'MsgBox (FName$)
                
                'C:\Mike\circoviruses2.fas
                LPos = 0
                Do
                    Pos = InStr(LPos + 1, FName$, "\", vbBinaryCompare)
                    If Pos = 0 Then Exit Do
                    LPos = Pos
                Loop
                Dim DirName As String
                DirName = Left$(FName$, LPos)
                
                If DirName <> "" Then
                    ChDir DirName
                    ChDrive DirName
                Else
                
                    
                End If
                
                x = LPos
                
        
                FNameII = Right$(FName, Len(FName) - LPos)
                FName = FNameII
            Else
                If InFileX <> "LastSave.rdp5" Then
                    With Form1.CommonDialog1
                        .MaxFileSize = 32000
                        .FLAGS = cdlOFNAllowMultiselect + cdlOFNExplorer
                        .FileName = ""
                        .DefaultExt = "*.*"
                        .Filter = "All Files (*.*)|*.*|RDP5 Project Files (*.rdp5)|*.rdp5|RDP4 Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq|Extended multiple FASTA file (*.xmfa)|*.seq|FASTA Multiple Alignment Format (*.fas)"
                        .FilterIndex = 1 ' Always make the default filestype all
                        .Action = 1 'Specify that the "open file" action is required.
                        FName$ = .FileName  'Stores selected file name in the
                        FNameII = .FileTitle
                        
                    End With
                    
                    Form1.Refresh
                Else
                    FName$ = InFileX
                End If
                Pos = InStr(1, FName$, Chr(0), vbBinaryCompare)
                
                ReDim MultFN(10)
                MultFNum = 0
                If Pos > 0 Then 'ie multiple files have been selected
                    
                    LPos = Pos + 1
                    Pos = InStr(Pos + 1, FName, Chr(0), vbBinaryCompare)
                    MultFNum = 0
                    Do While Pos > 0
                        MultFN(MultFNum) = Mid$(FName, LPos, Pos - LPos)
                        
                        MultFNum = MultFNum + 1
                        LPos = Pos + 1
                        Pos = InStr(Pos + 1, FName, Chr(0), vbBinaryCompare)
                        
                        If MultFNum > UBound(MultFN, 1) Then
                            ReDim Preserve MultFN(UBound(MultFN, 1) + 10)
                            
                        End If
                        If Pos = 0 Then
                            MultFN(MultFNum) = Mid$(FName, LPos, Len(FName) - LPos + 1)
                            Exit Do
                        End If
                    Loop
                    
                    FName$ = MultFN(1)
                    For x = 1 To MultFNum - 1
                        MultFN(x) = MultFN(x + 1)
                    Next x
                    MultFN(MultFNum) = MultFN(0)
                    MultFN(0) = FName$

                Else
                    ReDim MultFN(0)
                    MultFN(0) = FName$
                End If

                
                
            End If
    
        End If
        
        If FName$ = "" Or FName$ = OName$ Then
            If FName$ = OName$ And FName$ <> "" Then
                If CLine = "" Or CLine = " " Then
                    Response = MsgBox("Reload the same file?", 36)
                    If Response = 7 Then
                        Form1.Enabled = True
                        UFTag = oFTag
                        StillLoadingFlag = 0
                        Exit Sub
                    End If
                End If
              
            Else
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            End If
            
        End If
        
        If NextNo > 0 And UCase(Trim(Right$(FName$, 7))) <> ".RDP5ML" Then
            Dim tXOList() As XOverDefine, tXOListMi() As XOverDefine, tXOListMa() As XOverDefine, tCurrentxover() As Integer, tCurrentxoverMi() As Integer, tCurrentxoverMa() As Integer
    'If CombinedFileFlag = 1 Then
            ReDim tXOList(UBound(XoverList, 1), UBound(XoverList, 2))
            ReDim tCurrentxover(UBound(CurrentXOver))
            For x = 0 To UBound(XoverList, 1)
                tCurrentxover(x) = CurrentXOver(x)
                For Y = 0 To tCurrentxover(x)
                    tXOList(x, Y) = XoverList(x, Y)
                Next Y
            Next x
            On Error Resume Next
            UBXO = -1
            UBXO = UBound(BCurrentXoverMi)
            On Error GoTo 0
            If UBXO > -1 Then
            ReDim tCurrentxoverMi(UBound(BCurrentXoverMi)), tCurrentxoverMa(UBound(BCurrentXoverMa))
            
            ReDim tXOListMa(UBound(BestXOListMa, 1), UBound(BestXOListMa, 2))
            ReDim tXOListMi(UBound(BestXOListMi, 1), UBound(BestXOListMi, 2))
            For x = 0 To UBound(BestXOListMi, 1)
                tCurrentxoverMi(x) = BCurrentXoverMi(x)
                For Y = 0 To tCurrentxoverMi(x)
                    tXOListMi(x, Y) = BestXOListMi(x, Y)
                Next Y
            Next x
            For x = 0 To UBound(BestXOListMa, 1)
                tCurrentxoverMa(x) = BCurrentXoverMa(x)
                For Y = 0 To tCurrentxoverMa(x)
                    tXOListMa(x, Y) = BestXOListMa(x, Y)
                Next Y
            Next x
        
            End If
        End If
        
        
        rdptime = Abs(GetTickCount)
        ResFlag = 6
        NextnoSubtract = 0
        
        
        If FName$ <> OName$ And ((Right$(OName$, 3) = "rdp" Or Right$(OName$, 3) = "RDP") And (Right$(FName$, 3) = "rdp" Or Right$(FName$, 3) = "RDP")) Then
            If CLine = "" Or CLine = " " Then
                Response = MsgBox("Would you like to replace the file you currently have loaded?" & Chr$(13) & Chr$(10) & Chr$(13) & Chr$(10) & "Press 'Yes' to replace file and 'No' to append the new file to the already loaded file", 36, "RDP Warning") ' vbYesNoCancel)
            End If
            ResFlag = Response
            If Response = 6 Then
                'BSStepsize = BSStepsize / FSM
            ElseIf Response = 2 Then
                'NextnoSubtract = Nextno
            ElseIf Response = 7 Then
                NextnoSubtract = NextNo
                CombinedFileFlag = 1
            End If
        End If
        If Mid$(Right$(FName$, 4), 1, 1) = "." Then
            DefExt = Right$(FName$, 4)
        Else
            DefExt = ".*"
        End If
    
        Screen.MousePointer = 11
        SSPanel1.Caption = "Loading File"
        ProgressBar1.Value = 1
        Call UpdateF2Prog
        Form1.Refresh
'        SS = Abs(GetTickCount)
'        SSS = Abs(GetTickCount)
        
        
        If MultFNum > 0 Then
            
            If CLine = "" Or CLine = " " Then
                Response = MsgBox("You have selected multiple files. Would you like these appended and then analysed? Pressing 'No' will result in the files being analsyed separately with results for each being written to the same directory as the input files but to separate .rdp, .csv and .fas files (with similar names to those of their associated input files).", 36)
            Else
                Response = 7
            End If
            If Response = 7 Then
                AutoMultFlag = MultFNum
                MultFNum = 0
                Dim OverView() As String, OverviewHotspots() As String, OverviewHotspots2() As String
                ReDim OverView(AutoMultFlag + 1), OverviewHotspots(AutoMultFlag + 1), OverviewHotspots2(AutoMultFlag + 1)
            Else
                AutoMultFlag = 0
            End If
        End If
        
        NF = FreeFile
        AFN = 0
        
DoNextAFN:
        
        If AutoMultFlag > 0 Then
            FName$ = MultFN(AFN)
        End If
        On Error GoTo FileNotFound
        Open FName$ For Binary Access Read As #NF
        On Error GoTo 0
        RLFlag = 0
        OldSeqFile = SeqFile
        GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwTotalPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        WholeFileFlag = 0

        If LOF(NF) < 50000000 Then 'Allow whole file to be loaded if it will take up less than 1/10 of total RAM
            WholeFileFlag = 1
'            XX = LOF(NF)
            
            SeqFile = String$(LOF(NF), " ")
            Get #NF, 1, SeqFile

        Else
            SeqFile = String$(100000, " ")
            Get #NF, 1, SeqFile
        End If
'        XX = Len(SeqFile)
        Close #NF
        
        
        
        
        
        
        
        
        PFName = FName$
        Dim PosRDP5 As Long
        PosRDP5 = InStr(1, SeqFile, "RDP5 Project File", vbTextCompare)
        If PosRDP5 = 0 Then
            Dim PosGene As Long
            PosGB = InStr(1, SeqFile, "ACCESSION", vbBinaryCompare)
            If PosGB = 0 Then
                PosGB = InStr(1, SeqFile, "LOCUS", vbBinaryCompare) 'clc genbank files don't have accession numbers in them
                If PosGB > 0 Then
                    PosGB = InStr(1, SeqFile, "FEATURES", vbBinaryCompare)
                    If PosGB > 0 Then
                        PosGB = InStr(1, SeqFile, "DEFINITION", vbBinaryCompare)
                    End If
                End If
                If PosGB = 0 Then
                    PosGene = InStr(1, SeqFile, "[orf", vbTextCompare)
                    If PosGene = 0 Then
                        PosGene = InStr(1, SeqFile, "[gene", vbTextCompare)
                        If PosGene = 0 Then
                            PosGene = InStr(1, SeqFile, "[domain", vbTextCompare)
                            If PosGene = 0 Then
                                
                                PosGene = InStr(1, SeqFile, "[motif", vbTextCompare)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        Dim PosIL As Long
        PosIL = InStr(1, SeqFile, "[interact", vbTextCompare)
                
        If Len(SeqFile) < 100 And PosGB = 0 And PosGene = 0 And PosIL = 0 Then 'only let the program run through if the file is big enoug or its a genebank/orfmap file
    
            If CLine = "" Or CLine = " " Then
                
                Response = MsgBox("The file you specified contains no data", vbInformation)
                Form1.ProgressBar1 = 0
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
                Screen.MousePointer = 0
                FName$ = ""
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            Else
                Response = MsgBox("The file you specified in the command line contains no data.  Continue with the program?", vbYesNo)
    
                If Response = 6 Then
                    Form1.ProgressBar1 = 0
                    Form1.SSPanel1.Caption = ""
                    Call UpdateF2Prog
                    Screen.MousePointer = 0
                    Picture1.BackColor = Form1.BackColor
                    Picture3.BackColor = Form1.BackColor
                    Picture4.BackColor = Form1.BackColor
                    Picture11.BackColor = Form1.BackColor
                    Picture13.BackColor = Form1.BackColor
                    ErrorFlag = 1
                    CLine = ""
                    FName$ = ""
                    Form1.Enabled = True
                    UFTag = oFTag
                    StillLoadingFlag = 0
                    Exit Sub
                Else
                    End
                End If
    
            End If
    
        End If
    
        Form1.Refresh
        ProgressBar1.Value = 2
        Call UpdateF2Prog
        BigFileFlag = 0
        
        
        If FName$ = "" Then
            Screen.MousePointer = 0
            Form1.SSPanel1.Caption = ""
            Form1.Enabled = True
            UFTag = oFTag
            StillLoadingFlag = 0
            Exit Sub
        ElseIf Right$(FName$, 4) = ".ali" Or Right$(FName$, 4) = ".ALI" And x = 123456 Then
            ReDim StrainSeq(200)
            ReDim OriginalName(200)
    
            Call LoadALI
    
        ElseIf Right$(FName$, 4) = ".msd" Or Right$(FName$, 4) = ".MSD" And x = 1234784 Then
            ReDim StrainSeq(200)
            ReDim OriginalName(200)
    
            Call LoadMSD
    
        Else  'no identifiable sequence file extention
            'Check for clues within the file.
            If PosRDP5 = 0 Then
                Dim PosSS As Long, PosPDB As Long, PosStk, PosMfa As Long, PosSSX As Long
                PosSSX = InStr(1, SeqFile, "[siteset]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[sitelist]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[site set]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[site list]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[Site Set]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[Site List]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[SiteSet]", vbBinaryCompare)
                If PosSSX = 0 Then PosSSX = InStr(1, SeqFile, "[SiteList]", vbBinaryCompare)
               
                PosStk = InStr(1, SeqFile, "STOCKHOLM 1.0", vbBinaryCompare)
                PosPDB = InStr(1, SeqFile, "HEADER", vbBinaryCompare)
                If PosPDB = 0 Then 'TITLE
                    PosPDB = InStr(1, SeqFile, "TITLE", vbBinaryCompare)
                End If
                PosSS = InStr(1, SeqFile, "dG =", vbBinaryCompare)
                PosPIR = InStr(1, SeqFile, ">DL;", vbBinaryCompare)
                PosDMB = InStr(1, SeqFile, "MAXLENGTH:", vbBinaryCompare)
                PosAlX = InStr(1, SeqFile, "AlignmentProject", vbBinaryCompare)
                PosF = InStr(1, SeqFile, ">", vbBinaryCompare)
                PosC = InStr(1, SeqFile, "CLUSTAL", vbTextCompare)
                
                
                If PosC = 0 Then
                    PosC = InStr(1, SeqFile, "MUSCLE", vbTextCompare)
                End If
                If PosC = 0 Then
                    PosC = InStr(1, SeqFile, "Clustal", vbBinaryCompare)
                End If
                If PosC = 0 Then
                    PosC = InStr(1, SeqFile, "clustal", vbBinaryCompare)
                End If
                If PosC = 0 Then
                    PosCx = InStr(1, SeqFile, "*****", vbTextCompare)
                End If
                PosG = InStr(1, SeqFile, "PileUp", vbBinaryCompare)
                PosNE = InStr(1, SeqFile, "#NEXUS", vbBinaryCompare)
                If PosNE = 0 Then
                    PosNE = InStr(1, SeqFile, "#nexus", vbBinaryCompare)
                End If
                PosDM = InStr(1, SeqFile, "Multiple_Sequence_Alignment", vbBinaryCompare)
                PosXF = InStr(1, SeqFile, "{", vbBinaryCompare)
                
                PosMSF = InStr(1, SeqFile, "MSF", vbBinaryCompare)
                PosMeg = InStr(1, SeqFile, "#mega", vbBinaryCompare)
                PosMfa = InStr(1, SeqFile, "#FormatVersion", vbBinaryCompare)
                If PosMfa = 0 And PosF > 0 Then
                    'check whether the fasta file isn't actually an mfa file
                    If Right$(FName$, 4) = "xmfa" Then PosMfa = 1
                
                End If
                '#FormatVersion'dG =
                If PosMeg = 0 Then
                    PosMeg = InStr(1, SeqFile, "#MEGA", vbBinaryCompare)
                End If
                
                PosMugsy = InStr(1, SeqFile, "maf version", vbTextCompare)
                
                If PosNE = 0 And PosMugsy = 0 Then
                    PosGD = InStr(1, SeqFile, "#", vbBinaryCompare)
                End If
            End If
            'folding file
            If UCase(Trim(Right$(FName$, 7))) = ".RDP5ML" Then
                Call LoadActualEvents(ActualEventList(), FName$, NumActualEvents)
                FName = OName
                'ExRecFlag = 203'old way using rdp5ml
                ExRecFlag = 210
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            ElseIf PosSSX > 0 Then
                
                
                Call LoadSHAPE(FName)
                FName = OName
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            ElseIf PosIL > 0 Then
                Call LoadInteractions(FName)
                FName = OName
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                'XX = InteractList(0, 0)
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            ElseIf PosSS > 0 Then
                SSFoldFile = FName
                FName = OName
                Call OverlayMatrices
                ProgressBar1 = 100
                Screen.MousePointer = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            ElseIf PosGene > 0 Then
                Call ReadCoords2(FName)
                FName = OName
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            
            ElseIf PosPDB = 1 Then
                PDBFile = FName
                FName = OName
                
                If NextNo > 0 Then
    
                    Call OpenPDB
    
                Else
                    Response = MsgBox("You need to open an alignment file before opening a .pdb file.", 48)
                End If
                
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
                
            End If
            'GenBank file
    
            
                
            If PosGB > 0 And Right$(FName$, 4) <> ".rdp" And Right$(FName$, 4) <> ".RDP" Then
    
                If NextNo > 0 Then
                    RDPLGBFlag = 1
                    Call LoadGenBank(SeqFile)
                    
'                    For X = 1 To GeneNumber
'                        If GeneList(X).StartInAlign = -1 Then
'                            For Y = X + 1 To GeneNumber
'                                If GeneList(Y).StartInAlign > -1 And GeneList(Y).EndInAlign > -1 Then
'                                    GeneList(X).End = GeneList(Y).End
'                                    GeneList(X).EndInAlign = GeneList(Y).EndInAlign
'                                    GeneList(X).ExonNumber = GeneList(Y).ExonNumber
'                                    GeneList(X).Frame = GeneList(Y).Frame
'                                    GeneList(X).IntronFlag = GeneList(Y).IntronFlag
'                                    GeneList(X).Name = GeneList(Y).Name
'                                    GeneList(X).Orientation = GeneList(Y).Orientation
'                                    GeneList(X).Product = GeneList(Y).Product
'                                    GeneList(X).Start = GeneList(Y).Start
'                                    GeneList(X).StartInAlign = GeneList(Y).StartInAlign
'                                    GeneList(Y).StartInAlign = -1
'                                    GeneList(Y).EndInAlign = -1
'                                End If
'                            Next Y
'
'                        End If
'                    Next X
'                    For X = 1 To GeneNumber
'                        If GeneList(X).StartInAlign = -1 Then
'                            GeneNumber = X - 1
'                            Exit For
'                        End If
'                    Next X
'                    For X = 1 To GeneNumber
'                        If GeneList(X).Orientation = 1 Then
'                            If GeneList(X).EndInAlign > Len(StrainSeq(0)) Then
'                                GeneList(X).EndInAlign = GeneList(X).EndInAlign - Len(StrainSeq(0))
'                            End If
'                        ElseIf GeneList(X).Orientation = 2 Then
'                            If GeneList(X).StartInAlign > Len(StrainSeq(0)) Then
'                                GeneList(X).StartInAlign = GeneList(X).StartInAlign - Len(StrainSeq(0))
'                            End If
'                        End If
'                    Next X
                    
                    
                    Call FillGeneSEPos
                    Timer3.Enabled = False
                    Timer3.Interval = 100
                    Form5.Timer3.Enabled = True
                    F5T3Executing = 0
                    Timer4.Enabled = False
                    Timer4.Interval = 100
                    Form5.Timer4.Enabled = True
                    F5T1Executing = 0
                    
                    RDPLGBFlag = 0
                    
                    
                    
                    Call FillGeneSEPos
                Else
                    Response = MsgBox("You need to open an alignment file before opening a GenBank file.", 48)
                End If
    
                GBFile = SeqFile
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                Form1.Enabled = True
                UFTag = oFTag
                StillLoadingFlag = 0
                Exit Sub
            End If
            
            Form1.Enabled = False
            LoadBusy = 1
            'Open up some space to recieve an as yet undetermined number of sequences
            If ResFlag = 6 Then
                ReDim StrainSeq(200)
                ReDim OriginalName(200)
            Else
                ReDim Preserve StrainSeq(200 + NextNo)
                ReDim Preserve OriginalName(200 + NextNo)
            End If
            
            
            If PosRDP5 > 0 Then
                '66.6 megs
                Call ShutRunning
                Call ReadRDP5FileA
            ElseIf PosMugsy > 0 Then
                ActualFName = FName
                Call LoadMugsy
            ElseIf PosDMB > 0 Then 'DNAMan File
                ActualFName = FName
                Call LoadMSD
            ElseIf PosMfa > 0 Then
                ActualFName = FName
                Call LoadMFA
            ElseIf PosMeg > 0 Then 'Mega File
                
                ActualFName = FName
                Call LoadMeg
            ElseIf PosStk > 0 Then
                ActualFName = FName
                Call LoadMSA
            ElseIf PosMSF > 0 And PosMSF < 200 Then 'MSF File
                ActualFName = FName
                Call LoadMSF
            ElseIf PosPIR > 0 Then 'PIR File
                ActualFName = FName
                Call LoadPIR
    
            ElseIf PosDM > 0 Then 'DNAMan File
                ActualFName = FName
                Call LoadDNAMAN1
    
            ElseIf PosAlX > 0 Then
                ActualFName = FName
                Call LoadAlignX
    
            ElseIf PosF < 20 And PosF > 0 Then ' it is probably a FASTA file
                'XX = Response
                If ResFlag = 6 Then
                    NextNo = -1
                    SNNextNo = 0
                Else
                    SNNextNo = NextNo + 1
                End If
                ActualFName = FName
                Call LoadFASTA
                'XX = StrainSeq(2)
                x = x
                'If Response <> 6 Then
                '    Call DoAlnAddj(SNNextNo, AdjustAlign())
                'End If
            ElseIf PosXF < 20 And PosXF > 0 Then ' it is probably a FormatX file
                ActualFName = FName
                Call LoadFormatX
    
            ElseIf PosGD < 20 And PosGD > 0 Then 'it is probably a GDE file
                ActualFName = FName
                Call LoadGDE
    
            ElseIf PosG > 0 Then ' it is probably a GCG file
                ActualFName = FName
                Call LoadGCG
    
            ElseIf PosC > 0 Then ' it is probably a Clustal file
                ActualFName = FName
                Call LoadCLUSTAL
    
            ElseIf PosNE > 0 Then ' it is probably a Nexus file
                ActualFName = FName
                Call LoadNEXUS
            ElseIf PosCx > 0 Then
                ActualFName = FName
                Call LoadCLUSTAL
            Else ' If its none of the above lets see if its a phylip file
                ActualFName = FName
                Call LoadPhylip
    
            End If
    
        End If
        
        
'        For x = 1 To Len(StrainSeq(0))
'            If Mid$(StrainSeq(1), x, 1) <> "-" Then
'                x = x
'            End If
'        Next x
        
        'If (Nextno * Len(StrainSeq(0))) > 100000000 Then 'all a max of 0.1*2 gigs for working seqnum
        '    MemPoc = CLng(100000000 / Len(StrainSeq(0)))
        'End If
        'XX = Len(StrainSeq(0))
'        If Len(StrainSeq(0)) > 10000 Then
'            MemPoc = CLng(PermMemPoc * 10000 / Len(StrainSeq(0)))
'        End If
        
        If NextNo > MemPoc And PosRDP5 = 0 Then
            'catch high sequence numbers here, split them into smaller datasets ~500 sequences long
            'process them individually through command 1 and then save trematrices, distancematrices etc to disk for later use when
            'analysing recombination
            
            Call SplitThingsUp10
            
            SplitFlag = 0
Skipload:
            'Exit Sub
            'ResFlag = 6
        Else
            SplitFlag = 0
        End If
        
        Form1.Enabled = True
        LoadBusy = 0
        'XX = NextNo
        
        
        If PosRDP5 = 0 Then
        '1.797s for a 1100 sequence file
            SSS = Abs(GetTickCount)
            
            'Git rid of excess space
            
            'get rid of empty sequences and make all sequences the same length
            MaxLen = 0
            If BigFileFlag = 1 Then
                For x = 1 To NextNo
                    StrainSeq(x) = ""
                
                Next x
                MaxLen = Len(StrainSeq(0))
            Else
            
                For x = 0 To NextNo
                    If MaxLen < Len(StrainSeq(x)) Then
                        MaxLen = Len(StrainSeq(0))
                    End If
                Next x
                For x = 0 To NextNo
                    If Len(StrainSeq(x)) < MaxLen Then
                    
                        StrainSeq(x) = StrainSeq(x) + String(MaxLen - Len(StrainSeq(x)), "-")
                    End If
                Next x
            End If
            
            
            TestString = String(Len(StrainSeq(0)), "-")
            If BigFileFlag = 0 Then
                x = 0
                Do
                    
                    
                    
                    If TestString = StrainSeq(x) Then
                        If x < NextNo Then
                            'StraiName(X) = StraiName(Nextno)
                            OriginalName(x) = OriginalName(NextNo)
                            StrainSeq(x) = StrainSeq(NextNo)
                            NextNo = NextNo - 1
                        Else
                            NextNo = NextNo - 1
                            Exit Do
                        End If
                        NextNo = NextNo - 1
                    Else
                        x = x + 1
                    End If
                    
                    If x > NextNo Then Exit Do
                Loop
            End If
            

            If NextNo = 2 Then
                MsgBox ("I need four or more sequences to be able to properly analyse recombination. I have therefore duplicated the last sequence in the alignment")
                NextNo = NextNo + 1
                ReDim Preserve StrainSeq(NextNo)
                ReDim Preserve OriginalName(NextNo)
                ReDim Preserve StraiName(NextNo)
                'OriginalName(x)
                StrainSeq(NextNo) = StrainSeq(2)
                StraiName(NextNo) = StraiName(2)
                OriginalName(NextNo) = OriginalName(2)
            End If
            If (NextNo < 2 Or ErrorFlag = 1 Or val(StrainSeq(0)) <> 0) And BigFileFlag = 0 Then
        
                If NextNo = -1 Or (Len(StrainSeq(0)) < 10 And BigFileFlag = 0) Then
                    Response = MsgBox("I could not recognise this DNA alignment file format" + Chr$(13) + "Send it as an attatchment to darrenpatrickmartin@gmail.com and he'll fix the problem", 48)
                    
                    If RunFlag = 0 And ManFlag = -1 Then
                        Picture1.BackColor = Form1.BackColor
                        Picture3.BackColor = Form1.BackColor
                        Picture4.BackColor = Form1.BackColor
                        Picture11.BackColor = Form1.BackColor
                        Picture13.BackColor = Form1.BackColor
                    End If
        
                    Screen.MousePointer = 0
                    ProgressBar1 = 0
                    SSPanel1.Caption = ""
                    Call UpdateF2Prog
                ElseIf NextNo >= 0 And NextNo < 2 Then
                    If NextNo = 0 Then
                        Response = MsgBox("I only read one sequence.  I need three or more sequences before I can detect recombination.  If there is more than one sequence in the file please send it as an attachment to darrenpatrickmartin@gmail.com and he'll fix the problem.", 48)
                    ElseIf NextNo = 1 Then
                        Response = MsgBox("I only read two sequences.  I need three or more sequences before I can detect recombination.  If there are more than two sequences in the file please send it as an attachment to darrenpatrickmartin@gmail.com and he'll fix the problem.", 48)
                    
                    ElseIf NextNo = 2 Then
                        Response = MsgBox("I only read two sequences.  I need three or more sequences before I can detect recombination.  If there are more than two sequences in the file please send it as an attachment to darrenpatrickmartin@gmail.com and he'll fix the problem.", 48)
                    End If
                End If
        
                If DebuggingFlag < 2 Then On Error Resume Next
                Close #1
                On Error GoTo 0
        
                If oNextno > 0 Then
                    NextNo = oNextno
                    ReDim OriginalName(NextNo + 10)
                    ReDim Preserve StraiName(NextNo + 10)
                    ReDim StrainSeq(NextNo + 10)
        
                    For x = 0 To NextNo
                        StraiName(x) = TStraiName(x)
                        OriginalName(x) = ToOriginalName(x)
                        StrainSeq(x) = tStrainseq(x)
                    Next
        
                Else
                    NextNo = 0
                End If
        
                ErrorFlag = 0
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                FName$ = ""
                SeqFile = OldSeqFile
                UFTag = oFTag
                Form1.Enabled = True
                StillLoadingFlag = 0
                Exit Sub
            End If
            If BigFileFlag = 0 Then
                For x = 0 To NextNo
            
                    If Len(StrainSeq(x)) < 5 Or val(StrainSeq(x)) <> 0 Then
                        'ErrorFlag = 1
                        NextNo = x - 1
                        If NextNo < 2 Then ErrorFlag = 1
                        Exit For
                    End If
            
                Next
            End If
        
            ReDim TreeTestStats(3, 0)
        
        Else 'if this is a rdp5file
            If Len(StrainSeq(0)) = 0 Then
                If Right(LCase(FName), 13) <> "lastsave.rdp5" Then
                    Response = MsgBox("Something went wrong while loading this file." + Chr$(13) + "Send it as an attatchment to darrenpatrickmartin@gmail.com and he'll fix the problem", 48)
                End If
                If oNextno > 0 Then
                    NextNo = oNextno
                    ReDim OriginalName(NextNo + 10)
                    ReDim Preserve StraiName(NextNo + 10)
                    ReDim StrainSeq(NextNo + 10)
        
                    For x = 0 To NextNo
                        StraiName(x) = TStraiName(x)
                        OriginalName(x) = ToOriginalName(x)
                        StrainSeq(x) = tStrainseq(x)
                    Next
        
                Else
                    NextNo = 0
                End If
            
                ErrorFlag = 0
                Screen.MousePointer = 0
                ProgressBar1 = 0
                SSPanel1.Caption = ""
                Call UpdateF2Prog
                FName$ = ""
                SeqFile = OldSeqFile
                UFTag = oFTag
                Form1.Enabled = True
                StillLoadingFlag = 0
                Exit Sub
            End If
        End If
        
        
        
        
        Dim NeededMem, TotM
        
        ReDim Preserve StrainSeq(NextNo + 1): ReDim Preserve OriginalName(NextNo + 1), TreeStrainName(NextNo + 1)
        'record originalname
        ReDim Preserve StraiName(NextNo + 1)
        'XX = StraiName(9)
        If PosRDP5 = 0 Then
            For x = 0 To NextNo
                StraiName(x) = OriginalName(x)
            Next x
        End If
        'XX = StraiName(9)
        For x = 0 To NextNo
            TreeStrainName(x) = OriginalName(x)
        Next x
        
        SeqFile = "" 'Free the 1M+ that this string was using
        
        If Form1.ProgressBar1.Value < 25 Then Form1.ProgressBar1.Value = 25
        
        Call UpdateF2Prog
        Form1.Picture22.Visible = False 'closes ancestral sequence display
        If AncSeqFlag = 1 Then
            AncSeqFlag = 0
            Call ResizeForm1
        End If
        SearchWholeDBFlag = 0
        PermNextno = NextNo: TreeNextno = NextNo
        LastTop = -1
        LastBottom = -1 'makes sure the whole sequence display is redrawn
        ReDim BusyFlashing(NextNo)
        BackUpNextno = NextNo
        If PosRDP5 = 0 Then
            Call ShutRunning
        End If
        DontLoadExcludes = 0
        DatasetName = ""
        BPProbDistFlag = 0
        FlashntNum = 0
        T4TransCount = 0
        oMCCorrection = MCCorrection
        MCCorrection = 0
        DistanceInFileFlag = 0
        TempTreeDistanceDumpFlag = 0
        FubValidInFile = 0
        PermSeqNumInFile = 0
        If SeqSpacesTempFlag <> 3 Then SeqSpacesInFileFlag = 0
        uSeqNuminFile = 0
        TreeMatrixInFileFLag = 0
         XOMiMaInFileFlag = 0
         StrainSeqOnDisk = 0
         'XX = Nextno
         VRandOnFileFlag = 0
         TreeXInFileFlag = 0
         LoadSeqNumFromFile = 0
         CurWothwhilePos = 0
         MaRec = 0
         MiRec = 0
         VS4Max = 0
         VS4Max2 = 0
         InteractListLen = -1
         SSS = Abs(GetTickCount)
         
        
        '0.062 seconds for a 1100 sequence file
       
        For x = 0 To NextNo
            
            'Crop to 40 characters if longer
            If Len(StraiName(x)) > 40 Then StraiName(x) = Left$(StraiName(x), 40)
            
            'Replace Gaps in sequence names with "_"
            
            Do
                Pos = InStr(1, StraiName(x), " ", vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(StraiName(x), Pos, 1) = "_"
                Else
                    Exit Do
                End If
            Loop
        Next x
    End If
    SSS = Abs(GetTickCount)
        
        '0.000 seconds for a 1100 sequence file
     
RedoThis:
    'Get  third positions if necessary
    
    If PosRDP5 = 0 Then
        If BigFileFlag = 0 Then
            If ThirdFlag = 1 Then
                For Z = 0 To NextNo
                    TString = ""
                    For Y = 3 To Len(StrainSeq(Z)) Step 3
                        TString = TString + Mid(StrainSeq(Z), Y, 1)
                    Next Y
                    StrainSeq(Z) = TString
                Next Z
                        
            End If
    '        SS = abs(gettickcount)
            For x = 0 To NextNo
                For Y = 0 To 32
                    Pos = InStr(1, StrainSeq(x), Chr(Y), vbBinaryCompare)
                    If Pos > 0 Then
                        StrainSeq(x) = Left(StrainSeq(x), Pos - 1) + Mid(StrainSeq(x), Pos + 1, Len(StrainSeq(x)))
                    End If
                Next Y
            Next x
    '        EE = abs(gettickcount)
    '        TT = EE - SS
    '        '0.968 seconds for freds 3800 seq alignment
    '        X = X
    
            
    
    
        End If
        Dim BrNum As Long, AnswerX As Byte
        ReDim RBPPos(3)
        ReassortmentFlag = 0
    
        'Check for reassortment analysis
        
        If BigFileFlag = 0 Then
            For x = 0 To CInt(NextNo / 2)
                Pos = InStr(1, StrainSeq(x), "!", vbBinaryCompare)
                If Pos > 0 Then
                    Exit For
                End If
            Next x
            If Pos > 0 Then
                BrNum = 1
                For x = 1 To NextNo
                    If Mid$(StrainSeq(x), Pos, 1) = "!" Then
                        BrNum = BrNum + 1
                    End If
                Next x
                If BrNum > 0 Then 'Nextno / 10 Then
                    If CLine = "" Or CLine = " " Then
                        AnswerX = 6
                    Else
                    
                        AnswerX = MsgBox("Would you like to analyse this dataset for reassortment?  If you press 'NO' reassortment and recombination events will both be treated as recombination events. If you press 'YES' RDP will try to differentiate between recombination and reassortment events (recombination events with breakpoints that fall near the genome segment junctions will be treated as reassortment events).", vbYesNo)
                    End If
                    If AnswerX = 7 Then
                    
                        ReassortmentFlag = 0
                    Else
                        ReassortmentFlag = 1
                        'Find Acceptable breakpoint positions
                        RBPNum = 1
                        RBPPos(1) = 1
                        Pos = 0
                        Do
                            Pos = InStr(Pos + 1, StrainSeq(0), "!", vbBinaryCompare)
                            If Pos > 0 Then
                                'cycle to the last "!"
                                A = Pos + 1
                                Do
                                    If A < Len(StrainSeq(0)) Then
                                        If Mid$(StrainSeq(0), A, 1) <> "!" Then
                                            Exit Do
                                        End If
                                    Else
                                        A = Len(StrainSeq(0))
                                        Exit Do
                                    End If
                                    A = A + 1
                                Loop
                                Pos = CLng(Pos + (A - Pos) / 2)
                                
                                
                                RBPNum = RBPNum + 1
                                If RBPNum > UBound(RBPPos, 1) Then
                                    ReDim Preserve RBPPos(RBPNum + 10)
                                End If
                                RBPPos(RBPNum) = Pos
                                Pos = A
                            Else
                                
                                RBPNum = RBPNum + 1
                                If RBPNum > UBound(RBPPos, 1) Then
                                    ReDim Preserve RBPPos(RBPNum + 10)
                                End If
                                RBPPos(RBPNum) = Len(StrainSeq(0))
                                Exit Do
                            End If
                        Loop
                        
                        
                    End If
                Else
                    ReassortmentFlag = 0
                End If
            Else
                ReassortmentFlag = 0
            End If
        End If
     
        If BigFileFlag = 0 Then
            For x = 0 To NextNo
                StrainSeq(x) = StrConv(StrainSeq(x), 1)
            Next
        End If
        
        If BigFileFlag = 0 Then
            Dim tNT As String
            For x = 0 To NextNo
                tNT = Right$(StrainSeq(x), 1)
                If tNT <> "A" And tNT <> "C" And tNT <> "G" And tNT <> "T" And tNT <> "." And tNT <> "-" And tNT <> "U" Then
                    StrainSeq(x) = Left$(StrainSeq(x), Len(StrainSeq(x)) - 1)
                End If
        
            Next
            'replace Us in strainseq with Ts
            
            For x = 0 To NextNo
                Pos = 1
                Do While Pos > 0
                    Pos = InStr(Pos, StrainSeq(x), "U", vbBinaryCompare)
                    If Pos > 0 Then
                        Mid$(StrainSeq(x), Pos, 1) = "T"
                    Else
                        Exit Do
                    End If
                Loop
            
            Next x
            
        End If
        
        If BigFileFlag = 0 Then
    'Makes every sequence the length of the longest sequence
            ShortestLen = 0
        
            For x = 0 To NextNo
        
                If Len(StrainSeq(x)) > ShortestLen Then
                    ShortestLen = Len(StrainSeq(x))
                End If
        
            Next ''X
        
            For x = 0 To NextNo
        
                If Len(StrainSeq(x)) < ShortestLen Then
                    StrainSeq(x) = StrainSeq(x) + String$(ShortestLen - Len(StrainSeq(x)), "-")
                End If
        
            Next ''X
           
           
        
        
            If Len(StrainSeq(NextNo)) > ShortestLen Then
                StrainSeq(NextNo) = Left$(StrainSeq(NextNo), Len(StrainSeq(0)))
            ElseIf Len(StrainSeq(NextNo)) < ShortestLen Then
                StrainSeq(NextNo) = StrainSeq(NextNo) + String$(ShortestLen - Len(StrainSeq(NextNo)), "-")
            End If
            
            
            'Pad the end with 4 gaps - this is necessary for the 4nt encodings
            
    '        For X = 0 To Nextno
    '            StrainSeq(X) = StrainSeq(X) + "----"
    '        Next X
            GlobalMemoryStatus MemSit
            NeededMem = Len(StrainSeq(0))
            NeededMem = NeededMem * (NextNo + 1)
            NeededMem = NeededMem * 100
            TotM = Abs(MemSit.dwTotalPhys)
            If TotM > 1000000000 Or TotM < 10000000 Then TotM = 1000000000
            If (NeededMem > TotM) And Len(StrainSeq(0)) > 100000 Then
                LargeSeqFlag = 1
                Call ShrinkSequences
            Else
                If NeededMem > TotM Then
                    'need to throw out some sequences - i.e. try get the number of sequences down to
                            
                End If
                LargeSeqFlag = 0
                ReDim Decompress(Len(StrainSeq(0)))
                ReDim Recompress(Len(StrainSeq(0)))
                For x = 0 To Len(StrainSeq(0))
                    Decompress(x) = x
                    Recompress(x) = x
                Next x
            
                
            End If
        Else
            '*********************************************************************
            'This is where we deal with very big files
            '*********************************************************************
            Call ShrinkSequences2
        End If
     
     End If
    'replace TABS in sequence names with spaces
   
      
    If SplitFlag = 0 Then
        ReDim MaskSeq(NextNo)
    End If
    ReDim GrpMaskSeq(NextNo)
  
    ModSeqNumFlag = 0
    '141 Urmilla
    If PosRDP5 = 0 Then 'only have to do this is we're not loading a rdp5 file
        'XX = UBound(StrainSeq)
        For Y = 0 To 5
            If Y = 0 Then
                RT = Chr(9)
                RW = " "
            ElseIf Y = 1 Then
                RT = "("
                RW = "{"
            ElseIf Y = 2 Then
                RT = ")"
                RW = "}"
            ElseIf Y = 3 Then
                RT = Chr(34)
                RW = " "
            ElseIf Y = 4 Then
                RT = ","
                RW = "_"
            ElseIf Y = 5 Then
                RT = "."
                RW = "_"
            End If
            For x = 0 To NextNo
                Do
                    Pos = InStr(1, StraiName(x), RT, vbBinaryCompare)
                    If Pos > 0 Then
                        Mid$(StraiName(x), Pos, 1) = RW
                    Else
                        Exit Do
                    End If
                Loop
                StraiName(x) = Trim(StraiName(x))
                'need to do this in treestrainname too or it fucks up newick files
                Do
                Pos = InStr(1, TreeStrainName(x), RT, vbBinaryCompare)
                If Pos > 0 Then
                    Mid$(TreeStrainName(x), Pos, 1) = RW
                Else
                    Exit Do
                End If
            Loop
            TreeStrainName(x) = Trim(TreeStrainName(x))
            Next x
        Next Y
        
        'replace "'" characters in first position of sequence names (messes up geneconv)
        
        For x = 0 To NextNo
            If Left$(StraiName(x), 1) = "'" Then
                StraiName(x) = Right$(StraiName(x), Len(StraiName(x)) - 1)
            End If
        Next x
        
        
            '0.469 seconds for a 1100 sequence file
        'Tidy up any odd characters at the end of sequences
        
        'Tidy up unacceptable characters in sequence names
        For x = 0 To NextNo
            Do
                Pos = InStr(1, StraiName(x), "'", vbBinaryCompare)
                If Pos > 0 Then
                    Mid(StraiName(x), Pos, 1) = " "
                Else
                    Exit Do
                End If
            Loop
        Next x
        'Make sure sequence names are acceptable
        For x = 0 To NextNo
            If StraiName(x) = "" Then
                UFTag = oFTag
                Form1.Enabled = True
                StillLoadingFlag = 0
                Exit Sub
            End If
            If Asc(Left(StraiName(x), 1)) > 47 And Asc(Left(StraiName(x), 1)) < 58 Then
                StraiName(x) = "SN" + StraiName(x)
            End If
        Next x
        
        'makes sure no names are nested within other names
        Call NameCheckX
    
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    
     
    
    SSS = Abs(GetTickCount)
        '0.219 seconds for a 1100 sequence file
    'checkpoint 1
        'Capitalise sequences
'len(strainseq(0))=len(strainseq(0))
    
  '141.7 Megs
    
    ReDim PPXOSeq(NextNo)
    ReDim RFlag(NextNo)
    ReDim SelectGroups(NextNo)
    ReDim DSeqs(NextNo)
    ReDim DoneTree(4, 3)
    ReDim GPVTFont(5, 100), GPVText(100)
    DoingShellFlag = 0
    GPVTNum = -1
    LastSEFlag = -2
    LastCurgene = -1
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box, 3 = bsvalue)
    'D = coordinates/sequence number/colour etc - (0 = startX ccord, 1=startY coord, 2 = endX ccord, 3=endY coord, 4 = colour;
    'E = element number
    LastVScroll3Value = -1
    ReDim MapBlocks(4, 4, 4, NextNo + 10)
   ' ReDim MapBlocksR(4, Nextno + 10, 4, 4)
    ReDim TreeDraw(3, 4, 1, 4, (NextNo + 2) * 2)
    
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB())
    ReDim TreeBlocks(3, 4, 5, (NextNo + 2))
    ReDim TBLen(3, 4)
    ReDim TreeBlocksL(3, 5, 5, 20)
    ReDim TreeXScaleMod(1, 3, 4)
    ReDim MapBlockNum(4, 4)
    ReDim Excludetrace(NextNo + 10)
    ReDim ISInvolved(NextNo)
    'ReDim StoreLPV(AddNum - 1, NextNo)
    '154.5 Megs Urmilla
    'Clear TDLen
    For x = 0 To 3
        TreeImage(x) = 0
        For Y = 0 To 4
            For Z = 0 To 2
                TDLen(x, Y, Z) = 0
            Next Z
        Next Y
    Next x
    
    
    DoneColFlag = 0
    CSelect = 0
    'Reset flags
    ReDim BSFilePos(0, 0, 0)
    OVS = -1
    SHAPEFlag = 0
    DistanceFlag = 0
    TreeTypeFlag = 0
    RecombineFlag = 0
    ShowSeqFlag = 0
    RunFlag = 0
    EditSeqFlag = 0
    NJFlag = 0
    Form5.Timer3.Enabled = False
'    Form5.Timer2.Enabled = False
'    Form5.Timer1.Enabled = False
    Form5.Timer4.Enabled = False

'    If DebuggingFlag < 2 Then On Error Resume Next
'     Form5.Inet2.Cancel
'    On Error GoTo 0
    JustOpened = 1
    F5T1Executing = 0
    F5T2Executing = 0
    F5T3Executing = 0
    GenBankFetchStep = 3
    GenBankFetchStep2 = 3
    GenBankFetchStep3 = 3
    SumAncSeq = ""
    MLAncSeq = ""
    ParsAncSeq = ""
    ORFFlag = 0
    GeneNumber = 0
    Set HTTPRequest = New WinHttp.WinHttpRequest
    Set HTTPRequest2 = New WinHttp.WinHttpRequest
    
    Resetload = 1
    TreeDistFlag = 0
    Pic4Flag = 0
    Pic11Flag = 0
    GCMCCheckFlag = 0
    RedoReticulateFlag = 0
    ManFlag = -1
    RelX = 0
    RelY = 0
    BPCvalFlag = 0
    SelectedSeqNumber = -1
    MaxaaLen = 0
    PDBFileNumber = 0
    If ResFlag = 6 And SecondPass = 0 Then
        SEventNumber = 0
    End If
    TManFlag = -1
    CurrentCheck = -1
    CurMatrixFlag = 255
    XTableFlag = 0
    TotStructs = -1
    PermInterProtInteracts = -1
    StrainSeqOnDisk = 0
    PermPDBNo = -1: PermContactNumberB = -1: PermContactNumberT = -1
    Translation(0) = ""
    SchemDownFlag = 0
    PersistantP2tTYF = 0
    PersistantP2TYFM = 0
    If Len(StrainSeq(0)) > 20000 Then
        UPArrayDim1 = 20000
    Else
        UPArrayDim1 = Len(StrainSeq(0))
    End If
    UPArrayDimXFact = UPArrayDim1 / Len(StrainSeq(0))
    
    'TreeRXInFileFlag = 0
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    StepNo = 0
    SSS = Abs(GetTickCount)
     
        '0.015 seconds for a 1100 sequence file
   
    Call ClearMatrix
    SSS = Abs(GetTickCount)
        '0.000 seconds for a 1100 sequence file
    ReDim ValidList(500), CountList(500)
    
    
    'checkpoint 2
    '130.1 Megs Urmilla
    ValidList(132) = 1: ValidList(136) = 1: ValidList(144) = 1: ValidList(170) = 1: ValidList(134) = 1: ValidList(138) = 1: ValidList(151) = 1: ValidList(140) = 1: ValidList(153) = 1: ValidList(157) = 1
    CountList(132) = 1: CountList(136) = 1: CountList(144) = 1: CountList(170) = 1

    SimSeq = ""
    
    ReDim PermOriginalName(NextNo)
    PermNextno = NextNo
    oNextno = NextNo
    SSS = Abs(GetTickCount)
    For x = 0 To NextNo
        PermOriginalName(x) = OriginalName(x)
    Next x
    
    'XX = SeqSpacesInFileFlag
    
    If (CLine = "" Or CLine = " ") Then
        
        Form1.SSPanel1.Caption = "Calculating identities"
        Form1.Picture26.Picture = LoadPicture()
        Form1.Picture19.Picture = LoadPicture()
        Form1.Picture20.Picture = LoadPicture()
        Form1.Picture20.Visible = False
        Form1.Refresh
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        'XX = UBound(SeqSpaces, 2)
        'SeqSpacesInFileFlag = 1
        
        If NextNo > 200 Then
            TYF = 200 / NextNo
            If TYF < 0.2 Then TYF = 0.2
            
        Else
            TYF = 1
        End If
        TYF2 = 1
        'TYF = 0.5
        
        
        
        
        DontPrintNames = 1
        'XX = Form1.Picture1.Width
        ReDim CurTree(4)
        
        If AutoMultFlag = 0 Or AFN = 0 Then
            Call DoInterface
            Form1.Refresh
        End If
        DontPrintNames = 0
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Call DoCols
        If AutoMultFlag = 0 Or AFN = 0 Then
            Form1.ProgressBar1.Value = 30
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    End If
    
    

    'checkpoint 3
    
    
    
    
     '130.3 Megs Urmilla
    'Adds sequenece data to the list for user sepecified outlyer seqs

    For x = 0 To NextNo
        Form3.List1.AddItem OriginalName(x), x
        
    Next
    
    
    '130.4 Megs Urmilla
    
    GapChar = "-"
    Dim RemoveES As Byte
    RemoveES = 1
    
    
    
    'this will actually not work if there is compression and I should disable it if there is compression.
    ReDim PermSeq1Align(Len(StrainSeq(0)), 0)
    ReDim PermSeq2Align(Len(StrainSeq(0)), 0)
    ReDim PDBtoAlign(Len(StrainSeq(0)), 0)
    
    
    SSS = Abs(GetTickCount)
        '0.047 seconds for a 1100 sequence file
    'Copy nucleotide data into an integer array (its quicker to work with
    'an integer array than with a string)
   
    'Sort out tree nodestorage
    
    If MaxEListLen = 0 Then
        ReDim NodeXY(25, NextNo + 2, 1)
    Else
        ReDim NodeXY(25, NextnoBak, 1)
    End If
    
    
    ReDim NHString(100)
    
    
    
    GlobalMemoryStatus MemSit
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    
    MaxXOListSize = APhys / 20
    MinSeqSize = 50
    
    If Len(StrainSeq(0)) / 100 > MinSeqSize Then
        MinSeqSize = Len(StrainSeq(0)) / 100
    End If
    
    
    'checkpoint 5
    
    If (Len(StrainSeq(0)) * NextNo) > 2000000 Then
        ProbEstimateInFileFlag = 1
        Erase ProbEstimate
    End If
    'XX = SeqFile
    '@
    '119.7 Megs Urmilla
    
    ReDim SeqNum(Len(StrainSeq(0)), NextNo + 1)
    If SeqSpacesTempFlag = 4 Or SeqSpacesInFileFlag = 1 Then 'this indicates that gap location info for uncompressed sequences is already stored on disk
        'The usual seqspaces array must not be used
    
        ReDim SeqSpaces(Len(StrainSeq(0)) + 2)
        For x = 0 To NextNo
            Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, x), StrainSeq(x), SeqSpaces(0))
        Next ''X
        Erase SeqSpaces
    Else
        SeqSpacesInFileFlag = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqSpaces(Len(StrainSeq(0)) + 2, NextNo)
        UB1 = -1
        UB2 = -1
        UB1 = UBound(SeqSpaces, 1)
        UB2 = UBound(SeqSpaces, 2)
        On Error GoTo 0
        '342.9 Megs
        'XX = Len(StrainSeq(1))
        If UB1 = Len(StrainSeq(0)) + 2 And UB2 = NextNo Then
            For x = 0 To NextNo
                If Len(StrainSeq(x)) = 0 Then
                    StrainSeq(x) = String(Len(StrainSeq(0)), "-")
                    NextNo = NextNo - 1
                    PermNextno = PermNextno - 1
                End If
                Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, x), StrainSeq(x), SeqSpaces(0, x))
            Next ''X
            x = x
        Else
            If StrainSeqOnDisk = 0 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5Strainseq" + UFTag For Binary As #FF
                Put #FF, , StrainSeq()
                Close #FF
                StrainSeqOnDisk = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            UB = 50
            If UB > NextNo Then UB = NextNo
            ReDim SeqSpaces(Len(StrainSeq(0)) + 2, UB)
            
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5SSFile" + UFTag For Binary As #FF
            
            
            Y = 0
            For x = 0 To NextNo
                If Y > UBound(SeqSpaces, 2) Then
                    Put #FF, , SeqSpaces()
                    Y = 0
                    ReDim SeqSpaces(Len(StrainSeq(0)) + 2, UB)
                End If
                Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, x), StrainSeq(x), SeqSpaces(0, Y))
                If x > 0 Then
                    StrainSeq(x) = ""
                End If
                Y = Y + 1
            Next ''X
            Put #FF, , SeqSpaces()
            Close #FF
            SeqSpacesInFileFlag = 1
            ChDrive oDirX
            ChDir oDirX
            
        End If
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'dont know how to handle this bit with rdp5
    'save decompress and seqspaces
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'If PosRDP5 = 0 Then
    '342.2 Megs
        If SeqSpacesTempFlag = 2 Then
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                For x = 0 To NextNo
                    
                    Z = 0
                    For Y = 1 To Len(StrainSeq(0))
                        
                        Do
                            'XX = UBound(SeqSpacesTemp, 2)
                            If SeqSpacesTemp(x, Z) >= Decompress(Y) Then
                                SeqSpaces(Y, x) = Z - 1
                                Exit Do
                            End If
                            Z = Z + 1
                            If Y = Len(StrainSeq(0)) Or Z >= UBound(SeqSpacesTemp, 2) Then
                                SeqSpaces(Y, x) = Z - 1
                                Exit For
                            End If
                            'SeqSpaces(Y, X) = SeqSpacesTemp(Decompress(Y), X)
                        Loop
                    Next Y
                Next x
            End If
        ElseIf SeqSpacesTempFlag = 1 Then
        
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                For Y = 0 To NextNo
                    For x = 0 To Len(StrainSeq(0))
                        SeqSpaces(x, Y) = SeqSpacesTemp(Decompress(x), Y)
                    Next x
                Next Y
            End If
            Erase SeqSpacesTemp
        ElseIf SeqSpacesTempFlag = 0 Then
        
            
            
            FF = FreeFile
            Dim TVX As Long, LSV As Long
            
            LSV = Decompress(Len(StrainSeq(0))) + 1
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "SSTF" + UFTag For Binary As #FF
                For Y = 0 To NextNo
                    For x = 0 To Len(StrainSeq(0))
                        Z = Decompress(x)
                        Z = Y * (LSV) + Decompress(x) + 1
                        rvar = Z
                        rvar = rvar * 4
                        Get #FF, rvar, TVX
                        SeqSpaces(x, Y) = TVX
                    Next x
                Next Y
                Close #FF
                KillFile "SSTF" + UFTag
                ChDrive oDirX
                ChDir oDirX
            End If
            
            
        End If
    'End If
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
       
    
    SSS = Abs(GetTickCount)
    '522599
    'XX = Timer1.Enabled
    If SeqSpacesTempFlag <> 4 Then
      If ((Len(StrainSeq(0)) + 3) * (NextNo + 1) * 8) > 10000000 And SeqSpacesInFileFlag = 0 Then
          Form1.SSPanel1.Caption = "Writing data to disk"
          Form1.Refresh
          If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
          SeqSpacesInFileFlag = 1
          oDirX = CurDir
          ChDrive App.Path
          ChDir App.Path
          FF = FreeFile
          Open "RDP5SSFile" + UFTag For Binary As #FF
          '@
          Put #FF, , SeqSpaces
          Close #FF
          
          ChDrive oDirX
          ChDir oDirX
          Erase SeqSpaces
    
          
      End If
    End If
    '192.4 Megs Urmilla
    
    If StrainSeqOnDisk = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim Preserve StrainSeq(NextNo + 1)
        UB = Len(StrainSeq(0))
        For x = 1 To NextNo
            StrainSeq(x) = String(UB, " ")
        Next x
        Open "RDP5Strainseq" + UFTag For Binary As #FF
        Get #FF, , StrainSeq()
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    'checkpoint 5
    
        '0.141 seconds for a 1100 sequence file
    
    

    'Strange characters used to be removed by this old routine.
    'clear all unusual characters from sequences
    'For X = 0 To 255
    '    If chr$(X) <> "A" And chr$(X) <> "C" And chr$(X) <> "G" And chr$(X) <> "T" And chr$(X) <> "-" And chr$(X) <> "U" Then
    '        ReplaceChar chr$(X), GapChar
    '    ElseIf chr$(X) = "U" Then
    '        ReplaceChar "U", "T"
    '    End If
    '    Form1.ProgressBar1 = 60 + (X / 255) * 30
    'Next 'X
    'ReplaceChar ".", GapChar
  'ReDim SeqCols(Nextno)
    'Work out colour coding for the sequence display and replace strange characters
    'If (CLine = "" Or CLine = " ") Then
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Call SeqCols2
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If TotGapCharCount > (NextNo * Len(StrainSeq(0))) / 2 Then
            MsgBox ("The file that you are trying to load seems like it might be an amino acid sequence alignment. Note that RDP5 can only properly analyse DNA sequence alignments - all characters other than 'A', 'C', 'G' and 'T' will be replaced with '-' characters")
        End If
        'checkpoint 6
    'End If
    
    
    

    
    
    SSS = Abs(GetTickCount)
        '1.360 seconds for a 1100 sequence file
        'checkpoint 6
    Picture4.Enabled = True
    Picture11.Enabled = True
    SSPanel11.Visible = True
    
    FullWindowSize = 40
    HomologyIndicator = 1
    
    'check an see if there is a stored distance marix for this file
    
    If NextNo > 1000 And FName <> "tempfile" Then
            Dim SM() As Single
            ReDim SM(NextNo, NextNo)
            FF = FreeFile
            Open FName + "SM" For Binary As #FF
            If LOF(FF) > 0 Then
                Get #FF, , SM()
                ReDim PermValid(NextNo, NextNo)
                ReDim PermDIffs(NextNo, NextNo)
                ReDim Distance(NextNo, NextNo)
                
'                If X = X Then
                    
                    GoOn = ReMakeDistance(Len(StrainSeq(0)), NextNo, UBound(Distance, 1), SM(0, 0), Distance(0, 0), PermValid(0, 0), PermDIffs(0, 0))
                    
'                Else
'                    GoOn = 1
'    '                SS = abs(gettickcount)
'
'
'                    'this should be ported to c++
'                    For X = 0 To Nextno
'                        If SM(X, X) <> 0 Then
'                            GoOn = 0: Exit For
'                        End If
'                        Distance(X, X) = 1
'                        For Y = X + 1 To Nextno
'                            PermValid(X, Y) = SM(X, Y)
'                            PermValid(Y, X) = SM(X, Y)
'                            PermDiffs(X, Y) = SM(Y, X)
'                            PermDiffs(Y, X) = SM(Y, X)
'                            '
'                            If PermValid(X, Y) > 0 Then
'                                If PermValid(X, Y) > Len(StrainSeq(0)) Then
'                                    GoOn = 0
'                                    Exit For
'                                End If
'                                Distance(X, Y) = 1 - (PermDiffs(X, Y) / PermValid(X, Y))
'                            Else
'                                Distance(X, Y) = 0
'                            End If
'                            Distance(Y, X) = Distance(X, Y)
'                        Next Y
'                        If GoOn = 0 Then Exit For
'
'
'                    Next X
'                End If
'                EE = abs(gettickcount)
'                TT = EE - SS
'                X = X 'for freds file - 2.8 seconds
                
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If GoOn = 1 Then
                    DistanceFlag = 1
                Else
                    DistanceFlag = 0
                End If
                Close #FF
            Else
                Close #FF
                If DebuggingFlag < 2 Then On Error Resume Next
                Kill FName + "SM"
                On Error GoTo 0
            End If
            
            
        End If
    
    
    DoneBKgFlag = 0: DoneTajDflag = 0: DonGCContentFlag = 0
    ReDim AVTaj(100), AvBKG(100), AvGCContent(100)
    If (CLine = "" Or CLine = " ") Then
        
         SS = Abs(GetTickCount)
         '    For X = 1 To 1000
            IDDisplayMode = 0 'if this is set to 3 it causes problems because it will try to access unmodseqnun before permseqnum has been made
            Call CalcIdentity3(1)
        ''    Next X
            EE = Abs(GetTickCount)
            TT = EE - SS '10125 (old way), 7094 using imagedata, 6656 using singles instead of doubles
            '6250,6157,4047,1.438
            x = x
    End If
    Form1.SSPanel1.Caption = "Building sequence display"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
   
    
    'checkpoint 7
     
   SSS = Abs(GetTickCount)
    '18.782 seconds for a 1100 sequence file
    
    'Picture1.FontSize = 9.75 * TYF
    
    '351.7 Megs Urmilla
    Command6(1).Enabled = True
    If IDDisplayMode = 0 Then
        Picture4.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
        Picture11.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
    ElseIf IDDisplayMode = 1 Then
        Picture4.ToolTipText = "Average Tajima D (window size =" + CStr(FullWindowSize) + ")"
        Picture11.ToolTipText = "Average Tajima D identity (window size =" + CStr(FullWindowSize) + ")"
    ElseIf IDDisplayMode = 2 Then
        Picture4.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
        Picture11.ToolTipText = "Average GC content identity (window size =" + CStr(FullWindowSize) + ")"
    End If
    'If (CLine = "" Or CLine = " ") Then
    '    AvBkgHomology = 0
    '    For X = 0 To Len(StrainSeq(0))
    '        AvBkgHomology = AvBkgHomology + BkgIdentity(X) '0.6613
    '    Next X
    '    AvBkgHomology = AvBkgHomology / Len(StrainSeq(0))
    'End If
    '5.7 seconds
    'ProgressBar1.Value = 100
    Picture11.DrawMode = 12
    
    If (CLine = "" Or CLine = " ") Then
        'Draw sequence window
'        XX = UBound(Decompress)
        PrintSeqLen = MakePrintSeqLen
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            If Len(StrainSeq(0)) - (PrintSeqLen - 5) > 32000 Then
                HScroll1Mod = CLng(Len(StrainSeq(0)) / 32000) + 1
                HScroll1.Max = (Len(StrainSeq(0)) - (PrintSeqLen - 5)) / HScroll1Mod
            Else
                HScroll1Mod = 1
                HScroll1.Max = Len(StrainSeq(0)) - (PrintSeqLen - 5)
                x = x
            End If
        Else
            HScroll1Mod = CLng(UBound(Recompress, 1) / 32000) + 1
            HScroll1.Max = (UBound(Recompress, 1) - (PrintSeqLen - 5)) / HScroll1Mod
        End If
    
    
        HScroll1.Min = 1
        '433160
        
        ReDim SubValid(0, 0)
        ReDim SubDiffs(0, 0)
        ReDim SMat(0, 0)
        ReDim FubValid(0, 0)
        ReDim FMat(0, 0)
        Erase OverlapList
        
        
    'End If
        
        
        Erase CurrentXOver
        Erase BCurrentXoverMi
        Erase BCurrentXoverMa
        
        
        ORFFlag = 0
        GeneNumber = 0
        Resetload = 1
        '351.7 Urmilla
        Call HScroll1_Change
        '363.8 Urmilla
        Dim tTYF As Double, TYFM As Integer
        
        StartX = 0
        NumSeqLines = x
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        Call CalcttyfAdjust(TYFM, tTYF, 0, 0)
        P1OH = (((NextNo + 2) * 13) - TYFM) * tTYF * ttyfAdjust
        
        P3OH = P1OH
        
        'If F1MDF = 0 Then
        '363.8 Urmilla
        With Form1.VScroll3 'Sequence display scrollbar
            'Form1.VScroll3.Visible = False
            
            TestMax = -Form1.Picture9.ScaleHeight + P1OH
            'If F1MDF = 0 Then
               ' .Max = -Form1.Picture9.ScaleHeight + Form1.Picture1.Height
            'End If
            'Form1.VScroll3.Visible = True
            If TestMax <= 0 Then
                .Enabled = False
            Else
                If TestMax < 32000 Then
                
                
                    .Max = TestMax
                    ScrollSF = 1
                Else
                    .Max = 32000
                    ScrollSF = 32000 / TestMax
                End If
                If Form1.Picture9.ScaleHeight > 0 Then
                    .LargeChange = Form1.Picture9.ScaleHeight
                End If
                'If F1MDF = 0 Then
                    .Enabled = True
                'End If
            End If
    
        End With
        
        
        
        
        If ColDistInFile = 1 Then
            
                
           
            
            ReDim ColDist2(0)
            Timer7(1).Enabled = False
        End If
        '443596
        HScroll1.Enabled = True
    
    End If
    
    
    
    Form1.SSPanel1.Caption = "Checking for necessery memory"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
   'Urmilla 363.3
    SSS = Abs(GetTickCount)
        '0.219 seconds for a 1100 sequence file
    If HScroll1.Max > 0 Then 'PrintSeqLen - 5 Then
        HScroll1.Enabled = True
    Else
        HScroll1.Enabled = False
    End If
    If ColDistInFile = 1 Then
        
        ReDim ColDist2(0)
        Timer7(1).Enabled = False
    End If
    'XX = UBound(SeqLines, 2)
    'XX = (XX + 1) * 6 * 8
    '363.4
    
    Form1.SSPanel1.Caption = "Checking for necessery memory"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    GCSeqRange(0) = 0
    GCSeqRange(1) = Len(StrainSeq(0))
    'checkpoint 8
    
    MCStart = 0
    
    MCEnd = Len(StrainSeq(0))
    'Form1.ProgressBar1.Value = 0
    'Clears tree image holders

    For x = 0 To 3
        TreeImage(x) = 0
    Next ''X
    
    GlobalMemoryStatus MemSit

    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    MaxXOListSize = APhys / 20
    MaxXOListSize = CLng(MaxXOListSize / NextNo / 50 / 10)
    If MaxXOListSize < 6 Then MaxXOListSize = 6
    
    TreeImage(0) = 0
    SaveFlag = 0
    'If file is an RDP project file
    
    
    ReDim MultColour(NextNo + MaxEListLen + 2)
    'Update the "recent files" list

    If FileList(1) <> FName$ And FName$ <> "LastSave.rdp5" Then

        If FileList(4) <> FileList(3) And FileList(3) <> FName$ Then FileList(4) = FileList(3)

        If FileList(3) <> FileList(2) And FileList(2) <> FName$ Then FileList(3) = FileList(2)

        If FileList(2) <> FileList(1) And FileList(1) <> FName$ Then FileList(2) = FileList(1)
        FileList(1) = FName$
    End If

    If FileList(4) <> "" Then
        File4Mnu.Caption = FileList(4)
    Else
        File4Mnu.Caption = "--"
    End If
     
    If FileList(3) <> "" Then
        File3Mnu.Caption = FileList(3)
    Else
        File3Mnu.Caption = "--"
    End If

    If FileList(2) <> "" Then
        File2Mnu.Caption = FileList(2)
    Else
        File2Mnu.Caption = "--"
    End If

    If FileList(1) <> "" Then
        File1Mnu.Caption = FileList(1)
    Else
        File1Mnu.Caption = "--"
    End If

    Picture7.ToolTipText = ""
    
    'checkpoint 9
    ReDim TTFlag(3, 4)
    ReDim CurTree(4)
    ReDim XCord(4, 3, NextNo + 2 + MaxEListLen)
    ReDim YCord(4, 3, NextNo + 2 + MaxEListLen)
    ReDim RYCord(4, 3, NextNo + 2 + MaxEListLen)
    ReDim SNodeXPos(20, NextNo + 1 + MaxEListLen)
    ReDim SNodeYPos(20, NextNo + 1 + MaxEListLen)
    ReDim SSeqXPos(20, NextNo + 1 + MaxEListLen)
    ReDim SSeqYPos(20, NextNo + 1 + MaxEListLen)
    ReDim SDLen(20, NextNo + 1 + MaxEListLen)
    ReDim MCIdentical(0)
    
    
    DoneMatX(0) = 0
    DoneMatX(1) = 0
    DoneMatX(2) = 0
    DoneMatX(3) = 0
    DoneMatX(4) = 0
    DoneMatX(5) = 0
    DoneMatX(6) = 0
    DoneMatX(7) = 0
    DoneMatX(12) = 0
    DoneMatX(13) = 0
    DoneMatX(14) = 0
    VRFlag = 0
    '365.5 Urmilla
    For x = 0 To NextNo

        For Y = 0 To 3
            XCord(0, Y, x) = TRegion
        Next 'Y

    Next 'X

   ' DoEvents
    
    
    'If UPGMA positions of seqs are unknown draw a quick tree to determine them
    
     
    SSS = Abs(GetTickCount)
        '0.250 seconds for a 1100 sequence file
    
    ReDim SeqCol(NextNo + 1)
    ReDim FFillCol(NextNo + 1)
    ReDim PrintCharLen(NextNo)
    PrintCharLenFlag = 0
    'checkpoint 10
    
    
    ReDim uTreeTrace(0), uDaught(0, 0), uOriginalName(0), uSeqNum(0, 0), uMissingData(0, 0)
     ReDim uTreeDistance(0, 0)
     ReDim uSeqCol(0), uFFillCol(0)
     ReDim uDistance(0, 0)
     ReDim uOriginalName(0)
    
    
    ReDim ONameLen(NextNo)
    MaxONameLen = 0
    For x = 0 To NextNo
        ONameLen(x) = Len(OriginalName(x))
        If MaxONameLen < ONameLen(x) Then
            MaxONameLen = ONameLen(x)
        End If
    Next x
    
    
    
    SSPanel1.Caption = "Making UPGMA"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
   
    'checkpoint 11
    '365.5 Urmilla
    'Form1.ProgressBar1.Value = 47
    Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
    'UPGMA(Strainame(),NodeLength() , TreeX(), TreeY() , AvDst, Decompress() , PermDiffs() , PermValid() , Nextno , Distance(),  SPF, LF)
    '431.2 Urmilla
    
    'checkpoint 12
    Form1.ProgressBar1.Value = 53
    SSPanel1.Caption = "Writing data to disk"
    Call UpdateF2Prog
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
   'Make backups of distance and tree distance
        
    Call PutPerms
    
    
    
    If DebuggingFlag < 2 Then On Error Resume Next
    VSC1NC = 1
    For x = 0 To 3
        Form2.VScroll1(x).Value = 0
        
    Next
    VSC1NC = 0
    
    On Error GoTo 0
    
    
    Form1.ProgressBar1.Value = 58
    Call UpdateF2Prog
    '565924
    
    TreeXInFileFlag = 0
    '431.2 Urmilla
    
    Call DrawTree
    
    '450.7 Urmilla
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Erase TreeX
    End If
    
    '431.2 Urmilla
    'checkpoint 13
    
    Form1.ProgressBar1.Value = 63
    Call UpdateF2Prog
    Form1.Label14.Caption = "UPGMA ignoring recombination"
    TreeImage(0) = 1
    DoneTree(0, 0) = 1
    NJFlag = 1
    
    SSS = Abs(GetTickCount)
        '5.422 seconds for a 1100 sequence file
   
    'See whether compatibility matrix should be drawn or not
    'It depends on available memory
    RETFlag = 0
    Form1.Picture5.Enabled = False
    
    SSS = Abs(GetTickCount)
    
    
    
    ReDim CurveArray(Len(StrainSeq(0)))
    For x = 0 To Len(StrainSeq(0))
        CurveArray(x) = 1
    Next x
    ReDim ORFRefList(50)
    If ReassortmentFlag = 1 Then
        ReDim DoneSegment(RBPNum)
        ReDim LastSegment(RBPNum)
        ReDim RemoveSegment(100)
    Else
        ReDim DoneSegment(20)
        ReDim LastSegment(20)
        ReDim RemoveSegment(100)
    End If
    If Skiploadflag = 0 Then
        If ORFFlag = 0 And (CLine = "" Or CLine = " ") And Len(StrainSeq(0)) < 500000 And AutoMultFlag = 0 Then
            StartFetch = Abs(GetTickCount)
            'get the sequence with the smallest average distance to any other sequences
            Dim AvDistance() As Single, MaxVal As Single, WinSeq As Long
            
            ReDim AvDistance(NextNo)
            For x = 0 To NextNo
                For Y = 0 To NextNo
                    AvDistance(x) = AvDistance(x) + Distance(x, Y)
                Next Y
            Next x
            MaxVal = 0
            For x = 0 To NextNo
                If MaxVal < AvDistance(x) Then
                    MaxVal = AvDistance(x)
                    WinSeq = x
                End If
            Next x
            ORFRefList(0) = WinSeq '203
            ORFRefList(1) = WinSeq
            ORFRefList(2) = WinSeq
            ORFRefList(3) = WinSeq
            ORFRefList(4) = WinSeq
            ORFRefList(5) = WinSeq
            'ORFRefList(3) = WinSeq
           
            'get a list of up to 9 other sequences to retrieve for ORF and annotation info
            
            Y = 6
            For x = NextNo To 0 Step -1
                If TreeY(x) <> ORFRefList(0) Then
                    ORFRefList(Y) = TreeY(x)
                    
                    Y = Y + 1
                    If Y > 50 Then Exit For
                End If
            Next x
            If NextNo < 50 Then
                ORFRefNum = NextNo
            Else
                ORFRefNum = 50
            End If
        End If
    End If
    
    'If Len(StrainSeq(0)) < 10000 Then
    '    GCDimSize = Len(StrainSeq(0))
    'Else
    '    GCDimSize = 10000
    'End If
    'find the three most deverged sequences and find the subseq for these
    'find the pair with the highest permdiff
    Dim MaxDiffs As Long, WinX As Long, WinY As Long, winz As Long
    '431.2 Urmilla
    
    
    '431.7 Urmilla
    
    '695316
    'checkpoint 15 - before setupscanarrays
    SSS = Abs(GetTickCount)
        '0.125 seconds for a 1100 sequence file
    'checkpoint 15
    If SecondPass = 0 And ResFlag = 6 Then
        ReDim BanWin(Len(StrainSeq(0)) * 2)
        ReDim MissingData(Len(StrainSeq(0)), NextNo)
        If ReassortmentFlag = 1 Then
            Dim tBP As Long
            If UBound(RBPPos, 1) < RBPNum Then
                ReDim Preserve RBPPos(RBPNum)
            End If
            For x = 0 To RBPNum
                If RBPPos(x) > Len(StrainSeq(0)) Then RBPPos(x) = Len(StrainSeq(0))
                tBP = RBPPos(x)
                For Y = 0 To NextNo
                    MissingData(tBP, Y) = 1
                Next Y
            Next x
        End If
        
        ReDim MDMap(Len(StrainSeq(0)))
        
        
        ReDim XoverList(NextNo, 10), MaxXOP(AddNum - 1, NextNo)
        Call ResetMaxPVCO(NextNo)
        If SplitFlag = 0 Then
            ReDim MaskSeq(NextNo)
        End If
        ReDim SubMaskSeq(NextNo)
        ReDim CurrentXOver(NextNo)
        ReDim ELLite(5, 0)
    End If
    ' XX = Maskseq(9)
    '470.8 Urmilla
    'checkpoint 16
    RefNum = 0
    TripListLen = 0
    QvRAutoAssignableFlag = 0
    QvRFlag = 0
    UseALFlag = 0
    
    Dim NN As Variant
   
    NN = NextNo + 1
    NN = NN * NextNo
    NN = NN * (NextNo - 1)
    NN = NN / 6
    
    TripListLen = 0
    'XX = Maskseq(17)
    
    ReDim BestXOListMi(NextNo, 1)
    ReDim BestXOListMa(NextNo, 1)
    NumExcludedEventNum = 0
    ExcludedEventBPNum = 0
    If PosRDP5 = 0 Then
        If NN <= MaxAnalNo Then
            ReDim Worthwhilescan(NN)
        Else
            ReDim Worthwhilescan(MaxAnalNo)
        End If
        If (Right$(FName$, 4) = ".rdp" Or Right$(FName$, 4) = ".RDP") And SecondPass = 0 Then
    '
            If CombinedFileFlag = 1 Then
                ReDim CurrentXOver(UBound(tCurrentxover))
                For x = 0 To UBound(tXOList, 1)
                    If tCurrentxover(x) > UBound(XoverList, 2) Then
                        ReDim Preserve XoverList(UBound(XoverList, 1), tCurrentxover(x) + 10)
                    End If
                    CurrentXOver(x) = tCurrentxover(x)
                    For Y = 0 To tCurrentxover(x)
                        XoverList(x, Y) = tXOList(x, Y)
                        
                    Next Y
                Next x
                
                ReDim BCurrentXoverMi(UBound(tCurrentxoverMi))
                For x = 0 To UBound(tXOListMi, 1)
                
                    If tCurrentxoverMi(x) > UBound(BestXOListMi, 2) Then
                        ReDim Preserve BestXOListMi(UBound(BestXOListMi, 1), tCurrentxoverMi(x) + 10)
                    End If
                    BCurrentXoverMi(x) = tCurrentxoverMi(x)
                    For Y = 0 To tCurrentxoverMi(x)
                        BestXOListMi(x, Y) = tXOListMi(x, Y)
                    Next Y
                Next x
                ReDim BCurrentXoverMa(UBound(tCurrentxoverMa))
                For x = 0 To UBound(tXOListMa, 1)
                    If tCurrentxoverMa(x) > UBound(BestXOListMa, 2) Then
                        ReDim Preserve BestXOListMa(UBound(BestXOListMa, 1), tCurrentxoverMa(x) + 10)
                    End If
                    BCurrentXoverMa(x) = tCurrentxoverMa(x)
                    For Y = 0 To tCurrentxoverMa(x)
                        BestXOListMa(x, Y) = tXOListMa(x, Y)
                    Next Y
                Next x
            End If
            Call LoadRDP(CLng(ResFlag), CLng(SNNextNo), AdjustAlign())
            'XX = XoverList(0, 4).Probability
            Picture2.BackColor = BackColours + 65793 * 10
            RIMode = 0
            
            Call Command13_Click(2)
            Command13(2).Enabled = False
            If ResFlag = 7 And CombinedFileFlag = 1 Then
                
                
            ElseIf ResFlag <> 6 And (ResFlag <> 7 And CombinedFileFlag = 1) Then
                ResFlag = 6
                'DistanceFlag = 0
                SecondPass = 1
                GoTo RedoThis
            End If
            Form1.Picture5.Enabled = True
            
            Dim TTr As Long
            TT = 0
            'XX = CurrentXOver(NextNo)
            If RefNum > 0 Then
            
            ElseIf UseALFlag = 0 And UBound(Worthwhilescan) < NN And QvRFlag = 0 Then
                If NN > MaxAnalNo Then
                    NN = MaxAnalNo
                    Call MakeAnalysisList
                    UseALFlag = 1
                End If
               ReDim Worthwhilescan(NN)
               For x = 0 To UBound(Worthwhilescan)
                    'If Worthwhilescan(X) = 1 Then
                    Worthwhilescan(x) = 1 + 2 + 4 + 8 + 16 + 32 + 64
                    'End If
                Next x
            Else
                
                For x = 0 To UBound(Worthwhilescan)
                    If Worthwhilescan(x) = 1 Then
                        TTr = TTr + Worthwhilescan(x)
                    End If
                Next x
    
                If TTr < 10 Then
                    For x = 0 To UBound(Worthwhilescan)
                        'If Worthwhilescan(X) = 1 Then
                        Worthwhilescan(x) = 1 + 2 + 4 + 8 + 16 + 32 + 64
                        'End If
                    Next x
    
                End If
            End If
        ElseIf SecondPass = 1 Then
            Call FORDPLoad
        Else
            If SplitFlag = 0 Then
                'XX = Maskseq(10): XX = Maskseq(16)
                Call AutoMaskmnu_Click
                'XX = Maskseq(10): XX = Maskseq(16)
            End If
        End If
        If CombinedFileFlag = 1 Then
            
            Call SeqCols2
            DoneBKgFlag = 0: DoneTajDflag = 0: DonGCContentFlag = 0
            ReDim AVTaj(100), AvBKG(100), AvGCContent(100)
            If (CLine = "" Or CLine = " ") Then
                
                 SS = Abs(GetTickCount)
                 '    For X = 1 To 1000
                    IDDisplayMode = 0 'if this is set to 3 it causes problems because it will try to access unmodseqnun before permseqnum has been made
                    Call CalcIdentity3(1)
                ''    Next X
                    EE = Abs(GetTickCount)
                    TT = EE - SS '10125 (old way), 7094 using imagedata, 6656 using singles instead of doubles
                    '6250,6157,4047,1.438
                    x = x
            End If
        End If
    Else
        '470.8 megs Urmilla
        If NN <= MaxAnalNo Then
            ReDim Worthwhilescan(NN)
        Else
            ReDim Worthwhilescan(MaxAnalNo)
        End If
        '480.3 Megs Urmilla
        
        Call ReadRDP5FileB(MidPosRDP)
        If MaxEListLen > 0 Then
            ReDim NodeXY(25, NextnoBak, 1)
            ReDim XCord(4, 3, NextNo + 2 + MaxEListLen)
            ReDim YCord(4, 3, NextNo + 2 + MaxEListLen)
            ReDim RYCord(4, 3, NextNo + 2 + MaxEListLen)
            ReDim SNodeXPos(20, NextNo + 1 + MaxEListLen)
            ReDim SNodeYPos(20, NextNo + 1 + MaxEListLen)
            ReDim SSeqXPos(20, NextNo + 1 + MaxEListLen)
            ReDim SSeqYPos(20, NextNo + 1 + MaxEListLen)
            ReDim SDLen(20, NextNo + 1 + MaxEListLen)
            Call DrawTree
        End If
        Call FORDPLoad
        Picture2.BackColor = BackColours + 65793 * 10
        RIMode = 0
        Call Command13_Click(2)
    End If
    If NextnoBak > 0 Then
        ReDim TreeDrawColBak(((NextnoBak + 2) * 2), 3), TreeDrawColBakFlag(3)
    Else
        ReDim TreeDrawColBak((NextNo + 2 + MaxEListLen) * 4, 3)
    End If
    'checkpoint 17
    '506.8 Megs Urmilla
    'XX = Maskseq(17)
    Call PrintNames
    
    'Store namelengths
    
    ReDim pMaskSeq(NextNo)
    For x = 0 To NextNo
        pMaskSeq(x) = MaskSeq(x)
    Next x
    If BSCutOff = 0 Then BSCutOff = 0.95
   
    Dim VDouble As Double
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    VDouble = Sqr(APhys)
    
    VScroll3.Value = 0
    
    
    
    
    If ReassortmentFlag > 0 Then
        
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                'TBP = RBPPos(X)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
    
    End If
    'permseqnum is a permanent record of the sequences that are loaded up
    
    If NextnoBak = 0 Or NextNo = NextnoBak Then
        DoExcludes = 0
    End If
    
'    SS = Abs(GetTickCount)
    If (Len(StrainSeq(0))) * NextNo * 4 > 5000000 Then
        PermSeqNumInFile = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        '@
        Put #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        ReDim PermSeqNum(0, 0)
    Else
        PermSeqNumInFile = 0
        ReDim PermSeqNum(Len(StrainSeq(0)), NextNo)
        Dummy = CopySeqs(Len(StrainSeq(0)), NextNo, SeqNum(0, 0), PermSeqNum(0, 0))
    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X
'    EEE = Abs(GetTickCount)
'    ttt = EEE - SSS '13203,5109 (rediming just before copyseq)
'    X = X
    '0.031s
    
    
'This is needed for the fast findsubseq routines
   'Call MakeIntegerSeq3
    '506.8 Megs Urmilla
   
   For x = 0 To 20
     MatZoom(x) = 1
   Next x
   VRFlag = 0
   CurMatrixFlag = 255
    
    F2TreeIndex = 0
    ExRecFlag = 0
    
    'check if this is experimental data
    Dim DoneP() As Byte, ChimPair As Long
    ReDim DoneP(NextNo), ParentSeqs(1), ChimaeraSeqs(NextNo, 1), RefChimaera(NextNo)
    ChimaeraNum = -1: ChimPair = 0
    ParentSeqs(0) = -1
    ParentSeqs(1) = -1
    '506.8 Megs
    For x = 0 To NextNo
        If InStr(1, LCase(OriginalName(x)), "parent 1", vbTextCompare) > 0 Or InStr(1, LCase(OriginalName(x)), "parent1", vbTextCompare) > 0 Or InStr(1, LCase(OriginalName(x)), "parent_1", vbTextCompare) > 0 Then
            DoneP(x) = 1
            ParentSeqs(0) = x
            RefChimaera(x) = -1
            For Y = 0 To NextNo
                If DoneP(Y) = 0 Then
                    If InStr(1, LCase(OriginalName(Y)), "parent 2", vbTextCompare) > 0 Or InStr(1, LCase(OriginalName(Y)), "parent2", vbTextCompare) > 0 Or InStr(1, LCase(OriginalName(Y)), "parent_2", vbTextCompare) > 0 Then
                        ParentSeqs(1) = Y
                        DoneP(Y) = 1
                        RefChimaera(Y) = -1
                        ExRecFlag = 1
                        'now check for chimaera experiment
                        For A = 0 To NextNo
                            RefChimaera(A) = ChimaeraNum
                            If DoneP(A) = 0 Then
                                If InStr(1, OriginalName(A), "chimaera", vbTextCompare) > 0 Or InStr(1, OriginalName(A), "chimera", vbTextCompare) > 0 Then
                                    RefChimaera(A) = -1
                                    If ChimPair = 0 Then
                                        ChimaeraNum = ChimaeraNum + 1
                                    Else
                                        Chimaeraflag = 1
                                    End If
                                    
                                    ChimaeraSeqs(ChimaeraNum, ChimPair) = A
                                    ChimPair = ChimPair + 1
                                    If ChimPair > 1 Then
                                        ChimPair = 0
                                    End If
                                End If
                                'Exit For
                            End If
                        Next A
                        
                        Exit For
                    End If
                End If
            Next Y
            Exit For
        End If
    Next x
    
    
    If ParentSeqs(1) = -1 Then
        ParentSeqs(0) = -1
    End If
'    If InStr(1, OriginalName(0), "parent", vbTextCompare) > 0 Or InStr(1, OriginalName(0), "parent 1", vbTextCompare) > 0 Or InStr(1, OriginalName(0), "parent1", vbTextCompare) > 0 Or InStr(1, OriginalName(0), "parent_1", vbTextCompare) > 0 Then
'        If InStr(1, OriginalName(1), "parent", vbTextCompare) > 0 Or InStr(1, OriginalName(1), "parent 2", vbTextCompare) > 0 Or InStr(1, OriginalName(1), "parent2", vbTextCompare) > 0 Or InStr(1, OriginalName(1), "parent_2", vbTextCompare) > 0 Then
'
'            ExRecFlag = 1
'             If InStr(1, OriginalName(2), "chimaera", vbTextCompare) > 0 Or InStr(1, OriginalName(2), "chimaera 1", vbTextCompare) > 0 Or InStr(1, OriginalName(2), "chimaera1", vbTextCompare) > 0 Or InStr(1, OriginalName(2), "chimaera_1", vbTextCompare) > 0 Then
'                If InStr(1, OriginalName(3), "chimaera", vbTextCompare) > 0 Or InStr(1, OriginalName(3), "chimaera 2", vbTextCompare) > 0 Or InStr(1, OriginalName(3), "chimaera2", vbTextCompare) > 0 Or InStr(1, OriginalName(3), "chimaera_2", vbTextCompare) > 0 Then
'                    Chimaeraflag = 1
'                End If
'            End If
'        End If
'    End If
    
    
    
    
    If RefNum < 2 Then
        QvRAutoAssignableFlag = 0
        QvRFlag = 0
        RefNum = 0
        If CLine = "" Or CLine = " " Then
            Call CheckQueryReference
        End If
    ElseIf CLine = "" Or CLine = " " Then
        QvRFlag = 1
    End If
    If QvRFlag = 1 Then
        Call PrintNames
    End If
    ReDim PDistPlt(0, 0)
    ReDim ProbPlt(0, 0)
    ReDim HitPlt(0, 0)
    ReDim Hitnumber(0)
    Rnd (-BSRndNumSeed)
    '506.8 Megs
'    XX = MCCorrection
    If AutoMultFlag > 0 Then
        'do analyses and write results here
        oDirX = CurDir
        
        'ShortOutFlag = 100 'ie do a full scan and exit
        Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor)) + ":  " + PFName + " {examining " + Trim(Str(AFN + 1)) + " of " + Trim(Str(AutoMultFlag + 1)) + " datasets)"
            
        Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
    
        Call MakeS1S2S3
        StillLoadingFlag = 0
        Call Command22_Click
        InFileX = ActualFName$
        Call WriteRDPFile(InFileX & ".rdp")
        
        Call MakeCSV(InFileX & ".csv", 6)
        
        Call SaveAlign(InFileX & "-Dispersed.fas", 0, OriginalName(), 7)
        
        If AFN = 0 Then
            OverView(0) = "File number, Alignment file name, Total number of unique recombination events detected, Total number of unique recombination events detected by > " + Trim(Str(ConsensusProg)) + " different recombination detection methods" + ", Total number of events that might be attributable to evolutionary processes other than recombination, Highly probable recombination events detected by > " + Trim(Str(ConsensusProg)) + " different recombination detection methods"
            OverviewHotspots(0) = "File number, Aligment file name, Total number of unique recombination events detected, Total BPs mapped, Global 99%, Global 95%, 6.0-6.1K peak max, Local 99%, Local 95%, TP's > global 99%, TP's >global 95%, TP's >local 99%, TP's >local 95%, FP's > global 99%, FP's >global 95%, FP's >local 99%, FP's >local 95%, TP nucs > global 99%, TP nucs >global 95%, TP nucs >local 99%, TP nucs >local 95%, FP nucs > global 99%, FP nucs >global 95%, FP nucs >local 99%, FP nucs >local 95%"
            OverviewHotspots2(0) = "File number, Aligment file name, Total number of unique recombination events detected, Total BPs mapped, Global 99%, Global 95%, 6.0-6.1K peak max, Local 99%, Local 95%, TP's > global 99%, TP's >global 95%, TP's >local 99%, TP's >local 95%, FP's > global 99%, FP's >global 95%, FP's >local 99%, FP's >local 95%, TP nucs > global 99%, TP nucs >global 95%, TP nucs >local 99%, TP nucs >local 95%, FP nucs > global 99%, FP nucs >global 95%, FP nucs >local 99%, FP nucs >local 95%"
        
        End If
        
        Dim NonSus As Long
        NonSus = 0
        For x = 0 To SEventNumber
            If YannWarn(x) = 1 Then NonSus = NonSus + 1
        Next x
        
        
        
        
        OverView(AFN + 1) = Trim(Str(AFN + 1)) + "," + InFileX + "," + Trim(Str(SEventNumber)) + "," + Trim(Str(NumEventsAboveCO)) + "," + Trim(Str(NonSus)) + "," + Trim(Str(NUCO))
        
        If x = x Then
            For bpc = 0 To 1
                Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor)) + ":  " + PFName + " {examining " + Trim(Str(AFN + 1)) + " of " + Trim(Str(AutoMultFlag + 1)) + " datasets)"
                If bpc = 0 Then
                    Call BPDistPltMnu_Click
                    Call SaveTxtMnu_Click
                Else
                    Call BPDistPltMnu2_Click
                    Call SaveTxtMnu_Click
                End If
                'GCritval(2) = BPCVal(0, 0)
                'GCritval(3) = BPCVal(0, 1)
                Dim MaxV As Single, MaxVP As Long
                Dim FP() As Byte, TP() As Long
                ReDim TP(10)
                ReDim FP(3, Len(StrainSeq(0)))
                
                MaxVP = -1
                If bpc = 0 Then
                    MaxV = 0
                    For x = 1 To Len(StrainSeq(0))
                        If x > 5899 And x < 6301 Then
                            If MaxV < GPrint(2, x) Then
                                MaxV = GPrint(2, x)
                                MaxVP = x
                                
                            End If
                        End If
                        If GPrint(2, x) > GCritval(2) Then 'global99%
                            FP(0, x) = 1
                        End If
                        If GPrint(2, x) > GCritval(3) Then 'global 95%
                            FP(1, x) = 1
                        End If
                        If GPrint(2, x) > GPrint(0, x) Then 'local 99%
                            FP(2, x) = 1
                        End If
                        If GPrint(2, x) > GPrint(1, x) Then 'local 95%
                            FP(3, x) = 1
                        End If
                    Next x
                Else
                    MaxV = 100000
                    For x = 1 To Len(StrainSeq(0))
                        If x > 5899 And x < 6301 Then
                            If MaxV > GPrint(2, x) Then
                                MaxV = GPrint(2, x)
                                MaxVP = x
                                
                            End If
                        End If
                        
                        If GPrint(2, x) < GPrint(0, x) Then 'local 99%
                            FP(2, x) = 1
                        End If
                        If GPrint(2, x) < GPrint(1, x) Then 'local 95%
                            FP(3, x) = 1
                        End If
                    Next x
                End If
                Dim TP2() As Long
                ReDim TP2(7)
                For Y = 0 To 3
                    For x = 1 To Len(StrainSeq(0))
                    
    '                    If FP(Y, x) = 1 Then
    '                        Z = x + 1
    '                        Do While Z <= Len(StrainSeq(0))
    '                            If FP(Y, Z) = 0 Then Exit Do
    '                            Z = Z + 1
    '                            DoEvents
    '                        Loop
    '                        Z = Z - 1
                            If x < 6401 And x > 5799 Then 'its the planned hotspot
                                If x < 6101 And x > 5999 Then
                                    TP2(Y) = TP2(Y) + FP(Y, x)
                                End If
                            Else
                                TP2(Y + 4) = TP2(Y + 4) + FP(Y, x)
                            End If
    '                        x = Z
    '                    End If
    '                    x = x + 1
    '                    DoEvents
                    Next x
                    x = x
                Next Y
                For Y = 0 To 3
                    x = 1
                    Do While x <= Len(StrainSeq(0))
                        If FP(Y, x) = 1 Then
                            Z = x + 1
                            Do While Z <= Len(StrainSeq(0))
                                If FP(Y, Z) = 0 Then Exit Do
                                Z = Z + 1
                                DoEvents
                            Loop
                            Z = Z - 1
                            If x < 6401 And Z > 5799 Then 'its the planned hotspot
                                TP(Y) = 1
                            Else
                                TP(Y + 4) = TP(Y + 4) + 1
                            End If
                            x = Z
                        End If
                        x = x + 1
                        DoEvents
                    Loop
                
                Next Y
                
                
                'OverviewHotspots(0) = "File number,         Aligment file name, events detected,             Global 99%,                        Global 95%,         Local 99%, Local 95%, 6.0-6.1K peak height, FP's > local 99%, FP's >Local 95%, FP's >global 99%, FP's >global 95%"
                If bpc = 0 Then
                    If MaxVP > -1 Then
                        OverviewHotspots(AFN + 1) = Trim(Str(AFN + 1)) + "," + InFileX + "," + Trim(Str(SEventNumber)) + "," + Trim(Str(RememberBreakpointNum)) + "," + Str(GCritval(2)) + "," + Str(GCritval(3)) + "," + Str(MaxV) + "," + Str(GPrint(0, MaxVP)) + "," + Str(GPrint(1, MaxVP)) + "," + Str(TP(0)) + "," + Str(TP(1)) + "," + Str(TP(2)) + "," + Str(TP(3)) + "," + Str(TP(4)) + "," + Str(TP(5)) + "," + Str(TP(6)) + "," + Str(TP(7)) + "," + Str(TP2(0)) + "," + Str(TP2(1)) + "," + Str(TP2(2)) + "," + Str(TP2(3)) + "," + Str(TP2(4)) + "," + Str(TP2(5)) + "," + Str(TP2(6)) + "," + Str(TP2(7))
                    Else
                        OverviewHotspots(AFN + 1) = Trim(Str(AFN + 1)) + "," + InFileX + "," + Trim(Str(SEventNumber)) + "," + Trim(Str(RememberBreakpointNum)) + "," + Str(GCritval(2)) + "," + Str(GCritval(3)) + "," + Str(MaxV) + "," + "-1" + "," + "-1" + "," + Str(TP(0)) + "," + Str(TP(1)) + "," + Str(TP(2)) + "," + Str(TP(3)) + "," + Str(TP(4)) + "," + Str(TP(5)) + "," + Str(TP(6)) + "," + Str(TP(7)) + "," + Str(TP2(0)) + "," + Str(TP2(1)) + "," + Str(TP2(2)) + "," + Str(TP2(3)) + "," + Str(TP2(4)) + "," + Str(TP2(5)) + "," + Str(TP2(6)) + "," + Str(TP2(7))
                        
                    End If
                Else
                    OverviewHotspots2(AFN + 1) = Trim(Str(AFN + 1)) + "," + InFileX + "," + Trim(Str(SEventNumber)) + "," + Trim(Str(RememberBreakpointNum)) + "," + Str(GCritval(2)) + "," + Str(GCritval(3)) + "," + Str(MaxV) + "," + Str(GPrint(0, MaxVP)) + "," + Str(GPrint(1, MaxVP)) + "," + Str(TP(0)) + "," + Str(TP(1)) + "," + Str(TP(2)) + "," + Str(TP(3)) + "," + Str(TP(4)) + "," + Str(TP(5)) + "," + Str(TP(6)) + "," + Str(TP(7)) + "," + Str(TP2(0)) + "," + Str(TP2(1)) + "," + Str(TP2(2)) + "," + Str(TP2(3)) + "," + Str(TP2(4)) + "," + Str(TP2(5)) + "," + Str(TP2(6)) + "," + Str(TP2(7))
                End If
            Next bpc
            
            
        End If
        'Do Brief Output
        'Call DoBriefOut(InfileX & "-Recombinants.csv"
        'Call Command12_Click(1)
        
        If DebuggingFlag < 2 Then On Error Resume Next
        ChDir (oDirX)
        ChDrive (oDirX)
        On Error GoTo 0
        AFN = AFN + 1
        
        If AFN <= AutoMultFlag Then
    'If CombinedFileFlag = 1 Then
            ReDim tXOList(UBound(XoverList, 1), UBound(XoverList, 2))
            ReDim tCurrentxover(UBound(CurrentXOver))
            For x = 0 To UBound(XoverList, 1)
                tCurrentxover(x) = CurrentXOver(x)
                For Y = 0 To tCurrentxover(x)
                    tXOList(x, Y) = XoverList(x, Y)
                Next Y
            Next x
            ReDim tCurrentxoverMi(UBound(BCurrentXoverMi)), tCurrentxoverMa(UBound(BCurrentXoverMa))
            ReDim tXOListMa(UBound(BestXOListMa, 1), UBound(BestXOListMa, 2))
            ReDim tXOListMi(UBound(BestXOListMi, 1), UBound(BestXOListMi, 2))
            For x = 0 To UBound(BestXOListMi, 1)
                tCurrentxoverMi(x) = BCurrentXoverMi(x)
                For Y = 0 To tCurrentxoverMi(x)
                    tXOListMi(x, Y) = BestXOListMi(x, Y)
                Next Y
            Next x
            For x = 0 To UBound(BestXOListMa, 1)
                tCurrentxoverMa(x) = BCurrentXoverMa(x)
                For Y = 0 To tCurrentxoverMa(x)
                    tXOListMa(x, Y) = BestXOListMa(x, Y)
                Next Y
            Next x
            
            GoTo DoNextAFN
        Else
            
        
        

            FFX = FreeFile
            
            Dim NumCycle As Long, OFName As String
            NumCycle = 0
            OFName = "Ananlysis Overview.csv"
            
            Do
                If DebuggingFlag < 2 Then On Error Resume Next
                Open OFName For Output As #FFX
                On Error GoTo 0
                FFY = FreeFile
                If FFY = FFX And NumCycle = 0 Then
                    MsgBox ("A file with the name 'Ananlysis Overview.csv' is already open.  Close the file and then press the OK button.  If you'd like to keep the version of 'Ananlysis Overview.csv' that is currently open save it under another name (it will be overwritten once you close it).")
                     NumCycle = NumCycle + 1
                ElseIf FFY = FFX And NumCycle = 1 Then
                    OFName = "Ananlysis Overview " + Trim(Str(CLng(Rnd * 10000))) + ".csv"
                    NumCycle = 0
                    MsgBox ("OK then. The overview file will be saved under the name '" + OFName + "'.")
                Else
                    Exit Do
                End If
                
            Loop
            Print #1, "sep=,"
            For x = 0 To AFN
                Print #1, OverView(x)
            Next x
            NumCycle = NumCycle + 1
                
            
            Close #FFX
            
            FFX = FreeFile
            
            Open "Hotspot Overview.csv" For Output As #FFX
            For x = 0 To AFN
                Print #1, OverviewHotspots(x)
            Next x
            Close #FFX
            Open "Hotspot Overview P-val.csv" For Output As #FFX
            For x = 0 To AFN
                Print #1, OverviewHotspots2(x)
            Next x
            Close #FFX
            AutoMultFlag = 0
        
        
        
        End If
    End If
'    ReDim TraceSub(Nextno)
'    For X = 0 To Nextno
'        TraceSub(X) = X
'    Next X
    MaxDiffs = 0
    If SEventNumber = 0 Then
        For x = 0 To NextNo
            For Y = x + 1 To NextNo
                If PermDIffs(x, Y) > MaxDiffs Then
                    MaxDiffs = PermDIffs(x, Y)
                    WinX = x
                    WinY = Y
                End If
            Next Y
        Next x
        
        'now find the sequence that has the greatest total distance to these two
        MaxDiffs = 0
        For Z = 0 To NextNo
            If MaxDiffs < PermDIffs(WinX, Z) + PermDIffs(WinY, Z) Then
                MaxDiffs = PermDIffs(WinX, Z) + PermDIffs(WinY, Z)
                winz = Z
            End If
        
        Next Z
        'work out suseq distance between winx,winy and winz
        
    Else
        Dim UBPD As Long
        UBPD = UBound(PermDIffs, 1)
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                DA = XoverList(x, Y).Daughter
                Ma = XoverList(x, Y).MajorP
                Mi = XoverList(x, Y).MinorP
                If UBPD <= DA And UBPD <= Ma And UBPD <= Mi Then
                    If DA <= UBound(PermDIffs, 1) Then
                        If Ma <= UBound(PermDIffs, 1) And Mi <= UBound(PermDIffs, 1) Then
                            If PermDIffs(DA, Ma) > MaxDiffs Then
                                MaxDiffs = PermDIffs(DA, Ma)
                                WinX = DA
                                WinY = Ma
                                If MaxDiffs < PermDIffs(WinX, Mi) + PermDIffs(WinY, Mi) Then
                                    MaxDiffs = PermDIffs(WinX, Mi) + PermDIffs(WinY, Mi)
                                    winz = Mi
                                End If
                            End If
                            
                        End If
                        'XX = NextNo
                        If Mi <= UBound(PermDIffs, 1) And Ma <= UBound(PermDIffs, 1) Then
                            If PermDIffs(DA, Mi) > MaxDiffs Then
                                MaxDiffs = PermDIffs(DA, Mi)
                                WinX = DA
                                WinY = Mi
                                
                                If MaxDiffs < PermDIffs(WinX, Ma) + PermDIffs(WinY, Ma) Then
                                    MaxDiffs = PermDIffs(WinX, Ma) + PermDIffs(WinY, Ma)
                                    winz = Ma
                                End If
                            End If
                        End If
                    End If
                    'If Ma <= UBound(PermDIffs, 1) And Mi <= UBound(PermDIffs, 1) Then
                    If PermDIffs(Ma, Mi) > MaxDiffs Then
                        MaxDiffs = PermDIffs(Ma, Mi)
                        WinX = Ma
                        WinY = Mi
                        
                        If MaxDiffs < PermDIffs(WinX, DA) + PermDIffs(WinY, DA) Then
                            MaxDiffs = PermDIffs(WinX, DA) + PermDIffs(WinY, DA)
                            winz = DA
                        End If
                    End If
                    'End If
                End If
            Next Y
    
        Next x
        
    End If
    
    
    
    
    
    GCDimSize = 0
    For x = 1 To Len(StrainSeq(0))
        If SeqNum(x, WinX) <> SeqNum(x, WinY) Or SeqNum(x, WinX) <> SeqNum(x, winz) Then
            GCDimSize = GCDimSize + 1
        End If
    
    Next x
    GCDimSize = GCDimSize + 10
    
'    GCDimSize = 0
'    For X = 0 To Len(StrainSeq(0))
'        GCDimSize = GCDimSize + Identical(X)
'    Next X
'    GCDimSize = (Len(StrainSeq(0)) - GCDimSize + 1) / 4 '/ 2
    MaxRequiredFraglen = GCDimSize
    'GCDimSize = Len(StrainSeq(0)) 'it crashes getfrags if it is too small
    
    
    
    'checkpoint 14 - before setupscanarrays
    '695316
    '3seq lookup table
    '431.2 Urmilla
    Call SetUpScanArrays(0)
    
    
    'Call MakeLookupYZ
    Command18.Width = Command1.Width
    Command18.ToolTipText = "Save alignment in a different format"
    Command18.Enabled = True
    Command2(1).Visible = True
    SSPanel1.Caption = ""
    ProgressBar1.Value = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
    Form1.ZOrder
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
   ' XX = RBPPos(9)
'    XX = Len(StrainSeq(0))
'    eeee = Abs(GetTickCount)
'    tttt = eeee - SSSS
    '108.826'92.4256 without recalculating distance matrix and with quicker daught read
    P7ZoomLevel = 0
    '506.8 Urmilla
    If MCCorrection = 0 Then
        Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
    End If
    Call MakeS1S2S3
    '506.8 Megs Urmilla
    

    If ORFFlag = 0 And (CLine = "" Or CLine = " ") And Len(StrainSeq(0)) < 500000 And AutoMultFlag = 0 Then
        Resetload = 0
        StartFetch = Abs(GetTickCount)
        'get the sequence with the smallest average distance to any other sequences
        
'        If DebuggingFlag < 2 Then On Error Resume Next
'         Form5.Inet2.Cancel
'        On Error GoTo 0
        F5T1Executing = 0
        F5T2Executing = 0
        F5T3Executing = 0
        GenBankFetchStep = 3
        GenBankFetchStep2 = 3
        GenBankFetchStep3 = 3
'        Form5.Timer1.Enabled = True 'this tries to find geneinfo etc about the loaded sequences
'        Form5.Timer2.Enabled = True
        Form5.Timer3.Interval = 1
        Form5.Timer4.Interval = 1
        
        
        Form5.Timer3.Enabled = True
        
        Form5.Timer4.Enabled = True
    Else
        GenBankFetchStep = 1000
        GenBankFetchStep2 = 1000
        GenBankFetchStep3 = 1000
    End If
    EE = Abs(GetTickCount)
    TT = EE - rdptime '68.672, 19.062 for new format
    '70.266, 37.094
    'XX = SeqFile
    ReDim StatsDump(2, 51, 100)
    
    If AutoMultFlag = 0 Then
        If RelX > 0 Or RelY > 0 Then
            Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
        End If
    End If
    
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Form1.Enabled = True
    '506.8 Megs
    StillLoadingFlag = 0
    Exit Sub '65.175 '28.884,26.219,26.049, 22.703, 20.688,20.078
    '20.469, 20.844, 20.610
    '19.750
    '0.5 seconds
    
FileNotFound:
    
    Response = MsgBox("I could not find this file (" + FName + ").  It may either no longer exist or be on a network drive that is not currently mapped.", 48)
    
    SSPanel1.Caption = ""
    ProgressBar1.Value = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
    FName$ = ""
    UFTag = oFTag
    StillLoadingFlag = 0
    Exit Sub
End Sub

Private Sub Command1_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Picture3.Refresh
Picture2.Refresh
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub



Private Sub Command10_Click()
Command3.SetFocus
Form1.RSortMnu2.Caption = "Re-identify recombinant sequences for all unaccepted events"
Call RSortMnu2_Click
If DebuggingFlag < 2 Then On Error Resume Next
'For X = 1 To 2
'    If Form2.VScroll1(X) = 1 Then
'        Form2.VScroll1(X) = 0
'    Else
'        Form2.VScroll1(X) = 1
'    End If
'Next X
On Error GoTo 0
End Sub



Private Sub Command10_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
    Picture6.Refresh
    CurFlash = 0
    Timercheck(1) = 0
    Call Timer1_Timer
    HighlightFlag = 0
    RecSeq = 0
    PAVal = 0
    If RIMode = 1 Then
        Call MakeSummary
    End If
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command11_Click()

End Sub

Private Sub Command12_Click(Index As Integer)
If CLine = "" Or CLine = " " Then
    Command3.SetFocus
End If


If CurrentlyRunningFlag = 1 Then Exit Sub
If Index = 0 Then 'Options button
    If SEventNumber > 0 Then DontRefreshFlag = 1
    Form3.Combo1.Enabled = True
    Dim x As Long
    Timer2.Enabled = True
    Timer2.Interval = 500
    OKPress = 0
    ErrorFlag = 0
    OptFlag = OptFlag
    SSPanel2.Enabled = False
    SSPanel3.Enabled = False
    SSPanel4.Enabled = False
    SSPanel5.Enabled = False
    SSPanel6(0).Enabled = False
    SSPanel6(1).Enabled = False
    SSPanel6(2).Enabled = False
    SSPanel8.Enabled = False
    SpacerFlagT = SpacerFlag
    
    Call SetF3Vals(1)
    
    Form1.Enabled = False
    
    DoEvents
    Form3.Visible = True
    Form3.Command1.SetFocus
ElseIf Index = 1 Then 'Exit button
    Dim Response As Integer

    If RunFlag = 1 And SaveFlag = 0 And CLine = "" Then
        
        Response = MsgBox("Would you like to save your analysis results befor exiting?", 36)

        If Response = 7 Then
        Else
            Rffflag = 2
            Call Command18_Click

        End If

    End If
    
'    Unload Form2
'    Unload Form3
'    Unload Form4
'    Unload Form5
'    Unload Form6
'    Unload Form7
'    Unload frmSplash
    
    'Call Form_Terminate
    Unload Me
    'Call Form_Unload(0)
    'End
End If
End Sub

Private Sub Command12_MouseDown(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
If Index = 0 Then
    OptFlag = -1
ElseIf Index = 1 Then
End If
End Sub

Private Sub Command12_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
Picture3.Refresh
Picture2.Refresh
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command13_Click(Index As Integer)
    SSPanel6(2).Enabled = True
    Dim OV As Long
    If CLine = "" Or CLine = " " Then
        If DebuggingFlag < 2 Then On Error Resume Next
        'XX = Command3.Enabled
        If Command3.Enabled = True Then
            Command3.SetFocus
        End If
        On Error GoTo 0
    End If
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
    '506.8
    If Index = 0 Then
        If TreeTypeFlag = 3 And CTF > 0 Then
            SSPanel6(1).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(2).Visible = False
        Else
            If (RunFlag = 0 And NJDrawFlag = 0) Or TreeImage(0) = 0 Then
                CTF = 0
            End If
            
            If TreeTypeFlag = 0 Or BRunning = 1 Then
                If TBLLen = 0 Then
                    Call Command7_Click
                Else
                    Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, 0, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                End If
            Else
                If RelX = 0 And RelY = 0 Then
                    Call ModNextno
                    If Form1.VScroll1.Value <> 0 Or Form1.VScroll1.Value <> 1 Then
                        If Form1.VScroll1.Value = 1 Then
                            Form1.VScroll1.Value = 0
                        Else
                            If Form1.VScroll1.Max <= 1 Then
                                OV = Form1.VScroll1.Enabled
                                Form1.VScroll1.Enabled = True
                                Form1.VScroll1.Max = 1
                                Form1.VScroll1.Max = 1
                                Form1.VScroll1.Enabled = OV
                            End If
                            Form1.VScroll1.Value = 1
                        End If
                    Else
                        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                    End If
                    
                End If
                
            End If
            If Eventnumber > 0 And (RelX > 0 Or RelY > 0) Then
                Call Command17_Click
            Else
                SSPanel6(1).Visible = True
                SSPanel6(0).Visible = False
                SSPanel6(2).Visible = False
            End If
        End If
    
    ElseIf Index = 1 Then
        
        If CurMatrixFlag = 8 Then
            Call MCXoverK(0)
        ElseIf CurMatrixFlag = 11 Then
            Call DrawLRDMat
        
        ElseIf CurMatrixFlag = 255 And (RelX > 0 Or RelY > 0) Then
            Call MCMatMnu_Click
        End If
        If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
    ElseIf Index = 2 Then
        If RIMode = 0 Then
            VS4Max = VScroll4.Max
            
            
            RIMode = 1
            If ShowPlotFlag = 1 Or ShowPlotFlag = 2 Then
                Frame17.Visible = False
            End If
            Command13(2).Caption = "Recombination Info"
            If RelX > 0 Or RelY > 0 Then
                Command13(2).ToolTipText = "Press for detailed information on recombiation event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
            Else
                Command13(2).ToolTipText = "Press for detailed information on recombiation event 1"
            End If
            
            Picture2.Picture = LoadPicture()
            If VS4Max2 <= 0 Then
                VS4Max2 = (Form1.Picture2.TextHeight("O") + 2) * (SEventNumber + 4) - (Form1.Picture32.Height / Screen.TwipsPerPixelY)
                If VS4Max2 < 0 Then VS4Max = 0
            End If
            If VS4Max2 > 32000 Then
                V4Adj = vs2max2 / 32000
                VS4Max2 = 32000
                
            End If
            VScroll4.Max = VS4Max2
            If VScroll4.Value <> VS4CV Then
                If VS4CV > VScroll4.Max Then
                    VS4CV = VScroll4.Max
                End If '
                If VS4CV > VScroll4.Max Then VS4CV = VScroll4.Max
                If VS4CV < VScroll4.Min Then VS4CV = VScroll4.Min
                VScroll4.Value = VS4CV
            Else
                Call MakeSummary
            End If
            '506.8  Urmilla
            x = x
        Else
            RIMode = 0
            VS4Max2 = VScroll4.Max
            VS4CV = VScroll4.Value
            VScroll4.Value = 0
            VScroll4.Max = VS4Max
            
            
            Command13(2).Caption = "Overview"
            Command13(2).ToolTipText = "Press for summarized information on recombination events 1 through " + Trim(Str(SEventNumber))
            'Picture2.Height = 2500
            'If PermXVal > 0 And PermYVal > 0 Then
                If RelX > 0 Or RelY > 0 Then
                    PAVal = RelY
                    RecSeq = RelX
                    Pic7GoonFlag = 1
                    If RIMode = 0 Then
                        Call MakeRecombinationInfo(RecSeq, PAVal)
                    End If
                    'Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
                    'Call Picture6_MouseMove(0, 1, PermXVal, (PermYVal - VScroll2.Value * F1VS2Adj))
                    Pic7GoonFlag = 0
                End If
            'End If
        End If
        
        'update RInfo display
    
    
    
    End If
    XX = CurrentXOver(0)
    x = x
End Sub

Private Sub Command13_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub





Private Sub Command14_Click()

If NextNo < 1 Then Exit Sub

Dim TestString As String, FF As Long, LenTest As Long
LenTest = val(Text2.Text)
FF = FreeFile
FNameX = FName + " string length =" + Str(LenTest) + " outfile.csv"
Open FNameX For Output As #FF
For x = 0 To NextNo
    Y = 1
    Do
        TestString = Mid(StrainSeq(x), Y, LenTest)
        If Left(TestString, 1) <> "-" Then Exit Do
        Y = Y + 1
    Loop
    
    
    Pos = InStr(LenTest + Y, StrainSeq(x), TestString, vbBinaryCompare)
    If Pos > 0 Then
        Print #FF, Trim(Str(x + 1)) + "," + " > " + StraiName(x) + "," + TestString + "," + Trim(Str(Pos))
    End If
    Form1.ProgressBar1 = (x / NextNo) * 100
    Call UpdateF2Prog
Next x
Close #FF
Form1.ProgressBar1 = 0
Call UpdateF2Prog
MsgBox ("Outfile written to " + CurDir + FNameX)

End Sub

Private Sub Command15_Click()

Dim TestDistance() As Long, TT As Long
SS = GetTickCount
Call HammingDistance(StrainSeq(), TestDistance())
EE = GetTickCount
TT = EE - SS
x = x
Exit Sub
'StatsDumpFlag = 1
'Exit Sub
Call DumpStatsToFile(InFileX & "RecombIdentifyStats.csv")
XX = CurDir
XX = XX
Exit Sub
Call LoadActualEvents(ActualEventList(), "RPD_Output_TestSet_2022-08-21-10_36_55_3300-0.07-0.000114-150.rdp5ML", NumActualEvents)

Exit Sub
XX = OriginalPos(102) '668
XX = OriginalPos(190) '1336
XX = OriginalPos(272) '2004
XX = OriginalPos(385) '2672
XX = OriginalPos(517) '3340
XX = OriginalPos(642) '4008
XX = OriginalPos(834) '4630
Exit Sub
Dim NTC() As Long, OS As String
OS = String(Len(StrainSeq(0)), " ")
Open "redo with parents" For Output As #1
For x = 1 To Len(StrainSeq(0))
    ReDim NTC(255)
    For Y = 13 To 50
        
        
        NTC(SeqNum(x, Y)) = NTC(SeqNum(x, Y)) + 1
        
    Next Y
    biggest = 0
    Win = -1
    For Y = 50 To 90
        If biggest < NTC(Y) Then
            biggest = NTC(Y)
            Win = Y
        End If
    Next Y
    
    If Win > 0 Then
        Mid$(OS, x, 1) = Chr(Win - 1)
    Else
        Mid$(OS, x, 1) = "-"
    End If
    
Next x
Print #1, ">Parent 1(B1.1.7)"
Print #1, OS
OS = String(Len(StrainSeq(0)), " ")
For x = 1 To Len(StrainSeq(0))
    
    
    ReDim NTC(255)
    For Y = 53 To 85
        
        
        NTC(SeqNum(x, Y)) = NTC(SeqNum(x, Y)) + 1
        
    Next Y
    biggest = 0
    Win = -1
    For Y = 50 To 90
        If biggest < NTC(Y) Then
            biggest = NTC(Y)
            Win = Y
        End If
    Next Y
    
    
    If Win > 0 Then
        Mid$(OS, x, 1) = Chr(Win - 1)
    Else
        Mid$(OS, x, 1) = "-"
    End If
    
Next x
Print #1, ">Parent 2(B.1.351)"
Print #1, OS

For x = 95 To 238
    Print #1, ">" + OriginalName(x)
    Print #1, StrainSeq(x)
Next x

Close #1
'Call OutputRecTestCSV("Test.csv")

Exit Sub

For x = 1 To Len(StrainSeq(0))
    ReDim NTC(255)
    For Y = 0 To NextNo
        NTC(SeqNum(x, Y)) = NTC(SeqNum(x, Y)) + 1
        
    Next Y
    biggest = 0
    Win = -1
    For Y = 50 To 90
        If biggest < NTC(Y) Then
            biggest = NTC(Y)
            Win = Y
        End If
    Next Y
    biggest = -1
    Win2 = -1
    For Y = 50 To 90
        If Y <> Win Then
            If biggest < NTC(Y) Then
                biggest = NTC(Y)
                Win2 = Y
            End If
        End If
    Next Y
    If Win > -1 Then
        XX = NTC(Win)
        If NTC(Win2) < (NextNo + 1) * 0.01 Then
            For Y = 0 To NextNo
                If SeqNum(x, Y) <> Win Then
                    'XX = Chr(Win - 1)
                    Mid$(StrainSeq(Y), x, 1) = Chr(Win - 1)
                End If
            Next Y
        Else
            For Y = 0 To NextNo
                If SeqNum(x, Y) <> Win And SeqNum(x, Y) <> Win2 Then
                    'XX = Chr(Win - 1)
                    Mid$(StrainSeq(Y), x, 1) = "-"
                End If
            Next Y
        End If
    End If
Next x
Open "test.fas" For Output As #1
For x = 0 To NextNo
    Print #1, ">" + PermOriginalName(x)
    Print #1, StrainSeq(x)
Next x
Close #1

Dim NC() As Long
Dim P(2) As String
P(0) = String(Len(StrainSeq(0)), "-")
P(1) = String(Len(StrainSeq(0)), "-")
For Y = 1 To Len(StrainSeq(0))
    ReDim NC(255)
    TT = 0
    For x = 0 To NextNo
        If SeqNum(Y, x) > 46 Then
            NC(SeqNum(Y, x)) = NC(SeqNum(Y, x)) + 1
            TT = TT + 1
            'Exit Sub
        End If
    Next x
    If TT > 10 Then
        x = x
    End If
    If TT > 0 Then
        If NC(66) / TT > 0.9 Then
            Mid(P(0), Y, 1) = "A"
            Mid(P(1), Y, 1) = "A"
        ElseIf NC(66) / TT > 0.5 Then
            Mid(P(0), Y, 1) = "A"
        ElseIf NC(66) / TT > 0.1 Then
            Mid(P(1), Y, 1) = "A"
        End If
        If NC(68) / TT > 0.9 Then
            Mid(P(0), Y, 1) = "C"
            Mid(P(1), Y, 1) = "C"
        ElseIf NC(68) / TT > 0.5 Then
            Mid(P(0), Y, 1) = "C"
        ElseIf NC(68) / TT > 0.1 Then
            Mid(P(1), Y, 1) = "C"
        
        End If
        If NC(72) / TT > 0.9 Then
            Mid(P(0), Y, 1) = "G"
            Mid(P(1), Y, 1) = "G"
        ElseIf NC(72) / TT > 0.5 Then
            Mid(P(0), Y, 1) = "G"
        ElseIf NC(72) / TT > 0.1 Then
            Mid(P(1), Y, 1) = "G"
        
        End If
        'Exit Sub
        If NC(85) / TT > 0.9 Then
            Mid(P(0), Y, 1) = "T"
            Mid(P(1), Y, 1) = "T"
        ElseIf NC(85) / TT > 0.5 Then
            Mid(P(0), Y, 1) = "T"
        ElseIf NC(85) / TT > 0.1 Then
            Mid(P(1), Y, 1) = "T"
        End If
    End If
Next Y

XX = CurDir
Open "parentV2.fas" For Output As #1
Print #1, ">" + "Parent 1"
Print #1, P(0)
Print #1, ">" + "Parent 2"
Print #1, P(1)
For x = 0 To NextNo
    Print #1, ">" + OriginalName(x)
    Print #1, StrainSeq(x)
Next x
Close #1



Exit Sub
Dim Gen1() As Long, Gen2() As Long, intResult As Long, MaxX() As Long, Perms As Long
Perms = 10000
ReDim MaxX(Perms)
For x = 0 To Perms

    ReDim Gen1(10000), Gen2(10000)
    For Y = 1 To 2919
        intResult = Int((10000 * Rnd) + 1)
        Gen1(intResult) = Gen1(intResult) + 1
    Next Y
    For Y = 1 To 1118
        intResult = Int((10000 * Rnd) + 1)
        Gen2(intResult) = Gen2(intResult) + 1
    Next Y
    For Y = 0 To 10000
        If Gen2(Y) > 0 And Gen1(Y) > 0 Then MaxX(x) = MaxX(x) + 1
    Next Y
Next x

Dim ProbX As Double
For x = 0 To Perms
    If MaxX(x) >= 25 Then ProbX = ProbX + 1
    If MaxX(x) > 0 Then
        x = x
    End If
Next x
ProbX = ProbX / Perms
x = x
ProbX = 0
For x = 1 To Perms
    ProbX = ProbX + MaxX(x)
Next x
ProbX = ProbX / Perms
x = x
Exit Sub

Dim NumE As Long
NumE = 0
For x = 0 To SEventNumber
    If BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0 Then
        NumE = NumE + 1 '94
    End If
Next x
Exit Sub

ZZ = 0
For x = 0 To 9
    For Y = x + 1 To 9
        For Z = Y + 1 To 9
            For A = Z + 1 To 9
                ZZ = ZZ + 1
            Next A
        Next Z
    Next Y
    
Next x

ZZZ = (10 * 9 * 8 * 7) / 24
x = x


'    Dim DoPairs() As Byte, TP() As Byte, Mask() As Byte
'    ReDim DoPairs(NextNo, NextNo), TP(NextNo, NextNo), Mask(NextNo)
'    TP(0, 1) = 1
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            TP(x, Y) = 1
'        Next Y
'    Next x
'    'Call FastRecCheckGC(NextNo, LowestProb / MCCorrection, DoPairs(), Seqnum())
'    Call FastRecCheckGC2(NextNo, 0.05, DoPairs(), Seqnum(), TP(), Mask())
'Exit Sub

Open "Scotres.csv" For Output As #1


Print #1, "First Scan"
Print #1, ", GC, RDP / MC, FS "
Print #1, "2Hits,"; HitFirstGDP2; ","; HitFirstRDP2
Print #1, "1Hit,"; HitFirstGDP1; ","; HitFirstRDP1
Print #1, "0Hit,"; MissFirstGDP; ","; MissFirstRDP

Print #1, "Second Scan"
Print #1, "2Hits,"; HitSecondGDP2; ","; HitSecondRDP2; ","; HitSecondFDP2
Print #1, "1Hit,"; HitSecondGDP1; ","; HitSecondRDP1; ","; HitSecondFDP1
Print #1, "0Hit,"; MissSecondGDP; ","; MissSecondRDP; ","; MissSecondFDP
Print #1,
Print #1, "False Hits"
Print #1, "First Scan"
Print #1, "2Hits,"; FPHitFirstGDP2; ","; FPHitFirstRDP2; ","; FPHitFirstSDP2
Print #1, "1Hits,"; FPHitFirstGDP1; ","; FPHitFirstRDP1; ","; FPHitFirstSDP1
Print #1, "Second Scan"
Print #1, "2Hits,"; FPHitSecondGDP2; ","; FPHitSecondRDP2; ","; FPHitSecondFDP2
Print #1, "1Hits,"; FPHitSecondGDP1; ","; FPHitSecondRDP1; ","; FPHitSecondFDP1
Print #1,
Print #1, "True Misses"
Print #1, "First Scan"
Print #1, ","; FPMissFirstGDP; ","; FPMissFirstRDP
Print #1, "Second Scan"
Print #1, ","; FPMissSecondGDP; ","; FPMissSecondRDP; ","; FPMissSecondFDP



Print #1, "GC+RDP/MC"
Print #1, "First Scan"
Print #1, "Combo,Predicted and confirmed,Predicted not confirmed"
Print #1, "2R:2G,"; HitFirstRGDP22; ","; FPHitFirstRGDP22
Print #1, "2R:1G,"; HitFirstRGDP21; ","; FPHitFirstRGDP21
Print #1, "1R:2G,"; HitFirstRGDP12; ","; FPHitFirstRGDP12
Print #1, "1R:1G,"; HitFirstRGDP11; ","; FPHitFirstRGDP11
Print #1, "1R:0G,"; HitFirstRGDP10; ","; FPHitFirstRGDP10
Print #1, "0R:1G,"; HitFirstRGDP01; ","; FPHitFirstRGDP01
Print #1, "xR,"; HitFirstRGDP22 + HitFirstRGDP21 + HitFirstRGDP12 + HitFirstRGDP11 + HitFirstRGDP10; ","; FPHitFirstRGDP22 + FPHitFirstRGDP21 + FPHitFirstRGDP12 + FPHitFirstRGDP11 + FPHitFirstRGDP10
Print #1, "xG,"; HitFirstRGDP22 + HitFirstRGDP21 + HitFirstRGDP12 + HitFirstRGDP11 + HitFirstRGDP01; ","; FPHitFirstRGDP22 + FPHitFirstRGDP21 + FPHitFirstRGDP12 + FPHitFirstRGDP11 + FPHitFirstRGDP01

Print #1, "Rest,"; FPMissFirstRGDP; ","; MissFirstRGDP
Print #1, "Second Scan"
Print #1, "Combo,Predicted and confirmed,Predicted not confirmed"
Print #1, "2R:2G,"; HitSecondRGDP22; ","; FPHitSecondRGDP22
Print #1, "2R:1G,"; HitSecondRGDP21; ","; FPHitSecondRGDP21
Print #1, "1R:2G,"; HitSecondRGDP12; ","; FPHitSecondRGDP12
Print #1, "1R:1G,"; HitSecondRGDP11; ","; FPHitSecondRGDP11
Print #1, "1R:0G,"; HitSecondRGDP10; ","; FPHitSecondRGDP10
Print #1, "0R:1G,"; HitSecondRGDP01; ","; FPHitSecondRGDP01
Print #1, "xR,"; HitSecondRGDP22 + HitSecondRGDP21 + HitSecondRGDP12 + HitSecondRGDP11 + HitSecondRGDP10; ","; FPHitSecondRGDP22 + FPHitSecondRGDP21 + FPHitSecondRGDP12 + FPHitSecondRGDP11 + FPHitSecondRGDP10
Print #1, "xG,"; HitSecondRGDP22 + HitSecondRGDP21 + HitSecondRGDP12 + HitSecondRGDP11 + HitSecondRGDP01; ","; FPHitSecondRGDP22 + FPHitSecondRGDP21 + FPHitSecondRGDP12 + FPHitSecondRGDP11 + FPHitSecondRGDP01

Print #1, "Rest,"; FPMissSecondRGDP; ","; MissSecondRGDP










Print #1,
Print #1, FPMissFirstSDP
Print #1, MissFirstSDP
Print #1, HitFirstSDP1
Print #1, HitFirstSDP2

Close #1
XX = CurDir



'Call FillISInvolved(Nextno, UseALFlag, Worthwhilescan(), ISInvolved(), Analysislist())
'XX = Steps(1, 4457)
'Call Form_Unload(0)
'XX = Daught(24, 10)
'Exit Sub
XX = NextnoBak
'pos=1617-2053
XX = FullOName(4302)
XX = WhereIsExclude(6709) '97
XX = WhereIsExclude(4936) '152
XX = WhereIsExclude(7308) '132

XX = OriginalPos(XoverList(RelX, RelY).Daughter) '6709
XX = OriginalPos(XoverList(RelX, RelY).MajorP) '4936
XX = OriginalPos(XoverList(RelX, RelY).MinorP) '7308
NE = 0
For x = 1 To SEventNumber
    If BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 1 Then
        NE = NE + 1
    End If
Next x
For x = 0 To NextNo
    If OriginalPos(x) = 5 Then
        x = x
    End If
Next x



XX = MCCorrection
Dim dX As Long, dy As Long, DA As Long, DB As Long

Call SplitP(-XoverList(RelX, RelY).BeginP, dX, dy)
Exit Sub

For x = 0 To PermNextno
    For Y = 1 To CurrentXOver(x)
        If XoverList(x, Y).BeginP < 0 Then
            If x = XoverList(x, Y).Daughter Then
                x = x '120,116,254
            End If
            Call SplitP(-XoverList(x, Y).BeginP, dX, dy)
            If dy = x Then
                x = x
            End If
            If XoverList(x, Y).EndP < 0 Then
                Call SplitP(-XoverList(x, Y).EndP, DA, DB)
                If DB = x Then
                    x = x
                End If
            End If
            
        End If
        If XoverList(x, Y).BeginP < 0 And XoverList(x, Y).EndP < 0 Then
            XX = SuperEventList(XoverList(x, Y).Eventnumber) '99,106,123,125
            
            
            
            If XoverList(x, Y).BeginP = XoverList(x, Y).EndP Then
                x = x
            End If
        End If
    Next Y
Next x

Exit Sub

Dim ValX As Long, V1 As Long, V2 As Long, V3 As Long, V4 As Long



V1 = 398543
V2 = 1553

For V1 = 0 To 500000
    For V2 = 0 To 2998
        ValX = CombineP(V1, V2)
        
        
        
        Call SplitP(ValX, V3, V4)
        If V3 <> V1 Then
            x = x
        End If
        
        If V2 <> V4 Then
            x = x
        End If
    Next V2
Next V1
'V1 = Int(ValX / 4096)
x = x
Exit Sub
Dim Recoded() As Byte
Call RecodeSeqs(NextNo, SeqNum(), Recoded())

If FSSRDP(2, 1, 1, 2) = 0 Then
    Call FillFSSRDP
End If
Call MakeCompressSeq(NextNo, Recoded(), CompressSeq())

Call FindSubSeqRDPFast(CompressSeq(), 1, 2, 3, XoverSeqNumW())

Exit Sub
For x = 1 To SEventNumber
    A = BestEvent(x, 0)
    b = BestEvent(x, 1)
    Tot = ISInvolved(XoverList(A, b).Daughter) + ISInvolved(XoverList(A, b).MajorP) + ISInvolved(XoverList(A, b).MinorP)
    DScores(17, 0, x) = (ISInvolved(XoverList(A, b).Daughter) / Tot) * 50
    DScores(17, 1, x) = (ISInvolved(XoverList(A, b).MajorP) / Tot) * 50
    DScores(17, 2, x) = (ISInvolved(XoverList(A, b).MinorP) / Tot) * 50
    x = x
Next x


Exit Sub
For x = 0 To NextNo
    If OriginalPos(x) = 582 Then '24
       For Y = 1 To CurrentXOver(x)
            x = x
            XX = SuperEventList(XoverList(x, Y).Eventnumber) '1
        Next Y
    End If
'    If OriginalPos(x) = 1336 Then
'        For Y = 1 To CurrentXOver(x)
'            x = x
'            XX = SuperEventList(XOverList(x, Y).Eventnumber) '60,200
'            XX = OriginalName(x)
'        Next Y
'    End If
'    If OriginalPos(x) = 6072 Then
'        For Y = 1 To CurrentXOver(x)
'            x = x
'            XX = SuperEventList(XOverList(x, Y).Eventnumber) '225
'        Next Y
'    End If
Next x


Open "recs.txt" For Output As #1
For x = 1 To SEventNumber

    Print #1, Left(OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter), 10) + ", " + Left(OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP), 10) + ", " + Left(OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP), 10)
Next x
Close #1
x = x
'Call TripletCheck
'WebBrowser1.Navigate "http://web.cbio.uct.ac.za/~darren/rdp.html"

Exit Sub

    fX = FreeFile
    Dim BPlistpos() As Long
    ReDim BPlistpos(Len(StrainSeq(0)) + 10)
    Open "breakpointlist(unfiltered)" For Output As #fX
    For x = 1 To SEventNumber
        If BPCIs(2, x) > 0 And (BPCIs(2, x) <> BPCIs(0, x) Or BPCIs(2, x) <> BPCIs(1, x)) Then
            
            If BPlistpos(BPCIs(2, x)) = 0 Or x = x Then
                Print #fX, BPCIs(2, x) & "," & BPCIs(0, x) & "," & BPCIs(1, x)
                If BPCIs(0, x) < BPCIs(1, x) Then
                    For Y = BPCIs(0, x) To BPCIs(1, x)
                        BPlistpos(Y) = 1
                    Next Y
                Else
                    For Y = BPCIs(0, x) To Len(StrainSeq(0))
                        BPlistpos(Y) = 1
                    Next Y
                    For Y = 0 To BPCIs(1, x)
                        BPlistpos(Y) = 1
                    Next Y
                End If
            Else
                x = x
            End If
        End If
        
        If BPCIs(5, x) > 0 And (BPCIs(5, x) <> BPCIs(3, x) Or BPCIs(5, x) <> BPCIs(4, x)) Then
            If BPlistpos(BPCIs(5, x)) = 0 Or x = x Then
                Print #fX, BPCIs(5, x) & "," & BPCIs(3, x) & "," & BPCIs(4, x)
                If BPCIs(3, x) < BPCIs(4, x) Then
                    For Y = BPCIs(3, x) To BPCIs(4, x)
                        BPlistpos(Y) = 1
                    Next Y
                Else
                    For Y = BPCIs(3, x) To Len(StrainSeq(0))
                        BPlistpos(Y) = 1
                    Next Y
                    For Y = 0 To BPCIs(4, x)
                        BPlistpos(Y) = 1
                    Next Y
                End If
            Else
                x = x
            End If
        End If
        
    
    Next x
    Close #fX
    
Exit Sub
    Dim HTTPRequest As WinHttp.WinHttpRequest

    Set HTTPRequest = New WinHttp.WinHttpRequest
    With HTTPRequest
        .Open "GET", "https://utopia-game.com/wol/game/kingdoms_dump/?key=l1FdkNfdklAs", True
        .SEnd
        'XX = .ResponseBody
        
    End With
    Dim RText As String
    HTTPRequest.WaitForResponse
    XX = HTTPRequest.StatusText
    XX = HTTPRequest.GetAllResponseHeaders
    RText = HTTPRequest.ResponseText

    Set HTTPRequest = Nothing
    
'    Open "resepneheaders.txt" For Output As #1
'    Print #1, XX
'    Print #1, ""
'    Print #1, RText
'    Close #1
    Dim ProvNum As Long, LastPos As Long, Pos As Long, InvComma As String, Provinces As String, Loc As String, Land As String, Race As String, NW As String, Honor As String, protected As String, Name As String
    
    
    InvComma = Chr(34)
    Provinces = InvComma + "provinces" + InvComma
    Loc = InvComma + "loc" + InvComma
    Land = InvComma + "land" + InvComma
    Name = InvComma + "name" + InvComma
    protected = InvComma + "protected" + InvComma
    Race = InvComma + "race" + InvComma
    Honor = InvComma + "honor" + InvComma
    NW = InvComma + "nw" + InvComma
    LastPos = 1
    Pos = 0
    Dim pData() As ProvinceDetails
    ReDim pData(10000)
    ProvNum = 0
    Do
       Pos = InStr(LastPos, RText, Provinces, vbBinaryCompare)
       LastPos = Pos
       If Pos > 0 Then
            Do
                Pos = InStr(LastPos, RText, Loc, vbBinaryCompare)
                LastPos = Pos + 5
                Pos = InStr(LastPos, RText, InvComma)
                LastPos = Pos
                Pos = InStr(LastPos, RText, ":")
                'XX = Mid$(RText, LastPos, Pos - LastPos)
                ProvNum = ProvNum + 1
                XX = Mid$(RText, LastPos + 1, Pos - LastPos - 1)
                pData(ProvNum).Kingdom = val(Mid$(RText, LastPos + 1, Pos - LastPos - 1))
                LastPos = Pos
                Pos = InStr(LastPos, RText, InvComma)
                XX = Mid$(RText, LastPos + 1, Pos - LastPos - 1)
                pData(ProvNum).Island = val(Mid$(RText, LastPos + 1, Pos - LastPos - 1))
                LastPos = Pos
                GoOn = 1
                If ProvNum > 1 Then
                    If pData(ProvNum).Island <> pData(ProvNum - 1).Island Or pData(ProvNum).Kingdom <> pData(ProvNum - 1).Kingdom Then
                        Pos = InStr(LastPos, RText, Loc, vbBinaryCompare)
                        LastPos = Pos + 5
                        Pos = InStr(LastPos, RText, InvComma)
                        LastPos = Pos
                        Pos = InStr(LastPos, RText, ":")
                        pData(ProvNum).Kingdom = val(Mid$(RText, LastPos + 1, Pos - LastPos - 1))
                        LastPos = Pos
                        Pos = InStr(LastPos, RText, InvComma)
                        XX = Mid$(RText, LastPos + 1, Pos - LastPos - 1)
                        pData(ProvNum).Island = val(Mid$(RText, LastPos + 1, Pos - LastPos - 1))
                        LastPos = Pos
                        GoOn = 1
                    End If
                End If
                If GoOn = 1 Then
                    'this relly is a new province
                    'land
                    Pos = InStr(LastPos, RText, Land, vbBinaryCompare)
                    LastPos = Pos + 7
                    Pos = InStr(LastPos, RText, ",")
                    XX = Mid$(RText, LastPos, Pos - LastPos)
                    pData(ProvNum).Acres = val(Mid$(RText, LastPos, Pos - LastPos))
                    LastPos = Pos
                    
                    'prov name
                    Pos = InStr(LastPos, RText, Name, vbBinaryCompare)
                    LastPos = Pos + 9
                    Pos = InStr(LastPos, RText, ",")
                    
                    pData(ProvNum).Province = Mid$(RText, LastPos, Pos - LastPos - 1)
                    LastPos = Pos
                    x = x
                    'prov name
                    Pos = InStr(LastPos, RText, protected, vbBinaryCompare)
                    LastPos = Pos + 13
                    Pos = InStr(LastPos, RText, ",")
                    XX = Mid$(RText, LastPos, Pos - LastPos)
                    If XX = "true" Then
                        pData(ProvNum).Protection = 1
                    Else
                        pData(ProvNum).Protection = 0
                    End If
                    
                    LastPos = Pos
                    'Race
                    Pos = InStr(LastPos, RText, Race, vbBinaryCompare)
                    LastPos = Pos + 9
                    Pos = InStr(LastPos, RText, ",")
                    
                    pData(ProvNum).pRace = Mid$(RText, LastPos, Pos - LastPos - 1)
                    LastPos = Pos
                    
                    'Honor
                    'Race
                    Pos = InStr(LastPos, RText, Honor, vbBinaryCompare)
                    LastPos = Pos + 10
                    Pos = InStr(LastPos, RText, ",")
                    pData(ProvNum).pHonor = Mid$(RText, LastPos, Pos - LastPos - 1)
                    LastPos = Pos
                    
                    'NW
                    Pos = InStr(LastPos, RText, NW, vbBinaryCompare)
                    LastPos = Pos + 5
                    Pos = InStr(LastPos, RText, ",")
                    XX = Mid$(RText, LastPos, Pos - LastPos)
                    pData(ProvNum).pNW = val(Mid$(RText, LastPos, Pos - LastPos))
                    LastPos = Pos
                    
                   
                End If
            Loop
            x = x
       Else
            Exit Do
       End If
    
    Loop
    
      XX = CurDir
    
Exit Sub
Call PhilippeMap
Exit Sub
Call AderitoFold
Exit Sub
Call ExRecAssociationTest
Exit Sub
Dim NamesX() As String, CurN As Long, oDir As String
ReDim NamesX(NextNo, 2)
oDir = CurDir
ChDir App.Path
ChDrive App.Path
Open "names.csv" For Input As #1
CurN = -1
Do While Not EOF(1)
    CurN = CurN + 1
    Input #1, NamesX(CurN, 0)
    Input #1, NamesX(CurN, 1)
    Input #1, NamesX(CurN, 2)
    x = x
Loop
Close #1


For x = 0 To CurN
    Do
        Pos = InStr(1, NamesX(x, 0), "-", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(NamesX(x, 0), Pos, 1) = "_"
        Else
            Exit Do
        End If
    Loop

Next x

For x = 0 To NextNo
    Do
    Pos = InStr(1, OriginalName(x), "-", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(OriginalName(x), Pos, 1) = "_"
        Else
            Exit Do
        End If
    Loop

Next x


Dim MapToSeqs() As Long, Target As String
For x = 0 To CurN
    Target = NamesX(x, 0) 'Left(NamesX(X, 0), 10)
    For Y = 0 To NextNo
        Pos = InStr(1, OriginalName(Y), Target, vbTextCompare)
        If Pos > 0 Then
            OriginalName(Y) = NamesX(x, 1) + "_" + NamesX(x, 2) + "_" + OriginalName(Y)
        End If
    Next Y

Next x
ChDir oDir
ChDrive oDir

Exit Sub
Call TreeRootingTest

Exit Sub

'XX = StraiName(49)
'For AA = 1 To CurrentXOver(49)
'    XX = XOverlist(49, AA).Beginning
'Next AA
'Exit Sub
'Make simulated dataset
Dim Temp As String, Temp2 As String, Matrix() As Single
ChDir App.Path
ChDrive App.Path

ReDim Matrix(2690, 2690)
Open "MatA_corrected_startAC.csv" For Binary As #1
'XX = LOF(1)
Temp = String(LOF(1), " ")
Get #1, , Temp
Close #1
Pos = InStr(1, Temp, ",", vbBinaryCompare)
x = 1
Y = 1
Do
   
    Pos = InStr(Pos + 1, Temp, ",", vbBinaryCompare)
    If Pos = 0 Then Exit Do
    Pos2 = InStr(Pos + 1, Temp, ",", vbBinaryCompare)
    Temp2 = Mid$(Temp, Pos + 1, Pos2 - Pos - 1)
    If Right(Temp2, 1) <> "A" And Right(Temp2, 1) <> "C" And Right(Temp2, 1) <> "G" And Right(Temp2, 1) <> "T" Then
    
        
            Matrix(x, Y) = CSng(val(Temp2))
            x = x + 1
            If x > 2688 Then
                Y = Y + 1
                x = 1
                If Y >= 2688 Then Exit Do
                SSPanel1.Caption = Str(Y)
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
            
    Else
        x = x
    End If
    
    

Loop
Dim CountX As Long
Open "newfile.csv" For Output As #1
CountX = 0
For Y = 1 To 2688
    For x = Y + 1 To 2688
        If Matrix(x, Y) > 0 Then
            Print #1, Trim(Str(Y)) + "," + Trim(Str(x)) + "," + Trim(Str(Matrix(x, Y)))
            CountX = CountX + 1
        End If
    Next x
Next Y
Close #1
XX = CurDir
x = x
Call ExRecAssociationTest
Exit Sub
Dim cDib As New cDibSection
    Dim cDibBuffer As New cDibSection
    Dim i As Long
    Dim sPic As StdPicture
    
If x = 12345 Then
    Picture1.AutoRedraw = True
    'Form1.Picture1.Height = 100 'Form1.Picture9.ScaleHeight
    'Form1.Picture1.Width = 100 'Form1.Picture9.ScaleWidth
      ' Load the picture to fade:
      
      'SavePicture Form1.Picture1.Image, "c:/test2.bmp"
      'Set sPic = LoadPicture("c:/test2.bmp")
      Set Form1.Picture1.Picture = Form1.Picture1.Image
      'Set Form1.Picture1.Picture = LoadPicture("c:/test2.bmp")
      Set sPic = Form1.Picture1.Picture
      
      'XX = Form1.Picture1.Height
      'Set sPic = Form1.Picture1.Image
'      XX = sPic.Height '11774
'      XX = sPic.Width '31856
      cDib.CreateFromPicture sPic
      
      
      Dim papi As POINTAPI
      

'
'
'    Picture2.Enabled = True
'      BitBlt Picture2.hdc, 0, 0, Form1.Picture2.ScaleWidth, Form1.Picture2.ScaleHeight, Form1.Picture1.hdc, 0, 0, WHITENESS
'      Picture2.Refresh
      ' Create a copy of it:
      cDibBuffer.Create cDib.Width, cDib.Height
      
      Dummy = MoveToEx(cDib.hdc, 0, 0, papi)
      Dummy = LineTo(cDib.hdc, 100, 100)
'      Dummy = MoveToEx(Picture1.hdc, 0, 0, papi)
'      Dummy = LineTo(Picture1.hdc, 100, 100)
'      Picture1.Refresh
'      cDib.PaintPicture cDibBuffer.hdc
'      Picture1.Refresh
      cDib.PaintPicture Form1.Picture1.hdc
      Picture1.Refresh
      cDibBuffer.PaintPicture cDib.hdc
      Picture1.Refresh

ElseIf x = 1234567 Then
    
    Picture1.AutoRedraw = True
    'Form1.Picture1.Height = 100 'Form1.Picture9.ScaleHeight
    'Form1.Picture1.Width = 100 'Form1.Picture9.ScaleWidth
      ' Load the picture to fade:
      
      'SavePicture Form1.Picture1.Image, "c:/test2.bmp"
      'Set sPic = LoadPicture("c:/test2.bmp")
      Set Form1.Picture1.Picture = Form1.Picture1.Image
      'Set Form1.Picture1.Picture = LoadPicture("c:/test2.bmp")
      Set sPic = Form1.Picture1.Picture
      
      'XX = Form1.Picture1.Height
      'Set sPic = Form1.Picture1.Image
'      XX = sPic.Height '11774
'      XX = sPic.Width '31856
      cDib.CreateFromPicture sPic
      
   

'
'
'    Picture2.Enabled = True
'      BitBlt Picture2.hdc, 0, 0, Form1.Picture2.ScaleWidth, Form1.Picture2.ScaleHeight, Form1.Picture1.hdc, 0, 0, WHITENESS
'      Picture2.Refresh
      ' Create a copy of it:
      cDibBuffer.Create cDib.Width, cDib.Height
       
      cDib.PaintPicture cDibBuffer.hdc
      
      
    'XX = Form1.Picture1.ScaleWidth
    'XX = Form1.Picture1.ScaleHeight
    'Form1.Picture1.DrawMode = 13
      ' Fade Loop:
      For i = 0 To 255 Step 4
        ' Fade the dib by amount i:
        Fade cDib, i
        ' Draw it:
        cDib.PaintPicture Form1.Picture1.hdc
        ' Breathe a little. You may have to put a slowdown here:
        'Sleep 100
        DoEvents
        Form1.Picture1.Refresh
        ' Reset for next fade:
        cDibBuffer.PaintPicture cDib.hdc
      Next i
        Exit Sub
Else
    Dim FF As Long, TestString
    SS = Abs(GetTickCount)
    Picture1.AutoRedraw = True
    'DSDFlag = 1
    For Y = 1 To HScroll1.Max
        HScroll1.Value = Y
        '@
        DoEvents
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
         
    Next Y
    'DSDFlag = 0
    EE = Abs(GetTickCount)
    TT = EE - SS '77047, 68078 with c++ block drawing'110907, 98000, 97984, 86078, 34609
    x = x '8546 without text'4797 without text or blocks
    '120000 quality = 0
    '121766 draft quality
    '73703 73094 ANTIALIASED_QUALITY=4
    '72406 NONANTIALIASED_QUALITY
    '119422 PROOF_QUALITY = 2
    
    '74468 - FF_MODERN
    
    
    'DSDFlag = 0
End If
'HIV-75 121797,118828, 118657

'DNA-C 36141, 34734 35984 35186 (without refresh at end of doseqdisplay)
'29438, 27922 without reprinting names every cycle
'27546, 28656, 29078, 29547, 28219, 29266 -discarding os and other stuff in textout loop
'24703, 25750, 24328 - drawing smaller background with backcolours
'23562, 21515 with c++ blockdrawing
'21079 21218 20984 20704 - slightly faster drawing of tick marks
'18890 18641 18500 19015 no loadpicture for picture13
'19312, 19062 with pic4 position indicator that does not flash
'17531
'19313 with adjustments to avoid spaces
'17.641
'12531, 13422, 12578, 12375 with dibsection
'3843 with only redrawing necessary bits and bitblitting the rest
x = x
Exit Sub
SS = Abs(GetTickCount)
oDir = CurDir
ChDir App.Path
ChDrive App.Path

FF = FreeFile
Open "RefseqVirusGenomes50000.fas" For Binary As #FF
DB = String(LOF(FF), " ")
Get #FF, , DB

Close #FF
Y = 1

Do
    TestString = ""
    For x = Y To Len(StrainSeq(Z))
        If Mid$(StrainSeq(Z), x, 1) <> "-" Then
            TestString = TestString + Mid$(StrainSeq(Z), x, 1)
            If Len(TestString) = 20 Then
                Pos = InStr(1, DB, TestString, vbBinaryCompare)
                'If Pos > 0 Then
                    Exit For
                'End If
            End If
        End If
    Next x
    Y = Y + 5
    If Y > Len(StrainSeq(0)) - 50 Then
        Z = Z + 1
    End If
    If Pos > 0 Then
    
        Exit Do
    End If
    
Loop


For x = Pos To 1 Step -1
    If Mid$(DB, x, 1) = ">" Then
        XX = Mid$(DB, x, 50)
        x = x
        TT = Abs(GetTickCount)
        EE = TT - SS
        x = x
    End If
    
Next x

ChDir App.Path
ChDrive App.Path

'XX = GeneList(1).StartInAlign
'ORFFlag = 1
Exit Sub
'Call CheckGenes
Exit Sub
'Call GoOnline
Exit Sub
Open "Strain List.csv" For Append As #1
If LOF(1) = 0 Then
    Print #1, "Strain name, Isolate"
End If
For x = 0 To NextNo
    If MaskSeq(x) = 1 Then
        Print #1, "MSV-I," + OriginalName(x)
    End If
Next x


For x = 0 To NextNo
    If MaskSeq(x) = 2 Then
        Print #1, "MSV-E," + OriginalName(x)
    End If
Next x

Close #1
Exit Sub

Frame6.Visible = False
Dim PV As Double
PV = PHITest(MatrixTB(), SeqNum(), NextNo, Len(StrainSeq(0)), 0, PHIWin, 0)

Exit Sub
XX = MissedScans
XX = Unmissedscans
XX = ExeCountD
ExeCountD = 0
Unmissedscans = 0
MissedScans = 0

For x = 0 To Len(StrainSeq(0))
    XX = SeqNum(x, 0)
    
Next x
'NuminList = GetNumInList(21, 50, 63) '49426
'NuminList = GetNumInList(21, 63, 50) '49426
'NuminList = GetNumInList(50, 21, 63) '49426
'NuminList = GetNumInList(50, 63, 21) '49426
'NuminList = GetNumInList(63, 21, 50) '49426
'NuminList = GetNumInList(63, 50, 21) '49426
x = x
Exit Sub
'Call MakeSeqCompressor3
'Call NameShuffle
'Form2.Picture5.Visible = True
'Form2.Picture5.Width = 100 * Screen.TwipsPerPixelX
'Form2.Picture5.Height = 100 * Screen.TwipsPerPixelY
'Form2.Picture5.ZOrder
'Exit Sub'
'UB = UBound(SMat, 1)
'SS = Abs(GetTickCount)
'For X = 1 To 80
'Call RedrawPlotAA(1)
'Next X
'EE = Abs(GetTickCount)
'TT = EE - SS
''1.404
'X = X
''For X = 0 To Nextno
''    XX = StrainSeq(X)
''Next X
''Exit Sub
'Exit Sub
'''Erase Segbound()
'''Erase CompressValid11(), CompressDiffs11()
'''Erase CompressValid02(), CompressDiffs02()
'''Erase CompressValid12(), CompressDiffs12()
'''Erase CompressValid03(), CompressDiffs03()
'''Erase CompressValid13(), CompressDiffs13()
'''Erase CompressValid04(), CompressDiffs04()
'''Erase CompressValid14(), CompressDiffs14()
'''Erase SeqCompressor11(), SeqCompressor02()
'''Erase SeqCompressor03(), SeqCompressor12()
'''Erase SeqCompressor13(), SeqCompressor04()
'''Erase SeqCompressor14()
'''Erase MapBlockNum()
'''Erase Identical2()
'''Erase IdenticalR()
'''Erase IdenticalF()
'''Erase NumSeq()
''''762
'''
'''Erase ConvNumSeq()
'''Erase RedoDist(), Iseq4(), ISeq3(), StoreChanged(), BigFileOffsets(), RBPPos(), PAncPVals(), ReMapF(), ReMapR(), BPCIs(), ProgcolourB()
'''Erase RememberBPs(), CTNames(), CTBlocks(), CTText()
'''Erase CompressValid4(), CompressDiffs4(), SeqCompressor4(), CompressValid3(), CompressDiffs3()
'''redim fubvalid(0,0)()
'''Erase SeqSpacesTemp()
'''Erase SeqCoverage()
'''Erase NodeFindZ(), NodeXYZ(), NodeMaxRep()
'''Erase PADRETraceEventU(), PADRETraceU(), PADRENameU()
'''Erase BigTreeTraceEvent(), BigTreeTrace(), BigTreeName(), SNodePathX(), TreeTestStats(), MeanE(), MeanM(), LowerThanRealM(), LowerThanReal(), NOC(), OriginalName(), PDBtoAlign(), Recompress(), Decompress(), ABCons(), RefSpaces(), NumEScores(), SCHEMAMScores(), SCHEMAEScores(), RealEScores(), RealMScores(), PermContactMapT()
'''Erase MartString()
'''Erase MartVertex()
'''Erase MartEdge()
'''Erase SHAPEScores()
'''Erase MultCoords()
'X = X
'
'''Erase MultFN()
'''Erase dMax()
'''Erase HSCord()
'''Erase VScoreMat()
'''Erase NucMat()
'''Erase PrintPoints()
'''Erase VisRDOccupancyStat()
'''Erase AncPVals()
'''Erase SeqText()
'''Erase XoverSeqNumTS(), XTable(), YTable(), SqrA(), APos()
'''Erase AgeEvent(), S2TraceBack()
'''Erase GExtraText(), GBlock(), GCritval(), GVarPos(), GPrint(), GPrintCol(), GPrintPos(), VarsitesMC(), VarsitesCM(), VarsitesLD()
'''Erase CompatMatIJ()
'''X = X
'''Erase MatrixL(), MatrixMC(), MatrixC(), MatrixBP(), MatrixLD(), MatrixRMin(), MatrixRMinD(), MatrixRRP(), MatrixRR(), MatrixR(), MatrixM(), SHMatrixX(), MatrixRF(), MatrixSH()
'''Erase BestEStore(), aaConv(), AASeq()
'''Erase BPCVal(), PermsCurrentXOver(), BPListHolder()
'''Erase DScores(), FCMat(), SCMat(), testpa(), NOPINI()
'''Erase TestName()
'''
'''X = X
'''Erase BestXOListMa(), BestXOListMi(), BCurrentXoverMa(), BCurrentXoverMi()
'''Erase StepSEn(), StepSeqnum(), sPermSeqnum()
'''Erase ExtraD()
'''Erase ExtraHits()
'''Erase ExtraHitsMa()
'''Erase ExtraHitsMi()
'''Erase TreeTraceSeqs()
'''Erase PermOriginalName()
'''Erase TreeFMat()
'''Erase TreeSMat()
'''Erase TreeTrace()
'''Erase TreeStrainName()
'''Erase TreeMatrix()
'''Erase PermSeqNum(), Steps()
'''Erase PNPos(), MaxXOP(), RedoList(), DonePVCO()
'''Erase BanWin(), MDMap()
'X = X
'''Erase NumRecsI(), ColTotals(), LongSeqNum(), ValidList(), CountList()
'''Erase DistMod()
'''redim sMat(0,0)()
'''Erase FAMat()
'''redim saMat(0,0)()
'''Erase CritPVals(), BestPermP()
'''Erase SuperEvent()
'''redim SubValid(0,0)()
'''redim Subdiffs(0,0)()
'''Erase tPermDiffs()
'''X = X
'''
'''Erase tPermValid()
'''Erase EventTrace()
'''Erase SuperEventList()  ',SimSeqNum()
'''Erase txSeqNum(), EventSeq()
'''Erase ShowAllHits(), oRecombNo(), RecombNo(), PermDist(), mtP(), mtEv()
'''
'''Erase RecMap()
'''Erase BestEvent()
'''
'''Erase MaxEn()
'''Erase MinS()
'
'X = X
'''Erase AncSeqS()
'''Erase BranchMapX()
'X = X
'''Erase SelectGroups(), DSeqs()
'''Erase PPXOSeq(), PPWinScore(), PPWinScoreT()
'''Erase ShortOutput()
'''Erase AncDstMat(), AncSeq(), BranchMap(), MRCAMat(), ConDeg()
'''Erase StartPlt(), PDistPlt(), ProbPlt(), HitPlt()
'''Erase RecombMatrix()
'''Erase DstMat()
'''Erase Hitnumber()
'''Erase RevSeq(), Selected(), UYPos(), SYPos()
'''Erase GEvents()
'''Erase ProgF()
'X = X
'''Erase FFillCol(), SeqCol()
'''Erase SeqColRef(), Identical(), ColDist(), IDCount()
'''Erase SiteIdentity(), SubMaskSeq(), GCIDCount(), MCIDCount(), GCXDiffPos(), GCXPosDiff()
'''Erase GCXOverSeq()
'''Erase MCXoverSeq()
'''Erase GCIdentical(), MCIdentical()
'''Erase RefCol(), PltPos()
'''Erase PltVal(), MCPrintData(), MCPrintPos()
'''Erase ETSeqNum()
'''Erase TreeSeqMap()
'''Erase CurTree()
'''X = X
'''Erase XCord()
'''Erase YCord()
'''Erase RYCord()
'''Erase TTFlag()
'''Erase NodeYPos()
'''Erase TreeX()
'''Erase TreeY()
'''Erase NewNo()
'''Erase ColourSeq()
'''Erase TreeRX()
'''Erase TreeRY()
'X = X
'''Erase TempSeq(), NHString()
'''Erase MultColour()
'''Erase TreeRLen()
'''Erase SSSubSeq(), PltCol3(), PScores(), PltCol2(), PltCol()
'''Erase DistMatrix()
'''Erase SSScore(), HighestDSS(), SmoothDSS()
'''Erase TOSeq()
'X = X
'''Erase TotMat(), LastMatrix()
'''Erase TOTSeqNum()
'''Erase RetXPos(), RetYPos()
'''Erase RetPlot()
'''Erase ProgColour()
'''Erase LSurface()
'''Erase LXPos()
'''Erase FileList(), RecombSeq()
'X = X
'''Erase SubSetF(), SubSetR(), MCWarningFlag(), PeakNumber(), MCXDiffPos(), MCXPosDiff()
'''Erase MCFile(), PeakPair()
'''Erase SmoothChi(), SmoothChiX(), Scores(), ScoresX(), WinScoresX(), Winscores(), Chivals(), ChiValsX()
'''Erase PDBSeq(), Nucs(), RevNucs(), ContactFrame(), WinScorePDB(), WinFrame(), WinRange()
'''Erase SixFrame(), LongInteract(), InterProtMap()
'X = X
'''Erase ProtInfo(), ContactMapT(), ContactMapB(), PermPDBSeq(), PermSeq2Align(), PermSeq1Align(), Seq1Align()
'''Erase CXoverSeq()
'''Erase xLenXoverSeq()
'''Erase XOverSeqNumW(), XoverSeqNum(), SpacerSeqs(), XPosDiff(), XDiffPos(), ValidSpacer()
'''Erase XOverSeq()
'''Erase XOverHomologyNum()
'''Erase PValCat()
'''Erase MaxPValCat()
'''Erase CurrentXOver()
'''Erase Maskseq()
'''Erase SeqSpaces()
'''Erase LenNoGaps()
'''Erase RFlag()
'''Erase FoundMethods()
'X = X
'''Erase GoOnA(), GoOnB(), BSFilePos()
'''Erase PVals(), FragMaxScore(), MaxScorePos()
'''Erase SubSeq()
'''Erase GCSeq()
'''Erase StraiName()
'''Erase GCEnabledNo()
'''Erase FragSt(), FragEn(), FragScore()
'''Erase GCSeqRange(), xGCSeqRange()
'''Erase ORFWin()
'''Erase BkgIdentity()
'''Erase NodeLength()
'''Erase SDLen()
'X = X
'''Erase SNodeXPos()
'''Erase SNodeYPos()
'''Erase uSeqNum()
'''Erase uMissingData()
'''Erase uTreeTrace()
'''Erase uTreeDistance()
'''Erase uSeqCol()
'''Erase uFFillCol()
'''Erase uDistance()
'''Erase uOriginalName()
'''Erase GrpMaskSeq()
'''Erase PValMap()
'''Erase Fact(), BinTable()
'''Erase DoneTree()
'X = X
'''Erase TreeXScaleMod()
'''Erase TreeBlocksL()
'''Erase TBLen()
'''Erase RepeatCycles()
'''Erase FlashArray()
'''Erase BusyFlashing()
'''Erase TripListLenSeq(), ISeq4P(), AnalysisList(), TripList(), SBlockBak(), FlashColour()
'''Erase btMissingData()
'''Erase AnalT()
'''Erase pMaskSeq()
'''Erase ValidSite()
'
''760
'Erase Daught() '2 'Change from long to byte
'                'MAKEBACKUPS
'                'replacewithbackups
'                'buildfirstxolist
'                'cleanxolist
'                'swapinvolved
''751
'Erase MinorPar() '2 'Change from long to byte
''742
'Erase MajorPar() '2 'Change from long to byte
''734
'
''773
'Erase MapBlocks() '9 Stores positions and colours of sequence blocks on trees - is dimensioned (4,4,4 permnextno*some number(because of bigtrees)) but could just be 4, permnextno
''764
'
''764
'Erase NodeXY() '1
''763
'
''763
'Erase SeqLines() '1
''762
'
''762
'Erase uDaught() '2 'Could be redeclared as a byte - and could be written to disk - only really used in modeseqnum
''754
'
''754
'Erase SchemBlocks() '1
''753
'Erase SchemString() '1
''752
'
''752
'Erase TreeBlocks() '2
''750
'Erase treedrawb() '12
''738
'
''738
'Erase TreeSeqNum() '45 'could be  changed frm int to byte
'                        'used in dll makeetseqnumx
'                        'sub makeetseqnum
'                        'used indirectly for making sequences used to make all trees using shelled programs
'                        'could save to disk
''693
'
''693
'Erase MissingData() '51
''642
'
''642
'Erase FMat() '42 'No longer persistant
'
''584
'
''584
'Erase PermDiffs() '47
''527
'
''527
'Erase PermValid() '58
''469
'
''469
'Erase Confirm() '1
''468
'Erase ConfirmP() '4
''464
'Erase ConfirmMi() '2 'keep these stored on disk
''462
'Erase ConfirmPMi() '4 'keep these stored on disk
''458
'Erase ConfirmMa() '1 'keep these stored on disk
''457
'Erase ConfirmPMa() '4 'keep stored on disk
''453
'
''453
'redim permarray(0,0)() '11 'dump to disk if necessary to make some space
''442
'
''442
'Erase Output() '1
''441
'
''439
'Erase TreeDistance() '57 'Could this share a matrix with Distance?
''382
'
''382
'Erase SSeqXPos() '1
''381
'Erase SSeqYPos() '1
''380
'
''380
'Erase SNodepath() '1
''379
'
''351
'Erase SeqNum() '73  'Why didn't I make this a byte array to begin with?
''278
'
''264
'Erase Distance() '57' could this share with treedistance
''207
'
'
'
''210
'Erase StrainSeq() '98 'why is this so much bigger than seqnum?
'                    ' it should be ~38Megs (i.e. half the size of seqnum)
''112
'
'
''112
'
'
''87
'
'
'
'
'X = X
''SBlockBak
''permarray ~11Megs
''seqprob2 ~60 megs
'Exit Sub
''54384 base
''147420 (strainseq 105120 expected 93036 observed)
''147412 - checkpoint 1
''156755 - checkpoint 2 (after declaration of all standard arrays and variables)
''158040 - checkpoint 3 after dointerface and docols
''158980 - chcekpoint 4 just befor seqnum/seqspaces declare
''260212 - checkpoint 5 after seqnum and seqspaces calcs- 101232 observed, 103457 expected
''260444 - checkpoint 6 after seqcols
''433796 - checkpoint 7 after calcidentity - observed 173352 expected 173076 for distance, pervalid and permdiffs
''444180 - checkpoint 8 hscroll1change
''444180-checkpoint 9 - just before domensioning of tree arrays
''447052 - checkpoint 10 after demensioning of tree drawing arrays
''447096 - checkpoint 11 before UPGMA
''563648 - checkpoint 12 after upgma ~80 megs unaccounted for memory******************************************
''569628 - checkpoint 13 after drawtree
''569592 - checkpoint 14 before setupscanarrays
''569596 - checkpoint 15
''622572 - checkpoint 16 - after dimming missingdata and some others
''865112 - checkpoint 17 - after loading recombination data and displaying it - sort out minp
'
''865140 -
'ReDim Distance(0, 0) '806960
''807368
'ReDim TreeDistance(0, 0)
''749652
'ReDim PermValid(0, 0)
''691912
'ReDim PermDiffs(0, 0)
''634220
'ReDim SeqNum(0, 0)
''532960
'ReDim MissingData(0, 0)
''482336
'Erase StrainSeq
''377216
'Erase XOverlist
''373304
''Erase MinP '****************************************************************
''316137
'Erase TreeX '****************************************
''287304
'Erase Daught
''279252
'Erase MajorPar
''271244
'Erase MinorPar
''263212
'Erase ETSeqNum '888888888888888
'Erase NumSeq '888888888888
'redim permarray(0,0)
'Erase XOverlist
'X = X
'Picture6.Picture = LoadPicture()
'Picture6.Width = 0
'Picture6.Height = 0
''Picture1.Height = 0
''Picture1.Width = 0
''Picture1.Picture = LoadPicture()
'Form5.Picture1.Height = 0
'Form5.Picture2.Height = 0
'Exit Sub
'
'Call UpdateIDScores
'Exit Sub
'Call MakeTB
'Exit Sub
'Dim tRedo() As Integer, tPV() As Single, tPD() As Single, TD() As Single
'
'ReDim tPD(Nextno, Nextno), tPV(Nextno, Nextno), TD(Nextno, Nextno)
'
'Dim AVD As Double, UDS As Double, tRedo() As Integer
'ReDim tRedo(Nextno)
'For X = 0 To Nextno
'    tRedo(X) = 1
'Next X
'Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), Nextno, tPD(), tPV(), SeqNum(), TD(), AVD, UDS, tRedo())
'
'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        If Distance(X, Y) <> TD(X, Y) Then
'            X = X
'        End If
'        If PermValid(X, Y) <> tPV(X, Y) Then
'            X = X
'        End If
'        If PermDiffs(X, Y) <> tPD(X, Y) Then
'            X = X
'        End If
'    Next Y
'Next X
'
'Exit Sub

End Sub

Private Sub Command17_Click()

Command3.SetFocus

If Form2.Visible = True Then
    Form2.ZOrder
    Form2.WindowState = 0
    Call ResizeForm2
    Exit Sub
End If

If RelX > 0 Or RelY > 0 Then
    OI = F2TreeIndex
    If LongWindedFlag = 1 Then
        F2TreeIndex = 1
        Call ModSeqNum(0, 0, 0)
        Call ModNextno
    End If
    
    Call MultTreeWin
    Call ResizeForm2
    Form1.ProgressBar1 = 0
    Form2.ProgressBar1 = 0
    Call UpdateF2Prog
    If LongWindedFlag = 1 Then
        Call UnModNextno
        Call UnModSeqNum(0)
        
    End If
    F2TreeIndex = OI
    Form2.ZOrder
    Form2.WindowState = 0
End If

End Sub

Private Sub Command18_Click()
If SEventNumber = 0 Then
    Call SaveEAlignMnu_Click
Else
    
    Dim MissF As String
    Dim OneBP As String
    Dim WrongBP As String
    Dim MiParent As String
    Dim MaParent As String
    Dim Daughter As String
    Dim BS As String
    Dim ES As String
    Dim BA As String
    Dim EA As String
    Dim PVal As String
    Dim MCPVal As String
    Dim PermPVal As String
    Dim BPval As String
    Dim EPval As String
    Dim EPPVal As String
    Dim BPPVal As String
    Dim Prog As String
    XX = Len(StrainSeq(0))
    Command3.SetFocus
    If CurrentlyRunningFlag = 1 Then Exit Sub
    
    If CLine = "" Or ShortOutFlag = 3 Or ShortOutFlag = 4 Then
        'Command3.SetFocus
        'Dim SFName As String

        Dim SFnameII As String
        If ShortOutFlag = 3 Or ShortOutFlag = 4 Then
            sFName$ = Left(InFileX, Len(InFileX) - 3) + "rdp5"
        Else
            With Form1.CommonDialog1
                .FileName = ""
                '.InitDir = currentdir
                .FLAGS = cdlOFNOverwritePrompt
                '.Filter = "All Files (*.*)|*.*|RDP Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq|Extended multiple FASTA file (*.xmfa)|*.seq|FASTA Multiple Alignment Format (*.fas)"
                If Rffflag = 1 Then
                    .DefaultExt = ".csv"   'Specify the default extension.
                        'Specify which file extensions will be preferred.
                        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
                        .Filter = "Recombination Data in Excel readable text file format (*.csv)|*.csv|All Files (*.*)|*.*|"
                
                ElseIf Rffflag = 2 Then
                        .DefaultExt = ".rdp5"   'Specify the default extension.
                        'Specify which file extensions will be preferred.
                        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
                        .Filter = "RDP5 Project File (*.rdp5)|*.rdp5|RDP Project File (*.rdp)|*.rdp|Recombination Data in Text File (*.csv)|*.csv"
                Else
                    .DefaultExt = ".rdp5"   'Specify the default extension.
                        'Specify which file extensions will be preferred.
                        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
                        .Filter = "RDP5 Project File (*.rdp5)|*.rdp5|RDP Project File (*.rdp)|*.rdp|Recombination Data in Text File (*.csv)|*.csv"
                
                End If
                '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
                .FilterIndex = 1 ' specify that rdp project file is the preffered save
                .Action = 2 'Specify that the "open file" action is required.
                sFName$ = .FileName  'Stores selected file name in the
                'string, fname$.
                SFnameII = .FileTitle
            End With
        End If
        If sFName$ = "" Then Exit Sub
        Screen.MousePointer = 11
        If Right$(sFName$, 5) = ".rdp5" Or Right$(sFName$, 4) = ".RDP5" Then
            Call WriteRDP5File(sFName$)
        ElseIf Right$(sFName$, 4) = ".rdp" Or Right$(sFName$, 4) = ".RDP" Then
            If DebuggingFlag < 2 Then On Error Resume Next

            If DoScans(0, 1) = 1 Or (DoScans(0, 3) = 1 And MCTripletFlag = 1) Then
                
                KillFile Left$(SFnameII, Len(SFnameII) - 4) + ".gc"
                If GCOFile <> "" Then
                    FileCopy GCOFile, Left$(SFnameII, Len(SFnameII) - 4) + ".gc"
                End If
                Const STILL_ACTIVE = &H103

                If GCMCCheckFlag = 1 And mcProcess <> 0 Then
                    Form1.SSPanel1.Caption = "Completing GENECONV MaxChi check"

                    Do
                        GetExitCodeProcess mcProcess, retVal
                        Sleep (100)
                    Loop While retVal = STILL_ACTIVE

                    Form1.SSPanel1.Caption = ""
                    Dummy = CloseHandle(mcProcess)
                    mcProcess = 0
                    ' Kill App.Path & "\maxchiout"
                    Name App.Path & "\rdpfile.txt" As App.Path & "\maxchiout" + UFTag
                    MCFullFile = App.Path & "\maxchiout" + UFTag
                    GCMCCheckFlag = 0
                End If

                KillFile Left$(SFnameII, Len(SFnameII) - 4) + ".mc"
                If Dir("maxchiout") <> "" Then
                    FileCopy App.Path & "\maxchiout" + UFTag, Left$(SFnameII, Len(SFnameII) - 4) + ".mc"
                End If
            End If

      
            On Error GoTo 0
            Close #1
            
            Call WriteRDPFile(sFName)
            
            FName$ = sFName$
            PFName = sFName$
            If PFName <> "LastSave.rdp5" And PFName <> "" Then
                Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor)) + ":  " + PFName
            Else
            
                Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor))
            End If
            
            
            If DatasetName <> "" Then
                Form1.Caption = Form1.Caption + DatasetName
            End If
            
        ElseIf Right$(sFName$, 4) = ".csv" Or Right$(sFName$, 4) = ".CSV" Then
            'Print #1, SeqFile
            
            
            SomeAcceptFlag = 0
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    If XoverList(x, Y).Accept = 1 Then
                        SomeAcceptFlag = 1
                        Exit For
                    End If
                Next Y
                If SomeAcceptFlag = 1 Then Exit For
            Next x
            If SomeAcceptFlag = 1 Then
                
                Response = MsgBox("Would you like to save only 'accepted' recombination events. Pressing the 'No' button will save all recombination events", 36)
            Else
                Response = 7
            End If
            Form1.SSPanel1.Caption = "Saving Recombination Data"
            Form1.SSPanel1.Refresh
            
            If x = x Then
                Call MakeCSV(sFName$, Response)
            Else
                Open sFName$ For Output As #1
                ' Exit Sub
                Print #1, "Recombination Data for:", FName$
    
                If Response = 6 Then
                    Print #1, "Identified by:, Recombinant ,Major parent, Minor parent,Beginning in alignment,Ending in alignment,Beginning in sequence,Ending in sequence,Uncorrected P-Val,MC corrected P-Val, Permutation P-Val,Beginning breakpoint P-val, Ending breakpoint P-val, Beginning breakpoint permutation P-val, Ending breakpoint permutation P-val, Incorrect recombinant?, Only one breakpoint?, Incorrect breakpoint?"
                Else
                    Print #1, "Identified by:, Recombinant ,Major parent, Minor parent,Beginning in alignment,Ending in alignment,Beginning in sequence,Ending in sequence,Uncorrected P-Val,MC corrected P-Val, Permutation P-Val,Beginning breakpoint P-val, Ending breakpoint P-val, Beginning breakpoint permutation P-val, Ending breakpoint permutation P-val, Incorrect recombinant?, Only one breakpoint?, Incorrect breakpoint?,Accepted?"
                End If
    
                Dim AcceptVal As String
    
                PCount = 0
                
                For x = 0 To PermNextno
    
                    For Y = 0 To CurrentXOver(x)
                        
                        If Response <> 6 Or XoverList(x, Y).Accept = 1 Then
                            
                            If XoverList(x, Y).Accept = 1 Then
                                AcceptVal = "Accepted"
                            ElseIf XoverList(x, Y).Accept = 2 Then
                                AcceptVal = "Rejected"
                            Else
                                AcceptVal = "Undecided"
                            End If
    
                            If XoverList(x, Y).ProgramFlag = 0 Or XoverList(x, Y).ProgramFlag = 0 + AddNum Then
                                Prog = "RDP"
                            ElseIf XoverList(x, Y).ProgramFlag = 1 Or XoverList(x, Y).ProgramFlag = 1 + AddNum Then
                                Prog = "GENECONV"
                            ElseIf XoverList(x, Y).ProgramFlag = 2 Or XoverList(x, Y).ProgramFlag = 2 + AddNum Then
                                Prog = "Bootscan"
                            ElseIf XoverList(x, Y).ProgramFlag = 3 Or XoverList(x, Y).ProgramFlag = 3 + AddNum Then
                                Prog = "Maxchi"
                            End If
    
                            Daughter = OriginalName(XoverList(x, Y).Daughter)
    
                            If XoverList(x, Y).OutsideFlag = 0 Then
                                MaParent = OriginalName(XoverList(x, Y).MajorP)
                                MiParent = OriginalName(XoverList(x, Y).MinorP)
                            ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                                MaParent = "Unknown (" & OriginalName(XoverList(x, Y).MajorP) & ")"
                                MiParent = OriginalName(XoverList(x, Y).MinorP)
                            ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                                MaParent = OriginalName(XoverList(x, Y).MajorP)
                                MiParent = "Unknown (" & OriginalName(XoverList(x, Y).MinorP) & ")"
                            End If
    
                            If XoverList(x, Y).ProgramFlag = 1 Or XoverList(x, Y).ProgramFlag = 1 + AddNum Or ((XoverList(x, Y).ProgramFlag = 3 Or XoverList(x, Y).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1) Then MaParent = "Undetermined"
                            If SeqSpacesInFileFlag = 1 Then
                                oDirX = CurDir
                                ChDrive App.Path
                                ChDir App.Path
                                FF = FreeFile
                               
                                OS1 = x * (Len(StrainSeq(0)) + 3)
                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                Get #FF, (((XoverList(x, Y).Beginning + OS1) - 1) * 4) + 1, SSB
                                Get #FF, (((XoverList(x, Y).Ending + OS1) - 1) * 4) + 1, SSE
                                Get #FF, (((XoverList(x, Y).Beginning + 10 + OS1) - 1) * 4) + 1, SSC
                                Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, ssd
                                Close #FF
                                ChDrive oDirX
                                ChDir oDirX
                            Else
                                SSB = SeqSpaces(XoverList(x, Y).Beginning, x)
                                SSE = SeqSpaces(XoverList(x, Y).Ending, x)
                                'SSE = SeqSpaces(osbc, CSeq)
                                SSC = SeqSpaces(XoverList(x, Y).Beginning + 10, x)
                                ssd = SeqSpaces(Len(StrainSeq(0)) + 10, x)
                            End If
                            If XoverList(x, Y).SBPFlag = 0 Or (XoverList(x, Y).ProgramFlag <> 3 And XoverList(x, Y).ProgramFlag <> 3 + AddNum) Then
                                BS = XoverList(x, Y).Beginning - SSB
                                ES = XoverList(x, Y).Ending - SSE
                                BA = XoverList(x, Y).Beginning
                                EA = XoverList(x, Y).Ending
                            ElseIf XoverList(x, Y).SBPFlag = 1 Then
                                BS = "Undetermined"
                                ES = XoverList(x, Y).Ending - SSB
                                BA = "Undetermined"
                                EA = XoverList(x, Y).Ending
                            ElseIf XoverList(x, Y).SBPFlag = 2 Then
                                BS = XoverList(x, Y).Beginning - SSE
                                ES = "Undetermined"
                                BA = XoverList(x, Y).Beginning
                                EA = "Undetermined"
                            ElseIf XoverList(x, Y).SBPFlag = 3 Then
    
                                If XoverList(x, Y).Beginning + 10 < Len(StrainSeq(0)) Then
                                    BS = "Undetermined (" & XoverList(x, Y).Beginning + 10 - SSC & ")"
                                    'Close #1
                                    'Exit Sub
                                    ES = "Undetermined"
                                    BA = "Undetermined (" & XoverList(x, Y).Beginning + 10 & ")"
                                    EA = "Undetermined"
                                Else
                                    BS = "Undetermined (" & Len(StrainSeq(0)) - ssd & ")"
                                    ES = "Undetermined"
                                    BA = "Undetermined (" & Len(StrainSeq(0)) & ")"
                                    EA = "Undetermined"
                                End If
    
                            End If
    
                            If XoverList(x, Y).ProgramFlag = 0 Or XoverList(x, Y).ProgramFlag = 0 + AddNum Then
    
                                If MCFlag = 0 And MCCorrection > 0 Then
                                    MCPVal = XoverList(x, Y).Probability
                                    PVal = XoverList(x, Y).Probability / MCCorrection
                                ElseIf MCFlag = 1 Then
                                    MCPVal = XoverList(x, Y).Probability * MCCorrection
                                    PVal = XoverList(x, Y).Probability
                                ElseIf MCFlag = 2 Then
                                    MCPVal = XoverList(x, Y).Probability
                                    PVal = StepUp(x, Y)
                                End If
    
                                PermPVal = "--"
                                BPval = "--"
                                EPval = "--"
                                BPPVal = "--"
                                EPPVal = "--"
                            ElseIf XoverList(x, Y).ProgramFlag = 1 Or XoverList(x, Y).ProgramFlag = 1 + AddNum Then
                                MCPVal = XoverList(x, Y).Probability
                                PVal = XoverList(x, Y).Probability / GCMCCorrection
    
                                If GCNumPerms > 0 Then
    
                                    If XoverList(x, Y).PermPVal > 0 Then
                                        PermPVal = XoverList(x, Y).PermPVal
                                    Else
                                        PermPVal = "< 0" & Trim$(CStr(1 / GCNumPerms))
                                    End If
    
                                Else
                                    PermPVal = "--"
                                End If
    
                                BPval = "--"
                                EPval = "--"
                                BPPVal = "--"
                                EPPVal = "--"
                            ElseIf XoverList(x, Y).ProgramFlag = 2 Or XoverList(x, Y).ProgramFlag = 2 + AddNum Then
                                MCPVal = XoverList(x, Y).Probability * MCCorrection
                                PVal = XoverList(x, Y).Probability
                                PermPVal = "--"
                                BPval = "--"
                                EPval = "--"
                                BPPVal = "--"
                                EPPVal = "--"
                            ElseIf XoverList(x, Y).ProgramFlag = 3 Or XoverList(x, Y).ProgramFlag = 3 + AddNum Then
    
                                If XoverList(x, Y).SBPFlag = 0 Then
                                    MCPVal = "--"
                                    PVal = "--"
                                    PermPVal = "--"
                                    BPval = 0 'XoverList(x, Y).BeginP
                                    EPval = 0 'XoverList(x, Y).EndP
    
                                    BPPVal = "--"
                                    EPPVal = "--"
                                    
    
                                ElseIf XoverList(x, Y).SBPFlag = 1 Then
                                    MCPVal = "--"
                                    PVal = "--"
                                    PermPVal = "--"
                                    BPval = "--"
                                    EPval = XoverList(x, Y).EndP
    
                                    BPPVal = "--"
                                    EPPVal = "--"
                                   
    
                                ElseIf XoverList(x, Y).SBPFlag = 2 Then
                                    MCPVal = "--"
                                    PVal = "--"
                                    PermPVal = "--"
                                    BPval = 0 'XoverList(x, Y).BeginP
                                    EPval = "--"
    
                                    BPPVal = "--"
                                    EPPVal = "--"
                                    
    
                                ElseIf XoverList(x, Y).SBPFlag = 3 Then
                                    MCPVal = "--"
                                    PVal = "--"
                                    PermPVal = "--"
                                    BPval = 0 'XoverList(x, Y).BeginP
                                    EPval = "--"
    
                                    BPPVal = "--"
                                    EPPVal = "--"
                                    
    
                                End If
    
                            End If
    
                            If XoverList(x, Y).MissIdentifyFlag > 0 Then
                                MissF = "+"
                            Else
                                MissF = "-"
                            End If
    
                            If XoverList(x, Y).SBPFlag = 3 And XoverList(x, Y).ProgramFlag = 3 Or XoverList(x, Y).ProgramFlag = 3 Then
                                OneBP = "+"
                                WrongBP = "-"
                            Else
                                OneBP = "-"
    
                                If XoverList(x, Y).SBPFlag > 0 Then
                                    WrongBP = "+"
                                Else
                                    WrongBP = "-"
                                End If
    
                            End If
    
                            PCount = PCount + 1
    
                            If MiParent <> MaParent And MiParent <> Daughter And Daughter <> MaParent Then
    
                                If Response = 6 Then
                                    Print #1, Prog, ",", Daughter, ",", MaParent, ",", MiParent, ",", BA, ",", EA, ",", BS, ",", ES, ",", PVal, ",", MCPVal, ",", PermPVal, ",", BPval, ",", EPval, ",", BPPVal, ",", EPPVal, ",", MissF, ",", OneBP, ",", WrongBP
                                Else
                                    Print #1, Prog, ",", Daughter, ",", MaParent, ",", MiParent, ",", BA, ",", EA, ",", BS, ",", ES, ",", PVal, ",", MCPVal, ",", PermPVal, ",", BPval, ",", EPval, ",", BPPVal, ",", EPPVal, ",", MissF, ",", OneBP, ",", WrongBP, ",", AcceptVal
                                End If
    
                            End If
    
                            If (PCount / oRecombNo(100)) <= 1 Then
                                Form1.ProgressBar1 = (PCount / oRecombNo(100)) * 100
                                Call UpdateF2Prog
                            End If
    
                        End If
    
                    Next 'Y
    
                Next 'X
            End If
            Form1.ProgressBar1 = 100
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Form1.ProgressBar1 = 0
        End If
        
        Screen.MousePointer = 0
    Else
        Open OutFileX For Append As #1
        
        If ShortOutFlag = 0 Then
            
            Print #1, "Start"
            Print #1, "Recombination Data for:", InFileX
            Print #1, "Possible recombination events:", oRecombNo(100)
            Print #1, ",", "IncorrectRecombinant?", ",", "RecombinantSequence", ",", "MajorParent", ",", "MinorParent", ",", "BeginningInAlignment", ",", "EndingInAlignment", ",", "BeginningInSequence", ",", "EndingInSequence", ",", "UncorrectedProbability", ",", "MCCorrectedProbability"

            If MCFlag = 0 Then

                For x = 0 To PermNextno

                    For Y = 0 To CurrentXOver(x)

                        If XoverList(x, Y).Probability > 0 Then
                            
                            If SeqSpacesInFileFlag = 1 Then
                                oDirX = CurDir
                                ChDrive App.Path
                                ChDir App.Path
                                FF = FreeFile
                               
                                OS1 = x * (Len(StrainSeq(0)) + 3)
                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                Get #FF, (((XoverList(x, Y).Beginning + OS1) - 1) * 4) + 1, SSB
                                Get #FF, (((XoverList(x, Y).Ending + OS1) - 1) * 4) + 1, SSE
                                Close #FF
                                ChDrive oDirX
                                ChDir oDirX
                            Else
                                SSB = SeqSpaces(XoverList(x, Y).Beginning, x)
                                SSE = SeqSpaces(XoverList(x, Y).Ending, x)
                                'SSE = SeqSpaces(osbc, CSeq)
                            End If
                            If XoverList(x, Y).OutsideFlag = 0 Then

                                If XoverList(x, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If
                                
                                Print #1, ",", MissF, ",", OriginalName(XoverList(x, Y).Daughter), ",", OriginalName(XoverList(x, Y).MajorP), ",", OriginalName(XoverList(x, Y).MinorP), ",", XoverList(x, Y).Beginning, ",", XoverList(x, Y).Ending, ",", XoverList(x, Y).Beginning - SSB, ",", XoverList(x, Y).Ending - SSE, ",", XoverList(x, Y).Probability / MCCorrection, ",", XoverList(x, Y).Probability
                            ElseIf XoverList(x, Y).OutsideFlag = 1 Then

                                If XoverList(x, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, ",", MissF, ",", OriginalName(XoverList(x, Y).Daughter), ",", "Unknown (" + OriginalName(XoverList(x, Y).MajorP) + ")", ",", OriginalName(XoverList(x, Y).MinorP), ",", XoverList(x, Y).Beginning, ",", XoverList(x, Y).Ending, ",", XoverList(x, Y).Beginning - SSB, ",", XoverList(x, Y).Ending - SSE, ",", XoverList(x, Y).Probability / MCCorrection, ",", XoverList(x, Y).Probability
                            ElseIf XoverList(x, Y).OutsideFlag = 2 Then

                                If XoverList(x, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, ",", MissF, ",", OriginalName(XoverList(x, Y).Daughter), ",", OriginalName(XoverList(x, Y).MajorP), ",", "Unknown (" + OriginalName(XoverList(x, Y).MinorP) + ")", ",", XoverList(x, Y).Beginning, ",", XoverList(x, Y).Ending, ",", XoverList(x, Y).Beginning - SSB, ",", XoverList(x, Y).Ending - SSE, ",", XoverList(x, Y).Probability / MCCorrection, ",", XoverList(x, Y).Probability
                            End If

                        Else
                            'Exit For
                        End If

                    Next 'Y

                Next 'X

            ElseIf MCFlag = 1 Then

                For x = 0 To PermNextno

                    For Y = 0 To CurrentXOver(x)
                       
                        If SeqSpacesInFileFlag = 1 Then
                            oDirX = CurDir
                            ChDrive App.Path
                            ChDir App.Path
                            FF = FreeFile
                           
                            OS1 = x * (Len(StrainSeq(0)) + 3)
                            Open "RDP5SSFile" + UFTag For Binary As #FF
                            Get #FF, (((XoverList(x, Y).Beginning + OS1) - 1) * 4) + 1, SSB
                            Get #FF, (((XoverList(x, Y).Ending + OS1) - 1) * 4) + 1, SSE
                            Close #FF
                            ChDrive oDirX
                            ChDir oDirX
                        Else
                            SSB = SeqSpaces(XoverList(x, Y).Beginning, x)
                            SSE = SeqSpaces(XoverList(x, Y).Ending, x)
                            'SSE = SeqSpaces(osbc, CSeq)
                        End If
                        Print #1, OriginalName(XoverList(x, Y).Daughter), OriginalName(XoverList(x, Y).MajorP), OriginalName(XoverList(x, Y).MinorP), XoverList(x, Y).Beginning, XoverList(x, Y).Ending, XoverList(x, Y).Beginning - SSB, XoverList(x, Y).Ending - SSE, XoverList(x, Y).Probability, XoverList(x, Y).Probability * MCCorrection
                    Next 'Y

                Next 'X
            ElseIf MCFlag = 2 Then

            End If
            If SeqSpacesInFileFlag = 1 Then
                Erase SeqSpaces
            End If
            Print #1, "Finish"
        ElseIf ShortOutFlag = 1 Then
            OutString = ""
            
            For x = 0 To 5
            
                OutString = OutString + Trim(Str(ShortOutput(x)))
            Next x
            Print #1, OutString
            'For X = 0 To permnextno'
'
'                If RFlag(X) > 0 Then
'                    Print #1, "1"
'                Else
'                    Print #1, "0"
'                End If'
'
'            Next 'X

        ElseIf ShortOutFlag = 2 Then

            For x = 0 To PermNextno
                Print #1, RFlag(x)
            Next 'X

        End If

        Close #1
        Screen.MousePointer = 0
    End If
End If
End Sub

Private Sub Command18_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
 Rffflag = 0
 Call Command18_Click
End Sub

Private Sub Command18_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Picture3.Refresh
    Picture2.Refresh
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
End Sub









Private Sub Command2_Click(Index As Integer)
    Dim x As Long
    TotMCCycles = 0
    If Index = 0 Then
        Command3.SetFocus
        If CurrentlyRunningFlag = 1 Then Exit Sub
        Form1.ScaleMode = 1
        PopupMenu FileMnu, 0, Command1.Left + SSPanel2.Left, Command1.Height + Command1.Top
    ElseIf Index = 1 Then
        
        Command3.SetFocus
        If CurrentlyRunningFlag = 1 Then Exit Sub
        Form1.ScaleMode = 1
        If SEventNumber > 0 Then
            SeqMnuFlag = 1
            FindSeqmnu4.Caption = "Save recombination results to a .rdp5 project file"
            PlaceABBPMnu.Caption = "Save recombination results to an excel readable .csv file"
            FindSeqmnu4.Enabled = True
            PlaceABBPMnu.Enabled = True
            PlaceAEBPMnu.Visible = False
        Else
            FindSeqmnu4.Visible = False
            PlaceABBPMnu.Visible = False
            PlaceAEBPMnu.Visible = False
            
            
        End If
        
        If RunFlag = 1 Then
            SaveARRRMnu.Enabled = True
            SaveARSRMnu.Enabled = True
            'SaveARCRMnu.Enabled = True
            If NextnoBak <= NextNo Then
                SaveARRSMnu.Enabled = True
                SplitAliMnu.Enabled = True
                VertAlignSplitMnu.Enabled = True
            Else
                SaveARRSMnu.Enabled = False
                SplitAliMnu.Enabled = False
                VertAlignSplitMnu.Enabled = False
            End If
        Else
            SaveARRRMnu.Enabled = False
            SaveARSRMnu.Enabled = False
            'SaveARCRMnu.Enabled = False
            SplitAliMnu.Enabled = False
            VertAlignSplitMnu.Enabled = False
            SaveARRSMnu.Enabled = False
        End If
        
        For x = 0 To NextNo
        
            If MaskSeq(x) > 0 Then Exit For
            
        Next x
        
        If x <= NextNo Then
            SaveDisMnu.Enabled = True
            SaveEnMnu.Enabled = True
        Else
        
            SaveDisMnu.Enabled = False
            SaveEnMnu.Enabled = False
        End If
        
        PopupMenu SeqMnu, 0, Command18.Left + SSPanel2.Left, Command1.Height + Command1.Top
    ElseIf Index = 2 Then
        Command3.SetFocus
    
        If CurrentlyRunningFlag = 1 Then Exit Sub
        Form1.ScaleMode = 1
        
        If SEventNumber > 0 Then
            XOverGoToEventMnu.Enabled = True
        Else
            XOverGoToEventMnu.Enabled = False
        End If
        
        PopupMenu XOverMnu, 0, Command22.Left + SSPanel2.Left, Command1.Height + Command1.Top
    
    ElseIf Index = 3 Then
            Command3.SetFocus
            If CurrentlyRunningFlag = 1 Then Exit Sub
            Form1.ScaleMode = 1
            PopupMenu Tree2Mnu, 0, Command7.Left + SSPanel2.Left, Command1.Height + Command1.Top
    ElseIf Index = 4 Then
        Command3.SetFocus
        If CurrentlyRunningFlag = 1 Then Exit Sub
        If NextNo >= 3 Then
            CMMnu(0).Enabled = True
            CMMnu(1).Enabled = True
            SHMatrixMnu.Enabled = True
        Else
            CMMnu(0).Enabled = False
            CMMnu(1).Enabled = False
            SHMatrixMnu.Enabled = False
            
        End If
        If SEventNumber > 0 Then
                RecRCMnu.Enabled = True
                RecBPMnu.Enabled = True
                RecMatMnu.Enabled = True
                ModMatMnu.Enabled = True
                If RelX > 0 Or RelY > 0 Then
                    MCMatMnu.Enabled = True
                    LMatMnu.Enabled = True
                Else
                    MCMatMnu.Enabled = False
                    LMatMnu.Enabled = False
                End If
            Else
                RecRCMnu.Enabled = False
                RecBPMnu.Enabled = False
                RecMatMnu.Enabled = False
                ModMatMnu.Enabled = False
                MCMatMnu.Enabled = False
                LMatMnu.Enabled = False
            End If
        Form1.ScaleMode = 1
        MatrixOptMnu.Visible = True
        MatrixOptMnu.Enabled = True
        PopupMenu CHMatMnu, 0, Command38.Left + SSPanel2.Left, Command1.Height + Command1.Top 'Mat2Mnu, 0, Command38.left + SSPanel2.left, Command1.Height + Command1.Top
    End If
End Sub







Private Sub Command2_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command22_Click()
If StillLoadingFlag = 1 Then Exit Sub
If JumpInFlag = 1 Then GoTo Jumpin
If DatasetNumber > 0 Then
    Call DataFeed
    Exit Sub
Jumpin:
End If
'DontWorryAboutSplitsFlag = 1
MissSecondGDP = 0: MissFirstGDP = 0: HitSecondGDP1 = 0: HitFirstGDP1 = 0: HitSecondGDP2 = 0: HitFirstGDP2 = 0
 MissSecondRDP = 0: MissFirstRDP = 0: HitSecondRDP1 = 0: HitFirstRDP1 = 0: HitSecondRDP2 = 0: HitFirstRDP2 = 0
 MissSecondRGDP = 0: MissFirstRGDP = 0: HitSecondRGDP11 = 0: HitFirstRGDP11 = 0: HitSecondRGDP12 = 0: HitFirstRGDP12 = 0: HitSecondRGDP21 = 0: HitFirstRGDP21 = 0: HitSecondRGDP22 = 0: HitFirstRGDP22 = 0
 MissSecondFDP = 0: MissFirstSDP = 0: HitSecondFDP1 = 0: HitFirstSDP1 = 0: HitSecondFDP2 = 0: HitFirstSDP2 = 0
 FPMissSecondGDP = 0: FPMissFirstGDP = 0: FPHitSecondGDP1 = 0: FPHitFirstGDP1 = 0: FPHitSecondGDP2 = 0: FPHitFirstGDP2 = 0
 FPMissSecondRDP = 0: FPMissFirstRDP = 0: FPHitSecondRDP1 = 0: FPHitFirstRDP1 = 0: FPHitSecondRDP2 = 0: FPHitFirstRDP2 = 0
 FPMissSecondRGDP = 0: FPMissFirstRGDP = 0: FPHitSecondRGDP11 = 0: FPHitFirstRGDP11 = 0: FPHitSecondRGDP12 = 0: FPHitFirstRGDP12 = 0: FPHitSecondRGDP21 = 0: FPHitFirstRGDP21 = 0: FPHitSecondRGDP22 = 0: FPHitFirstRGDP22 = 0
 FPMissSecondFDP = 0: FPMissFirstSDP = 0: FPHitSecondFDP1 = 0: FPHitFirstSDP1 = 0: FPHitSecondFDP2 = 0: FPHitFirstSDP2 = 0




Dim oDirX As String, YScaleFactor As Single, A As Long, g As Long, C As Long, T As Long, Y As Long, Response As Integer, x As Double, oRec As Long, LT As Long, oNumberOfSeqs As Long, StartL As Long, StartW As Long
Dim UB As Long, FF As Long, SeqLen As Long, FS, FSM As Double, Num2 As Long
Dim DimSize As Integer, b As Long, BSCycleNumber As Long, TotalTime As Variant, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long, LmB As Variant
Dim OP As Long, LSeq As Long, WinNum As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, SSX As Long, ZZZ As Long, StSt As Long
Dim BB As Long, ZZ As Long, AAA As Long, Dummy As Long, ETS As Long
'Do you want to rerun analysis?


If RunFlag = 1 And CLine = "" And JumpInFlag = 0 Then
    Response = MsgBox("Restart analysis?", 36)
    If Response = 7 Then
        CurrentlyRunningFlag = 0
        'Form1.Picture10.Enabled = True
        Exit Sub
    End If
    Call UnModNextno
    Call UnModSeqNum(0)
End If

If RefNum > 0 And QvRFlagOverrideFlag = 0 And (CLine = "" Or CLine = " ") And JumpInFlag = 1 Then
    Response = MsgBox("There are a number of reference sequences selected.  Would you like to do an autmated query vs references scan for recombination?  If you press 'Yes' the sequences that have not been identified as reference sequences will be tested to determine whether they are the recombinant offspring of two or more of the reference sequences. If you press 'No' a fully exploratory scan for recombination will be carried out (i.e. a scan where every sequence is treated as a potential recombinant)", 36)
    If Response = 7 Then
        QvRFlag = 0
        
        'Form1.Picture10.Enabled = True
    Else
        QvRFlag = 1
    End If
ElseIf RefNum > 0 And QvRFlagOverrideFlag = 0 And (CLine <> "" And CLine <> " ") Then
    QvRFlag = 1
End If

If SelGrpFlag > 0 Then
    Dim GrpTest As Long
    GrpTest = 0
    For x = 0 To NextNo
        GrpTest = GrpTest + GrpMaskSeq(x)
        If GrpTest > 2 Then
            Exit For
        End If
    Next x
    If GrpTest < 2 Then
        SelGrpFlag = 0
    End If
End If

Rnd (-BSRndNumSeed)
'Randomize (BSRndNumSeed)
QvRFlagOverrideFlag = 0

If MCCorrection > MaxAnalNo Or QvRFlag = 1 Then
    Form1.SSPanel1.Caption = "Finding list of sequences to analyse"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If
'XX = MaxAnalNo
'MaxAnalNo = 100000
If ReassortmentFlag = 1 Then CircularFlag = 0
AbortFlag = 0
'Call DrawGMap
    If CLine = "" Or CLine = " " Then
        Command3.SetFocus
    End If
    If CurrentlyRunningFlag = 1 Then Exit Sub
    
    
    'DontDoHS1Change = 1
    'Form1.Picture7.Enabled = False
    
    
    
    
    Form1.Picture10.Enabled = False

    
    AcceptChangeFlag = 0
    ManFlag = -1
    
    If (CLine = "" Or CLine = " ") Then
        Command3.SetFocus
    End If

    
    If Form2.Visible = True Then Form2.Visible = False
    ReDim SubMaskSeq(NextNo + 1), RevSeq(NextNo)
    ReDim NumRecsI(NextNo)
    ReDim XOverSeq(NextNo + 2)
    ReDim CurrentXOver(NextNo + 1)
   
    'Work out how many sequences we're actually dealing with to see
    'if a bootscan is viable
    NumberOfSeqs = 0
    For x = 0 To NextNo
        If MaskSeq(x) < 1 Then
            SubMaskSeq(NumberOfSeqs) = x
            RevSeq(x) = NumberOfSeqs
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    oNumberOfSeqs = NumberOfSeqs
    
    'Have a look at available memory to see if a bootscan is viable
    GlobalMemoryStatus MemSit
     
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    If DoScans(0, 2) = 1 And (CLine = "") Then
        
        SeqLen = Len(StrainSeq(0))
        Num2 = 2
        FS = ((NumberOfSeqs * (NumberOfSeqs - 1)) / 2)
        FS = FS * BSBootReps
        FS = FS * (CLng(SeqLen / BSStepSize) + 2)
        FS = FS * Num2
        If FS > 2000000000 And x = 12345 Then
            FSM = 2000000000 / FS
            If BSStepSize / FSM < BSStepWin / 4 Then
                If CLine = "" Or CLine = " " Then
                    Response = MsgBox("You have specified that you would like to scan this alignment using Bootscan with " & BSBootReps & " bootsrap replicates and a step size of " & BSStepSize & ".  You should, however, be warned that this will require an approximately " & Trim$(CStr(CLng(FS / 100000000) / 10)) & " Gigabyte file being written to your hard disk.  Unfortunately windows currently has capped file sizes at ~ 2 Gigabytes. " & Chr$(13) & Chr$(10) & Chr$(13) & Chr$(10) & "Would you like to increase the stepsize to " & CLng(BSStepSize / FSM) - 1 & " and simply continue with the scan? ", 35, "RDP Warning") ' vbYesNoCancel)
                Else
                    Response = 6
                End If
                If Response = 6 Then
                    BSStepSize = BSStepSize / FSM
                    pBSStepSize = BSStepSize
                ElseIf Response = 2 Then
                    oRecombNo(100) = 0
                    GoTo BailOut
                ElseIf Response = 7 Then
                    oRecombNo(100) = 0
                    GoTo BailOut
                End If
            Else
                SeqLen = Len(StrainSeq(0))
                Num2 = 2
                FS = ((NumberOfSeqs * (NumberOfSeqs - 1)) / 2)
                FS = FS * BSBootReps
                FS = FS * (CLng(SeqLen / (BSStepWin / 4)) + 2)
                FS = FS * Num2
                FSM = 2000000000 / FS
                If CLine = "" Or CLine = " " Then
                    Response = MsgBox("You have specified that you would like to scan this alignment using Bootscan with " & BSBootReps & " bootsrap replicates and a step size of " & BSStepSize & ".  You should, however, be warned that this will require an approximately " & Trim$(CStr(CLng(FS / 100000000) / 10)) & " Gigabyte file being written to your hard disk.  Unfortunately windows currently has capped file sizes at ~ 2 Gigabytes. " & Chr$(13) & Chr$(10) & Chr$(13) & Chr$(10) & "Would you like to increase the stepsize to " & CLng(BSStepWin / 4) & ", reduce the number of bootstrap replicates to " & CLng(BSBootReps * FSM) - 1 & " and simply continue with the scan? ", 35, "RDP Warning") ' vbYesNoCancel)
                Else
                    Response = 6
                End If
                If Response = 6 Then
                    BSBootReps = CLng(FSM * BSBootReps)
                    pBSBootReps = pBSBootReps
                    BSStepSize = BSStepWin / 4
                    pBSStepSize = BSStepSize
                ElseIf Response = 2 Then
                    oRecombNo(100) = 0
                    GoTo BailOut
                ElseIf Response = 7 Then
                    oRecombNo(100) = 0
                    GoTo BailOut
                End If
            End If
            
        ElseIf FS > 1000000000 Then
            If CLine = "" Or CLine = " " Then
                Response = MsgBox("You have specified that you would like to scan this alignment using Bootscan with " & BSBootReps & " bootsrap replicates and a step size of " & BSStepSize & ".  You should, however, be warned that theses settings will result in an approximately " & Trim$(CStr(CLng(FS / 1000000))) & " Megabyte temporary file being written to your hard disk. " & Chr$(13) & Chr$(10) & Chr$(13) & Chr$(10) & "Would you like to continue with the scan? ", 36, "RDP Warning") ' vbYesNoCancel)
            Else
                Response = 6
            End If
            If Response = 6 Then
                'BSStepsize = BSStepsize / FSM
            ElseIf Response = 2 Then
                oRecombNo(100) = 0
                GoTo BailOut
            ElseIf Response = 7 Then
                oRecombNo(100) = 0
                GoTo BailOut
            End If
        End If
        'if
    End If
    
    'Write RDP.ini file to store the exact progam state at start of run
    Call WriteIni
    
    If CLine = "" Or CLine = " " Then
        'set up sequence display
        If ShowSeqFlag <> 0 Then
            ShowSeqFlag = 0
            Form1.Picture3.AutoRedraw = True
            Picture3.Picture = LoadPicture()
            Label21 = "Show All Sequences"
            OnlyDoPositionIndicator = 0
            OnlyDoPosBar = 0
            OnlyDoFlash = 0
            LastBottom = -1
            Call HScroll1_Change
            If ColDistInFile = 1 Then
                
                ReDim ColDist2(0)
                Timer7(1).Enabled = False
            End If
            Call PrintNames
        End If
        CurrentlyRunningFlag = 1
        
        'Set up stuff needed for diplaying plots
        Picture7.Picture = LoadPicture(): Picture10.Picture = LoadPicture()
        Picture7.AutoRedraw = True: Picture10.AutoRedraw = False
        Form1.Picture7.ScaleMode = 3: Form1.Picture10.ScaleMode = 3
        Picture7.CurrentX = 0: Picture7.CurrentY = 0
        XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
        YScaleFactor = 0.85
        PicHeight = Form1.Picture7.Height * YScaleFactor
        Picture7.BackColor = BackColours: Picture10.BackColor = BackColours
        Picture7.Enabled = False
        
        'clear recombination info display
        Picture2.Picture = LoadPicture()
        SSPanel16.Caption = ""
        SSPanel16.BackColor = HalfColour
        Picture2.BackColor = Form1.BackColor
        Label58.Caption = ""

        'clear and disable schmatic sequence display
        Picture6.Picture = LoadPicture()
        Picture6.Left = 0: Picture6.AutoRedraw = True
        Picture6.BackColor = Form1.BackColor
        Picture5.BackColor = Form1.BackColor
        SSPanel5.Enabled = False
                
        'disable similarity and sequence displays
        SSPanel3.Enabled = False
        
        SSPanel4.Enabled = False

        'Sort out comparrison table
        Call SetUpFrame17
        
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        
        Label50(0).Caption = "--"
        Label50(1).Caption = "--"
        Label50(2).Caption = "--"
        Label50(3).Caption = "--"
        Label50(12).Caption = "--"
        Label50(13).Caption = "--"
        Frame17.Visible = True
            
        If (ShowPlotFlag = 2 Or ShowPlotFlag = 1) Then
            SSPanel6(1).Visible = False
            SSPanel6(2).Visible = False
            SSPanel6(0).Visible = True
            
            If ShowPlotFlag = 2 Then
                oDMax = 0.4
                oPMax = 10
                oRec = 0
                ReDim StartPlt(AddNum)
                
                Call DoAxes2(oDMax, 0, oPMax, 0, MaxHits, 0, 0, "PDist", "P-Val", "# Hits")
            End If
            
        End If
        
        Frame17.ZOrder
        
        If DebuggingFlag < 2 Then On Error Resume Next
        LowestProb = pLowestProb
        
        On Error GoTo 0
       
        SSPanel1.Caption = "Preparing for Scan"
        
        Timer1.Enabled = False: Timer2.Enabled = False
        Command6(0).Enabled = False: Command6(2).Enabled = False: Command5.Enabled = False: Command9.Enabled = False: Command10.Enabled = False
        SSPanel5.Enabled = False: SSPanel2.Enabled = False
        HScroll2.Enabled = False
        VScroll2.Enabled = False
        
        Picture8.Enabled = False
        
        
        'Open space in bottom panel for seconds remaining info
        If DoScans(0, 8) = 1 Or DoScans(0, 0) = 1 Or (DoScans(0, 1) = 1 And GCtripletflag = 1) Or DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 6) = 1 Then
    
            StartL = ProgressBar1.Left
            StartW = ProgressBar1.Width
            ProgressBar1.Value = 0
            Call UpdateF2Prog
            For x = 3 * Screen.TwipsPerPixelX To 223 * Screen.TwipsPerPixelX Step 20 * Screen.TwipsPerPixelX
                StartL = StartL + 20 * Screen.TwipsPerPixelX
                StartW = StartW - 20 * Screen.TwipsPerPixelX
                If StartW > 0 And StartL > 0 Then
                    ProgressBar1.Width = StartW: ProgressBar1.Left = StartL
                End If
                DoEvents 'covered by currentlyrunningflag
                'Sleep 3
                Form1.WindowState = Form1.WindowState
            Next 'X
    
        End If
        
        'Enable the stop button
        Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Command25.Enabled = True
        Command25.ToolTipText = "Stop exploratory phase of the scan"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        'disable the options and accept buttons
        Form1.Command29(0).Enabled = 0
        Form1.Command29(1).Enabled = 0
        'disable sspanel6 (tree, matrix, recombination info and overview)
        Form1.SSPanel6(0).Enabled = False
        Form1.SSPanel6(1).Enabled = False
        Form1.SSPanel6(2).Enabled = False
    End If
    
    Call SetupGlobals
    
    'Start the clock
    ST = Abs(GetTickCount)
    LT = ST
    
    'Early start geneconv if necessary
    If DoScans(0, 1) = 1 And GCtripletflag = 0 Then
        Call GCXOverB
    ElseIf DoScans(0, 3) = 1 And MCTripletFlag = 1 And ShortOutFlag = 0 Then
        Call GCDrawC
        MinP = 0
    End If
    
    'work out bonferroni etc corrections
    Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
    
    If MCCorrection > MaxAnalNo Or QvRFlag = 1 Then
        Form1.SSPanel1.Caption = "Finding list of sequences to analyse"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    
    XOverListSize = Int(NextNo * (NextNo * 2))
    XOverListSize = XOverListSize / 8
    If XOverListSize > 100 Then XOverListSize = 100
    If MaxXOListSize < XOverListSize Then XOverListSize = MaxXOListSize
    
    ReDim XoverList(NextNo, XOverListSize)
    ReDim MaxXOP(AddNum - 1, NextNo)
    Call ResetMaxPVCO(NextNo)
    On Error GoTo 0
       
    BRunning = 1 ' tell some parts of the program that a run is in progress
       
    'erase unneeded array
    ReDim SMat(0, 0)
    ReDim FMat(0, 0)
    ReDim SubValid(0, 0)
    ReDim SubDiffs(0, 0)
    ReDim FubValid(0, 0)
    
    If StrainSeqOnDisk = 0 And PermNextno * (Len(StrainSeq(0))) > 10000000 Then
        oDirX = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5Strainseq" + UFTag For Binary As #FF
        Put #FF, , StrainSeq()
        Close #FF
        ReDim Preserve StrainSeq(0)
        StrainSeqOnDisk = 1
        ChDrive oDirX
        ChDir oDirX
    End If
       
    If GPerms > 0 Then
        Call DoPermsB
        DistanceFlag = 1
        Call SetupGlobals
    End If
    
    b = 0
    'Call SetUpNumSeq
    
    'clear method timers
    For x = 0 To 20
        MethodTime(x) = 0
    Next x
    
    If (x = x Or MCCorrection > MaxAnalNo) And QvRFlag = 0 Then
        Call MakeAnalysisList
        UseALFlag = 1
    ElseIf QvRFlag = 1 Then
        If TripListLen > 1000000 Then
            On Error Resume Next
                UB = -1
                UB = UBound(Analysislist, 2)
            On Error GoTo 0
            
            If UB = -1 Then
                'Call MakeAnalysisListQvR
                ReDim Preserve Analysislist(2, TripListLen)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5AnalysisList" + UFTag For Binary As #FF
                Get #FF, , Analysislist
                Close #FF

                ChDrive oDirX
                ChDir oDirX
            End If
        End If
        If TripListLen = 0 Then
            Call MakeAnalysisListQvR
        End If
        UseALFlag = 1
    End If
    
    SSS = Abs(GetTickCount)
    
    If (CLine <> "" And CLine <> " ") Then
        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
        GetConsoleScreenBufferInfo hOutput, scrbuf
        WriteToConsole vbClearLine
        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
        GetConsoleScreenBufferInfo hOutput, scrbuf
        WriteToConsole vbCrLf & "Detecting recombination signals (the first of two analysis phases)" & vbCrLf & vbCrLf
    End If
    
    Iter = 0
    
    Do While Iter < 100
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        If Dir("RDP5Redolist" + Str(Iter) + UFTag) <> "" Then
            ''Open "RDP5Redolist" + Str(Iter) + UFTag For Binary As #FF
            
            Kill "RDP5Redolist" + Str(Iter) + UFTag
            
            'GoTo REDOREDO
        Else
            Iter = Iter + 1
        End If
        ChDrive oDirX
        ChDir oDirX
    Loop
        
    
    If UseALFlag = 1 And (ExRecFlag = 0 Or ExRecFlag = 210) Then
        Call UnModNextno
         Call UnModSeqNum(0)
        CurWothwhilePos = TripListLen
        ReDim Worthwhilescan(TripListLen)
        Call MakeScanCompressArrays(NextNo, SeqNum())
        If DoScans(0, 0) = 1 Then
            Rnd (-BSRndNumSeed)
            Command25.ToolTipText = "Stop exploratory RDP phase of the scan"
            CurrentCorrect = 0
            'rdp
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            ReDim ValidSpacer(NextNo)
            ReDim SpacerSeqs(NextNo)
            ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
            ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
            ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
            'If UBound(CompressSeq, 2) <> NextNo Then
    
            
            'End If
            If ProbEstimateInFileFlag = 1 Then
                ReDim ProbEstimate(171, 171, 50)
                
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                'XX = App.Path
                FF = FreeFile
                Open "BinProbs" For Binary As #FF
                Get #FF, , ProbEstimate()
                Close #FF
            End If
            
            
            'AnalysisList(0, TripListLen)
            If PermNextno > TripListSaveCO And x = 12345 Then
    
'                TripListLenSeq(x) = TripListLen
'                ReDim Preserve Analysislist(2, TripListLen)
'                FF = FreeFile
'                Open "TrpList" + Trim(Str(x)) For Binary As #FF
'                Put #FF, , Analysislist()
'                Close #FF
'                TripListLen = 0
                
                
            Else
            
            'TripListLen = 950000
                
                ST = Abs(GetTickCount)
                
                
                
                If MCCorrection = 0 Then
                    Dim TXX As Variant
                    TXX = 0
                    For x = 0 To NextNo
                        If MaskSeq(x) = 0 Then
                            TXX = TXX + 1
                        End If
                    Next x
                    TX = TXX - 2
                    TXX = TXX * (TXX - 1)
                    TXX = TXX * (TX - 2)
                    TXX = TXX / 6
                    MCCorrection = TXX
                End If
                If x = x Then
                    Dim RedoL3() As Byte, NumRedos As Long, UCThresh As Double, EPX As Long
                    Dim Steps As Long
                    If MCFlag = 0 Then
                        UCThresh = LowestProb / MCCorrection
                    Else
                        UCThresh = LowestProb
                    End If
                    ReDim RedoL3(TripListLen)
                    Steps = 100000000 / Len(StrainSeq(0))
                    Steps = Steps '* (XOverWindowX / 30)
                    UseCompress = 1
                    'ZZZ = 0
                    'XX = NextNo
                    ggg = 0
                    
                    For Y = 0 To TripListLen Step Steps
                        If Y + Steps - 1 > TripListLen Then
                            EPX = TripListLen
                        Else
                            EPX = Y + Steps - 1
                        End If
                        '@'@
                        'NumRedos = AlistRDP3(Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        NumRedos = AlistRDP4(UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        
                        'If NumRedos > 0 Then
                        '@'@
                        
'                        Open "temp2.csv" For Output As #1
'                        For x = 0 To TripListLen
'
'                                Print #1, Str(Analysislist(0, x)) + "," + Str(Analysislist(1, x)) + "," + Str(Analysislist(2, x))
'
'                        Next x
'                        Close #1
'
                        XX = RedoListSize
                        For x = Y To EPX
                            If RedoL3(x) = 1 Then
                                Seq1 = Analysislist(0, x)
                                Seq2 = Analysislist(1, x)
                                Seq3 = Analysislist(2, x)
'                                If x = 18001 Then
'                                    x = x
'                                    XX = XoverList(27, 11).Beginning
'                                    XX = XoverList(27, 11).Ending
'                                    XX = XoverList(27, 11).Probability
'
'                                End If
                                
                                'ZZZ = ZZZ + 1
                                CurrentTripListNum = x
                                ''22,245,285
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                ggg = ggg + 1 '855,535, 572, 559
' If XoverList(27, 11).Beginning <> 0 And XoverList(27, 11).Ending <> 0 And XoverList(27, 11).Probability <> 0 Then
'    x = x
' End If
'
'                                If RedoListSize > 0 Then
                                  '  Call AddToRedoList(0, Analysislist(0, x), Analysislist(1, x), Analysislist(2, x))
'                                End If
                            ElseIf RedoL3(x) = 2 Then
                                If ProgBinRead(0, Worthwhilescan(x)) = 0 Then
                                    Worthwhilescan(x) = Worthwhilescan(x) + 1
                                End If
                                Call AddToRedoList(0, Analysislist(0, x), Analysislist(1, x), Analysislist(2, x))
                            End If
                        Next x
                        x = x
                        'End If
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            If (Y + Steps - 1) <= (TripListLen + 1) Then
                                Form1.ProgressBar1.Value = (Y + Steps - 1) / (TripListLen + 1) * 100
                            End If
                            Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            UpdateRecNums (SEventNumber)
                            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(0) = 1
                                oRec = oRecombNo(100)
                                Call UpdatePlotC
                                ET = Abs(GetTickCount)
                            End If
                            LT = ET
                            If Form1.ProgressBar1.Value > 0 Then
                                Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Str(Y + Steps - 1) & " of " & Str(TripListLen) & " triplets examined"
                            End If
                            If (CLine <> "" And CLine <> " ") Then
                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                WriteToConsole vbClearLine
                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                            End If
                            Call UpdateF2Prog
                            DoEvents
                            If AbortFlag = 1 Then
                                Exit For
                            End If
                            
                        End If
                    Next Y
                    'XX = ZZZ '262244
                    UseCompress = 0
                Else
                    '@'@'@
                    For x = 0 To TripListLen
                        Seq1 = Analysislist(0, x)
                        Seq2 = Analysislist(1, x)
                        Seq3 = Analysislist(2, x)
                        CurrentTripListNum = x
                        nnn = nnn + 1
                        '@
                        Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                        
                        
                        ET = Abs(GetTickCount)
                        If Abs(ET - LT) > 500 Then
                            Form1.ProgressBar1.Value = x / TripListLen * 100
                            
                            Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            UpdateRecNums (SEventNumber)
                            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(0) = 1
                                oRec = oRecombNo(100)
                                Call UpdatePlotC
                                ET = Abs(GetTickCount)
                            End If
                            LT = ET
                            If Form1.ProgressBar1.Value > 0 Then
                                Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Str(x) & " of " & Str(TripListLen) & " triplets examined"
                            
                                Call UpdateF2Prog
                            End If
                            DoEvents 'covered by currentlyrunningflag
                            If AbortFlag = 1 Then
                                SSPanel1.Caption = ""
                                ProgressBar1.Value = 0
                                Call UpdateF2Prog
                                If CurWothwhilePos > x Then CurWothwhilePos = x
                                x = TripListLen
                            End If
                            RunFlag = 1
                            If (CLine <> "" And CLine <> " ") Then
                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                WriteToConsole vbClearLine
                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                            End If
                        End If
                        If Worthwhilescan(x) = 0 Then
                            If Analysislist(2, x) < NextNo And x < TripListLen Then
                                 If Analysislist(2, x) + 1 < Analysislist(2, x + 1) Then
                                    Analysislist(2, x) = Analysislist(2, x) + 1
                                    mmm = mmm + 1
                                    x = x - 1
                                End If
                            
                            End If
                        End If
                        x = x
                    Next x
                End If
            End If
            If MCFlag = 2 Then
                CurrentCorrect = 4
                Call StepDown
            End If
            ET = Abs(GetTickCount)
            Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(0) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
                ET = Abs(GetTickCount)
            End If
            
'            EE = Abs(GetTickCount) '123.678 for 950000 triplets
'            TT = EE - SS
            ET = Abs(GetTickCount)
            MethodTime(0) = Abs(ET - ST)
            Erase ValidSpacer
            Erase SpacerSeqs
            Erase XoverSeqNum
            Erase XoverSeqNumW
            Erase XOverHomologyNum
            If ProbEstimateInFileFlag = 1 Then
                Erase ProbEstimate
            End If
            If AbortFlag = 1 Then
                SSPanel1.Caption = ""
                ProgressBar1.Value = 0
                Call UpdateF2Prog
                AbortFlag = 0
                ABFl(0) = 1
                
            End If
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running RDP scan: 100% complete" & vbCrLf
            End If
        End If
        '42:17, 22922870, 24527115 (redolistsize = 1604245)
        
        '14:48,12:50, 2524462, 4133825(redolistsize = 1609363)
        XX = RedoListSize
        If DoScans(0, 1) = 1 Then
        'geneconv
            GCIndelFlag = 0
            Command25.ToolTipText = "Stop exploratory GENECONV phase of the scan"
            CurrentCorrect = 1
            b = 0
            oRecombNo(1) = 0
            GCST = Abs(GetTickCount)
            ReDim SubSeq(Len(StrainSeq(0)), 6)
            Dim SS2() As Byte
                ReDim SS2(UBound(SubSeq, 1), UBound(SubSeq, 2))
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            ReDim FragMaxScore(GCDimSize, 5)
            ReDim MaxScorePos(GCDimSize, 5)
            ReDim PVals(GCDimSize, 5)
            ReDim FragSt(GCDimSize, 6)
            ReDim FragEn(GCDimSize, 6)
            ReDim FragScore(GCDimSize, 6)
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'If x = x Then
                If MCFlag = 0 Then
                    UCThresh = LowestProb / MCCorrection
                Else
                    UCThresh = LowestProb
                End If
                
                ReDim RedoL3(TripListLen)
                Steps = (100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                'ZZZ = 0
                For Y = 0 To TripListLen Step Steps
                    If Y + Steps - 1 > TripListLen Then
                        EPX = TripListLen
                    Else
                        EPX = Y + Steps - 1
                    End If
                    '@'@'@'@'@'@'@'@
                    'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                    'If NumRedos > 0 Then
                    '@'@
                    
                    'ggg = 0
                    'gggg = 0
                    For x = Y To EPX
                        If RedoL3(x) = 1 Then
                            Seq1 = Analysislist(0, x) '0
                            Seq2 = Analysislist(1, x) '8
                            Seq3 = Analysislist(2, x) '42
                            'ZZZ = ZZZ + 1
                            CurrentTripListNum = x
                            NewOneFound = 0
                            Call GCXoverD(0)
                            'ggg = ggg + 1
                        ElseIf RedoL3(x) = 2 Then
                                If ProgBinRead(1, Worthwhilescan(x)) = 0 Then
                                
                                    Worthwhilescan(x) = Worthwhilescan(x) + 2
                                
                                End If
                                Call AddToRedoList(1, Analysislist(0, x), Analysislist(1, x), Analysislist(2, x))
                                'gggg = gggg + 1
'                        ElseIf RedoL3(x) = 0 Then
'                            x = x
                        End If
                    Next x
                    'End If
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        If (Y + Steps - 1) <= TripListLen Then
                            Form1.ProgressBar1.Value = (Y + Steps - 1) / TripListLen * 100
                        End If
                        Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(1) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value > 0 Then
                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - GCST))) & " remaining"
                            Form1.SSPanel1.Caption = Str(Y + Steps - 1) & " of " & Str(TripListLen) & " triplets examined"
                        End If
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        Call UpdateF2Prog
                        DoEvents
                        If AbortFlag = 1 Then
                            Exit For
                        End If
                        
                    End If
                Next Y
                'XX = ZZZ '262244
                UseCompress = 0

            If MCFlag = 2 Then
                CurrentCorrect = 1
                Call StepDown
            End If
            ET = Abs(GetTickCount)
            ET = Abs(ET)
            GCST = Abs(GCST)
            Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(1) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
            End If
            If AbortFlag = 1 Then
                SSPanel1.Caption = ""
                ProgressBar1.Value = 0
                Call UpdateF2Prog
                AbortFlag = 0
                ABFl(1) = 1
            End If
            ET = Abs(GetTickCount)
            GCST = Abs(GCST)
            MethodTime(1) = Abs(ET - GCST)
            Erase SubSeq
            Erase FragMaxScore
            Erase MaxScorePos
            Erase PVals
            Erase FragSt
            Erase DeleteArray
            Erase FragEn
            Erase FragScore
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running GENECONV scan: 100% complete" & vbCrLf
            End If
            
        End If

        If DoScans(0, 2) = 1 Then

            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running BOOT scan: 0% complete"
            End If

            Command25.ToolTipText = "Stop exploratory RECSCAN phase of the analysis"
            CurrentCorrect = 2
            BSStart = Abs(GetTickCount)
            oRecombNo(2) = 0
            BSCycleNumber = 0
            SSPanel1.Caption = "Performing Bootscans"

            'Call BSXoverO
            Call BSXoverR '2
            'Call BSXoverP2

'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running BOOT scan: 100% complete" & vbCrLf
'            End If


            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(2) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
            End If
            BSEnd = Abs(GetTickCount)
            BSStart = Abs(BSStart)
            Form1.Label50(4).Caption = DoTimeII(Abs(BSEnd - BSStart)) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
            Form1.Label50(12).Caption = DoTimeII(Abs(BSEnd - ST)) 'DoTimeII(bsend - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
            ET = Abs(GetTickCount)
            MethodTime(2) = ET - Abs(BSStart)

            If MCFlag = 2 Then
                CurrentCorrect = 2
                Call StepDown
            End If
            UpdateRecNums (SEventNumber)

            If AbortFlag = 1 Then
                SSPanel1.Caption = ""
                ProgressBar1.Value = 0
                Call UpdateF2Prog
                AbortFlag = 0
                ABFl(2) = 1

                If oRecombNo(2) = 0 Then DoScans(0, 2) = 0
            End If
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running BOOT scan: 100% complete" & vbCrLf
            End If
        End If

'1h:04
'26:35
'1871414
        If DoScans(0, 3) = 1 Then
            Command25.ToolTipText = "Stop exploratory MAXCHI phase of the scan"
            CurrentCorrect = 3
            SSPanel1.Caption = "Executing MaxChi"
            MCS = Abs(GetTickCount)
            oRecombNo(3) = 0
            Form1.ProgressBar1 = 0
            Call UpdateF2Prog
            Dim ActualDir As String
            If DebuggingFlag < 2 Then On Error Resume Next
            ActualDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            On Error GoTo 0
            'Close #1
            Picture3.AutoRedraw = True
            
            Call SetupMCArrays
            If MCProportionFlag = 0 Then
                Call GetCriticalDiff(0)
                If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
                    MCWinSize = HWindowWidth * 2
                End If
            End If
            If UBound(CompressSeq, 2) <> NextNo Then
                Call MakeScanCompressArrays(NextNo, SeqNum())
            End If
            
'            Dim Scores2() As Byte
'                Dim WinScores2() As Long
'                ReDim Scores2(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
'                ReDim WinScores2(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'            Dim SmoothChi2() As Double
'            ReDim SmoothChi2(UBound(SmoothChi, 1), UBound(SmoothChi, 2))
'
            
            UseCompress = 1
'            Dim RLX() As Byte
'            ReDim RLX(TripListLen)
            If MCFlag = 0 Then
                UCThresh = LowestProb / MCCorrection
            Else
                UCThresh = LowestProb
            End If
            If x = x Then
                'UCTHresh = LowestProb / MCCorrection
                
                ReDim RedoL3(TripListLen)
                Steps = (100000000 / Len(StrainSeq(0))) / 2
                
                ZZZ = 0
                For Y = 0 To TripListLen Step Steps
                    If Y + Steps - 1 > TripListLen Then
                        EPX = TripListLen
                    Else
                        EPX = Y + Steps - 1
                    End If
                    '@'@'@'@'@'@'@'@
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    HWindowWidth = CLng(MCWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    NumRedos = AlistMC2(Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, 0, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                    'If NumRedos > 0 Then
                    '@'@
                    
                    'ggg = 0
                    'gggg = 0
                    For x = Y To EPX
'                        If RedoL3(x) > 0 Then
'                            RLX(x) = 1
'                        End If
'                        If x = 46 Then
'                            x = x
'                        End If
                        If RedoL3(x) = 1 Then
                            
                            Seq1 = Analysislist(0, x) '15
                            Seq2 = Analysislist(1, x) '44
                            Seq3 = Analysislist(2, x) '119
                            ZZZ = ZZZ + 1
                            BQPV = 1
'                            Seq1 = 15
'                            Seq2 = 44
'                            Seq3 = 119
                            'GoOn = FastRecCheckMC(0, LongWindedFlag, BQPV, 1, UCTHresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiff, 1, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChi(0, 0))
                    
'                            If GoOn = 1 And RedoL3(x) = 0 Then
'                                x = x
'                            End If
                            CurrentTripListNum = x
                            NewOneFound = 0
                            Call MCXoverF(0, 0, 0)
                            'x = x
'                            If NewOneFound = 0 Then
'                                x = x
'                            End If
'                            x = x
                            'ggg = ggg + 1
                        ElseIf RedoL3(x) = 2 Then
                                ZZZ = ZZZ + 1
                                If ProgBinRead(3, Worthwhilescan(x)) = 0 Then
                                
                                    Worthwhilescan(x) = Worthwhilescan(x) + 4
                                
                                End If
                                Call AddToRedoList(3, Analysislist(0, x), Analysislist(1, x), Analysislist(2, x))
                                'gggg = gggg + 1
'                        ElseIf RedoL3(x) = 0 Then
'                            x = x
'                        ElseIf RedoL3(x) = 0 Then
'                            Seq1 = Analysislist(0, x) '0
'                            Seq2 = Analysislist(1, x) '8
'                            Seq3 = Analysislist(2, x) '42
'                            ZZZ = ZZZ + 1
'                            CurrentTripListNum = x
'                            NewOneFound = 0
'                            Call MCXoverF(0, 0, 0)
'                            If NewOneFound = 1 Then
'                                x = x
'                            End If
                        End If
                    Next x
                    'End If
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    MCE = ET
                    If Abs(ET - LT) > 500 Then
                        If (Y + Steps - 1) <= (MCCorrection + 1) And (Y + Steps - 1) < (TripListLen + 1) Then
                            Form1.ProgressBar1.Value = (Y + Steps - 1) / (TripListLen + 1) * 100
                        Else
                            Form1.ProgressBar1.Value = 100
                        End If
                        Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS))
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(1) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value > 0 Then
                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(MCE - MCS)) * (100 / Form1.ProgressBar1.Value) - (Abs(MCE - MCS))) & " remaining"
                            Form1.SSPanel1.Caption = Str(Y + Steps - 1) & " of " & Str(TripListLen) & " triplets examined"
                        End If
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        Call UpdateF2Prog
                        DoEvents
                        If AbortFlag = 1 Then
                            Exit For
                        End If
                        
                    End If
                Next Y
                'XX = ZZZ '262244
                UseCompress = 0
            Else
                UseCompress = 1
                
                For x = 0 To TripListLen
    '                AA = Abs(GetTickCount)
    '                For ZZ = 1 To 10000
                    Seq1 = Analysislist(0, x)
                    Seq2 = Analysislist(1, x)
                    Seq3 = Analysislist(2, x)
                    '0,1,6;0,1,96(46);0,1,110(53),0,1,118(57)
                    LastY3 = -1
                    MCMaxP = LowestProb
                    CurrentTripListNum = x
    '                If Seq1 = 2 And Seq2 = 13 And Seq3 = 49 Then
    '                    x = x
    '                End If
                    'ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
                    'ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
                    'ReDim Chivals(Len(StrainSeq(0)), 2)
    '                ReDim SmoothChi(Len(StrainSeq(0)), 2)
    '                ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    '                ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    '                ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
                    GoOn = FastRecCheckMC(0, LongWindedFlag, BQPV, 1, UCThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiff, 1, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChi(0, 0))
                    'ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
                    'ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
                    'ReDim Chivals(Len(StrainSeq(0)), 2)
    '                ReDim SmoothChi(Len(StrainSeq(0)), 2)
    '                ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    '                ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    '                ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
                    '37174
'                    If GoOn = 1 And RLX(x) = 0 Then
'                        x = x
'                    ElseIf GoOn = 0 And RLX(x) = 1 Then
'                        x = x
'                    End If
                    If GoOn = 1 Then
                        'NewOneFound = 0
                        ZZZ = ZZZ + 1
                        Call MCXoverF(0, 0, 0)
                        x = x
    '                    If NewOneFound = 1 And GoOn = 0 Then
    '                        x = x
    '                    End If
                     End If
                      x = x
    '                  For A = 0 To UBound(SmoothChi, 1)
    '                    For Y = 0 To UBound(SmoothChi, 2)
    '                        If SmoothChi2(A, Y) <> SmoothChi(A, Y) Then
    '                            x = x
    '                        End If
    '                    Next Y
    '
    '                  Next A
    '                'End If
    '
    '                Next ZZ
    '
    '                XX = Seq1 '35,69,81
    '                XX = Seq2
    '                XX = Seq3
    '                For A = 0 To 2
    '                    For Y = 0 To UBound(WinScores2, 2)
    '                        If WinScores2(Y, A) <> Winscores(Y, A) Then
    '                            x = x
    '                        End If
    '                    Next Y
    '
    '                    For Y = 0 To UBound(Scores2, 2)
    '                        If Scores2(Y, A) <> Scores(Y, A) Then
    '                            x = x
    '                        End If
    '                    Next Y
    '                    x = x
    '                Next A
                     MCE = Abs(GetTickCount)
                    ET = Abs(GetTickCount)
    '                BB = Abs(GetTickCount)
    '                TT = BB - AA '9.360
                    
                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                        Form1.ProgressBar1.Value = (x) / (TripListLen) * 100
                        
                        Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS))
                        Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(3) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value > 0 Then
                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(MCE - MCS)) * (100 / Form1.ProgressBar1.Value) - Abs(MCE - MCS)) & " remaining"
                        End If
                        Form1.SSPanel1.Caption = Str(x) & " of " & Str(TripListLen) & " triplets examined"
                        
                        Call UpdateF2Prog
                        DoEvents 'covered by currentlyrunningflag
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        If AbortFlag = 1 Then
                            SSPanel1.Caption = ""
                            ProgressBar1.Value = 0
                            Call UpdateF2Prog
                            If CurWothwhilePos > x Then CurWothwhilePos = x
                            x = TripListLen
                        End If
                    End If
                    RunFlag = 1
                    If Worthwhilescan(x) = 0 Then
                        If Analysislist(2, x) < NextNo And x < TripListLen Then
                             If Analysislist(2, x) + 1 < Analysislist(2, x + 1) Then
                                Analysislist(2, x) = Analysislist(2, x) + 1
                                mmm = mmm + 1
                                x = x - 1
                            End If
                        End If
                    End If
    
                Next x
            End If
            XX = ZZZ
            '26591 - old
            '26581 -new
            UseCompress = 0
            If MCFlag = 2 Then
                CurrentCorrect = 3
                Call StepDown
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir ActualDir
            ChDrive ActualDir
            On Error GoTo 0
            MCE = Abs(GetTickCount)
            ET = Abs(GetTickCount)
            MCS = Abs(MCS)
            UpdateRecNums (SEventNumber)
            Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
            Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST))) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
            Form1.Frame17.Refresh
            TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
            ET = Abs(GetTickCount)
            MethodTime(3) = ET - Abs(MCS)
        
            Erase Scores
            Erase Winscores
            Erase Chivals
            Erase SmoothChi
            If AbortFlag = 1 Then
                SSPanel1.Caption = ""
                ProgressBar1.Value = 0
                Call UpdateF2Prog
                AbortFlag = 0
                ABFl(3) = 1
            End If
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running MAXCHI scan: 100% complete" & vbCrLf
            End If
            
        End If '
        '1248168
        '1247287
        '1259867
        '1260402
        '1259723
        '1263210
        '12.86
        '12.07 (without parallel)
        '2:35
        '901321 135679
        '14493954, 133291133
        '28:50
        '4513697 4927287
        '13:11
        '686949 1113400
        '48:13
        '5186164  6272254 (zzz = 4838463) old
        'zzz = 4160709 - missing ~700K screened triplets
        XX = ZZZ
        '4828456 - new one
        '4838463
        '(349094) 818514
        If DoScans(0, 4) = 1 Then
            Command25.ToolTipText = "Stop exploratory CHIMAERA phase of the scan"
            CurrentCorrect = 4
            SSPanel1.Caption = "Executing Chimaera"
            ChiS = Abs(GetTickCount)
            oRecombNo(4) = 0
            Form1.ProgressBar1 = 0
            Call UpdateF2Prog
            b = 0
            Picture3.AutoRedraw = True
    
            HWindowWidth = CLng(CWinSize / 2)
            ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
            ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
            ReDim ChiValsX(Len(StrainSeq(0)))
            ReDim SmoothChiX(Len(StrainSeq(0)))
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            
            Dim LXOS() As Long
            ReDim LXOS(3)
            Dim XDP() As Long, XPD() As Long
            ReDim XDP(Len(StrainSeq(0)) + 200, 2), XPD(Len(StrainSeq(0)) + 200, 2)
            Call GetCriticalDiff(1)
            If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
                CWinSize = HWindowWidth * 2
            End If
            
            
            
            If UBound(CompressSeq, 2) <> NextNo Then
                Call MakeScanCompressArrays(NextNo, SeqNum())
            End If
            UseCompress = 1
            If MCFlag = 0 Then
                UCThresh = LowestProb / MCCorrection
            Else
                UCThresh = LowestProb
            End If
            Dim FindAllFlagX As Byte
            FindAllFlagX = 0
            If x = x Then
                ReDim RedoL3(TripListLen)
                Steps = 100000000 / Len(StrainSeq(0))
                
                ZZZ = 0
                For Y = 0 To TripListLen Step Steps
                    If Y + Steps - 1 > TripListLen Then
                        EPX = TripListLen
                    Else
                        EPX = Y + Steps - 1
                    End If
                    '@'@'@'@'@'@'@'@
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    HWindowWidth = CLng(MCWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    'NumRedos = AlistMC2(Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindallFlag, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCTHresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                    FindallFlag = 0
                    NumRedos = AlistChi(0, MissingData(0, 0), Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSRDP, 2), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                    '                                                  x                 x           x             x         x                  x            x         x                                                  x                                       x               x        x        x           x                                                                                                                                                                   x                 x
                    'If NumRedos > 0 Then
                    '@'@
                    
                    'ggg = 0
                    'gggg = 0
                    For x = Y To EPX
                        CurrentTripListNum = x
                        
                        If RedoL3(x) > 0 Then
                            If ProgBinRead(0, RedoL3(x)) = 1 Then
                                
                                Seq1 = Analysislist(0, x) '15
                                Seq2 = Analysislist(1, x) '44
                                Seq3 = Analysislist(2, x) '119
                                ZZZ = ZZZ + 1
                                BQPV = 1
                                
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If NewOneFound = 0 Then
'                                    x = x
'                                End If
                                
                            End If
                            If ProgBinRead(2, RedoL3(x)) = 1 Then
                                
                                Seq3 = Analysislist(0, x) '15
                                Seq1 = Analysislist(1, x) '44
                                Seq2 = Analysislist(2, x) '119
                                ZZZ = ZZZ + 1
                                BQPV = 1
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If NewOneFound = 0 Then
'                                    x = x
'                                End If
                            End If
                            If ProgBinRead(4, RedoL3(x)) = 1 Then
                                
                                Seq2 = Analysislist(0, x) '15
                                Seq3 = Analysislist(1, x) '44
                                Seq1 = Analysislist(2, x) '119
                                ZZZ = ZZZ + 1
                                BQPV = 1
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If NewOneFound = 0 Then
'                                    x = x
'                                End If
                            End If
                            If ProgBinRead(1, RedoL3(x)) = 1 Or ProgBinRead(3, RedoL3(x)) = 1 Or ProgBinRead(5, RedoL3(x)) = 1 Then
                                ZZZ = ZZZ + 1
                                If ProgBinRead(4, Worthwhilescan(x)) = 0 Then
                                    Worthwhilescan(x) = Worthwhilescan(x) + 5
                                End If
                                Call AddToRedoList(4, Analysislist(0, x), Analysislist(1, x), Analysislist(2, x))
                            End If
                        End If
                    Next x
                    'End If
                    
                    ChiE = Abs(GetTickCount)
                    ET = Abs(GetTickCount)
                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                        If x <= TripListLen Then
                            Form1.ProgressBar1.Value = x / TripListLen * 100
                        End If
                        Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS))
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(4) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 1
                        Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
                        Form1.SSPanel1.Caption = Str(x) & " of " & Str(TripListLen) & " triplets examined"
                        Call UpdateF2Prog
                        DoEvents 'covered by currentlyrunningflag
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running CHIMAERA scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        If AbortFlag = 1 Then
                            SSPanel1.Caption = ""
                            ProgressBar1.Value = 0
                            Call UpdateF2Prog
                            If CurWothwhilePos > x Then CurWothwhilePos = x
                            x = TripListLen
                        End If
                    End If
                    Call UpdateF2Prog
                    DoEvents
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                        
                    
                Next Y
                'XX = ZZZ '262244
                UseCompress = 0
            
            Else
            
                For x = 0 To TripListLen
                    CurrentTripListNum = x
                    Seq1 = Analysislist(0, x)
                    Seq2 = Analysislist(1, x)
                    Seq3 = Analysislist(2, x)
                    tSeq1 = Seq1
                    tSeq2 = Seq2
                    tSeq3 = Seq3
                    'XDP(),
                    GoOn = FastRecCheckChim(MissingData(0, 0), XPD(0, 0), LXOS(0), 0, 0, LongWindedFlag, BQPV, 1, UCThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), CriticalDiff, FindAllFlagX, UBound(FSSRDP, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), UBound(WinScoresX, 1), ScoresX(0), WinScoresX(0), UBound(XDP, 1), XDP(0, 0), ChiValsX(0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChiX(0))
                    If GoOn = 1 Then
                        Call CXoverA(FindAllFlagX, 0, 0)
                    End If
                    
                    'End If
                    Seq1 = tSeq2
                    Seq2 = tSeq3
                    Seq3 = tSeq1
                    GoOn = FastRecCheckChim(MissingData(0, 0), XPD(0, 0), LXOS(0), 1, 0, LongWindedFlag, BQPV, 1, UCThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), CriticalDiff, FindAllFlagX, UBound(FSSRDP, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), UBound(WinScoresX, 1), ScoresX(0), WinScoresX(0), UBound(XDP, 1), XDP(0, 0), ChiValsX(0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChiX(0))
                    If GoOn = 1 Then
                        Call CXoverA(FindAllFlagX, 0, 0)
                    End If
                    
                    Seq1 = tSeq3
                    Seq2 = tSeq1
                    Seq3 = tSeq2
                    GoOn = FastRecCheckChim(MissingData(0, 0), XPD(0, 0), LXOS(0), 2, 0, LongWindedFlag, BQPV, 1, UCThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), CriticalDiff, FindAllFlagX, UBound(FSSRDP, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), UBound(WinScoresX, 1), ScoresX(0), WinScoresX(0), UBound(XDP, 1), XDP(0, 0), ChiValsX(0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChiX(0))
                    If GoOn = 1 Then
                        Call CXoverA(FindAllFlagX, 0, 0)
                    End If
                    
                    Seq1 = tSeq1
                    Seq2 = tSeq2
                    Seq3 = tSeq3
        
                    ChiE = Abs(GetTickCount)
                    ET = Abs(GetTickCount)
                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                        Form1.ProgressBar1.Value = (x) / (TripListLen) * 100
                        
                        Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS))
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(4) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 1
                        Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
                        Form1.SSPanel1.Caption = Str(x) & " of " & Str(TripListLen) & " triplets examined"
                        Call UpdateF2Prog
                        DoEvents 'covered by currentlyrunningflag
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running CHIMAERA scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        If AbortFlag = 1 Then
                            SSPanel1.Caption = ""
                            ProgressBar1.Value = 0
                            Call UpdateF2Prog
                            If CurWothwhilePos > x Then CurWothwhilePos = x
                            x = TripListLen
                        End If
                    End If
                    RunFlag = 1
                    If Worthwhilescan(x) = 0 Then
                        If Analysislist(2, x) < NextNo And x < TripListLen Then
                             If Analysislist(2, x) + 1 < Analysislist(2, x + 1) Then
                                Analysislist(2, x) = Analysislist(2, x) + 1
                                mmm = mmm + 1
                                x = x - 1
                            End If
                        End If
                    End If
                
                Next x
                UseCompress = 0
            
            End If
            
            
            If MCFlag = 2 Then
                CurrentCorrect = 4
                Call StepDown
            End If
            ChiS = Abs(ChiS)
            ChiE = Abs(GetTickCount)
            ET = Abs(GetTickCount)
            
            UpdateRecNums (SEventNumber)
            Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
            Form1.Frame17.Refresh
            TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
            ET = Abs(GetTickCount)
            MethodTime(4) = Abs(ET - ChiS)
            Erase ScoresX ' 0=s1,s2Matches etc
            Erase WinScoresX ' 0=s1,s2Matches etc
            Erase ChiValsX
            Erase SmoothChiX
            
            If AbortFlag = 1 Then
                AbortFlag = 0
                ABFl(4) = 1
            End If
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running CHIMAERA scan: 100% complete" & vbCrLf
            End If
        End If
        '1263210
        '1193315
        '1193315
        '941056
        '941056 FindSubSeqD 1:56
        '941056 FindSubSeqDP 2:19
        
        '923588
        '946477
        '946304'all blanking
        '946304 'noxdiffpos
        
        '925243 with fastreccheckchi gateway
        '883407
        '883407
        
        '*****************************************************************************************
        'Siscan not implemented here
        '*****************************************************************************************
        '623348 1051030 - new (with findall = 1)
        '448786 758494 - new (with findall = 0)
        '445371 755811 - old (with findall = 0)
        '446786 758494 - old properly modded for findall = 0)
        '623348 1051030 - old (with findall = 1)
        '448901 758703 - old way findall = 0
        '446901 758703
        If DoScans(0, 5) = 1 Then
            Command25.ToolTipText = "Stop exploratory SISCAN phase of the ananlysis"
            CurrentCorrect = 5
            Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte
            
            'Dimension horizontal randomisation array if necessary
            If SSOutlyerFlag = 0 Or x = x Then
                ReDim HRandTemplate(SSWinLen)
                ReDim TakenPos(SSWinLen)
            End If
            ReDim VRandTemplate(0, 0)
            GlobalMemoryStatus MemSit
            
            APhys = Abs(MemSit.dwTotalPhys)
            If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
            LmB = Len(StrainSeq(0))
            LmB = LmB * SSNumPerms
            LmB = LmB * 12
            If APhys < LmB Then
                OP = SSNumPerms
                SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
                pSSNumPerms = SSNumPerms
                    If CLine = "" Or CLine = " " Then
                        MsgBox ("You have specified that you would like to do a scan with " + Trim(Str(OP)) + " permutations. There is only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations. The SiScan results you get might be ureliable")
                    End If
            End If
            'Dimension vertical randomisation array
            ReDim VRandTemplate(Len(StrainSeq(0)), SSNumPerms)
            
            Dim DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte
            ReDim DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)
            
            Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
            
            Rnd (-SSRndSeed)
            LSeq = Len(StrainSeq(0))
            WinNum = CLng(LSeq / SSStep + 1)
            TotalSSRecombinants = 0
            Dim SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double
            ReDim SeqMap(Len(StrainSeq(0)))
            ReDim ZPScoreHolder(WinNum, 15)
            ReDim ZSScoreHolder(WinNum, 14)
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            'Make sure it will still run even in the event of a user messup
            If SSNumPerms2 = 0 Then
                SSNumPerms2 = 10
            End If
            Dim CorrectP As Double, TraceSub() As Long, oSeq As Long, PermSScores() As Long, PScoreHolder() As Long, SScoreHolder() As Long, PermPScores() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double
            ReDim SeqScore3(Len(StrainSeq(0))), MeanPScore(15), SDPScore(15)
            ReDim PermSScores(SSNumPerms, 15), PermPScores(SSNumPerms, 15), SScoreHolder(WinNum, 14), PScoreHolder(WinNum, 15)
            If SSOutlyerFlag = 2 Then
                Call GetOutie
                oSeq = Outie
            End If
            
            ReDim TraceSub(NextNo)
            For x = 0 To NextNo
                TraceSub(x) = x
            Next x
            
            
            If MCFlag = 0 Then
                CorrectP = LowestProb / MCCorrection
            Else
                CorrectP = LowestProb
            End If
            
            C = 0
            
            
            If x = 123456 Then 'do presecreen with a very lenient RDP scan
                
                
                CurrentCorrect = 0
                'rdp
                ReDim XDiffPos(Len(StrainSeq(0)) + 200)
                ReDim XPosDiff(Len(StrainSeq(0)) + 200)
                ReDim ValidSpacer(NextNo)
                ReDim SpacerSeqs(NextNo)
                ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
                ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
                ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
                'If UBound(CompressSeq, 2) <> NextNo Then
        
                
                'End If
                If ProbEstimateInFileFlag = 1 Then
                    ReDim ProbEstimate(171, 171, 50)
                    
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    'XX = App.Path
                    FF = FreeFile
                    Open "BinProbs" For Binary As #FF
                    Get #FF, , ProbEstimate()
                    Close #FF
                End If
                
                

                
                'TripListLen = 950000
                    
                ST = Abs(GetTickCount)
                
                
                
                
                
                'If x = x Then
                    
                    If MCFlag = 0 Then
                        UCThresh = (LowestProb / MCCorrection) * 100
                    Else
                        UCThresh = LowestProb * 100
                    End If
                    ReDim RedoL3(TripListLen)
                    Steps = 100000000 / Len(StrainSeq(0))
                    Steps = Steps '* (XOverWindowX / 30)
                    UseCompress = 1
                    'ZZZ = 0
                    'XX = NextNo
                    ggg = 0
                    
                    For Y = 0 To TripListLen Step Steps
                        If Y + Steps - 1 > TripListLen Then
                            EPX = TripListLen
                        Else
                            EPX = Y + Steps - 1
                        End If
                        '@'@
                        'NumRedos = AlistRDP3(Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        NumRedos = AlistRDP4(UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        
                        'If NumRedos > 0 Then
                        '@'@
                        
'                        Open "temp2.csv" For Output As #1
'                        For x = 0 To TripListLen
'
'                                Print #1, Str(Analysislist(0, x)) + "," + Str(Analysislist(1, x)) + "," + Str(Analysislist(2, x))
'
'                        Next x
'                        Close #1
'
                        XX = RedoListSize
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = Analysislist(0, x)
                                Seq2 = Analysislist(1, x)
                                Seq3 = Analysislist(2, x)
                                'ZZZ = ZZZ + 1
                                CurrentTripListNum = x
                                ''22,245,285
                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                ggg = ggg + 1 '855,535, 572, 559
                                
                                ET = Abs(GetTickCount)
                                If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                                    SSE = Abs(GetTickCount)
                                    SSS = Abs(SSS)
                                    ST = Abs(ST)
                                    If C < TripListLen + 1 Then
                                        Form1.ProgressBar1.Value = (C + 1) / (TripListLen + 1) * 100
                                    End If
                                    Form1.Label50(10).Caption = DoTimeII(Abs(SSE - SSS))
                                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                    UpdateRecNums (SEventNumber)
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(5) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                        ET = Abs(GetTickCount)
                                    End If
                                    LT = ET
                                    If Form1.ProgressBar1.Value > 0 Then
                                        Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(SSE - SSS) * (100 / Form1.ProgressBar1.Value) - (SSE - SSS)) & " remaining"
                                    End If
                                    Form1.SSPanel1.Caption = Str(C) & " of" & Str(TripListLen) & " triplets examined"
                                    Call UpdateF2Prog
                                    DoEvents 'covered by currentlyrunningflag
                                    If (CLine <> "" And CLine <> " ") Then
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole vbClearLine
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole "Running SIS scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                    End If
                                    If AbortFlag = 1 Then
                                        Form1.SSPanel1.Caption = ""
                                        Form1.ProgressBar1.Value = 0
                                        Call UpdateF2Prog
                                        If CurWothwhilePos > x Then CurWothwhilePos = x
                                        x = TripListLen
                                        Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
                                    End If
                                            
                                End If
                                
                            End If
                        Next x
                        
                    Next Y
                    'XX = ZZZ '262244
                    UseCompress = 0
            
            
            Else
                
                For x = 0 To TripListLen
                    Seq1 = Analysislist(0, x)
                    Seq2 = Analysislist(1, x)
                    Seq3 = Analysislist(2, x)
                    CurrentTripListNum = x
                    C = C + 1
                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                    ET = Abs(GetTickCount)
                                
                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                        SSE = Abs(GetTickCount)
                        SSS = Abs(SSS)
                        ST = Abs(ST)
                        If C < TripListLen + 1 Then
                            Form1.ProgressBar1.Value = (C + 1) / (TripListLen + 1) * 100
                        End If
                        Form1.Label50(10).Caption = DoTimeII(Abs(SSE - SSS))
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        UpdateRecNums (SEventNumber)
                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(5) = 1
                            oRec = oRecombNo(100)
                            Call UpdatePlotC
                            ET = Abs(GetTickCount)
                        End If
                        LT = ET
                        If Form1.ProgressBar1.Value > 0 Then
                            Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(SSE - SSS) * (100 / Form1.ProgressBar1.Value) - (SSE - SSS)) & " remaining"
                        End If
                        Form1.SSPanel1.Caption = Str(C) & " of" & Str(TripListLen) & " triplets examined"
                        Call UpdateF2Prog
                        DoEvents 'covered by currentlyrunningflag
                        If (CLine <> "" And CLine <> " ") Then
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole vbClearLine
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Running SIS scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                        End If
                        If AbortFlag = 1 Then
                            Form1.SSPanel1.Caption = ""
                            Form1.ProgressBar1.Value = 0
                            Call UpdateF2Prog
                            If CurWothwhilePos > x Then CurWothwhilePos = x
                            x = TripListLen
                            Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
                        End If
                                
                    End If
                    If AbortFlag = 0 Then
                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                    End If
                    If Worthwhilescan(x) = 0 Then
                        If Analysislist(2, x) < NextNo And x < TripListLen Then
                             If Analysislist(2, x) + 1 < Analysislist(2, x + 1) Then
                                Analysislist(2, x) = Analysislist(2, x) + 1
                                mmm = mmm + 1
                                x = x - 1
                            End If
                        End If
                    End If
                            
                    
                Next x
            
            End If
            
            
            SSOutlyerFlag = pSSOutlyerFlag
            ET = Abs(GetTickCount)
            SSE = Abs(GetTickCount)
            Form1.ProgressBar1.Value = 100
            Call UpdateF2Prog
            Form1.Label50(10).Caption = DoTimeII(Abs(SSE - SSS))
            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
            UpdateRecNums (SEventNumber)
            
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(5) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
                
            End If
            If MCFlag = 2 Then
                CurrentCorrect = 5
                Call StepDown
            End If
            UpdateRecNums (SEventNumber)
            If AbortFlag = 1 Then
                AbortFlag = 0
                ABFl(5) = 1
            End If
            ET = Abs(GetTickCount)
            MethodTime(5) = ET - Abs(SSS)
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running SIS scan: 100% complete" & vbCrLf
            End If
        End If
        
        
        
        
        
        If DoScans(0, 8) = 1 Then
            Command25.ToolTipText = "Stop exploratory 3SEQ phase of the scan"
            b = 0
            ChiS = Abs(GetTickCount)
            If XTableFlag = 0 Then
                Call Build3SeqTable
            End If
            ReDim XoverSeqNumTS(Len(StrainSeq(0)))
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            For x = 0 To TripListLen
                CurrentTripListNum = x
                LastY3 = -1
                Seq1 = Analysislist(0, x)
                Seq2 = Analysislist(1, x)
                Seq3 = Analysislist(2, x)
                tSeq1 = Seq1
                tSeq2 = Seq2
                tSeq3 = Seq3
                
                Call TSXOver(0)
                
                Seq1 = tSeq2
                Seq2 = tSeq3
                Seq3 = tSeq1
                
                Call TSXOver(0)
                
                Seq1 = tSeq3
                Seq2 = tSeq1
                Seq3 = tSeq2
                
                Call TSXOver(0)
                
                Seq1 = tSeq1
                Seq2 = tSeq2
                Seq3 = tSeq3
    
                ChiE = Abs(GetTickCount)
                ET = Abs(GetTickCount)
                If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                    Form1.ProgressBar1.Value = (x) / (TripListLen) * 100
                    
                    Form1.Label50(14).Caption = DoTimeII(Abs(ChiE - ChiS))
                    Form1.Label50(12).Caption = DoTimeII(Abs(ET) - Abs(ST))
                    UpdateRecNums (SEventNumber)
                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(4) = 1
                                            oRec = oRecombNo(100)
                                            Call UpdatePlotC
                                            ET = Abs(GetTickCount)
                                        End If
                    LT = ET
                    If Form1.ProgressBar1.Value > 0 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
                    End If
                    Form1.SSPanel1.Caption = Str(x) & " of " & Str(TripListLen) & " triplets examined"
                    Call UpdateF2Prog
                    DoEvents 'covered by currentlyrunningflag
                    If (CLine <> "" And CLine <> " ") Then
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole vbClearLine
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Running 3SEQ scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                    End If
                    If AbortFlag = 1 Then
                        SSPanel1.Caption = ""
                        ProgressBar1.Value = 0
                        Call UpdateF2Prog
                        If CurWothwhilePos > x Then CurWothwhilePos = x
                        x = TripListLen
                    End If
                End If
                RunFlag = 1
                If Worthwhilescan(x) = 0 Then
                    If Analysislist(2, x) < NextNo And x < TripListLen Then
                         If Analysislist(2, x) + 1 < Analysislist(2, x + 1) Then
                            Analysislist(2, x) = Analysislist(2, x) + 1
                            mmm = mmm + 1
                            x = x - 1
                        End If
                    End If
                End If
            Next x
            ChiS = Abs(ChiS)
             ChiE = Abs(GetTickCount)
             ET = Abs(GetTickCount)
             
             UpdateRecNums (SEventNumber)
             Form1.Label50(14).Caption = DoTimeII(Abs(ChiE - ChiS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
             Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
             Form1.Frame17.Refresh
             TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
             ET = Abs(GetTickCount)
             MethodTime(8) = Abs(ET - ChiS)
             
             
             If ShortOutFlag = 1 Then CurrentlyRunningFlag = 0: Exit Sub
            
             
             If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                 StartPlt(8) = 1
                 oRec = oRecombNo(100)
                 Call UpdatePlotC
                 
             End If
             If MCFlag = 2 Then
                 CurrentCorrect = 8
                 Call StepDown
             End If
             
             UpdateRecNums (SEventNumber)
             
             
             
             
             
             If AbortFlag = 1 Then
                 AbortFlag = 0
                 ABFl(8) = 1
             End If
             ET = Abs(GetTickCount)
             If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running 3SEQ scan: 100% complete" & vbCrLf
            End If
        End If
        
        
        
        If AbortFlag = 1 Then AbortFlag = 0
        'write analysislist to file
        
        If TripListLen > 1000000 Then
            ReDim Preserve Analysislist(2, TripListLen)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5AnalysisList" + UFTag For Binary As #FF
            Put #FF, , Analysislist
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            Erase Analysislist
        End If
'    ElseIf ExRecFlag = 0 Then
'        Dim NN As Variant
'        NN = NextNo + 1
'        NN = NN * NextNo
'        NN = NN * (NextNo - 1)
'        NN = NN / 6
'        ReDim Worthwhilescan(NN)
'
'
'
'        If DoScans(0, 0) = 1 Then
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running RDP scan: 0% complete"
'            End If
'
'            Command25.ToolTipText = "Stop exploratory RDP phase of the scan"
'
'            CurrentCorrect = 0
'
'            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'            If SpacerFlag > 0 Then
'                ReDim ValidSpacer(NextNo)
'                ReDim SpacerSeqs(NextNo)
'            Else
'                ReDim ValidSpacer(0), SpacerSeqs(0)
'            End If
'            ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
'            ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
'            ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
'            If ProbEstimateInFileFlag = 1 Then
'                ReDim ProbEstimate(171, 171, 50)
'
'                oDirX = CurDir
'                ChDrive App.Path
'                ChDir App.Path
'                'XX = App.Path
'                FF = FreeFile
'                Open "BinProbs" For Binary As #FF
'                Get #FF, , ProbEstimate()
'                Close #FF
'            End If
'            Form1.SSPanel1.Caption = "Detecting Recombination Using RDP"
'
'
'            If IndividualB > -1 Then
'
'                If NextNo > 1 Then
'
'                    If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'                    Seq1 = IndividualA
'                    Seq2 = IndividualB
'
'                    For Seq3 = 0 To NextNo
'
'                        If Seq3 <> Seq1 And Seq3 <> Seq2 Then
'
'                            Form1.Picture3.Refresh
'                            LastY3 = -1
'                            Picture3.MousePointer = 0
'                            b = b + 1
'
'                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'
'                        End If
'
'                    Next 'Seq3
'
'                    '
'                    ET = Abs(GetTickCount)
'                    If Abs(ET - LT) > 500 Then
'                                    Form1.ProgressBar1.Value = ((b + 1) / (MCCorrection + 1) * 100)
'                                    Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
'                                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                    UpdateRecNums (SEventNumber)
'                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                        StartPlt(0) = 1
'                                        oRec = oRecombNo(100)
'                                        Call UpdatePlotC
'                                        ET = Abs(GetTickCount)
'                                    End If
'                                    LT = ET
'                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
'                                    Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
'                                    Call UpdateF2Prog
'
'                                    If (CLine <> "" And CLine <> " ") Then
'                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                        WriteToConsole vbClearLine
'                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                        WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                    End If
'
'
'                                End If
'
'                    DoEvents 'covered by currentlyrunningflag
'                End If
'
'            ElseIf IndividualA > -1 Then
'
'                If NextNo > 1 Then
'
'                    If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                    If XOverWindowX <> CDbl(Form1.Text5.Text) Then XOverWindowX = CDbl(Text5.Text)
'
'                    Seq1 = IndividualA
'
'                    For Seq2 = 0 To NextNo
'
'                        If Seq2 <> Seq1 And MaskSeq(Seq2) <> 2 Then
'                            For Seq3 = Seq2 + 1 To NextNo
'
'                                If Seq3 <> Seq1 Then
'                                    'Emboss sequence beng compared
'                                    Form1.Picture3.Refresh
'                                    LastY3 = -1
'                                    Picture3.MousePointer = 0
'                                    b = b + 1
'
'                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'
'                                End If
'
'                            Next 'Seq3
'
'                            'Form1.ProgressBar1.Value = b / (ProgressAdjustNo + nextno + (nextno * (nextno + 1))) * 100
'                            ET = Abs(GetTickCount)
'
'
'
'
'                                If Abs(ET - LT) > 500 Then
'                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                    Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
'                                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                    UpdateRecNums (SEventNumber)
'                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                        StartPlt(0) = 1
'                                        oRec = oRecombNo(100)
'                                        Call UpdatePlotC
'                                        ET = Abs(GetTickCount)
'                                    End If
'                                    LT = ET
'                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
'                                    Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
'                                    Call UpdateF2Prog
'                                    If (CLine <> "" And CLine <> " ") Then
'                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                        WriteToConsole vbClearLine
'                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                        WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                    End If
'                                End If
'                        End If
'
'
'                        DoEvents 'covered by currentlyrunningflag
'                    Next 'Seq2
'
'                    'Form1.ProgressBar1.Value = B / MCCorrection * 100
'                End If
'
'            Else
'                ' Exit Sub
'                SSX = Abs(GetTickCount)
'                ZZZ = 0
'
'
'
'                If NextNo > 1 Then
'
'                    If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                    If XOverWindowX <> CDbl(Form1.Text5.Text) And Form1.Text5.Text <> "" Then XOverWindowX = CDbl(Text5.Text)
'
'                    If x = 12345 Then
'                        Call NewScan
''                    ElseIf X = 12345 Then
''                        Call NewScan
'
''                    ElseIf x = 12345 Then
''                        'binarray must be dimentioned so that it is EXACTLY divisible by 4
''
''                        ReDim BinArray(Len(StrainSeq(0)), Nextno)
''                        'ReDim BinArray2(Len(StrainSeq(0)), Nextno)
'''                        ReDim BinA2(Len(StrainSeq(0)), Nextno)
'''                        ReDim BinA3(Len(StrainSeq(0)), Nextno)
'''                        ReDim BinA4(Len(StrainSeq(0)), Nextno)
'''
'''                        ReDim XPD2(Len(StrainSeq(0)) + 200)
'''                        ReDim XPD3(Len(StrainSeq(0)) + 200)
'''                        ReDim XPD4(Len(StrainSeq(0)) + 200)
'''
'''                        ReDim XDP2(Len(StrainSeq(0)) + 200)
'''                        ReDim XDP3(Len(StrainSeq(0)) + 200)
'''                        ReDim XDP4(Len(StrainSeq(0)) + 200)
'''
'''                        ReDim XSN2(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
'''                        ReDim XSN3(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
'''                        ReDim XSN4(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
''
''
''
'''                        Dim XD As Single
'''                        XD = Len(StrainSeq(0)) + 1
'''                        Do
'''                            If (XD / 4) = Int(XD / 4) Then Exit Do
'''                            XD = XD + 1
'''                        Loop
'''                        XD = XD - 1
'''                        ReDim BinArray(XD, Nextno)
''                        StSt = abs(gettickcount)
''                        ExeCountA = 0
''
''                        For AAA = 1 To 1
''                        For Seq1 = 0 To Nextno
''
''                            If MaskSeq(Seq1) = 0 Then
''                                Dummy = MakeBinArrayP(Seq1, Len(StrainSeq(0)), Nextno, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0))
''
'''                                For X = 0 To Nextno
'''                                    For Y = 0 To Len(StrainSeq(0))
'''                                        BinA2(Y, X) = BinArray(Y, X)
'''                                        BinA3(Y, X) = BinArray(Y, X)
'''                                        BinA4(Y, X) = BinArray(Y, X)
'''                                    Next Y
'''                                Next X
''
'''                                Dummy = CopyCharArray(UBound(BinArray, 1), UBound(BinArray, 2), BinArray(0, 0), BinA2(0, 0))
'''                                Dummy = CopyCharArray(UBound(BinArray, 1), UBound(BinArray, 2), BinArray(0, 0), BinA3(0, 0))
'''                                Dummy = CopyCharArray(UBound(BinArray, 1), UBound(BinArray, 2), BinArray(0, 0), BinA4(0, 0))
''                                For Seq2 = Seq1 + 1 To Nextno
''
''                                    If MaskSeq(Seq2) = 0 Then
''                                        'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
''                                        For Seq3 = Seq2 + 1 To Nextno
''
''                                            If MaskSeq(Seq3) = 0 Then
''
''                                                LastY3 = -1
''                                                b = b + 1
''                                                ZZZ = ZZZ + 1
''                                                'aaa = Abs(GetTickCount)
''                                                'For X = 1 To 20                                            '
''                                                Call XOverIV(SeqNum(), Seq1, Seq2, Seq3, 0)
''                                                'Next X
''    '                                           bbb = Abs(GetTickCount)
''    '                                            ccc = bbb - aaa
''                                                'X = X '5.219, 5.109, 5.156
''                                                '9.688, 9.640, 9.626
''                                                '10.750 with reduction
''                                                '8.375 with just parallel for
''
''
''                                                '2.937, 2.844, 2.812 with probcalcp2
''                                                '2.828, 2812, 2.781 without probcalcp2
''                                                '2.860, 2.813, 2828 old findnext
''                                                '2.953 2.828, 2.828 old findsubseq
''                                                '2.704,2.656, 2.656 findsubseqp
''    '                                            '2.672, 2.578, 2.625 old xohomology
''                                                '2.844, 2.734, 2.750 new xohomologyp
''
''
''
''
''                                                '4.828, 4.750, 4.766
''                                                '2.968 2.922 old calprobp
''                                                '6.641
''                                                '6.812 flush and firstprivate
''                                                '7.281 using reduction
''                                                '7.703 with z in private and reduction
''                                                '6.625 no z in private:6.625 z in private
''                                                '5.281 omp parallel for rather than separated
''                                                '5.953 withe probability reduction
''                                                '5.265 with or without z n privates
''                                                If AbortFlag = 1 And Nextno * Len(StrainSeq(0)) > 50000 Then
''                                                    DoEvents 'covered by currentlyrunningflag
''                                                    SSPanel1.Caption = ""
''                                                    ProgressBar1.Value = 0
''                                                    Call UpdateF2Prog
''                                                    x = GetNumInList(Seq1, Seq2, Seq3)
''                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
''
''                                                    Seq1 = Nextno
''                                                    Seq2 = Nextno
''                                                    Seq3 = Nextno
''                                                End If
''
''                                            End If
''
''                                        Next 'Seq3
''
''                                        DoEvents 'covered by currentlyrunningflag
''
''                                        If AbortFlag = 1 Then
''                                            SSPanel1.Caption = ""
''                                            ProgressBar1.Value = 0
''                                            Call UpdateF2Prog
''                                            x = GetNumInList(Seq1, Seq2, Seq3)
''                                            If CurWothwhilePos > x Then CurWothwhilePos = x
''                                            Seq1 = Nextno: Seq2 = Nextno: Seq3 = Nextno
''                                        End If
''
''                                        ET = Abs(GetTickCount)
''
''
''                                    End If
''
''
''                                    ET = Abs(ET)
''                                    If Abs(ET - LT) > 500 Then
''                                        If (b + 1) <= (MCCorrection + 1) Then
''                                            Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
''                                        End If
''                                        Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
''                                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
''                                        UpdateRecNums (SEventNumber)
''                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
''                                            StartPlt(0) = 1
''                                            oRec = oRecombNo(100)
''                                            Call UpdatePlotC
''                                            ET = Abs(GetTickCount)
''                                        End If
''                                        LT = ET
''                                        If Form1.ProgressBar1.Value > 0 Then
''                                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
''                                            Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
''                                        End If
''                                        If (CLine <> "" And CLine <> " ") Then
''                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                                            GetConsoleScreenBufferInfo hOutput, scrbuf
''                                            WriteToConsole vbClearLine
''                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                                            GetConsoleScreenBufferInfo hOutput, scrbuf
''                                            WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
''                                        End If
''                                        Call UpdateF2Prog
''
''
''
''                                    End If
''
''
''                                Next 'Seq2
''
''                            End If
''
''                        Next 'Seq1
''                        Next AAA
''                        ETS = abs(gettickcount)
''                        ttt = ETS - StSt '4.766
''                        '0.094
''
''
''                        '2.953, 2.875, 2.860, 2.849 exit after findsubseqP4
''                        '8.906, 8.907, 8.968
''                        '8.938, 8.860, 8.750, 8.687 'full hiv75
''                        '3.296 after startposx
'
'                    Else
'                        UseCompress = 1
'                        Call MakeScanCompressArrays(NextNo, SeqNum())
'                        StSt = Abs(GetTickCount)
'                        Dim tMaskseq() As Byte, MaxChunkSize As Long, LeftToDo As Variant, Seq1To As Long, DP() As Byte, DP2() As Byte, RedoL() As Long, RedoL2() As Long
'                        ReDim tMaskseq(NextNo), DP(0, 0), DP2(0, 0)
'                        For x = 0 To NextNo
'                            tMaskseq(x) = MaskSeq(x)
'                        Next x
'
'                        ReDim RedoL(2, MCCorrection)
'                        MaxChunkSize = 50000
'                        Seq1 = 0
'                        b = 0
'                        Do While Seq1 <= NextNo
'                            LeftToDo = NextNo - Seq1 + 1
'                            LeftToDo = (LeftToDo * (LeftToDo - 1)) / 2
'                            Seq1To = MaxChunkSize / LeftToDo
'                            If Seq1To < 4 Then Seq1To = 4
'                            Seq1To = Seq1 + Seq1To
'                            If Seq1To > NextNo Then Seq1To = NextNo
'                            For x = Seq1 To Seq1To
'                                If MaskSeq(x) = 0 Then
'                                    b = b + (NextNo - x) * (NextNo - x - 1) / 2
'                                End If
'                            Next x
'                            'Seq1To = NextNo
'                            NumRedos = PrimaryRDP3(Seq1, 2, MinSeqSize, Seq1To, NextNo, UCTHresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDIffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'                            If NumRedos > 0 Then
'                                If x = x Then 'reorder redos
'                                    'sort seq 1
'                                    SSS = Abs(GetTickCount)
'                                    Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
'                                    ReDim S1Count(NextNo), SPS1(NextNo)
'                                    For x = 1 To NumRedos
'                                        CurS1 = RedoL(0, x)
'                                        S1Count(CurS1) = S1Count(CurS1) + 1
'                                    Next x
'                                    SPS1(0) = S1Count(0)
'                                    For x = 1 To NextNo
'                                        SPS1(x) = SPS1(x - 1) + S1Count(x)
'                                    Next x
'                                    ReDim RedoL2(2, NumRedos)
'                                    Dim L2Pos As Long
'                                    For x = NumRedos To 0 Step -1
'                                        L2Pos = SPS1(RedoL(0, x))
'                                        RedoL2(0, L2Pos) = RedoL(0, x)
'                                        RedoL2(1, L2Pos) = RedoL(1, x)
'                                        RedoL2(2, L2Pos) = RedoL(2, x)
'                                        SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
'                                    Next x
'                '                    XX = SPS1(4)
'                '                    XX = S1Count(4)
'                '                    SSS = abs(gettickcount)
'                '                    For x = 0 To NumRedos
'                '                        For y = x + 1 To NumRedos
'                '                            If RedoL2(0, x) > RedoL2(0, y) Then
'                '                                Call SwapSort(RedoL2(), x, y)
'                '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
'                '                                If RedoL2(1, x) > RedoL2(1, y) Then
'                '                                    Call SwapSort(RedoL2(), x, y)
'                '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
'                '                                    If RedoL2(2, x) > RedoL2(2, y) Then
'                '                                        Call SwapSort(RedoL2(), x, y)
'                '                                    End If
'                '                                End If
'                '                            End If
'                '                        Next y
'                '                    Next x
'                                End If
'                                For x = 1 To NumRedos
'
'                                  Seq1 = RedoL2(0, x)
'                                  Seq2 = RedoL2(1, x)
'                                  Seq3 = RedoL2(2, x)
'                                  ''22,245,285
'                                  Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                Next x
'                            End If
'                            Seq1 = Seq1To + 1
'                            ET = Abs(GetTickCount)
'                            ET = Abs(ET)
'                            If Abs(ET - LT) > 500 Then
'                                If (b + 1) <= (MCCorrection + 1) Then
'                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                End If
'                                Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
'                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                UpdateRecNums (SEventNumber)
'                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                    StartPlt(0) = 1
'                                    oRec = oRecombNo(100)
'                                    Call UpdatePlotC
'                                    ET = Abs(GetTickCount)
'                                End If
'                                LT = ET
'                                If Form1.ProgressBar1.Value > 0 Then
'                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
'                                    Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
'                                End If
'                                If (CLine <> "" And CLine <> " ") Then
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole vbClearLine
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                End If
'                                Call UpdateF2Prog
'                            End If
'                         Loop
'                         UseCompress = 0
''                        For AAA = 1 To 1
''                        For Seq1 = 0 To NextNo
''
''                            If MaskSeq(Seq1) = 0 Then
''
''                                For Seq2 = Seq1 + 1 To NextNo
''
''                                    If MaskSeq(Seq2) = 0 Then
''
''                                        For Seq3 = Seq2 + 1 To NextNo
''
''                                            If MaskSeq(Seq3) = 0 Then
''
''                                                LastY3 = -1
''                                                b = b + 1
''                                                ZZZ = ZZZ + 1
''                                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
''                                                If AbortFlag = 1 And NextNo * Len(StrainSeq(0)) > 50000 Then
''                                                    DoEvents 'covered by currentlyrunningflag
''                                                    SSPanel1.Caption = ""
''                                                    ProgressBar1.Value = 0
''                                                    Call UpdateF2Prog
''                                                    x = GetNumInList(Seq1, Seq2, Seq3)
''                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
''                                                    Seq1 = NextNo
''                                                    Seq2 = NextNo
''                                                    Seq3 = NextNo
''                                                End If
''
''                                            End If
''
''                                        Next 'Seq3
''
''                                        DoEvents 'covered by currentlyrunningflag
''
''                                        If AbortFlag = 1 Then
''                                            SSPanel1.Caption = ""
''                                            ProgressBar1.Value = 0
''                                            Call UpdateF2Prog
''                                            x = GetNumInList(Seq1, Seq2, Seq3)
''                                            If CurWothwhilePos > x Then CurWothwhilePos = x
''                                            Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
''                                        End If
''
''                                        ET = Abs(GetTickCount)
''
''
''                                    End If
''
''
''                                    ET = Abs(ET)
''                                    If Abs(ET - LT) > 500 Then
''                                        If (b + 1) <= (MCCorrection + 1) Then
''                                            Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
''                                        End If
''                                        Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
''                                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
''                                        UpdateRecNums (SEventNumber)
''                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
''                                            StartPlt(0) = 1
''                                            oRec = oRecombNo(100)
''                                            Call UpdatePlotC
''                                            ET = Abs(GetTickCount)
''                                        End If
''                                        LT = ET
''                                        If Form1.ProgressBar1.Value > 0 Then
''                                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
''                                            Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
''                                        End If
''                                        If (CLine <> "" And CLine <> " ") Then
''                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                                            GetConsoleScreenBufferInfo hOutput, scrbuf
''                                            WriteToConsole vbClearLine
''                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                                            GetConsoleScreenBufferInfo hOutput, scrbuf
''                                            WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
''                                        End If
''                                        Call UpdateF2Prog
''                                    End If
''
''
''                                Next 'Seq2
''
''                            End If
''
''                        Next 'Seq1
''                         Next AAA
'                        ETS = Abs(GetTickCount)
'                        ttt = ETS - StSt '2.469'4.844
'                        '9.484, 9.500, 9.500
'                        '3.375,3.328,3.391
'                        '0.063 pre findsubseq
'                        '3.359, 3.344,3.313 post findsubseq
'                        '9.344 9.328 9.250, full HIV75
'                        x = x
'                    End If
'
'                End If
'
'            End If
'
'
'            '87.285
'
'            Form1.ProgressBar1.Value = 0
'            Call UpdateF2Prog
'            LastY3 = -1
'            Picture3.MousePointer = 0
'            Picture3.ForeColor = 0
'
'            If MCFlag = 2 Then
'                CurrentCorrect = 0
'                Call StepDown
'            End If
'            If LongWindedFlag = 0 Then
'                'Clean up used arrays
'
'            End If
'            ET = Abs(GetTickCount)
'            MethodTime(0) = Abs(ET - ST)
'
'
'            Erase ValidSpacer
'            Erase SpacerSeqs
'            Erase XoverSeqNum
'            Erase XoverSeqNumW
'            If ProbEstimateInFileFlag = 1 Then
'                Erase ProbEstimate
'            End If
'            Erase XOverHomologyNum
'
'
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbCrLf
'            End If
'
'        End If
'        ET = Abs(ET)
'        ST = Abs(ST)
''        EEE = Abs(GetTickCount)
''        ttt = EEE - SSS
'        '5969,5953
'        Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
'        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'        UpdateRecNums (SEventNumber)
'
'
'        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                StartPlt(0) = 1
'                oRec = oRecombNo(100)
'                Call UpdatePlotC
'                ET = Abs(GetTickCount)
'        End If
'        If AbortFlag = 1 Then
'            AbortFlag = 0
'            ABFl(0) = 1
'        End If
'
'        ET = Abs(GetTickCount)
'
'        If DoScans(0, 0) = 1 Then
'
'            Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'            Form1.Label50(0).Refresh
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'            Form1.Label50(12).Refresh
'            TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
'        End If
'
'        SSPanel13.Caption = ""
'        DoEvents 'covered by currentlyrunningflag
'        Form1.WindowState = Form1.WindowState
'        SSX = Abs(GetTickCount)
'        If DoScans(0, 1) = 1 Then
'            Command25.ToolTipText = "Stop exploratory GENECONV phase of the scan"
'            CurrentCorrect = 1
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running GENECONV scan: 0% complete"
'            End If
'            b = 0
'
'            oRecombNo(1) = 0
'            If GCtripletflag = 1 Then
'                    'On Error GoTo SkipGeneconv
'                    ReDim SubSeq(Len(StrainSeq(0)), 6)
'                    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'                    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'                    ReDim FragMaxScore(GCDimSize, 5)
'                    ReDim MaxScorePos(GCDimSize, 5)
'                    ReDim PVals(GCDimSize, 5)
'                    ReDim FragSt(GCDimSize, 6)
'                    ReDim FragEn(GCDimSize, 6)
'                    ReDim FragScore(GCDimSize, 6)
'                    ReDim DeleteArray(Len(StrainSeq(0)) + 1)
'                    'On Error GoTo 0
'                    GCST = Abs(GetTickCount)
'                    If IndividualB > -1 Then
'                        Seq1 = IndividualA
'                                Seq2 = IndividualB
'                                        For Seq3 = 0 To NextNo
'
'                                            If Seq3 <> Seq1 And Seq3 <> Seq2 And MaskSeq(Seq3) <= 1 Then
'
'                                                LastY3 = -1
'
'                                                Call GCXoverD(0)
'
'
'                                                b = b + 1
'
'                                                ET = Abs(GetTickCount)
'
'                                                If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'
'                                                    Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
'                                                    Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                                                    UpdateRecNums (SEventNumber)
'                                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                        StartPlt(1) = 1
'                                                        oRec = oRecombNo(100)
'                                                        Call UpdatePlotC
'                                                        ET = Abs(GetTickCount)
'                                                    End If
'                                                    LT = ET
'                                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (ET - GCST)) & " remaining"
'                                                    Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                    Call UpdateF2Prog
'                                                    DoEvents 'covered by currentlyrunningflag
'                                                    If (CLine <> "" And CLine <> " ") Then
'                                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                        WriteToConsole vbClearLine
'                                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                        WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                    End If
'                                                    If AbortFlag = 1 Then
'                                                        SSPanel1.Caption = ""
'                                                        ProgressBar1.Value = 0
'                                                        Call UpdateF2Prog
'                                                        x = GetNumInList(Seq1, Seq2, Seq3)
'                                                        If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                        Seq1 = NextNo
'                                                        Seq2 = NextNo
'                                                        Seq3 = NextNo
'                                                    End If
'                                                End If
'
'
'                                            End If
'
'                                            RunFlag = 1
'                                        Next 'Seq3
'                    ElseIf IndividualA > -1 Then
'                        Seq1 = IndividualA
'
'                                For Seq2 = 0 To NextNo
'
'                                    If Seq2 <> Seq1 And MaskSeq(Seq2) <= 1 Then
'                                        LastY3 = -1
'
'                                        For Seq3 = Seq2 + 1 To NextNo
'
'                                            If Seq3 <> Seq1 And MaskSeq(Seq3) <= 1 Then
'
'                                                LastY3 = -1
'
'                                                Call GCXoverD(0)
'
'
'                                                b = b + 1
'                                                ET = Abs(GetTickCount)
'
'
'                                                ET = Abs(GetTickCount)
'
'                                                If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'
'                                                    Form1.Label50(2).Caption = DoTimeII(Abs(Abs(ET) - Abs(GCST)))
'                                                    Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET) - Abs(ST)))
'                                                    UpdateRecNums (SEventNumber)
'                                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                        StartPlt(1) = 1
'                                                        oRec = oRecombNo(100)
'                                                        Call UpdatePlotC
'                                                        ET = Abs(GetTickCount)
'                                                    End If
'                                                    LT = ET
'                                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (ET - GCST)) & " remaining"
'                                                    Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                    Call UpdateF2Prog
'                                                    DoEvents 'covered by currentlyrunningflag
'
'                                                    If AbortFlag = 1 Then
'                                                        SSPanel1.Caption = ""
'                                                        ProgressBar1.Value = 0
'                                                        Call UpdateF2Prog
'                                                        x = GetNumInList(Seq1, Seq2, Seq3)
'                                                        If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                        Seq1 = NextNo
'                                                        Seq2 = NextNo
'                                                        Seq3 = NextNo
'                                                    End If
'                                                    If (CLine <> "" And CLine <> " ") Then
'                                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                        WriteToConsole vbClearLine
'                                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                        GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                        WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                    End If
'                                                End If
'
'
'                                            End If
'
'                                            RunFlag = 1
'                                        Next 'Seq3
'
'                                    End If
'
'                                Next 'Seq2
'
'                    Else
'                        If GCDimSize < 50000 Then
''                            SSSS = abs(gettickcount)
'                            MaxRequiredFraglen = 0
'                            Call NewScanGC2
''                            GCDimSize = MaxRequiredFraglen + 10
''                            eeee = abs(gettickcount)
''                            tttt = eeee - SSSS '10.594 eith binarray parallelized inner loop
'                            '10.235 binarrayp parallelized outer loop
'                            '12.328 no binarray parallellization
'                            '9.219, 9.359, 9.250 with makebinarray in the correct spot
'                            x = x
'                        Else
'
'                            'SSSS = abs(gettickcount)
'                            For Seq1 = 0 To NextNo
'
'                                If MaskSeq(Seq1) = 0 Then
'
'                                    For Seq2 = Seq1 + 1 To NextNo
'
'                                        If MaskSeq(Seq2) = 0 Then
'                                            LastY3 = -1
'
'                                            For Seq3 = Seq2 + 1 To NextNo
'
'                                                If MaskSeq(Seq3) = 0 Then
'
'                                                    LastY3 = -1
'    '                                                aaa = Abs(GetTickCount)
'    '                                                For ZZ = 1 To 10
'                                                    Call GCXoverD(0)
'    '                                                Next ZZ
'    '                                                bbb = Abs(GetTickCount)
'    '                                                ttt = bbb - aaa 'getfrags: 4.563,4.453,4.469
'                                                    x = x
'                                                                    'getfragsp no parallel:4.391,4.281, 4.297
'                                                                    'getmaxfragscore:4.375,4.375, 4.328
'                                                                    'getmaxfragscoreP no parallel:3.938,3.859, 3.860
'                                                                    'FindSubSeqGCA:3.875,3.860,3.859
'                                                                    'FindSubSeqGCAP no parallel:3.812,3.750, 3.750
'                                                                    'gcgethipval:3.766,3.672,3.687
'                                                                    'gcgethipvalp novector:3.735,3.687,3.703
'                                                                    'gcgethipvalp parallel:3.719,3.687,3.672
'                                                                    'getfragsp 3.828, 3.703, 3.703 with unparallel array void
'                                                                    '4.000, 3.968, 3.922
'
'                                                                    '4.234
'                                                                    '4.203 with flush
'                                                                    '3.875 unparallelised getmaxfrag
'                                                                    'parallelised getmaxfrag 3.672,3.625, 3.625
'                                                    b = b + 1
'
'                                                    ET = Abs(GetTickCount)
'
'
'
'                                                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                        If (b + 1) < (MCCorrection + 1) Then
'                                                            Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                                        End If
'                                                        ET = Abs(ET)
'                                                        ST = Abs(ST)
'                                                        GCST = Abs(GCST)
'                                                        Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
'                                                        Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                                                        UpdateRecNums (SEventNumber)
'                                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                            StartPlt(1) = 1
'                                                            oRec = oRecombNo(100)
'                                                            Call UpdatePlotC
'                                                            ET = Abs(GetTickCount)
'                                                        End If
'                                                        LT = ET
'                                                        If Form1.ProgressBar1.Value > 0 Then
'                                                            Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (ET - GCST)) & " remaining"
'                                                        End If
'                                                        Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                        Call UpdateF2Prog
'                                                        DoEvents 'covered by currentlyrunningflag
'
'                                                        If AbortFlag = 1 Then
'                                                            SSPanel1.Caption = ""
'                                                            ProgressBar1.Value = 0
'                                                            Call UpdateF2Prog
'                                                            x = GetNumInList(Seq1, Seq2, Seq3)
'                                                            If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                            Seq1 = NextNo
'                                                            Seq2 = NextNo
'                                                            Seq3 = NextNo
'                                                        End If
'                                                        If (CLine <> "" And CLine <> " ") Then
'                                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                            GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                            WriteToConsole vbClearLine
'                                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                            GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                            WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                        End If
'                                                    End If
'
'
'                                                End If
'
'                                                RunFlag = 1
'                                            Next 'Seq3
'
'                                        End If
'
'                                    Next 'Seq2
'
'                                End If
'
'                            Next 'Seq1
'                        End If
'                    End If
'                    ET = Abs(GetTickCount)
''                    eeee = abs(gettickcount)
''                    tttt = eeee - SSSS '9.218,9.391,9.109 total - 9.688
''
'                    '9.953:9.703
'                    '10.671-old
'                    '10.640-new
'                    '
'                    '9.906, 10.015
'                    '9.641,9.672
'                    '9.656, 9.594, 9.578
'                    '9.609,9.625
'
'                    '9.375
'
'                    '9.234
'                    ' 7.438 with parallelised findsubseqgca and indelflag = 0
'
'
'                    '8.140,7.84, 7.640, 7.594, 7.625 with parallelised findsubseqgca and indelflag = 1
'                    '7.734, 7.406
'                    '8.828 8.641 without parallelized getfragsp2
'                    '7.359, 7.094
'                    '5.625,5.703
'
'                    '4.422
'
'                    '2.735 after parallellized bit
'                    '3.984, 4.079 after getmaxfragscore
'                    '4.219 after calcmaxp
'                    '4.954, 4.313 after gccalcpval
'                    '4.250, 4.109, 4.203, 4.219
'                    If Abs(ET - LT) > 500 Then
'                        LT = ET
'                        Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                        Call UpdateF2Prog
'                        Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
'                        Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                        UpdateRecNums (SEventNumber)
'                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                            StartPlt(1) = 1
'                            oRec = oRecombNo(100)
'                            Call UpdatePlotC
'                            ET = Abs(GetTickCount)
'                        End If
'                    End If
'
''            Else
''                Call GCXOver
''                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
''                    oRec = oRecombNo(100)
''                    StartPlt(1) = 1
''                    Call UpdatePlotC
''                End If
''
''                Form1.ProgressBar1.Value = 100
''                Call UpdateF2Prog
'            End If
'
'
'
'
'            If MCFlag = 2 Then
'                CurrentCorrect = 1
'                Call StepDown
'            End If
'            If (b + 1) <= (MCCorrection + 1) Then
'                Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                Call UpdateF2Prog
'            End If
'            ET = Abs(ET)
'            GCST = Abs(GCST)
'            Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'            UpdateRecNums (SEventNumber)
'            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                StartPlt(1) = 1
'                oRec = oRecombNo(100)
'                Call UpdatePlotC
'            End If
'            If AbortFlag = 1 Then
'                SSPanel1.Caption = ""
'                ProgressBar1.Value = 0
'                Call UpdateF2Prog
'                AbortFlag = 0
'                ABFl(1) = 1
'
'
'            End If
'            ET = Abs(GetTickCount)
'            GCST = Abs(GCST)
'            MethodTime(1) = Abs(ET - GCST)
'SkipGeneconv:
'            Erase SubSeq
'            Erase FragMaxScore
'            Erase MaxScorePos
'            Erase PVals
'            Erase FragSt
'            Erase DeleteArray
'            Erase FragEn
'            Erase FragScore
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running GENECONV scan: 100% complete" & vbCrLf
'            End If
'        End If
''        eex = Abs(GetTickCount)
''        ttt = eex - SSX
'        '12.818,12.728
'        '11.937
'        '9.375,9359,9407 - desktop (1067)
'        '6.453,6.500,6.344 - setting min ts = 0
'        '6.125 - removing minfrag refernces
'
'
'        b = 0
'        SSS = Abs(GetTickCount)
        
'
'        SSPanel1.Caption = ""
''        EEE = Abs(GetTickCount)
''        ttt = EEE - SSS
'        '917.265 (228)
'        '131.937 (228) - c++ findaughter
'        '115.453 (228)
'        '106.266 (228)
'        '96.781(228)
'        '95.765(228)
'
'        '150.547 (228)
'        '140.546 (228)
'        '133.625 (228)
'        '43
'        '38
'        'XX = BSStepWin
'        If ErrorFlag = 1 Then
'            ErrorFlag = 0
'            Form1.Label50(5).Caption = "Undetermined"
'        End If
'
'
'        RunFlag = 1
'        SSPanel13.Caption = ""
'        DoEvents 'covered by currentlyrunningflag
'        'Picture7.AutoRedraw = False
'        'Picture7.ClipControls = False
'        'Picture10.AutoRedraw = False
''    SS = Abs(GetTickCount)
'        If DoScans(0, 3) = 1 Then
'            Command25.ToolTipText = "Stop exploratory MAXCHI phase of the scan"
'            CurrentCorrect = 3
'            SSPanel1.Caption = "Executing MaxChi"
'            MCS = Abs(GetTickCount)
'            oRecombNo(3) = 0
'            Form1.ProgressBar1 = 0
'            Call UpdateF2Prog
'            b = 0
'
'
'            If DebuggingFlag < 2 Then On Error Resume Next
'
'            ActualDir = CurDir
'            ChDir App.Path
'            ChDrive App.Path
'            On Error GoTo 0
'
'            'Close #1
'            Picture3.AutoRedraw = True
'            If UBound(CompressSeq, 2) <> NextNo Then
'                Call MakeScanCompressArrays(NextNo, SeqNum())
'            End If
'            If MCTripletFlag = 0 Then
'                HWindowWidth = CLng(MCWinSize / 2)
'                pHWindowWidth = HWindowWidth
'                lHWindowWidth = HWindowWidth
'                ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
'                ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
'                ReDim Chivals(Len(StrainSeq(0)), 2)
'                ReDim SmoothChi(Len(StrainSeq(0)), 2)
'                ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'                ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'                ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
'
'                If MCProportionFlag = 0 Then
'                    Call GetCriticalDiff(0)
'                    If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
'                        MCWinSize = HWindowWidth * 2
'                    End If
'                End If
'                If IndividualB > -1 Then
'
'                    If NextNo > 1 Then
'
'                        If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                        If XOverWindowX <> CDbl(Form1.Text5.Text) Then XOverWindowX = CDbl(Text5.Text)
'
'
'                        Seq1 = IndividualA
'                        Seq2 = IndividualB
'
'                        For Seq3 = 0 To NextNo
'
'                            If Seq3 <> Seq1 And Seq3 <> Seq2 Then
'                                'Emboss sequence beng compared
'                                'Form1.Picture3.Refresh
'                                LastY3 = -1
'                                Picture3.MousePointer = 0
'                                b = b + 1
'                                MCMaxP = LowestProb
'
'                                Call MCXoverF(0, 0, 0)
'
'
'                                            MCE = Abs(GetTickCount)
'                                            ET = Abs(GetTickCount)
'
'                                            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'
'                                                Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS))
'                                                Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                                                UpdateRecNums (SEventNumber)
'                                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                    StartPlt(3) = 1
'                                                    oRec = oRecombNo(100)
'                                                    Call UpdatePlotC
'                                                    ET = Abs(GetTickCount)
'                                                End If
'                                                LT = ET
'                                                Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(MCE - MCS)) * (100 / Form1.ProgressBar1.Value) - Abs(MCE - MCS)) & " remaining"
'                                                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                Call UpdateF2Prog
'                                                DoEvents 'covered by currentlyrunningflag
'
'                                                If AbortFlag = 1 Then
'                                                    SSPanel1.Caption = ""
'                                                    ProgressBar1.Value = 0
'                                                    Call UpdateF2Prog
'                                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                    Seq1 = NextNo
'                                                    Seq2 = NextNo
'                                                    Seq3 = NextNo
'                                                End If
'                                                If (CLine <> "" And CLine <> " ") Then
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole vbClearLine
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                End If
'                                            End If
'
'                            End If
'
'                        Next 'Seq3
'
'                        '
'                    End If
'
'                ElseIf IndividualA > -1 Then
'
'                    If NextNo > 1 Then
'
'                        If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                        If XOverWindowX <> CDbl(Form1.Text5.Text) Then XOverWindowX = CDbl(Text5.Text)
'
'                        Seq1 = IndividualA
'
'                        For Seq2 = 0 To NextNo
'
'                            If Seq2 <> Seq1 And MaskSeq(Seq2) <> 2 Then
'
'                                For Seq3 = Seq2 + 1 To NextNo
'
'                                    If Seq3 <> Seq1 Then
'                                        'Emboss sequence beng compared
'                                        Form1.Picture3.Refresh
'                                        LastY3 = -1
'                                        Picture3.MousePointer = 0
'                                        b = b + 1
'                                        MCMaxP = LowestProb
'
'                                        Call MCXoverF(0, 0, 0)
'
'                                        MCE = Abs(GetTickCount)
'                                            ET = Abs(GetTickCount)
'
'                                            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'
'                                                Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS))
'                                                Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                                                UpdateRecNums (SEventNumber)
'                                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                    StartPlt(3) = 1
'                                                    oRec = oRecombNo(100)
'                                                    Call UpdatePlotC
'                                                    ET = Abs(GetTickCount)
'                                                End If
'                                                LT = ET
'                                                Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(MCE - MCS)) * (100 / Form1.ProgressBar1.Value) - Abs(MCE - MCS)) & " remaining"
'                                                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                Call UpdateF2Prog
'                                                DoEvents 'covered by currentlyrunningflag
'
'                                                If AbortFlag = 1 Then
'                                                    SSPanel1.Caption = ""
'                                                    ProgressBar1.Value = 0
'                                                    Call UpdateF2Prog
'                                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                    Seq1 = NextNo
'                                                    Seq2 = NextNo
'                                                    Seq3 = NextNo
'                                                End If
'                                                If (CLine <> "" And CLine <> " ") Then
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole vbClearLine
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                End If
'                                            End If
'
'                                        'DoEvents
'
'
'
'                                    End If
'
'                                Next 'Seq3
'
'                            End If
'
'                            Form1.ProgressBar1.Value = (b / MCCorrection) * 100
'                            Call UpdateF2Prog
'                        Next 'Seq2
'
'                        'Form1.ProgressBar1.Value = B / MCCorrection * 100
'                    End If
'
'                Else
'
'                    For Seq1 = 0 To NextNo
'
'                        If MaskSeq(Seq1) = 0 Then
'
'                            For Seq2 = Seq1 + 1 To NextNo
'
'                                If MaskSeq(Seq2) = 0 Then
'                                    LastY3 = -1
'
'                                    For Seq3 = Seq2 + 1 To NextNo
'
'                                        If MaskSeq(Seq3) = 0 Then
'                                            MCMaxP = LowestProb
'                                            LastY3 = -1
''                                            aaa = Abs(GetTickCount)
'                                            'For zzz = 1 To 10
'                                            Call MCXoverF(0, 0, 0)
'                                            'Next zzz
''                                            bbb = Abs(GetTickCount)
''                                            ccc = bbb - aaa
'
'
'                                            '6.256, 6.240, 6.255
'                                            '6,193, 6.193, 6.193'unrolling loop in calcchivals
'                                            '5.133, 5.116, 5.148'using integers instead of doubles in calcchivals
'                                            'XX = Seq1
'                                           'calcchivals 2.359, 2.328, 2.312
'                                            'calcchivalsp 2.266, 2.281, 2.281
'                                            'growmchiwin 2.281, 2.282, 2.281
'                                            'growmchiwinp 2.203, 2.203, 2.219
'                                            b = b + 1
'                                            MCE = Abs(GetTickCount)
'                                            ET = Abs(GetTickCount)
'
'                                            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                If (b + 1) <= (MCCorrection + 1) Then
'                                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                                End If
'                                                ET = Abs(ET)
'                                                ST = Abs(ST)
'                                                MCS = Abs(MCS)
'                                                Form1.Label50(6).Caption = DoTimeII(Abs(Abs(MCE) - Abs(MCS)))
'                                                Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
'                                                UpdateRecNums (SEventNumber)
'                                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                    StartPlt(3) = 1
'                                                    oRec = oRecombNo(100)
'                                                    Call UpdatePlotC
'                                                    ET = Abs(GetTickCount)
'                                                End If
'                                                LT = ET
'                                                If Form1.ProgressBar1.Value > 0 Then
'                                                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(MCE - MCS)) * (100 / Form1.ProgressBar1.Value) - (MCE - MCS)) & " remaining"
'                                                    Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                End If
'                                                Call UpdateF2Prog
'                                                DoEvents 'covered by currentlyrunningflag
'
'                                                If AbortFlag = 1 Then
'                                                    SSPanel1.Caption = ""
'                                                    ProgressBar1.Value = 0
'                                                    Call UpdateF2Prog
'                                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                    Seq1 = NextNo
'                                                    Seq2 = NextNo
'                                                    Seq3 = NextNo
'                                                End If
'                                                If (CLine <> "" And CLine <> " ") Then
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole vbClearLine
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                End If
'                                            End If
'
'
'                                        End If
'
'                                        RunFlag = 1
'                                    Next 'Seq3
'
'
'                                End If
'
'                            Next 'Seq2
'
'                        End If
'
'                    Next 'Seq1
'
'                End If
'
'
'
'            End If
'            If MCFlag = 2 Then
'                CurrentCorrect = 3
'                Call StepDown
'            End If
'            If DebuggingFlag < 2 Then On Error Resume Next
'
'            ChDir ActualDir
'            ChDrive ActualDir
'            On Error GoTo 0
'            MCE = Abs(GetTickCount)
'            ET = Abs(GetTickCount)
'            MCS = Abs(MCS)
'            UpdateRecNums (SEventNumber)
'            Form1.Label50(6).Caption = DoTimeII(Abs(MCE - MCS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
'            Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST))) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'            Form1.Frame17.Refresh
'            TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
'            ET = Abs(GetTickCount)
'            MethodTime(3) = ET - Abs(MCS)
'
'            Erase Scores
'            Erase Winscores
'            Erase Chivals
'            Erase SmoothChi
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running MAXCHI scan: 100% complete" & vbCrLf
'            End If
'        End If
'
'
''        EE = Abs(GetTickCount)
''        ttt = EE - SS
'        '96.469
'        '37.578 - correcting for sequence size 71376
'        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                StartPlt(3) = 1
'                oRec = oRecombNo(100)
'                Call UpdatePlotC
'
'        End If
'
'        If AbortFlag = 1 Then
'            AbortFlag = 0
'            ABFl(3) = 1
'        End If
'
'        UpdateRecNums (SEventNumber)
'        If DoScans(0, 4) = 1 Then
'            Command25.ToolTipText = "Stop exploratory CHIMAERA phase of the scan"
'            CurrentCorrect = 4
'            SSPanel1.Caption = "Executing Chimaera"
'            ChiS = Abs(GetTickCount)
'            oRecombNo(4) = 0
'            Form1.ProgressBar1 = 0
'            Call UpdateF2Prog
'            b = 0
'            Picture3.AutoRedraw = True
'
'            HWindowWidth = CLng(CWinSize / 2)
'            ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
'            ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
'            ReDim ChiValsX(Len(StrainSeq(0)))
'
'            ReDim SmoothChiX(Len(StrainSeq(0)))
'            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'
'            Call GetCriticalDiff(1)
'            If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
'                CWinSize = HWindowWidth * 2
'            End If
'            If IndividualB > -1 Then
'
'                    If NextNo > 1 Then
'
'                        If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                        If XOverWindowX <> CDbl(Form1.Text5.Text) Then XOverWindowX = CDbl(Text5.Text)
'
'                        Seq1 = IndividualA
'                        Seq2 = IndividualB
'
'                        For Seq3 = 0 To NextNo
'
'                            If Seq3 <> Seq1 And Seq3 <> Seq2 Then
'                                'Emboss sequence beng compared
'                                Form1.Picture3.Refresh
'                                LastY3 = -1
'                                Picture3.MousePointer = 0
'                                b = b + 1
'                                MCMaxP = LowestProb
'
'                               tSeq1 = Seq1
'                                            tSeq2 = Seq2
'                                            tSeq3 = Seq3
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq2
'                                            Seq2 = tSeq3
'                                            Seq3 = tSeq1
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq3
'                                            Seq2 = tSeq1
'                                            Seq3 = tSeq2
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq1
'                                            Seq2 = tSeq2
'                                            Seq3 = tSeq3
'
'                                UpdateRecNums (SEventNumber)
'
'
'                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                    StartPlt(4) = 1
'                                    oRec = oRecombNo(100)
'                                    Call UpdatePlotC
'                                    ET = Abs(GetTickCount)
'                                End If
'
'                                MCE = Abs(GetTickCount)
'                                ET = Abs(GetTickCount)
'
'                                If ProgressBar1.Value > 0 Then
'                                    Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(MCE - MCS) * (100 / Form1.ProgressBar1.Value) - (MCE - MCS)) & " remaining"
'                                End If
'
'                                Form1.Label50(8).Caption = DoTimeII(Abs(MCE - MCS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
'                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'                                DoEvents 'covered by currentlyrunningflag
'                                If (CLine <> "" And CLine <> " ") Then
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole vbClearLine
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole "Running MAXCHI scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                End If
'                                If AbortFlag = 1 Then
'                                    'AbortFlag = 0
'                                    'RunFlag = 0
'                                    SSPanel1.Caption = ""
'                                    ProgressBar1.Value = 0
'                                    Call UpdateF2Prog
'                                    'Picture3.MousePointer = 0
'                                    'Screen.MousePointer = 0
'                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                    Seq1 = NextNo
'                                    Seq2 = NextNo
'                                    Seq3 = NextNo
'                                End If
'
'                            End If
'
'                        Next 'Seq3
'
'                        '
'                    End If
'
'                ElseIf IndividualA > -1 Then
'
'                    If NextNo > 1 Then
'
'                        If CDbl(Text5.Text) < 5 Then Text5.Text = 5
'
'                        If XOverWindowX <> CDbl(Form1.Text5.Text) Then XOverWindowX = CDbl(Text5.Text)
'
'                        Seq1 = IndividualA
'
'                        For Seq2 = 0 To NextNo
'
'                            If Seq2 <> Seq1 And MaskSeq(Seq2) <> 2 Then
'
'                                For Seq3 = Seq2 + 1 To NextNo
'
'                                    If Seq3 <> Seq1 Then
'                                        'Emboss sequence beng compared
'                                        Form1.Picture3.Refresh
'                                        LastY3 = -1
'                                        Picture3.MousePointer = 0
'                                        b = b + 1
'                                        MCMaxP = LowestProb
'
'                                        tSeq1 = Seq1
'                                            tSeq2 = Seq2
'                                            tSeq3 = Seq3
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq2
'                                            Seq2 = tSeq3
'                                            Seq3 = tSeq1
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq3
'                                            Seq2 = tSeq1
'                                            Seq3 = tSeq2
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq1
'                                            Seq2 = tSeq2
'                                            Seq3 = tSeq3
'
'                                        ChiE = Abs(GetTickCount)
'                                            ET = Abs(GetTickCount)
'
'                                            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                                Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                                Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS))
'                                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                                UpdateRecNums (SEventNumber)
'                                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                    StartPlt(4) = 1
'                                                    oRec = oRecombNo(100)
'                                                    Call UpdatePlotC
'                                                    ET = Abs(GetTickCount)
'                                                End If
'                                                LT = ET
'                                                Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
'                                                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                Call UpdateF2Prog
'                                                DoEvents 'covered by currentlyrunningflag
'                                                If (CLine <> "" And CLine <> " ") Then
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole vbClearLine
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole "Running CHIMAERA scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                End If
'                                                If AbortFlag = 1 Then
'                                                    'AbortFlag = 0
'                                                    'RunFlag = 0
'                                                    SSPanel1.Caption = ""
'                                                    ProgressBar1.Value = 0
'                                                    Call UpdateF2Prog
'                                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                    Seq1 = NextNo
'                                                    Seq2 = NextNo
'                                                    Seq3 = NextNo
'                                                End If
'                                            End If
'                                    End If
'
'                                Next 'Seq3
'
'                                'Form1.ProgressBar1.Value = b / (ProgressAdjustNo + nextno + (nextno * (nextno + 1))) * 100
'                            End If
'
'                            Form1.ProgressBar1.Value = (b / MCCorrection) * 100
'                            Call UpdateF2Prog
'                        Next 'Seq2
'
'                    End If
'
'                Else
'
'                    For Seq1 = 0 To NextNo
'
'                        If MaskSeq(Seq1) = 0 Then
'
'                            For Seq2 = Seq1 + 1 To NextNo
'
'                                If MaskSeq(Seq2) = 0 Then
'                                    LastY3 = -1
'
'                                    For Seq3 = Seq2 + 1 To NextNo
'
'                                        If MaskSeq(Seq3) = 0 Then
'                                            MCMaxP = LowestProb
'                                            LastY3 = -1
'                                            tSeq1 = Seq1
'                                            tSeq2 = Seq2
'                                            tSeq3 = Seq3
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq2
'                                            Seq2 = tSeq3
'                                            Seq3 = tSeq1
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq3
'                                            Seq2 = tSeq1
'                                            Seq3 = tSeq2
'
'                                            Call CXoverA(0, 0, 0)
'
'                                            Seq1 = tSeq1
'                                            Seq2 = tSeq2
'                                            Seq3 = tSeq3
'                                            b = b + 1
'                                            ChiE = Abs(GetTickCount)
'                                            ET = Abs(GetTickCount)
'
'                                            If (Abs(ET - LT)) > 500 Or AbortFlag = 1 Then
'                                                If (b + 1) / (MCCorrection + 1) <= 1 Then
'                                                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
'                                                End If
'                                                Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS))
'                                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                                UpdateRecNums (SEventNumber)
'                                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                                    StartPlt(4) = 1
'                                                    oRec = oRecombNo(100)
'                                                    Call UpdatePlotC
'                                                    ET = Abs(GetTickCount)
'                                                End If
'                                                LT = ET
'                                                If Form1.ProgressBar1.Value > 0 Then
'                                                    Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
'                                                End If
'
'                                                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                                Call UpdateF2Prog
'                                                DoEvents 'covered by currentlyrunningflag
'                                                If (CLine <> "" And CLine <> " ") Then
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole vbClearLine
'                                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                                    WriteToConsole "Running CHIMAERA scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                                End If
'                                                If AbortFlag = 1 Then
'                                                    'AbortFlag = 0
'                                                    'RunFlag = 0
'                                                    SSPanel1.Caption = ""
'                                                    ProgressBar1.Value = 0
'                                                    Call UpdateF2Prog
'                                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                                    Seq1 = NextNo
'                                                    Seq2 = NextNo
'                                                    Seq3 = NextNo
'                                                End If
'                                            End If
'
'
'                                        End If
'
'                                        RunFlag = 1
'                                    Next 'Seq3
'
'                                End If
'
'                            Next 'Seq2
'
'                        End If
'
'                    Next 'Seq1
'
'            End If
'            If MCFlag = 2 Then
'                CurrentCorrect = 4
'                Call StepDown
'            End If
'            ChiS = Abs(ChiS)
'            ChiE = Abs(GetTickCount)
'            ET = Abs(GetTickCount)
'
'            UpdateRecNums (SEventNumber)
'            Form1.Label50(8).Caption = DoTimeII(Abs(ChiE - ChiS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'            Form1.Frame17.Refresh
'            TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
'            ET = Abs(GetTickCount)
'            MethodTime(4) = Abs(ET - ChiS)
'            Erase ScoresX ' 0=s1,s2Matches etc
'            Erase WinScoresX ' 0=s1,s2Matches etc
'            Erase ChiValsX
'            Erase SmoothChiX
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running CHIMAERA scan: 100% complete" & vbCrLf
'            End If
'        End If
'                'XX = oRecombNo(4)
'
'
'
'        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                StartPlt(4) = 1
'                oRec = oRecombNo(100)
'                Call UpdatePlotC
'        End If
'
'        If AbortFlag = 1 Then
'            AbortFlag = 0
'            ABFl(4) = 1
'        End If
'
'
'        'If doscans(0,4) = 1 Then
'        'End If
'    SSS = Abs(GetTickCount)
'
'        If DoScans(0, 5) = 1 Then
'            Command25.ToolTipText = "Stop exploratory SISCAN phase of the ananlysis"
'            CurrentCorrect = 5
'
'
'            'Dimension horizontal randomisation array if necessary
'            If SSOutlyerFlag = 0 Or x = x Then
'                ReDim HRandTemplate(SSWinLen)
'                ReDim TakenPos(SSWinLen)
'            End If
'            ReDim VRandTemplate(0, 0)
'            GlobalMemoryStatus MemSit
'
'            APhys = Abs(MemSit.dwTotalPhys)
'            If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
'            APhys = 400000000
'            LmB = Len(StrainSeq(0))
'            LmB = LmB * SSNumPerms
'            LmB = LmB * 12
'            If APhys < LmB Then
'                OP = SSNumPerms
'                SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
'                pSSNumPerms = SSNumPerms
'                If SSNumPerms < 100 Then
'                    If CLine = "" Or CLine = " " Then
'                        MsgBox ("There is not enough free memory available to perform a SiScans in either exploratory or checking modes - Both modes will, therefore, be disabled.  Perhaps if you close some programs the situation will improve.")
'                    End If
'                    DoScans(0, 5) = 0
'                    DoScans(1, 5) = 0
'                Else
'                    If CLine = "" Or CLine = " " Then
'                        MsgBox ("You have specified that you would like to do a scan with " + Trim(Str(OP)) + " permutations. There is, however, only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations.")
'                    End If
'                End If
'            End If
'            'Dimension vertical randomisation array
'            ReDim VRandTemplate(Len(StrainSeq(0)), SSNumPerms)
'
'            ReDim DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)
'
'            Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
'
'            Rnd (-BSRndNumSeed)
'            LSeq = Len(StrainSeq(0))
'            WinNum = CLng(LSeq / SSStep + 1)
'            TotalSSRecombinants = 0
'            ReDim SeqMap(Len(StrainSeq(0)))
'            ReDim ZPScoreHolder(WinNum, 15)
'            ReDim ZSScoreHolder(WinNum, 14)
'            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'            'Make sure it will still run even in the event of a user messup
'            If SSNumPerms2 = 0 Then
'                SSNumPerms2 = 10
'            End If
'
'
'
'
'            ReDim SeqScore3(Len(StrainSeq(0))), MeanPScore(15), SDPScore(15)
'            ReDim PermSScores(SSNumPerms, 15), PermPScores(SSNumPerms, 15), SScoreHolder(WinNum, 14), PScoreHolder(WinNum, 15)
'            If SSOutlyerFlag = 2 Then
'                Call GetOutie
'                oSeq = Outie
'            End If
'
'            ReDim TraceSub(NextNo)
'            For x = 0 To NextNo
'                TraceSub(x) = x
'            Next x
'
'
'            If MCFlag = 0 Then
'                CorrectP = LowestProb / MCCorrection
'            Else
'                CorrectP = LowestProb
'            End If
'
'            C = 0
'
'            If IndividualB > -1 Then
'
'            ElseIf IndividualA > -1 Then
'
'            Else
'                For Seq1 = 0 To NextNo - 2
'
'                    For Seq2 = Seq1 + 1 To NextNo - 1
'                        For Seq3 = Seq2 + 1 To NextNo
'                            C = C + 1
'                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
'                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
'                            ET = Abs(GetTickCount)
'
'                            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                SSE = Abs(GetTickCount)
'                                SSS = Abs(SSS)
'                                ST = Abs(ST)
'                                If C < MCCorrection + 1 Then
'                                    Form1.ProgressBar1.Value = (C + 1) / (MCCorrection + 1) * 100
'                                End If
'                                Form1.Label50(10).Caption = DoTimeII(Abs(SSE - SSS))
'                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'                                UpdateRecNums (SEventNumber)
'                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                    StartPlt(5) = 1
'                                    oRec = oRecombNo(100)
'                                    Call UpdatePlotC
'                                    ET = Abs(GetTickCount)
'                                End If
'                                LT = ET
'                                If Form1.ProgressBar1.Value > 0 Then
'                                    Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(SSE - SSS) * (100 / Form1.ProgressBar1.Value) - (SSE - SSS)) & " remaining"
'                                End If
'                                Form1.SSPanel1.Caption = Str(C) & " of" & Str(MCCorrection) & " triplets examined"
'                                Call UpdateF2Prog
'                                DoEvents 'covered by currentlyrunningflag
'                                If (CLine <> "" And CLine <> " ") Then
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole vbClearLine
'                                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                    GetConsoleScreenBufferInfo hOutput, scrbuf
'                                    WriteToConsole "Running SIScan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                End If
'                                If AbortFlag = 1 Then
'                                    Form1.SSPanel1.Caption = ""
'                                    Form1.ProgressBar1.Value = 0
'                                    Call UpdateF2Prog
'                                    x = GetNumInList(Seq1, Seq2, Seq3)
'                                    If CurWothwhilePos > x Then CurWothwhilePos = x
'                                    Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
'                                End If
'
'                            End If
'                            If AbortFlag = 0 Then
'                                Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
'                            End If
'
'                        Next 'Seq3
'                    Next 'Seq2
'                Next 'Seq1
'
'            End If
'
'            SSOutlyerFlag = pSSOutlyerFlag
'            ET = Abs(GetTickCount)
'            SSE = Abs(GetTickCount)
'            Form1.ProgressBar1.Value = 100
'            Call UpdateF2Prog
'            Form1.Label50(10).Caption = DoTimeII(Abs(SSE - SSS))
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
'            UpdateRecNums (SEventNumber)
'
'            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                StartPlt(5) = 1
'                oRec = oRecombNo(100)
'                Call UpdatePlotC
'
'            End If
'            If MCFlag = 2 Then
'                CurrentCorrect = 5
'                Call StepDown
'            End If
'            UpdateRecNums (SEventNumber)
'            If AbortFlag = 1 Then
'                AbortFlag = 0
'                ABFl(5) = 1
'            End If
'            ET = Abs(GetTickCount)
'            MethodTime(5) = ET - Abs(SSS)
'
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running SIS scan: 100% complete" & vbCrLf
'            End If
'        End If
'
''        EEE = Abs(GetTickCount)
''        ttt = EEE - SSS
'        'base = 0.719
'
'
'        '229.391 (1838)
'        '227.812
'        '227.563
'        '224.703
'        '164.156 (2037)'2065
'        '153.793 2037
'        '159 9(45) 9 (74)
'        '155.500
'        '113.422 (1954)
'        '8 (47) 8 (76)
'        '107.671 (1726) - I corrected an error in makez - division of long instead of double
'        '107515
'        '88.234 (1726)
'        '81.891
'        '79.437
'        '78.984
'        '79.938
'        '79.875
'        '76.172(1726)
'        '76.109
'
'        '158.969 (2433)
'        '155.484 (2438) - slightly different sd calc
'        '132.735
''        If DoScans(0, 6) = 1 Then
''            Command25.ToolTipText = "Stop exploratory PHYLPRO phase of the scan"
''            CurrentCorrect = 6
''            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
''            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
''            Call PXoverF
''
''            If MCFlag = 2 Then
''                CurrentCorrect = 6
''                Call StepDown
''            End If
''
''            ET = Abs(GetTickCount)
''
''            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
''            UpdateRecNums (SEventNumber)
''
''            If AbortFlag = 1 Then
''                AbortFlag = 0
''                ABFl(6) = 1
''            End If
''            If (CLine <> "" And CLine <> " ") Then
''                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                GetConsoleScreenBufferInfo hOutput, scrbuf
''                WriteToConsole vbClearLine
''                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
''                GetConsoleScreenBufferInfo hOutput, scrbuf
''                WriteToConsole "Running PHYLPRO scan: 100% complete" & vbCrLf
''            End If
''        End If
'
'
'
'        If DoScans(0, 8) = 1 Then
'            Command25.ToolTipText = "Stop exploratory 3SEQ phase of the scan"
'            b = 0
'            ChiS = Abs(GetTickCount)
'            If XTableFlag = 0 Then
'                Call Build3SeqTable
'            End If
'            ReDim XoverSeqNumTS(Len(StrainSeq(0)))
'            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'            For Seq1 = 0 To NextNo
'
'                If MaskSeq(Seq1) = 0 Then
'
'                    For Seq2 = Seq1 + 1 To NextNo
'
'                        If MaskSeq(Seq2) = 0 Then
'                            LastY3 = -1
'
'                            For Seq3 = Seq2 + 1 To NextNo
'
'                                If MaskSeq(Seq3) = 0 Then
'                                    MCMaxP = LowestProb
'                                    LastY3 = -1
'                                    tSeq1 = Seq1
'                                    tSeq2 = Seq2
'                                    tSeq3 = Seq3
'
'                                    Call TSXOver(0)
'
'                                    Seq1 = tSeq2
'                                    Seq2 = tSeq3
'                                    Seq3 = tSeq1
'
'                                    Call TSXOver(0)
'
'                                    Seq1 = tSeq3
'                                    Seq2 = tSeq1
'                                    Seq3 = tSeq2
'
'                                    Call TSXOver(0)
'
'                                    Seq1 = tSeq1
'                                    Seq2 = tSeq2
'                                    Seq3 = tSeq3
'                                    b = b + 1
'                                    ChiE = Abs(GetTickCount)
'                                    ET = Abs(GetTickCount)
'
'                                    If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
'                                        If ((b + 1) / (MCCorrection + 1) * 100) <= 100 Then
'                                            Form1.ProgressBar1.Value = ((b + 1) / (MCCorrection + 1) * 100)
'                                        Else
'                                            Form1.ProgressBar1.Value = 100
'                                        End If
'                                        Form1.Label50(14).Caption = DoTimeII(Abs(ChiE - ChiS))
'                                        Form1.Label50(12).Caption = DoTimeII(Abs(ET) - Abs(ST))
'                                        UpdateRecNums (SEventNumber)
'                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                            StartPlt(4) = 1
'                                            oRec = oRecombNo(100)
'                                            Call UpdatePlotC
'                                            ET = Abs(GetTickCount)
'                                        End If
'                                        LT = ET
'                                        Form1.SSPanel13.Caption = "Approximately " & DoTime(Abs(ChiE - ChiS) * (100 / Form1.ProgressBar1.Value) - (ChiE - ChiS)) & " remaining"
'                                        Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
'                                        Call UpdateF2Prog
'                                        DoEvents 'covered by currentlyrunningflag
'                                        If (CLine <> "" And CLine <> " ") Then
'                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                            GetConsoleScreenBufferInfo hOutput, scrbuf
'                                            WriteToConsole vbClearLine
'                                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                                            GetConsoleScreenBufferInfo hOutput, scrbuf
'                                            WriteToConsole "Running 3SEQ scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
'                                        End If
'                                        If AbortFlag = 1 Then
'                                            'AbortFlag = 0
'                                            'RunFlag = 0
'                                            SSPanel1.Caption = ""
'                                            ProgressBar1.Value = 0
'                                            Call UpdateF2Prog
'                                            x = GetNumInList(Seq1, Seq2, Seq3)
'                                            If CurWothwhilePos > x Then CurWothwhilePos = x
'                                            Seq1 = NextNo
'                                            Seq2 = NextNo
'                                            Seq3 = NextNo
'                                        End If
'                                    End If
'
'
'                                End If
'
'                                RunFlag = 1
'                            Next 'Seq3
'
'                        End If
'
'                    Next 'Seq2
'
'                End If
'
'            Next 'Seq1
'            '4.19'46897
'            '1:17'46899
'            '1:11
'            MethodTime(8) = Abs(ET - ChiS)
'
'            If (CLine <> "" And CLine <> " ") Then
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole vbClearLine
'                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
'                GetConsoleScreenBufferInfo hOutput, scrbuf
'                WriteToConsole "Running 3SEQ scan: 100% complete" & vbCrLf
'            End If
'
'
'        End If
'
'        ChiS = Abs(ChiS)
'        ChiE = Abs(GetTickCount)
'        ET = Abs(GetTickCount)
'
'        UpdateRecNums (SEventNumber)
'        Form1.Label50(14).Caption = DoTimeII(Abs(ChiE - ChiS)) 'Str$((Int((MCE - MCS) / 100)) / 10)
'        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST)) 'Str$((Int((abs(ET - ST)) / 100)) / 10)
'        Form1.Frame17.Refresh
'        TotalTime = CStr((Int((Abs(ET - ST)) / 100)) / 10)
'        ET = Abs(GetTickCount)
'
'        If ShortOutFlag = 1 Then CurrentlyRunningFlag = 0: Exit Sub
'
'
'        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'            StartPlt(8) = 1
'            oRec = oRecombNo(100)
'            Call UpdatePlotC
'
'        End If
'        If MCFlag = 2 Then
'            CurrentCorrect = 8
'            Call StepDown
'        End If
'
'        UpdateRecNums (SEventNumber)
'
'        If AbortFlag = 1 Then
'            AbortFlag = 0
'            ABFl(8) = 1
'        End If
'        ET = Abs(GetTickCount)
    ElseIf ExRecFlag = 1 Then
            Call ExRecAnalysis
        
    ElseIf ExRecFlag = 203 Then
        Dim StartP As Double, SeqPos As Long
        StartP = 10 ^ -10
        Dim SMap() As Long
        ReDim SMap(Len(StrainSeq(0)), NextNo)
        For x = NumActualEvents To 0 Step -1
            If ActualEventList(3, x) <> 0 Or ActualEventList(4, x) <> 0 Then
                If ActualEventList(1, x) < ActualEventList(2, x) Then
                    For Z = ActualEventList(1, x) + 1 To ActualEventList(2, x)
                        SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                    Next Z
                Else '
                    For Z = ActualEventList(1, x) + 1 To Len(StrainSeq(0))
                        SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                    Next Z
                    
                    For Z = 1 To ActualEventList(2, x)
                        SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                    Next Z
                End If
            End If
        Next x
        For x = NumActualEvents To 0 Step -1
            If ActualEventList(3, x) <> 0 Or ActualEventList(4, x) <> 0 Then
                SeqPos = ActualEventList(3, x) - 1
                Dim Spos As Long, Epos As Long, SANTAEv As Long
                Spos = ActualEventList(1, x) + 1
                Epos = ActualEventList(2, x) + 1
                SANTAEv = ActualEventList(0, x)
                
                If Spos < Epos Then
                    For Z = Spos To Epos
                        If SMap(Z, SeqPos) = SANTAEv Then
                            For Y = Z To Epos
                                If SMap(Z, SeqPos) <> SANTAEv Or Y = Epos Then
                                    CurrentXOver(SeqPos) = CurrentXOver(SeqPos) + 1
                                    If CurrentXOver(SeqPos) > UBound(XoverList, 2) Then
                                        ReDim Preserve XoverList(UBound(XoverList, 1), CurrentXOver(SeqPos) + 100)
                                    End If
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).Daughter = ActualEventList(3, x) - 1
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).MinorP = ActualEventList(4, x) - 1
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).MajorP = ActualEventList(5, x) - 1
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).Probability = StartP
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).Beginning = Z
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).Ending = Y
                                    XoverList(SeqPos, CurrentXOver(SeqPos)).ProgramFlag = 0
                                    StartP = StartP * 0.99999999999
                                    'XoverList(SeqPos, CurrentXOver(SeqPos)). = 0
                                    Z = Y
                                    Exit For
                                End If
                            Next Y
                            
                        End If
                        
                    Next Z
                End If
                x = x

                
                
            End If
            
        Next x

    End If
    
    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
            StartPlt(8) = 1
            oRec = oRecombNo(100)
            Call UpdatePlotC
    End If
    
    
    'XX = UBound(BestEvent, 1)
    'XX = UBound(BestEvent, 2)
    'Erase NumSeq: Erase Iseq4
    
    
    SSPanel13.Caption = ""
    ProgressBar1 = 0
    Call UpdateF2Prog
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Picture7.AutoRedraw = True
    'Picture7.ClipControls = False
    Picture10.AutoRedraw = True
    ZZ = 0
    For x = 0 To PermNextno
       ZZ = ZZ + CurrentXOver(x) '863
    Next x
    
    Call FillISInvolved(NextNo, UseALFlag, Worthwhilescan(), ISInvolved(), Analysislist())
    
    If LongWindedFlag = 1 And ShortOutFlag <> 1 And (ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210) Then
            
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbCrLf & "Detecting recombinants, finding breakpoints and counting recombination events (the second of two analysis phases)" & vbCrLf & vbCrLf
            End If
            
            Command25.ToolTipText = "Stop the recombinant identification phase of the scan"
            DoneTree(0, 3) = 0
            DoneTree(1, 3) = 0
            
            Call DoRDP(0, 0)
            
            Command25.ToolTipText = ""
            CurrentlyRunningFlag = 0
            Call MakeSummary
            
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Evidence of" & Str(SEventNumber) & " unique recombination events detected (" + Trim(Str(oRecombNo(100))) & " recombination signals remaining)       " & vbCrLf & vbCrLf
                WriteToConsole "Finished detecting, analysing and counting recombination events" & vbCrLf
            End If

            
            'Clean up used arrays
            
    End If
    
    
    If StrainSeqOnDisk = 1 Then
        ReDim Preserve StrainSeq(NextNo + 1)
        oDirX = CurDir
        ChDir App.Path
        ChDrive App.Path
        
        
        For x = 1 To NextNo
            StrainSeq(x) = String(Len(StrainSeq(0)), " ")
        Next x
        
        FF = FreeFile
        
        Open "RDP5Strainseq" + UFTag For Binary As #FF
        Get #FF, , StrainSeq()
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    
   ' XX = BestEvent(1, 0)
    If ShortOutFlag <> 1 And LongWindedFlag = 1 And AbortFlag = 0 Then
        'Call GetSupers
        Call SetUpEvents
        
    End If
   ' XX = BestEvent(1, 0)
    If DoScans(0, 8) = 1 Or DoScans(0, 6) = 1 Or DoScans(0, 0) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or ProgressBar1.Left > 5 * Screen.TwipsPerPixelX Then

        For x = 223 * Screen.TwipsPerPixelX To 3 * Screen.TwipsPerPixelX Step -20 * Screen.TwipsPerPixelX
            StartL = StartL - 20 * Screen.TwipsPerPixelX
            StartW = StartW + 20 * Screen.TwipsPerPixelX
            ProgressBar1.Width = StartW: ProgressBar1.Left = StartL
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Sleep 3
        Next 'X

    End If
If ShowPlotFlag < 2 Then
    ReDim StartPlt(6)
    If DoScans(0, 0) = 1 Then StartPlt(0) = 1
    If DoScans(0, 1) = 1 Then StartPlt(1) = 1
    If DoScans(0, 2) = 1 Then StartPlt(2) = 1
    If DoScans(0, 3) = 1 Then StartPlt(3) = 1
    If DoScans(0, 4) = 1 Then StartPlt(4) = 1
    If DoScans(0, 5) = 1 Then StartPlt(5) = 1
    If DoScans(0, 6) = 1 Then StartPlt(6) = 1
End If
    'Clean up sequence names
BailOut:
    Picture3.AutoRedraw = True
    Picture3.Picture = LoadPicture()
    ReDim Preserve MaskSeq(NextNo)
    Call PrintNames

    If oRecombNo(100) = 0 And (ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210) Then
        RunFlag = 0
        'Label22.Caption = "No Potentially Recombinant Sequences Discovered"
        If AutoMultFlag > 0 Then
        
        Else
            If CLine = "" Or CLine = " " Then
                MsgBox ("No evidence of recombination was found in this alignment")
            End If
        End If
        SSPanel1.Caption = ""
        ProgressBar1.Value = 0
        Call UpdateF2Prog
        Screen.MousePointer = 0
        Picture3.MousePointer = 0
        SSPanel2.Enabled = True
        SSPanel3.Enabled = True
        Picture1.Enabled = True
        Picture8.Enabled = True
        Picture7.Enabled = False
        Picture20.Visible = False
        
        If ManFlag < 1 Then
            Frame7.Enabled = False
            Form1.Picture23(1).Enabled = False
        Else
            Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Command29(0).Enabled = True:  Command29(1).Enabled = True
        End If
        Command25.Enabled = False
        Command25.ToolTipText = ""
        ScanFlagX = 0
        BRunning = 0
        CurrentlyRunningFlag = 0
        Exit Sub
    Else
        'ReDim RecombNo(100)
        'For X = 0 To 100
        '    RecombNo(X) = oRecombNo(X)
        'Next X
    End If

    SSPanel1.Caption = "Sorting Data"
    
    BB = Abs(GetTickCount)
    
    If CLine = "" Then
        RIMode = 1
        If DebuggingFlag < 2 Then On Error Resume Next
        Picture2.BackColor = BackColours + 65793 * 10
        On Error GoTo 0
        CurrentlyRunningFlag = 0
        Call MakeSummary
        If RelX = 0 And RelY = 0 Then
            Command13(2).Enabled = False
        End If
        SSPanel3.Enabled = True
        Picture1.Enabled = True
    End If
    
    
    
    
    If ShortOutFlag = 3 Then
        
        BRunning = 0
        CurrentlyRunningFlag = 0
        Exit Sub
    End If
    
    If oNumberOfSeqs <> 0 Then
        NumberOfSeqs = oNumberOfSeqs
    End If
'    EE = Abs(GetTickCount)
'    TT = EE - BB
    SSPanel1.Caption = "Updating recombination graphs"
    Picture3.Refresh
    LastY3 = -1
    If CLine = "" Or CLine = " " Then
        Call IntegrateXOvers(1)
        UpdateRecNums (SEventNumber)
    End If
    
    ReDim TreeTestStats(3, SEventNumber)
    For x = 0 To SEventNumber
        For Y = 0 To 3
            TreeTestStats(Y, x) = -1
        Next Y
    Next x
    RelX = 0
    RelY = 0
    oPMax = PPMax
    
    'HScroll2.Max = Picture6.ScaleWidth - Picture5.ScaleWidth
    Form1.SSPanel5.Enabled = True
    Picture7.Enabled = True
    Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    If SchemFlag = 0 Then
        Label58.Caption = "Unique sequences"
    ElseIf SchemFlag = 1 Then
        Label58.Caption = "Methods"
    ElseIf SchemFlag = 2 Then
        Label58.Caption = "P-Values"
    ElseIf SchemFlag = 3 Then
        Label58.Caption = "Parental identities"
    End If

    SSPanel6(1).Visible = False
    SSPanel6(2).Visible = False
    SSPanel6(0).Visible = True
    'Form1.Frame17.Visible = True
    
    SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    Picture5.Enabled = True
    Form1.Picture3.AutoRedraw = True
    
    
    
    
    SSPanel2.Enabled = True
    Picture8.Enabled = True
    Command6(3).Enabled = False
    Command17.Enabled = False
    Command18.Enabled = True    'Enable "Save" button
    'Command18.Width = 70 * Screen.TwipsPerPixelX
    'command2(1).Visible = True
    Command6(2).Enabled = True
    Command5.Enabled = True
    Command9.Enabled = True
    'enable sspanel6 (tree, matrix, recombination info and overview)
        Form1.SSPanel6(0).Enabled = True
        Form1.SSPanel6(1).Enabled = True
        Form1.SSPanel6(2).Enabled = True
    
    If ManFlag < 1 Then
        Frame7.Enabled = False
        Form1.Picture23(1).Enabled = False
    Else
        Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Command29(0).Enabled = True:  Command29(1).Enabled = True
    End If
    Command25.Enabled = False
    Command25.ToolTipText = ""
    Command18.ToolTipText = "Save results in .csv or .rdp project file format"
    Screen.MousePointer = 0
    'Frame17.BackColor = Picture11.BackColor
    'Picture10.BackColor = Picture11.BackColor
    ScanFlagX = 0
    If CLine = "" Or CLine = " " Then
         If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    End If
    BRunning = 0
    CurrentlyRunningFlag = 0
    Exit Sub
RedoReDim:
    DimSize = DimSize / 2
    ReDim XoverList(NextNo, DimSize)
    Resume Next
End Sub

Private Sub Command22_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Picture3.Refresh
    Picture2.Refresh
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
End Sub





Private Sub Command25_Click()
    AbortFlag = 1: SAbortFlag = 1
    Command3.SetFocus
    'Call MakeAncestral
    Exit Sub
    'Command3.SetFocus
    Picture7.ScaleMode = 3
    CurrentCheck = Combo1.ListIndex
    ExeCheckFlag = 1

    If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then

        Call RDPChecking

    ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then

        Call BootscanChecking

    ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then

        Call MaxChiChecking

    End If

    ExeCheckFlag = 0

    If RunFlag = 1 And ManFlag = -1 Then
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DontPutForm2Ontop = 0
    ElseIf ManFlag > -1 Then

        Call DoLegend

    End If

End Sub



Private Sub Command25_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
End Sub

Private Sub Command28_Click()
    AbortFlag = 1
End Sub

Private Sub Command29_Click(Index As Integer)
    'Form3.TabStrip1.Index = Form3.TabStrip1.SelectedItem(5)
    'Set Form3.TabStrip1.Index = 5
    'Set ListView1.SelectedItem = ListView1.ListItems(1)
'    If Form2OnTopFlag = 1 Then
'        Dummy = SetTopMostWindow(Form2.hwnd, False)
'        Form2OnTopFlag = 0
'    End If
    ofv = OptFlag
    If Index = 1 Then
        Command3.SetFocus
        'If SERecSeq = 0 And SEPAVal = 0 Then
        If RelX > 0 Or RelY > 0 Then
            SERecSeq = RelX: SEPAVal = RelY
    'End I
            Call AcceptSMnu_Click
            If XoverList(RelX, RelY).Accept <> 1 Then
                Call AcceptSMnu_Click
            End If
        'ARFlag = 2
        'Form1.Timer6.Enabled = True
            Call Command9_Click
        Else
            Command29(1).Enabled = False
        End If
    Else
        If RelX = 0 And RelY = 0 And ofv <> 41 Then
            Call Command12_Click(0)
        Else
            Dim VisFrame As Integer
            Command3.SetFocus
            OptFlag = -1
            OptButtonF = 1
            Form3.TabStrip1.Visible = False
        
            If ManFlag > -1 Then
        
                If ManFlag = 3 Then
                    OptFlag = 33
                    VisFrame = 3
                    Form3.TabStrip2.Tabs(1).Caption = "Bootscan Options"
                ElseIf ManFlag = 1 Then
                    OptFlag = 31
                    VisFrame = 2
                    Form3.TabStrip2.Tabs(1).Caption = "GENECONV Options"
                ElseIf ManFlag = 4 Then
                    OptFlag = 34
                    VisFrame = 4
                    Form3.TabStrip2.Tabs(1).Caption = "MaxChi Options"
                ElseIf ManFlag = 5 Then
                    OptFlag = 35
                    VisFrame = 7
                    Form3.TabStrip2.Tabs(1).Caption = "LARD Options"
                ElseIf ManFlag = 7 Then
                    OptFlag = 37
                    VisFrame = 9
                    Form3.TabStrip2.Tabs(1).Caption = "Distance Plot Options"
                ElseIf ManFlag = 8 Then
                    OptFlag = 38
                    VisFrame = 10
                    Form3.TabStrip2.Tabs(1).Caption = "TOPAL Options"
                ElseIf ManFlag = 20 Then
                    OptFlag = -1
                    VisFrame = 13
                    Form3.TabStrip2.Tabs(1).Caption = "Recombination Rate Plot Options"
                ElseIf ManFlag = 161 Then
                    VisFrame = 8
                    OptFlag = 41
                    Form3.TabStrip2.Tabs(1).Caption = "Breakpoint Distribution Plot Options"
                    Form3.Combo1.ListIndex = 8
                    Form3.Combo1.Enabled = False
                    Form3.Command28(19).Enabled = False
                    Form3.Picture1 = LoadPicture()
                    Form3.Label1(58).Enabled = False
                End If
        
            ElseIf CurrentCheck > -1 And ((RelX > 0 Or RelY > 0) Or ofv = 41) Then
        
                If CurrentCheck = 0 Then
                    VisFrame = 1
                    OptFlag = 0
                    Form3.TabStrip2.Tabs(1).Caption = "RDP Options"
                ElseIf CurrentCheck = 1 Then
                    VisFrame = 2
                    OptFlag = 1
                    Form3.TabStrip2.Tabs(1).Caption = "GENECONV Options"
                ElseIf CurrentCheck = 15 Then
                    VisFrame = 8
                    OptFlag = 41
                    Form3.TabStrip2.Tabs(1).Caption = "Breakpoint Distribution Plot Options"
                    Form3.Combo1.ListIndex = 8
                    Form3.Combo1.Enabled = False
                    Form3.Command28(19).Enabled = False
                    Form3.Picture1 = LoadPicture()
                    Form3.Label1(58).Enabled = False
                ElseIf CurrentCheck = 55 Then
                    Exit Sub
                ElseIf CurrentCheck = 2 Or CurrentCheck = 3 Then
                    VisFrame = 3
                    OptFlag = 3
                    Form3.TabStrip2.Tabs(1).Caption = "Bootscan Options"
                    
                ElseIf CurrentCheck = 4 Then
                    VisFrame = 4
                    OptFlag = 4
                    Form3.TabStrip2.Tabs(1).Caption = "MaxChi Options"
                ElseIf CurrentCheck = 5 Then
                    VisFrame = 6
                    OptFlag = 9
                    Form3.TabStrip2.Tabs(1).Caption = "SiScan Options"
                ElseIf CurrentCheck = 6 Then
                    VisFrame = 7
                    OptFlag = 5
                    Form3.TabStrip2.Tabs(1).Caption = "LARD Options"
                ElseIf CurrentCheck = 7 Then
                    VisFrame = 8
                    OptFlag = 6
                    Form3.TabStrip2.Tabs(1).Caption = "Reticulate Options"
                ElseIf CurrentCheck = 8 Then
                    VisFrame = 9
                    OptFlag = 7
                    Form3.TabStrip2.Tabs(1).Caption = "Distance Plot Options"
                ElseIf CurrentCheck = 40 Or CurrentCheck = 41 Then
                    Form3.TabStrip2.Tabs(1).Caption = "VisRD Options"
                    VisFrame = 14
                    If CurrentCheck = 40 Then
                        OptFlag = 50
                    Else
                        OptFlag = 51
                    End If
                ElseIf CurrentCheck = 9 Then
                    VisFrame = 10
                    OptFlag = 8
                    Form3.TabStrip2.Tabs(1).Caption = "TOPAL Options"
                ElseIf CurrentCheck = 10 Then
                    VisFrame = 5
                    OptFlag = 11
                    Form3.TabStrip2.Tabs(1).Caption = "Chimaera Options"
                ElseIf CurrentCheck = 13 Then
                    VisFrame = 12
                    OptFlag = 13
                    Form3.TabStrip2.Tabs(1).Caption = "PhylPro Options"
                ElseIf CurrentCheck = 20 Then
                    Exit Sub
                ElseIf CurrentCheck = 55 Then
                    Exit Sub
                ElseIf CurrentCheck = 21 Then
                    VisFrame = 4
                    OptFlag = 22
                    Form3.TabStrip2.Tabs(1).Caption = "MaxChi Options"
                ElseIf CurrentCheck = 22 Then
                    Exit Sub
                ElseIf CurrentCheck = 23 Then
                    VisFrame = 9
                    OptFlag = 23
                    Form3.TabStrip2.Tabs(1).Caption = "Distance Plot Options"
                End If
        
            Else
        
                If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 0 Then
                    VisFrame = 1
                    OptFlag = 0
                    Form3.TabStrip2.Tabs(1).Caption = "RDP Options"
                ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 1 Then
                    VisFrame = 2
                    If pGCTripletflag = 0 Then
                        
                        OptFlag = 21
                    Else
                        
                        OptFlag = 1
                    End If
                    Form3.TabStrip2.Tabs(1).Caption = "GENECONV Options"
                ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 2 Then
                    VisFrame = 3
                    OptFlag = 3
                    Form3.TabStrip2.Tabs(1).Caption = "Bootscan Options"
                ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 3 Then
                    If MCTripletFlag = 0 Then
                        VisFrame = 4
                        OptFlag = 4
                        Form3.TabStrip2.Tabs(1).Caption = "MaxChi Options"
                    Else
                        VisFrame = 4
                        OptFlag = 22
                        Form3.TabStrip2.Tabs(1).Caption = "MaxChi Options"
                    End If
                ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 4 Then
                    VisFrame = 5
                    OptFlag = 10
                    Form3.TabStrip2.Tabs(1).Caption = "Chimaera Options"
                ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag - AddNum = 5 Then
                    VisFrame = 6
                    OptFlag = 9
                    Form3.TabStrip2.Tabs(1).Caption = "SiScan Options"
                Else
                    Exit Sub
                End If
        
            End If
            Dim OChk As Byte
            If RelX > 0 Or RelY > 0 Or ofv = 41 Then
                For x = 0 To 14
            
                    If x = VisFrame Then
                        Form3.Frame2(x).Visible = True
                    Else
                        Form3.Frame2(x).Visible = False
                    End If
            
                Next 'X
                OptionsFlag = 1
                Call Command12_Click(0)
                OptionsFlag = 0
                Command29(0).Enabled = True: Command29(1).Enabled = True
                Combo1.Enabled = True
                
            Else
                
                For x = 0 To 14
            
                    
                        Form3.Frame2(x).Visible = True
                    
            
                Next 'X
                OptionsFlag = -1
                VisFrame = -1
                OChk = NoF3Check2
                NoF3Check2 = 1
                Call Command12_Click(0)
                NoF3Check2 = OChk
            End If
        
        End If
        
        
    End If
End Sub

Private Sub Command29_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Index = 1 And Form2.Visible = True And Form2.WindowState = 0 And Form2OnTopFlag = 0 And Form2.hwnd = GetForegroundWindow Then
    Dummy = SetTopMostWindow(Form2.hwnd, True)
    Form2OnTopFlag = 1
End If
End Sub

Private Sub Command3_Click()
    'Command3.SetFocus

    If WeightedFlagT = 1 Then
        WeightedFlagT = 0
        Label19 = "Antibiasing off"
    Else
        WeightedFlagT = 1
        Label19 = "Antibiasing on"
    End If
    
   
End Sub

Private Sub Command3_GotFocus()
 If AncSeqFlag = 1 Then
        Call HScroll1_Change
        If ColDistInFile = 1 Then
            
            ReDim ColDist2(0)
            Timer7(1).Enabled = False
        End If
    End If
End Sub





Private Sub Command32_Click()

End Sub



Private Sub Command3_KeyDown(KeyCode As Integer, Shift As Integer)
If CurrentlyRunningFlag = 1 Then Exit Sub
Call DoKeydown(KeyCode)
End Sub

Private Sub Command33_Click(Index As Integer)


    'These are the zoom in and zoom out buttons
    Dim tTYF As Double, TYFM As Integer, OSM As Long, DiffY As Long
    Dim OM As Long, TS(3) As Double, OV As Long, OFS As Double, otTYF As Double, IndexX As Byte, CurrentSeq As Long, OFS2 As Single
'    If CLine = "" Or CLine = " " Then
'        Command3.SetFocus
'    End If
    'what is the centre column (goes into goposx)
    
    
    
    If Index = 0 Or Index = 1 Then
        Call DoSeqZoom(Index)
    
    ElseIf Index = 2 Then 'This is the tree zoom out button
        
        Call TreeZoom(0)
        
    ElseIf Index = 3 Then 'This is the tree zoom in button
        
        Call TreeZoom(1)
       
    End If
End Sub


Private Sub Command33_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
P1Seq = -1
P1NT = -1
End Sub



Private Sub Command38_Click()
    Command3.SetFocus
    If CurrentlyRunningFlag = 1 Then Exit Sub
    If NextNo >= 3 Then
        Command3.SetFocus
        
        If SEventNumber = 0 Then
            CurMatrixFlag = 0
            Call DrawCompatMat
            
            Form1.Check1.Enabled = False
            SSPanel6(2).Enabled = True
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
            TimerVal = 0
            FirstPass = 1
        ElseIf RelX > 0 Or RelY > 0 Then
            Call MCMatMnu_Click
        
        
        ElseIf CurMatrixFlag = 255 And (RelX > 0 Or RelY > 0) Then
            Call MCMatMnu_Click
        Else
            Call RecRCMnu_Click
        End If
        
    Else
        If CLine = "" Or CLine = " " Then
            Response = MsgBox("You need to load up a file with more than three sequences to make a compatibility matrix", vbInformation)
        End If
    End If
End Sub

Private Sub Command38_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command39_Click(Index As Integer)
Call DoMatrixZoom(Index)
End Sub

Private Sub Command39_MouseDown(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
Timer3.Enabled = True

If HVScrollflag = 0 Then
    If CurMatrixFlag = 2 Then
            UB = (UBound(MatrixM, 1) - 1)
    ElseIf CurMatrixFlag = 1 Then
            UB = (UBound(MatrixR, 1) - 1)
    ElseIf CurMatrixFlag = 0 Then
            UB = (UBound(MatrixC, 1) - 1)
    ElseIf CurMatrixFlag = 14 Then
            UB = (UBound(MatrixTB, 1) - 1)
    ElseIf CurMatrixFlag = 3 Then
            UB = (UBound(MatrixRR, 1) - 1)
    ElseIf CurMatrixFlag = 4 Then
            UB = (UBound(MatrixBP, 1) - 1)
    ElseIf CurMatrixFlag = 5 Then
        UB = UBound(MatrixLD, 1) - 1
    ElseIf CurMatrixFlag = 6 Then
        UB = UBound(MatrixRMin, 1) - 1
    ElseIf CurMatrixFlag = 7 Then
        UB = UBound(MatrixRMinD, 1) - 1
    ElseIf CurMatrixFlag = 8 Then
            UB = UBound(MatrixMC, 1) - 1
    ElseIf CurMatrixFlag = 11 Then
            UB = UBound(MatrixL, 1) - 1
    ElseIf CurMatrixFlag = 12 Then
        UB = UBound(MatrixSH, 2) - 1
    ElseIf CurMatrixFlag = 13 Then
        
            UB = UBound(MatrixRF, 1) - 1
    End If
    
    ActualMidPixelV = MatCoord(CurMatrixFlag, 1) + (UB / (2)) / MatZoom(CurMatrixFlag)
    ActualMidPixelH = MatCoord(CurMatrixFlag, 0) + (UB / (2)) / MatZoom(CurMatrixFlag)  '10.6=4
    HVScrollflag = 1
End If
If Index = 0 Then
    Timer3.Interval = 25
ElseIf Index = 1 Then
    Timer3.Interval = 26
End If
End Sub

Private Sub Command39_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Screen.MousePointer = 0
End Sub

Private Sub Command39_MouseUp(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
Timer3.Enabled = False
If Index = 0 Then
    Timer3.Interval = 25
ElseIf Index = 1 Then
    Timer3.Interval = 26
End If
End Sub

Private Sub Command4_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub




Private Sub Command4_Click(Index As Integer)
    If CLine = "" Or CLine = " " Then
        Command3.SetFocus
    End If
    If Index = 0 Then
        RIMode = 0
         VS4Max2 = VScroll4.Max
         VS4CV = VScroll4.Value
         VScroll4.Value = 0
         VScroll4.Max = VS4Max
         
         
        Command13(2).Caption = "Overview"
        Command13(2).ToolTipText = "Press for summarized information on recombination events 1 through " + Trim(Str(SEventNumber))
        'Picture2.Height = 2500
        If ManFlag > -1 Then

            Call DoLegend

        ElseIf RelX > 0 Or RelY > 0 Then
                    PAVal = RelY
                    RecSeq = RelX
                    Pic7GoonFlag = 1
                    DontPutForm2Ontop = 1
                    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                    DontPutForm2Ontop = 0
                    Pic7GoonFlag = 0
            
        End If

        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        SSPanel6(2).Visible = False
    ElseIf Index = 1 Then
        If TreeImage(TreeTypeFlag) > 0 Then
            SSPanel6(1).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(2).Visible = False
            x = x
        Else
            If CTF > 0 And TreeTypeFlag <> 0 Then
                CTF = 0
            End If
            If TreeTypeFlag = 0 Or BRunning = 1 Then
                If TBLLen = 0 Then
                    Call Command7_Click
                Else
                    Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, 0, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                End If
            Else
                If RelX = 0 And RelY = 0 Then
                    Call ModNextno
                    If Form1.VScroll1.Value <> 0 Or Form1.VScroll1.Value <> 1 Then
                        If Form1.VScroll1.Value = 1 Then
                            Form1.VScroll1.Value = 0
                        Else
                            If Form1.VScroll1.Max <= 1 Then
                                OV = Form1.VScroll1.Enabled
                                Form1.VScroll1.Enabled = True
                                Form1.VScroll1.Max = 1
                                Form1.VScroll1.Max = 1
                                Form1.VScroll1.Enabled = OV
                            End If
                            Form1.VScroll1.Value = 1
                        End If
                    Else
                        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                    End If
                    
                End If
            End If
            
    
            
            If Eventnumber > 0 Then
                Call Command17_Click
            Else
                SSPanel6(1).Visible = True
                SSPanel6(0).Visible = False
                SSPanel6(2).Visible = False
            End If
        End If
    ElseIf Index = 2 Then
            VS4Max = VScroll4.Max
            VScroll4.Max = VS4Max2
            VScroll4.Value = VS4CV
            RIMode = 1
            Frame17.Visible = False
            Command13(2).Caption = "Recombination Info"
            If RelX > 0 Or RelY > 0 Then
                Command13(2).ToolTipText = "Press for detailed information on recombiation event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
            Else
                Command13(2).ToolTipText = "Press for detailed information on recombiation event 1"
            End If
            Picture2.Picture = LoadPicture()
            Call MakeSummary
            SSPanel6(0).Visible = True
            SSPanel6(1).Visible = False
            SSPanel6(2).Visible = False
            
    End If
    
End Sub

Private Sub Command5_Click()
'ButtonRepress = ButtonRepress + 1

'For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
'    x = x
Command3.SetFocus
If FastNJFlag = 1 Then
    Form2.Command8.Enabled = False
    Form2.Command9.Enabled = False
    Form1.Command5.Enabled = False
    Form1.Command9.Enabled = False
End If
    
Call GoToPreviousEventMnu_Click



   
If FastNJFlag = 1 Then
   Form2.Command8.Enabled = True
   Form2.Command9.Enabled = True
   Form1.Command5.Enabled = True
    Form1.Command9.Enabled = True
End If
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
Form1.Refresh
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub Command5_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2.Visible = True And Form2.WindowState = 0 And Form2OnTopFlag = 0 And Form2.hwnd = GetForegroundWindow Then
    Dummy = SetTopMostWindow(Form2.hwnd, True)
    Form2OnTopFlag = 1
End If
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
        Picture6.Refresh
        CurFlash = 0
        Timercheck(1) = 0
        Call Timer1_Timer
        HighlightFlag = 0
        RecSeq = 0
        PAVal = 0
        If RIMode = 1 Then
            Call MakeSummary
        End If
    End If
End Sub

Private Sub Command6_Click(Index As Integer)
    
    'These are the buttons with the curley arrows
    Command3.SetFocus
    LastTop = -1
        LastBottom = -1 'makes sure the whole sequence display is redrawn
    If Index = 0 Then 'This is the button that cycles through the different sequence displays
        If RunFlag = 1 And ManFlag = -1 Then
            If RelX <> RecSeq Or PAVal <> RelY Then
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
            End If
            
            Picture3.ForeColor = QBColor(0)
            ShowSeqFlag = ShowSeqFlag + 1
            
            If ShowSeqFlag = 2 Then 'if the ancestral sequence is being displayed then cant show significant only
                ShowSeqFlag = 0
            End If
            'If XOverList(RelX, RelY).ProgramFlag = 1 And ShowSeqFlag = 2 Then
            '    ShowSeqFlag = 3
            'End If
    
            If ShowSeqFlag = 0 Then
                HScroll1.SmallChange = 1
                Picture3.Enabled = True
                Label21 = "Show All Sequences"
                ShowSeqFlag = 0
                Call PrintNames
                Call RedrawPlotAA(1)
            ElseIf ShowSeqFlag = 1 Then
                HScroll1.SmallChange = 1
                VScroll3.Value = 0
                Label21 = "Show Relevant Sequences"
                Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
                LastY3 = -1
                Call RedrawPlotAA(0)
            ElseIf ShowSeqFlag = 2 Then
                HScroll1.SmallChange = 20
                VScroll3.Value = 0
                Picture3.Enabled = False
                Label21 = "Show Only Significant Sites"
            End If
    
        Else
    
            If ManFlag > -1 Then Call DoLegend
            Picture3.Enabled = True
            ShowSeqFlag = 0
            Label21 = "Show All Sequences"
        End If
    
        Call HScroll1_Change
        If ColDistInFile = 1 Then
            
            ReDim ColDist2(0)
            Timer7(1).Enabled = False
        End If
    ElseIf Index = 1 Then 'This is the button that cycles through the similarity window display
        

        If HomologyIndicator = 1 Then
            HomologyIndicator = 2
    
            If Pic11Flag = 0 Then
    
                Call HomologyWindow
    
                Pic11Flag = 1
            Else
                Picture11.Visible = True
            End If
    
        Else
            HomologyIndicator = 1
    
            If Pic4Flag = 0 Then
                Pic4Flag = 1
    
                Call HomologyWindow
    
            Else
                Picture11.Visible = False
            End If
    
        End If
        DontDoH1Inc = 1
        Call HScroll1_Change
        DontDoH1Inc = 0
        If ColDistInFile = 1 Then
            
            ReDim ColDist2(0)
            Timer7(1).Enabled = False
        End If
    ElseIf Index = 2 Then 'This is the button that cycles through the schematic sequence display options
        
        progno = 0
        progno = progno + DoScans(0, 6) + DoScans(0, 1) + DoScans(0, 0) + DoScans(0, 2) + DoScans(0, 3) + DoScans(0, 5) + DoScans(0, 4)
        SchemFlag = SchemFlag + 1
    
        If SchemFlag = 4 Then SchemFlag = 0
        
    
        If SchemFlag = 0 Then
            Label58.Caption = "Unique sequences"
            
        ElseIf SchemFlag = 1 Then
            Label58.Caption = "Methods"
            
        ElseIf SchemFlag = 2 Then
            Label58.Caption = "P-Values"
            
        ElseIf SchemFlag = 3 Then
            Label58.Caption = "Parental identities"
            
        End If
        Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -VScroll2.Value, Form1.Picture6)
        If RunFlag = 1 And ManFlag = -1 Then
            If RecSeq <> RelX Or PAVal <> RelY Then
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
            End If
        ElseIf ManFlag > -1 Then
    
            Call DoLegend
    
        End If
    ElseIf Index = 3 Then 'This is the button that cycles through the tree display
        NJF = 0
        CTF = 0
        Command3.SetFocus
        Screen.MousePointer = 11
    
        If RecombineFlag = 0 Then
    
            Call DrawTree
    
            Screen.MousePointer = 0
            Exit Sub
        End If
    
        Picture16.Picture = LoadPicture()
        TreeTypeFlag = TreeTypeFlag + 1
        If PPAVal < 0 Then
            PPAVal = Abs(PPAVal)
        End If
            If XoverList(PRecSeq, PPAVal).ProgramFlag > 0 And TreeTypeFlag = 1 Then
                TreeTypeFlag = 2
            End If
        
    
        If TreeTypeFlag > 2 Then
            TreeTypeFlag = 1
        End If
        
        If LongWindedFlag = 1 Then
            OI = F2TreeIndex
            F2TreeIndex = 1
            'Call ModSeqNum(0)
            If TreeTypeFlag <> 0 Then
                Call ModNextno
            End If
        End If
        
        
        Dim YAdjD As Integer
    
        YAdjD = 14 'Screen.TwipsPerPixelY
        OldFontSize = 8.25
    
        
        YAdjD = 14
        If TreeTypeFlag = 0 Then
            If FastNJFlag = 0 Then
                Label14 = "UPGMA ignoring recombination"
            Else
                Label14 = "FastNJ tree ignoring recombination"
            End If
            If TreeImage(0) = 0 Then
                
                
                
                Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
                Call DrawTree
                If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
                    TreeXUB = UBound(TreeX, 1)
                    TreeXInFileFlag = 1
                    oDir = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    FF = FreeFile
                    Open "RDP5TreeX" + UFTag For Binary As #FF
                    Put #FF, , TreeX()
                    Close #FF
                    ChDir oDir
                    ChDrive oDir
                    Erase TreeX
                    
                End If
                                
                TreeImage(0) = 1
                
            End If
            ExtraDX = DoTreeColour(Picture16, 0, 0)
            
            'DoTreeLegend treeblocksl(), TBLLen, Picture16, ExtraDx, YAdjD
            'Picture16.ForeColor = 0
        ElseIf TreeTypeFlag = 1 Then
            Dim aEN As Long, aBE As Long
            aEN = XoverList(RelX, RelY).Ending
            aBE = XoverList(RelX, RelY).Beginning
            If aEN = Len(StrainSeq(0)) Then
                EN = 1
            Else
                EN = aEN + 1
            End If
            If aBE = 1 Then
                BE = Len(StrainSeq(0))
            Else
                BE = aBE - 1
            End If
            
            
            If FastNJFlag = 0 Then
                'Label14 = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
                If aBE > aEN Then
                    Label14 = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(aEN + 1))) + " - " + Trim$(CStr(Decompress(aBE - 1))) + ")"
                Else
                    If aBE > 0 Then
                        Label14 = "UPGMA of regions derived from major parent (1 - " + Trim$(CStr(Decompress(aBE - 1))) + " and " + Trim$(CStr(Decompress(aBE + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                    Else
                        Label14 = "UPGMA of regions derived from major parent" ' (1 - " + Trim$(CStr(Decompress(aBE - 1))) + " and " + Trim$(CStr(Decompress(aBE + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                    
                    End If
                End If

            Else
                'Label14 = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
                If aBE > aEN Then
                    Label14 = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(aEN + 1))) + " - " + Trim$(CStr(Decompress(aBE - 1))) + ")"
                Else
                    Label14 = "FastNJ tree of regions derived from major parent (1 - " + Trim$(CStr(Decompress(aBE - 1))) + " and " + Trim$(CStr(Decompress(aEN + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                End If

            End If
            
            If TreeImage(1) = 0 Then
                OS = SpacerNo
    
                'Call RTSpacerFind
                Call RecUPGMAIV
                'ExtraDx = DoTreeColour(Picture16, 0, 1)
                
                TreeImage(1) = 1
                
            
            End If
    
        ElseIf TreeTypeFlag = 2 Then
            
            
            If FastNJFlag = 0 Then
                'Label14 = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
                If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                    Label14 = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
                Else
                    Label14 = "UPGMA of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                End If

            Else
                'Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
                If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                    Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
                Else
                    Label14 = "FastNJ tree of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                End If
            End If
            If TreeImage(2) = 0 Then
                'Call RTSpacerFind
    
                Call RecUPGMAII
                'ExtraDx = DoTreeColour(Picture16, 0, 2)
                TreeImage(2) = 1
                
            
            End If
            
    
        Else
            Label14 = "FastNJ tree with recombinant regions removed"
            If FastNJFlag = 0 Then
                Label14 = "FastNJ tree with recombinant regions removed"
            Else
                Label14 = "FastNJ tree with recombinant regions removed"
            End If
            If TreeImage(3) = 0 Then
                'Call RTSpacerFind
    
                Call RecUPGMAIII
    
                TreeImage(3) = 1
               
                '
            End If
            ExtraDX = DoTreeColour(Picture16, 0, 3)
            
        End If
        
        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, 0, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
        
        Screen.MousePointer = 0
        ProgressBar1.Value = 0
        Call UpdateF2Prog
        If LongWindedFlag = 1 Then
            If TreeTypeFlag <> 0 Then
                Call UnModNextno
                x = x
            End If
            'Call UnModSeqNum(0)
             F2TreeIndex = OI
        End If
    End If

    
End Sub

Private Sub Command6_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
If RelX > 0 Or RelY > 0 Then
    Picture3.Refresh
    Picture2.Refresh
End If
If Index = 2 Then

    If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
        Picture6.Refresh
        CurFlash = 0
        Timercheck(1) = 0
        Call Timer1_Timer
        HighlightFlag = 0
        RecSeq = 0
        PAVal = 0
        If RIMode = 1 Then
            Call MakeSummary
        End If
    End If
End If
End Sub

Private Sub Command7_Click()
    
    Command3.SetFocus
    If CurrentlyRunningFlag = 1 Then Exit Sub
    If RelX = 0 And RelY = 0 Then
    
    
        If TreeImage(TreeTypeFlag) = 0 Or SSPanel6(1).Visible = True Then
            CTF = 0
            SS = Abs(GetTickCount)
            Call StartTree
            EE = Abs(GetTickCount)
            TT = EE - SS
            TreeImage(0) = 1 '0.187
            
            DoneTree(0, 0) = 1
            
            If TreeTypeFlag = 0 Then
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
            End If
            Form1.Picture16.Refresh
            x = x
        Else
            Call Command4_Click(1)
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
            x = x
        End If
    Else
        Call Command17_Click
    End If
End Sub

Private Sub Command7_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Picture3.Refresh
    Picture2.Refresh
    If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command8_Click(Index As Integer)
    SSPanel6(2).Enabled = True
    
    If CLine = "" Or CLine = " " Then
        Command3.SetFocus
    End If
    If Index = 0 Then

        If RunFlag = 1 And ManFlag = -1 Then
            RIMode = 0
            VS4Max2 = VScroll4.Max
            VS4CV = VScroll4.Value
            VScroll4.Value = 0
            VScroll4.Max = VS4Max
            
            
            Command13(2).Caption = "Overview"
            Command13(2).ToolTipText = "Press for summarized information on recombination events 1 through " + Trim(Str(SEventNumber))
            'Picture2.Height = 2500
            If RelX > 0 Or RelY > 0 Then
                PAVal = RelY
                RecSeq = RelX
                Pic7GoonFlag = 1
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
                Pic7GoonFlag = 0
            
            End If
        ElseIf ManFlag > -1 Then

            Call DoLegend

        End If

        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        SSPanel6(2).Visible = False
    ElseIf Index = 1 Then
        If CurMatrixFlag = 8 Then
            Call MCXoverK(0)
        ElseIf CurMatrixFlag = 11 Then
            Call DrawLRDMat
        
        ElseIf CurMatrixFlag = 255 And (RelX > 0 Or RelY > 0) Then
            Call MCMatMnu_Click
        End If
        If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
        
    ElseIf Index = 2 Then
            VS4Max = VScroll4.Max
            VScroll4.Max = VS4Max2
            If VS4CV > VS4Max2 Then VS4CV = VS4Max2
            VScroll4.Value = VS4CV
            RIMode = 1
            Frame17.Visible = False
            Command13(2).Caption = "Recombination Info"
            If RelX > 0 Or RelY > 0 Then
                Command13(2).ToolTipText = "Press for detailed information on recombiation event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
            Else
                Command13(2).ToolTipText = "Press for detailed information on recombiation event 1"
            End If
            Picture2.Picture = LoadPicture()
            
            Call MakeSummary
            SSPanel6(0).Visible = True
            SSPanel6(1).Visible = False
            SSPanel6(2).Visible = False
    End If

End Sub

Private Sub Command8_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub Command9_Click()
    
'    For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
'    x = x
    'ButtonRepress = ButtonRepress + 1
    Command3.SetFocus
    If FastNJFlag = 1 Then
        Form2.Command8.Enabled = False
        Form2.Command9.Enabled = False
        Form1.Command5.Enabled = False
        Form1.Command9.Enabled = False
    End If
    

Call GoToNextEventMnu_Click
'For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
'    x = x
If FastNJFlag = 1 Then
   Form2.Command8.Enabled = True
   Form2.Command9.Enabled = True
   Form1.Command5.Enabled = True
    Form1.Command9.Enabled = True
End If

Form1.ProgressBar1 = 0
Call UpdateF2Prog
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
Form1.Refresh
    EE = Abs(GetTickCount)
    TT = EE - SS
    '35.6 s with 1200 3Kb long sequences and no treewin
    '48.17 with UPGMA treewin, 32.01 without
'    Exit Sub
'
'    If DebuggingFlag < 2 Then On Error Resume Next
'    NewDirName = App.Path + "\" + FNameII + "dir"
'    MkDir NewDirName
'    'Exit Sub
'
'    Dim Begin As Integer
'    Dim Ending As Integer
'
'    If RunFlag = 1 And ManFlag = -1 Then
'        DontPutForm2Ontop = 1
'        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
'        DontPutForm2Ontop = 0
'
'    ElseIf ManFlag > -1 Then
'
'        Call DoLegend
'
'    End If
'
'    'XOverList(precseq, paval).Beginning = 100
'    'XOverList(precseq, paval).Ending = 1000 'Len(strainseq(0)) - 1
'    ReDim RecombSeq(Nextno)
'    'Exit Sub
'    'Make sub sequences
'    'First make small recombinant section
'XX = CurDir
'    If PartFlag = 1 Then
'    ElseIf PartFlag = 2 Then
'
'        If XOverlist(PRecSeq, PPAVal).Beginning < XOverlist(PRecSeq, PPAVal).Ending Then
'            'find beginning
'            Y = XOverlist(PRecSeq, PPAVal).Beginning
'            'Do Until SeqComponents(Seq3, Y) = Seq3 Or Y = 1
'            Y = Y - 1
'            'Loop
'            Begin = Y + 1
'            Y = Y + 1
'
'            Do Until Y = XOverlist(PRecSeq, PPAVal).Ending + 1 Or Y >= Len(StrainSeq(0))
'                '
'                Y = Y + 1
'            Loop
'
'            'For X = Y To Len(strainseq(0))
'            Ending = Y
'
'            For X = 0 To Nextno
'                RecombSeq(X) = Mid$(StrainSeq(X), Begin, Ending - Begin)
'            Next 'X
'
'        Else ' If recombination overlaps the end of the sequence
'            Y = XOverlist(PRecSeq, PPAVal).Beginning
'            'Do Until SeqComponents(Seq3, Y) = Seq3 Or Y = 1
'            Y = Y - 1
'            'Loop
'            Begin = Y + 1
'            Y = Y + 1
'
'            For X = 0 To Nextno
'                RecombSeq(X) = Right$(StrainSeq(X), Len(StrainSeq(0)) - Begin)
'            Next 'X
'
'            Y = 1
'
'            Do Until Y = XOverlist(PRecSeq, PPAVal).Ending + 1
'                Y = Y + 1
'            Loop
'
'            Ending = Y
'
'            For X = 0 To Nextno
'                RecombSeq(X) = RecombSeq(X) + Left$(StrainSeq(X), Ending)
'            Next 'X
'
'        End If
'
'    End If
'
'    'If DebuggingFlag < 2 Then On Error Resume Next
'    OldDir$ = CurDir
'
'    Dim SeqDirName As String
'
'    TempA = Begin
'    TempB = Ending
'    SeqDirName = NewDirName + "\" + OriginalName(Seq3) + " " + CStr(Begin) + " TO " + CStr(Ending - 1)
'    MkDir SeqDirName
'    'ChDir = SeqDirName
'
'    Dim NewName As String
'
'    For X = 0 To Nextno
'        'NewName = originalname(X) + ".seq"
'
'        Do
'            Pos = InStr(1, OriginalName(X), "/", vbBinaryCompare)
'
'            If Pos <> 0 Then
'
'                If Pos < Len(OriginalName(X)) And Pos > 1 Then
'                    OriginalName(X) = Mid$(OriginalName(X), 1, Pos - 1) + "-" + Mid$(OriginalName(X), Pos + 1, Len(OriginalName(X)) - Pos)
'                ElseIf Pos = Len(OriginalName(X)) Then
'                    OriginalName(X) = Mid$(OriginalName(X), 1, Pos - 1) + "-"
'                ElseIf Pos = 1 Then
'                    OriginalName(X) = "-" + Mid$(OriginalName(X), Pos + 1, Len(OriginalName(X)) - Pos)
'                End If
'
'            Else
'                Exit Do
'            End If
'
'        Loop
'
'        ''**** all this stuff is now commented out - it was the individual sequences saved.
'        'NewName = SeqDirName + "\" + originalname(X) + ".seq"
'        'Open NewName For Output As #1
'        'Print #1, "ORIGIN"
'        'Write #1,
'        'Print #1, RecombSeq(X)
'        'Close #1
'    Next 'X
'
'    Dim AlignName As String
'
'    AlignName = OriginalName(Seq3) + " " + CStr(Begin) + " TO " + CStr(Ending - 1)
'    NewName = SeqDirName + "\" + AlignName + ".fas"
'    Open NewName For Output As #1
'
'    For X = 0 To Nextno
'        Print #1, ">" + OriginalName(X)
'        Print #1, RecombSeq(X)
'    Next 'X
'
'    Close #1
'    NewName = SeqDirName + "\" + AlignName + "Unmasked.fas"
'    Open NewName For Output As #1
'
'    For X = 0 To Nextno
'
'        If Maskseq(X) = 0 Then
'            Print #1, ">" + OriginalName(X)
'            Print #1, RecombSeq(X)
'        End If
'
'    Next 'X
'
'    Close #1
'    NewName = SeqDirName + "\" + AlignName + ".msd"
'    'Full Data set
'    Open NewName For Output As #1
'    Print #1, "FILE: Multiple_Sequence_Alignment"
'    Print #1, "PROJECT:"
'    Print #1, "NUMBER:" + CStr(Nextno + 1)
'    Print #1, "MAXLENGTH:" + CStr(Len(StrainSeq(0)))
'
'    Dim Temporiginalname() As String
'
'    ReDim Temporiginalname(Nextno)
'
'    Dim Addj As Integer
'
'    Addj = 65
'
'    For X = 0 To Nextno
'
'        If Len(OriginalName(X)) > 9 Then
'            Temporiginalname(X) = Mid$(OriginalName(X), 1, 8) + Chr$(Addj)
'            Addj = Addj + 1
'        Else
'            Temporiginalname(X) = OriginalName(X)
'        End If
'
'    Next 'X
'
'    Dim Namestring() As String
'
'    ReDim Namestring(Int((Nextno + 1) / 6) + 1)
'    Namestring(0) = "NAMES:"
'
'    For X = 1 To Int((Nextno + 1) / 6)
'        Namestring(X) = "      "
'    Next 'X
'
'    For X = 0 To Int((Nextno + 1) / 6)
'        Y = 0
'
'        Do Until Y = 6 Or (X * 6 + Y) > Nextno
'            Namestring(X) = Namestring(X) + " " + Temporiginalname(X * 6 + Y)
'            Y = Y + 1
'        Loop
'
'    Next 'X
'
'    'Print #1, "NAMES:"
'
'    For X = 0 To Int((Nextno + 1) / 6)
'        Print #1, Namestring(X)
'    Next 'X
'
'    Print #1, ""
'    Print #1, "ORIGIN"
'
'    Dim Addon As Integer
'
'    For X = 0 To Nextno
'        Addon = 10 - Len(Temporiginalname(X))
'        Temporiginalname(X) = Temporiginalname(X) + String$(Addon, 32)
'    Next 'X
'
'    'Save whole alignment in .msd format
'    '    For X = 1 To Int(Len(strainseq(0)) / 60)
'    '        For Y = 0 To Nextno
'    '            Print #1, Temporiginalname(Y) + Mid$(strainseq(Y), X * 60 - 59, 60)
'    '        Next 'Y
'    '        Print #1, ""
'    '    Next 'X '
'    '
'    '    For Y = 0 To Nextno
'    '        Print #1, Temporiginalname(Y) + Mid$(strainseq(Y), X * 60 - 59, Len(strainseq(0)) - (X * 60 - 60))
'    '    Next 'Y
'    '    Close #1
'
'    Dim NLen As Long
'
'    NLen = CLng(Len(RecombSeq(0)) / 60)
'
'    For X = 1 To NLen
'
'        For Y = 0 To Nextno
'            Print #1, Temporiginalname(Y) + Mid$(RecombSeq(Y), X * 60 - 59, 60) + "    "
'        Next 'Y
'
'        Print #1, ""
'    Next 'X
'
'    For Y = 0 To Nextno
'        Print #1, Temporiginalname(Y) + Mid$(RecombSeq(Y), X * 60 - 59, Len(RecombSeq(0)) - (X * 60 - 60)) + String$((60 - (Len(RecombSeq(0)) - (X * 60 - 60))), 32) '                                           "  '+ chr$(32)
'    Next 'Y
'
'    Close #1
'    'Exit Sub
'    '  Dim B As Integer
'    'Only unmaked
'
'    For X = 0 To Nextno
'
'        If Maskseq(X) = 0 Then
'            b = b + 1
'        End If
'
'    Next 'X
'
'    NewName = SeqDirName + "\" + AlignName + " Unmasked.msd"
'    Open NewName For Output As #1
'    Print #1, "FILE: Multiple_Sequence_Alignment"
'    Print #1, "PROJECT:"
'    Print #1, "NUMBER:" + CStr(b)
'    Print #1, "MAXLENGTH:" + CStr(Len(StrainSeq(0)))
'    'Dim Temporiginalname() As String
'    'ReDim Temporiginalname(Nextno)
'    'Dim Addj As Integer
'    Addj = 65
'    'Print #1, "NAMES:"
'
'    For X = 0 To Int(b / 6)
'        Print #1, Namestring(X)
'    Next 'X
'
'    Print #1, ""
'    Print #1, "ORIGIN"
'    'Save whole alignment in .msd format
'
'    For X = 1 To Int(Len(RecombSeq(0)) / 60)
'
'        For Y = 0 To Nextno
'
'            If Maskseq(Y) = 0 Then
'                Print #1, Temporiginalname(Y) + Mid$(RecombSeq(Y), X * 60 - 59, 60) + "    "
'            End If
'
'        Next 'Y
'
'        Print #1, ""
'    Next 'X
'
'    For Y = 0 To Nextno
'
'        If Maskseq(Y) = 0 Then
'            Print #1, Temporiginalname(Y) + Mid$(RecombSeq(Y), X * 60 - 59, Len(RecombSeq(0)) - (X * 60 - 60)) + String$((60 - (Len(RecombSeq(0)) - (X * 60 - 60))), 32)  '"                                              " ' + cstr(32)
'        End If
'
'    Next 'Y
'
'    Close #1
'
'    'command9.style = 1
'    'Form1.Command9.BackColor = Form2.Command4.BackColor
'    CurDir = OldDir$
End Sub

Private Sub Command9_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2.Visible = True And Form2.WindowState = 0 And Form2OnTopFlag = 0 And Form2.hwnd = GetForegroundWindow Then
    Dummy = SetTopMostWindow(Form2.hwnd, True)
    Form2OnTopFlag = 1
End If
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
        Picture6.Refresh
        CurFlash = 0
        Timercheck(1) = 0
        Call Timer1_Timer
        HighlightFlag = 0
        RecSeq = 0
        PAVal = 0
        If RIMode = 1 Then
            Call MakeSummary
        End If
    End If
End Sub

Private Sub CopyMatrixMnu_Click()
    Clipboard.Clear
    Clipboard.SetData Form1.Picture26.Image
End Sub

Private Sub CopySchmMnu_Click()

Call SchemDrawingEMF(0, SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag)
'Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, originalname(), -Form1.VScroll2.Value, Form1.Picture6)
Exit Sub
    Clipboard.Clear
    Offset = 400 * HAddjust

    Dim LPNT As POINTAPI

    'Picture11.BackColor = QBColor(15)
    Picture6.DrawMode = 13
    Picture6.AutoRedraw = True
    If SchemFlag = 0 Then
        Clipboard.SetData Picture6.Image
    ElseIf SchemFlag = 1 Then
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 90), BackColours, BF
        
        Picture6.Line (0 + Offset, 5)-(10 + Offset, 15), ProgColour(0), BF
        Picture6.Line (0 + Offset, 20)-(10 + Offset, 30), ProgColour(1), BF
        Picture6.Line (0 + Offset, 35)-(10 + Offset, 45), ProgColour(2), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 60), ProgColour(3), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 75), ProgColour(4), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 90), ProgColour(5), BF
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 5
        Picture6.Print "RDP"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 20
        Picture6.Print "GENECONV"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 35
        Picture6.Print "Bootscan"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 50
        Picture6.Print "MaxChi"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 65
        Picture6.Print "Chimaera"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 80
        Picture6.Print "SiScan"
        Clipboard.SetData Picture6.Image
    ElseIf SchemFlag = 2 Then
        'For curline = 10 To 110
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 200), BackColours, BF
        curline = 0
        Pict = Picture6.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        RCol = 255
        Pict = Picture6.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        BCol = 255
        Pict = Picture6.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        GCol = 255
        Picture6.ForeColor = 0
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 4
        MaxLogPVal = -Log10(LowestProb)
        Picture6.CurrentX = 25 + Offset
        Picture6.Print "-  " & Int(MaxLogPVal * 10) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 42
        Picture6.Print "-  " & (Int(((MinLogPValSch + MaxLogPVal) / 2 + MaxLogPVal) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 81
        Picture6.Print "-  " & (Int((MinLogPValSch + MaxLogPVal) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 119
        Picture6.Print "-  " & (Int((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 158
        Picture6.Print "-  " & Int(MinLogPValSch * 10) / 10
        Picture6.CurrentX = 2 + Offset
        Picture6.CurrentY = 170
        Picture6.Print "-Log(P-Val)"
        Clipboard.SetData Picture6.Image
        Picture6.CurrentX = 0
        Picture6.CurrentY = 0
    ElseIf SchemFlag = 3 Then
        'For curline = 10 To 110
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 200), BackColours, BF
        curline = 0
        Pict = Picture6.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        RCol = 255
        Pict = Picture6.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        BCol = 255
        Pict = Picture6.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        GCol = 255
        Picture6.ForeColor = 0
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 4
        Picture6.CurrentX = 25 + Offset
        Picture6.Print "-  " & Int(MinDistX * 100) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 42
        Picture6.Print "-  " & (Int(((MaxDistX + MinDistX) / 2 + MinDistX) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 81
        Picture6.Print "-  " & (Int((MaxDistX + MinDistX) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 119
        Picture6.Print "-  " & (Int((MaxDistX + (MaxDistX + MinDistX) / 2) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 158
        Picture6.Print "-  " & Int(MaxDistX * 100) / 100
        Picture6.CurrentX = -10 + Offset
        Picture6.CurrentY = 170
        Picture6.Print "Parental identity"
        Clipboard.SetData Picture6.Image
        Picture6.CurrentX = 0
        Picture6.CurrentY = 0
    End If

End Sub

Private Sub CpyEMFMnu_Click()
    CopyFlag = 1

    Call SaveWMFPlot
    
    If ManFlag = -1 Then
        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            
            Call FindSubSeqRDP
        
        ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            
            'Call FindSubSeqGC
        
        ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
            
            Call FindSubSeqBS
        
        ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
            
            Call FindSubSeqMC
       
        End If
            
    End If

End Sub

Private Sub CpyTreeMnu_Click()
Dim NHFlag As Integer, oDir As String
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "tmp2.emf"
    On Error GoTo 0
    EMFFName = "tmp2.emf"
    semfnameII = "tmp2.emf"
    'CurTree(0) = 1
    F2TreeIndex = TreeTypeFlag
    CurTree(F2TreeIndex) = CTF
    If TreeTypeFlag = 0 And CTF <> 0 Then
        Call GetNHFlag(TreeTypeFlag, CTF, NHFlag)
            'If CTF = 4 Then
            
    End If        '    NHFlag = 13
     Call NJEMF(NHFlag)

       

    Clipboard.Clear
    
    'If DebuggingFlag < 2 Then On Error Resume Next
    Clipboard.SetData LoadPicture("tmp2.emf"), 3
    KillFile "tmp2.emf"
    ChDir oDir
    ChDrive oDir
    'On Error GoTo 0
End Sub

Private Sub Detect1Mnu_Click()
If ConsensusProg <> 0 Then
    ConsensusProg = 0
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect2Mnu_Click()
If ConsensusProg <> 1 Then
    ConsensusProg = 1
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect3Mnu_Click()
If ConsensusProg <> 2 Then
    ConsensusProg = 2
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect4Mnu_Click()
If ConsensusProg <> 3 Then
    ConsensusProg = 3
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect5Mnu_Click()
If ConsensusProg <> 4 Then
    ConsensusProg = 4
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect6Mnu_Click()
If ConsensusProg <> 5 Then
    ConsensusProg = 5
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub Detect7Mnu_Click()
If ConsensusProg <> 6 Then
    ConsensusProg = 6
    Call IntegrateXOvers(0)
    If RelX > 0 Or RelY > 0 Then
     
        SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        SEN = SEN - 1
        If SEN > 0 Then
            RelX = BestEvent(SEN, 0)
            RelY = BestEvent(SEN, 1)
            'Form1.timer7(0).Enabled = True 'this goes to the next event
        End If
    Else
        'Call IntegrateXOvers(0)
    End If
    
    Call Command9_Click
End If
End Sub

Private Sub DisableAllMnu2_Click()
    Call DisableAllMnu_Click
End Sub

Private Sub DNASCHEMAMnu_Click()
'Call BrejMod5
End Sub

Private Sub EMergeMnu_Click()
F7Flag = 0
Form1.Enabled = False




Form7.Caption = "Merge Events"
OSM = Form1.ScaleMode
Form1.ScaleMode = 1
Form7.Top = Form1.SSPanel5.Top
Form7.Left = Form1.SSPanel5.Left
Form1.ScaleMode = OSM

Form7.Text1(1).Visible = True
Form7.ScaleMode = 3
Form7.ScaleHeight = 50
Form7.Label1(0).Top = 5
Form7.Label1(1).Top = Form7.Label1(0).Top
Form7.Text1(0).Top = Form7.Label1(0).Top
Form7.Text1(1).Top = Form7.Label1(0).Top

Form7.Label1(0).Width = 60
Form7.Label1(1).Width = Form7.Label1(0).Width
Form7.Text1(0).Width = 50
Form7.Text1(1).Width = Form7.Text1(0).Width
Form7.Command1(0).Top = Form7.Text1(0).Top + Form7.Text1(0).Height + 5
Form7.Command1(1).Top = Form7.Command1(0).Top
Form7.Command1(0).Width = Form7.Text1(0).Width
Form7.Command1(1).Width = Form7.Text1(0).Width
Form7.ScaleMode = 3
Form7.Label1(0).Left = 5
Form7.ScaleMode = 3
Form7.Text1(0).Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
Form7.Combo1.Visible = False
Form7.Text1(0).Visible = True
Form7.Text1(1).Visible = True
Form7.Label1(0).Visible = True
Form7.Label1(1).Visible = True

'If X = 12345 Then
    
    
    
    
    
    
    
    
    Form7.Label1(1).Left = Form7.Text1(0).Left + Form7.Text1(0).Width + 5
    Form7.Text1(1).Left = Form7.Label1(1).Left + Form7.Label1(1).Width + 5
    Form7.Command1(0).Left = Form7.Text1(1).Left
    Form7.Command1(1).Left = Form7.Command1(0).Left + Form7.Command1(0).Width
    Form7.Label1(0).Caption = "Merge event"
    Form7.Label1(1).Caption = "with event"
    If PAVal > -1 And RecSeq > -1 Then
        Form7.Text1(0).Text = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
        Form7.Text1(1).Text = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
    End If
'End If
CIndex = 0
Form7.Caption = "Merge Events"
Form7.Combo1.Visible = False
Form7.Visible = True
Form7.Text1(0).Visible = True
Form7.Text1(0).SetFocus
If PAVal > -1 And RecSeq > -1 Then
    If XoverList(Reseq, PAVal).Accept = 1 Then
        AcceptChangeFlag = 2
        Form1.Command10.Enabled = True
        
    ElseIf AcceptChangeFlag = 0 Then
        AcceptChangeFlag = 1
    End If
End If
End Sub

Private Sub FastNJMnu2_Click()
If FastNJFlag = 0 Then 'Or (TreeTypeFlag = 0 And Left(Form1.Label1, 6) <> "FastNJ") Then
    FastNJFlag = 1
    Form2.MakeFastNJMnu.Caption = "Make UPGMA the default tree drawing method"
    Form2.MakeFastNJMnu2.Caption = "Make UPGMA the default tree drawing method"
    Form1.FastNJMnu2.Caption = "Make UPGMA the default tree drawing method"
    For x = 0 To 3
        TreeImage(x) = 0
    Next x
    If TreeTypeFlag = 0 Then
        Form1.Label14 = "FastNJ tree ignoring recombination"
    ElseIf TreeTypeFlag = 1 Then
        If XoverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
            EN = 1
        Else
            EN = XoverList(RelX, RelY).Ending + 1
        End If
        If XoverList(RelX, RelY).Beginning = 1 Then
            BE = Len(StrainSeq(0))
        Else
            BE = XoverList(RelX, RelY).Beginning - 1
        End If
        'Form1.Label14 = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
            Form1.Label14 = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + ")"
        Else
            Form1.Label14 = "FastNJ tree of regions derived from major parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If

    ElseIf TreeTypeFlag = 2 Then
        'Form1.Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
        Else
            Label14 = "FastNJ tree of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If

    ElseIf TreeTypeFlag = 3 Then
        Form1.Label14 = "FastNJ tree of non-recombinant regions"
    End If
Else
    Form2.MakeFastNJMnu.Caption = "Make FastNJ the default tree drawing method"
    Form2.MakeFastNJMnu2.Caption = "Make FastNJ the default tree drawing method"
    Form1.FastNJMnu2.Caption = "Make FastNJ the default tree drawing method"
    FastNJFlag = 0
    For x = 0 To 3
        TreeImage(x) = 0
    Next x
    
    If TreeTypeFlag = 0 Then
        Form1.Label14 = "UPGMA ignoring recombination"
    ElseIf TreeTypeFlag = 1 Then
        If XoverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
            EN = 1
        Else
            EN = XoverList(RelX, RelY).Ending + 1
        End If
        If XoverList(RelX, RelY).Beginning = 1 Then
            BE = Len(StrainSeq(0))
        Else
            BE = XoverList(RelX, RelY).Beginning - 1
        End If
        'Form1.Label14 = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
            Form1.Label14 = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + ")"
        Else
            Form1.Label14 = "UPGMA of regions derived from major parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If
    ElseIf TreeTypeFlag = 2 Then
        'Form1.Label14 = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Label14 = "UPGMA tree of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
        Else
            Label14 = "UPGMA tree of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If

    ElseIf TreeTypeFlag = 3 Then
        Form1.Label14 = "FastNJ tree with recombinant regions removed"
    End If
    
    
End If
'If Form2.Visible = True Then
    Call MultTreeWin
'End If
'update picture16
'Form1.Picture16.Picture = LoadPicture()

If RelX > 0 Or RelY > 0 Then
    For x = 0 To 3
        If x = 1 Then
            Call ModNextno
        Else
            If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                Call UnModNextno
            End If
        End If
        
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
    Next x
End If


Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, 0, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)




x = x
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub FastNJMnu3_Click()
Dim oFastNJFlag
Call Deactivate
oFastNJFlag = FastNJFlag
FastNJFlag = 0
DoneTree(0, 0) = 0
Call FastNJMnu2_Click
FastNJFlag = oFastNJFlag
CTF = 0
TreeTypeFlag = 0
TreeImage(TreeTypeFlag) = 1
Form1.Label14 = "FastNJ tree ignoring recombination"
Form1.ProgressBar1.Value = 100
Command28.Visible = False
Screen.MousePointer = 0
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0

Call Reactivate
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
SSPanel6(1).Visible = True
SSPanel6(0).Visible = False
SSPanel6(2).Visible = False
End Sub

Private Sub File1Mnu_Click()
    OldFileFlag = 1

    Call Command1_Click

    OldFileFlag = 0
End Sub

Private Sub File2Mnu_Click()
    OldFileFlag = 2

    Call Command1_Click

    OldFileFlag = 0
End Sub

Private Sub File3Mnu_Click()
    OldFileFlag = 3

    Call Command1_Click

    OldFileFlag = 0
End Sub

Private Sub File4Mnu_Click()
    OldFileFlag = 4

    Call Command1_Click

    OldFileFlag = 0
End Sub


Private Sub FindSeqMnu_Click()

Call FindSequences
End Sub

Private Sub FindSeqMnu3_Click()
Call FindSeqMnu_Click
End Sub

Private Sub FindSeqmnu4_Click()
If SeqMnuFlag = 1 Then
    Rffflag = 2
    Call Command18_Click
    SeqMnuFlag = 0
Else
    Call FindSeqMnu_Click
End If
End Sub

Private Sub Form_Activate()
If LoadBusy = 1 Then Exit Sub
    If Form3.Visible = True Then
        Form3.ZOrder
    End If

    If Form5.Visible = True Then
        Form5.ZOrder
    Else
        ' Form1.Refresh
    End If
    
    Call LoadPairsScores
    
    If F2ontop = 1 And Form2.Visible = True Then
        DSP2Flag = 1
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DontPutForm2Ontop = 0
        DSP2Flag = 0
        Form2.ZOrder
    End If
    
    If RunFlag = 1 And ManFlag = -1 And (RelX <> RecSeq Or RelY <> PAVal) Then
        DSP2Flag = 1
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DontPutForm2Ontop = 0
        DSP2Flag = 0
    ElseIf ManFlag > -1 Then

        Call DoLegend

    End If

End Sub

Private Sub Form_Click()
If LoadBusy = 1 Then Exit Sub
    'Form1.Command26.Visible = True: Form1.Command26.Top = 0
    If CurrentlyRunningFlag = 1 Then Exit Sub
    If RunFlag = 1 And ManFlag = -1 Then
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DontPutForm2Ontop = 0
    ElseIf ManFlag > -1 Then

        Call DoLegend

    End If
F1MO = 1
End Sub

Private Sub Form_DblClick()

Form1.Enabled = True
'Call Reactivate
If LoadBusy = 1 Then Exit Sub
Command15.Visible = True

Exit Sub
F1MO = 1

If Command14.Visible = False Then
    Command14.Visible = True
    Text2.Visible = True
Else
    Command14.Visible = False
    Text2.Visible = False
End If

Exit Sub
Call Reactivate
Form2.SSPanel1(0).Enabled = True
Form2.SSPanel1(1).Enabled = True
Form2.SSPanel1(2).Enabled = True
Form2.SSPanel1(3).Enabled = True
'Call VisRD
'Call Build3SeqTableFromMacFile
Exit Sub



Form1.ProgressBar1.Value = 0
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
Form1.SSPanel2.Enabled = True
Form1.Picture8.Enabled = True
Form1.Picture10.Enabled = True
Form1.Picture5.Enabled = True
Form1.Command6(0).Enabled = True
Exit Sub

Call RedrawPlotAA(1)
'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
Picture20.Cls
Picture19.BackColor = RGB(255, 255, 255)
'Form1.Command26.Visible = True
Exit Sub
Command26.Caption = "Konrad's Button"
Command26.Top = 50
Command26.Left = 10000
Command26.Width = 1500
Command26.Visible = True
XX = NextNo
Exit Sub
A = 0
b = 0
For x = 0 To SEventNumber
    ZZ = 0
    For Y = 0 To AddNum - 2
        If Confirm(x, Y) > 0 Then
            ZZ = ZZ + 1
        End If
    Next Y
    If ZZ > 2 Then
        
            A = A + 1
        
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept <> 2 Then
                If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability < 0.0000001 Then
                    b = b + 1
                End If
            End If
        
    End If
Next x
x = x

'Seqgen with proper settings and full screen

'>0
'63,17,4,2,0
'140,106,58,33,23

'>1
'37,14,4,2,0
'119,101,57,32,23

'>2
'17,11,3,2,0
'98,86,56,32,23

'>3
'11
'33


'>0
'80 ,46, 8, 2, 1, 0
'132,101,69,40,31,22

'>1
'54 ,36, 8, 3, 1, 0
'97 ,86,63,40,31,22

'>2
'27 ,22, 7, 3, 1, 0
'75 ,72,59,40,31,22

'>3
'12 ,10, 5, 3, 1, 0
'56 ,56,50,36,29,22


x = x
Exit Sub

Frame17.Visible = True
'Command26.Visible = False
Exit Sub
Form2.Picture2(0).Enabled = True
    Form2.Picture2(1).Enabled = True
    Form2.Picture2(2).Enabled = True
    Form2.Picture2(3).Enabled = True
    
    Form1.SSPanel6(1).Enabled = True
    Form1.Picture16.Enabled = True
    
    Form2.Command2.Enabled = False
    Exit Sub
    
    Exit Sub
    SSPanel6(1).Enabled = True
    
    Picture16.Enabled = True
    'Exit Sub
    SSPanel5.Enabled = True
    Picture5.Enabled = True
    'Exit Sub
    'Close #1
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.SSPanel8.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    
    'Command27.Visible = True
    Picture1.Enabled = True
End Sub

Private Sub Form_Deactivate()
If LoadBusy = 1 Then Exit Sub
'ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - Form1.VScroll2.Value)
    If F2ontop = 2 Then
        DSP2Flag = 1
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(ProxButton, ProxShift, ProxX, ProxY)
        DontPutForm2Ontop = 0
        DSP2Flag = 0
    ElseIf F2ontop = 1 Then
    ElseIf RunFlag = 1 And ManFlag = -1 Then
        DontPutForm2Ontop = 1
        DSP2Flag = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DSP2Flag = 0
        DontPutForm2Ontop = 0
    ElseIf ManFlag > -1 Then

        Call DoLegend


    End If

End Sub

Private Sub Form_DragDrop(Source As Control, x As Single, Y As Single)
If LoadBusy = 1 Then Exit Sub
If Picture12.Visible = True Then
    Picture12.Top = x
    Picture12.Left = Y
End If
F1MO = 1

End Sub

Private Sub Form_GotFocus()
If LoadBusy = 1 Then Exit Sub
End Sub

Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer)
If LoadBusy = 1 Then Exit Sub
Call DoKeydown(KeyCode)
End Sub

Private Sub Form_LinkClose()
If LoadBusy = 1 Then Exit Sub
End Sub

Private Sub Form_Load()
    If LoadBusy = 1 Then Exit Sub
    
    Dim EN As Long, Offset As Long, LPS As Long, InString As String, NPos As Long, TSZ As String, C As Long, TNX As Long, TN As Long, lResult As Long, OnlyMid As Long, x As Long, Dummy As Long, Dummy1 As Variant, Dummy2 As Variant, LPos As Long, Pos2 As Long, LFX As Variant, DS As Long, Y As Long, Winner As Long, Max As Single, Z As Long, A As Long
    Dim NumP As Long, ReadOffset As Long, aX As Long, aY As Long, FF As Long, ZZString As String, OutString As String
    'lResult = AddFontResource(App.Path & "\COUR.TTF")
    'lResult = AddFontResource(App.Path & "\COURE.FON")
    'lResult = AddFontResource(App.Path & "\COUR.TTF")
    
    Picture1.Font = "Courier New"
    'Picture2.Font = "Ariel"
    vbClearLine = ""
    For x = 0 To 100
      vbClearLine = vbClearLine & vbBack
      x = x
    Next x
    
    P16BaseFontSize = Picture16.FontSize
    NUMXY = 3
    BusyWithTreeFlag = 0
    
    DSDFlag = 2
    ltPosY = -1: ltPosX = -1
    FastestFlag = 1
    F1VS1ScaleFactor = 1
    FastNJFlag = 0
    Form1.WindowState = 2
    Form1.ScaleMode = 1
    LastTop = -1
    LastBottom = -1
    ReDim StoreChanged(0)
    'ReDim TTDistance(0, 0)
    ReDim BreaksExist(2, 1, 0)
    ReDim FubValid(0, 0)
    ReDim SubValid(0, 0)
    ReDim SubDiffs(0, 0)
    ReDim ColDist2(0)
    ReDim RememberBPs(0, 0)
    ReDim PermArray(0, 0)
    ReDim ABCons(0)
    ReDim TreeTrace(0)
    ReDim XoverSeqNumTS(0)
    ReDim PermsCurrentXOver(0, 0)
    ReDim RefGroupName(0)
    ReDim ReferenceCols(0)
    ReDim FMat(0, 0)
    ReDim SMat(0, 0)
    ReDim BigTreeTraceEvent(0)
    ReDim BigTreeTraceEventU(0)
    SSChoice(1) = 2
    SSChoice(3) = 1
    SSChoice(4) = 4
    SSChoice(10) = 3
    SpaceAdjust = 1
    
    TripListSaveCO = 200
    Dim TBH As Long, TBW As Long
    'SafePath = strGetCommonAppDataPath
    
    'Sequence display colours
    '                Col1 = RGB(128, 128, 255)
'                Col2 = RGB(255, 128, 128)
'                Col3 = RGB(255, 0, 0)
'                Col4 = RGB(128, 0, 0)
'                Col5 = RGB(64, 64, 255)
                
    ReDim ColX(255)
    Dim ColInc As Long
    SeqColCatNum = 20
    ColInc = Int(SeqColCatNum * 0.3)
    ColInc = (160 - 64) / ColInc
    For x = 0 To Int(SeqColCatNum * 0.3)
        Y = 64 + x * ColInc
        ColX(x) = RGB(Y, Y, 255)
    Next x
    
    For x = Int(SeqColCatNum * 0.3) + 1 To Int(SeqColCatNum * 0.7)
        Y = 160 - (x - (Int(SeqColCatNum * 0.3) + 1)) * ColInc
        ColX(x) = RGB(176, 0, Y + 64)
    Next x
    
    For x = Int(SeqColCatNum * 0.7) + 1 To SeqColCatNum
        Y = 255 - (x - (Int(SeqColCatNum * 0.7) + 1)) * ColInc
        ColX(x) = RGB(Y, 128, Y)
    Next x
    
'    ColX(0) = RGB(64, 64, 255)
'    ColX(1) = RGB(96, 96, 255)
'    ColX(2) = RGB(128, 128, 255)
'    ColX(3) = RGB(160, 160, 255)
'    ColX(4) = RGB(255, 160, 160)
'    ColX(5) = RGB(255, 128, 128)
'    ColX(6) = RGB(255, 96, 96)
'    ColX(7) = RGB(255, 64, 64)
'    ColX(8) = RGB(255, 0, 0)
'    ColX(9) = RGB(198, 0, 0)
'    ColX(10) = RGB(160, 0, 0)
    
    Call GetTaskBarSize(TBH, TBW)
    If F1MDF = 0 Then
        Form1OWidth = Screen.Width + 8 * Screen.TwipsPerPixelX
        Form1OHeight = Screen.Height - TBH * Screen.TwipsPerPixelY
        Form1.Width = Screen.Width + 8 * Screen.TwipsPerPixelX
        Form1.Height = Screen.Height - TBH * Screen.TwipsPerPixelY
    End If
    TaskBarHeight = TBH
    
    Call MakeTrans 'makes the amino acid translation arrays
    Dim FString As String
    OnlyMid = 0
    MinSeqSize = 50
    ReDim FlashArray(7, 255)
    For x = 0 To 127
      FlashArray(0, x) = RGB(x * 2, 0, 0)
      FlashArray(0, 255 - x) = RGB(x * 2, 0, 0)
      FlashArray(1, x) = RGB(128 + x, 128, 128)
      FlashArray(1, 255 - x) = RGB(128 + x, 128, 128)
      FlashArray(2, x) = RGB(255, 255 - x / 2, 255 - x / 2)
      FlashArray(2, 255 - x) = RGB(255, 255 - x / 2, 255 - x / 2)
      FlashArray(3, x) = RGB(x * 2, 0, 255)
      FlashArray(3, 255 - x) = RGB(x * 2, 0, 255)
      FlashArray(4, x) = RGB(255 - x * 2, 0, 0)
      FlashArray(4, 255 - x) = RGB(255 - x * 2, 0, 0)
      FlashArray(5, x) = RGB(x * 2, 255, 0)
      FlashArray(5, 255 - x) = RGB(x * 2, 255, 0)
      FlashArray(6, x) = RGB(120 + x * 1.06, 120, 255)
      FlashArray(6, 255 - x) = RGB(120 + x * 1.06, 120, 255)
      FlashArray(7, x) = RGB(170 + x * 0.66, 200, 255)
      FlashArray(7, 255 - x) = RGB(170 + x * 0.66, 200, 255)
    Next x
    ReDim SwapAround(5, 2)
    SwapAround(0, 0) = 0: SwapAround(0, 1) = 1: SwapAround(0, 2) = 2
    SwapAround(1, 0) = 1: SwapAround(1, 1) = 0: SwapAround(1, 2) = 2
    SwapAround(2, 0) = 1: SwapAround(2, 1) = 2: SwapAround(2, 2) = 0
    SwapAround(3, 0) = 2: SwapAround(3, 1) = 1: SwapAround(3, 2) = 0
    SwapAround(4, 0) = 2: SwapAround(4, 1) = 0: SwapAround(4, 2) = 1
    SwapAround(5, 0) = 0: SwapAround(5, 1) = 2: SwapAround(5, 2) = 1
    
    Call MakeSeqCompressor4
    Call MakeSeqCompressor3b
    ReDim CompressedSeqs3(0, 0)
    ReDim oRecombNo(100), RecombNo(100)
    ReDim DoneTree(4, 3)
    ReDim YannWarn(10)
    'Make lookup tables
    ReDim LogisticRWeights(50)
    LogisticRWeights(0) = -0.221493480564801 'ListCorr(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(1) = 0.198059042804444 'SimScoreB(A) ',SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(2) = 0.47694187676506 ',PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(3) = -1.19170156329627 'PhPrScore(A) ',PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(4) = -0.662118715129604 'PhPrScore2(A) ',PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(5) = -0.073324984506151 'PhPrScore3(A) ',SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(6) = 0.278275927914112 ' SubScore(A),(A), (A),(A), (A),(A),(A),(A),(A), (A),(A),(A), (A),(A),(A), (A), (A),(A),(A), (A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(7) = 3.90955579434989E-02 'SSDist(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(8) = 0.171923472353337 'OUIndexA(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(9) = 1.28251876438303 'SubPhPrScore(A)  'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(10) = 0.110737973227501 'SubScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(11) = 0.657022997108668 'SubPhPrScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(12) = 0 'SRCompatF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(13) = 0 'SRCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(14) = -0.667869348836109 'RCompat(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(15) = 4.52654430461813E-02 'RCompat2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(16) = -7.66074920155802E-02 'RCompat3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(17) = 9.8562602742249E-03 'RCompat4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(18) = -0.564308725378125 'RCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(19) = 7.90517724262972E-02 'RCompatS2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(20) = -0.125884944836657 'RCompatS3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(21) = -1.31168789120815E-03 'RCompatS4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(22) = 0 'RCompatXF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(23) = 0 'RCompatXS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(24) = 3.48823768089962E-02 'RCompatC(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(25) = 7.86484767601049E-02 'RCompatD(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(26) = 0.237589605798859 'TrpScore(A) ', BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(27) = -0.534466307261027 'BadDists(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(28) = -0.181698547967207 'OUList(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(29) = 0.207711662146291 'ListCorr2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(30) = -0.167599547313453 'ListCorr3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(31) = 0 'Consensus0(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(32) = 0 'Consensus1(A) ' RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(33) = 0 'Consensus2(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(34) = 0.299719245514468 'OuCheck(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(35) = -2.82398619561912E-02 'SetTot0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(36) = 0 'SetTot1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(37) = 6.83441527081767E-02 'RankF0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(38) = -5.78153697308177E-02 'RankF1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRWeights(39) = 1.04731184047884 'dMax(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    
    ReDim LogisticRMean(50)
    LogisticRMean(0) = 94.753703298307 'ListCorr(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(1) = 0.139836378768451 'SimScoreB(A) ',SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(2) = 0.308942644483362 ',PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(3) = 0.450785431625802 'PhPrScore(A) ',PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(4) = 0.380701322059252 'PhPrScore2(A) ',PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(5) = 0.377303653130472 'PhPrScore3(A) ',SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(6) = 8.18823836102858 ' SubScore(A),(A), (A),(A), (A),(A),(A),(A),(A), (A),(A),(A), (A),(A),(A), (A), (A),(A),(A), (A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(7) = 0.135506508579351 'SSDist(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(8) = 0.276170669668918 'OUIndexA(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(9) = 0.468039860624635 'SubPhPrScore(A)  'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(10) = 1.87201758610624 'SubScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(11) = 0.391980326807605 'SubPhPrScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(12) = 0 'SRCompatF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(13) = 0 'SRCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(14) = 2.51971270119256 'RCompat(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(15) = 1.94468768242848E-02 'RCompat2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(16) = 9.45135935284797E-02 'RCompat3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(17) = 2.37157034442498E-03 'RCompat4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(18) = 2.52948044366608 'RCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(19) = 1.57149111833875E-02 'RCompatS2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(20) = 0.117108664831957 'RCompatS3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(21) = 2.46278458844133E-03 'RCompatS4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(22) = 0 'RCompatXF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(23) = 0 'RCompatXS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(24) = 0.301304103077308 'RCompatC(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(25) = 0.310404678508881 'RCompatD(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(26) = 7.07723513809836 'TrpScore(A) ', BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(27) = 1.22124927028604 'BadDists(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(28) = 1 'OUList(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(29) = 0.391625582311733 'ListCorr2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(30) = 0.189936681938537 'ListCorr3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(31) = 0 'Consensus0(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(32) = 0 'Consensus1(A) ' RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(33) = 0 'Consensus2(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(34) = -12.4935654866149 'OuCheck(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(35) = 3.3153771578684 'SetTot0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(36) = 0 'SetTot1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(37) = 60.8791828246184 'RankF0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(38) = 59.2486630597948 'RankF1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRMean(39) = 0.516577148373722 'dMax(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    
    ReDim LogisticRSD(50)
    LogisticRSD(0) = 78.538293906759 'ListCorr(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(1) = 0.326262512486461 'SimScoreB(A) ',SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(2) = 0.462057449786267 ',PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(3) = 0.427634493849759 'PhPrScore(A) ',PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(4) = 0.414563870244038 'PhPrScore2(A) ',PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(5) = 0.412486808965749 'PhPrScore3(A) ',SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(6) = 8.88233717750243 ' SubScore(A),(A), (A),(A), (A),(A),(A),(A),(A), (A),(A),(A), (A),(A),(A), (A), (A),(A),(A), (A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(7) = 0.285110396910441 'SSDist(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(8) = 0.447102259984826 'OUIndexA(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(9) = 0.275052388079838 'SubPhPrScore(A)  'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(10) = 2.27412701881716 'SubScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(11) = 0.293853326309016 'SubPhPrScore2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(12) = 0 'SRCompatF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(13) = 0 'SRCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(14) = 2.68799791364796 'RCompat(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(15) = 0.236868932363907 'RCompat2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(16) = 0.739992390821267 'RCompat3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(17) = 0.104395339914869 'RCompat4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(18) = 2.65482479829257 'RCompatS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(19) = 0.22243613726572 'RCompatS2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(20) = 0.817086226912926 'RCompatS3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(21) = 9.79135692400848E-02 'RCompatS4(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(22) = 0 'RCompatXF(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(23) = 0 'RCompatXS(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(24) = 1.03960164852443 'RCompatC(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(25) = 1.04901723137511 'RCompatD(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(26) = 9.81652972665419 'TrpScore(A) ', BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(27) = 1.63666030884619 'BadDists(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(28) = 0.816496580927726 'OUList(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(29) = 0.224267221677208 'ListCorr2(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(30) = 0.125993157141627 'ListCorr3(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(31) = 0 'Consensus0(A) 'SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(32) = 0 'Consensus1(A) ' RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(33) = 0 'Consensus2(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(34) = 56.6096336189074 'OuCheck(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(35) = 5.58509097072035 'SetTot0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(36) = 0 'SetTot1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(37) = 47.3395384326832 'RankF0(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(38) = 47.5947492984513 'RankF1(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    LogisticRSD(39) = 0.215900563043243 'dMax(A) ' Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)
    
    
    
    
    'Factorial & Bin P-Val tables
    
    Call MakeBiomialTable
    
    ReDim ProgColour(100)
    ReDim ProgcolourB(100)
    'epsilon = 1 / 100000
    ManFlag = -1
    AddNum = 9
    ReDim StoreLPV(AddNum - 1, 100)
    'Store sreen size variables
    oTwipPerPixX = Screen.TwipsPerPixelX
    oTwipPerPixY = Screen.TwipsPerPixelY
    oScreenHeight = Screen.Height
    oScreenWidth = Screen.Height
    
    'Set up colours
    'Colours for methods
    ProgColour(0) = RGB(255, 50, 50)
    ProgColour(1) = RGB(128, 128, 255)
    ProgColour(2) = RGB(0, 148, 84)
    ProgColour(3) = RGB(255, 176, 32)
    ProgColour(4) = RGB(255, 255, 128)
    ProgColour(5) = RGB(255, 128, 255)
    ProgColour(6) = RGB(64, 200, 200)
    ProgColour(7) = RGB(128, 50, 50)
    ProgColour(8) = RGB(128, 255, 0)
    ProgColour(9) = RGB(0, 148, 84)
    ProgColour(10) = RGB(255, 128, 0)
    ProgColour(11) = RGB(255, 255, 128)
    ProgColour(12) = RGB(255, 128, 255)
    ProgColour(13) = RGB(64, 200, 200)
    
    
    'Bacground blended colors
    ProgcolourB(0) = RGB(255, 50, 50)
    ProgcolourB(1) = RGB(128, 128, 255)
    ProgcolourB(2) = RGB(0, 148, 84)
    ProgcolourB(3) = RGB(255, 128, 0)
    ProgcolourB(4) = RGB(255, 255, 128)
    ProgcolourB(5) = RGB(255, 128, 255)
    ProgcolourB(6) = RGB(64, 200, 200)
    ProgcolourB(7) = RGB(128, 50, 50)
    ProgcolourB(8) = RGB(128, 255, 0)
    ProgcolourB(9) = RGB(0, 148, 84)
    ProgcolourB(10) = RGB(255, 128, 0)
    ProgcolourB(11) = RGB(255, 255, 128)
    ProgcolourB(12) = RGB(255, 128, 255)
    ProgcolourB(13) = RGB(64, 200, 200)
    
    'Default colour for labeling trees
    SelCol = RGB(255, 128, 128)
    Call DoHeatMaps
    ProgNames(0) = "RDP"
    ProgNames(1) = "GENECONV"
    ProgNames(2) = "BootScan"
    ProgNames(3) = "MaxChi"
    ProgNames(4) = "Chimaera"
    ProgNames(5) = "SiScan"
    ProgNames(6) = "3Seq"
    ProgNames(7) = "LARD"
    ProgNames(8) = "3Seq"
    TBS(0) = "Potential recombinant "
    TBS(1) = "Sequence with evidence of the same recombination event "
    TBS(2) = "Sequences with evidence of the same recombination event "
    TBS(3) = "Sequence with partial evidence of the same recombination event "
    TBS(4) = "Sequences with partial evidence of the same recombination event "
    TBS(5) = "Sequence with trace evidence of the same recombination event "
    TBS(6) = "Sequences with trace evidence of the same recombination event "
    TBS(7) = "Potential minor parent "
    TBS(8) = "Sequence used to infer unknown parent "
    TBS(9) = "Potential major parent "
    TBS(10) = "Sequence used to infer unknown parent "
    TBS(11) = "Fragment of potential recombinant resembling the minor parent"
    TBS(12) = "Minor parent-like part of sequence with evidence of the same event"
    TBS(13) = "Minor parent-like part of sequences with evidence of the same event"
    TBS(14) = "Minor parent-like part of sequence with partial evidence of the same event "
    TBS(15) = "Minor parent-like part of sequences with partial evidence of the same event "
    TBS(16) = "Minor parent-like part of sequence with trace evidence of the same event "
    TBS(17) = "Minor parent-like part of sequences with trace evidence of the same event "
    TBS(18) = "Fragment of potential recombinant resembling the major parent"
    TBS(19) = "Major parent-like part of of sequence with some evidence of the same event"
    TBS(20) = "Sequence with indirect evidence of the same recombination event"
    Dim r As Long, g As Long, b As Long, Bak As Long, Pict As Long

    Pict = Form1.hdc
    Bak = GetBkColor(Pict)
    FormColour = Bak
    PerMaxPval = 25
    MaxHits = 10
    P1NT = -1
    b = Int(Bak / 65536)
    g = Int((Bak - b * 65536) / 256)
    r = Int(Bak - b * 65536 - g * 256)
    'AV = ((B + G + R) / 3) / 205
    Do
        r = r + (220 - r) / 2
        g = g + (220 - g) / 2
        b = b + (220 - b) / 2

        If ((r + g + b) / 3) >= 200 And ((r + g + b) / 3) <= 220 Then Exit Do
    Loop
'Form1.BackColor = RGB(255, 255, 160)
    BkR = 220 'r '220 '192
    BkG = 220 'g '220 '192
    BkB = 220 'b '220 '192
    BackColours = RGB(BkR, BkG, BkB)
    Purple = RGB(CInt(BkR - BkR / 3), 0, CInt(BkB - BkB / 3))
    Green = RGB(0, CInt(BkG - BkG / 3), CInt(BkB - BkB / 3))
    Yellow = RGB(255, 255, 0)
    
    LYellow = RGB(CInt(BkR + (255 - BkR) / 8), CInt(BkR + (255 - BkG) / 8), CInt(BkB - BkB / 8))
    LPurple = RGB(CInt(BkR - BkR / 16), CInt(BkG - BkG / 8), CInt(BkB - BkB / 16))
    LGreen = RGB(CInt(BkR - BkR / 8), CInt(BkG - BkG / 16), CInt(BkB - BkB / 16))
    
    'vLYellow = RGB(CInt(BkR + (255 - BkR) / 16), CInt(BkR + (255 - BkG) / 16), CInt(BkB - BkB / 16))
    'vLPurple = RGB(CInt(BkR - BkR / 32), CInt(BkG - BkG / 16), CInt(BkB - BkB / 32))
    'vLGreen = RGB(CInt(BkR - BkR / 16), CInt(BkG - BkG / 32), CInt(BkB - BkB / 32))
    
    
    vLYellow = RGB(CInt(BkR + (255 - BkR) / 3), CInt(BkG + (255 - BkG) / 3), BkB)
    vLPurple = RGB(CInt(BkR + (255 - BkR) / 3), BkG, CInt(BkB + (255 - BkB) / 3))
    vLGreen = RGB(BkR, CInt(BkG + (255 - BkG) / 3), CInt(BkB + (255 - BkB) / 3))
    
    mYellow = RGB(225, 225, CInt(BkB - BkB / 2))
    mPurple = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
    mGreen = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 6))
    'EightthColour
    HalfColour = RGB(CByte(BkR - BkR / 4.5), CByte(BkG - BkG / 4.5), CByte(BkB - BkB / 4.5))
    QuaterColour = RGB(CByte(BkR - BkR / 3), CByte(BkG - BkG / 3), CByte(BkB - BkB / 3))
    ThreeQuaterColour = RGB(CByte(BkR + (255 - BkR) / 2), CByte(BkG + (255 - BkG) / 2), CByte(BkB + (255 - BkB) / 2))
    FourQuaterColour = RGB(CByte(BkR + (255 - BkR) / 4.2), CByte(BkG + (255 - BkG) / 4.2), CByte(BkB + (255 - BkB) / 4.2))
    RedBorder = RGB(255, 0, 0)
    Rejected = RGB(CByte(BkR - BkR / 10), CByte(BkG - BkG / 10), CByte(BkB - BkB / 10))
    FillColour = RGB(CByte(BkR - BkR / 12), CByte(BkG - BkG / 12), CByte(BkB - BkB / 12))
    
    'Bacground blended colors
    ProgcolourB(0) = RGB((255 + BkR) / 2, (50 + BkG) / 2, (50 + BkB) / 2)
    ProgcolourB(1) = RGB((128 + BkR) / 2, (128 + BkG) / 2, (255 + BkB) / 2)
    ProgcolourB(2) = RGB(0, (148 + BkG) / 2, (84 + BkB) / 2)
    ProgcolourB(3) = RGB((255 + BkR) / 2, (128 + BkG) / 2, 0)
    ProgcolourB(4) = RGB((255 + BkR) / 2, (255 + BkG) / 2, (128 + BkB) / 2)
    ProgcolourB(5) = RGB(255, 128, 255)
    ProgcolourB(6) = RGB((64 + BkR) / 2, (200 + BkG) / 2, (200 + BkB) / 2)
    ProgcolourB(7) = RGB((128 + BkR) / 2, (50 + BkG) / 2, (50 + BkB) / 2)
    ProgcolourB(8) = RGB((128 + BkR) / 2, (255 + BkG) / 2, 0)
    ProgcolourB(9) = RGB(0, (148 + BkG) / 2, (84 + BkB) / 2)
    ProgcolourB(10) = RGB((255 + BkR) / 2, (128 + BkG) / 2, 0)
    ProgcolourB(11) = RGB((255 + BkR) / 2, (255 + BkG) / 2, (128 + BkB) / 2)
    ProgcolourB(12) = RGB((255 + BkR) / 2, (128 + BkG) / 2, (255 + BkB) / 2)
    ProgcolourB(13) = RGB((64 + BkR) / 2, (200 + BkG) / 2, (200 + BkB) / 2)
    
    FlatDiff(66, 66) = 0:  FlatValid(66, 66) = 1
    FlatDiff(68, 68) = 0:  FlatValid(68, 68) = 1
    FlatDiff(72, 72) = 0:  FlatValid(72, 72) = 1
    FlatDiff(85, 85) = 0:  FlatValid(85, 85) = 1
    FlatDiff(66, 68) = 1: FlatDiff(68, 66) = 1: FlatValid(66, 68) = 1: FlatValid(68, 66) = 1
    FlatDiff(66, 72) = 1: FlatDiff(72, 66) = 1: FlatValid(66, 72) = 1: FlatValid(72, 66) = 1
    FlatDiff(66, 85) = 1: FlatDiff(85, 66) = 1: FlatValid(66, 85) = 1: FlatValid(85, 66) = 1
    FlatDiff(68, 72) = 1: FlatDiff(72, 68) = 1: FlatValid(68, 72) = 1: FlatValid(72, 68) = 1
    FlatDiff(68, 85) = 1: FlatDiff(85, 68) = 1: FlatValid(68, 85) = 1: FlatValid(85, 68) = 1
    FlatDiff(85, 72) = 1: FlatDiff(72, 85) = 1: FlatValid(85, 72) = 1: FlatValid(72, 85) = 1
    FlatDiff(46, 66) = 0: FlatDiff(66, 46) = 0: FlatValid(46, 66) = 0: FlatValid(66, 46) = 0
    FlatDiff(46, 68) = 0: FlatDiff(68, 46) = 0: FlatValid(46, 68) = 0: FlatValid(68, 46) = 0
    FlatDiff(46, 72) = 0: FlatDiff(72, 46) = 0: FlatValid(46, 72) = 0: FlatValid(72, 46) = 0
    FlatDiff(46, 85) = 0: FlatDiff(85, 46) = 0: FlatValid(46, 85) = 0: FlatValid(85, 46) = 0
    SSPanel16.BackColor = HalfColour
    Top = 0
    Left = 0
    MiDistance = 0
    MaDistance = 1

    
    
    ReDim VScoreMat(4, 4, 4, 4, 2)
    Dummy = MakeVScoreMat(VScoreMat(0, 0, 0, 0, 0))
    


    Dim ScreenTwipsPerPixelX  As Long

'    ScreenHeightX = Screen.Height
'    ScreenWidthX = Screen.Width
    ScreenTwipsPerPixelX = Screen.TwipsPerPixelX
    TwipPerPix = ScreenTwipsPerPixelX
    'ScreenHeightX = 11520
    'ScreenTwipsPerPixelX = 12
    ReDim FileList(4)
    
    ReDim NucMat(85)
    NucMat(66) = 1
    NucMat(68) = 2
    NucMat(72) = 3
    NucMat(85) = 4
    
    CLine = Command
    
    ReDim FoundMethods(1000, 20)

    'MsgBox (CLine)
    'SpacerFlag = 2
    Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor))
    If DatasetName <> "" Then
        Form1.Caption = Form1.Caption + DatasetName
    End If
    Form3.List1.Enabled = False

    Dim iniName As String
    
    iniName$ = App.Path + "\RDP.ini"
    If DebuggingFlag < 2 Then On Error Resume Next
    If Dir(iniName) <> "" Then
        Open iniName$ For Input As #1
    
        'HomologyIndicator = 0
        'FullWindowSize = 40
        Dim curdirx As String
        PHIWin = 100
        BSFileName = "RDP5bsfile2" + UFTag
        Input #1, curdirx$
        Input #1, DefExt
        Input #1, SpacerFlag, CircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, XOverWindowX, LowestProb, MCFlag
        Input #1, SHWinLen, GCIndelFlag, SHStep, GCtripletflag
        Input #1, GCOutfileName
        Input #1, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
        Input #1, GCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, GCMinFragLen, GCMinPolyInFrag
        Input #1, GCMinPairScore, GCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
        Input #1, BSStepWin, BSStepSize, BSCutOff, BSBootReps, BSRndNumSeed, BSSubModelFlag
        Input #1, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
        Input #1, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
        Input #1, AllowConflict, MCPermMaxP, MCSteplen, MCWinSize
        Input #1, DoScans(0, 0), DoScans(0, 1), DoScans(0, 2), DoScans(0, 3), DoScans(0, 4), DoScans(0, 5)
        Input #1, FileList(1), FileList(2), FileList(3), FileList(4)
        Input #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
        Input #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
        Input #1, MCWinFract, MCProportionFlag, MCTripletFlag, MCStripGapsFlag
        Input #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
        Input #1, VisRDWin, ModelTestFlag
        Input #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
        Input #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
        Input #1, TOTreeType, TOFreqFlag, TOModel
        Input #1, BSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
        Input #1, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
        Input #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
        Input #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
        Input #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, BSPValFlag, SSFastFlag, SSGapFlag, SSVarPFlag, SSOutlyerFlag, SSRndSeed, SSWinLen, SSStep, SSNumPerms, SSNumPerms2
        Input #1, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, CWinFract, CProportionFlag, CWinSize, Dummy1, Dummy2
        Input #1, PPWinLen, PPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
        Input #1, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
        Input #1, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
        Close #1
    Else
        curdirx$ = App.Path
    End If
    ReDim GCSeqRange(1)
    
    If PolishBPFlag > 1 Then PolishBPFlag = 1
    If ConservativeGroup > 1 Then
        ConservativeGroup = 0
    End If
    
    If GCIndelFlag = 2 Then GCIndelFlag = 0 'ban the treat each indel as a polymorphism option
    BSTreeStrat = 5
    
    
    Dim SetDef As Byte
    SetDef = 0
    If ntType > 1 Or ntType < 0 Then
        ntType = 0
    End If
    If MaxTemperature < 0 Or (MaxTemperature > 0 And MaxTemperature < 1) Or MaxTemperature > 1000 Then
        MaxTemperature = 37
    End If
    If SHWinLen < 10 Then
        SHWinLen = 400
        SHStep = 100
        SHTree = 1 '0=upgma, 1=nj, 2= ls, 3 = ml
        SHTModel = 0 '0=JC, 1 = K2p, 2 = ??, 3 = ML
        SHTRndSeed = 3 'random number seed
        SHOptMethod = 1 '0=phyml, 1 =raxml
        SHOrAUFlag = 0 '0=SH, 1=AU
    End If
    If SCHEMAPermNo < 50 Or SCHEMADistCO < 1 Or SCHEMADistCO > 80 Then
        SCHEMAPermNo = 100000
        SCHEMADistCO = 4.5
    End If
    If CircularFlag <> 0 And CircularFlag <> 1 Then
    
       CircularFlag = 0
       SetDef = 1
    End If
    If BSSubModelFlag < 0 Or BSSubModelFlag > 4 Then
        SetDef = 1
    End If
    If SSNumPerms < 10 Then
        SSNumPerms = 100
        SetDef = 1
    End If
    If SSNumPerms2 < 10 Then
        SSNumPerms2 = 1000
        SetDef = 1
    End If
    FullWindowSize = 40
    HomologyIndicator = 1
    
    If VisRDWin < 100 Or VisRDWin > 2000 Then
        VisRDWin = 400
    End If
    LRDWin = 0
    LRDWinLen = 400
    MCTripletFlag = 0
    GCtripletflag = 1 'yes i'm an idiot
    
    Dim NP As Long
    NP = 0
    For x = 0 To AddNum - 1
        NP = NP + DoScans(0, x)
    Next x
    
    If NP = 0 Or SetDef = 1 Then
        DoScans(0, 0) = 1
        DoScans(0, 1) = 1
        DoScans(0, 3) = 1
    End If
    
    
    
    If (TBNChains = 0 And TBNGens = 0) Or SetDef = 1 Then
        TBModel = 2
        TBGamma = 1
        TBGammaCats = 4
        TBNGens = 10000000
        TBNChains = 4
        TBSampFreq = 100
        TBTemp = 0.2
        TBSwapFreq = 1
        TBSwapNum = 1
    End If
    'Public TPTVRat As Double, TPGamma As Long, TPAlpha As Double, TPInvSites As Double, TPModel As Byte, xTPModel As Byte, TPBPFEstimate As Byte, xTPBPFEstimate As Byte
    If TPGamma = 0 Or SetDef = 1 Then
        TPInvSites = 0
        TPTVRat = 2
        TPGamma = 1
        TPAlpha = 2
        TPModel = 6
        TPBPFEstimate = 0
        BSTreeStrat = 5
        BSupTest = 0
    End If
    
    If BSupTest < 0 Or BSupTest > 3 Then
        BSupTest = 0
        
    End If
    If BSTreeStrat > 5 Or BSTreeStrat < 0 Then
        BSTreeStrat = 5
    End If
    
    If GPerms < 100 Then GPerms = 0
    If PermTypeFlag > 1 Then PermTypeFlag = 0
    
      '      .Combo1.AddItem "Compaibility matrix (IJ)"
      '  .Combo1.AddItem "Modularity matrix"
      '  .Combo1.AddItem "Recombination matrix"
      '  .Combo1.AddItem "Recombinant region count matrix"
      '  .Combo1.AddItem "Breakpoint matrix"
      '  .Combo1.AddItem "Breakpoint distribution plot"
    If LowestProb = 0 Then LowestProb = 0.05
    
    'LDHAT Variables
    If MCMCUpdates < 100000 Or SetDef = 1 Then
        BlockPen = 10
        StartRho = 30
        MCMCUpdates = 1000000
        FreqCo = 0.05
        FreqCoMD = 0.1
        GCFlag = 1
        GCTractLen = 1000
    End If
    If PPWinLen = 0 Or SetDef = 1 Then
        PPWinLen = 60
        PPStripGaps = 0
        IncSelf = 0
        PPSeed = 3
        PPPerms = 1000
    End If
    
    If CWinSize = 0 Or SetDef = 1 Then
        CWinFract = 0.1
        CProportionFlag = 0
        CWinSize = 60
        
    End If
    
    If CWinFract > 0.75 Then CWinFract = 0.75
    If SSWinLen = 0 Or SetDef = 1 Then
        SSFastFlag = 1
        SSGapFlag = 0
        SSVarPFlag = 2
        SSOutlyerFlag = 1
        SSRndSeed = 3
        SSWinLen = 200
        SSStep = 20
        SSNumPerms = 1000
        SSNumPerms2 = 100
    End If
    
    
    
    
    If TTVRat = 0 Or (TAfreq + TCFreq + TGFreq + TTFreq = 0) Or SetDef = 1 Then
        ModelTestFlag = 0
        TBSReps = 100
        TRndSeed = 3
        TTVRat = 2
        TModel = 0
        TOCoeffVar = 1
        TBaseFreqFlag = 0
        TAfreq = 0.25
        TCFreq = 0.25
        TGFreq = 0.25
        TTFreq = 0.25
        TPower = 2
        TNegBLFlag = 0
        TSubRepsFlag = 0
        TGRFlag = 0
        TRndIOrderFlag = 0
        RAxMLCats = 25
    End If
    
    If RAxMLCats > 100 Or RAxMLCats < 1 Then RAxMLCats = 25
    
    
    
    If TModel = 3 Then
        If TBSReps < 13 Then TBSReps = 13 'I need to do this to avoid a memory leak in DNADIST - I don't know why its leaking but it is.
    End If
    If BSCoeffVar = 0 Then BSCoeffVar = 1

    If TOCoeffVar = 0 Then TOCoeffVar = 1

    If DPCoeffVar = 0 Then DPCoeffVar = 1

    If curdirx$ = "" Or ShowPlotFlag > 4 Or SetDef = 1 Then
        MCFlag = 0
        ShowPlotFlag = 2
        CircularFlag = 1
        FullWindowSize = 40
        HomologyIndicator = 1
        LowestProb = 0.05
        SpacerFlag = 0
        XOverWindowX = 30
        ForcePhylE = 1
        PolishBPFlag = 1
        
        ConsensusProg = 1
        AllowConflict = 1
        RealignFlag = 1
    End If
    If XOverWindowX < 5 Then XOverWindowX = 5
    GCSeqTypeFlag = 0
    If GCOutfileName = "" Or SetDef = 1 Then
        DoScans(0, 0) = 1
        DoScans(0, 1) = 1
        DoScans(0, 2) = 0
        DoScans(1, 2) = 1
        DoScans(0, 3) = 1
        DoScans(0, 5) = 0
        DoScans(1, 5) = 1
        DoScans(0, 4) = 0
        
        GCIndelFlag = 0
        
        GCMonoSiteFlag = 0
        ReDim GCSeqRange(1)
        GCOutfileName = "tf"
        GCOutFlag = 0
        GCOutFlagII = 0
        GCSortFlag = 0
        
        GCOffsetAddjust = 0
        GCLogFlag = 0
        GCMissmatchPen = 1
        
        GCMinFragLen = 1
        GCMinPolyInFrag = 2
        GCMinPairScore = 2
        GCMaxOverlapFrags = 1
        GCNumPerms = 0
        
        
        GCtripletflag = 1
    End If
    GCPermPolyFlag = 0
    GCMaxPermPVal = 0.05
    GCMaxGlobFrags = 2000
    GCMaxPairFrags = 0
    GCEndLen = 0
    If BSStepWin < 10 Or SetDef = 1 Then
        BSPValFlag = 1
        BSStepWin = 200
        BSStepSize = 20
        BSCutOff = 0.7
        BSBootReps = 100
        BSRndNumSeed = 3
        BSSubModelFlag = 0
        BSFreqFlag = 0
        BSFreqA = 0.25
        BSFreqC = 0.25
        BSFreqG = 0.25
        BSFreqT = 0.25
        BSTTRatio = 2#
        
        
        
        
        BSCDecreaseStepFlag = 1
        BSCDStepSize = 10
       
        'BSCDBootReps = 200
        BSCDSpan = 100
        BSTypeFlag = 0
        
    End If

    If MCWinSize < 10 Or SetDef = 1 Then
        
        'MCMaxP = 0.05
        MCSteplen = 1
        MCWinSize = 70
    End If

    If MCWinFract = 0 Or SetDef = 1 Then
        MCWinFract = 0.1
        MCProportionFlag = 0
        MCTripletFlag = 0
        MCStripGapsFlag = 1
    End If
    If MCWinFract > 0.75 Then MCWinFract = 0.75
    If LRDStep = 0 Or SetDef = 1 Then
        LRDModel = 0
        LRDCategs = 0
        LRDShape = 0.5
        LRDTvRat = 2#
        LRDACCoeff = 1
        LRDAGCoeff = 1
        LRDATCoeff = 1
        LRDCGCoeff = 1
        LRDCTCoeff = 1
        LRDGTCoeff = 1
        LRDBaseFreqFlag = 1
        LRDAFreq = 0.25
        LRDCFreq = 0.25
        LRDGFreq = 0.25
        LRDTFreq = 0.25
        LRDCodon1 = 1
        LRDCodon2 = 1
        LRDCodon3 = 1
        LRDStep = 20
        LRDRegion = 1
    End If
    LRDRegion = 1
    If DPWindow = 0 Or SetDef = 1 Then
        DPModelFlag = 1
        DPWindow = 200
        DPStep = 20
        DPTVRatio = 2#
        DPBFreqFlag = 0
        DPBFreqA = 0.25
        DPBFreqC = 0.25
        DPBFreqG = 0.25
        DPBFreqT = 0.25
    End If

   

    If TOWinLen = 0 Or SetDef = 1 Then
        TOPFlag = 0
        TORndNum = 3
        TOModel = 0
        TOTreeType = 1
        TOPerms = 100
        TOWinLen = 200
        TOStepSize = 10
        TOSmooth = 10
        TOPower = 2
        TOPValCOff = LowestProb
        TOTvTs = 2
        TOFreqFlag = 0
        TOFreqA = 0.25
        TOFreqC = 0.25
        TOFreqG = 0.25
        TOFreqT = 0.25
    End If
    If SetDef = 1 Then
        AllowConflict = 1
    Else
        If AllowConflict < 0 Then AllowConflict = 0
        If AllowConflict > 1 Then AllowConflict = 1
        AllowConflict = Int(AllowConflict)
    End If
    
    If MatPermNo = 0 Or SetDef = 1 Then
        MatPermNo = 1000
        MatWinSize = 200
    End If
    
    Picture16.MouseIcon = Command1.MouseIcon
    If BSFreqA = 0 Or SetDef = 1 Then
        BSTypeFlag = 0
        BSFreqA = 0.25
        BSFreqC = 0.25
        BSFreqG = 0.25
        BSFreqT = 0.25
    End If
    
   Call SetChecks
   TManFlag = -1
   CurrentCheck = -1
   TestName(0) = "Consensus"
   TestName(1) = "Parsimony O"
   TestName(2) = "Conflict"
   TestName(3) = "SubPhPr"
   TestName(4) = "TreeSubDist"
   TestName(5) = "OuCheck"
   TestName(6) = "TreeSubPhPr"
   TestName(7) = "TreePhPr"
   TestName(8) = "PhPr"
   TestName(9) = "TrpScore"
   TestName(10) = "dMax(VisRD)"
   TestName(11) = "DistRank"
   TestName(12) = "O:E"
   TestName(13) = "SubDist"
   TestName(14) = "Parsimony I"
   TestName(15) = "SetDistT"
   TestName(16) = "SetDistP"
   TestName(17) = "O:E Dist"
    Text5.Text = XOverWindowX
    If DebuggingFlag < 2 Then On Error Resume Next
    If Dir(curdirx$) = "" Then
        ChDir App.Path
        ChDrive App.Path
    Else
        ChDir curdirx$
        ChDrive curdirx$
    End If
    On Error GoTo 0
    'SpacerFlag = 1
    RecombineFlag = 0
    ' CircularFlag = 1
    'WeightedFlag = 1
    RunFlag = 0
    NJFlag = 0
    ShowSeqFlag = 0
    CurMatrixFlag = 255
    'FullWindowSize = 40
    ' HomologyIndicator = 1
    'XOverWindowX = 10
    If LowestProb > 1 Then
    LowestProb = 0.05
    End If
    pLowestProb = LowestProb
    On Error GoTo 0
    'Call ResizeForm1
    Form3.Text2.Text = XOverWindowX
    
    With Form1

        If Screen.Height = 7200 Then

            If ScreenTwipsPerPixelX = 12 Then   'ie 800 X 600 resolution with large fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
            Else       'ie 640 X 480 resolution with small fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
            End If

        ElseIf Screen.Height = 9000 Then  'ie 800 X 600 resolution with small fonts
            HAddjust = 1
            VAddjust = 1
        ElseIf Screen.Height = 9216 Then  'ie 1024 X 758 resolution with large fonts
            VAddjust = 9316 / 9000
            HAddjust = Screen.Width / 12000
        ElseIf Screen.Height >= 11520 Then  'ie 1024 X 768 resolution with small fonts
            VAddjust = 11700 / 9000 '11520 / 9000
            HAddjust = Screen.Width / 12000
        Else
            VAddjust = Screen.Height / 9000
            HAddjust = Screen.Width / 12000
        End If

    End With

    'Frame1.Top = 75

    Dim LastPos As Long
    'Detects if program executed from command line - if did then do the right thing
    Dim RunCycle As Long, ProgCycle As Long
    
   
    
    Pos = InStr(1, CLine, "/pl", vbTextCompare)
    
    
    'if you run from the cline you must have an input file indicated
    
    If x = x Then
        If (CLine <> "" And CLine <> " ") And Pos = 0 Then
        
            Call LoadPairsScores
            If InStr(1, CLine, "-rdpf", vbTextCompare) > 0 Then
                Pos = InStr(1, CLine, "-rdpf", vbTextCompare)
                
                LPos = Pos + 6
                Do
                    Pos2 = InStr(LPos, CLine, " ", vbBinaryCompare)
                    If Pos2 = 0 Then Pos2 = Len(CLine)
                    InFileX = Trim(Mid(CLine, Pos + 5, Pos2 - (Pos + 4)))
                    RDPInName = InFileX
                    'xxx = (Mid(CLine, Pos + 2, Pos2 - (Pos + 1)))
                    LFX = 0
                    If DebuggingFlag < 2 Then On Error Resume Next
                    
                    Open InFileX For Input As #1
                    
                    LFX = LOF(1)
                    Close #1
                    
                    On Error GoTo 0
                    If LFX > 0 Then Exit Do
                    LPos = Pos2 + 1
                Loop
                
                Call Command1_Click
                    
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbCrLf & "Loaded" & Str(NextNo + 1) & " sequences (each " + Trim(Str(Len(StrainSeq(0)))) & " characters in length)       " & vbCrLf
                If SEventNumber > 0 Then
                    WriteToConsole vbCrLf & "Loaded recombination information data for" & Str(SEventNumber) & " unique recombination events       " & vbCrLf
                End If
                    
                Pos = InStr(1, CLine, "-ssin", vbTextCompare)
                If Pos > 0 Then
                    LPos = Pos + 6
                    Do
                        Pos2 = InStr(LPos, CLine, " ", vbBinaryCompare)
                        If Pos2 = 0 Then Pos2 = Len(CLine)
                        InFileX = Trim(Mid(CLine, Pos + 5, Pos2 - (Pos + 4)))
                        'xxx = (Mid(CLine, Pos + 2, Pos2 - (Pos + 1)))
                        LFX = 0
                        SSInName = InFileX
                        If DebuggingFlag < 2 Then On Error Resume Next
                        Open InFileX For Input As #1
                        
                        LFX = LOF(1)
                        Close #1
                        
                        On Error GoTo 0
                        If LFX > 0 Then Exit Do
                        LPos = Pos2 + 1
                    Loop
                    Call Command1_Click
                    
                    
                    'RDP5MLFile
                    
                    Pos = InStr(1, CLine, "-ssou", vbTextCompare)
                    If Pos > 0 Then
                       
                        LPos = Pos + 6
                        Pos2 = InStr(LPos, CLine, " ", vbBinaryCompare)
                        If Pos2 = 0 Then Pos2 = Len(CLine)
                        SSOutName = Trim(Mid(CLine, Pos + 5, Pos2 - (Pos + 4)))
                        x = x
                        
                    Else
                        SSOutName = InFileX + "SiteSetAssociation"
                    End If
                    SSAppendFlag = 1
                    Pos = InStr(1, CLine, "-ssov", vbTextCompare)
                    If Pos > 0 Then
                        SSAppendFlag = 0
                    End If
                    
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole "Making recombination breakpoint distribution plot" & vbCrLf & vbCrLf
                    
                    Call BPDistPltMnu_Click
                    
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    If SSAppendFlag = 0 Then
                        WriteToConsole "Site set vs Breakpoint position association test p-value written to " + SSOutName & vbCrLf & vbCrLf
                    Else
                        WriteToConsole "Site set vs Breakpoint position association test p-value appended to " + SSOutName & vbCrLf & vbCrLf
                    End If
                    Call Command12_Click(1)
                    Exit Sub
                End If
                
                
            End If
        
        
            If InStr(1, CLine, "-f", vbTextCompare) = 0 Or InStr(1, CLine, "-?", vbTextCompare) > 0 Or InStr(1, CLine, "\?", vbTextCompare) > 0 Or InStr(1, CLine, "-h", vbTextCompare) > 0 Or InStr(1, CLine, "/?", vbTextCompare) > 0 Or InStr(1, CLine, "/h", vbTextCompare) > 0 Or InStr(1, CLine, "\h", vbTextCompare) > 0 Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Use as follows: RDP5CL.exe -f<full alignment file name including extension>  -<optional command 1> -<optional commant 2>" & vbCrLf & vbCrLf
                
                WriteToConsole "Command options:" & vbCrLf
                
                WriteToConsole "-f <name>:" & vbTab & vbTab & "input alignment file name (and path if necessary)" & vbCrLf
                WriteToConsole "-rdpf" & vbTab & vbTab & "input .rdp file name (and path if necessary)" & vbCrLf
                WriteToConsole "-am:" & vbTab & vbTab & "optimize automasking for maximum recombination detection sensitivity" & vbCrLf
                WriteToConsole "-o:" & vbTab & vbTab & "optimize automasking for maximum recombination detection sensitivity" & vbCrLf
                WriteToConsole "-riddt:" & vbTab & vbTab & "use the original RDP5/4/3 decision tree to identify recombinants (Default)" & vbCrLf
                WriteToConsole "-ridlr:" & vbTab & vbTab & "use logstistic regression optimised decision weights to identify recombinants" & vbCrLf
                'WriteToConsole "-ridnn:" & vbTab & vbTab & "use a trained neural network to identify recombinants" & vbCrLf
                WriteToConsole "-ds:" & vbTab & vbTab & "dump detailed recombinant identification stats to .csv file" & vbCrLf
                WriteToConsole "-nor:" & vbTab & vbTab & "do not output detailed analysis results in .rdp5 format (outputting a .rdp5 file is default) " & vbCrLf
                WriteToConsole "-noc:" & vbTab & vbTab & "do not output summary analysis results in .csv format (outputting a summary .csv file is default)" & vbCrLf
                WriteToConsole "-dist:" & vbTab & vbTab & "save a recombination-free version of the input alignment where recombinant sequences are split nto their constituent parts" & vbCrLf
                WriteToConsole "-da:" & vbTab & vbTab & "save a recombination-free version of the input alignment where recombinant sequences are split nto their constituent parts" & vbCrLf
                WriteToConsole "-rsr:" & vbTab & vbTab & "save a recombination-free version of the input alignment with recombinant sequences removed" & vbCrLf
                WriteToConsole "-rbr:" & vbTab & vbTab & "save a recombination-free version of the input alignment with recombinationally derived fragments of sequence removed" & vbCrLf
                WriteToConsole "-sa:" & vbTab & vbTab & "split alignment at detected recombination breakpoint positions into recombination-free subregion alignments" & vbCrLf
                WriteToConsole "-rbdp:" & vbTab & vbTab & "make recombination breakpoint distribution plots (tests for recombination hot-/cold-spots)" & vbCrLf
                WriteToConsole "-rfmlt:" & vbTab & vbTab & "remove recombination-derived fragments of sequences and make a maximum likelihood tree (with the GTR-CAT model using RaXML)" & vbCrLf
                WriteToConsole "-distml:" & vbTab & "split recombinant sequences into constituent parts and make a maximum likelihood tree (with the GTR-CAT model using RaXML)" & vbCrLf
                WriteToConsole "-ssin <name>:" & vbTab & vbTab & "input siteset file name (and path if necessary)" & vbCrLf
                WriteToConsole "-ssou <name>:" & vbTab & vbTab & "output file name for siteset vs breakpoint clustering association test result (and path if necessary)" & vbCrLf
                WriteToConsole "-ssap:" & vbTab & vbTab & "append siteset result" & vbCrLf
                WriteToConsole "-ssov:" & vbTab & vbTab & "overwrite siteset result" & vbCrLf
                WriteToConsole "-rdp5ml <name>:" & vbTab & vbTab & "input .rdp5ml file name (and path if necessary)" & vbCrLf
               
                Call Command12_Click(1)
                
               ' WriteToConsole "RDP5 command line options:" & vbCrLf
            End If
        
            
            
            
            Pos = InStr(1, CLine, "-f", vbTextCompare)
            
            
            If Pos = 0 And InStr(1, CLine, "-?", vbTextCompare) = 0 And InStr(1, CLine, "\?", vbTextCompare) = 0 And InStr(1, CLine, "-h", vbTextCompare) = 0 And InStr(1, CLine, "/?", vbTextCompare) = 0 And InStr(1, CLine, "/h", vbTextCompare) = 0 And InStr(1, CLine, "\h", vbTextCompare) = 0 Then
               InFileX = CLine
               CLine = ""
            Else
            
                
                'scan command line
                
                '-f filename
                '-o automask for optimal recombination detection
                '-am automask for optimal recombination detection
                '-nordpfile don't output a .RDP file
                '-nocsvfile don't output a summary of detected recombination events in .csv format
                '-dist/-da output a distributed alignment where recombinant sequences are split into consituent parts
                '-sa split alignment into sub-alignments based on breakpoint positions
                '-rsr recombinant sequnecs removed
                '-rbr recombinant regions removed
                '-rbdp1 make a recombination breakpoint distribution plot and output in .csv format
                '-rbdp2 make a recombination breakpoint distribution plot and output a graphic of it .emf format
                '-rfmltree make a maximum likelihood tree (with the GTR-gamma model using RaXML) and output it in NH and emf format
                '-distmltree make a maximum liklelihood tree (with the GTR-gamma model using RaXML) from a distributed alignment and output it in .emf and NH format
                
                '-ds = dumpstats
                
                Dim oDirX As String, TSX As String
                If DebuggingFlag < 2 Then On Error Resume Next
    
                oDirX = CurDir
                ChDrive (App.Path)
                ChDir (App.Path)
                On Error GoTo 0
                
                Pos = InStr(1, CLine, "-riddt", vbTextCompare)
                If Pos > 0 Then
                    ConsensusStrat = 0
                End If
                Pos = InStr(1, CLine, "-ridlr", vbTextCompare)
                If Pos > 0 Then
                    ConsensusStrat = 1
                End If
                Pos = InStr(1, CLine, "-ridnn", vbTextCompare)
                If Pos > 0 Then
                    ConsensusStrat = 1
                End If
                
                Pos = InStr(1, CLine, "-f", vbTextCompare)
                If Pos > 0 Then
                    LPos = Pos + 3
                    Do
                        Pos2 = InStr(LPos, CLine, " ", vbBinaryCompare)
                        If Pos2 = 0 Then Pos2 = Len(CLine)
                        InFileX = Trim(Mid(CLine, Pos + 2, Pos2 - (Pos + 1)))
                        'xxx = (Mid(CLine, Pos + 2, Pos2 - (Pos + 1)))
                        LFX = 0
                        If DebuggingFlag < 2 Then On Error Resume Next
                        Open InFileX For Input As #1
                        LFX = LOF(1)
                        Close #1
                        
                        On Error GoTo 0
                        If LFX > 0 Then Exit Do
                        LPos = Pos2 + 1
                    Loop
                Else
                    InFileX = "infile"
                End If
                
                'Check for multiple datasets
                Open InFileX For Input As #1
                TSX = ""
                Dim StartLNum As Long
                StartLNum = 0
                Do While TSX = ""
                    StartLNum = StartLNum + 1
                    Line Input #1, TSX
                Loop
                
                Pos = InStr(1, TSX, "multiple datasets", vbTextCompare)
                If Pos > 0 Then
                   
                    DatasetNo = val(Trim(Right$(TSX, Len(TSX) - 17)))
                    'find the number of sequences and sequence length assuming a flat phylip format
                    Line Input #1, TSX
                    StartLNum = StartLNum + 1
                    If TSX = "" Then
                        Do While TSX = ""
                        Line Input #1, TSX
                        StartLNum = StartLNum + 1
                        Loop
                    End If
                    Dim SLenX As Long
                    LastPos = 0
                    Do
                        Pos = InStr(LastPos + 1, TSX, " ", vbBinaryCompare)
                        If Pos <> LastPos + 1 Then Exit Do
                        
                    Loop
                    NextNo = val(Trim(Left$(TSX, Pos))) - 1
                    SLenX = val(Trim(Right$(TSX, Len(TSX) - Pos)))
                Else
                    DatasetNo = 0
                End If
                
                Close #1
                
                Pos = InStr(1, CLine, "-rdp5ml", vbTextCompare)
                If Pos > 0 Then
                   
                    LPos = Pos + 8
                    Pos2 = InStr(LPos, CLine, " ", vbBinaryCompare)
                    If Pos2 = 0 Then Pos2 = Len(CLine)
                    RDP5MLFile = Trim(Mid(CLine, Pos + 7, Pos2 - (Pos + 6)))
                   
                Else
                    RDP5MLFile = ""
                End If
                
                
                If DatasetNo = 0 Then
                    Call Command1_Click
                    
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole vbCrLf & "Loaded" & Str(NextNo + 1) & " sequences (each " + Trim(Str(Len(StrainSeq(0)))) & " characters in length)       " & vbCrLf

                    
                     'XX = Nextno
                     
                     
                     
                     
                     
                    Pos = InStr(1, CLine, "-o", vbTextCompare)
                    If Pos > 0 Then
                        Call AutoMaskmnu_Click
                    Else
                        Pos = InStr(1, CLine, "-am", vbTextCompare)
                        If Pos > 0 Then
                            Call AutoMaskmnu_Click
                        End If
                    End If
                
                    ShortOutFlag = 100 'ie do a full scan and exit
                    
                    Pos = InStr(1, CLine, "-ds", vbTextCompare)
                    If Pos > 0 Then
                        StatsDumpFlag = 1
                    End If
                    
                    If RDP5MLFile <> "" Then
                        Dim OIFX As String
                        OIFX = InFileX
                        InFileX = RDP5MLFile
                        Call Command1_Click
                        InFileX = OIFX
                    End If
                    
                    Call Command22_Click
                    
                    
                    If StatsDumpFlag = 1 Or ExRecFlag = 203 Or ExRecFlag = 210 Then '203 is the orinal way josh and Phillip compared
                                                                                    '210 trieds to match "normal" rdp detected events to santasim simulated events
                        Call DumpStatsToFile(InFileX & "RecombIdentifyStats.csv")
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Detailed recombination identification statistics written to the file'" & InFileX & "RecombIdentifyStat.csv'" & vbCrLf & vbCrLf

                    End If
                    
                    Pos = InStr(1, CLine, "-nordpfile", vbTextCompare)
                    If Pos = 0 Then
                        Call WriteRDP5File(InFileX & ".rdp5")
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Detailed results of recombination analysis written to the file '" & InFileX & ".rdp5' (which can be opened in the GUI version of RDP5)" & vbCrLf & vbCrLf


                    End If
                    Pos = InStr(1, CLine, "-nocsvfile", vbTextCompare)
                    If Pos = 0 Then
                        Call MakeCSV(InFileX & ".csv", 6)
                        
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Summarized results of recombination analysis written to the file '" & InFileX & ".csv' (which can be opened in spreadseet programs like Microsoft excel)" & vbCrLf & vbCrLf

                    End If
                    Pos = InStr(1, CLine, "-padreml", vbTextCompare)
'                    If Pos <> 0 Then
'                        Call PADREML(InFileX & ".tre", 1)
'                    End If
                    Pos = InStr(1, CLine, "-dist", vbTextCompare)
                    If Pos <> 0 Then
                        Call SaveAlign(InFileX & " distributed alignment.fas", 0, OriginalName(), 17)
                
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Processed alignment with recombinants split into their constituent parts written to the file '" & InFileX & " distributed alignment.fas'" & vbCrLf & vbCrLf

                
                    Else
                        Pos = InStr(1, CLine, "-da", vbTextCompare)
                        If Pos <> 0 Then
                            Call SaveAlign(InFileX & " distributed alignment.fas", 0, OriginalName(), 17)
                            hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                            GetConsoleScreenBufferInfo hOutput, scrbuf
                            WriteToConsole "Processed alignment with recombinants split into their constituent parts written to the file '" & InFileX & " distributed alignment.fas'" & vbCrLf & vbCrLf

                        End If
                    End If
                    
                    Pos = InStr(1, CLine, "-rsr", vbTextCompare) 'remove recombinant sequences
                    If Pos <> 0 Then
                        Call SaveAlign(InFileX & " recombinant ssequences removed.fas", 0, OriginalName(), 1)
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Processed alignment with recombinant sequences removed written to the file '" & InFileX & " recombinant ssequences removed.fas'" & vbCrLf & vbCrLf

                    End If
                    
                    Pos = InStr(1, CLine, "-rbr", vbTextCompare) 'remove recombinant regions
                    If Pos <> 0 Then
                        Call SaveAlign(InFileX & " recombinant regions removed.fas", 0, OriginalName(), 3)
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Processed alignment with recombinant regions removed written to the file '" & InFileX & " recombinant regions removed.fas'" & vbCrLf & vbCrLf

                    End If
                    
                    Pos = InStr(1, CLine, "-sa", vbTextCompare)
                    If Pos <> 0 Then
                        SaveTxtFlag = 1129
                        Call SplitAliMnu_Click
                        SaveTxtFlag = 0
                    End If
                    
                    
                    
                    'Pos = InStr(1, CLine, "-rbdp", vbTextCompare) 'make a recombination breakpoint distribution plot and output a table of it .csv format
                    If InStr(1, CLine, "-rbdp", vbTextCompare) > 0 Or InStr(1, CLine, "-rbpdp", vbTextCompare) > 0 Then
                        
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Making recombination breakpoint distribution plots" & vbCrLf & vbCrLf
                        
                        SaveTxtFlag = 12
                        Call BPDistPltMnu_Click
                        Call SaveEMFMnu_Click
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Recombination breakpoint distribution plot written to thr file '" & InFileX & " breakpoint distribution.emf' (which can be opened in a graphics program)" & vbCrLf
                        Call SaveTxtMnu_Click
                        WriteToConsole "Recombination breakpoint distribution plot data written to thr file '" & InFileX & " breakpoint distribution.csv' (which can be opened in a spreadsheet program)" & vbCrLf
                        SaveTxtFlag = 22
                        Call BPDistPltMnu2_Click
                        Call SaveEMFMnu_Click
                        WriteToConsole "Recombination breakpoint distribution plot written to thr file '" & InFileX & " breakpoint cluster probability distribution.emf' (which can be opened in a graphics program)" & vbCrLf
                        Call SaveTxtMnu_Click
                        WriteToConsole "Recombination breakpoint distribution plot written to thr file '" & InFileX & " breakpoint cluster probability distribution.csv' (which can be opened in a spreadsheet program)" & vbCrLf
                        'Call SaveAlign(InFileX & " distributed.fas", 0, OriginalName(), 17)
                    End If
                    
'                    Pos = InStr(1, CLine, "-rbdp2", vbTextCompare) '-rbdp2 make a recombination breakpoint distribution plot and output a graphic of it .emf format
'                    If Pos <> 0 Then
'                        SaveTxtFlag = 12
'                        Call BPDistPltMnu_Click
'                        Call SaveEMFMnu_Click
'                        SaveTxtFlag = 22
'                        Call BPDistPltMnu2_Click
'                        Call SaveEMFMnu_Click
'                        'Call SaveAlign(InFileX & " distributed.fas", 0, OriginalName(), 17)
'                    End If
                    
                    
                    Pos = InStr(1, CLine, "-rfmlt", vbTextCompare) '-rfmltree make a maximum likelihood tree (with the GTR-CAT model using RaXML) and output it in NH and emf format
                    If Pos <> 0 Then
                        SaveTxtFlag = 22
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Making a tree using RAxML" & vbCrLf & vbCrLf

                        Call MLMnuAL2_Click
                        Call SaveTreeEmfMnu_Click
                        WriteToConsole "Tree written to the file '" & InFileX & " ML tree with recombinant regions removed.emf' (which can be opened in a graphics program)" & vbCrLf
                        Call SaveNHFMnu_Click
                        WriteToConsole "Tree written to the file '" & InFileX & " ML tree with recombinant regions removed.tre' (which can be opened in a program like Mega or Figtree)" & vbCrLf
                    End If
                    
                    Pos = InStr(1, CLine, "-distml", vbTextCompare) '-distmltree make a maximum liklelihood tree (with the GTR-CAT model using RaXML) from a distributed alignment and output it in .emf and NH format
                    If Pos <> 0 Then
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Making a tree using RAxML" & vbCrLf & vbCrLf
                        SaveTxtFlag = 23
                        Call MLMnuAR_Click
                        
                        Call SaveTreeEmfMnu_Click
                        WriteToConsole "Tree written to the file " & InFileX & " 'ML tree with recombinant regions separated.emf' (which can be opened in a graphics program)" & vbCrLf
                        Call SaveNHFMnu_Click
                        WriteToConsole "Tree written to the file " & InFileX & " ML tree with recombinant regions separated.tre (which can be opened in a program like Mega or Figtree)" & vbCrLf
                    End If
                    
                    'Do Brief Output
                    'Call DoBriefOut(InfileX & "-Recombinants.csv"
                
                
                
                    Call Command12_Click(1)
                    If DebuggingFlag < 2 Then On Error Resume Next
    
                    ChDir (oDirX)
                    ChDrive (oDirX)
                    On Error GoTo 0
                Else
                    'find the number of sequences and sequence length assuming a flat phylip format
                    
                    'example clines
                    '-f test.txt -nordpfile -nocsvfile
                    '-f test.txt -nordpfile -nocsvfile -hotspot
                    'replicate,window,scope,confidence,numh,h1a,h1b,h2a,h2b,h3a,h3b,h4a,h4b,h5a,h5b,h6a,h6b,h7a,h7b,h8a,h8b,h9a,h9b,h10a,h10b
                    Dim TSY As String, Resultfile() As Double, MethodX As Double, MethodNameX() As String, WSX As Long, MNum As Long
                    ReDim MethodNameX(100)
                    'winsize = MatWinSize
                    ReDim Resultfile(9, DatasetNo, 2, 1, 1, 10, 1) ' progno,dno, winsize, local/global, ci, hspos,start/end)
                    Open InFileX For Input As #200
                    For x = 1 To StartLNum
                        Line Input #200, TSX
                        
                    Next x
                    TSX = ""
                    Do While TSX = ""
                        Line Input #200, TSX
                    Loop
                    MNum = 2
                    '-f 4 -nordpfile -nocsvfile -hotspot
                    For DS = 1 To DatasetNo
                        ReDim StrainSeq(NextNo)
                        ReDim OriginalName(NextNo)
                        For x = 0 To NextNo
                            If SLenX > Len(TSX) Then
                                OriginalName(x) = Trim(Left$(TSX, 10))
                                StrainSeq(x) = Trim(Right$(TSX, Len(TSX) - Len(OriginalName(x))))
                            Else
                                OriginalName(x) = Trim(Left$(TSX, Len(TSX) - SLenX))
                                StrainSeq(x) = Trim(Right$(TSX, SLenX))
                            End If
                            
                            If EOF(200) Then Exit For
                            Line Input #200, TSX
                            
                        Next x
                        If EOF(200) Then
                        
                        Else
                            Line Input #200, TSX 'roll over to next dataset
                        End If
                        
                        
                        
                        For MethodX = 0 To MNum
                            
                            Call Command1_Click 'prepares the datasets
                            For x = 0 To 100
                                DoScans(0, x) = 0
                            Next x
                            
                            If MethodX = 1 Then
                                DoScans(0, 0) = 1
                                MethodNameX(MethodX) = "RDP.RDP"
                            ElseIf MethodX = 2 Then
                                DoScans(0, 1) = 1
                                MethodNameX(MethodX) = "RDP.GENECONV"
                            ElseIf MethodX = 0 Then
                                DoScans(0, 3) = 1
                                MethodNameX(MethodX) = "RDP.MAXCHI"
                            End If
                            
                            
                            Pos = InStr(1, CLine, "-o", vbTextCompare)
                            If Pos > 0 Then
                                Call AutoMaskmnu_Click
                            End If
                        
                            ShortOutFlag = 100 'ie do a full scan and exit
                            Call Command22_Click
                            Pos = InStr(1, CLine, "-nordpfile", vbTextCompare)
                            If Pos = 0 Then
                                Call WriteRDPFile(InFileX & " " & Trim(Str(DS)) & ".rdp")
                            End If
                            Pos = InStr(1, CLine, "-nocsvfile", vbTextCompare)
                            If Pos = 0 Then
                                Call MakeCSV(InFileX & " " & Trim(Str(DS)) & ".csv", 6)
                            End If
                            Pos = InStr(1, CLine, "-hotspot", vbTextCompare)
                                
                            If Pos > 0 Then 'do hotspot test
                                For WSX = 0 To 2
                                    If WSX = 0 Then
                                        MatWinSize = 50
                                    ElseIf WSX = 1 Then
                                        MatWinSize = 100
                                    ElseIf WSX = 2 Then
                                        MatWinSize = 200
                                    End If
                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                        Call RecombMapIIIS
                                    Else
                                        Call RecombMapIII
                                    End If
                                    If x = x Then ' ie order output
                                        'TSl95
                                        
                                        For Y = 1 To 10
                                            Winner = Y
                                            'sorting
                                            
                                            If x = 12345 Then
                                                Winner = -1
                                                Max = 0
                                                For x = 1 To HSNum
                                                    If HSCord(1, x) > Max Then
                                                        Winner = x
                                                        Max = HSCord(1, x)
                                                    End If
                                                    
                                                Next x
                                                HSCord(1, Winner) = 0
                                            End If
                                            'add to resultsfile
                                            'ReDim Resultfile(9, DatasetNo, 2, 1, 1, 10, 1) ' progno,dno, winsize, local/global, ci, hspos,start/end)
                                            Resultfile(MethodX, DS, WSX, 0, 1, Y, 0) = HSCord(3, Winner)
                                            Resultfile(MethodX, DS, WSX, 0, 1, Y, 1) = HSCord(4, Winner)
                                            Resultfile(MethodX, DS, WSX, 1, 0, Y, 0) = HSCord(5, Winner)
                                            Resultfile(MethodX, DS, WSX, 1, 0, Y, 1) = HSCord(6, Winner)
                                            Resultfile(MethodX, DS, WSX, 1, 1, Y, 0) = HSCord(7, Winner)
                                            Resultfile(MethodX, DS, WSX, 1, 1, Y, 1) = HSCord(8, Winner)
                                            
                                        Next Y
                                    Else
                                    
                                    
                                        'Add to results file
                                        For x = 1 To HSNum
                                            If HSCord(0, x) = 1 Then
                                                TSY = "Hot-spot,"
                                            Else
                                                TSY = "Cold-spot,"
                                            End If
                                            TSY = TSY + Str(HSCord(3, x)) + "," + Str(HSCord(4, x)) + "," + Str(HSCord(5, x)) + "," + Str(HSCord(6, x)) + "," + Str(HSCord(7, x)) + "," + Str(HSCord(8, x)) + ","
                                            'TSX = ""
                                        Next x
                                    End If
                                Next WSX
                            End If
                            
                        Next MethodX
                        Pos = InStr(1, CLine, "-hotspot", vbTextCompare)
                        
                        
                        'Do Brief Output
                        'Call DoBriefOut(InfileX & "-Recombinants.csv"
                    
                    
                    
                        
                        
                    Next DS
                    'Close #50
                    Pos = InStr(1, CLine, "-hotspot", vbTextCompare)
                    If Pos > 0 Then
                        'write outfiles
                        For x = 0 To MNum 'methods
                            TSY = InFileX + "." + MethodNameX(x) + ".csv"
                            Open TSY For Output As #50
                            For Z = 1 To DatasetNo
                                
                                For Y = 0 To 2 'windows
                                    
                                    For A = 0 To 1 'local/global
                                        
                                        For b = 0 To 1 ' 95/ 99
                                            TSY = Trim(Str(Z)) + ","
                                            If Y = 0 Then
                                                TSY = TSY + "50,"
                                            ElseIf Y = 1 Then
                                                TSY = TSY + "100,"
                                            ElseIf Y = 2 Then
                                                TSY = TSY + "200,"
                                            End If
                                            If A = 0 And b = 0 Then
                                                'skip the local95
                                            Else
                                                If A = 0 And b = 1 Then 'local99
                                                    TSY = TSY + "local,99,"
                                                    
                                                ElseIf A = 1 And b = 0 Then 'global95
                                                    TSY = TSY + "global,95,"
                                                ElseIf A = 1 And b = 1 Then 'global99
                                                    TSY = TSY + "global,99,"
                                                End If
                                                TN = 0
                                                TNX = 0
                                                For C = 1 To 10
                                                    
                                                    If Resultfile(x, Z, Y, A, b, C, 0) > 0 Or Resultfile(x, Z, Y, A, b, C, 1) > 0 Then
                                                        'TSY = TSY + Resultfile(MethodX, DS, WSX, 0, 1, y - 1, 0) = HSCord(3, Winner)
                                                        TNX = C
                                                        TN = TN + 1
                                                    End If
                                                Next C
                                                TSY = TSY + Trim(Str(TN)) + ","
                                                TSZ = ""
                                                For C = 1 To TNX
                                                     If Resultfile(x, Z, Y, A, b, C, 0) > 0 Or Resultfile(x, Z, Y, A, b, C, 1) > 0 Then
                                                        TSZ = TSZ + Trim(Str(Resultfile(x, Z, Y, A, b, C, 0))) + "," + Trim(Str(Resultfile(x, Z, Y, A, b, C, 1))) + ","
                                                     End If
                                                Next C
                                                TSY = TSY + TSZ
                                                TSY = Left(TSY, Len(TSY) - 1)
                                                Print #50, TSY
                                            End If
                                        Next b
                                        
                                    Next A
                                Next Y
                            Next Z
                            Close #50
                        Next x
                        
                        
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
    
                    ChDir (oDirX)
                    ChDrive (oDirX)
                    On Error GoTo 0
                    Call Command12_Click(1)
                        
                End If
            End If
        ElseIf CLine <> "" And Pos > 0 Then
            'this is for David's power sims
            
            'Parse the command-line
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir (App.Path)
            ChDrive App.Path
            On Error GoTo 0
            Pos = InStr(1, CLine, " ", vbBinaryCompare)
    
            If Pos > 0 Then
                InFileX = Left$(CLine, Pos - 1)
                LastPos = Pos + 1
                'Pos = InStr(LastPos, CLine, " ", vbBinaryCompare)
    
                'If Pos > 0 Then
                '    OutFileX = Mid$(CLine, LastPos, Pos - LastPos)
                '    LastPos = Pos + 1
                'Else
                '    OutFileX = "outfile"
                'End If
                OutFileX = InFileX + ".csv"
                
                Dim PString As String
                'Check for method switches
                
                
                'Pos = InStr(1, CLine, "/m", vbTextCompare)
                If Pos > 0 Or x = x Then
                    'Set method flags
                    
                    NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                    If NPos = Pos + 2 Then
                        Do While NPos = Pos + 2
                            Pos = Pos + 1
                            NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                        Loop
                    
                    ElseIf NPos = 0 Then
                        NPos = Len(CLine)
                    End If
                    PString = Mid(CLine, Pos + 1, NPos - Pos)
                    
                    Pos = InStr(1, PString, "/a", vbTextCompare)
                    If Pos > 0 Then
                        DoScans(0, 0) = 1
                        DoScans(0, 1) = 1
                        DoScans(0, 2) = 1
                        DoScans(1, 2) = 1
                        DoScans(0, 3) = 1
                        DoScans(0, 4) = 1
                        DoScans(0, 5) = 1
                        DoScans(1, 5) = 1
                        DoScans(0, 8) = 1
                    Else
                        DoScans(0, 0) = 0
                        DoScans(0, 1) = 0
                        DoScans(0, 2) = 0
                        DoScans(1, 2) = 0
                        DoScans(0, 3) = 0
                        DoScans(0, 4) = 0
                        DoScans(0, 5) = 0
                        DoScans(1, 5) = 0
                        DoScans(0, 8) = 0
                        
                        Pos = InStr(1, PString, "/r", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 0) = 1 Else DoScans(0, 0) = 0
                        Pos = InStr(1, PString, "/g", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 1) = 1 Else DoScans(0, 1) = 0
                        Pos = InStr(1, PString, "/b", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 2) = 1: DoScans(1, 2) = 1 Else DoScans(0, 2) = 0
                        Pos = InStr(1, PString, "/m", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 3) = 1 Else DoScans(0, 3) = 0
                        Pos = InStr(1, PString, "/c", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 4) = 1 Else DoScans(0, 4) = 0
                        Pos = InStr(1, PString, "/s", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 5) = 1: DoScans(1, 5) = 1 Else DoScans(0, 5) = 0
                        Pos = InStr(1, PString, "/t", vbTextCompare)
                        If Pos > 0 Then DoScans(0, 8) = 1 Else DoScans(0, 5) = 0
                    End If
                Else
                    DoScans(0, 0) = 1
                    DoScans(0, 1) = 1
                    DoScans(0, 2) = 1
                    DoScans(1, 2) = 1
                    DoScans(0, 3) = 1
                    DoScans(0, 4) = 1
                    DoScans(0, 5) = 1
                    DoScans(1, 5) = 1
                    DoScans(0, 8) = 1
                    
                End If
                
                
                ShortOutFlag = 1
                
    
            Else
                InFileX = CLine
                OutFileX = "Outfile"
            End If
            
            'Check to see if infile has multiple datasets
            
            InString = String(10000, " ")
            'Close #1
            Open InFileX For Input As #1
            Line Input #1, InString
            
            InString = LCase(InString)
            If Left$(InString, 17) = "multiple datasets" Then
                
                Dim LenSeq As Long, InSeq As String
                LastPos = 20
                
                Pos = InStr(LastPos, InString, Chr(10), vbBinaryCompare)
                If Pos > 0 Then
                    Close #1
                    DatasetNo = (Mid(InString, LastPos, Pos - LastPos))
                    Pos = InStr(Pos + 2, InString, Chr(10), vbBinaryCompare)
                    Do While Pos - LastPos <= 2
                        LastPos = Pos
                        Pos = InStr(LastPos + 2, InString, Chr(10), vbBinaryCompare)
                    Loop
                    Dim RS As Long
                    RS = LastPos
                    PString = Mid(InString, LastPos, Pos - LastPos)
                    
                Else
                    Pos = InStr(15, InString, " ", vbBinaryCompare)
                    'Do
                        If Pos > 0 Then
                        'zz = right(InString, Len(InString) - Pos)
                            DatasetNo = val(Right(InString, Len(InString) - Pos))
                          
                        End If
                        LastPos = Len(InString) + 2
                        Line Input #1, PString
                    'Loop
                    x = x
                End If
                LPS = Len(PString)
                PString = Trim(PString)
                Pos = InStr(1, PString, " ", vbBinaryCompare)
                If Pos > 0 Then
                    NextNo = val(Left(PString, Pos)) - 1
                    LenSeq = val(Right(PString, Len(PString) - Pos))
                    LastPos = LastPos + LPS + 2
                End If
                
               
                
                'nr.dat testout /m r /o b
                
                    If x = x Then
                        If x = 12345 Then 'davids stuff
                            LastPos = Pos + 1
                            Pos = InStr(LastPos, InString, " ", vbBinaryCompare)
                            NextNo = CDbl(Mid(InString, LastPos, Pos - LastPos)) - 1
                            LastPos = Pos + 1
                            Pos = InStr(LastPos, InString, Chr(10), vbBinaryCompare)
                            LenSeq = CDbl(Mid(InString, LastPos, Pos - LastPos))
                            LastPos = Pos + 11
                        
                        End If
                    End If
                
                InSeq = String(LenSeq, " ")
                ReDim OriginalName(NextNo)
                ReDim StrainSeq(NextNo)
                OutFileX = OutFileX '+ ".csv"
                Open OutFileX For Output As #20
                Print #20, "DatasetNumber, RDP, Geneconv, Bootscan, Maxchi, Chimaera, Siscan, Phylpro, LARD, 3Seq"
                Close #20
                FString = Left(OutFileX, Len(OutFileX) - 4) & "-Detailed.csv"
                
                Open FString For Output As #30
                Print #30, "DataSetNumber,Sequence Number,Recombinant?"
                Close #30
                
                ShortOutFlag = 0
                
                For x = 1 To DatasetNo
                     ReDim ShortOutput(AddNum)
                            'infile.txt outfile s
                    If Offset < 0 Then
                        
                        For Y = 0 To NextNo
                            If Y = 0 Then
                        
                            Else
                                Line Input #1, InString
                            End If
                            Pos = InStr(1, InString, " ", vbBinaryCompare)
                            OriginalName(Y) = Trim(Left(InString, Pos))
                            StrainSeq(Y) = Trim(Right(InString, Len(InString) - Pos))
                           ' xxx = Right(StrainSeq(Y), 20)
                            x = x
                        Next Y
                        Do
                            If EOF(1) Then Exit Do
                            Line Input #1, InString
                            If Left(InString, Len(OriginalName(0))) = OriginalName(0) Then
                                Exit Do
                            End If
                        Loop
                    Else
                        Close #1
                        Open InFileX For Binary Access Read As #1
                        If x = x Then '
                            If x = 1 Then LastPos = LastPos + 11
                            For Y = 0 To NextNo
                                OriginalName(Y) = "S" & Trim(Str(Y))
                                Get #1, LastPos, InSeq
                                StrainSeq(Y) = InSeq
                                ZZString = Right(InSeq, 10)
                                'ZZ = Len(StrainSeq(0))
                                LastPos = LastPos + 12 + LenSeq
                                'for alldata.txt the offset must be 12
                                'LastPos = LastPos + 12 + LenSeq
                            Next Y
                             LastPos = LastPos + 9
                       'X = X
                        End If
                        Close #1
                    End If
                    
                    BackUpNextno = NextNo
                    Call Command1_Click
                    
                    If x = x Then
                    
                        'ShortOutFlag = 1 ' Use this if you just want yes/no
                        ShortOutFlag = 50 'use this if you want daughter ID
                        Call Command22_Click
                        'If ShortOutFlag = 1 Then
                            OutString = Str(x)
                            For Y = 0 To AddNum - 1
                                OutString = OutString & "," & Trim(Str(ShortOutput(Y)))
                                
                            Next
                        
                        
                            ReDim ShortOutput(AddNum - 1)
                        'End If
                        FF = FreeFile
                        'Print #FF, OutString
                        'Close #21
                        'Open OutFileX For Output As #21
                        Open OutFileX For Append As #20
                        Print #20, OutString
                        Close #20
                        OutString = ""
                        Dim ParentArray() As String, MD1 As String, MD2 As String, NS As Long
                        ReDim ParentArray(NextNo)
                        For A = 1 To SEventNumber
                            aX = BestEvent(A, 0)
                            aY = BestEvent(A, 1)
                            NS = 0
                            For b = 0 To AddNum - 1
                                If Confirm(A, b) > 0 Then
                                    NS = NS + 1
                                End If
                            
                            Next b
                            If XoverList(aX, aY).Accept <> 2 And NS > ConsensusProg And XoverList(aX, aY).MissIdentifyFlag <> 3 And XoverList(aX, aY).MissIdentifyFlag <> 13 Then
                                MD1 = ""
                                MD2 = ""
                                If XoverList(aX, aY).MissIdentifyFlag >= 10 Then
                                    If (DScores(0, 1, A) / (DScores(0, 0, A) + DScores(0, 1, A) + DScores(0, 2, A))) > 0.3 Then
                                        MD1 = "*"
                                    End If
                                    If (DScores(0, 2, A) / (DScores(0, 0, A) + DScores(0, 1, A) + DScores(0, 2, A))) > 0.3 Then
                                        MD2 = "*"
                                    End If
                                End If
                                
                                
                                
                                
                                
                                OutString = Trim(Str(XoverList(aX, aY).MajorP + 1)) + MD1 + "--" + Trim(Str(XoverList(aX, aY).MinorP + 1)) + MD2
                                For b = 0 To NextNo
                                    If Daught(A, b) > 0 And ParentArray(b) = "" Then
                                        ParentArray(b) = OutString
                                    End If
                                Next b
                            End If
                            x = x
                            
                        Next A
                        Open FString For Append As #30
                        
                        For A = 0 To NextNo
                            
                            If A = 0 Then
                                OutString = Str(x) + ","
                            Else
                                OutString = ","
                            End If
                            OutString = OutString + Str(A + 1) + ","
                            If ParentArray(A) = "" Then
                                OutString = OutString + "0,"
                            Else
                                OutString = OutString + ParentArray(A) + ","
                            End If
                            Print #30, OutString
                        Next A
                        Print #30, ""
                        Close #30
                        x = x
                        
                    End If
                    'OutString = Str(NumIn) + "," + OutString
                    
                    
                    'DoEvents
                   'AllData-64.txt s
                Next x
                Close #20
                End
            End If
        End If
    Else
    'this is for David's breakpoint sims
        If CLine <> "" Then
            For RunCycle = 0 To 11
                For ProgCycle = 6 To 7
                'If RunCycle = 1 Then Exit For
                
                
                    If RunCycle = 0 Then
                        CLine = "sim3_nonreciprocal_ancient_01.dat sim3_nonreciprocal_ancient_01"
                    ElseIf RunCycle = 1 Then
                        CLine = "sim3_nonreciprocal_ancient_06.dat sim3_nonreciprocal_ancient_06"
                    ElseIf RunCycle = 2 Then
                        CLine = "sim3_nonreciprocal_close_01.dat sim3_nonreciprocal_close_01"
                    ElseIf RunCycle = 3 Then
                        CLine = "sim3_nonreciprocal_close_06.dat sim3_nonreciprocal_close_06"
                    ElseIf RunCycle = 4 Then
                        CLine = "sim3_nonreciprocal_divergent_01.dat sim3_nonreciprocal_divergent_01"
                    ElseIf RunCycle = 5 Then
                        CLine = "sim3_nonreciprocal_divergent_06.dat sim3_nonreciprocal_divergent_06"
                    ElseIf RunCycle = 6 Then
                        CLine = "sim3_reciprocal_ancient_01.dat sim3_reciprocal_ancient_01"
                    ElseIf RunCycle = 7 Then
                        CLine = "sim3_reciprocal_ancient_06.dat sim3_reciprocal_ancient_06"
                    ElseIf RunCycle = 8 Then
                        CLine = "sim3_reciprocal_close_01.dat sim3_reciprocal_close_01"
                    ElseIf RunCycle = 9 Then
                        CLine = "sim3_reciprocal_close_06.dat sim3_reciprocal_close_06"
                    ElseIf RunCycle = 10 Then
                        CLine = "sim3_reciprocal_divergent_01.dat sim3_reciprocal_divergent_01"
                    ElseIf RunCycle = 11 Then
                        CLine = "sim3_reciprocal_divergent_06.dat sim3_reciprocal_divergent_06"
                    End If
                    
                    If ProgCycle = 0 Then
                        CLine = CLine + "RDP.csv /m r /o b"
                    ElseIf ProgCycle = 1 Then
                        CLine = CLine + "GENECONV.csv /m g /o b"
                    ElseIf ProgCycle = 2 Then
                        CLine = CLine + "RECSCAN.csv /m b /o b"
                    ElseIf ProgCycle = 3 Then
                        CLine = CLine + "MAXCHI.csv /m m /o b"
                    ElseIf ProgCycle = 4 Then
                        CLine = CLine + "CHIMAERA.csv /m c /o b"
                    ElseIf ProgCycle = 5 Then
                        CLine = CLine + "SISCAN.csv /m s /o b"
                    ElseIf ProgCycle = 6 Then
                        CLine = CLine + "MAXCHI_VS.csv /m m /o b"
                    ElseIf ProgCycle = 7 Then
                        CLine = CLine + "CHIMAERA_VS.csv /m c /o b"
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next

                    ChDir (App.Path)
                    ChDrive App.Path
                    On Error GoTo 0
                    Pos = InStr(1, CLine, " ", vbBinaryCompare)
            
                    If Pos > 0 Then
                        InFileX = Left$(CLine, Pos - 1)
                        LastPos = Pos + 1
                        Pos = InStr(LastPos, CLine, " ", vbBinaryCompare)
            
                        If Pos > 0 Then
                            OutFileX = Mid$(CLine, LastPos, Pos - LastPos)
                            LastPos = Pos + 1
                        Else
                            OutFileX = "outfile"
                        End If
                        
                        'Check for method switch
                        Pos = InStr(1, CLine, "/m", vbTextCompare)
                        If Pos > 0 Then
                            'Set method flags
                            
                            NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                            If NPos = Pos + 2 Then
                                Do While NPos = Pos + 2
                                    Pos = Pos + 1
                                    NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                                Loop
                            
                            ElseIf NPos = 0 Then
                                NPos = Len(CLine)
                            End If
                            PString = Mid(CLine, Pos + 1, NPos - Pos)
                            
                            Pos = InStr(1, PString, "a", vbTextCompare)
                            If Pos > 0 Then
                                DoScans(0, 0) = 1
                                DoScans(0, 1) = 1
                                DoScans(0, 2) = 1
                                DoScans(0, 3) = 1
                                DoScans(0, 4) = 1
                                DoScans(0, 5) = 1
                            Else
                            
                                Pos = InStr(1, PString, "r", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 0) = 1 Else DoScans(0, 0) = 0
                                Pos = InStr(1, PString, "g", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 1) = 1 Else DoScans(0, 1) = 0
                                Pos = InStr(1, PString, "b", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 2) = 1 Else DoScans(0, 2) = 0
                                Pos = InStr(1, PString, "m", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 3) = 1 Else DoScans(0, 3) = 0
                                Pos = InStr(1, PString, "c", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 4) = 1 Else DoScans(0, 4) = 0
                                Pos = InStr(1, PString, "s", vbTextCompare)
                                If Pos > 0 Then DoScans(0, 5) = 1 Else DoScans(0, 5) = 0
                            End If
                        Else
                            DoScans(0, 0) = 1
                            DoScans(0, 1) = 1
                            DoScans(0, 2) = 1
                            DoScans(0, 3) = 1
                            DoScans(0, 4) = 1
                            DoScans(0, 5) = 1
                        End If
                        Pos = InStr(1, CLine, "/o", vbTextCompare)
                        If Pos > 0 Then
                            NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                            If NPos = Pos + 2 Then
                                Do While NPos = Pos + 2
                                    Pos = Pos + 1
                                    NPos = InStr(Pos + 2, CLine, " ", vbBinaryCompare)
                                Loop
                                If NPos = 0 Then
                                    NPos = Len(CLine)
                                End If
                            ElseIf NPos = 0 Then
                                NPos = Len(CLine)
                            End If
                            PString = Mid(CLine, Pos + 1, NPos - Pos)
                            If InStr(1, PString, "s", vbTextCompare) > 0 Then
                                ShortOutFlag = 1
                                ReDim ShortOutput(10)
                            ElseIf InStr(1, PString, "m", vbTextCompare) > 0 Then
                                ShortOutFlag = 2
                            ElseIf InStr(1, PString, "a", vbTextCompare) > 0 Then
                                ShortOutFlag = 3
                            ElseIf InStr(1, PString, "b", vbTextCompare) > 0 Then
                                ShortOutFlag = 6 'give breakpoints only
                            Else
                                ShortOutFlag = 10
                            End If
                        Else
                            ShortOutFlag = 10 'give everything - I still need to sort this one out
                        End If
                        
            
                    Else
                        InFileX = CLine
                        OutFileX = "Outfile"
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
                    Kill OutFileX
                    On Error GoTo 0
                    
                   
                    'Check to see if infile has multiple datasets
                  
                    InString = String(10000, " ")
                    'Close #1
                    Open InFileX For Input As #1
                    Line Input #1, InString
                    
                    InString = LCase(InString)
                    If Left$(InString, 17) = "multiple datasets" Then
                        
                        
                        LastPos = 20
                        
                        Pos = InStr(LastPos, InString, Chr(10), vbBinaryCompare)
                        If Pos > 0 Then
                            Close #1
                            DatasetNo = (Mid(InString, LastPos, Pos - LastPos))
                            Pos = InStr(Pos + 2, InString, Chr(10), vbBinaryCompare)
                            Do While Pos - LastPos <= 2
                                LastPos = Pos
                                Pos = InStr(LastPos + 2, InString, Chr(10), vbBinaryCompare)
                            Loop
                            
                            RS = LastPos
                            PString = Mid(InString, LastPos, Pos - LastPos)
                            
                        Else
                            Pos = InStr(15, InString, " ", vbBinaryCompare)
                            If Pos > 0 Then
                            'zz = right(InString, Len(InString) - Pos)
                                DatasetNo = val(Right(InString, Len(InString) - Pos))
                                'X = X
                            End If
                            Line Input #1, PString
                            x = x
                        End If
                        
                        Pos = InStr(1, PString, " ", vbBinaryCompare)
                        If Pos > 0 Then
                            NextNo = val(Left(PString, Pos)) - 1
                            LenSeq = val(Right(PString, Len(PString) - Pos))
                        End If
                        
                        LastPos = Pos
                        
                        'nr.dat testout /m r /o b
                        If x = 12345 Then
                            If x = 12345 Then 'davids stuff
                                LastPos = Pos + 1
                                Pos = InStr(LastPos, InString, " ", vbBinaryCompare)
                                NextNo = CDbl(Mid(InString, LastPos, Pos - LastPos)) - 1
                                LastPos = Pos + 1
                                Pos = InStr(LastPos, InString, Chr(10), vbBinaryCompare)
                                LenSeq = CDbl(Mid(InString, LastPos, Pos - LastPos))
                                LastPos = Pos + 11
                            ElseIf x = 12345 Then 'conrads 999 and 20 taxa stuff
                                NextNo = 19
                                LenSeq = 999 + 333
                            ElseIf x = x Then 'conrads 999 stuff
                                NextNo = 9
                                LenSeq = 999 + 333
                            ElseIf x = 12345 Then 'conrads 9999 stuff
                                NextNo = 9
                                LenSeq = 9999 + 3333
                            End If
                        End If
                        InSeq = String(LenSeq, " ")
                        ReDim OriginalName(NextNo)
                        ReDim StrainSeq(NextNo)
                        OutFileX = OutFileX '+ ".csv"
                        Open OutFileX For Output As #20
                        Close #20
                        '2011743
                        'infile.txt outfile s
                        Text1.Text = LowestProb
                        '749 has neg modifier
                        Pos = InStr(LastPos + 1, InString, Chr(10), vbBinaryCompare)
                        If Pos > 0 Then
                            Do While Pos - LastPos < LenSeq
                                LastPos = Pos
                                Pos = InStr(LastPos + 1, InString, Chr(10), vbBinaryCompare)
                            Loop
                        Else
                            Line Input #1, InString
                            x = x
                            Z = 1
                            Do While Mid(InString, Z, 1) <> " "
                                Z = Z + 1
                            Loop
                            Do While Mid(InString, Z, 1) = " "
                                Z = Z + 1
                            Loop
                            LastPos = 0
                            
                            Pos = Z
                            ReadOffset = Z
                        End If
                        'find the offset
                        Dim FO As Long
                        FO = LastPos - RS + 1
                        Offset = Pos - LastPos - LenSeq
                        
                        LastPos = LastPos + Offset - 1
                       ' r.dat testoutr1r /m r /o b
                       'testin testout /m r /o b
                       '02.dat testoutcp0.csv /m c /o b
                        For x = 1 To DatasetNo
                            
                            'infile.txt outfile s
                            If Offset < 0 Then
                                
                                For Y = 0 To NextNo
                                    If Y = 0 Then
                                
                                    Else
                                        Line Input #1, InString
                                    End If
                                    Pos = InStr(1, InString, " ", vbBinaryCompare)
                                    OriginalName(Y) = Trim(Left(InString, Pos))
                                    StrainSeq(Y) = Trim(Right(InString, Len(InString) - Pos))
                                Next Y
                                Do
                                    If EOF(1) Then Exit Do
                                    Line Input #1, InString
                                    If Left(InString, Len(OriginalName(0))) = OriginalName(0) Then
                                        Exit Do
                                    End If
                                Loop
                            Else
                                Close #1
                                Open InFileX For Binary Access Read As #1
                                If x = 12345 Then
                                    For Y = 0 To NextNo
                                        OriginalName(Y) = "S" & Trim(Str(Y))
                                        Get #1, LastPos, InSeq
                                        StrainSeq(Y) = InSeq
                                        'ZZ = Len(StrainSeq(0))
                                        LastPos = LastPos + 12 + LenSeq
                                        'for alldata.txt the offset must be 12
                                        'LastPos = LastPos + 12 + LenSeq
                                    Next Y
                                     LastPos = LastPos + 9
                                ElseIf x = x Then 'conrads 999 seqs stuff
                                     For Y = 0 To NextNo
                                        OriginalName(Y) = "S" & Trim(Str(Y))
                                        Get #1, LastPos, InSeq
                                       ' XX = Len(StrainSeq(0))
                                        StrainSeq(Y) = InSeq
                                        'ZZ = Right(StrainSeq(Y), 10)
                                        LastPos = CLng(LastPos + Offset + Log10(Y + 2) + LenSeq - 0.49999)
                                        'for alldata.txt the offset must be 12
                                        'LastPos = LastPos + 12 + LenSeq
                                    Next Y
                                    LastPos = LastPos + 10
                                ElseIf x = 12345 Then 'conrads 9999 seqs
                                    LastPos = LastPos + 56
                                    For Y = 0 To NextNo
                                        OriginalName(Y) = "S" & Trim(Str(Y))
                                        Get #1, LastPos, InSeq
                                        StrainSeq(Y) = InSeq
                                        'zz = Len(StrainSeq(0))
                                        'zzz = Right(InSeq, 10)
                                        LastPos = LastPos + 12 + 22 + LenSeq
                                        'for alldata.txt the offset must be 12
                                        'LastPos = LastPos + 12 + LenSeq
                                    Next Y
                                    LastPos = LastPos + 9 - 44
                                End If
                                Close #1
                            End If
                            'XX = Len(StrainSeq(0))
                            BackUpNextno = NextNo
                            Call Command1_Click
                            
                            If x = x Then
                            'If X / 50 = Int(X / 50) Then
                            '    X = X
                            'End If
                                Call Command22_Click
                                If ShortOutFlag = 0 Then
                                    OutString = Str(x)
                                    For Y = 0 To 5
                                        OutString = OutString & "," & Trim(Str(ShortOutput(Y)))
                                    Next
                                
                                
                                    ReDim ShortOutput(5)
                                Else
                                    OutString = ""
                                    'Call DoRDP
                                    Dim AcProg() As Byte
                                    ReDim AcProg(AddNum * 2)
                                    If DoScans(0, 0) = 1 Then
                                        AcProg(0) = 1
                                    End If
                                    If DoScans(0, 1) = 1 Then
                                        AcProg(1) = 1
                                    End If
                                    If DoScans(0, 2) = 1 Then
                                        AcProg(2) = 1
                                    End If
                                    If DoScans(0, 3) = 1 Then
                                        AcProg(3) = 1
                                    End If
                                    If DoScans(0, 4) = 1 Then
                                        AcProg(4) = 1
                                    End If
                                    If DoScans(0, 5) = 1 Then
                                        AcProg(5) = 1
                                    End If
                                    'addin a check for number of methods required
                                    Dim MPVal As Double, Trace(2) As Long, NumIn As Long
                                    NumIn = 0
                                    
                                    If SEventNumber > 0 Then
                                        Dim DoneEvents() As Byte
                                        ReDim DoneEvents(SEventNumber)
                                        MPVal = 0
                                        
                                        If x = x Then ' sort by eventnumber
                                                Dim PCnt() As Byte, Prt As Long
                                                ReDim PCnt(SEventNumber, AddNum * 2)
                                                For Z = 0 To NextNo
                                                    For Y = 1 To CurrentXOver(Z)
                                                         EN = SuperEventList(XoverList(Z, Y).Eventnumber)
                                                         Prt = XoverList(Z, Y).ProgramFlag
                                                         
                                                         If XoverList(Z, Y).Probability < LowestProb And XoverList(Z, Y).Probability > 0 Then
                                                            PCnt(EN, Prt) = 1
                                                        End If
                                                    Next Y
                                                Next Z
                                                For A = 1 To SEventNumber
                                                    MPVal = 10000
                                                    For Z = 0 To NextNo
                                                        For Y = 1 To CurrentXOver(Z)
                                                            If SuperEventList(XoverList(Z, Y).Eventnumber) = A Then
                                                                
                                                                If XoverList(Z, Y).Probability < MPVal Then
                                                                    If XoverList(Z, Y).Probability > 0 Then
                                                                        If AcProg(XoverList(Z, Y).ProgramFlag) > 0 Then
                                                                            
                                                                            MPVal = XoverList(Z, Y).Probability
                                                                            Trace(0) = Z
                                                                            Trace(1) = Y
                                                                        End If
                                                                    End If
                                                                ElseIf XoverList(Z, Y).Probability = 0 Then
                                                                    x = x
                                                                End If
                                                            End If
                                                        Next Y
                                                    Next Z
                                                    If MPVal <= LowestProb Then
                                                        NumP = PCnt(A, 0) + PCnt(A, 1) + PCnt(A, 2) + PCnt(A, 5)
                                                        If PCnt(A, 3) = 1 Or PCnt(A, 4) Then
                                                            NumP = NumP + 1
                                                        End If
                                                        
                                                        If NumP > ConsensusProg Then
                                                            NumIn = NumIn + 1
                                                            If OnlyMid = 1 Then
                                                                
                                                                If Abs(XoverList(Trace(0), Trace(1)).Beginning - Len(StrainSeq(0)) / 2) < Abs(XoverList(Trace(0), Trace(1)).Ending - Len(StrainSeq(0)) / 2) Then
                                                                    OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Beginning) + ","
                                                                    x = x
                                                                Else
                                                                    OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Ending) + ","
                                                                End If
                                                            Else
                                                                OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Beginning) + "," + Str(XoverList(Trace(0), Trace(1)).Ending) + ","
                                                            End If
                                                        End If
                                                    End If
                                                Next A
                                                
                                        Else 'sort by pval
                                            Do While MPVal < 10000
                                                MPVal = 10000
                                                
                                                For Z = 0 To NextNo
                                                    For Y = 1 To CurrentXOver(Z)
                                                        If DoneEvents(SuperEventList(XoverList(Z, Y).Eventnumber)) = 0 Then
                                                            
                                                            If XoverList(Z, Y).Probability < MPVal Then
                                                                If XoverList(Z, Y).Probability > 0 Then
                                                                    If AcProg(XoverList(Z, Y).ProgramFlag) > 0 Then
                                                                        
                                                                        MPVal = XoverList(Z, Y).Probability
                                                                        Trace(0) = Z
                                                                        Trace(1) = Y
                                                                    End If
                                                                End If
                                                            End If
                                                        End If
                                                    Next Y
                                                Next Z
                                                DoneEvents(SuperEventList(XoverList(Trace(0), Trace(1)).Eventnumber)) = 1
                                            
                                                If MPVal < 10000 Then
                                                    
                                                    If OnlyMid = 1 Then
                                                        NumIn = NumIn + 1
                                                        If Abs(XoverList(Trace(0), Trace(1)).Beginning - Len(StrainSeq(0)) / 2) < Abs(XoverList(Trace(0), Trace(1)).Ending - Len(StrainSeq(0)) / 2) Then
                                                            OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Beginning) + ","
                                                            
                                                        Else
                                                            OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Ending) + ","
                                                        End If
                                                    Else
                                                        NumIn = NumIn + 2
                                                        OutString = OutString + Str(XoverList(Trace(0), Trace(1)).Beginning) + "," + Str(XoverList(Trace(0), Trace(1)).Ending) + ","
                                                    End If
                                                End If
                                            Loop
                                        End If
                                    End If
                                End If
                                FF = FreeFile
                                'Print #FF, OutString
                                'Close #21
                                'Open OutFileX For Output As #21
                                
                                
                            End If
                            OutString = Str(NumIn) + "," + OutString
                            Open OutFileX For Append As #20
                            Print #20, OutString
                            Close #20
                            
                            'DoEvents
                           'AllData-64.txt s
                        Next x
                        Close #20
                        '
                        
                    Else
                        Close #1
                        Call Command1_Click
                
                        If ErrorFlag = 1 Then
                            ErrorFlag = 0
                            Exit Sub
                        End If
                
                        Call Command22_Click
                        Call Command18_Click
                        Call Command12_Click(1)
                    End If
                    Close #1
                Next ProgCycle
            
            Next RunCycle
            End
            Call Command12_Click(1)
        End If
    End If
    'bit for automation of mtDNA project
    
    If FileList(4) <> "" Then
        File4Mnu.Caption = FileList(4)
    Else
        File4Mnu.Caption = "--"
    End If

    If FileList(3) <> "" Then
        File3Mnu.Caption = FileList(3)
    Else
        File3Mnu.Caption = "--"
    End If

    If FileList(2) <> "" Then
        File2Mnu.Caption = FileList(2)
    Else
        File2Mnu.Caption = "--"
    End If

    If FileList(1) <> "" Then
        File1Mnu.Caption = FileList(1)
    Else
        File1Mnu.Caption = "--"
    End If
'XX = DoScans(0, 0)

If CLine = "" And InFileX <> "" Then
    'need to strip inverted commas off the end of infilex
    If Left(InFileX, 1) = Chr(34) Then
        InFileX = Right(InFileX, Len(InFileX) - 1)
    End If
    If Right(InFileX, 1) = Chr(34) Then
        InFileX = Left(InFileX, Len(InFileX) - 1)
    End If
    CLine = "EXCEPTION18102001"
    LoadFileOnStartUpFlag = 1
Else
        
        
    
    
    Dim oDir As String, FL As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    If Dir("LastSave.rdp5") <> "" Then
        Open "LastSave.rdp5" For Input As #FF
        FL = LOF(FF)
        Close #FF
    Else
        FL = 0
    End If
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
    If FL > 100 Then
        LoadFileOnStartUpFlag = 2
        CLine = "EXCEPTION18102001"
    Else
        LoadFileOnStartUpFlag = 0
    End If
    
    
End If
'add mousewheel support
'Call WheelHook(Picture7.hWnd)

Call WheelHook(Form1.hwnd)

End Sub

Private Sub Form_LostFocus()
If LoadBusy = 1 Then Exit Sub
x = x
End Sub

Private Sub Form_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
If LoadBusy = 1 Then Exit Sub
F1MO = 1
If CurrentlyRunningFlag = 0 Then
    If (x > F1Hotspot(0) And x < F1Hotspot(1)) And (Y > F1Hotspot(2) And Y < F1Hotspot(3)) Then
        F1MDF = 1
    ElseIf (Y > F1Hotspot(2) And Y < F1Hotspot(3)) Then
        F1MDF = 2
    ElseIf (x > F1Hotspot(0) And x < F1Hotspot(1)) Then
        F1MDF = 3
    End If
Else
    F1MDF = 0
End If
End Sub

Private Sub Form_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
    If SchemDownFlag = 1 Then Exit Sub
If LoadBusy = 1 Then Exit Sub
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
HSCrollInc = 0
Call CheckUnFlash
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If

If CurrentlyRunningFlag = 1 Then Exit Sub
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
    Picture6.Refresh
    CurFlash = 0
    Timercheck(1) = 0
    Call Timer1_Timer
    HighlightFlag = 0
    RecSeq = 0
    PAVal = 0
    If RIMode = 1 Then
        Call MakeSummary
    End If
End If
Form1.ScaleMode = 1
Dim OT1 As Byte, OP6A As Byte, OP4A As Byte, OP11A As Byte, NX As Long, NY As Long, GoOnX As Byte, GoonY As Byte

F1MO = 1
If Button = 1 And F1MDF = 1 Then 'Or F1MDF = 2 Or F1MDF = 3 Then
   Form1.Refresh
   If F1LXY(0) <> x Or F1LXY(1) <> Y Then
        'XX = (Command12(1).Width * 2.1)
        'If (X - 1000) <= (Command12(1).Width * 2.1) Then X = Command12(1).Width * 2.1 + 1000
        'command12(1) is the exit button
        If x < (Command12(1).Width * 2.1) + 1000 Then
        
            NX = (Command12(1).Width * 2.1) + 1000
            If F1RF = 1 Then
                Form1.Width = LastF1Width
            End If
        ElseIf x >= -((Command12(1).Width * 2.3) + 1000 - Form1.Width) Then
            NX = -((Command12(1).Width * 2.3) + 1000 - Form1.Width)
            If F1RF = 1 Then
                Form1.Width = LastF1Width
            End If
        Else
            NX = x
        End If
        
        If Y < (Command12(1).Height * 5) + SSPanel6(0).Top + 700 Then
            NY = (Command12(1).Height * 5) + SSPanel6(0).Top + 700
            x = x
            If F1RF = 1 Then
                Form1.Height = LastF1Height
            End If
        ElseIf Y > -((Command12(1).Height * 8) - Form1.Height - SSPanel6(0).Top + 700) Then
            NY = -((Command12(1).Height * 8) - Form1.Height - SSPanel6(0).Top + 700)
            If F1RF = 1 Then
                Form1.Height = LastF1Height
                
            End If
            x = x
        Else
            NY = Y
            x = x
        End If
        
        
'        If NX < (Command12(1).Width * 2.1) + 1000 And NX < -(Command12(1).Width * 2.3) + 1000 - Form1.Width Then
'            ZZ = (Screen.Height - ((Y - 25) - SSPanel6(0).Top))
'
'
'            If NY < (Command12(1).Height * 5) + SSPanel6(0).Top + 700 And NY < -((Command12(1).Height * 8) - Form1.Height - SSPanel6(0).Top + 700) Then
'
        GoOnX = 0
        If x > (Command12(1).Width * 2.1) + 1000 And x < -((Command12(1).Width * 2.3) - Form1.Width + 1000) Then
            GoOnX = 1
        End If
            'ZZ = (Screen.Height - ((Y - 25) - SSPanel6(0).Top))
            
        GoonY = 0
        If ((Y - 700) - SSPanel6(0).Top) >= (Command12(1).Height * 5) And (Form1.Height - ((Y + 700) - SSPanel6(0).Top)) >= (Command12(1).Height * 8) Then
            GoonY = 1
        End If
        
        If GoonY = 1 Or GoOnX = 1 Then
                OT1 = Timer1.Enabled
                
                If GoOnX > 1 Then
                    SSPanel4.Width = x - 25
                    F1LXY(0) = x
                Else
                    SSPanel4.Width = NX - 25
                    F1LXY(0) = NX
                End If
                SSP4Fract = Form1.SSPanel4.Width / Form1.ScaleWidth
                
                If GoonY > 0 Then
                    SSPanel6(0).Height = Y - 25 - SSPanel6(0).Top
                    F1LXY(1) = Y
                Else
                    SSPanel6(0).Height = NY - 25 - SSPanel6(0).Top
                    F1LXY(1) = NY
                End If
                SSP6Fract = Form1.SSPanel6(0).Height / Form1.ScaleHeight
                'F1LXY(0) = X: F1LXY(1) = Y
                OP6A = Form1.Picture6.AutoRedraw
                OP4A = Form1.Picture4.AutoRedraw
                OP11A = Form1.Picture11.AutoRedraw
                Form1.Picture6.AutoRedraw = True
                Form1.Picture4.AutoRedraw = True
                Form1.Picture11.AutoRedraw = True
                SS = Abs(GetTickCount)
                For x = 1 To 1
                Call ResizeForm1
                Next x
                EE = Abs(GetTickCount)
                TT = EE - SS '5796,5828,5656
                '5922
                Timer1.Enabled = OT1
                Form1.Picture6.AutoRedraw = OP6A
                Form1.Picture4.AutoRedraw = OP4A
                Form1.Picture11.AutoRedraw = OP11A
                
          
        End If
    End If
ElseIf Button = 1 And F1MDF = 2 Then
   Form1.Refresh
   If F1LXY(0) <> x Or F1LXY(1) <> Y Then
        'If (X - 25) > (Command12(1).Width * 2.1) And (Form1.Width - X + 25) > (Command12(1).Width * 2.3) Then
            'ZZ = (Screen.Height - ((Y - 25) - SSPanel6(0).Top))
            If ((Y - 700) - SSPanel6(0).Top) > (Command12(1).Height * 5) And (Form1.Height - ((Y + 700) - SSPanel6(0).Top)) > (Command12(1).Height * 8) Then
                OT1 = Timer1.Enabled
                ' Cpy pictures to image controls
                
                'SSPanel4.Width = X - 25
                '.SSPanel3.Width = X - 25
                'SSPanel3.Height = Y - 25 - SSPanel3.Top
                SSPanel6(0).Height = Y - 25 - SSPanel6(0).Top
                SSP6Fract = Form1.SSPanel6(0).Height / Form1.ScaleHeight
                F1LXY(1) = Y
                OP6A = Form1.Picture6.AutoRedraw
                OP4A = Form1.Picture4.AutoRedraw
                OP11A = Form1.Picture11.AutoRedraw
                Form1.Picture6.AutoRedraw = True
                Form1.Picture4.AutoRedraw = True
                Form1.Picture11.AutoRedraw = True
                Call ResizeForm1
                Timer1.Enabled = OT1
                Form1.Picture6.AutoRedraw = OP6A
                Form1.Picture4.AutoRedraw = OP4A
                Form1.Picture11.AutoRedraw = OP11A
                
            End If
        'End If
    End If
ElseIf Button = 1 And F1MDF = 3 Then
   Form1.Refresh
   If F1LXY(0) <> x Or F1LXY(1) <> Y Then
   ' XX = (Command12(1).Width * 2.1)
        If (x - 1000) > (Command12(1).Width * 2.1) And (Form1.Width - x - 1000) > (Command12(1).Width * 2.3) Then
           ' ZZ = (Screen.Height - ((Y - 25) - SSPanel6(0).Top))
            'If ((Y - 25) - SSPanel6(0).Top) > (Command12(1).Height * 5) And (Form1.Height - ((Y - 25) - SSPanel6(0).Top)) > (Command12(1).Height * 8) Then
                OT1 = Timer1.Enabled
                
                ' Cpy pictures to image controls
                
                SSPanel4.Width = x - 25
                SSP4Fract = Form1.SSPanel4.Width / Form1.ScaleWidth
                '.SSPanel3.Width = X - 25
                'SSPanel3.Height = Y - 25 - SSPanel3.Top
                'SSPanel6(0).Height = Y - 25 - SSPanel6(0).Top
                F1LXY(0) = x
                OP6A = Form1.Picture6.AutoRedraw
                OP4A = Form1.Picture4.AutoRedraw
                OP11A = Form1.Picture11.AutoRedraw
                Form1.Picture6.AutoRedraw = True
                Form1.Picture4.AutoRedraw = True
                Form1.Picture11.AutoRedraw = True
                Call ResizeForm1
                Timer1.Enabled = OT1
                
                Form1.Picture6.AutoRedraw = OP6A
                Form1.Picture4.AutoRedraw = OP4A
                Form1.Picture11.AutoRedraw = OP11A
                
            'End If
        End If
    End If
Else
    If CurrentlyRunningFlag = 0 Then
        If x > F1Hotspot(0) And x < F1Hotspot(1) And Y > F1Hotspot(2) And Y < F1Hotspot(3) Then
            Screen.MousePointer = 5
        ElseIf x > F1Hotspot(0) And x < F1Hotspot(1) Then
            Screen.MousePointer = 9
        ElseIf Y > F1Hotspot(2) And Y < F1Hotspot(3) Then
            Screen.MousePointer = 7
        Else
            Screen.MousePointer = 0
        End If
        
    Else
        x = x
    End If

    If RunFlag = 1 Or ManFlag > -1 Then
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
    End If
    Form1.Label15.Caption = ""
    Form1.Label1.Caption = ""
    Picture3.Refresh
    LastY3 = -1
    Picture3.MousePointer = 0

    If HighlightFlagII = 1 Then
        Picture20.Refresh
        HighlightFlagII = 0
        Picture20.ToolTipText = ""
    End If
End If
'If Timer1.Enabled = False Then
'                    X = X
'                End If
If Button = 1 Then Form1.Refresh
End Sub

Private Sub Form_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
If LoadBusy = 1 Then Exit Sub
Dim OT1 As Byte
If CurrentlyRunningFlag = 1 Then Exit Sub
If F1MDF > 0 Then
    OT1 = Form1.Timer1.Enabled
    If NextNo > 0 Then
        'DontRefreshSeqsFlag = 0
        If HScroll1.Value > HScroll1.Min Then
            DontRefreshP1 = 1
             DontDoH1Inc = 1
            HScroll1.Value = HScroll1.Value - 1
           
            DontRefreshP1 = 0
             DontDoH1Inc = 1
            HScroll1.Value = HScroll1.Value + 1
             DontDoH1Inc = 0
        Else
           DontRefreshP1 = 1
           
        ''''''''''''''''''''''''''''''0.171
            If HScroll1.Value < HScroll1.Max Then
                DontDoH1Inc = 1
                
                HScroll1.Value = HScroll1.Value + 1
                
        ''''''''''''''''''''''''''''''''0.203, 0.187
                DontRefreshP1 = 0
                 DontDoH1Inc = 1
                HScroll1.Value = HScroll1.Value - 1
                 DontDoH1Inc = 0
            ElseIf HScroll1.Value > 1 Then
                DontDoH1Inc = 1
                
                HScroll1.Value = HScroll1.Value - 1
                
        ''''''''''''''''''''''''''''''''0.203, 0.187
                DontRefreshP1 = 0
                 DontDoH1Inc = 1
                HScroll1.Value = HScroll1.Value + 1
                 DontDoH1Inc = 0
            End If
    '''''''''''''''''''''''''''''''''0.530,0.515
            DontRefreshP1 = 0
        End If
    End If
    'Call HScroll1_Change
    
    If ColDistInFile = 1 Then
        
        ReDim ColDist2(0)
        Timer7(1).Enabled = False
    End If
    If RunFlag = 1 And RedoIntegrateXOversFlag > 0 Then
        
        Call IntegrateXOvers(0)
        Form1.Timer6.Enabled = 0
        RedoIntegrateXOversFlag = 0
        'remap the flashing bit
        Dim UBPA As Long
        If DebuggingFlag < 2 Then On Error Resume Next
            'UBPA = -1
            UBPA = UBound(PermArray, 2)
        On Error GoTo 0
        
        If RunFlag > 0 And UBPA > 0 Then
            For XX = 0 To UBPA
                If PermArray(0, XX) = -RelX Then
                    For Z = XX To UBound(PermArray, 2)
                        'If PermArray(0, Z) <> -RelX Then Exit For
                        For Yy = 1 To UBound(PermArray, 1)
                            If PermArray(Yy, Z) = RelY Then
                                'PermYVal = yy / 2.2 'Int(((Yy / SpaceAdjust) - 3) / 12)
                            
                                PermYVal = CLng(((Z * 12) + 3) * SpaceAdjust)
                                
                                
                                '(YY + VScroll2.Value * F1VS2Adj)
                                GoOn = 22
                                Exit For
                            End If
                           
                        Next Yy
                        If GoOn = 22 Then Exit For
                    Next Z
                    Exit For
                End If
                
                
            Next XX
        End If
    End If
    Form1.Timer1.Enabled = OT1
    If Combo1.Enabled = True And ManFlag = -1 Then
        If CurrentCheck <> 8 And CurrentCheck <> 9 And CurrentCheck <> 41 And CurrentCheck <> 6 And CurrentCheck <> 13 And CurrentCheck <> 16 And CurrentCheck <> 5 And CurrentCheck <> 1 And CurrentCheck <> 4 And CurrentCheck <> 3 And CurrentCheck <> 2 And CurrentCheck <> 10 And CurrentCheck <> 6 And CurrentCheck <> 15 And CurrentCheck <> 9 And CurrentCheck <> 12 And CurrentCheck <> 0 Then
            If CurrentCheck = -1 And x = 12345 Then
                Call CXoverB
            ElseIf CurrentCheck = -1 And (XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 1) Then
                'Call TSXOverB
            Else
                Call Combo1_Click
            End If
        End If

    End If
    If NextNo > 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
    End If
End If
F1MO = 1
F1MDF = 0
End Sub




Private Sub Form_OLECompleteDrag(Effect As Long)
If LoadBusy = 1 Then Exit Sub
End Sub

Private Sub Form_Paint()
    If LoadBusy = 1 Then Exit Sub
    If Form3.Visible = True Then Form3.ZOrder

    If Form5.Visible = True Then Form5.ZOrder
End Sub


Private Sub Form_Resize()
    Dim OT1 As Long, GoOn As Long, OP6A As Long, OP4A As Long, OP11A As Long
    ''XX = Form1.Visible
    If LoadBusy = 1 Then Exit Sub
    If Form1.Visible = False Then Exit Sub
    If UpdateProgressBar = 1 Then Exit Sub
    
    'If Form1.WindowState = 2 Then ResizeForm1: Exit Sub
    If DebuggingFlag < 2 Then On Error Resume Next
    
    On Error GoTo 0
    'Exit Sub
    'XX = ((Command12(1).Width * 2.1) + 1000) * 2 + 5
    'If Form1.ScaleWidth < ((Command12(1).Width * 2.1) + 1000) * 2 + 5 Then
    '    Form1.ScaleWidth = ((Command12(1).Width * 2.1) + 1000) * 2 + 5
    'Else
    
    'End If
    If DoingShellFlag <> 0 Then
        Exit Sub
    End If
    If CurrentlyRunningFlag <> 0 Then
        Exit Sub
    End If
    If SchemDownFlag <> 0 Then
        Exit Sub
    End If
    Form1.Timer6.Enabled = 0
    Dim MaxH As Single, MinW As Single
    MaxH = Command12(1).Height * 8 + 3000
    MinW = ((Command12(1).Width * 2.1) + 1000) * 2 + 500
    F1RF = 1
    If Form1.WindowState = 0 And CurrentlyRunningFlag = 0 Then
        'XX = Command12(1).Height * 8
        If (LastF1Width <> Form1.Width Or LastF1Height <> Form1.Height) And Form1.Visible = True And (Form1.Width > Form1OWidth * 0.25 And Form1.Height > Form1OHeight * 0.25) And (Form1.Width >= MinW And Form1.Height >= MaxH) Then
            
            
                
                
            OP6A = Form1.Picture6.AutoRedraw
            OP4A = Form1.Picture4.AutoRedraw
            OP11A = Form1.Picture11.AutoRedraw
            Form1.Picture6.AutoRedraw = True
            Form1.Picture4.AutoRedraw = True
            Form1.Picture11.AutoRedraw = True
'            F1MDF = 1
'            Call Form_MouseMove(1, 0, SSPanel5.Left, SSPanel5.Top)
'            F1MDF = 0
            Call ResizeForm1 '1
            
            
            
            
            Form1.Picture6.AutoRedraw = OP6A
            Form1.Picture4.AutoRedraw = OP4A
            Form1.Picture11.AutoRedraw = OP11A
            If RedoIntegrateXOversFlag > 0 Then
                Form1.Timer6.Enabled = 1
            End If
            LastF1Width = Form1.Width
            LastF1Height = Form1.Height
        ElseIf Form1.Width < MinW And Form1.Height < MaxH Then
            Form1.Width = MinW
            Form1.Height = MaxH
            Form1.Refresh
            LastF1Width = Form1.Width
            LastF1Height = Form1.Height
            'DoEvents
        ElseIf Form1.Width < MinW Then
            'XX = ((Command12(1).Width * 2.1) + 1000) * 2 + 10
            Form1.Width = MinW '6684
            'If (SSPanel4.Width / Form1.ScaleWidth) > 0.53 Then
            '    Call ResizeForm1
            'End If
            
            
            Form1.Refresh
            LastF1Width = Form1.Width
            LastF1Height = Form1.Height
'            X = X
           ' DoEvents
        ElseIf Form1.Height < MaxH Then
            'XX = (SSPanel6(0).Height / Form1.ScaleHeight)
            'If (SSPanel6(0).Height / Form1.ScaleHeight) > 0.53 Then
            '    Call ResizeForm1
            'End If
            Form1.Height = MaxH
            
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
           ' DoEvents
           ' F1MDF = 0
        End If
        LastF1Width = Form1.Width
        LastF1Height = Form1.Height
    ElseIf CurrentlyRunningFlag = 1 Then
        Form1.Width = LastF1Width
        Form1.Height = LastF1Height
    ElseIf Form1.WindowState = 2 Then
        
        OP6A = Form1.Picture6.AutoRedraw
        OP4A = Form1.Picture4.AutoRedraw
        OP11A = Form1.Picture11.AutoRedraw
        Form1.Picture6.AutoRedraw = True
        Form1.Picture4.AutoRedraw = True
        Form1.Picture11.AutoRedraw = True
        
        Call ResizeForm1 '2
        
        Form1.Picture6.AutoRedraw = OP6A
        Form1.Picture4.AutoRedraw = OP4A
        Form1.Picture11.AutoRedraw = OP11A
        LastF1Width = 0
        LastF1Height = 0
    End If
    F1RF = 0
    GoOn = 1
    If SSPanel4.Width < (Command12(1).Width * 2.1) Then SSPanel4.Width = (Command12(1).Width * 2.1): GoOn = 0
    If SSPanel6(0).Height < Command12(1).Height * 5 Then SSPanel6(0).Height = Command12(1).Height * 5: GoOn = 0

    If GoOn = 0 Then
        F1MDF = 1
        OT1 = Timer1.Enabled
        SSP4Fract = Form1.SSPanel4.Width / Form1.ScaleWidth
        
        SSP6Fract = Form1.SSPanel6(0).Height / Form1.ScaleHeight
        OP6A = Form1.Picture6.AutoRedraw
        OP4A = Form1.Picture4.AutoRedraw
        OP11A = Form1.Picture11.AutoRedraw
        Form1.Picture6.AutoRedraw = True
        Form1.Picture4.AutoRedraw = True
        Form1.Picture11.AutoRedraw = True
        
        Call ResizeForm1 '3
        
        
        SSPanel3.Visible = True
        SSPanel8.Visible = True
        SSPanel5.Visible = True
        SSPanel7.Visible = True
        SSPanel4.Visible = True
        
        Timer1.Enabled = OT1
        Form1.Picture6.AutoRedraw = OP6A
        Form1.Picture4.AutoRedraw = OP4A
        Form1.Picture11.AutoRedraw = OP11A
        F1MDF = 0
    Else
        
        SSPanel3.Visible = True
        SSPanel8.Visible = True
        SSPanel5.Visible = True
        SSPanel7.Visible = True
        SSPanel4.Visible = True
    
    End If
    
    Form1.Refresh
    'DoEvents
    On Error GoTo 0
End Sub

Private Sub Form_Unload(Cancel As Integer)
    'Call WheelUnHook(Picture7.hWnd)
    
    
    
    
    Dim lResult As Long
    Form1.Visible = False
    Form2.Visible = False
    Form3.Visible = False
    Form4.Visible = False
    Form5.Visible = False
    Form6.Visible = False
    Form2.Visible = False

    lResult = RemoveFontResource(App.Path & "\COUR.TTF")
    
    Dim oDir As String
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    XX = LowestProb
    Call WriteRDP5File("LastSave.rdp5")
    
    ChDrive oDir
    ChDir oDir
    
    
    Call WheelUnHook(Form1.hwnd)
    Call WriteIni

    Call ShutRunning

'    Unload Form2
'    Unload Form3
'    Unload Form5

    Unload Form2
    Unload Form3
    Unload Form4
    Unload Form5
    Unload Form6
    Unload Form7
    Unload frmSplash
    XX = CurDir
    KillFile "RDP5ExcludeList" + UFTag
    KillFile "CSequencesForSaving" + UFTag
    End
End Sub

Private Sub Frame17_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
x = x
End Sub

Private Sub Frame6_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
End Sub

Private Sub GENECONVScanMnu_Click()

    Call DeactivateScans
    DoScans(0, 1) = 1
    
    Call Command22_Click

End Sub

Private Sub GoToBestMnu_Click()
MenuUpFlag = 0
Dim HiProb As Double, LoProb As Double, XP As Long, YP As Long
Dim AcProg() As Byte
ReDim AcProg(AddNum * 2)
For x = 0 To AddNum - 1
    If DoScans(0, x) = 1 Then AcProg(x) = 1
Next x

If ReassortmentFlag = 0 Then
    Form1.SSPanel1.Caption = "Finding best recombination event"
    Form2.SSPanel3.Caption = "Finding best recombination event"
Else
    Form1.SSPanel1.Caption = "Finding best recombination/reassortment event"
    Form2.SSPanel3.Caption = "Finding best recombination/reassortment event"
End If
Form1.Refresh: Form2.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState

Timer1.Enabled = False

HiProb = 1
LoProb = 0
RedoFind:
For x = 0 To NextNo
    
    For Y = 1 To CurrentXOver(x)
        'If X = 0 And Y = 5 Then
        '    X = X
        'End If
           If XoverList(x, Y).ProgramFlag <> 5 Then
            If XoverList(x, Y).Accept = 0 Or (XoverList(x, Y).Accept = 1 And SkipAcceptedMnu.Checked = False) Or (XoverList(x, Y).Accept = 2 And SkipRejectedMnu.Checked = False) Then
                If XoverList(x, Y).Probability < HiProb And XoverList(x, Y).Probability > LoProb And AcProg(XoverList(x, Y).ProgramFlag) = 1 Then
                    HiProb = XoverList(x, Y).Probability
                    XP = x
                    YP = Y
                End If
            End If
        End If
    Next Y
Next x
If HiProb = 1 Then
   For x = 0 To NextNo
    
        For Y = 0 To CurrentXOver(x)
            'If X = 0 And Y = 5 Then
            '    X = X
            'End If
            'If XoverList(X, Y).ProgramFlag <> 5 Then
                If XoverList(x, Y).Accept = 0 Or (XoverList(x, Y).Accept = 1 And SkipAcceptedMnu.Checked = False) Or (XoverList(x, Y).Accept = 2 And SkipRejectedMnu.Checked = False) Then
            
                    If XoverList(x, Y).Probability < HiProb And XoverList(x, Y).Probability > LoProb And AcProg(XoverList(x, Y).ProgramFlag) = 1 Then
                        HiProb = XoverList(x, Y).Probability
                        XP = x
                        YP = Y
                    End If
                End If
            'End If
        Next Y
    Next x
    If HiProb = 1 Then
        Timer1.Enabled = True
        Exit Sub
    End If
End If

'Find position of the region on the screen (in picture6)
XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
Dim XS As Long
If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
    XS = CInt((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
Else
    If XoverList(XP, YP).Ending > 12 * XPicAddjust Then
        XS = (1 + (XoverList(XP, YP).Ending - 1) / 2) * XPicAddjust + 10
    Else
        XS = (XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * XPicAddjust + 10
    End If
End If


GoOn = 0
For Y = 0 To UBound(PermArray, 2)

    If PermArray(0, Y) = XP Then
        
        For Z = Y + 2 To UBound(PermArray, 2)
            If PermArray(0, Z) = -(XP + 1) Then
                XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
                LoProb = XoverList(XP, YP).Probability
                HiProb = 1
                'Exit Sub
                GoTo RedoFind
                
            End If
            
            If PermArray(XS, Z) = YP Then
                PermYVal = (Z * 12 + 3) * SpaceAdjust
                GoOn = 1
                Exit For
            End If
            'Exit Sub
            
        Next Z
        'GoOn = 1
        Exit For
    End If
Next Y

If GoOn = 0 Then
    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
    LoProb = XoverList(XP, YP).Probability
    HiProb = 1
    'XOverList(XP, YP).Accept = 2
    GoTo RedoFind
    
End If

exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP

RecSeq = XP
PAVal = YP
If PAVal < 0 Then
            x = x
        End If
Seq1 = XoverList(RelX, RelY).MajorP
Seq2 = XoverList(RelX, RelY).MinorP
Seq3 = XoverList(RelX, RelY).Daughter

If ReassortmentFlag = 0 Then
    Form1.SSPanel1.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
Else
    Form1.SSPanel1.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
End If
Form1.Refresh: Form2.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState



If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
    If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) / 2 > 0 Then
        VScroll2.Value = CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
    Else
        VScroll2.Value = 0
    End If
Else
    VScroll2.Value = VScroll2.Max
End If
'VScroll2.Value = (PermYVal) / Picture6.ScaleHeight * VScroll2.Max  ' - Picture5.ScaleHeight ' / 12




PermXVal = 6 + CLng(XoverList(RelX, RelY).Beginning * XPicAddjust)
DontPutForm2Ontop = 1
Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value - VScroll2.Value)
DontPutForm2Ontop = 0

Call SchemDown(1)
DontDoH1Inc = 1
Call HScroll1_Change
DontDoH1Inc = 0
If ColDistInFile = 1 Then
    
    ReDim ColDist2(0)
    Timer7(1).Enabled = False
End If
Form1.ProgressBar1 = 0
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
Screen.MousePointer = 0
End Sub

Private Sub GoToEvenXtMnu_Click()
Form1.Enabled = False


Form7.ScaleMode = 3
Form7.ScaleHeight = 50
Form7.Label1(0).Top = 5
Form7.Label1(1).Top = Form7.Label1(0).Top
Form7.Text1(0).Top = Form7.Label1(0).Top
    Form7.Text1(1).Top = Form7.Label1(0).Top
    Form7.Command1(0).Top = Form7.Text1(0).Top + Form7.Text1(0).Height + 5
    Form7.Command1(1).Top = Form7.Command1(0).Top
Form7.Label1(0).Width = 60
    Form7.Label1(1).Width = Form7.Label1(0).Width
Form7.Text1(0).Width = 50
    Form7.Text1(1).Width = Form7.Text1(0).Width
    Form7.Command1(0).Width = Form7.Text1(0).Width
    Form7.Command1(1).Width = Form7.Text1(0).Width
Form7.ScaleMode = 3
Form7.Label1(0).Left = 5
Form7.ScaleMode = 3
Form7.Text1(0).Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5

'If X = 12345 Then
    
    
    
    
    
    
    
    
    Form7.Label1(1).Left = Form7.Text1(0).Left + Form7.Text1(0).Width + 5
    Form7.Text1(1).Left = Form7.Label1(1).Left + Form7.Label1(1).Width + 5
    Form7.Command1(0).Left = Form7.Text1(1).Left
    Form7.Command1(1).Left = Form7.Command1(0).Left + Form7.Command1(0).Width
    Form7.Label1(0).Caption = "Merge event"
    Form7.Label1(1).Caption = "with event"
    Form7.Text1(0).Text = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
    Form7.Text1(1).Text = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
'End If
Form7.Caption = "Merge Events"
Form7.Visible = True
CIndex = 1
End Sub

Private Sub GoToNextEventMnu_Click()
If SEventNumber = 0 Then Exit Sub
MenuUpFlag = 0

Dim HiProb As Double, LoProb As Double, XP As Long, YP As Long
Dim AcProg() As Byte
ReDim AcProg(AddNum * 2)
For x = 0 To AddNum - 1
    If DoScans(0, x) = 1 Then AcProg(x) = 1: AcProg(x + AddNum) = 1
    
Next x

Timer1.Enabled = False

If RelX = 0 And RelY = 0 Then
    SEN = 0
    'Exit Sub
Else
    SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
End If
Cycle = 0
RedoFind:

Do
    SEN = SEN + 1
    
    If SEventNumber < SEN Then
        SEN = 1
        Cycle = Cycle + 1
        If Cycle = 2 Then
            SkipAcceptedMnu.Checked = False
        ElseIf Cycle = 3 Then
            Timer1.Enabled = True
            Exit Sub
        End If
    End If
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(BestEvent, 1)
    If UB < SEN Then
        Exit Sub
    End If
    On Error GoTo 0
    
    XP = BestEvent(SEN, 0)
    YP = BestEvent(SEN, 1)
    If YP < 0 Or (XP = 0 And YP = 0) Then GoTo RedoFind
    GoOn = 0
    If SuperEventList(XoverList(XP, YP).Eventnumber) <> SEN Then
        SuperEventList(XoverList(XP, YP).Eventnumber) = SEN
    End If
    If XoverList(XP, YP).Accept = 0 Then
        GoOn = 1
    Else
        If XoverList(XP, YP).Accept = 1 Then
            If SkipAcceptedMnu.Checked = False Then
                GoOn = 1
            End If
        Else
            If SkipRejectedMnu.Checked = False Then
                GoOn = 1
            
            End If
        End If
    End If
    If GoOn = 1 Then
        PN = 0
        For x = 0 To AddNum - 1
            If Confirm(SEN, x) > 0 Then PN = PN + 1
            
        Next x
        If PN > ConsensusProg Or ConsensusProg = 0 Then
            Exit Do
        End If
    End If
    
Loop




'Find position of the region on the screen (in picture6)
XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
Dim XS As Long, XS2 As Long, XS3 As Long
If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
    XS = CLng((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    XS2 = CLng(XoverList(XP, YP).Beginning * AdjArrayPos) + 1
    XS3 = CLng(XoverList(XP, YP).Ending * AdjArrayPos) - 1
Else
    If Len(StrainSeq(0)) - XoverList(XP, YP).Beginning > XoverList(XP, YP).Ending Then
        XS = CLng((XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
        XS3 = CLng((Len(StrainSeq(0))) * AdjArrayPos) - 1
        XS2 = CLng(XoverList(XP, YP).Beginning * AdjArrayPos) + 1
    Else
         XS = CLng((XoverList(XP, YP).Ending / 2) * AdjArrayPos)
         XS2 = 1
         XS3 = CLng(XoverList(XP, YP).Ending * AdjArrayPos) - 1
    End If
    'XS = CInt((1 + (XOverList(XP, YP).Ending - 1) / 2) * AdjArrayPos)
     'CInt((XOverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XOverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    'If XOverList(XP, YP).Ending > (12 * XPicAddjust) Then
    '    XS = (1 + (XOverList(XP, YP).Ending - 1) / 2) * AdjArrayPos
    'Else
    '    XS = (XOverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XOverList(XP, YP).Beginning) / 2) * AdjArrayPos
    'End If
End If

If XS = UBound(PermArray, 1) Then XS = XS - 1
If XS2 = UBound(PermArray, 1) Then XS2 = XS2 - 1
If XS3 = UBound(PermArray, 1) Then XS3 = XS3 - 1

If XS = 0 Then XS = 1
If XS2 = 0 Then XS2 = 1
If XS3 = 0 Then XS3 = 1

GoOn = 0
For Y = 0 To UBound(PermArray, 2)

    If PermArray(0, Y) = XP Then
       
        For Z = Y + 2 To UBound(PermArray, 2)
            If PermArray(0, Z) = -(XP + 1) Then
                If XS = 1 Then
                    XS = 2
                    For A = Y + 2 To UBound(PermArray, 2)
                        If PermArray(0, A) = -(XP + 1) Then
                            Exit For
                        End If
                        If PermArray(XS, A) = YP Then ' Or PermArray(XS + 1, A) = YP Then
                            GoOn = 1
                            Exit For
                        End If
                    Next A
                End If
                If GoOn = 0 Then
                    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
                    LoProb = XoverList(XP, YP).Probability
                    HiProb = 1
                    'Exit Sub
                    GoTo RedoFind
                End If
                
            End If
            UBPA = UBound(PermArray, 1)
            If UBPA >= XS And UBPA >= XS2 And UBPA >= XS3 Then
                If PermArray(XS, Z) = YP Or PermArray(XS2, Z) = YP Or PermArray(XS3, Z) = YP Then
                    PermYVal = (Z * 12 + 3) * SpaceAdjust
                    GoOn = 1
                    Exit For
                ElseIf PermArray(XS - 1, Z) = YP Or PermArray(XS2 - 1, Z) = YP Or PermArray(XS3 - 1, Z) = YP Then
                    PermYVal = (Z * 12 + 3) * SpaceAdjust
                    GoOn = 1
                    Exit For
                End If
            End If
            'Exit Sub
            
        Next Z
        'GoOn = 1
        Exit For
    End If
Next Y

If GoOn = 0 Then
    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
    LoProb = XoverList(XP, YP).Probability
    HiProb = 1
    'XOverList(XP, YP).Accept = 2
    GoTo RedoFind
    
End If


'TestPress = 0
'If opxv <> PermXVal Or opyv <> PermYVal Then
    
    exRelX = RelX
    exRely = RelY
    RelX = XP
    RelY = YP
    RecSeq = XP
    PAVal = YP
        
    If XP > 0 Or YP > 0 Then
        Call GoToThis(1, XP, YP, PermXVal, PermYVal)
    End If
    'opxv = PermXVal
    'opyv = PermYVal
'Else
    x = x
'End If
End Sub
Private Sub GoToThis(Redraw, XP, YP, PermXVal As Single, PermYVal As Single)
exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP
RecSeq = XP
PAVal = YP

ENumb = SuperEventList(XoverList(XP, YP).Eventnumber)
Dim AltYP
If BestEvent(ENumb, 0) = XP Then
    AltYP = BestEvent(ENumb, 1)
Else
    AltYP = YP
End If
If ReassortmentFlag = 0 Then
    Form1.SSPanel1.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
Else
    Form1.SSPanel1.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
End If
Form1.Refresh: Form2.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState

XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
If PermXVal = 0 And PermYVal = 0 Then 'ie find proper values
    
    
    Dim XS As Long
    If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
        XS = CInt((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    Else
        If XoverList(XP, YP).Ending > 12 * XPicAddjust Then
            XS = (1 + (XoverList(XP, YP).Ending - 1) / 2) * XPicAddjust + 10
        Else
            XS = (XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * XPicAddjust + 10
        End If
    End If
    If XS > UBound(PermArray, 1) Then XS = UBound(PermArray, 1)
    GoOn = 0
    For Y = 0 To UBound(PermArray, 2)

        If PermArray(0, Y) = XP Then
            
            For Z = Y + 2 To UBound(PermArray, 2)
                If PermArray(0, Z) = -(XP + 1) Then
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1 = 0
                        Form1.SSPanel1.Caption = ""
                        Call UpdateF2Prog
                        Screen.MousePointer = 0
                    End If
'                    For c = 702 To UBound(PermArray, 2)
'                        For D = 1 To UBound(PermArray, 1)
'                            If PermArray(D, c) > 0 Then
'                                X = X
'                                XX = XOverlist(XP, PermArray(D, c)).Beginning
'                                XX = XOverlist(XP, PermArray(D, c)).Ending
'                                XX = XOverlist(XP, YP).Beginning
'                                XX = XOverlist(XP, YP).Ending
'                                XX = BestEvent(7, 1)
'                            End If
'                        Next D
'                    Next c
                    Exit Sub
                    
                End If
                For A = 1 To UBound(PermArray, 1)
                    If PermArray(A, Z) = YP Or PermArray(A, Z) = AltYP Then
                        If AltYP = PermArray(A, Z) Then
                            YP = AltYP
                            RelY = AltYP
                        End If
                        PermYVal = (Z * 12 + 3) * SpaceAdjust
                        XS = A
                        GoOn = 1
                        Exit For
                    End If
                Next A
                'Exit Sub
                If GoOn = 1 Then Exit For
            Next Z
            'GoOn = 1
            Exit For
        End If
    Next Y

End If

Seq1 = XoverList(RelX, RelY).MajorP
Seq2 = XoverList(RelX, RelY).MinorP
Seq3 = XoverList(RelX, RelY).Daughter
'Pr = XOverlist(RelX, RelY).ProgramFlag
Dim OldVSVal As Long, NewVSVal As Long
OldVSVal = VScroll2.Value


    If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
        If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
            'VScroll2.Value = CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
            NewVSVal = CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
        Else
            If DontChangeVScrollFlag = 0 Then
                'VScroll2.Value = 0
                NewVSVal = 0
            End If
        End If
    Else
        If VScroll2.Max > 0 Then
           ' VScroll2.Value = VScroll2.Max
           NewVSVal = VScroll2.Max
        Else
            If DontChangeVScrollFlag = 0 Then
                'VScroll2.Value = 0
                NewVSVal = 0
            End If
        End If
    End If


    If ButtonRepress = 1 Then
        Call ScrollToVSPos(VScroll2, OldVSVal, NewVSVal)
    Else
        VScroll2.Value = NewVSVal
    End If



'VScroll2.Value = (PermYVal) / Picture6.ScaleHeight * VScroll2.Max  ' - Picture5.ScaleHeight ' / 12

PermXVal = 6 + CLng(XoverList(RelX, RelY).Beginning * XPicAddjust)
DontPutForm2Ontop = 1




Call Picture6_MouseMove(0, 1, PermXVal, (PermYVal - VScroll2.Value * F1VS2Adj))



DontPutForm2Ontop = 0
If Redraw = 1 Then
    F2ontop = 0
    If Form1.HScroll1.Value = HScroll1.Min And Form1.HScroll1.Max > 0 Then
        DontDoH1Inc = 1
        H1C = 1
        If Form1.HScroll1.Value < Form1.HScroll1.Max Then
            Form1.HScroll1.Value = HScroll1.Min + 1
        End If
        H1C = 0
        DontDoH1Inc = 1
        Form1.HScroll1.Value = HScroll1.Min
        DontDoH1Inc = 0
    ElseIf Form1.HScroll1.Value < Form1.HScroll1.Max Then
        H1C = 1
        DontDoH1Inc = 1
        If Form1.HScroll1.Value < Form1.HScroll1.Max Then
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
        End If
        H1C = 0
        DontDoH1Inc = 1
        If Form1.HScroll1.Value > 0 Then
            Form1.HScroll1.Value = Form1.HScroll1.Value - 1
        End If
        DontDoH1Inc = 0
    Else
        H1C = 1
        DontDoH1Inc = 1
        If Form1.HScroll1.Value > 0 Then
            Form1.HScroll1.Value = Form1.HScroll1.Value - 1
        End If
        DontDoH1Inc = 1
        H1C = 0
        If Form1.HScroll1.Value < Form1.HScroll1.Max Then
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
        End If
        DontDoH1Inc = 0
    End If
    F2ontop = 0
    If ColDistInFile = 1 Then
        
        ReDim ColDist2(0)
    End If
    Timer7(1).Enabled = False
    SS = Abs(GetTickCount)
    ButtonRepress = 1 ' ButtonRepress 1
    
    Call SchemDown(1)
    
    If DontRedoQuickDistFlag = 0 Then
        DontDoH1Inc = 1
        Call HScroll1_Change
        DontDoH1Inc = 0
    End If
    If ColDistInFile = 1 Then
        If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
            'redim SubValid(0,0)
            ReDim SubDiffs(0, 0)
            'redim sMat(0,0)
            ReDim FubValid(0, 0)
            'Erase FMat
        End If
        
        ReDim ColDist2(0)
        Timer7(1).Enabled = False
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS '52.938 seconds'20.047,29.406,23.437'''''18.140,26.953,21.063'''''15640,'13.953,22.000,15.735
    '26.505
    x = x
    '13.719,21.869,15.516
    '12.094,20.250,14.031'using addseqtoupgma
    '11.391,19.641,13.453' using fillnodemaxrep
    '11.734 -with speed up secoverage calc in VB.
    
    '11.469,19.796,13.578 secoverage calc in c++
    '11.141, 16.063, 10.093    with preflagging of empty sequences
    '10.672,11.156, 9.797   with better removal of empty sequences
    '10.671,9.047,9.656 ' with better zero length removal
    '9.625, 8.281, 8.703 with faster shortestdist search in recupgmaii
    '8.063, 7.375, 7.656 with faster shortestdist search in both recupgmaii and recupgmaiv
    '8.297, 7.469, 7.688 with on error
    '8.906, 9.000, 9.188 with full zoom in
    
    '8.781, 8.875, 8.297 full zoom out
    '8.765, 8.922, 8.906 - normal zoom with 10 multiplyer
    '8.406, 8.125, 8.297 - normal zoom with 5 multiplier
    '7.426,7.373,7.426 (on my laptop) - normal zoom with 2 multiplier
    '29.406
    x = x
End If
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Form1.Refresh
Timer1.Enabled = True
If UpdateProgressBar = 0 Then
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Screen.MousePointer = 0
End If
End Sub
Private Sub GoToPreviousEventMnu_Click()
If SEventNumber = 0 Then Exit Sub
MenuUpFlag = 0
Dim HiProb As Double, LoProb As Double, XP As Long, YP As Long
Dim AcProg() As Byte

ReDim AcProg(AddNum * 2)
For x = 0 To AddNum - 1
    If DoScans(0, x) = 1 Then AcProg(x) = 1: AcProg(x + AddNum) = 1
    
Next x



Timer1.Enabled = False

If RelX = 0 And RelY = 0 Then
    SEN = SEventNumber
    'If SEN = 0 Then Exit Sub
Else
    SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
End If
Cycle = 0
RedoFind:

Do
    SEN = SEN - 1
    
    If SEN < 1 Then
        SEN = SEventNumber
        Cycle = Cycle + 1
        
        If Cycle = 2 Then
            SkipAcceptedMnu.Checked = False
            SEN = 1
        ElseIf Cycle = 3 Then
            Timer1.Enabled = True
            Exit Sub
        End If
    End If
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(BestEvent, 1)
    If UB < SEN Then Exit Sub
    
    On Error GoTo 0
    
    
    XP = BestEvent(SEN, 0)
    YP = BestEvent(SEN, 1)
    If YP < 0 Or (XP = 0 And YP = 0) Then GoTo RedoFind
    GoOn = 0
    If SuperEventList(XoverList(XP, YP).Eventnumber) <> SEN Then
        SuperEventList(XoverList(XP, YP).Eventnumber) = SEN
    End If
    If XoverList(XP, YP).Accept = 0 Then
        GoOn = 1
    Else
        If XoverList(XP, YP).Accept = 1 Then
            If SkipAcceptedMnu.Checked = False Then
                GoOn = 1
            End If
        Else
            If SkipRejectedMnu.Checked = False Then
                GoOn = 1
            
            End If
        End If
    End If
    If GoOn = 1 Then
        PN = 0
        For x = 0 To AddNum - 1
            If Confirm(SEN, x) > 0 Then PN = PN + 1
            
        Next x
        If PN > ConsensusProg Then
            Exit Do
        End If
    End If
    
Loop




'Find position of the region on the screen (in picture6)
XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
Dim XS As Long, XS2 As Long, XS3 As Long
If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
    XS = CInt((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    XS2 = CLng(XoverList(XP, YP).Beginning * AdjArrayPos) + 1
    XS3 = CLng(XoverList(XP, YP).Ending * AdjArrayPos) - 1
Else
    If Len(StrainSeq(0)) - XoverList(XP, YP).Beginning > XoverList(XP, YP).Ending Then
        XS = CLng((XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
        XS3 = CLng((Len(StrainSeq(0))) * AdjArrayPos) - 1
        XS2 = CLng(XoverList(XP, YP).Beginning * AdjArrayPos) + 1
    Else
         XS = CLng((XoverList(XP, YP).Ending / 2) * AdjArrayPos)
         XS2 = 1
         XS3 = CLng(XoverList(XP, YP).Ending * AdjArrayPos) - 1
    End If
End If

If XS = UBound(PermArray, 1) Then XS = XS - 1
If XS2 = UBound(PermArray, 1) Then XS2 = XS2 - 1
If XS3 = UBound(PermArray, 1) Then XS3 = XS3 - 1

If XS = 0 Then XS = 1
If XS2 = 0 Then XS2 = 1
If XS3 = 0 Then XS3 = 1

GoOn = 0
For Y = 0 To UBound(PermArray, 2)

    If PermArray(0, Y) = XP Then
       
        For Z = Y + 2 To UBound(PermArray, 2)
            If PermArray(0, Z) = -(XP + 1) Then
                If XS = 1 Then
                    XS = 2
                    For A = Y + 2 To UBound(PermArray, 2)
                        If PermArray(0, A) = -(XP + 1) Then
                            Exit For
                        End If
                        If PermArray(XS, A) = YP Then ' Or PermArray(XS + 1, A) = YP Then
                            GoOn = 1
                            Exit For
                        End If
                    Next A
                End If
                If GoOn = 0 Then
                    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
                    LoProb = XoverList(XP, YP).Probability
                    HiProb = 1
                    'Exit Sub
                    GoTo RedoFind
                End If
                
            End If
            UBPA = UBound(PermArray, 1)
            If UBPA >= XS And UBPA >= XS2 And UBPA >= XS3 Then
                If PermArray(XS, Z) = YP Or PermArray(XS2, Z) = YP Or PermArray(XS3, Z) = YP Then
                    PermYVal = (Z * 12 + 3) * SpaceAdjust
                    GoOn = 1
                    Exit For
                ElseIf PermArray(XS - 1, Z) = YP Or PermArray(XS2 - 1, Z) = YP Or PermArray(XS3 - 1, Z) = YP Then
                    PermYVal = (Z * 12 + 3) * SpaceAdjust
                    GoOn = 1
                    Exit For
                End If
            End If
            'Exit Sub
            
        Next Z
        'GoOn = 1
        Exit For
    End If
Next Y

If GoOn = 0 Then
    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
    LoProb = XoverList(XP, YP).Probability
    HiProb = 1
    'XOverList(XP, YP).Accept = 2
    GoTo RedoFind
    
End If

exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP
RecSeq = XP
PAVal = YP
If PAVal < 0 Then
            x = x
        End If
        
        
        

If XP > 0 Or YP > 0 Then
    Call GoToThis(1, XP, YP, PermXVal, PermYVal)
End If




End Sub

Private Sub GoToSeqMnu_Click()



If SEventNumber = 0 Then Exit Sub
For Y = 0 To UBound(PermArray, 2)
    If PermArray(0, Y) = GTCS Then
        Y = (Y * 12 + 3) * SpaceAdjust
        If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
            If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
                VScroll2.Value = CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
                'CLng((y - Picture6.ScaleHeight / 2) / F1VS2Adj)
            Else
                VScroll2.Value = 0
            End If
        Else
            VScroll2.Value = VScroll2.Max
        End If
        Y = CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
        Picture6.AutoRedraw = False
        Picture6.DrawMode = 13
        Picture6.DrawWidth = 2
        For Z = 0 To 510 Step 5
            If Z > 255 Then
                CVal = 510 - Z
            Else
                CVal = Z
            End If
            'Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 12), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255)), B
            Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 11), RGB(BkR + (255 - BkR) * (CVal / 255), BkG - BkG * (CVal / 255), BkB - BkB * (CVal / 255)), B
            
            DS = Abs(GetTickCount)
                    Do
                        ES = Abs(GetTickCount)
                        If ES - DS <> 0 Then Exit Do
                        
                    Loop
                    
        Next Z
        'VScroll2.Value = (((Y * 12 + 3) * SpaceAdjust + 10) / Picture6.ScaleHeight) * VScroll2.Max
        Picture6.AutoRedraw = True
        Picture6.DrawMode = 13
        Picture6.DrawWidth = 1
        Exit For
    End If
Next Y

End Sub

Private Sub HScroll1_ChangeOld()
Dim PolyPoints() As POINTAPI, Response As Long, xBak As Long, UB3 As Long, UB2 As Long, GoOn As Long, SEN As Long, Z As Long, num As Long, UB As Long, MinParPos As Long, Overhang As Long, Mu As Long, Kx As Long, Kh As Long, NF As Long, oDir As String, oDirX As String, FF As Long
Dim X0 As String, X1 As String, X2 As String, X3 As Long, PAP As POINTAPI
Dim Pict4 As Long
Dim Pict4SH As Long
If DontRedoQuickDistFlag = 1 Then Exit Sub

Form1.Timer3.Enabled = True
Form1.Timer3.Interval = 2000
'445628



If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If sHSCroll1Down = 0 Then
    sHSCroll1Down = Abs(GetTickCount)
    HSCrollInc = 1
End If
If CurrentlyRunningFlag = 1 Then
    Exit Sub
End If
'XX = Decompress(Len(StrainSeq(0)))
If NextNo <> PermNextno Then UnModNextno





Dim RecompX As Long
If F2ontop = 1 Then
    
    'ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - Form1.VScroll2.Value)
    Form1.Enabled = True
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(ProxButton, ProxShift, ProxX, ProxY)
    DontPutForm2Ontop = 0
    Form1.Enabled = False
    'F2ontop = 0
End If
'432616
If NextNo = 0 Then Exit Sub
ReDim Preserve PltCol3(15)
'If F1MDF = 1 Then Exit Sub
    'Call SaveAncSeq_Click
    If AncSeqFlag = 0 And LastAncSeqFlag = 1 Then
        VScroll3.Height = HScroll1.Top - VScroll3.Top - 4 * Screen.TwipsPerPixelX
        
        
        Picture8.Height = VScroll3.Height
        
        Picture9.Height = VScroll3.Height
        
        'Picture1.Height = Picture9.Height
        
        Picture22.Visible = False
    Else
        LastAncSeqFlag = 1
    End If
    
    SSS = Abs(GetTickCount)
    'this gets rid of the cursor on the sequence display
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -20
        ltPosX = -20
    End If
    'Command3.SetFocus
    Dim FS As Double, SLen As Long, Pict As Long, x As Long, Y As Long, LineBottom As Long, LineTop As Long, LastY As Long, CountHits As Long
    Dim P1 As Integer, P2 As Integer, A As Integer, C As Integer, g As Integer, T As Integer, S As Integer
    Dim tTYF As Double, TYFM As Integer, Test As String
    'tTYF = 0.45
    If DontRefreshP1 = 1 Then Exit Sub
    '@
    ReDim Output(PermNextno + 2)
    
    'If the current selection is not an RDP derived result then don't print
    'reference sequences
    
    
    SLen = UBound(Decompress, 1)
    If TYF = 0 Then TYF = 1
    If P1FontSize <> 0 Then
        
        Picture1.FontSize = P1FontSize * TYF
    End If
    If PermNextno < PermNextno Then
        UnModNextno
        x = x
    End If
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -1
        ltPosX = -1
        '@
        ReDim SeqLines(5, PermNextno * 3), SeqText(PermNextno + 2): NumSeqLines = 0: NumSeqText = 0
    End If
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        
    
    '432616
    'tTYF = tTYF * 1.08
    PrintSeqLen = MakePrintSeqLen '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G"))
    'XX = Form1.Picture1.TextWidth("C") * WinLeft
    If RunFlag = 1 Then
        If AllowExtraSeqsFlag = 0 Then
            If XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then SpacerNo = 0
        End If
    End If

    If RLFlag = 1 Then
        On Error GoTo UnknownFormat
    End If

    'Picture1.Picture = LoadPicture() 'Clears picture
    Overhang = Int(PrintSeqLen - (SLen - (0.99 * SLen))) - 1
    'OverHang = 0

    Dim THold As Long

    'THold = HScroll1.Value
    If Decompress(Len(StrainSeq(0))) > HScroll1.Max And DontDoH1Inc = 0 Then
        If HScroll1.Value >= HScroll1.Min Then
            If HScroll1.Value = HScroll1.Min And LastH1Val = HScroll1.Min + 1 Then
                H1M = -HScroll1Mod + 2
                 LastH1Dir = 1 'right movement
            ElseIf HScroll1.Value = HScroll1.Max And LastH1Val = HScroll1.Max - 1 Then
                H1M = H1M + 1
            ElseIf HScroll1.Value = HScroll1.Max - 1 And LastH1Val = HScroll1.Max Then
                H1M = H1M - 1
                
                 LastH1Dir = 2 'left
            Else
                If LastH1Val < HScroll1.Value Then
                    H1M = H1M + HSCrollInc
                    LastH1Dir = 1 'right movement
                ElseIf LastH1Val > HScroll1.Value Then
                    H1M = H1M - HSCrollInc
                    LastH1Dir = 2 'left movement
                End If
            End If
            If H1M >= HScroll1Mod Then
                If HScroll1.Value = HScroll1.Max Then
                    H1M = HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Max - 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            ElseIf H1M <= -HScroll1Mod Then
                
                If HScroll1.Value = HScroll1.Min Then
                    H1M = -HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Min + 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            Else
                H1C = 1 'this stops the hscroll updating
                
                
                If HScroll1.Value > HScroll1.Min And LastH1Dir = 1 Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 1 Then
                    HScroll1.Value = HScroll1.Value + 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 2 Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value < HScroll1.Max - 1 And LastH1Dir = 2 Then
                    HScroll1.Value = HScroll1.Value + 1
                End If
                
                LastH1Val = HScroll1.Value
                H1C = 0
            End If
        Else
            
            LastH1Val = 0
        End If
    Else
        H1M = 0
    End If
    If HScroll1.Value = HScroll1.Min Then LastH1Val = HScroll1.Min
    If HScroll1.Value = HScroll1.Max Then
        LastH1Val = HScroll1.Max
        
    End If
    THold = HScroll1.Value
    
    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
        WinLeft = THold * HScroll1Mod + H1M
        x = x '87130,87125
    Else

        If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
            WinLeft = (THold * (Len(MCXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            WinLeft = (THold * (Len(GCXOverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            WinLeft = (THold * (Len(SSSubSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
            WinLeft = (THold * (Len(CXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
            WinLeft = (THold * (Len(PPXOSeq(0)) / SLen)) * HScroll1Mod
        Else
            WinLeft = (THold * (Len(XOverSeq(0)) / SLen)) * HScroll1Mod
        End If

    End If
'432620
    If PermNextno < 0 Then PermNextno = 0

    If WinLeft < 1 Then
        WinLeft = 1
    End If
    Picture1.ScaleMode = 3
    Picture1.CurrentX = 0
    Picture1.CurrentY = 0
    'Set up text output
    
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If AncSeqFlag = 1 Then
            Dim TestString As String, PrintString As String, ColWid As Double, ColCol As Long, MaxY As Long, MinY As Long, StartX, EndY, StartY
            
            Form1.Picture22.AutoRedraw = True
            Form1.Picture22.BackColor = Form1.Picture1.BackColor
            Form1.Picture22.Font = Form1.Picture1.Font
            Form1.Picture22.FontSize = Form1.Picture1.FontSize
            Form1.Picture22.CurrentX = 0
            Form1.Picture22.CurrentY = 0
            
            
            'draw bars
            TestString = String(PrintSeqLen, "A")
            ColWid = Picture22.TextWidth(TestString)
            ColWid = ColWid / PrintSeqLen
            Dim TH As Single, Ya As Single
            TH = Picture22.TextHeight("A") '- 1
            Ya = tTYF * Screen.TwipsPerPixelY
            'draw the sequence blocks
            For Y = 0 To 26 Step 13
                If Y = 0 Then
                    PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
                ElseIf Y = 13 Then
                    PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
                Else
                    PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
                End If
                
                
                For x = 1 To PrintSeqLen
                    'For Y = 0 To nruns
                    If x + WinLeft <= Len(StrainSeq(0)) Then
                        If x + WinLeft < UBound(AncPVals, 2) Then
                            StartX = (x - 1) * ColWid
                            If Mid$(PrintString, x, 1) = "A" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 128, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "C" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 255, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "G" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 128, 255), BF
                            ElseIf Mid$(PrintString, x, 1) = "T" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 255, 128), BF
                            End If
                            x = x
                        End If
                        'Next Y
                        
                        
                    End If
                Next x
                
                Form1.Picture22.CurrentX = 0
                Form1.Picture22.CurrentY = Y * tTYF * Screen.TwipsPerPixelY
                Form1.Picture22.Print PrintString
                x = x
            Next Y
            
    '        'Write the sequences
    '        PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '        PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.CurrentY = 13 * tTYF * Screen.TwipsPerPixelY
    '        Form1.Picture22.Print PrintString
    '        Form1.Picture22.CurrentY = 26 * tTYF * Screen.TwipsPerPixelY
    '        PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '
    '
            
            
            
            'ColWid = ColWid / (nruns + 1)
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            For x = 0 To PrintSeqLen
                'For Y = 0 To nruns
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    If x + WinLeft < UBound(AncPVals, 2) Then
                        StartX = x * ColWid '+ Y * ColWid
                        EndY = AncPVals(0, x + WinLeft) * MaxY
                        If AncPVals(0, x + WinLeft) > 0.95 Then
                            Form1.Picture22.ForeColor = RGB(0, 0, 255)
                        ElseIf AncPVals(0, x + WinLeft) > 0.75 Then
                            Form1.Picture22.ForeColor = RGB(0, 255, 0)
                        Else
                            Form1.Picture22.ForeColor = RGB(255, 0, 0)
                        End If
                    End If
                    'Next Y
                    Form1.Picture22.Line (StartX + 10, MinY)-(StartX + ColWid, StartY + EndY), , BF
                    
                End If
            Next x
            MinY = MinY + MaxY + 50
            MaxY = Picture22.Height - MinY - 100 'MinY + ((Picture22.Height) - MinY) / 2
            'MaxY = MaxY / 2
            For x = 0 To PrintSeqLen
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    StartX = x * ColWid
                    EndY = 0
                    StartY = MinY
                    For Y = 1 To 4
                        
                            If x + WinLeft < UBound(AncPVals, 2) Then
                                EndY = (AncPVals(Y, x + WinLeft) * (MaxY))
                                If Y = 1 Then
                                    Form1.Picture22.ForeColor = RGB(255, 128, 128)
                                ElseIf Y = 2 Then
                                    Form1.Picture22.ForeColor = RGB(128, 255, 128)
                                ElseIf Y = 3 Then
                                    Form1.Picture22.ForeColor = RGB(128, 128, 255)
                                ElseIf Y = 4 Then
                                    Form1.Picture22.ForeColor = RGB(255, 255, 128)
                                End If
                            End If
                            'Next Y
                            If EndY >= 0 Then
                                Form1.Picture22.Line (StartX + 10, StartY)-(StartX + ColWid, StartY + EndY), , BF
                            Else
                                EndY = 0
                            End If
                            StartY = StartY + EndY
                    Next Y
                End If
            Next x
            
            Form1.Picture22.ForeColor = Form1.Picture1.BackColor
            Form1.Picture22.Line (Picture9.Width - 10, 0)-(Picture22.Width, Picture22.Height), , BF
            Form1.Picture22.ForeColor = 0
            
            
            'Draw Axes and Key
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            'Axes
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 10, StartY + MaxY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 60, MinY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY + (StartY + MaxY - MinY) / 2)-(Picture9.Width + 60, MinY + (StartY + MaxY - MinY) / 2)
            Form1.Picture22.Line (Picture9.Width + 10, StartY + MaxY)-(Picture9.Width + 60, StartY + MaxY)
            
            Form1.Picture22.Font = Picture3.Font
            Form1.Picture22.FontSize = Form1.Picture3.FontSize
            'Draw sequence labels
            
            'P3.CurrentY = -VSV + (X + 1) * 13 * tTYF
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = 2 * Screen.TwipsPerPixelY
            
            Form1.Picture22.Print "Max. parsimony"
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = (13 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.Print "Max. likelihood"
            Form1.Picture22.CurrentY = (26 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.Print "Bayesian"
            
            
            
            
            
            If Picture22.FontSize < 6 Then Picture22.FontSize = 6
            If Picture22.FontSize > 10 Then Picture22.FontSize = 10
            
            
            
            'Do Tick labels
            Mu = Picture22.TextHeight("O") / 2
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu: Form1.Picture22.Print "0.0"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu + (StartY + MaxY - MinY) / 2: Form1.Picture22.Print "0.5"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = StartY + MaxY - Mu: Form1.Picture22.Print "1.0"
            
            'Draw keys
            Kx = Picture9.Width + 80 + Form1.Picture22.TextWidth("0.0") + 280
            Kh = Form1.Picture22.TextHeight("0.0")
            
            'Form1.Picture22.Print (kx, MinY + (MaxY - MinY) / 2 - mu)-(kx + kh, MinY + (MaxY - MinY) / 2 - mu + kh), RGB(0, 255, 0), BF
            Form1.Picture22.FontSize = Form1.Picture22.FontSize - 1
            Form1.Picture22.CurrentX = Kx
            Form1.Picture22.CurrentY = MinY + ((StartY + MaxY - MinY) - Picture22.TextWidth("Prob.")) / 2 - Mu * 0.5
            
            
            Call DoText(Form1.Picture22, Form1.Picture22.Font, "Prob.", 270)
            
            Kx = Picture9.Width + 80
            Kh = Form1.Picture22.TextHeight("0.0") / 1.5
            MaxY = MaxY + 100
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu)-(Kx + Kh, StartY + MaxY + Mu + Kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx, StartY + MaxY + mu * 2 + kh)-(kx + kh, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu)-(kx + kh + 500, StartY + MaxY + mu + kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu * 2 + kh)-(kx + kh + 500, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "A"
            
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh, StartY + MaxY + Mu * 2 + Kh * 2), RGB(128, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "C"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu)-(Kx + Kh + 500, StartY + MaxY + Mu + Kh), RGB(128, 128, 255), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "G"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh + 500, StartY + MaxY + Mu * 2 + Kh * 2), RGB(255, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "T"
            
            
            Form1.Picture22.Refresh
            Form1.Picture22.Visible = True
        End If
    End If
    
 '432596
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If ShowSeqFlag = 0 Then
            
            If (WinLeft + PrintSeqLen) > UBound(Decompress, 1) Then ReDim Preserve Decompress(WinLeft + PrintSeqLen)
            If Decompress(WinLeft) = WinLeft And (Decompress(WinLeft + PrintSeqLen) = WinLeft + PrintSeqLen Or Decompress(WinLeft + PrintSeqLen) = 0) Then
                For x = 0 To PermNextno
                    '@
                    If x <= UBound(StrainSeq, 1) Then
                        Output(x) = Mid$(StrainSeq(x), WinLeft, PrintSeqLen)
                    End If
                Next
            Else
                ' reads the full sequence from file
                    NF = FreeFile
                    Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                    
                    ReadLen = PrintSeqLen * (NextNo + 1)
                    ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                    FileSeqString = String(ReadLen, " ")
                     oDir = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "RDP5Longseq" + UFTag For Binary As #NF
                        Get #NF, ReadStart, FileSeqString
                    Close #NF
                     
                    ChDrive oDir
                    ChDir oDir
                    'reconfigure and add to output
                    For x = 0 To PermNextno
                        Output(x) = String(PrintSeqLen + 1, " ")
                    Next x
                    PosInString = 0
                    For Y = 1 To PrintSeqLen
                        For x = 0 To PermNextno
                            PosInString = PosInString + 1
                            Mid$(Output(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                        Next x
                    Next Y
                   
    '                XX = 0
                
            End If
    
        Else
    
            If ShowSeqFlag = 1 Then
                'Take the known SpacerSeqs and transfer these to SpacerSeqs
                
                If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                    RecompX = Recompress(WinLeft - 1 + Y)
                    If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                 
                        If pGCTripletflag = 0 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) Then
                            If pGCTripletflag = 0 Then
                                If Seq1 <> Seq2 Then
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                    Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x + 1) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        End If
                                    Next 'X
                
                                Else
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        End If
                                    Next 'X
                
                                End If
                                x = x
                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                Else
                                    Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen)
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen)
                                Else
                                    Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen)
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    MinParPos = 2
                                Else
                                    Output(2) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen)
                                    MinParPos = 2
                                End If
                                If SpacerNo + 2 > UBound(Output, 1) Then
                                    ReDim Preserve Output(SpacerNo + 2)
                                End If
                                If SpacerNo > 0 Then
    '                                If DebuggingFlag < 2 Then On Error Resume Next
    '                                UB = -1
    '                                UB = UBound(XOverSeq, 1)
    '                                On Error GoTo 0
                                    If AllowExtraSeqsFlag = 1 And ShowSeqFlag = 1 Then
                                        UB = UBound(SpacerSeqs, 1)
                                        For x = 1 To SpacerNo
                                            If x <= UB Then
                                                Output(x + 2) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                            'Else
                                            '    Exit For
                                            End If
                                        Next 'X
                                    End If
                                End If
                                
                            End If
    '                        XX = Output(3)
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                                Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen)
                                Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = Mid$(StrainSeq(RevSeq(x)), WinLeft, PrintSeqLen)
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen)
                            Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
            
                        Else 'If XOverlist(RelX, RelY).ProgramFlag <> 1 And XOverlist(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen)
                            If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen)
                            End If
                            Z = 1
                            SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                            For x = 0 To PermNextno
                                If x <> Seq3 Then
                                    If Daught(SEN, TreeTrace(x)) > 0 Then
                                        Z = Z + 1
                                        Output(Z) = Mid$(StrainSeq(TreeTrace(x)), WinLeft, PrintSeqLen)
                                        
                                    End If
                                End If
                            Next x
                            Z = Z + 1
                            Output(Z) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen)
                            MinParPos = Z
                            If SpacerNo > 0 And (XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Or AllowExtraSeqsFlag = 1) Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    
                                    If x <= UB Then
                                        If SpacerSeqs(x) <= UBound(StrainSeq, 1) Then
                                            Output(x + Z) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                        Else
                                            If TreeTrace(SpacerSeqs(x)) <= UBound(StrainSeq, 1) Then
                                                Output(x + Z) = Mid$(StrainSeq(TreeTrace(SpacerSeqs(x))), WinLeft, PrintSeqLen)
                                            Else
                                                Output(x + Z) = ""
                                            End If
                                            If Output(x + Z) = "" Then
                                                x = x
                                            End If
                                            x = x
                                        End If
                                    Else
                                    
                                    End If
                                Next 'X
                            ElseIf XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                Output(Z + 1) = Mid$(SSOLSeq, WinLeft, PrintSeqLen)
                            End If
                        End If
                    Else
                        NF = FreeFile
                        'Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                        
                        ReadLen = PrintSeqLen * (NextNo + 1)
                        ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                        FileSeqString = String(ReadLen, " ")
                         oDir = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        Open "RDP5Longseq" + UFTag For Binary As #NF
                            Get #NF, ReadStart, FileSeqString
                        Close #NF
                        Dim TempOutput() As String
                        ReDim TempOutput(PermNextno)
                        ChDrive oDir
                        ChDir oDir
                        'reconfigure and add to output
                        
                        
                        
                        For x = 0 To PermNextno
                            TempOutput(x) = String(PrintSeqLen + 1, " ")
                        Next x
                        'XX = Len(TempOutput(0))
                        PosInString = 0
                        For Y = 1 To PrintSeqLen
                            For x = 0 To PermNextno
                                PosInString = PosInString + 1
                                Mid$(TempOutput(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                            Next x
                        Next Y
                        
                        If XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                            If pGCTripletflag = 0 Then
                                If Seq1 <> Seq2 Then
                                    Output(0) = TempOutput(Seq1)
                                    Output(1) = TempOutput(Seq2)
                                    MinParPos = 1
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x + 1) = TempOutput(SpacerSeqs(x))
                                        End If
                                    Next 'X
                
                                Else
                                    Output(0) = TempOutput(Seq1)
                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                                    UB = UBound(SpacerSeqs, 1)
                                    For x = 1 To SpacerNo
                                        If x <= UB Then
                                            Output(x) = TempOutput(SpacerSeqs(x))
                                        End If
                                    Next 'X
                
                                End If
                                x = x
                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = TempOutput(Seq1)
                                Else
                                    Output(0) = TempOutput(TreeTrace(Seq1))
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = TempOutput(TreeTrace(Seq3))
                                Else
                                    Output(1) = TempOutput(Seq3)
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = TempOutput(Seq2)
                                    MinParPos = 2
                                Else
                                    Output(2) = TempOutput(TreeTrace(Seq2))
                                    MinParPos = 2
                                End If
                            End If
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = TempOutput(Seq1)
                                Output(1) = TempOutput(Seq3)
                                Output(2) = TempOutput(Seq2)
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = TempOutput(RevSeq(x))
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = TempOutput(Seq1)
                            Output(1) = TempOutput(Seq2)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = TempOutput(SpacerSeqs(x))
                                End If
                            Next 'X
                            
                        ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = TempOutput(TreeTrace(Seq1))
                            'XX = Len(Output(0))
                            If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                Output(1) = TempOutput(TreeTrace(Seq3))
                            End If
                            Output(2) = TempOutput(TreeTrace(Seq2))
                            MinParPos = 2
                            If SpacerNo > 0 And XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    If x <= UB Then
                                        Output(x + 2) = TempOutput(SpacerSeqs(x))
                                    End If
                                Next 'X
                            ElseIf XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                'XX = Len(SSOLSeq)
                                'XX = XOverlist(RelX, RelY).DHolder
                                Output(3) = TempOutput(XoverList(RelX, RelY).DHolder) 'Mid$(SSOLSeq, WinLeft, PrintSeqLen)
                            End If
                        End If
                        
                        
                    End If
                End If
    
            Else
    
                If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                    If WinLeft < 1 Then WinLeft = 1
                    Output(0) = Mid$(MCXoverSeq(Seq1), WinLeft, PrintSeqLen)
                    'Exit Sub
                    Output(1) = Mid$(MCXoverSeq(Seq2), WinLeft, PrintSeqLen)
                    MinParPos = 1
                    If SpacerNo > 0 Then
                        UB = UBound(SpacerSeqs, 1)
                        For x = 1 To SpacerNo
                            If x <= UB Then
                                Output(x + 1) = Mid$(MCXoverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                            End If
                        Next 'X
                    
                    End If
    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
                    If pGCTripletflag = 0 Then
                        
        
                        If Seq1 <> Seq2 Then
                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen)
                            Output(1) = Mid$(GCXOverSeq(Seq2), WinLeft, PrintSeqLen)
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = Mid$(GCXOverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
        
                        Else
                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen)
                            'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x) = Mid$(GCXOverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen)
                                End If
                            Next 'X
        
                        End If
                    Else
                        Output(0) = Mid$(GCXOverSeq(0), WinLeft, PrintSeqLen)
                        Output(1) = Mid$(GCXOverSeq(2), WinLeft, PrintSeqLen)
                        Output(2) = Mid$(GCXOverSeq(1), WinLeft, PrintSeqLen)
                        MinParPos = 2
                    End If
                ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
        
                    
                        Output(0) = Mid$(PPXOSeq(Seq1), WinLeft, PrintSeqLen)
                        Output(1) = Mid$(PPXOSeq(Seq3), WinLeft, PrintSeqLen)
                        Output(2) = Mid$(PPXOSeq(Seq2), WinLeft, PrintSeqLen)
                        MinParPos = 2
                        num = 3
                        For x = 0 To NumberOfSeqs
                            If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                Output(num) = Mid$(PPXOSeq(RevSeq(x)), WinLeft, PrintSeqLen)
                                num = num + 1
                            End If
                        Next 'X
                    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                    Output(0) = Mid$(SSSubSeq(1), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(SSSubSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(SSSubSeq(0), WinLeft, PrintSeqLen)
                    MinParPos = 2
                    Output(3) = Mid$(SSSubSeq(3), WinLeft, PrintSeqLen)
                ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                    Output(0) = Mid$(CXoverSeq(0), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(CXoverSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(CXoverSeq(1), WinLeft, PrintSeqLen)
                    MinParPos = 2
                Else
                    Output(0) = Mid$(XOverSeq(0), WinLeft, PrintSeqLen)
                    Output(1) = Mid$(XOverSeq(2), WinLeft, PrintSeqLen)
                    Output(2) = Mid$(XOverSeq(1), WinLeft, PrintSeqLen)
                    MinParPos = 2
                    If SpacerNo + 2 > UBound(Output, 1) Then
                        ReDim Preserve Output(SpacerNo + 2)
                    End If
                    If SpacerNo > 0 Then
                        If DebuggingFlag < 2 Then On Error Resume Next
                        UB = -1
                        UB = UBound(XOverSeq, 1)
                        On Error GoTo 0
                        If UB > 2 Then
                            For x = 1 To SpacerNo
                                If x + 2 <= UB Then
                                    Output(x + 2) = Mid$(XOverSeq(x + 2), WinLeft, PrintSeqLen)
                                Else
                                    Exit For
                                End If
                            Next 'X
                        End If
                    End If
    
                End If
    
            End If
    
        End If
    End If
    '437080
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
    Dim YCon As Long
    
    'XX = Form1.Picture1.TextWidth(Output(0))
    If Form1.Picture1.FontSize = P1FontSize Then 'some systems have fonts with different basic sizes
        'XConA = Form1.Picture1.TextWidth("A")
        
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
        x = x
    Else
       ' XConA = Form1.Picture1.TextWidth("A")
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
        'XConA = 1
'        XX = Form1.Picture1.TextHeight("A") / Form1.Picture1.TextWidth("A")
        YConA = 1.1
    End If
    
    
    PrintSeqLen = MakePrintSeqLen * YConA '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G")) * YConA
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If ShowSeqFlag = 0 Then 'If the current selection is "show all sequences"
    '        SS = Abs(GetTickCount)
                'XX = Picture1.ScaleWidth
                
                If ColDistInFile = 1 Then
                    If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
                        'redim SubValid(0,0)
                        ReDim SubDiffs(0, 0)
                        'redim sMat(0,0)
                        ReDim FubValid(0, 0)
                        'Erase FMat
                    End If
                    Timer7(1).Enabled = False
                    If DebuggingFlag < 2 Then On Error Resume Next
                    
                    UB = UBound(ColDist2, 1)
                    On Error GoTo 0
                    If UB = 0 Then
                        ReDim ColDist2(UBCD2)
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                        Open "RDP5CDFile" + UFTag For Binary As #FF
                        Get #FF, , ColDist2
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    End If
                    
                End If
                '591168
                Picture1.FillStyle = 0
                
                ''For zzz = 1 To 10
                Dim NSL As Long, DRSN1 As Long, UBSL2 As Long, UBI As Long, UBR As Long, StoreNum1 As Long, RSN1 As Long, Offset1 As Long, Offset2 As Long, Offset3 As Long, Offset4 As Long, Col1 As Long, Col2 As Long, Col3 As Long, Col4 As Long, Col5 As Long
                
    '            SS = Abs(GetTickCount)
                
'                Col1 = RGB(128, 128, 255)
'                Col2 = RGB(255, 128, 128)
'                Col3 = RGB(255, 0, 0)
'                Col4 = RGB(128, 0, 0)
'                Col5 = RGB(64, 64, 255)
                
                'ReDim ColX(255)
                'ColX (1)
                
                UBI = UBound(Identical)
                UBR = UBound(Recompress)
                UBSL2 = UBound(SeqLines, 2)
                For Y = 1 To PrintSeqLen
                    StoreNum1 = WinLeft + Y - 1
    '                If StoreNum1 >= 870 Then
    '                    X = X
    '                End If
                    If StoreNum1 <= UBR Then
                        RSN1 = Recompress(StoreNum1)
                        If RSN1 = 143 Then
                                x = x
                            End If
                        If UBI >= RSN1 Then
                            '@
                            YCon = StoreNum1 - WinLeft + 1
                            Offset1 = YCon * 8
                            Offset2 = YConA * 13
                            Offset3 = (PermNextno) * 13 + Offset2
                            Offset4 = Offset1 - 8
                            If StoreNum1 <= Decompress(Len(StrainSeq(0))) Then
                                If StoreNum1 - WinLeft > PrintSeqLen Then Exit For
                                RecompX = RSN1
                                
                                If UBI >= RSN1 Then
                                    '@
                                    If StoreNum1 = Decompress(RSN1) Then
                                        If UBSL2 < NumSeqLines + PermNextno Then
                                            UBSL2 = NumSeqLines + PermNextno * 3
                                            ReDim Preserve SeqLines(5, UBSL2)
                                        End If
                                        
                                        If Identical(RSN1) = 0 Then
                                            '@
                                            If x = 1234567 Then
                                                NSL = NumSeqLines
                                                NumSeqLines = FillSeqLines2(NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqLines, 1), ColDist2(0), SeqLines(0, 0), SeqColRef2(0), ColPos2(0))
                                            Else
                                                Dim StartP As Long, EndP As Long, SeqCol As Long
                                                
                                                StartP = ColPos2(RSN1)
                                                EndP = ColPos2(RSN1 + 1) - 2
                                                If StartP <> EndP Or x = x Then
                                                    'If SeqColRef2(RSN1) = 1 Then
                                                    SeqCol = ColX(SeqColRef2(RSN1))
'                                                    ElseIf SeqColRef2(RSN1) = 2 Then
'                                                        SeqCol = Col2 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 3 Then
'                                                        SeqCol = Col3 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 4 Then
'                                                        SeqCol = Col4 'colour of thing to draw
'                                                    End If
                                                    For x = StartP To EndP Step 2
                                                        '@
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(2, NumSeqLines) = Offset4 'X1
                                                        SeqLines(3, NumSeqLines) = CLng(ColDist2(x)) * 13 'Y1,7,9,13-16,18,21,23-24,8
                                                        SeqLines(4, NumSeqLines) = Offset1 'X2
                                                        SeqLines(5, NumSeqLines) = (CLng(ColDist2(x + 1))) * 13 + Offset2 'Y2
                                                        '@
                                                        SeqLines(1, NumSeqLines) = SeqCol
                                                        NumSeqLines = NumSeqLines + 1
                                                    Next 'X
                                                End If
                                            'End If
    '                                        ElseIf X = X Then
    '                                            NSL = NumSeqLines
    '                                            NumSeqLines = FillSeqLines(PermNextno, NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqColRef, 1), UBound(SeqLines, 1), UBound(ColDist, 1), ColDist(0, 0), SeqLines(0, 0), SeqColRef(0, 0))
    '                                            'X = X
    '                                        Else
    '                                        ''If X = 12345 Then
    '                                            For X = 0 To PermNextno
    '                                                ''Offset4 = X * 13
    '                                                If SeqColRef(RSN1, X) > 0 Then
    '                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
    '                                                    SeqLines(2, NumSeqLines) = Offset4 'X1
    '                                                    SeqLines(3, NumSeqLines) = X * 13 'Y1
    '                                                    SeqLines(4, NumSeqLines) = Offset1 'X2
    '                                                    SeqLines(5, NumSeqLines) = (X + ColDist(RSN1, X) - 1) * 13 + Offset2 'Y2
    '                                                    If SeqColRef(RSN1, X) = 1 Then
    '                                                        SeqLines(1, NumSeqLines) = Col1
    '                                                    ElseIf SeqColRef(RSN1, X) = 2 Then
    '                                                        SeqLines(1, NumSeqLines) = Col2 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 3 Then
    '                                                        SeqLines(1, NumSeqLines) = Col3 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 4 Then
    '                                                        SeqLines(1, NumSeqLines) = Col4 'colour of thing to draw
    '                                                    End If
    '                                                    NumSeqLines = NumSeqLines + 1
    '                                                    X = X + ColDist(RSN1, X)
    '                                                Else
    '                                                    X = X
    '                                                End If
    '                                            Next 'X
    '                                            ''End If
                                            End If
                
                                        Else '
                                            
                                            'Picture1.FillColor = RGB(64, 64, 255)
                                            'Picture1.ForeColor = RGB(64, 64, 255)
                                            'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = ColX(0)  'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = Offset4 'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Offset1 'X2
                                            SeqLines(5, NumSeqLines) = Offset3 'Y2
                                            NumSeqLines = NumSeqLines + 1
            '                                If UBound(SeqLines, 2) < NumSeqLines Then
            '                                    ReDim Preserve SeqLines(5, NumSeqLines + 2000)
            '                                End If
                                            
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                Next 'Y
    '            EE = Abs(GetTickCount)
    '            TT = EE - SS
    '            X = X ''687,703,719
                ''0.610,609,0.625 with rsn1
                '0.609 offset1
                '0.578 with 2000 redim
                
                ''Next zzz
                If ColDistInFile = 1 Then
                    Timer7(1).Enabled = True
                End If
                If WinLeft + PrintSeqLen < UBound(Recompress, 1) Then
                    If Recompress(WinLeft + PrintSeqLen) <> WinLeft + PrintSeqLen Then GoOn = 1
                End If
                If WinLeft <= UBound(Recompress, 1) Then
                If GoOn = 1 Or Recompress(WinLeft) <> WinLeft Then
                    For Y = WinLeft To WinLeft + PrintSeqLen
                        YCon = Y - WinLeft + 1
                        'XX = UBound(ABCons, 1)
                        If Y <= UBound(ABCons, 1) Then
                            If ABCons(Y) <> 0 Then
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            ElseIf Y <> Decompress(Recompress(Y)) Then    'these sites are ignored
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 128, 64) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            End If
                        End If
                    Next Y
                End If
                End If
                
                
                Picture1.ForeColor = 0
    '        EE = Abs(GetTickCount)
    '        TT = EE - SS
    '        X = X
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            Pict = 0
            Pict = Picture1.hdc
            If Pict = 0 Then
               Picture1.Height = Picture1.Width * 2
               Pict = Picture1.hdc
               Set Form1.Picture1.Picture = Form1.Picture1.Image
                Set sPic = Form1.Picture1.Picture
                cDib.CreateFromPicture sPic
            End If
            On Error GoTo 0
            Dim OutputNum As Long
            For x = 0 To UBound(Output)
                If Output(x) = "" Then Exit For
            Next x
            OutputNum = x
            If XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                For Y = 1 To PrintSeqLen
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                            RecompX = WinLeft + Y - 1
                            If ShowSeqFlag = 1 Then
                                
                                If (XPosDiff(Recompress(WinLeft - 2 + Y)) <> XPosDiff(RecompX)) Then 'And SeqNum(WinLeft + Y - 1, Seq3) <> 46 Then
                                    If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 12  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 12 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        
                                    End If
                                    If SeqNum(RecompX, Seq2) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 26  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    End If
                                    'ElseIf SeqNum(WinLeft + Y - 1, Seq1) = SeqNum(WinLeft + Y - 1, Seq2) And SeqNum(WinLeft + Y - 1, Seq1) <> 46 Then
                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                    '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                    'End If
                                    num = 2
                                    If SeqNum(RecompX, Seq3) <> 46 Then
                                        For Z = 0 To OutputNum
                                            If RevSeq(Z) <> Seq1 And RevSeq(Z) <> Seq2 And RevSeq(Z) <> Seq3 Then
                                                num = num + 1
                                                If SeqNum(RecompX, RevSeq(Z)) = SeqNum(RecompX, Seq3) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), mPurple, BF
                                                ElseIf SeqNum(RecompX, RevSeq(Z)) <> 46 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), Yellow, BF
                                                End If
                                                    'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'Else
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'End If
                    
                                                
                                                    
                                            End If
                                            
                                            
                                        Next Z
                                    End If
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((NumberOfSeqs) * 13 + 13) * tTYF), RGB(92, 92, 92), BF
                                End If
                               
                            Else
            
                                If WinLeft + Y - 1 < Len(PPXOSeq(0)) + 1 Then
                                        If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 12  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line ((Y * 8) - 7, 0)-((Y * 8), 12 * tTYF), Yellow, BF
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            
                                            
                                        End If
                                        If Mid$(Output(MinParPos), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 26  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        End If
                                        'ElseIf mid$(output(0),y,1) = mid$(output(2),y,1) And mid$(output(0),y,1) <> 46 Then
                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                        '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                        'End If
                                        num = 2
                                        If Mid$(Output(1), Y, 1) <> "-" Then
                                            For Z = 3 To OutputNum
                                                
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), mPurple, BF
                                                    ElseIf Mid$(Output(Z), Y, 1) <> "-" Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), Yellow, BF
                                                    End If
                                                        'If mid$(output(0),y,1) <> 46 And mid$(output(0),y,1) <> 47 Then
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'Else
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'End If
                        
                                                    
                                                
                                                
                                            Next Z
                                        End If
                                End If
            
                            End If
                        End If
                    End If
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                
                If pGCTripletflag = 0 Then
                    If ShowSeqFlag = 1 Then
        
                        For Y = 1 To PrintSeqLen
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If GCIdentical(RecompX) = 0 Then 'Or GCMonoSiteFlag = 1
        
                                
                                    If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            'Else
                                            '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), LPurple, BF
                                            'End If
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq1) Or SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq2) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                            End If
            
                                        Next 'Z
                                    End If
        
                                
        
                                ElseIf GCIdentical(RecompX) = 2 And GCIndelFlag = 1 Then
                                    StartY = Y
            
                                    Do While GCIdentical(RecompX) = 2
                                        Y = Y + 1
                                    Loop
            
                                    Y = Y - 1
            
                                    If Y = StartY Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                    Else
                                        'Teststring = Mid$(StrainSeq(Seq1), WinLeft + starty - 1, Y - starty)
            
                                        If Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) = Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                            End If
            
                                        Next 'Z
            
                                    End If
            
                                Else
            
                                    If GCMonoSiteFlag = 1 And SeqNum(RecompX, Seq1) > 60 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = ((NumEnabledSeqs) * 13 + 12)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), mPurple, BF
                                    Else
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), RGB(92, 92, 92), BF
                                    End If
            
                                End If
                            End If
                            
                        Next 'Y
        
                    Else
        
                        For Y = 1 To PrintSeqLen
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or x = x Then
                                    RecompX = Recompress(WinLeft - 1 + Y)
                                    If GCIndelFlag <> 1 Then
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                            End If
                
                                        End If
                
                                    Else
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If GCIdentical(GCXDiffPos(RecompX)) = 2 Then
                                                StartY = Y
                
                                                Do While GCIdentical(GCXDiffPos(RecompX)) = 2
                                                    Y = Y + 1
                                                Loop
                
                                                Y = Y - 1
                
                                                If Y = StartY Then
                
                                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8)) * tTYF, 25 * tTYF), mPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                Else
                                                    'TestString = Mid$(Output(0), StartY, Y - StartY + 1)
                
                                                    If Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) = Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                End If
                
                                            Else
                
                                                If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                                Else
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                End If
                
                                                For Z = 1 To OutputNum
                
                                                    If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                    End If
                
                                                Next 'Z
                
                                            End If
                
                                        End If
                
                                    End If
                                End If
                            End If
                        Next 'Y
        
                    End If
                Else ' ie gctriplrtflag=1
                   
                    LastY = -1
                    
                    For Y = 1 To PrintSeqLen
                        If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                            If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or x = x Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If (RecompX) > UBound(XPosDiff, 1) Then Exit For
                                If RecompX > 0 Then
                                
                                    If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX - 1) <> XPosDiff(RecompX)) Or ShowSeqFlag = 2 Then
                                        If LastY > -1 And ShowSeqFlag = 1 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (LastY * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y - 1) * 8  'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                            x = x
                                        End If
                                        LastY = -1
                                        Test$ = Mid$(Output$(0), Y, 1)
                    
                                        If Test$ <> "*" And Test$ <> "" Then
                                            CountHits = 0
                    
                                            For x = 0 To 2
                                                If x = 2 Then x = MinParPos
                                                If Mid$(Output(x), Y, 1) = Test$ Then
                                                    CountHits = CountHits + 1
                                                End If
                    
                                            Next 'X
                    
                                            If CountHits < 3 Then
                                                A = 0
                                                C = 0
                                                g = 0
                                                T = 0
                                                S = 0
                    
                                                For Z = 0 To 2
                                                    If Z = 2 Then Z = MinParPos
                                                    If Mid$(Output(Z), Y, 1) = "A" Then
                                                        A = A + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                        C = C + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                        g = g + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                        T = T + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                        S = S + 1
                                                    End If
                    
                                                Next 'Z
                    
                                                If A >= g And A >= T And A >= C Then
                                                    CountHits = A
                                                    Test$ = "A"
                                                ElseIf C >= g And C >= T And C >= A Then
                                                    CountHits = C
                                                    Test$ = "C"
                                                ElseIf g >= A And g >= T And g >= C Then
                                                    CountHits = g
                                                    Test$ = "G"
                                                ElseIf T >= g And T >= A And T >= C Then
                                                    CountHits = T
                                                    Test$ = "T"
                                                End If
                    
                                            End If
                    
                                            If CountHits / (2 + 1) = 1 Or S > 0 Or CountHits = 1 Then
                                                If CountHits <> 1 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                
                                                End If
                                            ElseIf CountHits / (3) >= 0.75 Then
                    
                                                For Z = 0 To OutputNum
                    
                                                    If Mid$(Output(Z), Y, 1) = Test$ Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(128, 128, 128) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        
                                                    End If
                    
                                                Next 'Z
                    
                                            Else
                    
                                                For Z = 0 To OutputNum
                    
                                                    If ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0 Then
                    
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13 - 1) * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                            x = x
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13 - 1) * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mGreen, BF
                                                            x = x
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13 - 1) * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mPurple, BF
                                                            x = x
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And XPosDiff(RecompX) = 0 Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                        x = x
                                                    End If
                    
                                                Next 'Z
                    
                                            End If
                    
                                        End If
                    
                                    Else
                    
                                        If LastY = -1 Then
                                            LastY = Y
                                        End If
                    
                                    End If
                                End If
                            End If
                        End If
        
                    Next 'Y
        
                    If LastY > -1 And ShowSeqFlag = 1 Then
                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)   'X1
                        SeqLines(3, NumSeqLines) = 0 'Y1
                        SeqLines(4, NumSeqLines) = Y * 8   'X2
                        SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                        NumSeqLines = NumSeqLines + 1
                        If UBound(SeqLines, 2) < NumSeqLines Then
                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                        End If
                        'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-(((Y - 1) * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                        x = x
                    End If
                End If
                Picture1.ForeColor = 0
            ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For Y = 1 To PrintSeqLen
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                    
                        If ShowSeqFlag = 1 Then
                            If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If MCIdentical(RecompX) = 0 Then
            
                                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
            
                                            If SeqNum(RecompX, Seq1) <> 46 And SeqNum(RecompX, Seq1) <> 47 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                                x = x
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                                x = x
                                            End If
            
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                            x = x
                                        End If
            
                                    End If
            
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), RGB(92, 92, 92), BF
                                    x = x
                                End If
            
                            Else
            
                                If WinLeft + Y - 1 < Len(MCXoverSeq(0)) + 1 Then
                                    'teststring = Mid$(Output(0), Y, 1)
            
                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
            
                                        If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(0), Y, 1) <> "." Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            x = x
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                            x = x
                                        End If
            
                                    Else
                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        x = x
                                    End If
            
                                End If
                            End If
        
                        End If
                    End If
    
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                LastY = -1
    
                For Y = 1 To PrintSeqLen
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or x = x Then
                            If Recompress(Y + WinLeft - 1) < UBound(XPosDiff, 1) Then
                                RecompX = Recompress(WinLeft + Y - 1)
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = ((Y - 1) * 8)  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        If CountHits / (3) <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        End If
                
                                        If CountHits / 3 = 1 Then
                                            If ShowSeqFlag = 1 Then
                                                If DebuggingFlag < 2 Then On Error Resume Next
                                                UB2 = 0
                                                UB2 = UBound(PScores, 1)
                                                On Error GoTo 0
                                                If UB2 > 0 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                End If
                                            ElseIf ShowSeqFlag = 2 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                            End If
                                        ElseIf CountHits / (3) >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                
                                            For Z = 0 To OutputNum
                
                                                If (ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0) And Output(Z) <> "" Then
                                                     If DebuggingFlag < 2 Then On Error Resume Next
                                                    UB2 = 0
                                                    UB2 = UBound(PScores, 1)
                                                    On Error GoTo 0
                                                    
                                                    
                                                    If UB2 = 15 Then
                                                        ReDim Preserve PScores(Len(StrainSeq(0))) 'Exit Sub
                                                        ReDim Preserve PltCol3(15)
                                                        'XX = UBound(PltCol3, 1)
                                                        'Exit Sub
                                                    End If
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                        
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                            ReDim Preserve PltCol3(15)
                                                            
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB3 = 0
                                                            UB3 = UBound(PScores, 1)
                                                            UB2 = UBound(PltCol3, 1)
                                                            On Error GoTo 0
                                                            
                                                            If UB2 > 0 And UB3 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13) * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf CountHits = 1 Then
                                                        'Picture1.Line ((Y * 8) - 8, (Z) * 13)-((Y * 8), (Z) * 13 + 12), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    End If
                
                                                ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or PScores(RecompX) = 0) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                ElseIf ShowSeqFlag = 1 And PScores(RecompX) > 0 And Output(Z) <> "" Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))   'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), PltCol3(PScores(WinLeft + Y - 1)), B
                                                End If
                
                                            Next 'Z
                
                                        End If
                
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            End If
                        End If
                    End If
                Next 'Y
    
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                    'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-(((Y - 1) * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                End If
    
            
            ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 Or XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                LastY = -1
                
                For Y = 1 To PrintSeqLen
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                         RecompX = Recompress(WinLeft + Y - 1)
                        If RecompX <= UBound(XDiffPos, 1) Then
                            If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or x = x Then
                               
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And (XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2)) Or XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft)))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                        x = x
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        If x = x Then 'CountHits / 3 <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        End If
                
                                        If CountHits / 3 = 1 Or S > 0 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                            x = x
                                        ElseIf CountHits / 3 >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (z) * 13 * tTYF)-((Y * 8) * tTYF, (z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                                            GoOn = 0
                                            If (WinLeft + Y - 1) >= 1 Then
                                                'If XPosDiff(WinLeft + Y + 1) <> XPosDiff(WinLeft + Y) Then
                                                    X0 = Mid$(Output(0), Y, 1)
                                                    X1 = Mid$(Output(1), Y, 1)
                                                    X2 = Mid$(Output(MinParPos), Y, 1)
                                                    If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(1), Y, 1) <> "-" And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                                        GoOn = 1
                                                    End If
                                                'End If
                                            End If
                                           
                                            If GoOn = 1 Then
                                                For Z = 0 To OutputNum
                                                    
                                                    If ShowSeqFlag = 2 Or (XPosDiff(RecompX) <> 0 And GoOn = 1) Then
                                                        
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mGreen, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mPurple, BF
                                                            'X = X
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or GoOn = 0) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                    
                                                    End If
                    
                                                Next 'Z
                                            Else
                                                
                                                'SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                'SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                'SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                                'SeqLines(3, NumSeqLines) = 0 'Y1
                                                'SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                                'SeqLines(5, NumSeqLines) = ((3 + SpacerNo) * 13)  'Y2
                                                'NumSeqLines = NumSeqLines + 1
                                                'If UBound(SeqLines, 2) < NumSeqLines Then
                                                '    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                'End If
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0  'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            
                                            End If
                                        End If
                                        
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            End If
                        End If
                    End If
                Next 'Y
                
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                    'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-(((Y - 1) * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                    x = x
                End If
    
            End If
    
        End If
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
 'XX = Len(Output(0))
'593248
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If WinLeft > Decompress(Len(StrainSeq(0))) - 58 Then
    
            For x = 0 To PermNextno
    
                If Len(Output(x)) > 0 Then
                    Output(x) = Output(x) + String$(58 - (Decompress(Len(StrainSeq(0))) - WinLeft), " ")
                End If
    
            Next 'X
    
        End If
    End If
    'XX = Picture1.TextHeight("A") - 3
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        Dim LOut As Long
        LOut = Len(Output(0))
        SeqText2 = String(LOut * (PermNextno + 2), " ")
        If Picture1.FontSize > 3 Or x = x Then
       
            For x = 0 To UBound(Output, 1) 'PermNextno
        
                If Len(Output(x)) > 0 Then
                    If UBound(SeqText, 1) < NumSeqText Then
                        ReDim Preserve SeqText(NumSeqText + 20)
                    End If
                    
                    SeqText(NumSeqText) = Output(x)
                    Mid$(SeqText2, 1 + (x * LOut), LOut) = Output(x)
                    '@
                    SeqLines(0, NumSeqLines) = 1 'this is text
                    '@
                    SeqLines(1, NumSeqLines) = NumSeqText 'position of string in seqtext
                    SeqLines(2, NumSeqLines) = 0 'xposition
                    SeqLines(3, NumSeqLines) = x * 13 'yposition
                    NumSeqText = NumSeqText + 1
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
    
                    'TextOut Pict, 0, (((X * 13 - TYFM) * tTYF)), Output(X), Len(Output(X))
                End If
        
            Next 'X
        End If
    
        'XX = Len(Output(1))
        '596996
        'If OnlyDoPosBar = 1 Then GoTo PosBarBit
        
        If DSDFlag = 0 Then
            Call DoSeqDisplay
        ElseIf DSDFlag = 1 Then
'            Dim sPic As StdPicture, cDib As New cDibSection, hdcHolder As Long
'            '@
           Dim hdcHolder As Long
            hdcHolder = cDib.hdc
            Call DoSeqDisplayDIB(hdcHolder)
            'Form1.Picture1.Top = -300
            'Form1.Picture1.Left = -300
            BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            'cDib.PaintPicture Form1.Picture1.hdc
        ElseIf DSDFlag = 2 Then
            If (PrintSeqLen <> LastPrintSeqLen Or LeftPos <> LastLeftPos) And (LastTop <> TopPos Or LastBottom <> BottomPos) Then
                hdcHolder = cDib.hdc
                
                Call DoSeqDisplayDIB2(hdcHolder)
                'Form1.Picture1.Top = -300
                'Form1.Picture1.Left = -300
                BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                'cDib.PaintPicture Form1.Picture1.hdc
            
            ElseIf (PrintSeqLen <> LastPrintSeqLen Or LeftPos <> LastLeftPos) Then ' just do left right thing
                hdcHolder = cDib.hdc
                
                BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                Call DoSeqDisplayDIB2(hdcHolder)
                BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            ElseIf (LastTop <> TopPos Or LastBottom <> BottomPos) Then ' just do up down thing
            
            End If
            hdcHolder = cDib.hdc
            Call DoSeqDisplayDIB(hdcHolder)
            'Form1.Picture1.Top = -300
            'Form1.Picture1.Left = -300
            BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            'cDib.PaintPicture Form1.Picture1.hdc
        
        
            LastPrintSeqLen = PrintSeqLen
            LastLeftPos = LeftPos
            LastTop = TopPosY
            LastBottom = BottomPosY
            
        End If
        '601668
        If VScroll3.Value <> LastVScroll3Value Then
            If ShowSeqFlag = 0 Then
                Call PrintNames
            Else
                Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
            End If
             LastVScroll3Value = VScroll3.Value
        End If
    End If
    

   
    
    Picture1.DrawMode = 13
    Picture1.ForeColor = 0
    
    
    'If ShowSeqFlag = 1 Then
    '    Picture7.Refresh
    '    Picture7.AutoRedraw = False
    '    Picture7.DrawMode = 12
    '    Picture7.Line (P1, 5)-(P2, 10 - 1), QuaterColour, BF ' QBColor(7), BF
    '    Picture7.DrawMode = 13
    '    Picture7.AutoRedraw = True
    'End If

    
    'do the scalebar
    LineBottom = Picture13.ScaleHeight
    LineTop = LineBottom - 2
    '@
    Picture13.FillColor = BackColours
    Picture13.ForeColor = BackColours
    Picture13.FillStyle = 0
    'Picture13.AutoRedraw = True
    'Picture13.Picture = LoadPicture()
    Dim TL As Integer, FSX As Integer
    FSX = Form1.Picture1.FontSize
    If FSX > 10 Then
        TL = 5
    ElseIf FSX > 6 Then
        TL = 10
    ElseIf FSX > 3 Then
        TL = 20
    Else
        TL = 50
    End If
    
    PrintSeqLen = MakePrintSeqLen
    
    Picture4.AutoRedraw = False
    Picture11.AutoRedraw = False
    If OnlyDoPosBar = 0 Or OnlyDoPositionIndicator = 1 Then
        
        Form1.Picture4.BorderStyle = 1
        P1 = CLng(((THold * HScroll1Mod) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        If ShowSeqFlag < 2 Then
            
            P2 = P1 + CLng(((PrintSeqLen - 5) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        Else
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                If (WinLeft + PrintSeqLen - 5) < Len(MCXoverSeq(0)) Then
                        P2 = CLng((Decompress(MCXDiffPos(WinLeft + PrintSeqLen - 5)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(MCXDiffPos(WinLeft)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                Else
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                   
                    End If
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(SSSubSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(CXoverSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            Else
                If WinLeft <= UBound(XDiffPos, 1) Then
                    If Recompress(WinLeft + PrintSeqLen - 5) < Len(XOverSeq(0)) And Decompress(XDiffPos((Recompress(WinLeft + PrintSeqLen - 5)))) > 0 Then
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                End If
            End If
            
        End If
        If P2 = P1 Then P2 = P1 + 1
        
        
        If HomologyIndicator = 2 Then
            
            Picture11.DrawMode = 12
            'Picture11.ForeColor = HalfColour 'QuaterColour
            Picture11.Refresh
            Picture11.Line (P1, 0)-(P2, Picture11.ScaleHeight - 1), QuaterColour, BF ' QBColor(7), BF
            x = x
        ElseIf HomologyIndicator = 1 Then
            
            
            Picture4.DrawMode = 6
            '
            
            
            Pict4 = Picture4.hdc
            Pict4SH = Picture4.ScaleHeight - 1
            '@
            'Picture4.ForeColor = QBColor(7)
            '~10% of the time is spent drawing this rectangle
             'Picture4.FillStyle = 1
             '@
             Picture4.Refresh
'            ReDim PolyPoints(5)
'            PolyPoints(0).x = P1: PolyPoints(0).y = 0
'            PolyPoints(1).x = P2: PolyPoints(1).y = 0
'            PolyPoints(2).x = P2: PolyPoints(2).y = Pict4SH
'            PolyPoints(3).x = P1: PolyPoints(3).y = Pict4SH
'            PolyPoints(4).x = P1: PolyPoints(4).y = 0
'            Polygon Picture4.hdc, PolyPoints(0), 4
             
            
             'Rectangle Pict4, P1, 0, P2, Picture4.ScaleHeight - 1
            
            MoveToEx Pict4, P1, 0, PAP
            LineTo Pict4, P2, 0
            '@
            LineTo Pict4, P2, Pict4SH
            LineTo Pict4, P1, Pict4SH
            LineTo Pict4, P1, 0
            
            
            'LineTo Picture4.hdc, x, Picture4.ScaleHeight - 1
            'Picture4.Line (P1, 0)-(P2, Picture4.ScaleHeight - 1), QBColor(7), B
            x = x
        End If
        PositionIndicaterOn = 1
        'If OnlyDoPositionIndicator = 1 And OnlyDoPosBar = 0 Then Exit Sub
    End If
    
    
    If OnlyDoPositionIndicator = 0 Then
        If OnlyDoPositionIndicator = 0 Then
            Rectangle Picture13.hdc, 0, 0, Picture13.ScaleWidth, Picture13.ScaleHeight
        End If

        'XX = Picture13.AutoRedraw
        If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
            Dim XX1 As Long, XX2 As Long, XX3 As Long, Y1 As Long, Y2 As Long
    '        XX = Picture13.Width
    '        XX = Picture13.ScaleWidth
            Dim ColbumpX As Long
            ReDim SEPosMap(-100 To Form1.Picture13.ScaleWidth * 4)
            If ORFFlag = 1 Then
                
                
                ReDim PolyPoints(5)
                For x = -2 To PrintSeqLen + 2
                    ColbumpX = ColBump(SeqFeatureTrace(WinLeft + x))
                    If WinLeft + x = 1797 Then
                        x = x
                    End If
                    If SeqFeatureMap(WinLeft + x) = 24 Then 'start of exon in - ori
                        XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                        XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                        XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                        For Y = XX1 To XX3
                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                        Next Y
                        
                        
                    
                        Y1 = 0
                        Y2 = LineBottom
                        PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                        PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                        PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                        PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                        PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                        PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                        
                        Form1.Picture13.FillStyle = 0
                        Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                        Form1.Picture13.ForeColor = RGB(255, 255, 128)
                        '@
                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        x = x
                    ElseIf SeqFeatureMap(WinLeft + x) = 1 Then
                        
                        
                        XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                        XX2 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                        XX3 = ((x + 3.5) * 8 + 6) * tTYF * XConA
                        For Y = XX1 To XX3
                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                        Next Y
                        
                        
                    
                        Y1 = 0
                        Y2 = LineBottom
                        PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                        PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                        PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                        PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                        PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                        PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                        
                        Form1.Picture13.FillStyle = 0
                        Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                        Form1.Picture13.ForeColor = RGB(128, 255, 128)
                        '@
                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                        x = x
                    ElseIf SeqFeatureMap(WinLeft + x) = 6 Then
                        
                        
                        XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                        XX2 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                        XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                        
                        For Y = XX1 To XX3
                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                        Next Y
                        
                        Y1 = 0
                        Y2 = LineBottom
                        PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                        PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                        PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                        PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                        PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                        PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                        
                        Form1.Picture13.FillStyle = 0
                        Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                        Form1.Picture13.ForeColor = RGB(255, 164, 164)
                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                    ElseIf SeqFeatureMap(WinLeft + x) = 9 Then
                        SEPosMap(x) = SeqFeatureTrace(WinLeft + x)
                        SEPosMap(x) = SeqFeatureTrace(WinLeft + x + 1)
                        SEPosMap(x) = SeqFeatureTrace(WinLeft + x + 2)
                        XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                        XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                        XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                        XX = LBound(SEPosMap, 1)
                        For Y = XX1 To XX3
                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                        Next Y
                        
                        Y1 = 0
                        Y2 = LineBottom
                        PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                        PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                        PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                        PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                        PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                        PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                        
                        Form1.Picture13.FillStyle = 0
                        Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                        Form1.Picture13.ForeColor = RGB(128, 255, 128)
                        
                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                    ElseIf SeqFeatureMap(WinLeft + x) = 10 Then
                        XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                        XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                        XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                        For Y = XX1 To XX3
                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                        Next Y
                        Y1 = 0
                        Y2 = LineBottom
                        PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                        PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                        PolyPoints(2).x = XX2: PolyPoints(2).Y = Y2 / 2
                        PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                        PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                        PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                        
                        Form1.Picture13.FillStyle = 0
                        Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                        Form1.Picture13.ForeColor = RGB(255, 164, 164)
                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                    
                    End If
                Next x
                Form1.Picture13.ForeColor = 0
            End If
            
            
            If DebuggingFlag < 2 Then On Error Resume Next
            
            UB = UBound(RememberBPs, 2)
            
            On Error GoTo 0
            If (RelX > 0 Or RelY > 0) And UB > 0 Then
                Dim BPPos As Long, WLPS As Long
                WLPS = WinLeft + PrintSeqLen
                
                For Z = NumberBPs To 0 Step -1 ' just makes sur that the "main event" is done last
                   ' If Z = 0 Then
                   ' X = X
                   ' End If
                    xBak = RememberBPs(1, Z) - CLng((AddNum - 2) / 2)
                    BPPos = RememberBPs(0, Z)
                    If BPPos > WinLeft And BPPos < WLPS Then
                        x = BPPos - WinLeft
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA - 5 + xBak, LineTop - 10)-((x * 8 + 6) * tTYF * XConA + xBak, LineBottom - 4), ProgcolourB(RememberBPs(1, Z))
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA + xBak, LineBottom - 4)-((x * 8 + 6) * tTYF * XConA + 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
                        Picture13.Line ((x * 8 + 6) * tTYF * XConA + 5 + xBak, LineTop - 10)-((x * 8 + 6) * tTYF * XConA - 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
                    End If
                Next Z
                p1TTYF = tTYF
            End If
            '@
           'Picture13.FillStyle = 1
            Picture13.ForeColor = 0
            Pict = Picture13.hdc
            Dim OS As String, TX As Single, LV As Single, DC As Long
            DC = Decompress(Len(StrainSeq(0)))
            TX = tTYF * XConA
            LV = (LineTop * VAddjust) - (16 * VAddjust)
            If x = x Then
                '@
                For x = 0 To PrintSeqLen
                    '@
                    YCon = WinLeft + x
                    If YCon <= DC Then
                        
                        X3 = (x * 8 + 6) * TX
                        
                        If (YCon) / TL = Int((YCon) / TL) Then
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                            '@
                            
                            Dummy = MoveToEx(Pict, X3, LineTop - 2, PAP)
                            Dummy = LineTo(Pict, X3, LineBottom)
                            '@
                            'Picture13.Refresh'
                            
                            C = (Picture13.TextWidth(Trim$(CStr(YCon)))) / 2
                            X3 = X3 - C
                            'Y1 = (LineTop * VAddjust) - (16 * VAddjust)
                            
                            OS = Trim$(CStr(YCon))
                            
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                            x = x
                        Else
                            '@
                            Dummy = MoveToEx(Pict, X3, LineTop, PAP)
                            
                            Dummy = LineTo(Pict, X3, LineBottom)
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                            x = x
                        End If
        
                    Else
                        Exit For
                    End If
        
                Next 'X
            End If
            
            'Print the BP positions
            
            x = x
    
        Else
    
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(MCXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 * XConA + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF * XConA - (Picture13.TextWidth(Trim$(CStr(Decompress(MCXDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(MCXDiffPos) Then Picture13.Print Decompress(MCXDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(GCXDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(GCXDiffPos) Then Picture13.Print Decompress(GCXDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                Else
                    For x = 0 To PrintSeqLen * 2
        
                        If WinLeft + x <= Len(GCXOverSeq(0)) Then
        
                            If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                                Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                                Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
        
                                If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                            Else
                                Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                            End If
        
                        Else
                            Exit For
                        End If
        
                    Next 'X
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(SSSubSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(CXoverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            Else
    
                For x = 0 To PrintSeqLen * 2
    
                    If WinLeft + x <= Len(XOverSeq(0)) Then
    
                        If (WinLeft + x) / TL = Int((WinLeft + x) / TL) Then
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop - 2)-((x * 8 + 6) * tTYF, LineBottom)
                            Picture13.CurrentX = (-3 + x * 8 + 7) * tTYF - (Picture13.TextWidth(Trim$(CStr(Decompress(XDiffPos(WinLeft + x)))))) / 2
                            Picture13.CurrentY = (LineTop * VAddjust) - (16 * VAddjust)
    
                            If WinLeft + x < UBound(XDiffPos) Then Picture13.Print Decompress(XDiffPos(WinLeft + x))
                        Else
                            Picture13.Line ((x * 8 + 6) * tTYF, LineTop)-((x * 8 + 6) * tTYF, LineBottom)
                        End If
    
                    Else
                        Exit For
                    End If
    
                Next 'X
    
            End If
    
        End If
    End If
'601580

    
    
    
    
    
    
    
    Picture1.Refresh
    '@
    Picture13.Refresh
    
    RLFlag = 0

    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
        Picture3.Enabled = True
    Else
        Picture3.Enabled = False
    End If
    
    
    
    
    
    
    If HorstFlag = 1 Then
    
        Call DrawHorstInterval(WinLeft, PrintSeqLen)
    End If
'EEE = Abs(GetTickCount)
'    ttt = EEE - SSS
'    x = x
'XX = Picture1.AutoRedraw
'Picture1.AutoRedraw = True
    Exit Sub
UnknownFormat:

    If RunFlag = 0 And ManFlag = -1 Then
        Picture1.BackColor = Form1.BackColor
        Picture3.BackColor = Form1.BackColor
        Picture4.BackColor = Form1.BackColor
        Picture11.BackColor = Form1.BackColor
        Picture13.BackColor = Form1.BackColor
    End If

    Response = MsgBox("I could not recognise this DNA alignment file format" + Chr$(13) + "Send it as an attatchment to darrenpatrickmartin@gmail.com", 32)
    ErrorFlag = 1
    RLFlag = 0
    Screen.MousePointer = 0
End Sub
Private Sub HScroll1_Change()
Dim PolyPoints() As POINTAPI, Response As Long, xBak As Long, UB3 As Long, UB2 As Long, GoOn As Long, SEN As Long, Z As Long, num As Long, UB As Long, MinParPos As Long, Overhang As Long, Mu As Long, Kx As Long, Kh As Long, NF As Long, oDir As String, oDirX As String, FF As Long
Dim X0 As String, X1 As String, X2 As String, X3 As Long, PAP As POINTAPI
Dim Pict4 As Long
Dim Pict4SH As Long
If LoadBusy = 1 Then Exit Sub
If NextNo = 0 Then Exit Sub
If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(Decompress, 1)
On Error GoTo 0
If UB = 0 Or UB = -1 Then Exit Sub

If PermNextno <= 0 Then Exit Sub
If HScroll1.Value < HScroll1.Min And PermNextno > 0 Then
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        If HScroll1.Max > 0 Then
            HScroll1.Value = HScroll1.Min + 1
            Exit Sub
        End If
    End If
End If

If DontRedoQuickDistFlag = 1 Then
    Exit Sub
End If
Form1.Timer3.Enabled = True
Form1.Timer3.Interval = 2000
'445628


If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If sHSCroll1Down = 0 Then
    sHSCroll1Down = Abs(GetTickCount)
    HSCrollInc = 1
End If
If CurrentlyRunningFlag = 1 Then
    Exit Sub
End If
'XX = Decompress(Len(StrainSeq(0)))
If NextNo <> PermNextno Then UnModNextno





Dim RecompX As Long
If F2ontop = 1 Then
    
    'ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - Form1.VScroll2.Value)
    Form1.Enabled = True
    DontPutForm2Ontop = 1
    DSP2Flag = 1
    Call Picture6_MouseMove(ProxButton, ProxShift, ProxX, ProxY)
    DSP2Flag = 0
    DontPutForm2Ontop = 0
    Form1.Enabled = False
    'F2ontop = 0
End If
'432616
If NextNo = 0 Then Exit Sub
ReDim Preserve PltCol3(15)
'If F1MDF = 1 Then Exit Sub
    'Call SaveAncSeq_Click
    If AncSeqFlag = 0 And LastAncSeqFlag = 1 Then
        VScroll3.Height = HScroll1.Top - VScroll3.Top - 4 * Screen.TwipsPerPixelX
        
        
        Picture8.Height = VScroll3.Height
        
        Picture9.Height = VScroll3.Height
        
        'Picture1.Height = Picture9.Height
        
        Picture22.Visible = False
    Else
        LastAncSeqFlag = 1
    End If
    
    SSS = Abs(GetTickCount)
    'this gets rid of the cursor on the sequence display
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -20
        ltPosX = -20
    End If
    'Command3.SetFocus
    Dim FS As Double, SLen As Long, Pict As Long, x As Long, Y As Long, LastY As Long, CountHits As Long
    Dim P1 As Integer, P2 As Integer, A As Integer, C As Integer, g As Integer, T As Integer, S As Integer
    Dim tTYF As Double, TYFM As Integer, Test As String
    'tTYF = 0.45
    If DontRefreshP1 = 1 Then
        
        Exit Sub
    End If
    '@
    If OnlyDoFlash = 0 Then
        ReDim Output(PermNextno + 2)
    End If
    'If the current selection is not an RDP derived result then don't print
    'reference sequences
    
    
    SLen = UBound(Decompress, 1)
    If TYF = 0 Then TYF = 1
    If P1FontSize <> 0 Then
        
        Picture1.FontSize = P1FontSize * TYF
    End If
    If PermNextno < PermNextno Then
        UnModNextno
    End If
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        ltPosY = -1
        ltPosX = -1
        '@
        ReDim SeqLines(5, PermNextno * 3), SeqText(PermNextno + 2): NumSeqLines = 0: NumSeqText = 0
    End If
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        
    '(13 * tTYF + 2) * Screen.TwipsPerPixelY
    '432616
    'tTYF = tTYF * 1.08
    PrintSeqLen = MakePrintSeqLen '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G"))
    'XX = Form1.Picture1.TextWidth("C") * WinLeft
    If RunFlag = 1 Then
        If AllowExtraSeqsFlag = 0 Then
            If XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then SpacerNo = 0
        End If
    End If

    If RLFlag = 1 Then
        On Error GoTo UnknownFormat
    End If

    'Picture1.Picture = LoadPicture() 'Clears picture
    Overhang = Int(PrintSeqLen - (SLen - (0.99 * SLen))) - 1
    'OverHang = 0

    Dim THold As Long

    'THold = HScroll1.Value
   ' XX = WinLeft
   oh1m = H1M
   If Len(StrainSeq(0)) > UBound(Decompress, 1) Then
   
        Exit Sub
   End If
    If Decompress(Len(StrainSeq(0))) - (PrintSeqLen - 5) > HScroll1.Max And DontDoH1Inc = 0 Then 'Len(StrainSeq(0)) - (PrintSeqLen - 5)
        If HScroll1.Value >= HScroll1.Min Then
            If HScroll1.Value = HScroll1.Min + 1 And LastH1Val = HScroll1.Min Then
                H1M = -HScroll1Mod + 1
                 LastH1Dir = 1 'right movement
            ElseIf HScroll1.Value = HScroll1.Max And LastH1Val = HScroll1.Max - 1 Then
                H1M = H1M + 1
            ElseIf HScroll1.Value = HScroll1.Max - 1 And LastH1Val = HScroll1.Max Then
                H1M = H1M - 1
                
                 LastH1Dir = 2 'left
            Else
                If LastH1Val < HScroll1.Value Then
                    'right arrow
                    H1M = H1M + HSCrollInc
                    LastH1Dir = 1 'right movement
                ElseIf LastH1Val > HScroll1.Value Then
                    'left arrow
                    H1M = H1M - HSCrollInc
                    LastH1Dir = 2 'left movement
                End If
            End If
            If H1M >= HScroll1Mod Then
                If HScroll1.Value = HScroll1.Max Then
                    H1M = HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Max - 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            ElseIf H1M <= -HScroll1Mod Then
                
                If HScroll1.Value < HScroll1.Min Then
                    H1M = -HScroll1Mod
                    H1C = 1 'this stops the hscroll updating
                    HScroll1.Value = HScroll1.Min + 1
                    LastH1Val = HScroll1.Value
                    H1C = 0
                Else
                    H1M = 0
                End If
            Else
                H1C = 1 'this stops the hscroll updating
                
                
                If HScroll1.Value > HScroll1.Min And LastH1Dir = 1 And LastH1Val > HScroll1.Min Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 1 Then
                    HScroll1.Value = HScroll1.Value + 1
                ElseIf HScroll1.Value = HScroll1.Max And LastH1Dir = 2 Then
                    HScroll1.Value = HScroll1.Value - 1
                ElseIf HScroll1.Value < HScroll1.Max - 1 And LastH1Dir = 2 Then
                'X = X
                    HScroll1.Value = HScroll1.Value + 1
                    'HScroll1.Value = HScroll1.Value - 1
                End If
                
                LastH1Val = HScroll1.Value
                H1C = 0
            End If
        Else
            
            LastH1Val = 0
        End If
    Else
        If Decompress(Len(StrainSeq(0))) - (PrintSeqLen - 5) > HScroll1.Max Then
            If HScroll1.Value = 1 Then
                H1M = -HScroll1Mod + 1
            End If
        Else
            H1M = 0
        End If
    End If
    
    If HScroll1.Value = HScroll1.Min Then
        LastH1Val = HScroll1.Min
        If Decompress(Len(StrainSeq(0))) > HScroll1.Max Then
            'If HScroll1.Value = 1 Then
                H1M = -HScroll1Mod + 1
            'End If
        End If
    End If
    If HScroll1.Value = HScroll1.Max Then
        LastH1Val = HScroll1.Max
        
    End If
    THold = HScroll1.Value
    'XX = HScroll1.Value
    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
        WinLeft = THold * HScroll1Mod + H1M
    Else

        If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
            WinLeft = (THold * (Len(MCXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            WinLeft = (THold * (Len(GCXOverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            WinLeft = (THold * (Len(SSSubSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
            WinLeft = (THold * (Len(CXoverSeq(0)) / SLen)) * HScroll1Mod
        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
            WinLeft = (THold * (Len(PPXOSeq(0)) / SLen)) * HScroll1Mod
        Else
            WinLeft = (THold * (Len(XOverSeq(0)) / SLen)) * HScroll1Mod
        End If

    End If
'432620
    If PermNextno < 0 Then PermNextno = 0

    If WinLeft < 1 Then
        WinLeft = 1
    End If
    Picture1.ScaleMode = 3
    Picture1.CurrentX = 0
    Picture1.CurrentY = 0
    'Set up text output
    
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If AncSeqFlag = 1 Then
            Dim TestString As String, PrintString As String, ColWid As Double, ColCol As Long, MaxY As Long, MinY As Long, StartX, EndY, StartY
            
            Form1.Picture22.AutoRedraw = True
            Form1.Picture22.BackColor = Form1.Picture1.BackColor
            Form1.Picture22.Font = Form1.Picture1.Font
            Form1.Picture22.FontSize = Form1.Picture1.FontSize
            Form1.Picture22.CurrentX = 0
            Form1.Picture22.CurrentY = 0
            
            
            'draw bars
            TestString = String(PrintSeqLen, "A")
            ColWid = Picture22.TextWidth(TestString)
            ColWid = ColWid / PrintSeqLen
            Dim TH As Single, Ya As Single
            TH = Picture22.TextHeight("A") '- 1
            Ya = tTYF * Screen.TwipsPerPixelY
            'draw the sequence blocks
            For Y = 0 To 26 Step 13
                If Y = 0 Then
                    PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
                ElseIf Y = 13 Then
                    PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
                Else
                    PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
                End If
                
                
                For x = 1 To PrintSeqLen
                    'For Y = 0 To nruns
                    If x + WinLeft <= Len(StrainSeq(0)) Then
                        If x + WinLeft < UBound(AncPVals, 2) Then
                            StartX = (x - 1) * ColWid
                            If Mid$(PrintString, x, 1) = "A" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 128, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "C" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 255, 128), BF
                            ElseIf Mid$(PrintString, x, 1) = "G" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(128, 128, 255), BF
                            ElseIf Mid$(PrintString, x, 1) = "T" Then
                                Form1.Picture22.Line (StartX + 10, Y * Ya)-(StartX + ColWid, Y * Ya + TH), RGB(255, 255, 128), BF
                            End If
                        End If
                        'Next Y
                        
                        
                    End If
                Next x
                
                Form1.Picture22.CurrentX = 0
                Form1.Picture22.CurrentY = Y * tTYF * Screen.TwipsPerPixelY
                Form1.Picture22.Print PrintString
            Next Y
            
    '        'Write the sequences
    '        PrintString = Mid$(ParsAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '        PrintString = Mid$(MLAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.CurrentY = 13 * tTYF * Screen.TwipsPerPixelY
    '        Form1.Picture22.Print PrintString
    '        Form1.Picture22.CurrentY = 26 * tTYF * Screen.TwipsPerPixelY
    '        PrintString = Mid$(SumAncSeq, WinLeft, PrintSeqLen)
    '        Form1.Picture22.Print PrintString
    '
    '
            
            
            
            'ColWid = ColWid / (nruns + 1)
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            For x = 0 To PrintSeqLen
                'For Y = 0 To nruns
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    If x + WinLeft < UBound(AncPVals, 2) Then
                        StartX = x * ColWid '+ Y * ColWid
                        EndY = AncPVals(0, x + WinLeft) * MaxY
                        If AncPVals(0, x + WinLeft) > 0.95 Then
                            Form1.Picture22.ForeColor = RGB(0, 0, 255)
                        ElseIf AncPVals(0, x + WinLeft) > 0.75 Then
                            Form1.Picture22.ForeColor = RGB(0, 255, 0)
                        Else
                            Form1.Picture22.ForeColor = RGB(255, 0, 0)
                        End If
                    End If
                    'Next Y
                    Form1.Picture22.Line (StartX + 10, MinY)-(StartX + ColWid, StartY + EndY), , BF
                    
                End If
            Next x
            MinY = MinY + MaxY + 50
            MaxY = Picture22.Height - MinY - 100 'MinY + ((Picture22.Height) - MinY) / 2
            'MaxY = MaxY / 2
            For x = 0 To PrintSeqLen
                If x + WinLeft <= Len(StrainSeq(0)) Then
                    StartX = x * ColWid
                    EndY = 0
                    StartY = MinY
                    For Y = 1 To 4
                            'XX = AncPValsBayes(4, 5)
                            If x + WinLeft < UBound(AncPVals, 2) Then
                                EndY = (AncPVals(Y, x + WinLeft) * (MaxY))
                                If Y = 1 Then
                                    Form1.Picture22.ForeColor = RGB(255, 128, 128)
                                ElseIf Y = 2 Then
                                    Form1.Picture22.ForeColor = RGB(128, 255, 128)
                                ElseIf Y = 3 Then
                                    Form1.Picture22.ForeColor = RGB(128, 128, 255)
                                ElseIf Y = 4 Then
                                    Form1.Picture22.ForeColor = RGB(255, 255, 128)
                                End If
                            End If
                            'Next Y
                            If EndY >= 0 Then
                                Form1.Picture22.Line (StartX + 10, StartY)-(StartX + ColWid, StartY + EndY), , BF
                            Else
                                EndY = 0
                            End If
                            StartY = StartY + EndY
                    Next Y
                End If
            Next x
            
            Form1.Picture22.ForeColor = Form1.Picture1.BackColor
            Form1.Picture22.Line (Picture9.Width - 10, 0)-(Picture22.Width, Picture22.Height), , BF
            Form1.Picture22.ForeColor = 0
            
            
            'Draw Axes and Key
            MinY = Picture22.TextHeight(PrintString) * 3 + 40
            MaxY = (Picture22.Height - 100 - MinY) / 2
            StartY = MinY
            'Axes
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 10, StartY + MaxY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY)-(Picture9.Width + 60, MinY)
            Form1.Picture22.Line (Picture9.Width + 10, MinY + (StartY + MaxY - MinY) / 2)-(Picture9.Width + 60, MinY + (StartY + MaxY - MinY) / 2)
            Form1.Picture22.Line (Picture9.Width + 10, StartY + MaxY)-(Picture9.Width + 60, StartY + MaxY)
            
            Form1.Picture22.Font = Picture3.Font
            Form1.Picture22.FontSize = Form1.Picture3.FontSize
            'Draw sequence labels
            
            'P3.CurrentY = -VSV + (X + 1) * 13 * tTYF
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = 2 * Screen.TwipsPerPixelY
            
            Form1.Picture22.Print "Max. parsimony"
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.CurrentY = (13 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.Print "Max. likelihood"
            Form1.Picture22.CurrentY = (26 * tTYF + 2) * Screen.TwipsPerPixelY
            Form1.Picture22.CurrentX = Picture9.Width + 80
            Form1.Picture22.Print "Bayesian"
            
            
            
            
            
            If Picture22.FontSize < 6 Then Picture22.FontSize = 6
            If Picture22.FontSize > 10 Then Picture22.FontSize = 10
            
            
            
            'Do Tick labels
            Mu = Picture22.TextHeight("O") / 2
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu: Form1.Picture22.Print "0.0"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = MinY - Mu + (StartY + MaxY - MinY) / 2: Form1.Picture22.Print "0.5"
            Form1.Picture22.CurrentX = Picture9.Width + 80: Form1.Picture22.CurrentY = StartY + MaxY - Mu: Form1.Picture22.Print "1.0"
            
            'Draw keys
            Kx = Picture9.Width + 80 + Form1.Picture22.TextWidth("0.0") + 280
            Kh = Form1.Picture22.TextHeight("0.0")
            
            'Form1.Picture22.Print (kx, MinY + (MaxY - MinY) / 2 - mu)-(kx + kh, MinY + (MaxY - MinY) / 2 - mu + kh), RGB(0, 255, 0), BF
            Form1.Picture22.FontSize = Form1.Picture22.FontSize - 1
            Form1.Picture22.CurrentX = Kx
            Form1.Picture22.CurrentY = MinY + ((StartY + MaxY - MinY) - Picture22.TextWidth("Prob.")) / 2 - Mu * 0.5
            
            
            Call DoText(Form1.Picture22, Form1.Picture22.Font, "Prob.", 270)
            
            Kx = Picture9.Width + 80
            Kh = Form1.Picture22.TextHeight("0.0") / 1.5
            MaxY = MaxY + 100
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu)-(Kx + Kh, StartY + MaxY + Mu + Kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx, StartY + MaxY + mu * 2 + kh)-(kx + kh, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu)-(kx + kh + 500, StartY + MaxY + mu + kh), RGB(255, 128, 128), BF
            'Form1.Picture22.Line (kx + 500, StartY + MaxY + mu * 2 + kh)-(kx + kh + 500, StartY + MaxY + mu * 2 + kh * 2), RGB(128, 255, 128), BF
            
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "A"
            
            Form1.Picture22.Line (Kx, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh, StartY + MaxY + Mu * 2 + Kh * 2), RGB(128, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "C"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu)-(Kx + Kh + 500, StartY + MaxY + Mu + Kh), RGB(128, 128, 255), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu - 20
            Form1.Picture22.Print "G"
            
            Form1.Picture22.Line (Kx + 500, StartY + MaxY + Mu * 2 + Kh)-(Kx + Kh + 500, StartY + MaxY + Mu * 2 + Kh * 2), RGB(255, 255, 128), BF
            Form1.Picture22.CurrentX = Kx + Kh + 50 + 500
            Form1.Picture22.CurrentY = StartY + MaxY + Mu * 2 + Kh - 20
            Form1.Picture22.Print "T"
            
            
            Form1.Picture22.Refresh
            Form1.Picture22.Visible = True
        End If
    End If
    
 '432596
 
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 And (OnlyDoFlash = 0 Or Len(Output(0)) = 0) Then
        If ShowSeqFlag = 0 Then
            
            If (WinLeft + PrintSeqLen) > UBound(Decompress, 1) Then ReDim Preserve Decompress(WinLeft + PrintSeqLen)
            If Decompress(WinLeft) = WinLeft And (Decompress(WinLeft + PrintSeqLen) = WinLeft + PrintSeqLen Or Decompress(WinLeft + PrintSeqLen) = 0) Then
                For x = 0 To PermNextno
                    '@
                    If x <= UBound(StrainSeq, 1) Then
                        Output(x) = Mid$(StrainSeq(x), WinLeft, PrintSeqLen)
                    End If
                Next
            Else
                ' reads the full sequence from file
                    NF = FreeFile
                    Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                    
                    ReadLen = PrintSeqLen * (NextNo + 1)
                    ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                    FileSeqString = String(ReadLen, " ")
                     oDir = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "RDP5Longseq" + UFTag For Binary As #NF
                        Get #NF, ReadStart, FileSeqString
                    Close #NF
                    ' Close #1
                    ' Close #2
                    ChDrive oDir
                    '@
                    ChDir oDir
                    'reconfigure and add to output
                    For x = 0 To PermNextno
                        Output(x) = String(PrintSeqLen + 1, " ")
                    Next x
                    PosInString = 0
                    For Y = 1 To PrintSeqLen
                        For x = 0 To PermNextno
                            '@
                            PosInString = PosInString + 1
                            '@'@
                            Mid$(Output(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                        Next x
                    Next Y
                   
    '                XX = 0
                
            End If
    
        Else
            ReDim SDisplaySeq(PermNextno)
            For x = 0 To PermNextno
                SDisplaySeq(x) = -1
            Next x
            If ShowSeqFlag = 1 Then
                'Take the known SpacerSeqs and transfer these to SpacerSeqs
                
                If (WinLeft + Y - 1) < Decompress(Len(StrainSeq(0))) Then
                    RecompX = Recompress(WinLeft - 1 + Y)
                    If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                 
                        If pGCTripletflag = 0 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) Then
'                            If pGCTripletflag = 0 Then
'                                If Seq1 <> Seq2 Then
'                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
'                                    Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq2
'                                    UB = UBound(SpacerSeqs, 1)
'                                    For X = 1 To SpacerNo
'                                        If X <= UB Then
'                                            Output(X + 1) = Mid$(StrainSeq(SpacerSeqs(X)), WinLeft, PrintSeqLen): SDisplaySeq(X + 1) = SpacerSeqs(X)
'                                        End If
'                                    Next 'X
'
'                                Else
'                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
'                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
'                                    UB = UBound(SpacerSeqs, 1)
'                                    For X = 1 To SpacerNo
'                                        If X <= UB Then
'                                            Output(X) = Mid$(StrainSeq(SpacerSeqs(X)), WinLeft, PrintSeqLen): SDisplaySeq(X) = SpacerSeqs(X)
'                                        End If
'                                    Next 'X
'
'                                End If
'                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                                Else
                                    Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen): SDisplaySeq(0) = TreeTrace(Seq1)
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen): SDisplaySeq(1) = TreeTrace(Seq3)
                                Else
                                    Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                                    MinParPos = 2
                                Else
                                    Output(2) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen): SDisplaySeq(2) = TreeTrace(Seq2)
                                    MinParPos = 2
                                End If
                                If SpacerNo + 2 > UBound(Output, 1) Then
                                    ReDim Preserve Output(SpacerNo + 2)
                                End If
                                If SpacerNo > 0 Then
    '                                If DebuggingFlag < 2 Then On Error Resume Next
    '                                UB = -1
    '                                UB = UBound(XOverSeq, 1)
    '                                On Error GoTo 0
                                    If AllowExtraSeqsFlag = 1 And ShowSeqFlag = 1 Then
                                        UB = UBound(SpacerSeqs, 1)
                                        For x = 1 To SpacerNo
                                            If x <= UB Then
                                                Output(x + 2) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen): SDisplaySeq(x + 2) = SpacerSeqs(x)
                                            'Else
                                            '    Exit For
                                            End If
                                        Next 'X
                                    End If
                                End If
                                
'                            End If
    '                        XX = Output(3)
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                                Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                                Output(2) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = Mid$(StrainSeq(RevSeq(x)), WinLeft, PrintSeqLen): SDisplaySeq(num) = RevSeq(x)
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = Mid$(StrainSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                            Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq2
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen): SDisplaySeq(x + 1) = SpacerSeqs(x)
                                End If
                            Next 'X
            
                        Else 'If XOverlist(RelX, RelY).ProgramFlag <> 1 And XOverlist(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = Mid$(StrainSeq(TreeTrace(Seq1)), WinLeft, PrintSeqLen): SDisplaySeq(0) = TreeTrace(Seq1)
                            If UBound(TreeTrace) >= Seq3 Then
                                If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                    Output(1) = Mid$(StrainSeq(TreeTrace(Seq3)), WinLeft, PrintSeqLen): SDisplaySeq(1) = TreeTrace(Seq3)
                                End If
                            Else
                                If Seq3 <= UBound(StrainSeq, 1) Then
                                    Output(1) = Mid$(StrainSeq(Seq3), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                                End If
                            End If
                            Z = 1
                            SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                            For x = 0 To PermNextno
                                If x <> Seq3 Then
                                    If UBound(Daught, 2) >= TreeTrace(x) Then
                                        If Daught(SEN, TreeTrace(x)) > 0 Then
                                            Z = Z + 1
                                            Output(Z) = Mid$(StrainSeq(TreeTrace(x)), WinLeft, PrintSeqLen): SDisplaySeq(Z) = TreeTrace(x)
                                            
                                        End If
                                    End If
                                End If
                            Next x
                            Z = Z + 1
                            Output(Z) = Mid$(StrainSeq(TreeTrace(Seq2)), WinLeft, PrintSeqLen): SDisplaySeq(Z) = TreeTrace(Seq2)
                            MinParPos = Z
                            If SpacerNo > 0 And (XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Or AllowExtraSeqsFlag = 1) Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    
                                    If x <= UB Then
                                        If SpacerSeqs(x) <= UBound(StrainSeq, 1) Then
                                            Output(x + Z) = Mid$(StrainSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen): SDisplaySeq(x + Z) = SpacerSeqs(x)
                                        Else
                                            If TreeTrace(SpacerSeqs(x)) <= UBound(StrainSeq, 1) Then
                                                Output(x + Z) = Mid$(StrainSeq(TreeTrace(SpacerSeqs(x))), WinLeft, PrintSeqLen): SDisplaySeq(x + Z) = TreeTrace(SpacerSeqs(x))
                                            Else
                                                Output(x + Z) = "": SDisplaySeq(x + Z) = -1
                                            End If
                                        End If
                                    Else
                                    
                                    End If
                                Next 'X
'                            ElseIf XOverlist(RelX, RelY).ProgramFlag <> 5 And XOverlist(RelX, RelY).ProgramFlag <> 5 + AddNum Then
'                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
'            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
'                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                Output(Z + 1) = Mid$(SSOLSeq, WinLeft, PrintSeqLen): SDisplaySeq(Z + 1) = -1
                            End If
                        End If
                    Else
                        NF = FreeFile
                        'Dim FileSeqString As String, ReadStart As Long, ReadLen As Long, PosInString
                        
                        ReadLen = PrintSeqLen * (NextNo + 1)
                        ReadStart = WinLeft * (NextNo + 1) - (NextNo + 1) + 1
                        FileSeqString = String(ReadLen, " ")
                         oDir = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        Open "RDP5Longseq" + UFTag For Binary As #NF
                            Get #NF, ReadStart, FileSeqString
                        Close #NF
                        Dim TempOutput() As String
                        ReDim TempOutput(PermNextno)
                        ChDrive oDir
                        ChDir oDir
                        'reconfigure and add to output
                        
                        
                        
                        For x = 0 To PermNextno
                            TempOutput(x) = String(PrintSeqLen + 1, " ")
                        Next x
                        'XX = Len(TempOutput(0))
                        PosInString = 0
                        For Y = 1 To PrintSeqLen
                            For x = 0 To PermNextno
                                PosInString = PosInString + 1
                                Mid$(TempOutput(x), Y, 1) = Mid$(FileSeqString, PosInString, 1)
                            Next x
                        Next Y
                        
                        If XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
'                            If pGCTripletflag = 0 Then
'                                If Seq1 <> Seq2 Then
'                                    Output(0) = TempOutput(Seq1): SDisplaySeq(0) = Seq1
'                                    Output(1) = TempOutput(Seq2): SDisplaySeq(1) = Seq2
'                                    MinParPos = 1
'                                    UB = UBound(SpacerSeqs, 1)
'                                    For X = 1 To SpacerNo
'                                        If X <= UB Then
'                                            Output(X + 1) = TempOutput(SpacerSeqs(X)): SDisplaySeq(0) = Seq1
'                                        End If
'                                    Next 'X
'
'                                Else
'                                    Output(0) = TempOutput(Seq1)
'                                    'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
'                                    UB = UBound(SpacerSeqs, 1)
'                                    For X = 1 To SpacerNo
'                                        If X <= UB Then
'                                            Output(X) = TempOutput(SpacerSeqs(X))
'                                        End If
'                                    Next 'X
'
'                                End If
'                            Else
                                'XX = originalname(TreeTrace(Seq3))
                                If Seq1 < UBound(StrainSeq, 1) Then
                                    Output(0) = TempOutput(Seq1): SDisplaySeq(0) = Seq1
                                Else
                                    Output(0) = TempOutput(TreeTrace(Seq1)): SDisplaySeq(0) = TreeTrace(Seq1)
                                End If
                                If Seq3 >= UBound(StrainSeq, 1) Then
                                    Output(1) = TempOutput(TreeTrace(Seq3)): SDisplaySeq(1) = TreeTrace(Seq3)
                                Else
                                    Output(1) = TempOutput(Seq3): SDisplaySeq(1) = Seq3
                                End If
                                If Seq2 < UBound(StrainSeq, 1) Then
                                    Output(2) = TempOutput(Seq2): SDisplaySeq(2) = Seq2
                                    MinParPos = 2
                                Else
                                    Output(2) = TempOutput(TreeTrace(Seq2)): SDisplaySeq(2) = TreeTrace(Seq2)
                                    MinParPos = 2
                                End If
'                            End If
                        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                            If WinLeft < 1 Then WinLeft = 1
                
                            
                                Output(0) = TempOutput(Seq1): SDisplaySeq(0) = Seq1
                                Output(1) = TempOutput(Seq3): SDisplaySeq(1) = Seq3
                                Output(2) = TempOutput(Seq2): SDisplaySeq(2) = Seq2
                                MinParPos = 2
                                num = 3
                                For x = 0 To NumberOfSeqs
                                    If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                        Output(num) = TempOutput(RevSeq(x)): SDisplaySeq(num) = RevSeq(x)
                                        num = num + 1
                                    End If
                                Next 'X
                        ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                            Output(0) = TempOutput(Seq1): SDisplaySeq(0) = Seq1
                            Output(1) = TempOutput(Seq2): SDisplaySeq(1) = Seq2
                            MinParPos = 1
                            UB = UBound(SpacerSeqs, 1)
                            For x = 1 To SpacerNo
                                If x <= UB Then
                                    Output(x + 1) = TempOutput(SpacerSeqs(x)): SDisplaySeq(x + 1) = SpacerSeqs(x)
                                End If
                            Next 'X
                            
                        ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                            Output(0) = TempOutput(TreeTrace(Seq1)): SDisplaySeq(0) = Seq1
                            'XX = Len(Output(0))
                            If TreeTrace(Seq3) <= UBound(StrainSeq, 1) Then
                                Output(1) = TempOutput(TreeTrace(Seq3)): SDisplaySeq(1) = TreeTrace(Seq3)
                            End If
                            Output(2) = TempOutput(TreeTrace(Seq2)): SDisplaySeq(2) = TreeTrace(Seq2)
                            MinParPos = 2
                            If SpacerNo > 0 And XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
                                UB = UBound(SpacerSeqs, 1)
                                For x = 1 To SpacerNo
                                    If x <= UB Then
                                        Output(x + 2) = TempOutput(SpacerSeqs(x)): SDisplaySeq(x + 2) = SpacerSeqs(x)
                                    End If
                                Next 'X
'                            ElseIf XOverlist(RelX, RelY).ProgramFlag <> 5 And XOverlist(RelX, RelY).ProgramFlag <> 5 + AddNum Then
'                                If LongWindedFlag = 0 And (RelX > 0 Or RelY > 0) And ShowSeqFlag = 1 Then
'            'XXXZZZ                          Output(3) = Mid$(AncSeqS(BranchMap(XOverlist(RelX, RelY).TreePos(0), 0) - Nextno), WinLeft, PrintSeqLen)
'                                End If
                            End If
                            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                'XX = Len(SSOLSeq)
                                'XX = XOverlist(RelX, RelY).DHolder
                                Output(3) = TempOutput(XoverList(RelX, RelY).DHolder): SDisplaySeq(3) = XoverList(RelX, RelY).DHolder 'Mid$(SSOLSeq, WinLeft, PrintSeqLen)
                            End If
                        End If
                        
                        
                    End If
                End If
    
            Else
    
                If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                    If WinLeft < 1 Then WinLeft = 1
                    Output(0) = Mid$(MCXoverSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                    'Exit Sub
                    Output(1) = Mid$(MCXoverSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq2
                    MinParPos = 1
                    If SpacerNo > 0 Then
                        UB = UBound(SpacerSeqs, 1)
                        For x = 1 To SpacerNo
                            If x <= UB Then
                                Output(x + 1) = Mid$(MCXoverSeq(SpacerSeqs(x)), WinLeft, PrintSeqLen): SDisplaySeq(x + 1) = SpacerSeqs(x)
                            End If
                        Next 'X
                    
                    End If
    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
'                    If pGCTripletflag = 0 Then
'
'
'                        If Seq1 <> Seq2 Then
'                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
'                            Output(1) = Mid$(GCXOverSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq2
'                            MinParPos = 1
'                            UB = UBound(SpacerSeqs, 1)
'                            For X = 1 To SpacerNo
'                                If X <= UB Then
'                                    Output(X + 1) = Mid$(GCXOverSeq(SpacerSeqs(X)), WinLeft, PrintSeqLen): SDisplaySeq(X + 1) = SpacerSeqs(X)
'                                End If
'                            Next 'X
'
'                        Else
'                            Output(0) = Mid$(GCXOverSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
'                            'Output(1) = Mid$(StrainSeq(Seq2), WinLeft, PrintSeqLen)
'                            UB = UBound(SpacerSeqs, 1)
'                            For X = 1 To SpacerNo
'                                If X <= UB Then
'                                    Output(X) = Mid$(GCXOverSeq(SpacerSeqs(X)), WinLeft, PrintSeqLen): SDisplaySeq(X) = SpacerSeqs(X)
'                                End If
'                            Next 'X
'
'                        End If
'                    Else
                        Output(0) = Mid$(GCXOverSeq(0), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                        Output(1) = Mid$(GCXOverSeq(2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                        Output(2) = Mid$(GCXOverSeq(1), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                        MinParPos = 2
'                    End If
                ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                    If WinLeft < 1 Then WinLeft = 1
        
                    
                        Output(0) = Mid$(PPXOSeq(Seq1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                        Output(1) = Mid$(PPXOSeq(Seq3), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                        Output(2) = Mid$(PPXOSeq(Seq2), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                        MinParPos = 2
                        num = 3
                        For x = 0 To NumberOfSeqs
                            If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
                                Output(num) = Mid$(PPXOSeq(RevSeq(x)), WinLeft, PrintSeqLen): SDisplaySeq(num) = RevSeq(x)
                                num = num + 1
                            End If
                        Next 'X
                    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                    Output(0) = Mid$(SSSubSeq(1), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                    Output(1) = Mid$(SSSubSeq(2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                    Output(2) = Mid$(SSSubSeq(0), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                    MinParPos = 2
                    Output(3) = Mid$(SSSubSeq(3), WinLeft, PrintSeqLen): SDisplaySeq(3) = -1
                ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                    Output(0) = Mid$(CXoverSeq(0), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                    Output(1) = Mid$(CXoverSeq(2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                    Output(2) = Mid$(CXoverSeq(1), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                    MinParPos = 2
                Else
                    Output(0) = Mid$(XOverSeq(0), WinLeft, PrintSeqLen): SDisplaySeq(0) = Seq1
                    Output(1) = Mid$(XOverSeq(2), WinLeft, PrintSeqLen): SDisplaySeq(1) = Seq3
                    Output(2) = Mid$(XOverSeq(1), WinLeft, PrintSeqLen): SDisplaySeq(2) = Seq2
                    MinParPos = 2
                    If SpacerNo + 2 > UBound(Output, 1) Then
                        ReDim Preserve Output(SpacerNo + 2)
                    End If
                    If SpacerNo > 0 Then
                        If DebuggingFlag < 2 Then On Error Resume Next
                        UB = -1
                        UB = UBound(XOverSeq, 1)
                        On Error GoTo 0
                        If UB > 2 Then
                            For x = 1 To SpacerNo
                                If x + 2 <= UB Then
                                    Output(x + 2) = Mid$(XOverSeq(x + 2), WinLeft, PrintSeqLen): SDisplaySeq(x + 2) = -1
                                Else
                                    Exit For
                                End If
                            Next 'X
                        End If
                    End If
    
                End If
    
            End If
    
        End If
    End If
    '437080
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
    Dim YCon As Long
    
    'XX = Form1.Picture1.TextWidth(Output(0))
    If Form1.Picture1.FontSize = P1FontSize Then 'some systems have fonts with different basic sizes
        'XConA = Form1.Picture1.TextWidth("A")
        
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
    Else
       ' XConA = Form1.Picture1.TextWidth("A")
        YConA = Form1.Picture1.TextHeight("A")
        'XConA = XConA / 8
        YConA = (YConA / 16)
        'XConA = 1
'        XX = Form1.Picture1.TextHeight("A") / Form1.Picture1.TextWidth("A")
        YConA = 1.1
    End If
    
    'Picture1.Width
    PrintSeqLen = MakePrintSeqLen '* YConA '(3 + Form1.Picture1.ScaleWidth / Form1.Picture1.TextWidth("G")) * YConA
    
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        
        TopPosY = (Form1.VScroll3.Value / ScrollSF) / tTYF
        BottomPosY = (Form1.Picture9.ScaleHeight + 20 + (Form1.VScroll3.Value / ScrollSF)) / tTYF
        
        Dim XS As Long, XE As Long
        
        If FlashntNum > 0 Or ShowSeqFlag <> 0 Or (Abs(LastLeftPos - WinLeft) >= PrintSeqLen Or ((PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) And (LastTop <> TopPosY Or LastBottom <> BottomPosY))) Then
            XS = 1
            XE = Len(Output(1))
        
        ElseIf (PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) Then ' just do left right thing
            If WinLeft > LastLeftPos Then
                XS = PrintSeqLen - (WinLeft - LastLeftPos)
                XE = Len(Output(1))
            ElseIf WinLeft < LastLeftPos Then
                XS = 1
                XE = LastLeftPos - WinLeft
            Else
                XS = 1
                XE = Len(Output(1))
            End If
            If XS > XE Then XS = XE
        ElseIf (LastTop <> TopPosY Or LastBottom <> BottomPosY) Then ' just do up down thing
            XS = 1
            XE = Len(Output(1))
        Else
            XS = 1
            XE = Len(Output(1))
        End If
        
        
        SubPrintlen = XE - XS
        If ShowSeqFlag = 0 Then 'If the current selection is "show all sequences"
    '        SS = Abs(GetTickCount)
                'XX = Picture1.ScaleWidth
                
                If ColDistInFile = 1 Then
                    If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
                        'redim SubValid(0,0)
                        ReDim SubDiffs(0, 0)
                        'redim sMat(0,0)
                        ReDim FubValid(0, 0)
                        'Erase FMat
                    End If
                    Timer7(1).Enabled = False
                    If DebuggingFlag < 2 Then On Error Resume Next
                    
                    UB = UBound(ColDist2, 1)
                    On Error GoTo 0
                    '@
                    If UB = 0 Then
                        ReDim ColDist2(UBCD2)
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                        Open "RDP5CDFile" + UFTag For Binary As #FF
                        Get #FF, , ColDist2
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    End If
                    
                End If
                '591168
                Picture1.FillStyle = 0
                
                ''For zzz = 1 To 10
                Dim NSL As Long, DRSN1 As Long, UBSL2 As Long, UBI As Long, UBR As Long, StoreNum1 As Long, RSN1 As Long, Offset1 As Long, Offset2 As Long, Offset3 As Long, Offset4 As Long, Col1 As Long, Col2 As Long, Col3 As Long, Col4 As Long, Col5 As Long
                
    '            SS = Abs(GetTickCount)
                
'                Col1 = RGB(128, 128, 255)
'                Col2 = RGB(255, 128, 128)
'                Col3 = RGB(255, 0, 0)
'                Col4 = RGB(128, 0, 0)
'                Col5 = RGB(64, 64, 255)
                
                'ReDim ColX(255)
                'ColX (1)
                UBI = 0
                On Error Resume Next
                UBI = UBound(Identical)
                On Error GoTo 0
                If UBI = 0 Then
                    ReDim Preserve Identical(Len(StrainSeq(0)) + 100)
                    Exit Sub
                End If
                
                UBR = UBound(Recompress)
                UBSL2 = UBound(SeqLines, 2)
                
                
                
                
                For Y = XS To XE
                    StoreNum1 = WinLeft + Y - 1
    '                If StoreNum1 >= 870 Then
    '                    X = X
    '                End If
                    If StoreNum1 <= UBR Then
                        RSN1 = Recompress(StoreNum1)
                        
                        If UBI >= RSN1 Then
                            '@
                            YCon = StoreNum1 - WinLeft + 1
                            Offset1 = YCon * 8
                            Offset2 = YConA * 13
                            Offset3 = (PermNextno) * 13 + Offset2
                            Offset4 = Offset1 - 8
                            If StoreNum1 <= Decompress(Len(StrainSeq(0))) Then
                                If StoreNum1 - WinLeft > PrintSeqLen Then Exit For
                                RecompX = RSN1
                                
                                If UBI >= RSN1 Then
                                    '@
                                    If StoreNum1 = Decompress(RSN1) Then
                                        If UBSL2 < NumSeqLines + PermNextno Then
                                            UBSL2 = NumSeqLines + PermNextno * 3
                                            ReDim Preserve SeqLines(5, UBSL2)
                                        End If
                                        
                                        If Identical(RSN1) = 0 Then
                                            '@
                                            If x = 1234567 Then
                                                NSL = NumSeqLines
                                                NumSeqLines = FillSeqLines2(NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqLines, 1), ColDist2(0), SeqLines(0, 0), SeqColRef2(0), ColPos2(0))
                                            Else
                                                Dim StartP As Long, EndP As Long, SeqCol As Long
                                                
                                                StartP = ColPos2(RSN1)
                                                If RSN1 + 1 > UBound(ColPos2) Then
                                                    ReDim Preserve ColPos2(RSN1 + 20)
                                                End If
                                                EndP = ColPos2(RSN1 + 1) - 2
                                                'If StartP <> EndP Or X = X Then
                                                    'If SeqColRef2(RSN1) = 1 Then
                                                If RSN1 > UBound(SeqColRef2) Then
                                                    ReDim Preserve SeqColRef2(RSN1 + 20)
                                                End If
                                                    SeqCol = ColX(SeqColRef2(RSN1))
'                                                    ElseIf SeqColRef2(RSN1) = 2 Then
'                                                        SeqCol = Col2 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 3 Then
'                                                        SeqCol = Col3 'colour of thing to draw
'                                                    ElseIf SeqColRef2(RSN1) = 4 Then
'                                                        SeqCol = Col4 'colour of thing to draw
'                                                    End If
                                                    For x = StartP To EndP Step 2
                                                        '@
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(2, NumSeqLines) = Offset4 'X1
                                                        SeqLines(3, NumSeqLines) = CLng(ColDist2(x)) * 13 'Y1,7,9,13-16,18,21,23-24,8
                                                        SeqLines(4, NumSeqLines) = Offset1 'X2
                                                        SeqLines(5, NumSeqLines) = (CLng(ColDist2(x + 1))) * 13 + Offset2 'Y2
                                                        '@
                                                        SeqLines(1, NumSeqLines) = SeqCol
                                                        NumSeqLines = NumSeqLines + 1
                                                    Next 'X
                                                'End If
                                            'End If
    '                                        ElseIf X = X Then
    '                                            NSL = NumSeqLines
    '                                            NumSeqLines = FillSeqLines(PermNextno, NSL, Offset1, Offset2, Offset4, RSN1, Col1, Col2, Col3, Col4, UBound(SeqColRef, 1), UBound(SeqLines, 1), UBound(ColDist, 1), ColDist(0, 0), SeqLines(0, 0), SeqColRef(0, 0))
    '                                            'X = X
    '                                        Else
    '                                        ''If X = 12345 Then
    '                                            For X = 0 To PermNextno
    '                                                ''Offset4 = X * 13
    '                                                If SeqColRef(RSN1, X) > 0 Then
    '                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
    '                                                    SeqLines(2, NumSeqLines) = Offset4 'X1
    '                                                    SeqLines(3, NumSeqLines) = X * 13 'Y1
    '                                                    SeqLines(4, NumSeqLines) = Offset1 'X2
    '                                                    SeqLines(5, NumSeqLines) = (X + ColDist(RSN1, X) - 1) * 13 + Offset2 'Y2
    '                                                    If SeqColRef(RSN1, X) = 1 Then
    '                                                        SeqLines(1, NumSeqLines) = Col1
    '                                                    ElseIf SeqColRef(RSN1, X) = 2 Then
    '                                                        SeqLines(1, NumSeqLines) = Col2 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 3 Then
    '                                                        SeqLines(1, NumSeqLines) = Col3 'colour of thing to draw
    '                                                    ElseIf SeqColRef(RSN1, X) = 4 Then
    '                                                        SeqLines(1, NumSeqLines) = Col4 'colour of thing to draw
    '                                                    End If
    '                                                    NumSeqLines = NumSeqLines + 1
    '                                                    X = X + ColDist(RSN1, X)
    '                                                Else
    '                                                    X = X
    '                                                End If
    '                                            Next 'X
    '                                            ''End If
                                            End If
                
                                        Else '
                                            
                                            'Picture1.FillColor = RGB(64, 64, 255)
                                            'Picture1.ForeColor = RGB(64, 64, 255)
                                            'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = ColX(0)  'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = Offset4 'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Offset1 'X2
                                            SeqLines(5, NumSeqLines) = Offset3 'Y2
                                            NumSeqLines = NumSeqLines + 1
            '                                If UBound(SeqLines, 2) < NumSeqLines Then
            '                                    ReDim Preserve SeqLines(5, NumSeqLines + 2000)
            '                                End If
                                            
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                Next 'Y
                
                If ColDistInFile = 1 Then
                    Timer7(1).Enabled = True
                End If
                If WinLeft + PrintSeqLen < UBound(Recompress, 1) Then
                    If Recompress(WinLeft + PrintSeqLen) <> WinLeft + PrintSeqLen Then GoOn = 1
                End If
                If WinLeft <= UBound(Recompress, 1) Then
                If GoOn = 1 Or Recompress(WinLeft) <> WinLeft Then
                    For Y = WinLeft + XS - 1 To WinLeft + XE
                        YCon = Y - WinLeft + 1
                        'XX = UBound(ABCons, 1)
                        If Y <= UBound(ABCons, 1) Then
                            If ABCons(Y) <> 0 Then
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            ElseIf Y <> Decompress(Recompress(Y)) Then    'these sites are ignored
                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                SeqLines(1, NumSeqLines) = RGB(64, 128, 64) 'colour of thing to draw
                                SeqLines(2, NumSeqLines) = YCon * 8 - 8 'X1
                                SeqLines(3, NumSeqLines) = 0 'Y1
                                SeqLines(4, NumSeqLines) = YCon * 8 'X2
                                SeqLines(5, NumSeqLines) = (PermNextno) * 13 + 13 * YConA 'Y2
                                NumSeqLines = NumSeqLines + 1
                                If UBound(SeqLines, 2) < NumSeqLines Then
                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                End If
                            End If
                        End If
                    Next Y
                End If
                End If
                
                If FlashntNum > 0 Then
                    'add in the flashing nts
                    For x = 1 To FlashntNum
                        If Flashnt(0, x) >= WinLeft And Flashnt(0, x) < WinLeft + PrintSeqLen Then
                            If UBSL2 < NumSeqLines + PermNextno Then
                                UBSL2 = NumSeqLines + PermNextno * 3
                                ReDim Preserve SeqLines(5, UBSL2)
                            End If
                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                            SeqLines(1, NumSeqLines) = Flashnt(3, x) 'colour of thing to draw
                            SeqLines(2, NumSeqLines) = (Flashnt(0, x) - WinLeft) * 8 'X1
                            SeqLines(3, NumSeqLines) = Flashnt(1, x) * 13 'Y1
                            SeqLines(4, NumSeqLines) = SeqLines(2, NumSeqLines) + 8 'X2
                            SeqLines(5, NumSeqLines) = SeqLines(3, NumSeqLines) + Offset2
                            NumSeqLines = NumSeqLines + 1
                        End If
                    Next x
                
                End If
                
                
                
                
    '            EE = Abs(GetTickCount)
    '            TT = EE - SS
    '            X = X ''687,703,719
                ''0.610,609,0.625 with rsn1
                '0.609 offset1
                '0.578 with 2000 redim
                
                ''Next zzz
                
                
                
                Picture1.ForeColor = 0
    '        EE = Abs(GetTickCount)
    '        TT = EE - SS
    '        X = X
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            Pict = 0
            Pict = Picture1.hdc
            If Pict = 0 Then
               Picture1.Height = Picture1.Width * 2
               Pict = Picture1.hdc
               Set Form1.Picture1.Picture = Form1.Picture1.Image
                Set sPic = Form1.Picture1.Picture
                cDib.CreateFromPicture sPic
            End If
            On Error GoTo 0
            Dim OutputNum As Long
            For x = 0 To UBound(Output)
                If Output(x) = "" Then Exit For
            Next x
            OutputNum = x
            If XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                            RecompX = WinLeft + Y - 1
                            If ShowSeqFlag = 1 Then
                                
                                If (XPosDiff(Recompress(WinLeft - 2 + Y)) <> XPosDiff(RecompX)) Then 'And SeqNum(WinLeft + Y - 1, Seq3) <> 46 Then
                                    If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq1) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 12  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 12 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        
                                        
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        
                                    End If
                                    If SeqNum(RecompX, Seq2) = SeqNum(RecompX, Seq3) And SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                    ElseIf SeqNum(RecompX, Seq2) <> 46 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 26  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 38  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                        
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                        SeqLines(3, NumSeqLines) = 13  'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                    End If
                                    'ElseIf SeqNum(WinLeft + Y - 1, Seq1) = SeqNum(WinLeft + Y - 1, Seq2) And SeqNum(WinLeft + Y - 1, Seq1) <> 46 Then
                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                    '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                    'End If
                                    num = 2
                                    If SeqNum(RecompX, Seq3) <> 46 Then
                                        For Z = 0 To OutputNum
                                            If RevSeq(Z) <> Seq1 And RevSeq(Z) <> Seq2 And RevSeq(Z) <> Seq3 Then
                                                num = num + 1
                                                If SeqNum(RecompX, RevSeq(Z)) = SeqNum(RecompX, Seq3) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), mPurple, BF
                                                ElseIf SeqNum(RecompX, RevSeq(Z)) <> 46 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                    SeqLines(3, NumSeqLines) = num * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = (num * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 7) * tTYF, Num * 13 * tTYF)-((Y * 8) * tTYF, (Num * 13 + 13) * tTYF), Yellow, BF
                                                End If
                                                    'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'Else
                                                    '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                    'End If
                    
                                                
                                                    
                                            End If
                                            
                                            
                                        Next Z
                                    End If
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((NumberOfSeqs) * 13 + 13) * tTYF), RGB(92, 92, 92), BF
                                End If
                               
                            Else
            
                                If WinLeft + Y - 1 < Len(PPXOSeq(0)) + 1 Then
                                        If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(0), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 12  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line ((Y * 8) - 7, 0)-((Y * 8), 12 * tTYF), Yellow, BF
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            
                                            
                                        End If
                                        If Mid$(Output(MinParPos), Y, 1) = Mid$(Output(1), Y, 1) And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), mPurple, BF
                                        ElseIf Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 26  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 38  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 26 * tTYF)-((Y * 8) * tTYF, 38 * tTYF), Yellow, BF
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                            SeqLines(3, NumSeqLines) = 13  'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 7) * tTYF, 13 * tTYF)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        End If
                                        'ElseIf mid$(output(0),y,1) = mid$(output(2),y,1) And mid$(output(0),y,1) <> 46 Then
                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 13), Yellow, BF
                                        '    Picture1.Line ((Y * 8) - 8, 25)-((Y * 8), 38), Yellow, BF
                                        'End If
                                        num = 2
                                        If Mid$(Output(1), Y, 1) <> "-" Then
                                            For Z = 3 To OutputNum
                                                
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), mPurple, BF
                                                    ElseIf Mid$(Output(Z), Y, 1) <> "-" Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 7)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 7) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 13) * tTYF), Yellow, BF
                                                    End If
                                                        'If mid$(output(0),y,1) <> 46 And mid$(output(0),y,1) <> 47 Then
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'Else
                                                        '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), mPurple, BF
                                                        'End If
                        
                                                    
                                                
                                                
                                            Next Z
                                        End If
                                End If
            
                            End If
                        End If
                    End If
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                
                If pGCTripletflag = 0 Then
                    If ShowSeqFlag = 1 Then
        
                        For Y = XS To XE
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If GCIdentical(RecompX) = 0 Then 'Or GCMonoSiteFlag = 1
        
                                
                                    If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            'If SeqNum(WinLeft + Y - 1, Seq1) <> 46 And SeqNum(WinLeft + Y - 1, Seq1) <> 47 Then
                                            
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            'Else
                                            '    Picture1.Line ((Y * 8) - 8, 0)-((Y * 8), 25), LPurple, BF
                                            'End If
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq1) Or SeqNum(RecompX, SpacerSeqs(Z)) <> SeqNum(RecompX, Seq2) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                            End If
            
                                        Next 'Z
                                    End If
        
                                
        
                                ElseIf GCIdentical(RecompX) = 2 And GCIndelFlag = 1 Then
                                    StartY = Y
            
                                    Do While GCIdentical(RecompX) = 2
                                        Y = Y + 1
                                    Loop
            
                                    Y = Y - 1
            
                                    If Y = StartY Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                        End If
            
                                    Else
                                        'Teststring = Mid$(StrainSeq(Seq1), WinLeft + starty - 1, Y - starty)
            
                                        If Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) = Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                        End If
            
                                        For Z = 1 To OutputNum
            
                                            If Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq1), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(StrainSeq(SpacerSeqs(Z)), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(StrainSeq(Seq2), Recompress(WinLeft + StartY - 1), Recompress(Y) - Recompress(StartY + 1)) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                            End If
            
                                        Next 'Z
            
                                    End If
            
                                Else
            
                                    If GCMonoSiteFlag = 1 And SeqNum(RecompX, Seq1) > 60 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = ((NumEnabledSeqs) * 13 + 12)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), mPurple, BF
                                    Else
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8) - 1) * tTYF, ((NumEnabledSeqs) * 13 + 12) * tTYF), RGB(92, 92, 92), BF
                                    End If
            
                                End If
                            End If
                            
                        Next 'Y
        
                    Else
        
                        For Y = XS To XE
                            If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                                'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                                    RecompX = Recompress(WinLeft - 1 + Y)
                                    If GCIndelFlag <> 1 Then
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                            End If
                
                                        End If
                
                                    Else
                
                                        If GCXDiffPos(RecompX) < Len(StrainSeq(0)) And GCXDiffPos(RecompX) > 0 Then
                
                                            If GCIdentical(GCXDiffPos(RecompX)) = 2 Then
                                                StartY = Y
                
                                                Do While GCIdentical(GCXDiffPos(RecompX)) = 2
                                                    Y = Y + 1
                                                Loop
                
                                                Y = Y - 1
                
                                                If Y = StartY Then
                
                                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        Picture1.Line (((Y * 8) - 8) * tTYF, 0)-(((Y * 8)) * tTYF, 25 * tTYF), mPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                Else
                                                    'TestString = Mid$(Output(0), StartY, Y - StartY + 1)
                
                                                    If Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) = Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), LPurple, BF
                                                    Else
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((StartY * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mYellow, BF
                                                    End If
                
                                                    For Z = 1 To OutputNum
                
                                                        If Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(0), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Or Mid$(Output(Z + 1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) <> Mid$(Output(1), Recompress(StartY), Recompress(Y) - Recompress(StartY + 1)) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((StartY * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), mYellow, BF
                                                        End If
                
                                                    Next 'Z
                
                                                End If
                
                                            Else
                
                                                If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), mPurple, BF
                                                Else
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                    SeqLines(5, NumSeqLines) = 25  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, 25 * tTYF), Yellow, BF
                                                End If
                
                                                For Z = 1 To OutputNum
                
                                                    If Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(0), Y, 1) Or Mid$(Output(Z + 1), Y, 1) <> Mid$(Output(1), Y, 1) Then
                                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = (Y * 8 - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = ((Z + 1) * 13)  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = ((Z + 1) * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, ((Z + 1) * 13) * tTYF)-((Y * 8) * tTYF, ((Z + 1) * 13 + 12) * tTYF), Yellow, BF
                                                    End If
                
                                                Next 'Z
                
                                            End If
                
                                        End If
                
                                    End If
                                'End If
                            End If
                        Next 'Y
        
                    End If
                Else ' ie gctriplrtflag=1
                   
                    LastY = -1
                    
                    For Y = XS To XE
                        If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                            'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If (RecompX) > UBound(XPosDiff, 1) Then Exit For
                                If RecompX > 0 Then
                                
                                    If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX - 1) <> XPosDiff(RecompX)) Or ShowSeqFlag = 2 Then
                                        If LastY > -1 And ShowSeqFlag = 1 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = (LastY * 8 - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y - 1) * 8  'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                            'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                        End If
                                        LastY = -1
                                        Test$ = Mid$(Output$(0), Y, 1)
                    
                                        If Test$ <> "*" And Test$ <> "" Then
                                            CountHits = 0
                    
                                            For x = 0 To 2
                                                If x = 2 Then x = MinParPos
                                                If Mid$(Output(x), Y, 1) = Test$ Then
                                                    CountHits = CountHits + 1
                                                End If
                    
                                            Next 'X
                    
                                            If CountHits < 3 Then
                                                A = 0
                                                C = 0
                                                g = 0
                                                T = 0
                                                S = 0
                    
                                                For Z = 0 To 2
                                                    If Z = 2 Then Z = MinParPos
                                                    If Mid$(Output(Z), Y, 1) = "A" Then
                                                        A = A + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                        C = C + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                        g = g + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                        T = T + 1
                                                    ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                        S = S + 1
                                                    End If
                    
                                                Next 'Z
                    
                                                If A >= g And A >= T And A >= C Then
                                                    CountHits = A
                                                    Test$ = "A"
                                                ElseIf C >= g And C >= T And C >= A Then
                                                    CountHits = C
                                                    Test$ = "C"
                                                ElseIf g >= A And g >= T And g >= C Then
                                                    CountHits = g
                                                    Test$ = "G"
                                                ElseIf T >= g And T >= A And T >= C Then
                                                    CountHits = T
                                                    Test$ = "T"
                                                End If
                    
                                            End If
                    
                                            If CountHits / (2 + 1) = 1 Or S > 0 Or CountHits = 1 Then
                                                If CountHits <> 1 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                
                                                End If
                                            ElseIf CountHits / (3) >= 0.75 Then
                    
                                                For Z = 0 To OutputNum
                    
                                                    If Mid$(Output(Z), Y, 1) = Test$ Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(128, 128, 128) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = Z * 13  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        
                                                    End If
                    
                                                Next 'Z
                    
                                            Else
                    
                                                For Z = 0 To OutputNum
                    
                                                    If ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0 Then
                    
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13 - 1) * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z * 13 - 1)  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 12)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And XPosDiff(RecompX) = 0 Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = Y * 8  'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                    End If
                    
                                                Next 'Z
                    
                                            End If
                    
                                        End If
                    
                                    Else
                    
                                        If LastY = -1 Then
                                            LastY = Y
                                        End If
                    
                                    End If
                                End If
                            'End If
                        End If
        
                    Next 'Y
        
                    If LastY > -1 And ShowSeqFlag = 1 Then
                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)   'X1
                        SeqLines(3, NumSeqLines) = 0 'Y1
                        SeqLines(4, NumSeqLines) = Y * 8   'X2
                        SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                        NumSeqLines = NumSeqLines + 1
                        If UBound(SeqLines, 2) < NumSeqLines Then
                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                        End If
                    End If
                End If
                Picture1.ForeColor = 0
            ElseIf (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
    
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                    
                        If ShowSeqFlag = 1 Then
                            If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Then
                                RecompX = Recompress(WinLeft - 1 + Y)
                                If RecompX = 0 Then RecompX = 1
                                If MCIdentical(RecompX) = 0 Then
            
                                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
            
                                        If SeqNum(RecompX, Seq1) = SeqNum(RecompX, Seq2) Then
            
                                            If SeqNum(RecompX, Seq1) <> 46 And SeqNum(RecompX, Seq1) <> 47 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            Else
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = 25  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            End If
            
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        End If
            
                                    End If
            
                                Else
                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                    SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                    NumSeqLines = NumSeqLines + 1
                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                    End If
                                End If
            
                            Else
            
                                If WinLeft + Y - 1 < Len(MCXoverSeq(0)) + 1 Then
                                    'teststring = Mid$(Output(0), Y, 1)
            
                                    If Mid$(Output(0), Y, 1) = Mid$(Output(1), Y, 1) Then
            
                                        If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(0), Y, 1) <> "." Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        Else
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = LPurple 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = 25  'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        End If
            
                                    Else
                                         SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = Yellow 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                        SeqLines(5, NumSeqLines) = 25  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                    End If
            
                                End If
                            End If
        
                        End If
                    End If
    
                Next 'Y
    
                Picture1.ForeColor = 0
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                LastY = -1
    
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                        'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                            If Recompress(Y + WinLeft - 1) < UBound(XPosDiff, 1) Then
                                RecompX = Recompress(WinLeft + Y - 1)
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = ((Y - 1) * 8)  'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13) 'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                        'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-((((Y - 1) * 8) - 1) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        If CountHits / (3) <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        End If
                
                                        If CountHits / 3 = 1 Then
                                            If ShowSeqFlag = 1 Then
                                                If DebuggingFlag < 2 Then On Error Resume Next
                                                UB2 = 0
                                                UB2 = UBound(PScores, 1)
                                                On Error GoTo 0
                                                If UB2 > 0 Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 0 'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                End If
                                            ElseIf ShowSeqFlag = 2 Then
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0 'Y1
                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                                'Picture1.Line (((Y * 8) - 8) * tTYF, 0)-((Y * 8) * tTYF, ((4) * 12 + 3) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                            End If
                                        ElseIf CountHits / (3) >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                
                                            For Z = 0 To OutputNum
                
                                                If (ShowSeqFlag = 2 Or XPosDiff(RecompX) <> 0) And Output(Z) <> "" Then
                                                     If DebuggingFlag < 2 Then On Error Resume Next
                                                    UB2 = 0
                                                    UB2 = UBound(PScores, 1)
                                                    On Error GoTo 0
                                                    
                                                    
                                                    If UB2 = 15 Then
                                                        ReDim Preserve PScores(Len(StrainSeq(0))) 'Exit Sub
                                                        ReDim Preserve PltCol3(15)
                                                        'XX = UBound(PltCol3, 1)
                                                        'Exit Sub
                                                    End If
                                                    
                                                    If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                        
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                            ReDim Preserve PltCol3(15)
                                                            
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB3 = 0
                                                            UB3 = UBound(PScores, 1)
                                                            UB2 = UBound(PltCol3, 1)
                                                            On Error GoTo 0
                                                            
                                                            If UB2 > 0 And UB3 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z * 13) * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    ElseIf CountHits = 1 Then
                                                        'Picture1.Line ((Y * 8) - 8, (Z) * 13)-((Y * 8), (Z) * 13 + 12), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                        If ShowSeqFlag = 1 Then
                                                            If DebuggingFlag < 2 Then On Error Resume Next
                                                            UB2 = 0
                                                            UB2 = UBound(PScores, 1)
                                                            On Error GoTo 0
                                                            If UB2 > 0 Then
                                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                                SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                                SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                                SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                                SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                                NumSeqLines = NumSeqLines + 1
                                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                                End If
                                                                'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(Y + WinLeft - 1)), BF
                                                            End If
                                                        ElseIf ShowSeqFlag = 2 Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = PltCol3(PScores(XDiffPos(RecompX))) 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), PltCol3(PScores(XDiffpos(Y + WinLeft - 1))), BF
                                                        End If
                                                    End If
                
                                                ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or PScores(RecompX) = 0) Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                ElseIf ShowSeqFlag = 1 And PScores(RecompX) > 0 And Output(Z) <> "" Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = PltCol3(PScores(RecompX)) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = 3  'Y1
                                                    SeqLines(4, NumSeqLines) = Y * 8   'X2
                                                    SeqLines(5, NumSeqLines) = ((OutputNum * 13))   'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, (4 * 13 - 1) * tTYF), PltCol3(PScores(WinLeft + Y - 1)), B
                                                End If
                
                                            Next 'Z
                
                                        End If
                
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            End If
                        'End If
                    End If
                Next 'Y
    
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                    'Picture1.Line (((LastY * 8) - 8) * tTYF, 0)-(((Y - 1) * 8) * tTYF, (4 * 13 - 1) * tTYF), RGB(92, 92, 92), BF
                End If
    
            
            ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 Or XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                LastY = -1
                
                For Y = XS To XE
                    If WinLeft + Y - 1 < Decompress(Len(StrainSeq(0))) Then
                         RecompX = Recompress(WinLeft + Y - 1)
                        If RecompX <= UBound(XDiffPos, 1) Then
                            'If WinLeft + Y - 1 = Decompress(Recompress(WinLeft + Y - 1)) Or X = X Then
                               
                                If RecompX = 0 Then RecompX = 1
                                If (XPosDiff(RecompX) > 0 And (XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft - 2)) Or XPosDiff(RecompX) <> XPosDiff(Recompress(Y + WinLeft)))) Or ShowSeqFlag = 2 Then
                                    If LastY > -1 And ShowSeqFlag = 1 Then
                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                        SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                        SeqLines(3, NumSeqLines) = 0 'Y1
                                        SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                        NumSeqLines = NumSeqLines + 1
                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                        End If
                                    End If
                                    LastY = -1
                                    Test$ = Mid$(Output$(0), Y, 1)
                
                                    If Test$ <> "*" And Test$ <> "" Then
                                        CountHits = 0
                
                                        For x = 0 To 2
                                            If x = 2 Then x = MinParPos
                                            If Mid$(Output(x), Y, 1) = Test$ Then
                                                CountHits = CountHits + 1
                                            End If
                
                                        Next 'X
                
                                        'If X = X Then 'CountHits / 3 <= 0.5 Then
                                            A = 0
                                            C = 0
                                            g = 0
                                            T = 0
                                            S = 0
                
                                            For Z = 0 To 2
                                                If Z = 2 Then Z = MinParPos
                                                If Mid$(Output(Z), Y, 1) = "A" Then
                                                    A = A + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "C" Then
                                                    C = C + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "G" Then
                                                    g = g + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "T" Then
                                                    T = T + 1
                                                ElseIf Mid$(Output(Z), Y, 1) = "." Or Mid$(Output(Z), Y, 1) = "-" Or Mid$(Output(Z), Y, 1) = "*" Then
                                                    S = S + 1
                                                End If
                
                                            Next 'Z
                
                                            If A >= g And A >= T And A >= C Then
                                                CountHits = A
                                                Test$ = "A"
                                            ElseIf C >= g And C >= T And C >= A Then
                                                CountHits = C
                                                Test$ = "C"
                                            ElseIf g >= A And g >= T And g >= C Then
                                                CountHits = g
                                                Test$ = "G"
                                            ElseIf T >= g And T >= A And T >= C Then
                                                CountHits = T
                                                Test$ = "T"
                                            End If
                
                                        'End If
                
                                        If CountHits / 3 = 1 Or S > 0 Then
                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                            SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                            SeqLines(3, NumSeqLines) = 0 'Y1
                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                            SeqLines(5, NumSeqLines) = (OutputNum * 13)   'Y2
                                            NumSeqLines = NumSeqLines + 1
                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                            End If
                                        ElseIf CountHits / 3 >= 0.75 Then
                
                                            For Z = 0 To OutputNum
                
                                                If Mid$(Output(Z), Y, 1) = Test$ Then
                                                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                    SeqLines(1, NumSeqLines) = RGB(128, 128, 255) 'colour of thing to draw
                                                    SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                    SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                    SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                    SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                    NumSeqLines = NumSeqLines + 1
                                                    If UBound(SeqLines, 2) < NumSeqLines Then
                                                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                    End If
                                                    'Picture1.Line (((Y * 8) - 8) * tTYF, (z) * 13 * tTYF)-((Y * 8) * tTYF, (z * 13 + 12) * tTYF), RGB(128, 128, 255), BF
                                                End If
                
                                            Next 'Z
                
                                        Else
                                            GoOn = 0
                                            If (WinLeft + Y - 1) >= 1 Then
                                                'If XPosDiff(WinLeft + Y + 1) <> XPosDiff(WinLeft + Y) Then
                                                    X0 = Mid$(Output(0), Y, 1)
                                                    X1 = Mid$(Output(1), Y, 1)
                                                    X2 = Mid$(Output(MinParPos), Y, 1)
                                                    If Mid$(Output(0), Y, 1) <> "-" And Mid$(Output(1), Y, 1) <> "-" And Mid$(Output(MinParPos), Y, 1) <> "-" Then
                                                        GoOn = 1
                                                    End If
                                                'End If
                                            End If
                                           
                                            If GoOn = 1 Then
                                                For Z = 0 To OutputNum
                                                    
                                                    If ShowSeqFlag = 2 Or (XPosDiff(RecompX) <> 0 And GoOn = 1) Then
                                                        
                                                        If Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mYellow 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, ((Z) * 13 + 12) * tTYF), mYellow, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(0), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mGreen 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, (Z) * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mGreen, BF
                                                            'X = X
                                                        ElseIf Mid$(Output(Z), Y, 1) = Mid$(Output(MinParPos), Y, 1) And Mid$(Output(Z), Y, 1) = Mid$(Output(1), Y, 1) Then
                                                            SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                            SeqLines(1, NumSeqLines) = mPurple 'colour of thing to draw
                                                            SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                            SeqLines(3, NumSeqLines) = (Z) * 13  'Y1
                                                            SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                            SeqLines(5, NumSeqLines) = (Z * 13 + 13)  'Y2
                                                            NumSeqLines = NumSeqLines + 1
                                                            If UBound(SeqLines, 2) < NumSeqLines Then
                                                                ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                            End If
                                                            'Picture1.Line (((Y * 8) - 8) * tTYF, Z * 13 * tTYF)-((Y * 8) * tTYF, (Z * 13 + 12) * tTYF), mPurple, BF
                                                            'X = X
                                                        End If
                    
                                                    ElseIf ShowSeqFlag = 1 And (XPosDiff(RecompX) = 0 Or GoOn = 0) Then
                                                        SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                        SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                        SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                        SeqLines(3, NumSeqLines) = 3  'Y1
                                                        SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                        SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                        NumSeqLines = NumSeqLines + 1
                                                        If UBound(SeqLines, 2) < NumSeqLines Then
                                                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                        End If
                                                        'Picture1.Line (((Y * 8) - 8) * tTYF, 3 * tTYF)-((Y * 8) * tTYF, ((3 + SpacerNo) * 13 - 1) * tTYF), RGB(92, 92, 92), B
                                                    
                                                    End If
                    
                                                Next 'Z
                                            Else
                                                
                                                'SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                'SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                'SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                                                'SeqLines(3, NumSeqLines) = 0 'Y1
                                                'SeqLines(4, NumSeqLines) = (((Y - 1) * 8))    'X2
                                                'SeqLines(5, NumSeqLines) = ((3 + SpacerNo) * 13)  'Y2
                                                'NumSeqLines = NumSeqLines + 1
                                                'If UBound(SeqLines, 2) < NumSeqLines Then
                                                '    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                'End If
                                                SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                                                SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                                                SeqLines(2, NumSeqLines) = ((Y * 8) - 8)  'X1
                                                SeqLines(3, NumSeqLines) = 0  'Y1
                                                SeqLines(4, NumSeqLines) = (Y * 8)   'X2
                                                SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                                                NumSeqLines = NumSeqLines + 1
                                                If UBound(SeqLines, 2) < NumSeqLines Then
                                                    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                                                End If
                                            
                                            End If
                                        End If
                                        
                                    End If
                
                                Else
                
                                    If LastY = -1 Then
                                        LastY = Y
                                    End If
                
                                End If
                            'End If
                        End If
                    End If
                Next 'Y
                
                If LastY > -1 And ShowSeqFlag = 1 Then
                    SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
                    SeqLines(1, NumSeqLines) = RGB(92, 92, 92) 'colour of thing to draw
                    SeqLines(2, NumSeqLines) = ((LastY * 8) - 8)  'X1
                    SeqLines(3, NumSeqLines) = 0 'Y1
                    SeqLines(4, NumSeqLines) = ((Y - 1) * 8)   'X2
                    SeqLines(5, NumSeqLines) = (OutputNum * 13)  'Y2
                    NumSeqLines = NumSeqLines + 1
                    If UBound(SeqLines, 2) < NumSeqLines Then
                        ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                    End If
                End If
    
            End If
    
        End If
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = 0
    Pict = Picture1.hdc
    If Pict = 0 Then
       Picture1.Height = Picture1.Width * 2
       Pict = Picture1.hdc
       Set Form1.Picture1.Picture = Form1.Picture1.Image
        Set sPic = Form1.Picture1.Picture
        cDib.CreateFromPicture sPic
    End If
    On Error GoTo 0
 'XX = Len(Output(0))
'593248
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        If WinLeft > Decompress(Len(StrainSeq(0))) - 58 Then
    
            For x = 0 To PermNextno
    
                If Len(Output(x)) > 0 Then
                    Output(x) = Output(x) + String$(58 - (Decompress(Len(StrainSeq(0))) - WinLeft), " ")
                End If
    
            Next 'X
    
        End If
    End If
    'XX = Picture1.TextHeight("A") - 3
    If OnlyDoPosBar = 0 And OnlyDoPositionIndicator = 0 Then
        Dim LOut As Long
        LOut = XE - XS + 1
        'XX = Mid$(StrainSeq(0), 208, 20)
        If LOut = 0 Then
            LOut = 1
            
        End If
        SeqText2 = String(LOut * (PermNextno + 2), " ")
        PrintStartY = XS
       
        
        
        'If Picture1.FontSize > 3 Or X = X Then
       
            For x = 0 To UBound(Output, 1) 'PermNextno
'        XX = FlashntX1
'
'        XX = FlashntX2
        
                If Len(Output(x)) > 0 Then
                    If UBound(SeqText, 1) < NumSeqText Then
                        ReDim Preserve SeqText(NumSeqText + 20)
                    End If
                    'If Len(Output(X)) > 0 Then
                        '@
                        SeqText(NumSeqText) = Mid$(Output(x), XS, LOut)
                        
                        Mid$(SeqText2, 1 + (x * LOut), LOut) = Mid$(Output(x), XS, LOut)
                        '@
                        SeqLines(0, NumSeqLines) = 1 'this is text
                        '@
                        SeqLines(1, NumSeqLines) = NumSeqText 'position of string in seqtext
                        SeqLines(2, NumSeqLines) = 0 'xposition
                        SeqLines(3, NumSeqLines) = x * 13 'yposition
                        NumSeqText = NumSeqText + 1
                        NumSeqLines = NumSeqLines + 1
                        If UBound(SeqLines, 2) < NumSeqLines Then
                            ReDim Preserve SeqLines(5, NumSeqLines + 1000)
                        End If
                    'Else
                    '   X = X
                    'End If
                    'TextOut Pict, 0, (((X * 13 - TYFM) * tTYF)), Output(X), Len(Output(X))
                End If
        
            Next 'X
        'End If
    
        'XX = Len(Output(1))
        '596996
        'If OnlyDoPosBar = 1 Then GoTo PosBarBit
        Dim SectionLen As Long, OverlapX As Long, XPrintseqlen As Long
        If DSDFlag = 0 Then
            Call DoSeqDisplay
            
        ElseIf DSDFlag = 1 Then
'            Dim sPic As StdPicture, cDib As New cDibSection, hdcHolder As Long
'            '@
           
            hdcHolder = cDib.hdc
            Call DoSeqDisplayDIB(hdcHolder)
            'Form1.Picture1.Top = -300
            'Form1.Picture1.Left = -300
            BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            'cDib.PaintPicture Form1.Picture1.hdc
        ElseIf DSDFlag = 2 Then
            XLenPerColumn = tTYF * XConA
            XPrintseqlen = PrintSeqLen * tTYF * XConA * 8 - 1 'PrintSeqLen * XLenPerColumn * 8
            If FlashntNum > 0 Or ShowSeqFlag <> 0 Or (Abs(WinLeft - LastLeftPos) >= PrintSeqLen Or ((PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) And (LastTop <> TopPosY Or LastBottom <> BottomPosY))) Then
                hdcHolder = cDib.hdc
                
                Call DoSeqDisplayDIB2(hdcHolder)
                'Form1.Picture1.Top = -300
                'Form1.Picture1.Left = -300
                BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                'cDib.PaintPicture Form1.Picture1.hdc
            
            ElseIf (PrintSeqLen <> LastPrintSeqLen Or WinLeft <> LastLeftPos) Then ' just do left right thing
                hdcHolder = cDib.hdc
                
                'BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                
                
                OverlapX = CLng(XLenPerColumn * (2) * 8)
                'XX = Form1.Picture9.ScaleWidth
                
                If WinLeft > LastLeftPos Then
                    SectionLen = CLng(XLenPerColumn * (WinLeft - LastLeftPos) * 8)
                    'SectionLen = 400
                    '@
                    BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen - SectionLen, Form1.Picture9.ScaleHeight, Form1.Picture1.hdc, SectionLen, 0, vbSrcCopy
                    'Picture1.Refresh
                    Call DoSeqDisplayDIB2(hdcHolder)
                    '@
                    BitBlt Form1.Picture1.hdc, XPrintseqlen - SectionLen, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, XPrintseqlen - SectionLen, 0, vbSrcCopy
                Else
                    SectionLen = CLng(XLenPerColumn * (LastLeftPos - WinLeft) * 8)
                    BitBlt Form1.Picture1.hdc, SectionLen, 0, XPrintseqlen - SectionLen, Form1.Picture9.ScaleHeight, Form1.Picture1.hdc, 0, 0, vbSrcCopy
                    Call DoSeqDisplayDIB2(hdcHolder)
                    BitBlt Form1.Picture1.hdc, 0, 0, SectionLen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                End If
                
                
            ElseIf (LastTop <> TopPosY Or LastBottom <> BottomPosY) Then ' just do up down thing
                hdcHolder = cDib.hdc
                
                'BitBlt Form1.Picture1.hdc, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
                Call DoSeqDisplayDIB2(hdcHolder)
                BitBlt Form1.Picture1.hdc, 0, 0, XPrintseqlen, Form1.Picture9.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
            
            End If
        
        
            LastPrintSeqLen = PrintSeqLen
            LastLeftPos = WinLeft
            LastTop = TopPosY
            LastBottom = BottomPosY
            
        End If
        '601668
        If VScroll3.Value <> LastVScroll3Value Then
            If ShowSeqFlag = 0 Then
                Call PrintNames
            Else
                Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
            End If
             LastVScroll3Value = VScroll3.Value
        End If
    End If
    

   
    
    Picture1.DrawMode = 13
    Picture1.ForeColor = 0
    
    
    'If ShowSeqFlag = 1 Then
    '    Picture7.Refresh
    '    Picture7.AutoRedraw = False
    '    Picture7.DrawMode = 12
    '    Picture7.Line (P1, 5)-(P2, 10 - 1), QuaterColour, BF ' QBColor(7), BF
    '    Picture7.DrawMode = 13
    '    Picture7.AutoRedraw = True
    'End If

    
   
    'Picture13.AutoRedraw = True
    'Picture13.Picture = LoadPicture()
    
    
    PrintSeqLen = MakePrintSeqLen
    
    Picture4.AutoRedraw = False
    Picture11.AutoRedraw = False
    If OnlyDoPosBar = 0 Or OnlyDoPositionIndicator = 1 Then
        
        Form1.Picture4.BorderStyle = 1
        P1 = CLng(((THold * HScroll1Mod) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        If ShowSeqFlag < 2 Then
            
            P2 = P1 + CLng(((PrintSeqLen - 5) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
        Else
            If (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
                If (WinLeft + PrintSeqLen - 5) < Len(MCXoverSeq(0)) Then
                        P2 = CLng((Decompress(MCXDiffPos(WinLeft + PrintSeqLen - 5)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(MCXDiffPos(WinLeft)) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                If pGCTripletflag = 0 Then
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                Else
                    If (WinLeft + PrintSeqLen - 5) < Len(GCXOverSeq(0)) Then
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                   
                    End If
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(SSSubSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
                If (WinLeft + PrintSeqLen - 5) < Len(CXoverSeq(0)) Then
                        P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                        P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                Else
                        P2 = CLng(1 * Picture11.ScaleWidth)
                    
                End If
            Else
                If WinLeft <= UBound(XDiffPos, 1) Then
                    If Recompress(WinLeft + PrintSeqLen - 5) < Len(XOverSeq(0)) And Decompress(XDiffPos((Recompress(WinLeft + PrintSeqLen - 5)))) > 0 Then
                            P1 = CLng((Decompress(XDiffPos((WinLeft))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    
                            P2 = CLng((Decompress(XDiffPos((WinLeft + PrintSeqLen - 5))) / Decompress(Len(StrainSeq(0)))) * Picture11.ScaleWidth)
                    Else
                            P2 = CLng(1 * Picture11.ScaleWidth)
                        
                    End If
                End If
            End If
            
        End If
        If P2 = P1 Then P2 = P1 + 1
        PosIndicatorP11(1) = P2 / Picture11.ScaleWidth
        PosIndicatorP11(0) = P1 / Picture11.ScaleWidth
        If ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
            RedrawPlotAA (1)
        End If
        
        If HomologyIndicator = 2 Then
            
            Picture11.DrawMode = 12
            'Picture11.ForeColor = HalfColour 'QuaterColour
            Picture11.Refresh
            Picture11.Line (P1, 0)-(P2, Picture11.ScaleHeight - 1), QuaterColour, BF ' QBColor(7), BF
        ElseIf HomologyIndicator = 1 Then
            
            
            Picture4.DrawMode = 6
            '
            
            
            Pict4 = Picture4.hdc
            Pict4SH = Picture4.ScaleHeight - 1
            '@
            'Picture4.ForeColor = QBColor(7)
            '~10% of the time is spent drawing this rectangle
             'Picture4.FillStyle = 1
             '@
             Picture4.Refresh
'            ReDim PolyPoints(5)
'            PolyPoints(0).x = P1: PolyPoints(0).y = 0
'            PolyPoints(1).x = P2: PolyPoints(1).y = 0
'            PolyPoints(2).x = P2: PolyPoints(2).y = Pict4SH
'            PolyPoints(3).x = P1: PolyPoints(3).y = Pict4SH
'            PolyPoints(4).x = P1: PolyPoints(4).y = 0
'            Polygon Picture4.hdc, PolyPoints(0), 4
             
            
             'Rectangle Pict4, P1, 0, P2, Picture4.ScaleHeight - 1
            
            MoveToEx Pict4, P1, 0, PAP
            LineTo Pict4, P2, 0
            LineTo Pict4, P2, Pict4SH
            LineTo Pict4, P1, Pict4SH
            LineTo Pict4, P1, 0
        End If
        PositionIndicaterOn = 1
        'If OnlyDoPositionIndicator = 1 And OnlyDoPosBar = 0 Then Exit Sub
    End If
    
    
    'If OnlyDoPositionIndicator = 0 And (Timer1.Enabled = False Or BPFlashed = 0) Or X = X Then
        

        'XX = Picture13.AutoRedraw
        'XX = Picture13.AutoRedraw
        
        Call DoP13Stuff(tTYF)
    
     
    'End If
'601580

    
    
    
    
    
    
    
    Picture1.Refresh
    '@
    Picture13.Refresh
    
    RLFlag = 0

    If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
        Picture3.Enabled = True
    Else
        Picture3.Enabled = False
    End If
    
    
    
    
    
    
'    If HorstFlag = 1 Then
'        X = X
'        X = X
'        Call DrawHorstInterval(WinLeft, PrintSeqLen)
'    End If
    Exit Sub
UnknownFormat:

    Call UnknownF
    
End Sub
Private Sub UnknownF()
    If RunFlag = 0 And ManFlag = -1 Then
        Picture1.BackColor = Form1.BackColor
        Picture3.BackColor = Form1.BackColor
        Picture4.BackColor = Form1.BackColor
        Picture11.BackColor = Form1.BackColor
        Picture13.BackColor = Form1.BackColor
    End If

    Response = MsgBox("I could not recognise this DNA alignment file format" + Chr$(13) + "Send it as an attatchment to darrenpatrickmartin@gmail.com", 32)
    ErrorFlag = 1
    RLFlag = 0
    Screen.MousePointer = 0
End Sub
Private Sub HScroll1_GotFocus()
    If (RelX > 0 Or RelY > 0) And Form1.Picture6.Enabled = True Then
         If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    Else
        If Form1.Command3.Enabled = True Then
            Form1.Command3.SetFocus
        End If
    End If
End Sub

Private Sub HScroll1_LostFocus()
x = x
End Sub

Private Sub HScroll1_Scroll()
If HScroll1.Value < HScroll1.Max / 2 Then
    H1M = -10000
Else
    H1M = 10000
End If

'SS = abs(gettickcount)
'For X = 1 To 300
'DontDoH1Inc = 1
    Call HScroll1_Change
'DontDoH1Inc = 0
'Next X
'EE = abs(gettickcount)
'TT = EE - SS
'6250
'4641 getting rid of picture1.cls
'2422
'7203 for 300
'6922
'6516
'6313
'5969
'X = X
'Form1.Picture1.Refresh
'XX = Decompress(Len(StrainSeq(0))) '5742700
End Sub

Private Sub HScroll2_Change()
    '260
    Form1.Picture6.Left = -HScroll2.Value
End Sub

Private Sub HScroll2_GotFocus()
     If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
End Sub

Private Sub HScroll2_Scroll()
    Form1.Picture6.Left = -HScroll2.Value
End Sub

Private Sub HScroll3_Change()
'This is a workaround for executing picture6_mousemove from outside form1
    HighlightFlag = 0
    Picture6.Enabled = True
    Picture5.Enabled = True
    If F2ontop <> 1 Then
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj) '370,186,0
        DontPutForm2Ontop = 0
    End If
End Sub


Public Sub HScroll4_Change()
'Timer3.Enabled = False
'Timer3.Enabled = False
'If HScroll4.Value < HScroll4.Max / 4 Then
'    HScroll4.Value = HScroll4.Max / 4
'
'End If
'
'
'
'If HScroll4.Value > (HScroll4.Max / 4) * 3 Then
'    HScroll4.Value = (HScroll4.Max / 4) * 3
'
'End If
'XX = HScroll4.Value
'XX = HScroll4.Max

ButtonScrollFlag = 1
If H1C = 1 Then Exit Sub
If F1MDF = 0 Then
    If DontDoKey = 2 Then
        DontDoKey = 0
    Else
        DontDoKey = 1
    End If
'ElseIf Picture26.Top = 0 And HScroll4.Value = 1 Then
'    Picture26.Top = Picture26.Top - Picture26.Height / 4
'    Picture26.left = Picture26.left - Picture26.Width / 4
End If

If Timer3.Enabled = False And DontResetFocus = 0 Then
    Command3.SetFocus
End If
Dim SS As Long, EE As Long, TT As Long
Dim TDist(1) As Double, UB As Long
UB = -1
If DebuggingFlag < 2 Then On Error Resume Next
If CurMatrixFlag = 2 Then
        UB = (UBound(MatrixM, 1) - 1)
ElseIf CurMatrixFlag = 1 Then
        UB = (UBound(MatrixR, 1) - 1)
ElseIf CurMatrixFlag = 0 Then
    'If DebuggingFlag < 2 Then On Error Resume Next
        UB = (UBound(MatrixC, 1) - 1)
    'On Error GoTo 0
ElseIf CurMatrixFlag = 14 Then
    'If DebuggingFlag < 2 Then On Error Resume Next
        UB = (UBound(MatrixTB, 1) - 1)
    'On Error GoTo 0
ElseIf CurMatrixFlag = 3 Then
        UB = (UBound(MatrixRR, 1) - 1)
ElseIf CurMatrixFlag = 4 Then
        UB = (UBound(MatrixBP, 1) - 1)
ElseIf CurMatrixFlag = 5 Then
    UB = UBound(MatrixLD, 1) - 1
ElseIf CurMatrixFlag = 6 Then
    UB = UBound(MatrixRMin, 1) - 1
ElseIf CurMatrixFlag = 7 Then
    UB = UBound(MatrixRMinD, 1) - 1
ElseIf CurMatrixFlag = 8 Then
        UB = UBound(MatrixMC, 1) - 1
ElseIf CurMatrixFlag = 11 Then
        UB = UBound(MatrixL, 1) - 1
ElseIf CurMatrixFlag = 12 Then
    
    UB = UBound(MatrixSH, 2) - 1
    
ElseIf CurMatrixFlag = 13 Then
    
    UB = UBound(MatrixRF, 1) - 1
        
End If
On Error GoTo 0
If UB = -1 Then
    CurMatrixFlag = 255
End If


If CurMatrixFlag = 255 Then Exit Sub

'MatCoord(CurMatrixFlag, 0) = HScroll4.Value
'MatCoord(CurMatrixFlag, 1) = VScroll5.Value
If Form1.VScroll5.Max < 1 Or Form1.HScroll4.Max < 1 Then
    If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 32000 And (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight > 0 Then
        Form1.VScroll5.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        Form1.HScroll4.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        
       ' Form1.VScroll5.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
       ' Form1.HScroll4.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
    ElseIf (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 1 Then
        Form1.HScroll4.Max = 0: Form1.HScroll4.Enabled = False
        Form1.VScroll5.Max = 0: Form1.VScroll5.Enabled = False
    Else
        Form1.VScroll5.Max = 32000
        Form1.HScroll4.Max = 32000
        MatZoom(CurMatrixFlag) = (Form1.HScroll4.Max + Form1.Picture26.ScaleHeight) / (Form1.Picture26.ScaleHeight * 2)
    End If
    If Form1.VScroll5.Max < 1 Then
        Form1.VScroll5.Max = 0
    End If
    If Form1.HScroll4.Max < 1 Then
        Form1.HScroll4.Max = 0
    End If
    
End If


If HScroll4.Max > 0 Then
    If MatZoom(CurMatrixFlag) > 0 Then
    TDist(0) = (HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    End If
Else
    TDist(0) = 0
End If
If VScroll5.Max > 0 Then
    If MatZoom(CurMatrixFlag) > 0 Then
        TDist(1) = (VScroll5.Value / VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    End If
Else
    TDist(1) = 0
End If

If F1MDF = 0 Then
    MatCoord(CurMatrixFlag, 0) = TDist(0) '* (MatZoom(CurMatrixFlag) - 1) '(TDist(0) * MatZoom(CurMatrixFlag)) / 4.5 '- UB / 2 * MatZoom(CurMatrixFlag) ' - UB / 2) / MatZoom(CurMatrixFlag)
    'MatCoord(CurMatrixFlag, 0) = (TDist(0) * MatZoom(CurMatrixFlag) - UB / 2) / MatZoom(CurMatrixFlag)
    MatCoord(CurMatrixFlag, 1) = TDist(1) ' * MatZoom(CurMatrixFlag) - UB / 2) / MatZoom(CurMatrixFlag)
End If
'ActualMidPixelV = TDist(1) + (UB / 2) / MatZoom(CurMatrixFlag)
'ActualMidPixelH = TDist(0) + (UB / 2) / MatZoom(CurMatrixFlag)

If MatCoord(CurMatrixFlag, 1) < 0 Then MatCoord(CurMatrixFlag, 1) = 0
'If MatCoord(CurMatrixFlag, 1) > UB * (MatZoom(CurMatrixFlag) - 1) Then MatCoord(CurMatrixFlag, 1) = UB * (MatZoom(CurMatrixFlag) - 1)
If MatCoord(CurMatrixFlag, 0) < 0 Then MatCoord(CurMatrixFlag, 0) = 0
'If MatCoord(CurMatrixFlag, 0) > UB * (MatZoom(CurMatrixFlag) - 1) Then MatCoord(CurMatrixFlag, 0) = UB * (MatZoom(CurMatrixFlag) - 1)

If HScroll4.Max = 0 Or VScroll5.Max = 0 Then
    MatCoord(CurMatrixFlag, 0) = 0
    MatCoord(CurMatrixFlag, 1) = 0
End If

If DoVS5 = 0 And (Form1.SSPanel6(2).Visible = True Or DoMatrixWhileResizing = 1) Then
    If CurMatrixFlag = 2 Then
        
        Call ModMatMnu_Click
    ElseIf CurMatrixFlag = 1 Then
        Call RecMatMnu_Click
        
    ElseIf CurMatrixFlag = 0 Then
        Call CMMnu_Click(0)
    ElseIf CurMatrixFlag = 14 Then
        Call CMMnu_Click(1)
    ElseIf CurMatrixFlag = 3 Then
        Call RecRCMnu_Click
    ElseIf CurMatrixFlag = 4 Then
        Call RecBPMnu_Click
    ElseIf CurMatrixFlag = 5 Then
        Call LDMatMnu_Click
    ElseIf CurMatrixFlag = 6 Then
        Call RMinMnu_Click
    ElseIf CurMatrixFlag = 7 Then
        Call RMinDMnu_Click
    ElseIf CurMatrixFlag = 8 Then
        MCMSN = 1
        Call MCMatMnu_Click
        MCMSN = 0
    ElseIf CurMatrixFlag = 11 Then
        Call LMatMnu_Click
    ElseIf CurMatrixFlag = 12 Then
        Call SHMatrixMnu_Click
    ElseIf CurMatrixFlag = 13 Then
        Call RFMatrixMnu_Click
        
    End If
End If
DontDoKey = 0
ButtonScrollFlag = 0
End Sub

Private Sub HScroll4_GotFocus()
DoVS5 = 0
HVScrollflag = 0
End Sub

Private Sub HScroll4_Scroll()
Call HScroll4_Change

End Sub

Private Sub Image3_Click(Index As Integer)
x = x
End Sub

Private Sub InvertMaskMnu_Click()
    
    For x = 0 To NextNo
        
        If MaskSeq(x) = 1 Then
            MaskSeq(x) = 2
        ElseIf MaskSeq(x) = 0 Then
            MaskSeq(x) = 1
        ElseIf MaskSeq(x) = 2 Then
            MaskSeq(x) = 0
        End If

    Next 'X
    
    Call PrintNames
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    LastY3 = -1
    
    Form1.MaskAllMnu.Visible = True
    Form1.UnmaskAllMnu.Visible = True
    Form1.DisableAllMnu.Visible = True
End Sub

Private Sub Label1_DblClick()
    Command25.Enabled = True
End Sub

Private Sub LDMatMnu_Click()
DontDoKey = 0
'If ButtonScrollFlag = 0 And CurMatrixFlag = 5 Then DoneMatX(5) = 0
CurMatrixFlag = 5
Call RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, 5, 0)


Form1.Check1.Enabled = False
Call DoMatCap
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If

Command39(0).Enabled = True
End Sub

Private Sub Label58_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
        Picture6.Refresh
        CurFlash = 0
        Timercheck(1) = 0
        Call Timer1_Timer
        HighlightFlag = 0
        RecSeq = 0
        PAVal = 0
        If RIMode = 1 Then
            Call MakeSummary
        End If
    End If
End Sub

Private Sub LDMnu_Click()
Call LDMatMnu_Click
End Sub

Private Sub LMatMnu_Click()
Dim oLRDRegion As Byte
Call ModSeqNum(0, 0, 1)
oLRDRegion = LRDRegion
LRDRegion = 2
If ButtonScrollFlag = 0 And CurMatrixFlag = 11 Then DoneMatX(11) = 0
If DoneMatX(11) = 0 Then
    CurMatrixFlag = 11
    Call LXoverB(0, 0)
Else
    CurMatrixFlag = 11
    Call DrawLRDMat
End If
LRDRegion = oLRDRegion
Call UnModSeqNum(1)
CurMatrixFlag = 11
Form1.Check1.Enabled = False
Call DoMatCap
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If

Command39(0).Enabled = True
End Sub

Private Sub LoadHWSitesetMnu_Click(Index As Integer)
    Dim Response As Long, Response2 As Long, UB As Long, StripOLFlag As Long, RealignFlag As Long, StripPartFlag As Long, AName As String
    If Index = 0 Then 'colour/histogram toggle
        Call Command6_Click(1)
    ElseIf Index = 1 Then
        F7Flag = 10
        'If IDDisplayMode = 0 Then
        
        Form7.Caption = "Change window size"
        'ElseIf IDDisplayMode = 1 Then
        '    Form7.Caption = "Change window size for similarity display"
        'End If
        
        Form7.Label1(0).Caption = "Window size"
        Form7.Text1(0).Text = FullWindowSize
        Form7.Label1(1).Visible = False
        Form7.Label1(0).Visible = True
        Form7.Text1(0).Visible = True
        Form7.Text1(1).Visible = False
        Form7.Combo1.Visible = False
        
        
        OSM = Form1.ScaleMode
        Form1.ScaleMode = 1
        Form7.Top = Form1.SSPanel4.Top
        Form7.Left = Form1.SSPanel4.Left + Form1.Picture4.Width / 2 - Form7.Width / 2
        Form1.ScaleMode = OSM
        Form7.Text1(0).ToolTipText = "Any number between 1 and " + Trim(Str(CLng(Len(StrainSeq(0)) * 0.9)))
        
        Form7.ScaleMode = 3
        Form7.ScaleHeight = 50
        Form7.Label1(0).Top = 5
        
        Form7.Text1(0).Top = Form7.Label1(0).Top
        
        
        Form7.Label1(0).Width = 70
        
        Form7.Text1(0).Width = 50
        
        Form7.Command1(0).Top = Form7.Text1(0).Top + Form7.Text1(0).Height + 5
        Form7.Command1(1).Top = Form7.Command1(0).Top
        Form7.Command1(0).Width = Form7.Text1(0).Width
        Form7.Command1(1).Width = Form7.Text1(0).Width
        Form7.ScaleMode = 3
        Form7.Label1(0).Left = 5
        Form7.ScaleMode = 3
        Form7.Text1(0).Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
        
        
        
        Form7.Visible = True
        'Form7.Text1(0).Visible = True
        Form7.Text1(0).SetFocus
    ElseIf Index = 6 Then 'save siteset
        ReDim SHAPEScores(Len(StrainSeq(0)))
        If IDDisplayMode = 0 Then
            For x = 1 To Len(StrainSeq(0))
                SHAPEScores(x) = BkgIdentity(x)
            Next x
        ElseIf IDDisplayMode = 1 Then
            For x = 1 To Len(StrainSeq(0))
                SHAPEScores(x) = TajD(x)
            Next x
        ElseIf IDDisplayMode = 2 Then
            For x = 1 To Len(StrainSeq(0))
                SHAPEScores(x) = GCContent(x)
            Next x
        End If
        SHAPECO = 10000
        SHAPEFlag = 1
    ElseIf Index = 3 Then ' tajima/identity toggle
        IDDisplayMode = 0
        Call CalcIdentity3(1)
    ElseIf Index = 4 Then ' tajima/identity toggle
        IDDisplayMode = 1
        Call CalcIdentity3(1)
    ElseIf Index = 5 Then
        IDDisplayMode = 2
        Call CalcIdentity3(1)
    ElseIf Index = 9 Then 'Save alignment
        Call SaveAASeqs
    ElseIf Index = 10 Then 'Save all gene alignments
        If DebuggingFlag < 2 Or x = x Then On Error Resume Next
        UB = -1
        UB = UBound(OverlapList, 1)
        On Error GoTo 0
        If UB = -1 Then Call MakeOverlapList
        
        For x = 1 To GeneNumber
            StripOLFlag = 0
            If GenesWithOverlaps(x) = 1 Then
                Response = MsgBox("You should note that nucleotides within some of the codons in some of the genes are expressed in two different frames. If you are intending to use the saved gene alignments to analyse natural selection using dN/dS based approaches you should discard these codons. Would you like to save only codon positions that do not overlap with codon positions in other genes?", vbYesNo)
                If Response = 6 Then
                    StripOLFlag = 1
                Else
                    StripOLFlag = 0
                End If
                Exit For
            End If
        Next x
        
        'AccountREcombFlag
        '222
        
        Response = MsgBox("Would you like to separate out portions of the gene that have potentially been aquired from different parents following recombination? It would be a good idea to do this if, for example, you are intending to use the codon alignment to detect positive selection using dN/dS based methods", vbYesNo)
        '6=yes, 7=no
        If Response = 6 Then
            AccountREcombFlag = 1
        Else
            AccountREcombFlag = 0
        End If
        
        
'        Response = MsgBox("Would you like me to save codon alignments of the gene sequences (I will realign the codons using Muscle)?", vbYesNo)
'        '6=yes, 7=no
'        If Response = 6 Then
'            RealignFlag = 1
'        Else
'            RealignFlag = 0
'        End If
        Response = MsgBox("Would you like me to strip stop codons and partial codons from the saved alignment?", vbYesNo)
        '6=yes, 7=no
        If Response = 6 Then
            StripPartFlag = 1
        Else
            StripPartFlag = 0
        End If
        'Call savegenealignment(Curgene, StripOLFlag, RealignFlag, StripPartFlag)
        With Form1.CommonDialog1
            .FileName = ""
            .DefaultExt = "fas"
            .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
            .FilterIndex = 1
            .Action = 2 'Specify that the "open file" action is required.
            AName = .FileName  'Stores selected file name in the
            ANameII = .FileTitle
        End With
        Dim Firstpart As String, SecondPart As String
        For x = Len(AName) To 1 Step -1
            If Mid$(AName, x, 1) = "." Then
                SecondPart = Right(AName, Len(AName) - x + 1)
                Firstpart = Left(AName, x - 1)
                Exit For
            End If
        Next x
        
        If AccountREcombFlag = 1 And SEventNumber = 0 Then
            Call Command22_Click
        End If

        For x = 1 To GeneNumber
            If GeneList(x).Name <> "" And GeneList(x).Name <> " " And InStr(1, GeneList(x).Name, "/", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Name, "\", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Name, "*", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Name, "?", vbBinaryCompare) = 0 Then
                Form1.SSPanel1.Caption = "Saving alignment for " + GeneList(x).Name + " (gene " + Trim(Str(x)) + " out of " + Trim(Str(GeneNumber)) + ")"
                
                
                Call SaveGeneAlignment(Firstpart + " " + GeneList(x).Name + SecondPart, x, StripOLFlag, RealignFlag, StripPartFlag, AccountREcombFlag, 0, 0)
            ElseIf GeneList(x).Product <> "" And GeneList(x).Product <> " " And InStr(1, GeneList(x).Product, "/", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Product, "\", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Product, "*", vbBinaryCompare) = 0 And InStr(1, GeneList(x).Product, "?", vbBinaryCompare) = 0 Then
                Form1.SSPanel1.Caption = "Saving alignment for " + GeneList(x).Product + " (gene " + Trim(Str(x)) + " out of " + Trim(Str(GeneNumber)) + ")"
                
                
                Call SaveGeneAlignment(Firstpart + " " + GeneList(x).Product + SecondPart, x, StripOLFlag, RealignFlag, StripPartFlag, AccountREcombFlag, 0, 0)
            Else
                Form1.SSPanel1.Caption = "Saving alignment for gene " + Trim(Str(x)) + " (of " + Trim(Str(GeneNumber)) + ")"
                Call SaveGeneAlignment(Firstpart + " Gene " + Trim(Str(x)) + SecondPart, x, StripOLFlag, RealignFlag, StripPartFlag, AccountREcombFlag, 0, 0)
                
            End If
             Form1.ProgressBar1.Value = (x / GeneNumber) * 100
             Call UpdateF2Prog
             If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Next x
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        
        Call UpdateF2Prog
    ElseIf Index = 12 Then 'FUBAR
        
    
    ElseIf Index = 15 Then 'SCHEMA
    
    
    End If
End Sub

Private Sub LSMnu_Click()
    
    Call Deactivate
    TSeqLen = Len(StrainSeq(0))
    TreeTypeFlag = 0
    tTF = CTF
    CTF = 2
    Picture16.AutoRedraw = True
    Form1.SSPanel1.Caption = "Drawing Tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    Command28.Visible = True

    Call GetOutie
ReDim ETSeqNum(TSeqLen, NextNo)
    For x = 1 To Len(StrainSeq(0))
        For Y = 0 To NextNo
            ETSeqNum(x, Y) = SeqNum(x, Y)
        Next Y
    Next x
    
    F2TreeIndex = 0
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Form1.Refresh

    If DoneTree(2, 0) = 1 Then
        
    Else

        Call NJTree2(2)

        If AbortFlag = 1 Then
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Screen.MousePointer = 0
            Call UpdateF2Prog
            AbortFlag = 0
            Form2.Command2.Enabled = False
            CTF = tTF

            Call Reactivate

            Exit Sub
        End If

    End If

    Picture16.ScaleMode = 3
    'Call NJTree(1)
    Form1.Picture16.ForeColor = 0

    For x = 0 To NextNo
        Form1.Picture16.CurrentX = XCord(2, F2TreeIndex, x)
        Form1.Picture16.CurrentY = YCord(2, F2TreeIndex, x)
        Form1.Picture16.Print (OriginalName(x))
    Next 'X

    Form1.Label14 = "LS tree ignoring recombination"
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Call Reactivate
    
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    
    Picture16.Refresh
    Picture16.Enabled = True
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    Command28.Visible = False
    Erase ETSeqNum
End Sub

Private Sub Man3Seq_Click()
OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual 3Seq Scan"
    Form5.Label4.Caption = "Select one potential recombinant sequence and two potential parental sequences"
    Form5.Label3.Caption = "Selected Parental Sequences"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = True
    Form5.Command5.Enabled = False
    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    TManFlag = 22
    'ot1e = Form1.Timer1.Enabled
    'Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 3
    ManMaxSeqNo = 3

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X

    

    
    
    If RelX > 0 Or RelY > 0 Then
        For x = 0 To NextNo
            Selected(x) = 0
        Next x
        olima = Selected(XoverList(RelX, RelY).MajorP)
        olimi = Selected(XoverList(RelX, RelY).MinorP)
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        OLI = Form5.Combo1.ListIndex
        Form5.Combo1.ListIndex = RelX + 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManBootscanMnu_Click()
    APlot = 0
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual Bootscan"
    Form5.Label4.Caption = "Select one potential recombinant sequence and at least three potential parental and/or outlyer sequences"
    Form5.Label3.Caption = "Selected Parental and/or Outlyer Sequences"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = True
    
        With Form5.Combo1
            OIndex = .ListIndex
            .Clear
            .AddItem "None", 0
    
            For x = 0 To NextNo
            
                .AddItem OriginalName(x), x + 1
            Next 'X
    
            .ListIndex = OIndex
        End With
    
    Form5.Combo1.Visible = True
    Form5.Check1.Visible = True
    Form5.Check1.Caption = "Closest relative scan"
    TManFlag = 3
    Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 4
    ManMaxSeqNo = NextNo + 1
    
    Call PreSelect
    
    'this does the selectinterface
    
    If RefNum > 0 Then
        DDF5C = 1
    End If
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    If RefNum > 0 Then
        DDF5C = 0
    End If
    
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManDistPltMnu_Click()
    APlot = 0
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual Distance Plot"
    Form5.Label4.Caption = "Select one potential recombinant sequence and at least one other sequence"
    Form5.Label3.Caption = "Selected Parental and/or Outlyer Sequence(s)"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = True
    
    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    Form5.Check1.Caption = "Closest relative scan"
    TManFlag = 7
    Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 2
    ManMaxSeqNo = NextNo + 1

    Call PreSelect
    
    'this does the selectinterface
    
    If RefNum > 0 Then
        DDF5C = 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    
    
    If RefNum > 0 Then
        DDF5C = 0
    End If
    
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManGCMnu_Click()
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual GENECONV Scan"
    Form5.Label4.Caption = "Select one potential recombinant sequence and at least two potential parental and/or outlyer sequences"
    Form5.Label3.Caption = "Selected Parental and/or Outlyer Sequences"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = True

    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    TManFlag = 1
    'ot1e = Form1.Timer1.Enabled
    'Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 2
    ManMaxSeqNo = NextNo + 1

    Call PreSelect
    
    'this does the selectinterface
    
    If RefNum > 0 Then
        DDF5C = 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    
    
    
    If RefNum > 0 Then
        DDF5C = 0
    End If
    
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
    
    'Form1.Timer1.Enabled = ot1e
End Sub

Private Sub ManLARDMnu_Click()
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual LARD scan"
    Form5.Label4.Caption = "Select three sequences"
    Form5.Label3.Caption = "Selected Parental and Recombinant Sequences"
    Form5.Check1.Visible = False
    Form5.Label1.Visible = False
    Form5.Combo1.Visible = False
    Form5.Combo1.Clear
    TManFlag = 5
    Form1.Timer1.Enabled = False
    ManPFlag = 0
    ManMinSeqNo = 3
    ManMaxSeqNo = 3
    
    
    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    
    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If RelX > 0 Or RelY > 0 Then
        ReDim Selected(NextNo)
        OLI = Form5.Combo1.ListIndex
        Form5.Combo1.Enabled = True
        'Form5.Combo1.ListIndex = -1 'RelX + 1
        'olima = Selected(XOverList(RelX, RelY).MajorP)
        'olimi = Selected(XOverList(RelX, RelY).MinorP)
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        Selected(XoverList(RelX, RelY).Daughter) = 1
       
        
    End If
    Form5.Combo1.Enabled = True
    If RelX > 0 Or RelY > 0 Then
        For x = 0 To NextNo
            Selected(x) = 0
        Next x
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        Selected(XoverList(RelX, RelY).Daughter) = 1
        
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManMaxChiMnu_Click()
    APlot = 0
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual MaxChi Scan"
    Form5.Label4.Caption = "Select one potential recombinant sequence and at least two potential parental and/or outlyer sequences"
    Form5.Label3.Caption = "Selected Parental and/or Outlyer Sequences"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = True

    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    TManFlag = 4
    Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 3
    ManMaxSeqNo = NextNo + 1
    
    Call PreSelect
    
    'this does the selectinterface
    
    If RefNum > 0 Then
        DDF5C = 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    
    
    If RefNum > 0 Then
        DDF5C = 1
    End If
    
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManPhylProMnu_Click()
    APlot = 0
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual PhylPro Scan"
    Form5.Label4.Caption = "Select at least three sequences"
    Form5.Label3.Caption = "Selected Sequences"
    Form5.Label1.Visible = False

    Form5.Combo1.Visible = False
    Form5.Check1.Visible = False
    TManFlag = 10
    Form1.Timer1.Enabled = False
    ManPFlag = 0
    ManMinSeqNo = 3
    ManMaxSeqNo = NextNo + 1

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If RelX > 0 Or RelY > 0 Then
        For x = 0 To NextNo
            Selected(x) = 0
        Next x
        olima = Selected(XoverList(RelX, RelY).MajorP)
        olimi = Selected(XoverList(RelX, RelY).MinorP)
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        OLI = Form5.Combo1.ListIndex
        Form5.Combo1.ListIndex = RelX + 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub ManRDPMnu_Click()
    OManFlag = ManFlag
End Sub

Private Sub ManSis_Click()
    APlot = 0
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual SiScan"
    Form5.Label4.Caption = "Select either three or four sequences (one potential recombinant sequence, two potential parental sequences and an optional outlyer sequence).  If only three sequences are selected a randomised outlyer sequence will be used."
    Form5.Label3.Caption = "Selected Parental and Recombinant Sequences"
    Form5.Label1.Visible = True
    Form5.Label1 = "Outlyer sequence"

    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    TManFlag = 9
    Form1.Timer1.Enabled = False
    ManPFlag = 0
    ManMinSeqNo = 3
    ManMaxSeqNo = 4

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If RelX > 0 Or RelY > 0 Then
        For x = 0 To NextNo
            Selected(x) = 0
        Next x
        olima = Selected(XoverList(RelX, RelY).MajorP)
        olimi = Selected(XoverList(RelX, RelY).MinorP)
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        OLI = Form5.Combo1.ListIndex
        Form5.Combo1.ListIndex = RelX + 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub


Private Sub ManTOPALMnu_Click()
    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Manual TOPAL scan"
    Form5.Label4.Caption = "Select at least four sequences"
    Form5.Label3.Caption = "Selected Sequences"
    Form5.Check1.Visible = False
    Form5.Label1.Visible = False
    Form5.Combo1.Visible = False
    Form5.Combo1.Clear
    TManFlag = 8
    Form1.Timer1.Enabled = False
    ManPFlag = 0
    ManMinSeqNo = 4
    ManMaxSeqNo = NextNo + 1
    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If RelX > 0 Or RelY > 0 Then
        For x = 0 To NextNo
            Selected(x) = 0
        Next x
        olima = Selected(XoverList(RelX, RelY).MajorP)
        olimi = Selected(XoverList(RelX, RelY).MinorP)
        Selected(XoverList(RelX, RelY).MajorP) = 1
        Selected(XoverList(RelX, RelY).MinorP) = 1
        OLI = Form5.Combo1.ListIndex
        Form5.Combo1.ListIndex = RelX + 1
    End If
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False
End Sub

Private Sub MaskAllMnu_Click()

    For x = 0 To NextNo
        MaskSeq(x) = 1
    Next 'X
    Call PrintNames
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    LastY3 = -1
    
    Form1.UnmaskAllMnu.Visible = True
    Form1.DisableAllMnu.Visible = True
    Form1.MaskAllMnu.Visible = False
    'Form1.InvertMaskMnu.Visible = False
    
End Sub
Public Sub DisableAllMnu_Click()
    
    For x = 0 To NextNo
        MaskSeq(x) = 2
    Next 'X
    
    Call PrintNames
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    LastY3 = -1
    
    Form1.UnmaskAllMnu.Visible = True
    Form1.MaskAllMnu.Visible = True
    'Form1.InvertMaskMnu.Visible = False
    Form1.DisableAllMnu.Visible = False
End Sub



Private Sub MaskAllMnu2_Click()
Call MaskAllMnu_Click
End Sub

Private Sub MatrixOptMnu_Click()
VisFrame = 8
OptFlag = 70
Form3.TabStrip2.Tabs(1).Caption = "Matrix Options"
        

For x = 0 To 14

    If x = VisFrame Then
        Form3.Frame2(x).Visible = True
    Else
        Form3.Frame2(x).Visible = False
    End If

Next 'X
Form3.TabStrip2.Tabs(1).Caption = "Matrix Options"
Form3.TabStrip1.Visible = False


Dim OChk As Byte
OptionsFlag = 1
OChk = NoF3Check2
NoF3Check2 = 1
Form3.Combo1.Enabled = True


Command3.SetFocus
ErrorFlag = 0


SpacerFlagT = SpacerFlag

Call SetF3Vals(1)

If CurMatrixFlag = 0 Then
    Form3.Combo1.ListIndex = 0
ElseIf CurMatrixFlag = 14 Then
    Form3.Combo1.ListIndex = 1
ElseIf CurMatrixFlag = 13 Then
    Form3.Combo1.ListIndex = 2
ElseIf CurMatrixFlag = 12 Then
    Form3.Combo1.ListIndex = 3
ElseIf CurMatrixFlag = 2 Then
    Form3.Combo1.ListIndex = 4
ElseIf CurMatrixFlag = 1 Then
    Form3.Combo1.ListIndex = 5
ElseIf CurMatrixFlag = 3 Then
    Form3.Combo1.ListIndex = 6
ElseIf CurMatrixFlag = 4 Then
    Form3.Combo1.ListIndex = 7
End If
'.Combo1.AddItem "Compaibility matrix (IJ)" 0
'        .Combo1.AddItem "Shimodaira-Hasegawa matrix" 1
'        .Combo1.AddItem "Modularity matrix" 2
'        .Combo1.AddItem "Recombination matrix" 3
'        .Combo1.AddItem "Recombinant region count matrix" 4
'        .Combo1.AddItem "Breakpoint matrix" 5
 
'If CurMatrixFlag = 2 Then
'        UB = (UBound(MatrixM, 1) - 1)'modularity matrix
'ElseIf CurMatrixFlag = 1 Then
'        UB = (UBound(MatrixR, 1) - 1)'recombination matrix
'ElseIf CurMatrixFlag = 0 Then
'        UB = (UBound(MatrixC, 1) - 1)'compatibility matrix
'ElseIf CurMatrixFlag = 3 Then
'        UB = (UBound(MatrixRR, 1) - 1)'recombinant region count matrix
'ElseIf CurMatrixFlag = 4 Then
'        UB = (UBound(MatrixBP, 1) - 1)'breakpoin matrix
'ElseIf CurMatrixFlag = 5 Then'LD matrix
'    UB = UBound(MatrixLD, 1) - 1
'ElseIf CurMatrixFlag = 6 Then'RMin marix
'    UB = UBound(MatrixRMin, 1) - 1
'ElseIf CurMatrixFlag = 7 Then'RMinD
'    UB = UBound(MatrixRMinD, 1) - 1
'ElseIf CurMatrixFlag = 8 Then'Maxchi matrix
'        UB = UBound(MatrixMC, 1) - 1
'ElseIf CurMatrixFlag = 11 Then'Lard Marix
'        UB = UBound(MatrixL, 1) - 1
'ElseIf CurMatrixFlag = 12 Then'Shimiodiara hasegawa
'    UB = UBound(MatrixSH, 2) - 1
'End If

Form2.Enabled = False
DoEvents
Form3.Visible = True
Form3.Command1.SetFocus

NoF3Check2 = OChk
OptionsFlag = 0


End Sub

Private Sub MatrixOptMnu2_Click()
Call MatrixOptMnu_Click
End Sub

Private Sub MatrixSaveMnu_Click()

    With Form1.CommonDialog1
        .FileName = ""
        .DefaultExt = ".bmp"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "BMP File (*.bmp)|*.bmp"
        .Action = 2 'Specify that the "open file" action is required.
        sbmpname$ = .FileName  'Stores selected file name in the
        SBMPnameII = .FileTitle
    End With

    If sbmpname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11

    SavePicture Form1.Picture26.Image, sbmpname$

    Screen.MousePointer = 0
End Sub

Private Sub MaxChiScanMnu_Click()
ConsensusProg = 0
    Call DeactivateScans
    DoScans(0, 3) = 1
    Call Command22_Click

    'doscans(0,0) = ORDP
    'doscans(0,1) = OGC
    'doscans(0,2) = OBS
    'doscans(0,3) = OMC
    'doscans(0,4) = OPP
    'doscans(0,5) = OSS
End Sub

Private Sub MCMatMnu_Click()
If MCMSN = 0 Then
    Call ModSeqNum(0, 0, 1)
End If
If ButtonScrollFlag = 0 And CurMatrixFlag = 8 Then DoneMatX(8) = 0
CurMatrixFlag = 8
Call MCXoverK(0)

Call UnModSeqNum(1)
CurMatrixFlag = 8
Form1.Check1.Enabled = False
Call DoMatCap
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If

Command39(0).Enabled = True
End Sub

Private Sub MCMatMnu2_Click()
Call MCMatMnu2_Click
End Sub

Private Sub MLMnu_Click()
    TSeqLen = Len(StrainSeq(0))
    TreeTypeFlag = 0
    tTF = CTF
    CTF = 3
    Picture16.AutoRedraw = True
    Form1.SSPanel1.Caption = "Drawing Tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    Command28.Visible = True
    
    Call Deactivate
    Call GetOutie

    F2TreeIndex = 0
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Form1.Refresh

    If DoneTree(3, 0) = 1 Then
        
    Else

        Call NJTree2(3)

        If AbortFlag = 1 Then
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Screen.MousePointer = 0
            CTF = tTF
            AbortFlag = 0
            Form2.Command2.Enabled = False

            Call Reactivate

            Exit Sub
        End If

    End If

     'Call NJTree(1)
    Picture16.ScaleMode = 3
    Form1.Picture16.ForeColor = 0

    For x = 0 To NextNo
        'If X <> Seq1 And X <> Seq2 And X <> Seq3 Then
        Form1.Picture16.CurrentX = XCord(3, F2TreeIndex, x)
        Form1.Picture16.CurrentY = YCord(3, F2TreeIndex, x)
        Form1.Picture16.Print (OriginalName(x))
        'End If
    Next 'X
    
    Dim TMX As String
    Call GetModelString(TMX)
    Form1.Label14 = "ML " + TMX + " tree ignoring recombination"
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Call Reactivate

    
    Picture16.Refresh
    Picture16.Enabled = True
    If RelX > 0 Or RelY > 0 Then
        DoTreeColour Picture16, CTF, TreeTypeFlag
    End If
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    'Picture17.Enabled = True
    Command28.Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
End Sub

Private Sub MLMnuAL2_Click()
If SEventNumber = 0 Then
    Call Command22_Click
    Screen.MousePointer = 11
    Call Deactivate
    If SEventNumber > 0 Then
        Call DrawML7(Form1.Picture16)
    Else
        If CLine = "" Or CLine = " " Then
            MsgBox ("There were no detectable recombination events in this alignment")
        End If
    End If
Else
    Call Deactivate
    Screen.MousePointer = 11
    Call DrawML7(Form1.Picture16)
    
End If
Call Reactivate
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
Screen.MousePointer = 0
End Sub

Private Sub MLMnuAR_Click()
If SEventNumber = 0 Then
    Call Command22_Click
    Call Deactivate
    If SEventNumber > 0 Then
        Call DrawML6(Form1.Picture16, 4)
    Else
        If CLine = "" Or CLine = " " Then
            MsgBox ("There were no detectable recombination events in this alignment")
        End If
    End If
Else
    Call Deactivate
    Call DrawML6(Form1.Picture16, 4)
    
End If
Call Reactivate
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub ModMatMnu_Click()
If ButtonScrollFlag = 0 And CurMatrixFlag = 2 Then DoneMatX(1) = 0
CurMatrixFlag = 2
Call DrawRecMatrix(1)
CurMatrixFlag = 2
Form1.Check1.Enabled = False
Call DoMatCap
SSPanel6(2).Enabled = True
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If
If MatZoom(CurMatrixFlag) > 1 Then
    Command39(0).Enabled = True
End If
End Sub

Private Sub ModMatMnu2_Click()
Call ModMatMnu_Click
Form1.SSPanel6(2).Enabled = True
End Sub

Private Sub NJMnu_Click()
    SS = Abs(GetTickCount)
    TSeqLen = Len(StrainSeq(0))
    tTF = CTF
    CTF = 1
    TreeTypeFlag = 0
    TreeImage(TreeTypeFlag) = 1
    Picture16.AutoRedraw = True
    Form1.SSPanel1.Caption = "Drawing Tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    Command28.Visible = True

    Call Deactivate
    Call GetOutie

    F2TreeIndex = 0
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Form1.Refresh

    ReDim ETSeqNum(TSeqLen, NextNo)
    For x = 1 To Len(StrainSeq(0))
        For Y = 0 To NextNo
            ETSeqNum(x, Y) = SeqNum(x, Y)
        Next Y
    Next x
    

    
    If DoneTree(1, 0) = 1 And x = 12345 Then
        
    Else

        Call NJTree2(1)

        If AbortFlag = 1 Then
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            
            Screen.MousePointer = 0
            AbortFlag = 0
            CTF = tTF
            Form2.Command2.Enabled = False

            Call Reactivate

            Exit Sub
        End If

    End If

    
    Form1.Label14 = "NJ tree ignoring recombination"
    Form1.ProgressBar1.Value = 100
    Command28.Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    Call Reactivate

    Picture16.Enabled = True
    If RelX > 0 Or RelY > 0 Then
        DoTreeColour Picture16, CTF, TreeTypeFlag
    End If
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    Erase ETSeqNum
    
End Sub

Private Sub PABPMnu_Click()
If DontSaveUndo = 0 Then
    Call SaveUndo
End If
Dim RL As Long, LS As Long, BPos As Long, Epos As Long
Dim EV As Long, oRelX As Long, oRelY As Long
oRelX = RelX
oRelY = RelY
Call UnModNextno
If NewBP(0) < NewBP(1) Then
    If NewBP(1) - NewBP(0) < Len(StrainSeq(0)) / 2 Or CircularFlag = 0 Then
        BPos = NewBP(0)
        Epos = NewBP(1)
    Else
        BPos = NewBP(1)
        Epos = NewBP(0)
    End If
Else
    If NewBP(0) - NewBP(1) < Len(StrainSeq(0)) / 2 Or CircularFlag = 0 Then
        BPos = NewBP(1)
        Epos = NewBP(0)
    Else
        BPos = NewBP(0)
        Epos = NewBP(1)
    End If
End If
EV = SuperEventList(XoverList(RelX, RelY).Eventnumber)
For RelX = 0 To NextNo
    For RelY = 1 To CurrentXOver(RelX)
        If SuperEventList(XoverList(RelX, RelY).Eventnumber) = EV Then
            XoverList(RelX, RelY).Ending = Epos
            XoverList(RelX, RelY).Beginning = BPos
                
            'check to see if the new BP pos is close to misssing data
            Call DoEnds(2)
        End If
    Next RelY
Next RelX

RelX = oRelX
RelY = oRelY
'XX = exRely

If XoverList(RelX, RelY).Accept = 1 Then
    AcceptChangeFlag = 2
    Form1.Command10.Enabled = True
   
    
ElseIf AcceptChangeFlag = 0 Then
    AcceptChangeFlag = 1
End If

GoOn = RedoBreakpoints(1)

Call IntegrateXOvers(0)
PermXVal = 0: PermYVal = 0
Timer1.Enabled = False
UpdateIDFlag = 1
Dim inRelX As Long, inRelY As Long
inRelX = RelX: inRelY = RelY
Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
If inRelX <> RelX Or inRelY <> RelY Then
    Call IntegrateXOvers(0)
    UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
End If


If RIMode = 0 Then
    Call MakeRecombinationInfo(RelX, RelY)
End If
UpdateIDFlag = 0

Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
Screen.MousePointer = 0

Timer1.Enabled = True

End Sub

Private Sub PBPMnu3_Click()

Call UnModNextno
If NewBP(0) < NewBP(1) Then
    If NewBP(1) - NewBP(0) < Len(StrainSeq(0)) / 2 Or CircularFlag = 0 Then
        BPos = NewBP(0)
        Epos = NewBP(1)
    Else
        BPos = NewBP(1)
        Epos = NewBP(0)
    End If
Else
    If NewBP(0) - NewBP(1) < Len(StrainSeq(0)) / 2 Or CircularFlag = 0 Then
        BPos = NewBP(1)
        Epos = NewBP(0)
    Else
        BPos = NewBP(0)
        Epos = NewBP(1)
    End If
End If

XoverList(RelX, RelY).Ending = Epos
XoverList(RelX, RelY).Beginning = BPos


GoOn = RedoBreakpoints(1)




Call DoEnds(2)

If XoverList(RelX, RelY).Accept = 1 Then
    AcceptChangeFlag = 2
    Form1.Command10.Enabled = True
    
ElseIf AcceptChangeFlag = 0 Then
    AcceptChangeFlag = 1
End If


Call IntegrateXOvers(0)
PermXVal = 0: PermYVal = 0
Timer1.Enabled = False



UpdateIDFlag = 1


Dim inRelX As Long, inRelY As Long
inRelX = RelX: inRelY = RelY
Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
If inRelX <> RelX Or inRelY <> RelY Then
    Call IntegrateXOvers(0)
    UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
End If

'Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
If RIMode = 0 Then
    Call MakeRecombinationInfo(RelX, RelY)
End If
UpdateIDFlag = 0



Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
Screen.MousePointer = 0


Timer1.Enabled = True

End Sub

Private Sub Picture1_Click()
'Form1.ZOrder

For x = 1 To FlashntNum
    If Flashnt(2, x) > 500 Then Flashnt(2, x) = 800
    
Next x

End Sub

Private Sub Picture1_KeyDown(KeyCode As Integer, Shift As Integer)
Call DoKeydown(KeyCode)
If KeyCode = vbKeyPageUp Or KeyCode = vbKeyLeft Or (KeyCode = vbKeyUp And F1P1X = -1 And F1P6Y = -1) Then 'Or KeyCode = vbKeyUp
    Call GoToPreviousEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeyPageDown Or KeyCode = vbKeyRight Or (KeyCode = vbKeyDown And F1P1X = -1 And F1P6Y = -1) Then
    Call GoToNextEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeySpace Then
    Call GoToBestMnu_Click

End If

'If Form1.Picture6.Enabled = True Then
'    Form1.Picture6.SetFocus
'End If
End Sub

Private Sub Picture1_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Picture3.Refresh
    Picture2.Refresh
PermSPos = SPSPos

    Dim MaxNameLen As Integer, TempLen() As Long
    Form1.ZOrder
    If Button = 2 Then
        
        If ShowSeqFlag = 1 Then
            If RelX > 0 Or RelY > 0 Then
                PlaceABBPMnu.Visible = True
                PlaceAEBPMnu.Visible = True
            Else
                PlaceABBPMnu.Visible = False
                PlaceAEBPMnu.Visible = False
            End If
        Else
            x = x
            If RelX > 0 Or RelY > 0 Then
                PlaceABBPMnu.Visible = True
                PlaceAEBPMnu.Visible = True
            Else
                PlaceABBPMnu.Visible = False
                PlaceAEBPMnu.Visible = False
            End If
            'PlaceBBPMnu.Visible = False
            'PlaceEBPMnu.Visible = False
        End If
        
        If RunFlag = 1 Then
            SaveARRRMnu.Enabled = True
            SaveARSRMnu.Enabled = True
            'SaveARCRMnu.Enabled = True
            
            If NextnoBak <= NextNo Then
                SaveARRSMnu.Enabled = True
                SplitAliMnu.Enabled = True
                VertAlignSplitMnu.Enabled = True
            Else
                SaveARRSMnu.Enabled = False
                SplitAliMnu.Enabled = False
                VertAlignSplitMnu.Enabled = False
            End If
        Else
            SaveARRRMnu.Enabled = False
            SaveARSRMnu.Enabled = False
            'SaveARCRMnu.Enabled = False
            SplitAliMnu.Enabled = False
            VertAlignSplitMnu.Enabled = False
            SaveARRSMnu.Enabled = False
        End If
        For x = 0 To NextNo
        
            If MaskSeq(x) > 0 Then Exit For
            
        Next x
        
        If x <= NextNo Then
            SaveDisMnu.Enabled = True
            SaveEnMnu.Enabled = True
        Else
        
            SaveDisMnu.Enabled = False
            SaveEnMnu.Enabled = False
        End If
        FindSeqmnu4.Caption = "Find Sequence"
        PlaceABBPMnu.Caption = "Place beginning breakpoint here"
        
        'PlaceAEBPMnu.Visible = True
        'PlaceABBPMnu.Visible = True
        FindSeqmnu4.Visible = True
        
        Form1.PopupMenu SeqMnu
        '    SaveBMPFlag = 3
        '   Form1.PopupMenu SchemMnu
    ElseIf Button = 1 Then
        P1MDStart = Abs(GetTickCount)
        If ShowSeqFlag = 0 Then
            Form1.ScaleMode = 3
            If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                Picture12.Height = 15 * SeqColCatNum * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = 87 * (14 / Screen.TwipsPerPixelX)
            Else
                Picture12.Height = (15 * SeqColCatNum + 22) * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = 220 * (14 / Screen.TwipsPerPixelX)
            End If
            
            Picture12.ZOrder
            
            
            Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
            If Picture12.Top < 0 Then Picture12.Top = 0
            Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
            
            Picture12.Picture = LoadPicture()
            Picture12.AutoRedraw = True
            
            For Z = 0 To SeqColCatNum
            
                Picture12.Line (50, Z * 200 + 50)-(200, Z * 200 + 200), ColX(Z), BF
            
            Next Z
'            Picture12.Line (50, 250)-(200, 400), RGB(128, 128, 255), BF
'            Picture12.Line (50, 450)-(200, 600), RGB(255, 128, 128), BF
'            Picture12.Line (50, 650)-(200, 800), RGB(255, 0, 0), BF
'            Picture12.Line (50, 850)-(200, 1000), RGB(128, 0, 0), BF
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                Picture12.Line (50, (SeqColCatNum + 1) * 200 + 50)-(200, (SeqColCatNum + 1) * 200 + 200), RGB(64, 128, 64), BF
            End If
            'Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
            'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
            Dim OutString As String
            
            Picture12.ForeColor = RGB(150, 150, 150)
            Picture12.CurrentX = 250 + 14
            Picture12.CurrentY = 50 + 14
            Picture12.Print " 100% Identity"
            
            For Z = 1 To SeqColCatNum - 1
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + (200 * Z) + 14
                OutString = Trim(Str(Int(100 - (Z / SeqColCatNum) * 100)))
                OutString = "> " + OutString + "% identity"
                Picture12.Print OutString
            Next Z
            
            
            Picture12.CurrentX = 250 + 14
            Picture12.CurrentY = 50 + (200 * Z) + 14
            OutString = Trim(Str(Int(100 - ((SeqColCatNum - 1) / SeqColCatNum) * 100)))
            OutString = "< " + OutString + "% identity"
            Picture12.Print OutString
            
'            Picture12.CurrentX = 250 + 14
'            Picture12.CurrentY = 250 + 14
'            Picture12.Print "> 75% Identity"
'            Picture12.CurrentX = 250 + 14
'            Picture12.CurrentY = 450 + 14
'            Picture12.Print "> 50% Identity"
'            Picture12.CurrentX = 250 + 14
'            Picture12.CurrentY = 650 + 14
'            Picture12.Print "> 25% Identity"
'            Picture12.CurrentX = 250 + 14
'            Picture12.CurrentY = 850 + 14
'            Picture12.Print "< 25% Identity"
           
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + (200 * (SeqColCatNum + 1)) + 14
                Picture12.Print "Sites ignored due to sequence compression"
            End If
            
            Picture12.ForeColor = RGB(0, 0, 0)
            Picture12.CurrentX = 250
            Picture12.CurrentY = 50
            Picture12.Print " 100% Identity"
            
            For Z = 1 To SeqColCatNum - 1
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50 + (200 * Z)
                OutString = Trim(Str(Int(100 - (Z / SeqColCatNum) * 100)))
                OutString = "> " + OutString + "% identity"
                Picture12.Print OutString
            Next Z
            
            
            Picture12.CurrentX = 250
            Picture12.CurrentY = 50 + (200 * Z)
            OutString = Trim(Str(Int(100 - ((SeqColCatNum - 1) / SeqColCatNum) * 100)))
            OutString = "< " + OutString + "% identity"
            Picture12.Print OutString
            
            
'            Picture12.ForeColor = 0
'            Picture12.CurrentX = 250
'            Picture12.CurrentY = 50
'            Picture12.Print " 100% Identity"
'            Picture12.CurrentX = 250
'            Picture12.CurrentY = 250
'            Picture12.Print "> 75% Identity"
'            Picture12.CurrentX = 250
'            Picture12.CurrentY = 450
'            Picture12.Print "> 50% Identity"
'            Picture12.CurrentX = 250
'            Picture12.CurrentY = 650
'            Picture12.Print "> 25% Identity"
'            Picture12.CurrentX = 250
'            Picture12.CurrentY = 850
'            Picture12.Print "< 25% Identity"
            
            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50 + (200 * (SeqColCatNum + 1))
                Picture12.Print "Sites ignored due to sequence compression"
            End If
            'Picture12.Visible = True
        ElseIf ShowSeqFlag = 1 Then

            If (XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 3) And MCTripletFlag = 1 Then
                Form1.ScaleMode = 3
                Picture12.Height = 46 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = 110 * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), mPurple, BF
                Picture12.Line (50, 250)-(200, 400), Yellow, BF
                Picture12.Line (50, 450)-(200, 600), RGB(64, 64, 64), BF
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Identical sites"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Non-identical sites"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Ignored Sites"
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Identical sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Non-identical sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Ignored Sites"
                'Picture12.Visible = True
            ElseIf XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 6 Then
                Form1.ScaleMode = 3
                TW = Picture1.TextWidth(OriginalName(Seq3))
                Picture12.Height = 46 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = (120 + TW) * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), mPurple, BF
                Picture12.Line (50, 250)-(200, 400), Yellow, BF
                Picture12.Line (50, 450)-(200, 600), RGB(64, 64, 64), BF
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Sites identical to " & OriginalName(Seq3)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Sites not identical to " & OriginalName(Seq3)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Ignored Sites"
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Sites identical to " & OriginalName(Seq3)
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Sites not identical to " & OriginalName(Seq3)
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Ignored Sites"
                'Picture12.Visible = True
            ElseIf (XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 5) Then
                ReDim TempLen(2)
                TempLen(0) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))
                TempLen(1) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MajorP))
                TempLen(2) = Len(OriginalName(XoverList(RelX, RelY).MajorP)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))

                For Z = 0 To 2

                    If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                Next 'Z

                'MaxNameLen = 0
                Form1.ScaleMode = 3
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.Height = 125 * (15 / Screen.TwipsPerPixelY)
                Else
                    Picture12.Height = 114 * (15 / Screen.TwipsPerPixelY)
                End If
                Picture12.Width = (210 + MaxNameLen * 6) * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), Purple, BF
                Picture12.Line (50, 250)-(200, 400), mPurple, BF
                Picture12.Line (50, 450)-(200, 600), Green, BF
                Picture12.Line (50, 650)-(200, 800), mGreen, BF
                Picture12.Line (50, 850)-(200, 1000), Yellow, BF
                Picture12.Line (50, 1050)-(200, 1200), mYellow, BF
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.Line (50, 1250)-(200, 1400), PltCol3(11), BF
                    Picture12.Line (50, 1450)-(200, 1600), HalfColour, BF
                    Picture12.Line (50, 1650)-(200, 1800), RGB(64, 64, 64), BF
                Else
                    Picture12.Line (50, 1250)-(200, 1400), HalfColour, BF
                    Picture12.Line (50, 1450)-(200, 1600), RGB(64, 64, 64), BF
                End If
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 650 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 850 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 1050 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 1250 + 14
                
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1250 + 14
                    Picture12.Print "Sites contributing to all highlighted plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1450 + 14
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1650 + 14
                    Picture12.Print "Ignored Sites"
                Else
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1250 + 14
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1450 + 14
                    Picture12.Print "Ignored Sites"
                End If
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"

                'Picture12.Print "Sites contributing to  -  plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 650
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plots"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 850
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 1050
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1250
                    Picture12.Print "Sites contributing to all highlighted plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1450
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1650
                    Picture12.Print "Ignored Sites"
                Else
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1250
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1450
                    Picture12.Print "Ignored Sites"
                End If
                'Picture12.Visible = True
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                ReDim TempLen(2)
                TempLen(0) = 20 + Len(OriginalName(XoverList(RelX, RelY).MinorP))
                TempLen(1) = 20 + Len(OriginalName(XoverList(RelX, RelY).MajorP))
                TempLen(2) = 32

                For Z = 0 To 2

                    If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                Next 'Z

                'MaxNameLen = 0
                Form1.ScaleMode = 3
                MaxNameLen = MaxNameLen + 3
                Picture12.Height = 58 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = (Picture12.TextWidth("O") / Screen.TwipsPerPixelX) * MaxNameLen '(135 + MaxNameLen * 6) * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), mPurple, BF
                Picture12.Line (50, 250)-(200, 400), mGreen, BF
                Picture12.Line (50, 450)-(200, 600), mYellow, BF
                Picture12.Line (50, 650)-(200, 800), RGB(64, 64, 64), BF
                'Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
                'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MinorP)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MajorP)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Sites different to both 'parents'"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 650 + 14
                Picture12.Print "Ignored Sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.ForeColor = RGB(0, 0, 0)
                Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MinorP)
                'Picture12.Print "Sites contributing to  -  plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MajorP)
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Sites different to both 'parents'"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 650
                Picture12.Print "Ignored Sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 850
                
                'Picture12.Visible = True
            ElseIf ((XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum) Or ((XoverList(RelX, RelY).ProgramFlag <> 1 Or XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum) And pGCTripletflag = 1)) Then
                ReDim TempLen(2)
                TempLen(0) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))
                TempLen(1) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MajorP))
                TempLen(2) = Len(OriginalName(XoverList(RelX, RelY).MajorP)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))

                For Z = 0 To 2

                    If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                Next 'Z

                'MaxNameLen = 0
                Form1.ScaleMode = 3
                MaxNameLen = MaxNameLen + 3
                Picture12.Height = 58 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = (135 + MaxNameLen * 6) * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), mPurple, BF
                Picture12.Line (50, 250)-(200, 400), mGreen, BF
                Picture12.Line (50, 450)-(200, 600), mYellow, BF
                Picture12.Line (50, 650)-(200, 800), RGB(64, 64, 64), BF
                'Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
                'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 650 + 14
                Picture12.Print "Ignored Sites"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 850 + 14
                Picture12.Print "Chimaera"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 1050 + 14
                Picture12.Print "SiScan"
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                'Picture12.Print "Sites contributing to  -  plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 650
                Picture12.Print "Ignored Sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 850
                Picture12.Print "Chimaera"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 1050
                Picture12.Print "SiScan"
                'Picture12.Visible = True
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then

                If GCIndelFlag = 1 Then
                    Form1.ScaleMode = 3
                    Picture12.Height = 74 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = 120 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), LPurple, BF
                    Picture12.Line (50, 450)-(200, 600), Yellow, BF
                    Picture12.Line (50, 650)-(200, 800), mYellow, BF
                    Picture12.Line (50, 850)-(200, 1000), RGB(64, 64, 64), BF
                    'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Concordant indel blocs"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 650 + 14
                    Picture12.Print "Discordant indel blocs"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 850 + 14
                    Picture12.Print "Ignored sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1050 + 14
                    Picture12.Print "SiScan"
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.Print "Concordant sites"
                    'Picture12.Print "Sites contributing to  -  plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Concordant indel blocs"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 650
                    Picture12.Print "Discordant indel blocs"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 850
                    Picture12.Print "Ignored sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1050
                    Picture12.Print "SiScan"
                    'Picture12.Visible = True
                
                Else
                    Form1.ScaleMode = 3
                    Picture12.Height = 47 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = 95 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), Yellow, BF
                    Picture12.Line (50, 450)-(200, 600), RGB(64, 64, 64), BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Ignored sites"
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Ignored sites"
                    'Picture12.Visible = True
                End If

            End If

        ElseIf ShowSeqFlag = 2 Then

            If (XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 3) And MCTripletFlag = 1 Then
                Form1.ScaleMode = 3
                Picture12.Height = 34 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = 100 * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), mPurple, BF
                Picture12.Line (50, 250)-(200, 400), Yellow, BF
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Identical sites"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Non-identical sites"
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Identical sites"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Non-identical sites"
                'Picture12.Visible = True
            ElseIf (XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 5) Then
                ReDim TempLen(2)
                TempLen(0) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))
                TempLen(1) = Len(OriginalName(XoverList(RelX, RelY).Daughter)) + Len(OriginalName(XoverList(RelX, RelY).MajorP))
                TempLen(2) = Len(OriginalName(XoverList(RelX, RelY).MajorP)) + Len(OriginalName(XoverList(RelX, RelY).MinorP))

                For Z = 0 To 2

                    If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                Next 'Z

                'MaxNameLen = 0
                Form1.ScaleMode = 3
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.Height = 112 * (15 / Screen.TwipsPerPixelY)
                Else
                    Picture12.Height = 98 * (15 / Screen.TwipsPerPixelY)
                End If
                Picture12.Width = (210 + MaxNameLen * 6) * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                If Picture12.Top < 0 Then Picture12.Top = 0
                Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                Picture12.Line (50, 50)-(200, 200), Purple, BF
                Picture12.Line (50, 250)-(200, 400), mPurple, BF
                Picture12.Line (50, 450)-(200, 600), Green, BF
                Picture12.Line (50, 650)-(200, 800), mGreen, BF
                Picture12.Line (50, 850)-(200, 1000), Yellow, BF
                Picture12.Line (50, 1050)-(200, 1200), mYellow, BF
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.Line (50, 1250)-(200, 1400), PltCol3(11), BF
                    Picture12.Line (50, 1450)-(200, 1600), HalfColour, BF
                    Picture12.Line (50, 1650)-(200, 1800), RGB(64, 64, 64), BF
                Else
                    Picture12.Line (50, 1250)-(200, 1400), HalfColour, BF
                    Picture12.Line (50, 1450)-(200, 1600), RGB(64, 64, 64), BF
                End If
                Picture12.ForeColor = RGB(150, 150, 150)
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 250 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 450 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 650 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 850 + 14
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 1050 + 14
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 1250 + 14
                
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1250 + 14
                    Picture12.Print "Sites contributing to all highlighted plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1450 + 14
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1650 + 14
                    Picture12.Print "Ignored Sites"
                Else
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1250 + 14
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1450 + 14
                    Picture12.Print "Ignored Sites"
                End If
                Picture12.ForeColor = 0
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"

                'Picture12.Print "Sites contributing to  -  plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 250
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 450
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 650
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plots"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 850
                Picture12.Print "Sites contributing to highlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                Picture12.CurrentX = 250
                Picture12.CurrentY = 1050
                Picture12.Print "Sites contributing to unhighlighted " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plots"
                If XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1250
                    Picture12.Print "Sites contributing to all highlighted plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1450
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1650
                    Picture12.Print "Ignored Sites"
                Else
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1250
                    Picture12.Print "Sites contributing to greyed outed plots"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1450
                    Picture12.Print "Ignored Sites"
                End If
                'Picture12.Visible = True
            
            ElseIf XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                If XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                    ReDim TempLen(2)
                    TempLen(0) = 20 + Len(OriginalName(XoverList(RelX, RelY).MinorP))
                    TempLen(1) = 20 + Len(OriginalName(XoverList(RelX, RelY).MajorP))
                    TempLen(2) = 32

                    For Z = 0 To 2
    
                        If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                    Next 'Z
    
                    'MaxNameLen = 0
                    Form1.ScaleMode = 3
                    Picture12.Height = 47 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = (Picture12.TextWidth("O") / Screen.TwipsPerPixelX) * MaxNameLen '(135 + MaxNameLen * 6) * (14 / Screen.TwipsPerPixelX)
                
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), mGreen, BF
                    Picture12.Line (50, 450)-(200, 600), mYellow, BF
                    'Picture12.Line (50, 650)-(200, 800), RGB(64, 64, 64), BF
                    'Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
                    'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MinorP)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MajorP)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Sites different to both 'parents'"
                    'Picture12.Print "Sites contributing to  -  plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.ForeColor = RGB(0, 0, 0)
                    Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MinorP)
                    'Picture12.Print "Sites contributing to  -  plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Sites identical to " + OriginalName(XoverList(RelX, RelY).MajorP)
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Sites different to both 'parents'"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 850
                    
                    'Picture12.Visible = True
                Else
                
                    ReDim TempLen(2)
                    TempLen(0) = Picture12.TextWidth(OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP))
                    TempLen(1) = Picture12.TextWidth(OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP))
                    TempLen(2) = Picture12.TextWidth(OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP))
    
                    For Z = 0 To 2
    
                        If TempLen(Z) > MaxNameLen Then MaxNameLen = TempLen(Z)
                    Next 'Z
    
                    'MaxNameLen = 0
                    Form1.ScaleMode = 3
                    Picture12.Height = 47 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = (135 + MaxNameLen / Screen.TwipsPerPixelX) ' * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), mGreen, BF
                    Picture12.Line (50, 450)-(200, 600), mYellow, BF
                    'Picture12.Line (50, 650)-(200, 800), RGB(64, 64, 64), BF
                    'Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
                    'Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                    'Picture12.Print "Sites contributing to  -  plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).Daughter) + " - " + OriginalName(XoverList(RelX, RelY).MajorP) + " plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Sites contributing to " + OriginalName(XoverList(RelX, RelY).MajorP) + " - " + OriginalName(XoverList(RelX, RelY).MinorP) + " plot"
                    'Picture12.Visible = True
                End If
            ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then

                If GCIndelFlag = 1 Then
                    Form1.ScaleMode = 3
                    Picture12.Height = 60 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = 120 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), LPurple, BF
                    Picture12.Line (50, 450)-(200, 600), Yellow, BF
                    Picture12.Line (50, 650)-(200, 800), mYellow, BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Concordant indel blocs"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 650 + 14
                    Picture12.Print "Discordant indel blocs"
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.Print "Concordant sites"
                    'Picture12.Print "Sites contributing to  -  plot"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Concordant indel blocs"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Discordant sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 650
                    Picture12.Print "Discordant indel blocs"
                    'Picture12.Visible = True
                Else
                    Form1.ScaleMode = 3
                    Picture12.Height = 34 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = 95 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = Y + SSPanel3.Top + (Picture9.Top) / Screen.TwipsPerPixelY + 5 - Picture12.Height + Picture1.Top
                    If Picture12.Top < 0 Then Picture12.Top = 0
                    Picture12.Left = x + SSPanel3.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), mPurple, BF
                    Picture12.Line (50, 250)-(200, 400), Yellow, BF
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "Discordant sites"
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    Picture12.Print "Concordant sites"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "Discordant sites"
                    'Picture12.Visible = True
                End If

            End If

        End If

    End If

End Sub

Private Sub Picture1_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)

RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Dim TV1 As Variant, TV2 As Variant, FF As Long, oDirX As String, Spos As Long, ntPos As Long, LenTXT As Integer, HiTxt As Integer, TPosX As Integer, TPosY As Integer, CSeq As Long, VSV, PermX As Single, PermY As Single
PermY = Y
PermX = x
'For x = 0 To NextNo
'    If OriginalPos(x) = 6147 Then
'        x = x
'    End If
'Next x
'For x = 0 To NextNo
'    If x = 1117 Then
'        x = x
'    End If
'    For Y = 1 To CurrentXOver(x)
'        XX = SuperEventList(XOverList(x, Y).Eventnumber) '2,19,66
'    Next Y
'Next x
'Form1.Timer4.Interval = 30
P1MMStillGoing = P1MMStillGoing + 1
If P1MMStillGoing > 1000 Then
    P1MMStillGoing = P1MMStillGoing - 1
    Exit Sub
End If
HSCrollInc = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If

'XX = Picture1.AutoRedraw
Curgene = 0
VSV = VScroll3.Value / ScrollSF
Y = Y + VSV
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
'XX = GetForegroundWindow
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
If Form1.ProgressBar1.Value > 0 Then
    P1MMStillGoing = P1MMStillGoing - 1
    Exit Sub
End If
Picture3.Refresh
        Picture2.Refresh
    If RunFlag = 1 Or ManFlag >= 0 Then
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
        
    End If
F1P1X = x
F1P1Y = Y - VSV
    '(XOverList(RecSeq, PAVal).Beginning - SeqSpaces(XOverList(RecSeq, PAVal).Beginning, RecSeq))

If DebuggingFlag < 2 Then On Error Resume Next
On Error Resume Next
If Screen.ActiveForm.Name = "Form1" Then
'If Screen.ActiveForm Then
    Picture1.SetFocus
End If
On Error GoTo 0

Dim tTYF As Double, TYFM As Integer
Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)

LenTXT = Picture1.TextWidth("A")
HiTxt = Picture1.TextHeight("A")

TPosX = Int(x / LenTXT) + 1 'Int(((X / 8 / tTYF) + 1) / XConA) '/ tTYF
TPosY = (Int(Y / 13 / (tTYF * ttyfAdjust))) ' / tTYF

ntPos = 0
CSeq = -1

F2P2Y = -1
F1P7X = -1
F1P2Y = -1
F1P3Y = -1
F1P6Y = -1
F2P3Y = -1
F1P16Y = -1
F1P26Y = -1
F2P2Index = -1
If ShowSeqFlag = 0 Then
    If TPosX - WinLeft <= Decompress(Len(StrainSeq(0))) Then
        CSeq = TPosY
        Spos = WinLeft + TPosX - 1
        P1NT = Spos
        P1Seq = CSeq
        SPSPos = Spos
    End If
    'Picture2.Picture = LoadPicture()
    'Picture2.CurrentY = 0
    'Picture2.Print CSeq
ElseIf ShowSeqFlag = 1 Then
    Spos = WinLeft + TPosX - 1
    SPSPos = Spos
    P1NT = Spos
    If TPosY <= UBound(SDisplaySeq, 1) Then
        CSeq = SDisplaySeq(TPosY)
    Else
        CSeq = -1
    End If
'    If XOverlist(RelX, RelY).ProgramFlag = 1 Or XOverlist(RelX, RelY).ProgramFlag = 1 + AddNum Then
'        CSeq = XX
'        If Seq1 <> Seq2 Then
'            If TPosY = 0 Then
'                CSeq = Seq1
'            ElseIf TPosY = 1 Then
'                CSeq = Seq2
'            End If
'        Else
'            If TPosY = 0 Then
'                CSeq = Seq1
'            End If
'        End If
'    ElseIf (XOverlist(RelX, RelY).ProgramFlag = 3 Or XOverlist(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
'        If TPosY = 0 Then
'            CSeq = Seq1
'        ElseIf TPosY = 1 Then
'            CSeq = Seq2
'        End If
'    Else
'        If TPosY = 0 Then
'            CSeq = Seq1
'        ElseIf TPosY = 1 Then
'            CSeq = Seq3
'        ElseIf TPosY = 2 Then
'            CSeq = Seq2
'        End If
'    End If
Else

End If
If CSeq > -1 And CSeq <= PermNextno And CSeq <= NextNo Then 'And Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
    If Spos > 0 And Spos <= UBound(Recompress, 1) Then
        If Recompress(Spos) <> Recompress(Spos - 1) Then
            
            
            
        Else
            'Picture1.Refresh
            'Picture1.ToolTipText = "Actual nucleotide position in " & OriginalName(CSeq) & " unknown due to sequence compression"
        End If
        If SeqSpacesInFileFlag = 0 Then
            If Recompress(Spos) <= UBound(SeqSpaces, 1) And CSeq <= UBound(SeqSpaces, 2) Then
                ntPos = (Spos - SeqSpaces(Recompress(Spos), CSeq))
            Else
                ntPos = 0
            End If
        Else
            
            '*********************
            'SeqSpaces single value read from file
            '*********************8
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Dim OS1 As Long, SSX As Long
'            SS = Abs(GetTickCount)
            OS1 = CSeq * (Len(StrainSeq(0)) + 3)
            Open "RDP5SSFile" + UFTag For Binary As #FF
            'ssx = SeqSpaces(recompress(spos),cseq)
            If ((((Recompress(Spos) + OS1) - 1) * 4) + 1) > -1 Then
                Get #FF, ((((Recompress(Spos) + OS1) - 1) * 4) + 1), SSX
            End If
            'Get #FF, 5, SSX
            'SSVal(1) = SeqSpaces(bb1, RecSeq)
            
            Close #FF
'            EE = Abs(GetTickCount)
'            TT = EE - SS
'            x = x
            ChDrive oDirX
            ChDir oDirX
            
            
            ntPos = Spos - SSX
            x = x
        End If
        Picture1.ScaleMode = 3
        If GeneSEFlash = 0 Or x = x Then
            If ntPos > 0 And (TPosX <> ltPosX Or TPosY <> ltPosY) Then
                If ShowSeqFlag = 0 Then
                    LenTXT = Picture1.TextWidth("A")
                    HiTxt = Picture1.TextHeight("A")
                    'Picture1.Refresh
                    Dim Rnt As Byte, Gnt As Byte, Bnt As Byte
                    GoOn = 1
                    
                    For x = 1 To FlashntNum
                        If Flashnt(2, x) = 1000 Then Flashnt(2, x) = 900
                        If Flashnt(0, x) = Spos And Flashnt(1, x) = CSeq Then
                            GoOn = 0
                            If Flashnt(2, x) > 500 Then
                                For Y = 1 To FlashntNum
                                    If Flashnt(2, Y) > 500 Then Flashnt(2, Y) = 800
                                Next Y
                            End If
                            
                            Flashnt(2, x) = 80
                            Call ConvertLongToRGB(ColX(SeqColRef2(Recompress(Spos))), Rnt, Gnt, Bnt)
                            'Flashnt(3, X) = RGB(Rnt + (255 - Rnt) / 1.2, Gnt + (255 - Gnt) / 1.2, Bnt + (255 - Bnt) / 1.2)
                            'Flashnt(4, X) = Flashnt(3, X)
                            Flashnt(3, x) = RGB(255, 255, 0)
                            'Flashnt(5, X) = RGB(255, 255, 0)
                            DontFade = x
                            
                        End If
                    Next x
                    If GoOn = 1 Then
                        Dim ColHolder As Long, MV As Long, CV As Long, X1 As Long, X2 As Long, X3 As Long, X4 As Long, Y1 As Long, Y2 As Long, Y3 As Long, Y4 As Long, M As Single, C As Single
                        Dim NTnum() As Long, ntV As Long, Maxnt As Long, NewntNum As Long, Rnt2 As Byte, Gnt2 As Byte, Bnt2 As Byte, Steps As Single, Rnt3 As Long, Gnt3 As Long, Bnt3 As Long
                        ReDim NTnum(100)
                        If FlashntNum < 0 Then FlashntNum = 0
                        FlashntNum = FlashntNum + 1
                        If FlashntNum > UBound(Flashnt, 2) Then
                            ReDim Preserve Flashnt(5, FlashntNum + 100)
                        End If
                        FirstFlash = 1 'need this to make sure that the screen only opdates as much as it needs to
                        Flashnt(0, FlashntNum) = Spos
                        Flashnt(1, FlashntNum) = CSeq
                        Flashnt(2, FlashntNum) = 80
                        
                        
                        Call ConvertLongToRGB(ColX(SeqColRef2(Recompress(Spos))), Rnt, Gnt, Bnt)
                        Flashnt(3, FlashntNum) = RGB(255, 255, 0)
                        'Flashnt(3, FlashntNum) = RGB(Rnt + (255 - Rnt) / 1.2, Gnt + (255 - Gnt) / 1.2, Bnt + (255 - Bnt) / 1.2)
                        
                        If Decompress(Recompress(Spos)) = Spos Then
                            If SeqNum(Recompress(Spos), CSeq) = MostCommonnt(Recompress(Spos)) Then
                                ColHolder = SeqColRef2(Recompress(Spos))
                                Flashnt(4, FlashntNum) = ColX(ColHolder)
                                
                            Else
                                Flashnt(4, FlashntNum) = BackColours
                            End If
                        Else
                            If Spos <= UBound(ABCons, 1) Then
                                If ABCons(Spos) <> 0 Then
                                    Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                                Else
                                    Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                End If
                            Else
                                Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                            End If
                        End If
                        
                        DontFade = FlashntNum
                        NewntNum = FlashntNum
                        Dim ThisTime As Long
                        ThisTime = Abs(GetTickCount)
                        Dim RevOrder As Long
                        
                        'XX = ThisTime - LastP1Time
    '                    If LastntNum <> NewntNum And LastntNum > 0 Then
    '                        X = X
    '                    End If
    
    '                    If Abs(LastP1X - SPos) > 1 And LastP1X > -1 Then
    '                        X = X
    '                    End If
                        If LastntNum > 0 And (Abs(LastP1Y - CSeq) > 1 Or Abs(LastP1X - Spos) > 1) And LastP1Y > -1 And LastP1X > -1 Then
                            Dim PropX As Single
                            
                            'fade lastntnum by 25%
                            'Call ConvertLongToRGB(Flashnt(3, LastntNum), Rnt, Gnt, Bnt)
                            Call ConvertLongToRGB(Flashnt(4, LastntNum), Rnt2, Gnt2, Bnt2)
                            Rnt3 = CLng(Rnt2) + (255 - Rnt2) * 0.75
                            Gnt3 = CLng(Gnt2) + (255 - Gnt2) * 0.75
                            Bnt3 = CLng(Bnt2) + (0 - Bnt2) * 0.75
                            Rnt = CByte(Rnt3)
                            Gnt = CByte(Gnt3)
                            Bnt = CByte(Bnt3)
                            Flashnt(3, LastntNum) = RGB(Rnt, Gnt, Bnt)
                          
                            
                            
                            If Gnt2 < 255 Then
                                Rnt3 = 255 - Gnt2
                                Gnt3 = 255 - Gnt
                            Else
                                Rnt3 = 255 - Rnt2
                                Gnt3 = 255 - Rnt
                            End If
                            
                            
                            
                            
                            PropX = (Rnt3 - Gnt3) / Rnt3
                            
                            X1 = Spos
                            X2 = LastP1X
                            
                            Y1 = CSeq
                            Y2 = LastP1Y
                            If X2 <> X1 Then
                                M = (Y2 - Y1) / (X2 - X1)
                                'If M = 0 Then M = SmallNum
                            Else
                                M = 100000
                            End If
                            
                            C = Y1 - M * X1
                            
                            'do the middle bits
                            
                            Z = 0
                            
                            If Abs((X1) - (X2)) >= Abs((Y1) - (Y2)) Then
                                Steps = Abs(X2 - 1 - (X1 + 1) + 2)
                                
                                
                                If X1 > X2 Then
                                    X4 = X1
                                    X1 = X2
                                    X2 = X4
                                    Y4 = Y1
                                    Y1 = Y2
                                    Y2 = Y4
                                    RevOrder = 1
                                    Z = 0
                                Else
                                    RevOrder = 0
                                    Z = Steps
                                End If
                                If (X2 - 1) - (X1 + 1) < PrintSeqLen Then
                                    For X3 = X1 + 1 To X2 - 1
                                        If RevOrder = 1 Then
                                            Z = Z + 1
                                        Else
                                            Z = Z - 1
                                        End If
                                        ReDim NTnum(100)
                                        Y3 = (M * X3 + C)
                                        FlashntNum = FlashntNum + 1
                                        If FlashntNum > UBound(Flashnt, 2) Then
                                            ReDim Preserve Flashnt(5, FlashntNum + 100)
                                        End If
                                        Flashnt(0, FlashntNum) = X3
                                        Flashnt(1, FlashntNum) = Y3
                                        Flashnt(2, FlashntNum) = 80
                                        Flashnt(3, FlashntNum) = RGB(255, 255, 0)
                                        'Flashnt(3, FlashntNum) = RGB(Rnt + (255 - Rnt) / 1.2, Gnt + (255 - Gnt) / 1.2, Bnt + (255 - Bnt) / 1.2)
                                        'reinsert this is mostcommon doesnt work
        '                                If Decompress(Recompress(X3)) = X3 Then
        '                                    For X4 = 0 To Nextno
        '                                        ntV = SeqNum(Recompress(X3), X4)
        '                                        NTnum(ntV) = NTnum(ntV) + 1
        '                                    Next X4
        '                                Else
        '                                    ntV = 66
        '                                    NTnum(ntV) = Nextno
        '                                End If
        '                                Maxnt = 0
        '                                For X4 = 60 To 90
        '                                    If Maxnt < NTnum(X4) Then
        '                                        Maxnt = NTnum(X4)
        '                                    End If
        '                                Next X4
                                        If Decompress(Recompress(X3)) = X3 Then
                                            If SeqNum(Recompress(X3), Y3) = MostCommonnt(Recompress(X3)) Then  'NTnum(SeqNum(Recompress(X3), Y3)) = Maxnt Then
                                                
                                                Flashnt(4, FlashntNum) = ColX(SeqColRef2(Recompress(X3))) 'colour it must return to
                                            Else
                                                Flashnt(4, FlashntNum) = BackColours
                                            End If
                                        Else
                                            If X3 <= UBound(ABCons, 1) Then
                                                If ABCons(X3) <> 0 Then
                                                    Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                                                Else
                                                    Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                                End If
                                            Else
                                                Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                                            End If
                                        End If
                                        'Call ConvertLongToRGB(Flashnt(4, FlashntNum), Rnt, Gnt, Bnt)
                                        'Call ConvertLongToRGB(Flashnt(4, LastntNum), Rnt2, Gnt2, Bnt2)
                                        
                                        
                                        Call ConvertLongToRGB(Flashnt(4, FlashntNum), Rnt, Gnt, Bnt)
                                        'Call ConvertLongToRGB(Flashnt(4, LastntNum), Rnt2, Gnt2, Bnt2)
                                        Rnt3 = Rnt + (255 - Rnt) * PropX
                                        Gnt3 = Gnt + (255 - Gnt) * PropX
                                        Bnt3 = Bnt + (0 - CLng(Bnt)) * PropX
        '                                If PropX < 1 Then
        '                                    X = X
        '                                End If
                                        If LastntNum > -1 Then
                                            
                                            
                                            Flashnt(3, FlashntNum) = RGB(CByte(Rnt3 + (255 - Rnt3) * (Z / Steps)), CByte(Gnt3 + (255 - Gnt3) * (Z / Steps)), CByte(Bnt3 + (0 - Bnt3) * (Z / Steps)))
                                        End If
                                        
                                    Next X3
                                End If
                            Else
                                Steps = Abs(Y2 - 1 - (Y1 + 1) + 2)
                                If Y1 > Y2 Then
                                    X4 = X1
                                    X1 = X2
                                    X2 = X4
                                    Y4 = Y1
                                    Y1 = Y2
                                    Y2 = Y4
                                    RevOrder = 1
                                    Z = 0
                                Else
                                    RevOrder = 0
                                    Z = Steps
                                End If
                                If (Y2 - 1) - (Y1 + 1) < PrintSeqLen Then
                                    For Y3 = Y1 + 1 To Y2 - 1
                                        If RevOrder = 1 Then
                                            Z = Z + 1
                                        Else
                                            Z = Z - 1
                                        End If
                                        
                                        ReDim NTnum(100)
                                        X3 = (Y3 - C) / M
                                        FlashntNum = FlashntNum + 1
                                        If FlashntNum > UBound(Flashnt, 2) Then
                                            ReDim Preserve Flashnt(5, FlashntNum + 100)
                                        End If
                                        Flashnt(0, FlashntNum) = X3
                                        Flashnt(1, FlashntNum) = Y3
                                        Flashnt(2, FlashntNum) = 80
                                        Flashnt(3, FlashntNum) = RGB(255, 255, 0)
                                        'Flashnt(3, FlashntNum) = RGB(Rnt + (255 - Rnt) / 1.2, Gnt + (255 - Gnt) / 1.2, Bnt + (255 - Bnt) / 1.2)
                                        If Decompress(Recompress(X3)) = X3 Then
                                            For X4 = 0 To NextNo
                                                ntV = SeqNum(Recompress(X3), X4)
                                                NTnum(ntV) = NTnum(ntV) + 1
                                            Next X4
                                        Else
                                            ntV = 66
                                            NTnum(ntV) = NextNo
                                        End If
                                        Maxnt = 0
                                        For X4 = 60 To 90
                                            If Maxnt < NTnum(X4) Then
                                                Maxnt = NTnum(X4)
                                            End If
                                        Next X4
                                        If Decompress(Recompress(X3)) = X3 Then
                                            If NTnum(SeqNum(Recompress(X3), Y3)) = Maxnt Then
                                                
                                                Flashnt(4, FlashntNum) = ColX(SeqColRef2(Recompress(X3))) 'colour it must return to
                                            Else
                                                Flashnt(4, FlashntNum) = BackColours
                                            End If
                                        Else
                                            If X3 <= UBound(ABCons, 1) Then
                                                If ABCons(X3) <> 0 Then
                                                    Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                                                Else
                                                    Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                                End If
                                            Else
                                                Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                            End If
                                        End If
                                        Call ConvertLongToRGB(Flashnt(4, FlashntNum), Rnt, Gnt, Bnt)
                                        'Call ConvertLongToRGB(Flashnt(4, LastntNum), Rnt2, Gnt2, Bnt2)
                                        Rnt3 = Rnt + (255 - Rnt) * PropX
                                        Gnt3 = Gnt + (255 - Gnt) * PropX
                                        Bnt3 = Bnt + (0 - CLng(Bnt)) * PropX
        '                                If PropX < 1 Then
        '                                    X = X
        '                                End If
                                        If LastntNum > -1 Then
                                            
                                            
                                            Flashnt(3, FlashntNum) = RGB(CByte(Rnt3 + (255 - Rnt3) * (Z / Steps)), CByte(Gnt3 + (255 - Gnt3) * (Z / Steps)), CByte(Bnt3 + (0 - Bnt3) * (Z / Steps)))
                                        End If
                                    Next Y3
                                End If
                            End If
                        ElseIf x = 12345 And LastntNum > 0 And (Abs(LastP1Y - CSeq) > 0 Or Abs(LastP1X - Spos) > 0) And LastP1Y > -1 And LastP1X > -1 Then
                            Call ConvertLongToRGB(Flashnt(4, LastntNum), Rnt2, Gnt2, Bnt2)
                            Rnt3 = CLng(Rnt2) + (255 - Rnt2) * 0.75
                            Gnt3 = CLng(Gnt2) + (255 - Gnt2) * 0.75
                            Bnt3 = CLng(Bnt2) + (0 - Bnt2) * 0.75
                            Rnt = CByte(Rnt3)
                            Gnt = CByte(Gnt3)
                            Bnt = CByte(Bnt3)
                            Flashnt(3, LastntNum) = RGB(Rnt, Gnt, Bnt)
                            FlashntNum = FlashntNum + 1
                            Flashnt(0, FlashntNum) = Spos
                            Flashnt(1, FlashntNum) = CSeq
                            Flashnt(2, FlashntNum) = 80
                            Flashnt(3, FlashntNum) = RGB(255, 255, 0)
                            If Decompress(Recompress(Spos)) = Spos Then
                                Flashnt(4, FlashntNum) = ColX(SeqColRef2(Recompress(Spos)))
                            Else
                                If Spos <= UBound(ABCons, 1) Then
                                    If ABCons(Spos) <> 0 Then
                                        Flashnt(4, FlashntNum) = RGB(64, 64, 255)
                                    Else
                                        Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                    End If
                                Else
                                    Flashnt(4, FlashntNum) = RGB(64, 128, 64)
                                End If
                                
                                
                            End If
                            Flashnt(5, FlashntNum) = RGB(0, 0, 0)
                            
                        End If
                        
                        
                        
                    End If
                    LastP1X = Spos
                    LastP1Y = CSeq
                    LastntNum = NewntNum
                    
                    'DoEvents
    '                DontDoH1Inc = 1
    ''                'OnlyDoPosBar = 1
    '                Call HScroll1_Change
    ''                'OnlyDoPosBar = 0
    '                DontDoH1Inc = 0
                    Timer4.Enabled = True
                    'Call Timer4_Timer
                    'If P1MMStillGoing = 1 Then
                    Dim CodonInfo As String, CodonNo As Long, aaEncoded As String, GeneNo As Long, CodonStart As Long, CPP As Long
                    CodonInfo = ""
                    If ORFFlag = 1 Then
                        For ZZ = 0 To 3
                        'XX = UBound(ORFWin, 1)
                            If ORFWin(ZZ, Spos) > 0 Then
                                If GeneList(ORFWin(ZZ, Spos)).Name <> "" Then
                                    
                                    GeneNo = ORFWin(ZZ, Spos)
                                    XX = GeneList(GeneNo).Product
                                    
                                    If GeneList(GeneNo).Orientation = 1 Then
                                        If GeneList(GeneNo).Start < GeneList(GeneNo).End Then
                                            CodonNo = Int((Spos - GeneList(GeneNo).StartInAlign) / 3) + 1
                                        Else
                                            If Spos < GeneList(GeneNo).Start Then
                                                CodonNo = Int((Spos + (Len(StrainSeq(0)) - GeneList(GeneNo).StartInAlign)) / 3) + 1
                                            Else
                                                CodonNo = Int((Spos - GeneList(GeneNo).StartInAlign) / 3) + 1
                                            End If
                                        End If
                                        For Yy = Spos To 0 Step -1
                                            CPP = Int((Yy - GeneList(GeneNo).StartInAlign) / 3) + 1
                                            
                                            If CPP <> CodonNo Then
                                                CodonStart = Yy + 1
                                                Exit For
                                            End If
                                            
                                        Next Yy
                                    
                                    ElseIf GeneList(GeneNo).Orientation = 2 Then
                                        If GeneList(GeneNo).End < GeneList(GeneNo).Start Then
                                            CodonNo = Int((GeneList(GeneNo).StartInAlign - Spos) / 3) + 1
                                        Else
                                            If Spos < GeneList(GeneNo).Start Then
                                                CodonNo = Int((GeneList(GeneNo).StartInAlign - Spos) / 3) + 1
                                            Else
                                                CodonNo = Int((GeneList(GeneNo).StartInAlign + (Len(StrainSeq(0)) - Spos)) / 3) + 1
                                            
                                            End If
                                        End If
                                        GoOn = 1
                                        If Spos < GeneList(GeneNo).StartInAlign Then
                                            For Yy = Spos To Len(StrainSeq(0)) ' Step -1
                                                
                                                CPP = Int((GeneList(GeneNo).StartInAlign - Yy) / 3) + 1
                                                
                                                If CPP <> CodonNo Then
                                                    CodonStart = Yy - 1
                                                    GoOn = 0
                                                    Exit For
                                                End If
                                                
                                            Next Yy
                                            If GoOn = 1 Then
                                                
                                                For Yy = 1 To Spos ' Step -1
                                                
                                                    CPP = Int((GeneList(GeneNo).StartInAlign - Yy) / 3) + 1
                                                    
                                                    If CPP <> CodonNo Then
                                                        CodonStart = Yy - 1
                                                        GoOn = 0
                                                        Exit For
                                                    End If
                                                    
                                                Next Yy
                                            End If
                                        Else
                                            
                                            For Yy = Spos To Len(StrainSeq(0)) ' Step -1
                                                
                                                CPP = Int((GeneList(GeneNo).StartInAlign - Yy) / 3) + 1
                                                
                                                If CPP <> CodonNo Then
                                                    CodonStart = Yy - 1
                                                    GoOn = 0
                                                    Exit For
                                                End If
                                                
                                            Next Yy
                                            If GoOn = 1 Then
                                                For Yy = 1 To Spos ' Step -1
                                                
                                                    CPP = Int((GeneList(GeneNo).StartInAlign - Yy) / 3) + 1
                                                    
                                                    If CPP <> CodonNo Then
                                                        CodonStart = Yy - 1
                                                        GoOn = 0
                                                        Exit For
                                                    End If
                                                    
                                                Next Yy
                                            End If
                                        
                                        End If
                                    End If
                                    If GeneList(GeneNo).Orientation = 1 Then
                                        If CodonStart + 2 <= Len(StrainSeq(0)) Then
                                            aaEncoded = Trans(Nucs(SeqNum(CodonStart, CSeq)), Nucs(SeqNum(CodonStart + 1, CSeq)), Nucs(SeqNum(CodonStart + 2, CSeq)))
                                        End If
                                    Else
                                        If CodonStart - 2 >= 0 Then
                                            aaEncoded = Trans(RevNucs(SeqNum(CodonStart, CSeq)), RevNucs(SeqNum(CodonStart - 1, CSeq)), RevNucs(SeqNum(CodonStart - 2, CSeq)))
                                        End If
                                    End If
                                    'Form1.Caption = Str(CodonNo) + " " + aaEncoded
                                    If CodonInfo <> "" Then
                                        CodonInfo = CodonInfo + "; "
                                    Else
                                        CodonInfo = "("
                                    End If
                                    CodonInfo = CodonInfo + "Codon " + Trim(Str(CodonNo)) + " of " + GeneList(GeneNo).Name + " encoding " + aaEncoded
                                    
                                End If
                            End If
                        Next ZZ
                        If CodonInfo <> "" Then
                            CodonInfo = CodonInfo + ")"
                        End If
                    End If
                    'Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq)
                    If ORFFlag = 1 Then
                       Curgene = GeneNo 'SEPosMap(PermX)
                       If GeneList(Curgene).Name <> "" Then
                            Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq) + CodonInfo '" (" + GeneList(Curgene).Name + ")"
                        Else
                            Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq)
                        End If
                    Else
                       Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq)
                    End If
                Else
                    If ORFFlag = 1 Then
                       Curgene = SEPosMap(PermX)
                       Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq) + " (" + GeneList(Curgene).Name + ")"
                    Else
                       Picture1.ToolTipText = "Nucleotide position " & ntPos & " of " & OriginalName(CSeq)
                    End If
                    'End If
                    Label15.Caption = Trim(Str(Spos)) + ", " + Trim(Str(CSeq))
                    Picture1.AutoRedraw = True
                    Picture1.DrawMode = 6
                    '(X * 13 - TYFM) * tTYF)
                    'Picture1.Line (((TPosX - 1) * LenTXT + 1), (TPosY - TYFM) * HiTxt)-(((TPosX - 1) * LenTXT + LenTXT - 1), (TPosY - TYFM) * HiTxt + (HiTxt) * tTYF), RGB(196, 196, 0), BF
                    
                    TV1 = ltPosY
                    TV1 = TV1 * 13 - TYFM
                    TV1 = TV1 * tTYF * ttyfAdjust - VSV + 1
                    TV2 = ltPosY + 1
                    TV2 = (TV2 * 13 - TYFM) * tTYF * ttyfAdjust + 1 - VSV
                    If ltPosY <= PermNextno And ltPosY <= NextNo Then
                        Picture1.Line (((ltPosX - 1) * LenTXT), TV1)-(((ltPosX - 1) * LenTXT + LenTXT - 1), TV2), RGB(0, 0, 120), BF
                    
                    End If
                    
                    TV1 = TPosY
                    TV1 = TV1 * 13 - TYFM
                    TV1 = TV1 * tTYF * ttyfAdjust - VSV + 1
                    TV2 = TPosY + 1
                    TV2 = (TV2 * 13 - TYFM) * tTYF * ttyfAdjust + 1 - VSV
                    Picture1.Line (((TPosX - 1) * LenTXT), TV1)-(((TPosX - 1) * LenTXT + LenTXT - 1), TV2), RGB(0, 0, 120), BF
                    ltPosY = TPosY
                    ltPosX = TPosX
                    Picture1.DrawMode = 13
                    Picture1.AutoRedraw = True
                End If
            Else
                '
            End If
        End If
    Else
        Picture1.Refresh
        Picture1.ToolTipText = ""
        Label15.Caption = "--"
    End If
Else
    'kill the flashed nt
    Call CheckUnFlash
    Picture1.Refresh
    Picture1.ToolTipText = ""
   ' SSPanel1.Caption = ""
End If

Dim AxLen As Long
If DebuggingFlag < 2 Then On Error Resume Next
AxLen = -1
AxLen = GYAxHi(1)
On Error GoTo 0
If AxLen > 0 And p7CurWinSize > 0 Then
    
    P7XP = oP7XP
    Call ShrinkZoom
    P7XP = 0
    oP7XP = 0
    'XX = Form1.Label1.Visible
    Form1.Label1.Caption = ""
End If
P1MMStillGoing = P1MMStillGoing - 1
'xx=screen.
'On Error GoTo 0
End Sub

Private Sub Picture1_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Picture12.Visible = False
    P1MDStart = -1
End Sub

Private Sub Picture10_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    Call CheckUnFlash
End Sub

Private Sub Picture12_Click()
Dim PorS As Byte, PntAPI As POINTAPI
Dim RCo As Byte, GCo As Byte, BCo As Byte
Form1.Picture10.ScaleMode = 3
XFactor = (Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0)))
'YScaleFactor = 0.85
'PicHeight = Form1.Picture7.Height * YScaleFactor
If ManFlag = 9 Then
    If P2YVal < 20 Then
        PorS = 0
    Else
        PorS = 1
        P2YVal = P2YVal - 20
    End If
    If P2YVal = 0 Then Exit Sub
    
    GCo = 100
    BCo = 255
    RCo = 0
    'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
    Call RedrawPlotAA(1)
    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8))
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, (30 + Decompress(GPrintPos(0, 0)) * XFactor), (PicHeight - (15 + ((GPrint(P2YVal, 0) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35))), PntAPI
    For x = 1 To Len(StrainSeq(0))
        If GPrintPos(0, x) = 0 Then Exit For
        LineTo Pict, (30 + Decompress(GPrintPos(0, x)) * XFactor), (PicHeight - (15 + ((GPrint(P2YVal, x) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35)))
    Next x
    Form1.Picture7.DrawWidth = 2
    
    Form1.Picture7.ForeColor = RGB(RCo, GCo, BCo)
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, (30 + Decompress(GPrintPos(0, 0)) * XFactor), (PicHeight - (15 + ((GPrint(P2YVal, 0) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35))), PntAPI
    For x = 1 To Len(StrainSeq(0))
        If GPrintPos(0, x) = 0 Then Exit For
        LineTo Pict, (30 + Decompress(GPrintPos(0, x)) * XFactor), (PicHeight - (15 + ((GPrint(P2YVal, x) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35)))
    Next x
    Form1.Picture7.DrawWidth = 1
    
        Picture12.AutoRedraw = True
        Picture12.Picture = LoadPicture()
        

        If PorS = 0 Then
            Picture12.Line (25, 25 + 200 * (P2YVal - 1))-(600, 75 + (200 * (P2YVal - 1) + 150)), RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8)), BF
        Else
            Picture12.Line (725, 25 + 200 * (P2YVal - 1))-(1300, 75 + (200 * (P2YVal - 1) + 150)), RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8)), BF
        End If
        
        For x = 1 To 15
            Picture12.Line (50, 50 + 200 * (x - 1))-(200, 50 + (200 * (x - 1) + 150)), PltCol(x), BF
        Next x
        
        Picture12.ForeColor = RGB(150, 150, 150)
        For x = 1 To 15
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 250 + 14
            Picture12.CurrentY = 50 + (x - 1) * 200 + 14
            Picture12.Print "P" & Trim$(CStr(x))
        Next x
        
        
        Picture12.ForeColor = 0
        
        For x = 1 To 15
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 250
            Picture12.CurrentY = 50 + (x - 1) * 200
            Picture12.Print "P" & Trim$(CStr(x))
        Next x
        
        For x = 1 To 9
            Picture12.Line (750, 50 + 200 * (x - 1))-(900, 50 + (200 * (x - 1) + 150)), PltCol2(x), BF
        Next x
        If PorS = 0 Then
        
            Picture12.Line (50, 50 + 200 * (P2YVal - 1))-(200, 50 + (200 * (P2YVal - 1) + 150)), RGB(RCo, GCo, BCo), BF
        Else
            Picture12.Line (750, 50 + 200 * (P2YVal - 1))-(900, 50 + (200 * (P2YVal - 1) + 150)), RGB(RCo, GCo, BCo), BF
        End If
        
        Picture12.ForeColor = RGB(150, 150, 150)
        For x = 1 To 9
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 950 + 14
            Picture12.CurrentY = 50 + (x - 1) * 200 + 14
            Picture12.Print "S" & Trim$(CStr(x))
        Next x
        
        
        Picture12.ForeColor = 0
        
        For x = 1 To 9
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 950
            Picture12.CurrentY = 50 + (x - 1) * 200
            Picture12.Print "S" & Trim$(CStr(x))
        Next x
        Picture12.Refresh
ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
    If P2YVal < 20 Then
        PorS = 0
    Else
        PorS = 1
        P2YVal = P2YVal - 20
    End If
    If P2YVal = 0 Then Exit Sub
    
    GCo = 100
    BCo = 255
    RCo = 0
    'XX = Form1.Picture21.Height
    x = x
    'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
    Call RedrawPlotAA(1)
    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8))
    Pict = Form1.Picture7.hdc
    
    Dim PorSX As Long
    PorSX = PorS * 14
    If PorSX = 0 Then
        ModX = -1
    Else
        ModX = 0
    End If
    MoveToEx Pict, (30 + Decompress(GPrintPos(0, 0)) * XFactor), (PicHeight - (15 + ((GPrint(PorSX + P2YVal + ModX, 0) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35))), PntAPI
    For x = 1 To Len(StrainSeq(0))
        If GPrintPos(0, x) = 0 Then Exit For
        LineTo Pict, (30 + Decompress(GPrintPos(0, x)) * XFactor), (PicHeight - (15 + ((GPrint(PorSX + P2YVal + ModX, x) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35)))
    Next x
    Form1.Picture7.DrawWidth = 2
    
    Form1.Picture7.ForeColor = RGB(RCo, GCo, BCo)
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, (30 + Decompress(GPrintPos(0, 0)) * XFactor), (PicHeight - (15 + ((GPrint(PorSX + P2YVal + ModX, 0) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35))), PntAPI
    For x = 1 To Len(StrainSeq(0))
        If GPrintPos(0, x) = 0 Then Exit For
        LineTo Pict, (30 + GPrintPos(0, x) * XFactor), (PicHeight - (15 + ((GPrint(PorSX + P2YVal + ModX, x) - SSLo) / (SSUp - SSLo)) * (PicHeight - 35)))
    Next x
    
    Form1.Picture7.DrawWidth = 1
    
        Picture12.AutoRedraw = True
        Picture12.Picture = LoadPicture()
        

        If PorS = 0 Then
            Picture12.Line (25, 25 + 200 * (P2YVal - 1))-(600, 75 + (200 * (P2YVal - 1) + 150)), RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8)), BF
        Else
            Picture12.Line (725, 25 + 200 * (P2YVal - 1))-(1300, 75 + (200 * (P2YVal - 1) + 150)), RGB((BkR - (BkR - RCo) / 8), (BkG - (BkG - GCo) / 8), (BkB + (BCo - BkB) / 8)), BF
        End If
        
        For x = 1 To 15
            Picture12.Line (50, 50 + 200 * (x - 1))-(200, 50 + (200 * (x - 1) + 150)), PltCol(x), BF
        Next x
        
        Picture12.ForeColor = RGB(150, 150, 150)
        For x = 1 To 15
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 250 + 14
            Picture12.CurrentY = 50 + (x - 1) * 200 + 14
            Picture12.Print "P" & Trim$(CStr(x))
        Next x
        
        
        Picture12.ForeColor = 0
        
        For x = 1 To 15
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 250
            Picture12.CurrentY = 50 + (x - 1) * 200
            Picture12.Print "P" & Trim$(CStr(x))
        Next x
        
        For x = 1 To 9
            Picture12.Line (750, 50 + 200 * (x - 1))-(900, 50 + (200 * (x - 1) + 150)), PltCol2(x), BF
        Next x
        If PorS = 0 Then
        
            Picture12.Line (50, 50 + 200 * (P2YVal - 1))-(200, 50 + (200 * (P2YVal - 1) + 150)), RGB(RCo, GCo, BCo), BF
        Else
            Picture12.Line (750, 50 + 200 * (P2YVal - 1))-(900, 50 + (200 * (P2YVal - 1) + 150)), RGB(RCo, GCo, BCo), BF
        End If
        
        Picture12.ForeColor = RGB(150, 150, 150)
        For x = 1 To 9
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 950 + 14
            Picture12.CurrentY = 50 + (x - 1) * 200 + 14
            Picture12.Print "S" & Trim$(CStr(x))
        Next x
        
        
        Picture12.ForeColor = 0
        
        For x = 1 To 9
            'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
            Picture12.CurrentX = 950
            Picture12.CurrentY = 50 + (x - 1) * 200
            Picture12.Print "S" & Trim$(CStr(x))
        Next x
        Picture12.Refresh
End If
End Sub

Private Sub Picture12_DragDrop(Source As Control, x As Single, Y As Single)
Picture12.DragMode = 0

End Sub

Private Sub Picture12_DragOver(Source As Control, x As Single, Y As Single, State As Integer)
'Picture12.Left = X
'Picture12.Top = Y
End Sub

Private Sub Picture12_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
P12X = x / Screen.TwipsPerPixelX
P12Y = Picture12.Height - (Y / Screen.TwipsPerPixelY)

End Sub

Private Sub Picture12_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Dim TipString(29) As String
If Button = 1 Then
   'Picture12.Left = Picture12.Left + (CLng(X / Screen.TwipsPerPixelX) - P12X)
   'Picture12.Top = Picture12.Top + (CLng(Y / Screen.TwipsPerPixelY) - P12Y)
   '
   'P12X = X / Screen.TwipsPerPixelX
    'P12Y = Y / Screen.TwipsPerPixelY
    'DoEvents
    'Picture12.DragMode = 1
Else
    
     
     Dim SPNum As Long
     
     
     If ManFlag = -1 Then
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
            
           TipString(8) = "S1=S2~S3~S4"
           
           SPNum = (Y + 75) / 200
           P2YVal = 0
           If x < 700 Then
               
               '+ 1
               
                   
                       If SPNum >= 0 And SPNum <= 15 Then
                           If HLFlag <> SPNum Then
                               Picture12.Refresh
                               Picture12.AutoRedraw = False
                               
                               For Z = 0 To 255 Step 16
                                   
                                   If HLFlag > -1 Then
                                           Picture12.ForeColor = RGB(255 - Z, 0, 0)
                                           Picture12.CurrentX = 250
                                           Picture12.CurrentY = 50 + (HLFlag - 1) * 200
                                           Picture12.Print "P" & Trim$(CStr(HLFlag))
                                   End If
                                   Picture12.ForeColor = RGB(Z, 0, 0)
                                   Picture12.CurrentX = 250
                                   Picture12.CurrentY = 50 + (SPNum - 1) * 200
                                   Picture12.Print "P" & Trim$(CStr(SPNum))
                                   Sleep 5
                               Next Z
                               'Picture12.ToolTipText = TipString(P2YVal)
                               HLFlag = SPNum
                           End If
                       Else
                           'Picture12.ToolTipText = ""
                           Picture12.Refresh
                           HLFlag = -1
                       End If
                   P2YVal = SPNum
                   If P2YVal > 15 Then
                       P2YVal = 0
                       
                   End If
           Else
               
               If SPNum >= 0 And SPNum <= 9 Then
                   If HLFlag <> SPNum Then
                               Picture12.Refresh
                               Picture12.AutoRedraw = False
                               
                               For Z = 0 To 255 Step 16
                                   
                                   If HLFlag > -1 Then
                                           Picture12.ForeColor = RGB(255 - Z, 0, 0)
                                           Picture12.CurrentX = 950
                                           Picture12.CurrentY = 50 + (HLFlag - 1) * 200
                                           Picture12.Print "S" & Trim$(CStr(HLFlag))
                                   End If
                                   Picture12.ForeColor = RGB(Z, 0, 0)
                                   Picture12.CurrentX = 950
                                   Picture12.CurrentY = 50 + (SPNum - 1) * 200
                                   Picture12.Print "S" & Trim$(CStr(SPNum))
                                   Sleep 5
                               Next Z
                               
                               HLFlag = SPNum
                           End If
               Else
                   HLFlag = -1
                   Picture12.Refresh
               End If
               P2YVal = SPNum + 20
           End If
           
           If P2YVal > 29 Then P2YVal = 0
        End If
    ElseIf ManFlag = 9 Then
        
            
           TipString(8) = "S1=S2~S3~S4"
           
           SPNum = (Y + 75) / 200
           P2YVal = 0
           If x < 700 Then
               
               '+ 1
               
                   
                       If SPNum >= 0 And SPNum <= 15 Then
                           If HLFlag <> SPNum Then
                               Picture12.Refresh
                               Picture12.AutoRedraw = False
                               
                               For Z = 0 To 255 Step 16
                                   
                                   If HLFlag > -1 Then
                                           Picture12.ForeColor = RGB(255 - Z, 0, 0)
                                           Picture12.CurrentX = 250
                                           Picture12.CurrentY = 50 + (HLFlag - 1) * 200
                                           Picture12.Print "P" & Trim$(CStr(HLFlag))
                                   End If
                                   Picture12.ForeColor = RGB(Z, 0, 0)
                                   Picture12.CurrentX = 250
                                   Picture12.CurrentY = 50 + (SPNum - 1) * 200
                                   Picture12.Print "P" & Trim$(CStr(SPNum))
                                   Sleep 5
                               Next Z
                               'Picture12.ToolTipText = TipString(P2YVal)
                               HLFlag = SPNum
                           End If
                       Else
                           'Picture12.ToolTipText = ""
                           Picture12.Refresh
                           HLFlag = -1
                       End If
                   P2YVal = SPNum
                   If P2YVal > 15 Then
                       P2YVal = 0
                       
                   End If
           Else
               
               If SPNum >= 0 And SPNum <= 9 Then
                   If HLFlag <> SPNum Then
                               Picture12.Refresh
                               Picture12.AutoRedraw = False
                               
                               For Z = 0 To 255 Step 16
                                   
                                   If HLFlag > -1 Then
                                           Picture12.ForeColor = RGB(255 - Z, 0, 0)
                                           Picture12.CurrentX = 950
                                           Picture12.CurrentY = 50 + (HLFlag - 1) * 200
                                           Picture12.Print "S" & Trim$(CStr(HLFlag))
                                   End If
                                   Picture12.ForeColor = RGB(Z, 0, 0)
                                   Picture12.CurrentX = 950
                                   Picture12.CurrentY = 50 + (SPNum - 1) * 200
                                   Picture12.Print "S" & Trim$(CStr(SPNum))
                                   Sleep 5
                               Next Z
                               
                               HLFlag = SPNum
                           End If
               Else
                   HLFlag = -1
                   Picture12.Refresh
               End If
               P2YVal = SPNum + 20
           End If
           
           If P2YVal > 29 Then P2YVal = 0
        
    End If
    
End If


End Sub

Private Sub Picture12_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
'Picture12.Visible = False
End Sub

Private Sub Picture13_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
'Form1.Picture4.Refresh: Form1.Picture11.Refresh
Dim A As Long, b As Long, C As Long, BC() As Long, SEFlag As Long

If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
'Dim RefA() As Long
SEFlag = LastSEFlag
Call CheckUnFlash
Dim PixCol As Long, PCR As Byte, PCG As Byte, PCB As Byte, TTText As String
If ORFFlag = 1 Then
    LastCurgene = -1
    
    Curgene = SEPosMap(x) '606
'    If Curgene = 25 Then '381,373
'        X = X
'    ElseIf Curgene = 26 Then
'        X = X '377
'    End If
'    If Y < 5 Then
'            X = X
'        End If
    If Curgene = GeneNumber + 3 Then
    x = x
        TTText = "Segment boundry"
    ElseIf Curgene > 0 Then
        
        PixCol = GetPixel(Picture13.hdc, x, Y)
'        For A = 1 To FlashntNum
'            If Flashnt(2, A) > 500 Then
'                Flashnt(2, A) = 80
'            End If
'        Next A
        Call ConvertLongToRGB(PixCol, PCR, PCG, PCB)
        Dim StartExon As Long, EndExon As Long, ExonN As Long, Pos As Long, ProtName As String
        
        If PixCol > 0 Then
            
        If PCR > 200 And (CLng(PCR) - CLng(PCG) < 40) And (CLng(PCR) - CLng(PCG) > 10) And CLng(PCG) - CLng(PCB) > 90 Then  'its an intron donor
            Call GetExonStats(Curgene, StartExon, EndExon)
            If GeneList(Curgene).Orientation = 1 Then
                ExonN = Curgene - StartExon + 1
            ElseIf GeneList(Curgene).Orientation = 2 Then
                ExonN = EndExon - Curgene + 1
            End If
            'If GeneList(Curgene).Orientation = 1 Then
                TTText = "Approximate position of " + GeneList(StartExon).Name + " intron " + Trim(Str(ExonN)) + " donor site"
'            ElseIf GeneList(Curgene).Orientation = 2 Then
'                TTText = "Approximate position of intron " + Trim(Str(ExonN)) + " donor site of " + GeneList(StartExon).Name
'            End If
            SEFlag = 6
        ElseIf PCR > 200 And (CLng(PCR) - CLng(PCG) < 10) And (CLng(PCR) - CLng(PCG) >= 0) And (CLng(PCG) - CLng(PCB) > 50) Then 'its an intron acceptor
            Call GetExonStats(Curgene, StartExon, EndExon)
            If GeneList(Curgene).Orientation = 1 Then
                ExonN = Curgene - StartExon + 1
            ElseIf GeneList(Curgene).Orientation = 2 Then
                ExonN = EndExon - Curgene + 1
            End If
            TTText = "Approximate position of " + GeneList(StartExon).Name + " intron " + Trim(Str(ExonN - 1)) + " acceptor site"
            SEFlag = 4
        ElseIf (PCB < 200 And PCR < 200 And PCG > 200 And (CLng(PCG) - CLng(PCR)) > 50 And CLng(PCG) - CLng(PCB) > 50) Then 'its a start
            If GeneList(Curgene).IntronFlag = 0 Then
                
                If Right$(GeneList(Curgene).Product, 1) = "*" Then 'means its a component of a polyprotein
                    Pos = InStr(1, GeneList(Curgene).Product, ":", vbBinaryCompare)
                    If Pos > 1 Then
                       ProtName = Left(GeneList(Curgene).Product, Pos - 1)
                       TTText = "Approximate first codon position of " + ProtName + " cleavage product in " + GeneList(Curgene).Name
                    Else
                        TTText = "Approximate first codon position of " + GeneList(Curgene).Product + " cleavage product"
                    End If
                Else
                    TTText = "Approximate position of " + GeneList(Curgene).Name + " start codon"
                End If
            Else
                
                Call GetExonStats(Curgene, StartExon, EndExon)
                
                If GeneList(Curgene).Orientation = 1 Then
                    ExonN = Curgene - StartExon + 1
                ElseIf GeneList(Curgene).Orientation = 2 Then
                    ExonN = EndExon - Curgene + 1
                End If
                If (GeneList(Curgene).Orientation = 2 And Curgene = EndExon) Or (GeneList(Curgene).Orientation = 1 And Curgene = StartExon) Then
                    TTText = "Approximate position of " + GeneList(StartExon).Name + " start codon"
                Else
                    TTText = "Approximate position of " + GeneList(StartExon).Name + " exon " + Trim(Str(ExonN)) + " start codon"
                End If
            End If
            
            GeneSEFlash = 1
            Form1.Timer1.Enabled = True
            
            SEFlag = 0
            
            
        ElseIf PCR > 200 And PCB > 100 And CLng(PCR) - CLng(PCG) > 50 And CLng(PCR) - CLng(PCB) > 50 Then 'its an end
            If GeneList(Curgene).IntronFlag = 0 Then
                If Right$(GeneList(Curgene).Product, 1) = "*" Then 'means its a component of a polyprotein
                    Pos = InStr(1, GeneList(Curgene).Product, ":", vbBinaryCompare)
                    If Pos > 1 Then
                       ProtName = Left(GeneList(Curgene).Product, Pos - 1)
                       TTText = "Approximate last codon position of " + ProtName + " cleavage product in " + GeneList(Curgene).Name
                    Else
                        TTText = "Approximate last codon position of " + GeneList(Curgene).Product + " cleavage product"
                    End If
                Else
                    TTText = "Approximate position of " + GeneList(Curgene).Name + " stop codon"
                End If
            Else
                
                Call GetExonStats(Curgene, StartExon, EndExon)
                
                If GeneList(Curgene).Orientation = 1 Then
                    ExonN = Curgene - StartExon + 1
                ElseIf GeneList(Curgene).Orientation = 2 Then
                    ExonN = EndExon - Curgene + 1
                End If
                If (GeneList(Curgene).Orientation = 2 And Curgene = StartExon) Or (GeneList(Curgene).Orientation = 1 And Curgene = EndExon) Then
                    TTText = "Approximate position of " + GeneList(StartExon).Name + " stop codon"
                Else
                    TTText = "Approximate end of " + GeneList(StartExon).Name + " exon " + Trim(Str(ExonN))
                End If
            End If
            'TTText = "Approximate position of " + GeneList(Curgene).Name + " end codon"
            Form1.Timer1.Enabled = True
            GeneSEFlash = 1
            SEFlag = 2
        ElseIf CLng(PCB) + CLng(PCG) + CLng(PCR) > 150 Then
            TTText = ""
            SEFlag = -1
            XX = PCR
            XX = PCG
            XX = PCB
        End If
        If SEFlag > -1 Then
        If LastSEFlag <> SEFlag Then
            For A = 0 To FlashntNum
                If Flashnt(2, A) = 1000 Then
                    Flashnt(2, A) = 900
                End If
            Next A
        End If
        Dim TargetCol As Long
        If SEFlag = 0 Then
            TargetCol = RGB(128, 255, 128)
        ElseIf SEFlag = 2 Then
            TargetCol = RGB(255, 128, 128)
        ElseIf SEFlag = 4 Then
            TargetCol = RGB(255, 255, 128)
        ElseIf SEFlag = 6 Then
            TargetCol = RGB(255, 198, 128)
        End If
        
        Dim NTnum() As Long, ntV As Long, Maxnt As Long, FirstCycle As Long, DoneCol() As Long, ActiveNum As Long, ColHolder As Long
        If ShowSeqFlag = 0 And SEFlag > -1 And (SEFlag <> LastSEFlag Or (SEFlag = LastSEFlag And LastCurgene <> Curgene)) Then
            'XX = HScroll1Hits
             'HScroll1Hits = 0
            HScroll1Hits = HScroll1Hits + 1
            SS = Abs(GetTickCount)
            ReDim BC(PermNextno)
            ReDim DoneCol(Len(StrainSeq(0)))
            A = 1
            Do
                'If Flashnt(2, A) > 500 Then Flashnt(2, A) = 800
                If Flashnt(2, A) = 1000 Then
                    If A = LastntNum Then LastntNum = -1
                    If A = DontFade Then DontFade = -1
                    If A < FlashntNum Then

                        For b = 0 To 5
                            Flashnt(b, A) = Flashnt(b, FlashntNum)
                        Next b
                        If DontFade = FlashntNum Then DontFade = A
                        If LastntNum = FlashntNum Then LastntNum = A
                        A = A - 1
                    End If
                    FlashntNum = FlashntNum - 1
                ElseIf Flashnt(2, A) = 900 Then
                    Flashnt(2, A) = 800
                End If
                A = A + 1
                If A > FlashntNum Then Exit Do
            Loop
            
            'ReDim RefA(Len(StrainSeq(0)))
            'For D = 1 To 200
            
            If Left(GeneList(Curgene).Name, 3) = "asp" Then
                x = x
            End If
            For A = 0 To PermNextno
                'ReDim RefA(Len(StrainSeq(0)))
                
                If GeneSEPos(A, Curgene, SEFlag) > 0 Then
                    For b = GeneSEPos(A, Curgene, SEFlag) To GeneSEPos(A, Curgene, SEFlag + 1)
                        FlashntNum = FlashntNum + 1
                        If FlashntNum > UBound(Flashnt, 2) Then
                            ReDim Preserve Flashnt(5, FlashntNum + 100)
                        End If
                        If FlashntNum < 0 Then FlashntNum = 0
'                        If X = X Then
                            '@
                            ActiveNum = FindDupFlash(A, b, UBound(Flashnt, 1), FlashntNum, Flashnt(0, 0))
'                        Else
'                            ActiveNum = FlashntNum
'                            For C = 0 To FlashntNum - 1
'                                If Flashnt(1, C) = A Then
'                                    If Flashnt(0, C) = b Then
'                                        ActiveNum = C
'                                        FlashntNum = FlashntNum - 1
'                                        Exit For
'                                    End If
'                                End If
'                            Next C
'                        End If
                        FirstFlash = 3
                        Flashnt(0, ActiveNum) = b
                        Flashnt(1, ActiveNum) = A
                        Flashnt(2, ActiveNum) = 1000
                        Flashnt(3, ActiveNum) = TargetCol 'current colour
                        Flashnt(5, ActiveNum) = TargetCol 'start colour
                        If SeqNum(b, A) = MostCommonnt(b) Then
                            ColHolder = SeqColRef2(b)
                            '@
                            Flashnt(4, ActiveNum) = ColX(ColHolder)
                        Else
                            Flashnt(4, ActiveNum) = BackColours
                        End If
'                        If DoneCol(b) = 0 Or RefA(b) <> SeqNum(b, A) Then
'                            ReDim NTnum(100)
'                            For C = 0 To PermNextno
'                                ntV = SeqNum(b, C)
'                                NTnum(ntV) = NTnum(ntV) + 1
'                            Next C
'                            Maxnt = 0
'                            For C = 60 To 90
'                                If Maxnt < NTnum(C) Then
'                                    Maxnt = NTnum(C)
'                                End If
'                            Next C
'                            RefA(b) = SeqNum(b, A)
'                            If NTnum(SeqNum(b, A)) = Maxnt Then
'
'                                DoneCol(b) = ColX(SeqColRef2(b)) 'colour it must return to
'                            Else
'                                DoneCol(b) = BackColours
'                            End If
'
'                        End If
'                        Flashnt(4, ActiveNum) = DoneCol(b)
                    Next b
                    Timer4.Enabled = True
                    'XX = FlashntNum
                End If
            Next A
            'Next D
            EE = Abs(GetTickCount)
            TT = EE - SS '4110 urminla's dataset2.953, 2734 without redimming, 1266 (changing c loop), 94 ctranslation of inner loop
            x = x
            LastSEFlag = SEFlag
        End If
        End If
        End If
    Else
        TTText = ""
        LastSEFlag = -2
        For A = 0 To FlashntNum
            If Flashnt(2, A) = 1000 Then
                Flashnt(2, A) = 900
            End If
        Next A
        'Timer4.Enabled = True
    End If
    If Picture13.ToolTipText <> TTText Then
        Picture13.ToolTipText = TTText
    End If
End If
 XX = HScroll1Hits
End Sub

Private Sub Picture15_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
End Sub

Private Sub Picture16_KeyDown(KeyCode As Integer, Shift As Integer)
Call DoKeydown(KeyCode)
End Sub

Private Sub Picture16_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    If CurrentlyRunningFlag = 1 Then Exit Sub
    Dim MaxY As Long
    Dim tTYF As Double, TYFM As Integer
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(StoreChanged, 1)
    On Error GoTo 0
    
    If Pic2MD = 0 Or UB < NextNo Then
        ReDim Preserve StoreChanged(NextNo)
    End If
    
    Picture16.Enabled = True
    Y = Y + VScroll1.Value * F1VS1ScaleFactor
    Call ModOffsets(8.25, Picture16, tTYF, TYFM)
    Y = Int(Y / tTYF + 1)
    OldFontSize = 8.25
    Dim CurrentSeq As Integer

    If TwipPerPix = 12 Then AddjNum = 14 Else AddjNum = 14
    Index = TreeTypeFlag
    F2TreeIndex = TreeTypeFlag
    If Index = 0 Or (Index = 3 And (CTF = 0 Or CTF = 1)) Then
        MaxY = (NextNo + 1) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CTF, 0, Abs(Int((Y - 3) / AddjNum)))
    ElseIf Index = 1 Then
        MaxY = (NextNo + 2) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(1), 1, Abs(Int((Y - 3) / AddjNum)))
    ElseIf Index = 2 Then
        MaxY = (NextNo + 1) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(2), 2, Abs(Int((Y - 3) / AddjNum)))
    ElseIf Index = 3 Then
        MaxY = (NextNo + 1) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(3), 3, Abs(Int((Y - 3) / AddjNum)))
    End If
    PRat = TDLen(TreeTypeFlag, CTF, 2) / Form1.Picture16.ScaleWidth
    XMod = TreeXScaleMod(1, TreeTypeFlag, CTF)
    
    If XMod = 0 Then
        Exit Sub
    End If
    PRat = PRat / XMod

    If Button = 1 Then
        Pic2MD = 1
        If TreeTypeFlag = 0 Or (TreeTypeFlag = 3 And (CTF = 0 Or CTF = 1)) Then
            'If CurrentSeq <> Seq1 And CurrentSeq <> Seq2 And CurrentSeq <> Seq3 Then
                
                LChange = CurrentSeq
                Z = Form1.Picture16.ScaleWidth
                Picture16.CurrentY = YCord(CTF, Index, CurrentSeq)
                
                If x > XCord(CTF, F2TreeIndex, CurrentSeq) / PRat And x < (XCord(CTF, F2TreeIndex, CurrentSeq) / PRat + Picture16.TextWidth(OriginalName(CurrentSeq))) And Abs(Int((Y - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
                    
                    If CurrentSeq = 0 Then
                        If Index = 0 Or (Index = 3 And (CTF = 0 Or CTF = 1)) Then
                            MaxY = (((NextNo + 1) * AddjNum))
                            If Y - 3 >= 0 Then
                                If Abs(Int((Y - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
                                    CurrentSeq = RYCord(CTF, 0, Abs(Int((Y - 3) / AddjNum)))
                                    
                                End If
                            Else
                                CurrentSeq = RYCord(CTF, 0, 0)
                            End If
                        End If
                        x = x
                    End If
                    If SelGrpFlag = 0 Then
                        MaskSeq(CurrentSeq) = MaskSeq(CurrentSeq) + 1
                        If MaskSeq(CurrentSeq) > 2 Then MaskSeq(CurrentSeq) = 0
                        StoreChanged(CurrentSeq) = MaskSeq(CurrentSeq) + 1
                    Else
                        If GrpMaskSeq(CurrentSeq) >= 1 Then
                            GrpMaskSeq(CurrentSeq) = 0
                            StoreChanged(CurrentSeq) = 4
                        Else
                            GrpMaskSeq(CurrentSeq) = 1
                            StoreChanged(CurrentSeq) = 5
                        End If
                    End If
                    
                    LastCurChange = CurrentSeq
                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
                    
                    'On Error GoTo 0
                End If
                PrintNames
        End If
        
    Else
        Picture16.Enabled = False
        If Picture16.ToolTipText = "Right click for node options" Then
            FastNJMnu2.Visible = False
            SelGrpMnu.Visible = False
            Automaskmnu2.Visible = False
            UnmaskAllMnu2.Visible = False
            MaskAllMnu2.Visible = False
            DisableAllMnu2.Visible = False
            CpyTreeMnu.Visible = False
            SaveNHFMnu.Visible = False
            SaveTreeBmpMnu.Visible = False
            SaveTreeEmfMnu.Visible = False
            TreeOptMnu.Caption = "Determine ancestral sequence at this node"
            PopupMenu TreeMnu
        Else
            FastNJMnu2.Visible = True
            SelGrpMnu.Visible = True
            Automaskmnu2.Visible = True
            UnmaskAllMnu2.Visible = True
            MaskAllMnu2.Visible = True
            DisableAllMnu2.Visible = True
            CpyTreeMnu.Visible = True
            SaveNHFMnu.Visible = True
            SaveTreeBmpMnu.Visible = True
            SaveTreeEmfMnu.Visible = True
            TreeOptMnu.Caption = "Tree Options"
            
            PopupMenu TreeMnu
            
        End If
        Picture16.Enabled = True
    End If
x = x
End Sub

Private Sub Picture16_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim NY As Single, NX As Single
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    If StillCycling = 1 Then Exit Sub
    If CurrentlyRunningFlag = 1 Then Exit Sub
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    
    
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
    
    F2P2Y = -1
    P1Seq = -1
    P1NT = -1
    F1P7X = -1
    F1P2Y = -1
    F1P3Y = -1
    F1P6Y = -1
    F2P3Y = -1
    F1P16Y = Y
    F1P26Y = -1
    F2P2Index = -1
    Dim OY As Single, CurrentSeq As Integer, tTYF As Double, TYFM As Integer, MaxY As Long
    'CurrentSeq = -1
    Index = TreeTypeFlag
    F2TreeIndex = TreeTypeFlag
    OY = Y
    Y = Y + VScroll1.Value * F1VS1ScaleFactor
    Call ModOffsets(8.25, Picture16, tTYF, TYFM)
    Y = Int(Y / tTYF + 1)
    NX = x
    NY = Y
    AddjNum = 14
'Exit Sub
    If Index = 0 Or (Index = 3 And (CTF = 0 Or CTF = 1)) Then
        MaxY = (((NextNo + 1) * AddjNum))
        If Abs(Int((Y - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
            If Y - 3 >= 0 Then
                CurrentSeq = RYCord(CTF, 0, (Abs(Int((Y - 3) / AddjNum))))
                
            Else
                CurrentSeq = RYCord(CTF, 0, 0)
            End If
        End If
    End If
    PRat = TDLen(TreeTypeFlag, CTF, 2) / Form1.Picture16.ScaleWidth
    XMod = TreeXScaleMod(1, TreeTypeFlag, CTF)
    'NX = NX * XMod
    If XMod = 0 Or PRat = 0 Then
        Exit Sub
    End If
    PRat = PRat / XMod
    'this checks if the mouse pointer is over a sequence name
    If x > XCord(CTF, F2TreeIndex, CurrentSeq) / PRat And x < (XCord(CTF, F2TreeIndex, CurrentSeq) / PRat + Picture16.TextWidth(OriginalName(CurrentSeq))) And Abs(Int((Y - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
        
        If TreeTypeFlag = 0 Or (TreeTypeFlag = 3 And (CTF = 0 Or CTF = 1)) Then
            Picture16.MousePointer = 99
        
            If MaskSeq(CurrentSeq) = 0 Then
                Picture16.ToolTipText = "Left click to mask " + OriginalName(CurrentSeq)
            ElseIf MaskSeq(CurrentSeq) = 1 Then
                Picture16.ToolTipText = "Left click to disable " + OriginalName(CurrentSeq)
            ElseIf MaskSeq(CurrentSeq) = 2 Then
                Picture16.ToolTipText = "Left click to enable " + OriginalName(CurrentSeq)
            End If
        End If
        
        If Pic2MD = 1 Then
            
            'If LastOY = -1 Then LastOY = OY
           '
           ' If OY >= LastOY Then
           '     ZZ = 0
           '     For NY = LastOY To OY Step 1 'AddjNum
           '         StillCycling = 1
           '         If Index = 0 Then
           '             MaxY = (((Nextno + 1) * AddjNum))
           '             If Abs(Int((NY - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
           '                 If Y - 3 >= 0 Then
           '                     CurrentSeq = RYCord(CTF, 0, (Abs(Int((NY - 3) / AddjNum))))
           '
           '                 Else
           '                    CurrentSeq = RYCord(CTF, 0, 0)
           '                 End If
           '             End If
           '         End If
                   If CurrentSeq <> LChange And (F2TreeIndex = 0) Then
                        Call Picture16_MouseDown(Button, Shift, x, OY)
                        'LChange = CurrentSeq
                        'NY = NY + 1
            '            If NY > OY Then Exit For
            '            ZZ = ZZ + 1
                   End If
            '    Next NY
            '
            '    If Abs(LastOY - OY) > 50 Then
            '        X = X
            '    End If
            '        LastOY = OY
            '        StillCycling = 0
                
            'Else
            '
            '    For NY = LastOY To OY Step -1 'AddjNum
            '        StillCycling = 1
            '      ' If Index = 0 Then
            '      '      MaxY = (((Nextno + 1) * AddjNum))
            '      '      If Abs(Int((NY - 3) / AddjNum)) < UBound(RYCord, 3) - 1 Then
            '      '          If Y - 3 >= 0 Then
            '      '              CurrentSeq = RYCord(CTF, 0, (Abs(Int((NY - 3) / AddjNum))))
            '      '
            '      '          Else
            '      '              CurrentSeq = RYCord(CTF, 0, 0)
            '      '          End If
            '      '      End If
            '      '  End If
            '       If CurrentSeq <> LChange And (F2TreeIndex = 0) Then
            '            Call Picture16_MouseDown(Button, Shift, X, NY)
            '            LChange = CurrentSeq
            '            If NY <> OY Then
            '                XX = XX
            '            End If
            '       End If
            '    Next NY
            '    LastOY = OY
            '    StillCycling = 0
            'End If
            '    For NY = LastOY To OY Step -1
            '        If CurrentSeq <> LChange And (F2TreeIndex = 0) Then
            '            Call Picture16_MouseDown(Button, Shift, X, NY)
            '
            '        End If
            '    Next NY
            '    LastOY = OY
            'End If
            
            
        End If

    Else
        'check if the mousepointer is over a node
        
        MaybeDisplay = 1
        
        If Index > 0 Then
            UnModNextno
        End If
     
     
    
        NHFlag = -1
        SelectNode(0) = -1
        Call GetNHFlag(Index, CTF, NHFlag)
         
         'check to see if mouse pointer is over a node
        If Index = 0 And CTF = 0 Then
             XMod = TreeXScaleMod(1, 0, 0)
        Else
             XMod = TreeXScaleMod(1, Index, CTF) '1.105 upgma'1.068 fastnj
        End If
        'XMod = XMod / PRat
        
        PRat = TDLen(TreeTypeFlag, CTF, 2) / Form1.Picture16.ScaleWidth '919 - 0.904 '321 - 0.327
        
        PRat = PRat / XMod
       ' XMod = XMod / PRat
        DontRefresh = 0
         Picture16.AutoRedraw = False
         'Form2.Picture2(Index).ToolTipText = "Right Click for Options"
         If NHFlag > -1 Then
             
             If UBound(NodeXY, 1) >= NHFlag Then
                For ZX = 0 To NextNo
                    If UBound(NodeXY, 2) >= ZX Then
                        If NodeXY(NHFlag, ZX, 0) / PRat > NX - 5 And NodeXY(NHFlag, ZX, 0) / PRat < NX + 5 Then '139
                            If NodeXY(NHFlag, ZX, 1) > NY - 5 And NodeXY(NHFlag, ZX, 1) < NY + 5 Then
                                'Mouse pointer is hovering over a node
                                
                                If SelectNode(0) <> ZX Then
                                   ' Picture16.DrawMode = 10
                                    
'                                    Picture16.FillColor = Col
'                                    Picture16.FillStyle = 0
                                    
                                    
                                    
                                    
                                       YPX = Int((NodeXY(NHFlag, ZX, 1)) * tTYF + 1) - VScroll1.Value
                                    
                                    'For A = 1 To 4
                                        
                                        SelectNode(0) = ZX 'the selected node
                                        SelectNode(1) = NodeXY(NHFlag, ZX, 0) / PRat 'adjusted x coordinate of node
                                        SelectNode(2) = YPX 'adjusted y-coordinate of node
                                        SelectNode(3) = NHFlag 'the current tree nhfile
                                        SelectNode(4) = Index 'the pciturebox in the picturebox array
                                        
                                        PermSelectNode(0) = ZX 'the selected node
                                        PermSelectNode(1) = NodeXY(NHFlag, ZX, 0) / PRat 'adjusted x coordinate of node
                                        PermSelectNode(2) = YPX 'adjusted y-coordinate of node
                                        PermSelectNode(3) = NHFlag 'the current tree nhfile
                                        PermSelectNode(4) = Index 'the pciturebox in the picturebox array
                                        If Index = 3 And CurTree(Index) > 1 Then
                                        Else
                                            XX = UBound(TreeDrawColBak, 2)
                                            If TreeDrawColBakFlag(Index) = 0 Then
                                                TDL1 = TDLen(Index, CTF, 1)
                                                For x = 0 To TDL1
                                                    If UBound(TreeDrawColBak, 1) >= x Then
                                                        TreeDrawColBak(x, Index) = TreeDrawB(4, x, Index, CTF, 1)
                                                    End If
                                                Next x
                                                TreeDrawColBakFlag(Index) = 1
                                                'XX = Nextno
                                            End If
                                            'FInd Y flashing bounds
                                            
                                            Dim NodeFind() As Byte, UBNF As Long, IncSeq() As Long, AH1 As Long, AH2 As Long
                                            ReDim IncSeq(PermNextno)
                                            UnModNextno
                                            Call MakeNodeFind(NodeFind(), SelectNode(3))
                                            UBNF = UBound(NodeFind, 2)
                                            
                                            YFlashBound(1) = 0
                                            YFlashBound(0) = 1000000
                                            UnModNextno
                                            If SelectNode(4) = 0 Or (SelectNode(4) = 3 And (CTF = 0 Or CTF = 1)) Then
                                                'If SelectNode(4) = 0 Then
                                                    For A = 0 To TDLen(Index, CTF, 0)
                                                        'If SelectNode(4) = 0 Then
                                                            AH2 = TreeDrawB(2, A, Index, CTF, 0) 'the sequence number
        '                                                Else
        '                                                    AH2 = TreeTrace(TreeDrawB(2, A, Index, CurTree(Index), 0))
        '                                                End If
                                                        AH1 = TreeDrawB(1, A, Index, CTF, 0) '* TSingle 'y cocord
                                                        
                                                        If AH2 >= 0 And AH2 <= UBNF Then
                                                            If NodeFind(ZX, AH2) = 1 Then
                                                                If YFlashBound(1) < AH1 Then
                                                                    YFlashBound(1) = AH1
                                                                End If
                                                                If YFlashBound(0) > AH1 Then YFlashBound(0) = AH1
                                                            End If
                                                        End If
                                                    Next A
                                            Else
                                                Call ModNextno
                                                'XX = Nextno
                                                For A = 0 To TDLen(Index, CTF, 0)
                                                    
                                                    If A <= UBound(TreeTrace, 1) + 1 And TreeDrawB(2, A, Index, CTF, 0) > -1 Then
                                                        AH2 = TreeTrace(TreeTraceSeqs(1, (TreeDrawB(2, A, Index, CTF, 0))))
                                                        'AH2 = TreeDrawB(2, A, Index, CurTree(Index), 0)
                                                        AH1 = TreeDrawB(1, A, Index, CTF, 0) '* TSingle 'y cocord
                                                        
                                                        If AH2 >= 0 And AH2 <= UBNF Then
                                                            If NodeFind(ZX, AH2) = 1 Then
                                                                If YFlashBound(1) < AH1 Then
                                                                    YFlashBound(1) = AH1
                                                                End If
                                                                If YFlashBound(0) > AH1 Then YFlashBound(0) = AH1
                                                            End If
                                                        Else
                                                            x = x
                                                        End If
                                                    Else
                                                        x = x
                                                    End If
                                                Next A
                                            End If
                                            'YFlashBound(0) = NodeXY(NHFlag, ZX, 1) - 30
                                            YFlashBound(1) = YFlashBound(1) + 12 'NodeXY(NHFlag, ZX, 1) + 30
                                            XFlashbound = CLng(CLng((NodeXY(NHFlag, ZX, 0) - 0.5) / PRat))
                                            
                                             x = x
                                            
    '                                        YFlashBound(0) = 0
    '                                        YFlashBound(1) = 100000
    '                                        For X = 0 To TDL1
    '                                            If TreeDrawB(2, X, Index, CurTree(Index), 1) > NodeXY(NHFlag, ZX, 0) Then
    '                                                If YFlashBound(0) < NodeXY(NHFlag, ZX, 1) Then YFlashBound(0) = NodeXY(NHFlag, ZX, 1)
    '                                                If YFlashBound(1) > NodeXY(NHFlag, ZX, 1) Then YFlashBound(1) = NodeXY(NHFlag, ZX, 1)
    '                                            End If
    '
    '                                        Next X
    
                                            BranchFlashFlag = 2
                                            Form1.Timer1.Enabled = True
                                            'Form2.Picture2(Index).Circle (NodeXY(NHFlag, ZX, 0) * XMod, YPX - 1), 4, Col2 'draws the node dot (most commonly used)
                                        
                                        
                                        End If
                                        'Sleep 100
                                        'Form2.Picture2(Index).Refresh
                                        
                                    'Next A
                                    'XX = Nextno
                                    
                                   
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    DontRefresh = 1
                                Else
                                    'Form2.Picture2(Index).ToolTipText = "Right Click for Node Options"
                                    DontRefresh = 1
                                End If
                                
                                If Picture16.ToolTipText <> "Right click for node options" Then
                                    Picture16.ToolTipText = "Right click for node options"
                                    F1P16LastTooltip(1) = OY
                                    F1P16LastTooltip(0) = x
                                End If
                                DontRefresh = 1
                                If Picture16.MousePointer <> 99 Then
                                    'Form2.Picture2(Index).ToolTipText = "Right Click for Node Options"
                                    Picture16.MousePointer = 99
                                End If
                                MaybeDisplay = 0
                                Exit For
                            Else
                                'Picture16.MousePointer = 0
                                'Picture16.ToolTipText = "Right click for options"
                                'Form2.Picture2(Index).ToolTipText = "Right Click for Options"
                            End If
                        Else
                            'Picture16.MousePointer = 0
                            'Picture16.ToolTipText = "Right click for options"
                        End If
                    End If
                Next ZX
             Else
                Picture16.MousePointer = 0
                Picture16.ToolTipText = "Right click for options"
                SelectNode(0) = -1
             End If
             If DontRefresh = 0 Then
                 'Form2.Picture2(Index).MousePointer = 0
                 'Picture16.DrawMode = 10
                 'Form2.Picture2(Index).ToolTipText = "Right Click for Options"
                 Picture16.FillColor = Col
                 Picture16.FillStyle = 0
                 If SelectNode(1) > 0 And SelectNode(2) > 0 And NHFlag = SelectNode(3) And SelectNode(0) > -1 Then 'this erases the dot
                     Picture16.FillStyle = 0
                     
                     
                     
                 End If
                 'SelectNode(0) = -1
             End If
         Else
            Picture16.Refresh
            Picture16.MousePointer = 0
            Picture16.ToolTipText = "Right click for options"
            F1P16LastTooltip(1) = OY
            F1P16LastTooltip(0) = x
            F2P2SNum = -1
            MaybeDisplay = 0
            'PermSelectNode(0) = -1
            SelectNode(0) = -1
         End If
        x = x
        
    End If
    If MaybeDisplay = 1 Then
        'Picture2(Index).Refresh
        Picture16.MousePointer = 0
        Picture16.ToolTipText = "Right click for options "
        F1P16LastTooltip(1) = OY
        F1P16LastTooltip(0) = x
        'PermSelectNode(0) = -1
        SelectNode(0) = -1
        'Picture2(Index).ToolTipText = "Right Click for Options"
     End If
     Picture16.DrawMode = 13
End Sub

Private Sub Picture16_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim CS As Long, RV As Byte
Dim tTYF As Double, TYFM As Integer
Pic2MD = 0
LChange = -1
LastOY = -1

    Y = Y + VScroll1.Value
    Call ModOffsets(8.25, Picture16, tTYF, TYFM)
    Y = Int(Y / tTYF + 1)
    OldFontSize = 8.25
    Dim CurrentSeq As Integer

    If TwipPerPix = 12 Then AddjNum = 14 Else AddjNum = 14
    Index = TreeTypeFlag
    F2TreeIndex = TreeTypeFlag
    If x = x Then
        'MaxY = (Nextno + 1) * AddjNum
        'If Y < MaxY Then CurrentSeq =
        For Z = 0 To NextNo
            'CS = RYCord(CTF, 0, Z)
            If StoreChanged(RYCord(CTF, Index, Z)) > 0 Then
                For A = Z + 1 To NextNo
                    If StoreChanged(RYCord(CTF, Index, A)) = 0 Then
                        'If A <> Z Then
                            For b = A + 1 To NextNo
                                If StoreChanged(RYCord(CTF, Index, b)) > 0 Then
                                    If StoreChanged(RYCord(CTF, Index, b)) < 4 Then 'its a mask operation
                                        RV = StoreChanged(RYCord(CTF, Index, Z)) - 1
                                        For C = A To b - 1
                                            MaskSeq(RYCord(CTF, Index, C)) = RV
                                        Next C
                                    Else 'its a grpmask operation
                                        RV = StoreChanged(RYCord(CTF, Index, Z)) - 4
                                         For C = A To b - 1
                                            GrpMaskSeq(RYCord(CTF, Index, C)) = RV
                                        Next C
                                        
                                    End If
                                    Exit For
                                End If
                            Next b
                        'End If
                        Z = b - 1
                        Exit For
                    End If
                Next A
                'Exit For
            End If
        Next Z
        If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(StoreChanged, 1)
        ReDim StoreChanged(UB)
        On Error GoTo 0
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    ElseIf Index = 1 Then
        MaxY = (NextNo + 2) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(1), 1, Abs(Int((Y - 3) / AddjNum)))
    ElseIf Index = 2 Then
        MaxY = (NextNo + 1) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(2), 2, Abs(Int((Y - 3) / AddjNum)))
    ElseIf Index = 3 Then
        MaxY = (NextNo + 1) * AddjNum
        If Y < MaxY Then CurrentSeq = RYCord(CurTree(3), 3, Abs(Int((Y - 3) / AddjNum)))
    End If


End Sub

Private Sub Picture16_Paint()
Picture16.AutoRedraw = True

'This checks to see whether the drawing op is going to work or not.
Pict = 0
If DebuggingFlag < 2 Then On Error Resume Next
Pict = Picture16.hdc
On Error GoTo 0
Index = TreeTypeFlag
If Pict = 0 Then
    If TwipPerPix = 12 Then AddjNum = 14 Else AddjNum = 14
    OldFontSize = 8.25
    Picture16.AutoRedraw = False
    Picture16.ScaleMode = 3
    For CurrentSeq = 0 To NextNo
            Picture16.CurrentY = YCord(CurTree(Index), Index, CurrentSeq)
            Picture16.CurrentX = XCord(CurTree(Index), Index, CurrentSeq)
            
            If ((CurrentSeq <> Seq1 And CurrentSeq <> Seq2 And CurrentSeq <> Seq3) Or (RelX = 0 And RelY = 0)) And TreeTypeFlag = 0 Then 'And MultColour(CurrentSeq) > 0 Then
                    
                    A = Picture16.CurrentX
                    b = Picture16.CurrentY
                    Picture16.Line (A, b + 3)-(A + 1500, b + AddjNum + 1), BackColours, BF
                    Picture16.CurrentX = A
                    Picture16.CurrentY = b
                    'picture16.print originalname(CurrentSeq)
                    If MaskSeq(CurrentSeq) = 0 Then
                        Picture16.ForeColor = 0
                    ElseIf MaskSeq(CurrentSeq) = 1 Then
                        Picture16.ForeColor = 8
                    ElseIf MaskSeq(CurrentSeq) = 2 Then
                        Picture16.ForeColor = ThreeQuaterColour
                    End If
                    Picture16.Print OriginalName(CurrentSeq)
                    
                
                'On Error GoTo 0
            Else
                A = Picture16.CurrentX
                b = Picture16.CurrentY
                Picture16.Line (A, b + 3)-(A + 1500, b + AddjNum + 1), BackColours, BF
                Picture16.CurrentX = A
                Picture16.CurrentY = b
                If CurrentSeq = Seq2 Then
                    
                    'picture16.print originalname(CurrentSeq)
                    
                    If OutsideFlagX = 2 Then
                        Picture16.ForeColor = RGB(0, 0, 128)
                    Else
                        Picture16.ForeColor = RGB(0, 0, 255)
                    End If
                    Picture16.Print OriginalName(Seq2)
                ElseIf CurrentSeq = Seq1 Then
                    
                    If OutsideFlagX = 1 Then
                        Picture16.ForeColor = RGB(0, 0, 128)
                    Else
                        Picture16.ForeColor = RGB(0, 0, 255)
                    End If
                    Picture16.Print OriginalName(Seq1)
                    
                Else
                    
                
                    Picture16.ForeColor = RGB(255, 0, 0)
                    
                    Picture16.Print OriginalName(Seq3)
                End If
                Picture16.ForeColor = 0
            End If
    
    Next 'CurrentSeq
    Picture16.AutoRedraw = True

End If
End Sub

Private Sub Picture17_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
Timer3.Enabled = False
If Button = 2 Then
    If CurMatrixFlag <> 0 Then
       
        PopupMenu ColMnu
    End If
End If
End Sub

Private Sub Picture18_Click()
Timer3.Enabled = False
End Sub

Private Sub Picture19_Click()
x = x
End Sub

Private Sub Picture2_KeyDown(KeyCode As Integer, Shift As Integer)
Call DoKeydown(KeyCode)

RecSeq = 0: PAVal = 0
'DSP2Flag = 1
If KeyCode = vbKeyPageUp Or KeyCode = vbKeyLeft Then
    Call GoToPreviousEventMnu_Click
    
    KPFlag = 1
ElseIf KeyCode = vbKeyPageDown Or KeyCode = vbKeyRight Then
    Call GoToNextEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeySpace Then
    Call GoToBestMnu_Click
End If
'DSP2Flag = 0
'Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
If RIMode = 0 Then
    If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
End If
End Sub

Private Sub Picture2_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim PerX As Single, PerY As Single
Dim NewR As Long, NewG As Long, NewB As Long
PerX = x
PerY = Y



Dim DontFlash As Byte
 If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
     Screen.MousePointer = 0
 End If

 If RIMode = 0 Then
    If Picture6.Enabled = True Then
        Picture6.SetFocus
    End If
 End If

 
 Dim Pict As Long
 Dim PntAPI As POINTAPI
 Dim b1 As Long, g1 As Long, r1 As Long, b2 As Long, g2 As Long, r2 As Long
 Dim Extra As Integer
 If PermNextno <> NextNo Then
    UnModNextno
 End If
 
 If RIMode = 1 Then
     If OverviewSeq > -1 Then
         If Button = 2 Then
             RCAllFlag = 1
             If AcceptAllMnuFlag <> 2 Then
                Form1.RSortMnu2.Caption = "Accept all events in this table"
                Form1.RSortMnu2.Visible = True
                AcceptAllMnuFlag = 1
             Else
                Form1.RSortMnu2.Caption = "Un-accept all events in this table"
                Form1.RSortMnu2.Visible = True
                AcceptAllMnuFlag = 2
             End If
             'Form1.GoToEventMnu.Visible = True
             Form1.RCheckMnu.Visible = True
             MenuUpFlag = 1
             SERecSeq = BestEvent(OverviewSeq, 0)
             SEPAVal = BestEvent(OverviewSeq, 1)
             Form1.RCheckMnu.Caption = "Re-Check all recombination events with all methods"
             Form1.SwapMajorMinorMnu.Enabled = True
             Form1.ReassignMajorMnu.Caption = "Make the major parent (" & OriginalName(XoverList(SERecSeq, SEPAVal).MajorP) & ") the recombinant"
             Form1.ReassignMinorMnu.Caption = "Make the minor parent (" & OriginalName(XoverList(SERecSeq, SEPAVal).MinorP) & ") the recombinant"
             Form1.SwapMajorMinorMnu.Caption = "Swap major (" & OriginalName(XoverList(SERecSeq, SEPAVal).MajorP) & ") and minor parent (" & OriginalName(XoverList(SERecSeq, SEPAVal).MinorP) & ")"
             
             
             
             
             If XoverList(SERecSeq, SEPAVal).Accept = 1 Then
                 Form1.AcceptMnu.Enabled = False
                 Form1.AcceptSMnu.Enabled = False
                 Form1.AcceptMnu.Visible = False
                 Form1.AcceptSMnu.Visible = False
             Else
                 Form1.AcceptMnu.Enabled = True
                 Form1.AcceptSMnu.Enabled = True
                 Form1.AcceptMnu.Visible = True
                 Form1.AcceptSMnu.Visible = True
             End If
             
             If XoverList(SERecSeq, SEPAVal).Accept = 2 Then
                 Form1.RejectMnu.Enabled = False
                 Form1.RejectSMnu.Enabled = False
                 Form1.RejectMnu.Visible = False
                 Form1.RejectSMnu.Visible = False
             Else
                 Form1.RejectMnu.Enabled = True
                 Form1.RejectSMnu.Enabled = True
                 Form1.RejectMnu.Visible = True
                 Form1.RejectSMnu.Visible = True
             End If
             
             
             ENxx = OverviewSeq
             A = 0
             If Form1.RejectSMnu.Enabled = True Or Form1.AcceptSMnu.Enabled = True Then
                 If ExcludedEventNum > 0 Then
                    A = SumEventCount(ENxx)
                Else
                    A = 0
                    For Z = 0 To NextNo
                        If Daught(ENxx, Z) > 0 Then
                            A = A + 1
                            
                        End If
                    Next Z
                End If
                 If A = 1 Then
                     Form1.RejectSMnu.Visible = False
                     Form1.AcceptSMnu.Visible = False
                     If XoverList(SERecSeq, SEPAVal).Accept = 1 Then
                        Form1.AcceptMnu.Visible = False
                        Form1.RejectMnu.Caption = "Un-accept this event"
                    ElseIf XoverList(SERecSeq, SEPAVal).Accept = 2 Then
                        Form1.RejectMnu.Visible = False
                        Form1.AcceptMnu.Caption = "Un-reject this event"
                    ElseIf XoverList(SERecSeq, SEPAVal).Accept = 0 Then
                        Form1.RejectMnu.Caption = "Reject this event"
                        Form1.AcceptMnu.Caption = "Accept this event"
                    End If
                 Else
                     Form1.RejectMnu.Visible = False
                     Form1.AcceptMnu.Visible = False
                     If XoverList(SERecSeq, SEPAVal).Accept = 0 Then
                        Form1.RejectSMnu.Caption = "Reject this event in all " + Trim(Str(A)) + " sequences where it is found"
                        Form1.AcceptSMnu.Caption = "Accept this event in all " + Trim(Str(A)) + " sequences where it is found"
                     ElseIf XoverList(SERecSeq, SEPAVal).Accept = 1 Then
                        Form1.RejectSMnu.Caption = "Un-accept this event in all " + Trim(Str(A)) + " sequences where it is found"
                        Form1.AcceptSMnu.Visible = False
                     ElseIf XoverList(SERecSeq, SEPAVal).Accept = 1 Then
                        Form1.RejectSMnu.Visible = False
                        Form1.AcceptSMnu.Caption = "Un-reject this event in all " + Trim(Str(A)) + " sequences where it is found"
                     End If
                 End If
             End If
                 
             Form1.ReassignMajorMnu.Enabled = True
             Form1.ReassignMinorMnu.Enabled = True
             Form1.PopupMenu Form1.SchemEditMnu
         Else 'button=1
             Tot = 0
             For x = 0 To UBound(FoundMethods, 2)
                 Tot = Tot + FoundMethods(OverviewSeq, x)
             Next x
             If Tot > ConsensusProg Then
                 If P2Method > -1 Then
                     If P2PD = 0 Then
                         
                         OVS = P2Method
                         
                         Do
                            OverviewSeq = OverviewSeq - 1
                            If OverviewSeq <= 0 Then OverviewSeq = SEventNumber - OverviewSeq
                            If OverviewSeq > UBound(BestEvent, 1) Then
                                Exit Sub
                            End If
                            RelX = BestEvent(OverviewSeq, 0)
                            RelY = BestEvent(OverviewSeq, 1)
                            If RelX > 0 And RelY > 0 Then Exit Do
                         Loop
                         Dim oAcc As Byte, oRej As Byte
                         oAcc = SkipAcceptedMnu.Checked
                         oRej = SkipRejectedMnu.Checked
                         SkipAcceptedMnu.Checked = False
                         SkipRejectedMnu.Checked = False
                         If P2Method = 5 Then
                            CurrentCheck = 5
                         End If
                         SS = Abs(GetTickCount)
                        ' DSP2Flag = 1
                         GoToNextEventMnu_Click
                         'DSP2Flag = 0
                         EE = Abs(GetTickCount)
                         TT = EE - SS
                         
                         'End If
                         SkipAcceptedMnu.Checked = oAcc
                         SkipRejectedMnu.Checked = oRej
                         DontDoComboFlag = 1
                         If P2Method = 0 Then
                         
                             CurrentCheck = 0
                             Combo1.ListIndex = 0
                         ElseIf P2Method = 1 Then
                             CurrentCheck = 1
                             Combo1.ListIndex = 1
                         ElseIf P2Method = 2 Then
                             CurrentCheck = 3
                             Combo1.ListIndex = 3
                         ElseIf P2Method = 3 Then
                             CurrentCheck = 4
                             Combo1.ListIndex = 4
                         ElseIf P2Method = 4 Then
                             CurrentCheck = 5
                             Combo1.ListIndex = 5
                             
                         ElseIf P2Method = 5 Then
                         
                             CurrentCheck = 6
                             'DontDoComboFlag = 0
                             Combo1.ListIndex = 6
                         ElseIf P2Method = 8 Then
                             CurrentCheck = 9
                             Combo1.ListIndex = 7
                         End If
                         DontDoComboFlag = 0
                     Else
                         If P2Method = 0 Then
                             Combo1.ListIndex = 0
                         ElseIf P2Method = 1 Then
                             Combo1.ListIndex = 1
                         ElseIf P2Method = 2 Then
                             Combo1.ListIndex = 3
                         ElseIf P2Method = 3 Then
                             Combo1.ListIndex = 4
                         ElseIf P2Method = 4 Then
                             Combo1.ListIndex = 5
                         ElseIf P2Method = 5 Then
                             Combo1.ListIndex = 6
                         ElseIf P2Method = 8 Then
                             Combo1.ListIndex = 7
                         End If
                     End If
                 ElseIf P2Method = -1 Then
                     If P2CurE = -1 Then
                         OVS = -1
                         Do
                            OverviewSeq = OverviewSeq - 1 'this is accessed by going through goto next event
                            If OverviewSeq < 1 Then OverviewSeq = SEventNumber - OverviewSeq
                            If OverviewSeq > UBound(BestEvent, 1) Then
                                Exit Sub
                            End If
                            RelX = BestEvent(OverviewSeq, 0)
                            RelY = BestEvent(OverviewSeq, 1)
                            If RelX > 0 Or RelY > 0 Then Exit Do
                         Loop
                         'Dim oAcc As Byte, oRej As Byte
                         oAcc = SkipAcceptedMnu.Checked
                         oRej = SkipRejectedMnu.Checked
                         SkipAcceptedMnu.Checked = False
                         SkipRejectedMnu.Checked = False
                         CurE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                         'Call MakeSummary
                         'Form1.Picture2.Refresh
                         SS = Abs(GetTickCount)
                         DSP2Flag = 1 'stops scrolling of picture 2
                         GoToNextEventMnu_Click
                         DSP2Flag = 0
                         RecSeq = 0
                         PAVal = 0
                         EE = Abs(GetTickCount)
                         TT = EE - SS
                         Call MakeSummary
                         'Form1.Picture2.Refresh
                         SkipAcceptedMnu.Checked = oAcc
                         SkipRejectedMnu.Checked = oRej
                     Else
                         Call GotoSeqInSchem(P2CurE)
                     End If
                 End If
             End If
         End If
     End If
 ElseIf RIMode = 0 Then
 
 
     If GTCS <> -1 And ((RelX > 0 Or RelY > 0) Or SelectedSeqNumber > -1) And ManFlag = -1 Then
         
         If Button = 2 Then
            If GTCS = -2 Then
                If XoverList(RelX, RelY).SBPFlag = 2 Then
                    XoverList(RelX, RelY).SBPFlag = 0
                ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                    XoverList(RelX, RelY).SBPFlag = 1
                ElseIf XoverList(RelX, RelY).SBPFlag = 1 Then
                    XoverList(RelX, RelY).SBPFlag = 3
                ElseIf XoverList(RelX, RelY).SBPFlag = 0 Then
                    XoverList(RelX, RelY).SBPFlag = 2
                End If
            ElseIf GTCS = -3 Then
                If XoverList(RelX, RelY).SBPFlag = 1 Then
                    XoverList(RelX, RelY).SBPFlag = 0
                ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                    XoverList(RelX, RelY).SBPFlag = 2
                ElseIf XoverList(RelX, RelY).SBPFlag = 2 Then
                    XoverList(RelX, RelY).SBPFlag = 3
                ElseIf XoverList(RelX, RelY).SBPFlag = 0 Then
                    XoverList(RelX, RelY).SBPFlag = 1
                
                End If
            End If
            
            If GTCS = -2 Or GTCS = -3 Then
            
            
                If PermXVal > 0 Or PermYVal > 0 And (RecSeq <> RelX Or PAVal <> RelY) Then
                    PAVal = RelY
                    
                    RecSeq = RelX
                    'XX = VScroll2.Max
                    DontPutForm2Ontop = 1
                    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - (VScroll2.Value * F1VS2Adj))
                    DontPutForm2Ontop = 0
                
                Else
                    Call MakeRecombinationInfo(RelX, RelY)
                End If
                
                Picture2.Refresh
            End If
         ElseIf Button = 1 Then
            If GTCS = -2 Or GTCS = -3 Then
                Dim Tw1 As Single, GoPos As Single
                If P1FontSize <> 0 Then
                    Picture1.FontSize = P1FontSize * TYF
                End If
                Dim tTYF As Double, TYFM As Integer
                Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
                Tw1 = Form1.Picture1.TextWidth("A")
                Tw1 = Form1.Picture9.ScaleWidth / Tw1 / 2
                
                If GTCS = -2 Then
                    GoPos = Decompress(XoverList(RelX, RelY).Ending)
                ElseIf GTCS = -3 Then
                    GoPos = Decompress(XoverList(RelX, RelY).Beginning)
                End If
                Dim H1V As Long
                If GoPos > Tw1 And GoPos < Decompress(Len(StrainSeq(0)) - Tw1) Then
                    H1V = CLng(((GoPos - Tw1))) 'CLng(((GoPos - Tw1) / (Decompress(Len(StrainSeq(0))) - Tw1 * 2)) * HScroll1.Max)
                    If H1V >= 0 And H1V <= HScroll1.Max Then
                        HScroll1.Value = H1V
                    End If
                    
                ElseIf GoPos <= Tw1 Then
                    HScroll1.Value = HScroll1.Min
                Else
                    HScroll1.Value = HScroll1.Max
                End If
            End If
            
'            If GTCS = -2 Then
'                HScroll1.Value = CLng((XOverlist(RecSeq, PAVal).Ending / Len(StrainSeq(0))) * HScroll1.Max)
'            ElseIf GTCS = -3 Then
'                HScroll1.Value = CLng((XOverlist(RecSeq, PAVal).Beginning / Len(StrainSeq(0))) * HScroll1.Max)
'            End If
            
         End If
         If GTCS <= -1 And GTCS > -4 Then
             DontFlash = 1
             If Form1.HScroll3.Value = 0 Then
                 Form1.HScroll3.Value = 1
             Else
                 Form1.HScroll3.Value = 0
             End If
         ElseIf GTCS = -4 Then ' do the event menu
             Call SelEventMnu_Click
         ElseIf GTCS > -1 Then
             DontFlash = 0
             FlashY = -1
             Dim OldVal As Long, NewVal As Long
             For Y = 0 To UBound(PermArray, 2)
                 If PermArray(0, Y) = GTCS Then
                     
                     OldVal = VScroll2.Value
                     Y = ((Y * 12 + 3) * SpaceAdjust)
                     If VScroll2.Max > 0 Then
                         If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
                             If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
                                 NewVal = CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
                                 'CLng((y - Picture6.ScaleHeight / 2) / F1VS2Adj)
                             Else
                                 NewVal = 0
                             End If
                         Else
                             NewVal = VScroll2.Max
                         End If
                     End If
                     Call ScrollToVSPos(VScroll2, OldVal, NewVal)
                     
                     
                     
                     PermFlashY = Y
                     Y = CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
                     
                     
                     
                     Picture6.Refresh
                     
                     If x = 12345 Then
                         
                         Picture6.AutoRedraw = False
                         Picture6.DrawMode = 13
                         Picture6.DrawWidth = 2
                         For Z = 0 To 510 Step 5
                             If Z > 255 Then
                                 CVal = 510 - Z
                             Else
                                 CVal = Z
                             End If
                             'Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 12), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255)), B
                             Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 11), RGB(BkR + (255 - BkR) * (CVal / 255), BkG - BkG * (CVal / 255), BkB - BkB * (CVal / 255)), B
                             
                             DS = Abs(GetTickCount)
                             Do
                                 ES = Abs(GetTickCount)
                                 If ES - DS <> 0 Then Exit Do
                                 
                             Loop
                         Next Z
                         'VScroll2.Value = (((Y * 12 + 3) * SpaceAdjust + 10) / Picture6.ScaleHeight) * VScroll2.Max
                         Picture6.AutoRedraw = True
                         Picture6.DrawMode = 13
                         Picture6.DrawWidth = 1
                     Else
                         FlashCol = 510
                     End If
                     FlashY = Y 'CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
                     Timer1.Enabled = True
                     Call Timer1_Timer
                     Exit For
                 End If
             Next Y
         End If
     ElseIf ManFlag = -1 Then
         If RecSeq > 0 Or PAVal > 0 Then
             If GTCS = -4 Then
                 Call SelEventMnu_Click ' do the event menu
             End If
         End If
            
     End If
     
     If ManFlag = 1 Then Extra = 1
 
     If ManFlag = 1 Then Extra = 1
     If ManFlag = 161 And Button = 2 Then
        
        Picture2.Enabled = False
        CpyTreeMnu.Visible = False
        SaveTreeBmpMnu.Visible = False
        SaveTreeEmfMnu.Visible = False
        FastNJMnu2.Visible = False
        SelGrpMnu.Visible = False
        Automaskmnu2.Visible = False
        UnmaskAllMnu2.Visible = False
        MaskAllMnu2.Visible = False
        DisableAllMnu2.Visible = False
        TreeOptMnu.Visible = False
        CSVFlag = 1
        SaveNHFMnu.Caption = "Save result to .csv file"
        PopupMenu TreeMnu
        CSVFlag = 0
        'restore treemnu
        SaveNHFMnu.Caption = "Save tree in Newick format"
        CpyTreeMnu.Visible = True
        SaveTreeBmpMnu.Visible = True
        SaveTreeEmfMnu.Visible = True
        FastNJMnu2.Visible = True
        SelGrpMnu.Visible = True
        Automaskmnu2.Visible = True
        UnmaskAllMnu2.Visible = True
        MaskAllMnu2.Visible = True
        DisableAllMnu2.Visible = True
        TreeOptMnu.Visible = True
        Picture2.Enabled = True
        
     ElseIf (P2YVal > 0 Or (P2YVal = 0 And ManFlag = 10)) And P2YVal <= NumberOfSeqs + Extra Then
         ReDim Preserve RevSeq(NumberOfSeqs)
         
         
         
         XFactor = (Form1.Picture7.ScaleWidth - 40) / Decompress(Len(StrainSeq(0)))
         x = P2YVal
         If Button = 2 Then
            Form7.Visible = False
            Form7.Left = PerX + Picture32.Left + SSPanel6(0).Left
            Form7.Top = PerY + Picture32.Top + SSPanel6(0).Top
            
            If RIMode <> 0 Then
            With Form7.CommonDialog1
                If DebuggingFlag < 2 Then On Error Resume Next
                .CancelError = True
                
                .Action = 3 'Specify that the "colour" action is required.
                'Stores selected colour in the string, SelCol.
                
                If Err.Number = &H7FF3 Then
                    On Error GoTo 0
        ' Cancel clicked
                Else
                    On Error GoTo 0
                    SelCol = .Color
                    
                    Dim oldCol As Long
                    If x > UBound(RevSeq, 1) Then x = 0
                    oldCol = SeqCol(RevSeq(x))
                    SeqCol(RevSeq(x)) = SelCol
                    b1 = Int(SelCol / 65536)
                    g1 = Int((SelCol - b1 * 65536) / 256)
                    r1 = Int(SelCol - b1 * 65536 - g1 * 256)
                    
                    NewR = BkR - (BkR - r1) / 2
                    NewG = BkG - (BkG - g1) / 2
                    NewB = BkB - (BkB - b1) / 2
                    If NewR > 255 Then NewR = 255
                    If NewR < 0 Then NewR = 0
                    If NewG > 255 Then NewG = 255
                    If NewG < 0 Then NewG = 0
                    If NewB > 255 Then NewB = 255
                    If NewB < 0 Then NewB = 0
                    FFillCol(RevSeq(x)) = RGB(NewR, NewG, NewB)
                    UB = UBound(GPrintCol, 1)
                    For Z = 0 To UB
                        If GPrintCol(Z) = oldCol Then
                            GPrintCol(Z) = SelCol
                        End If
                    Next Z
                    
                End If
            End With
            End If
         End If
         
         
         If x <= NumberOfSeqs And x >= 0 Then
             
             Bak = SeqCol(RevSeq(x))
         ElseIf x = NumberOfSeqs + 1 Then
             Bak = SeqCol(RevSeq(0))
         End If
 
         b1 = Int(Bak / 65536)
         g1 = Int((Bak - b1 * 65536) / 256)
         r1 = Int(Bak - b1 * 65536 - g1 * 256)
         
         NewR = BkR - (BkR - r1) / 2
         NewG = BkG - (BkG - g1) / 2
         NewB = BkB - (BkB - b1) / 2
         If NewR > 255 Then NewR = 255
         If NewR < 0 Then NewR = 0
         If NewG > 255 Then NewG = 255
         If NewG < 0 Then NewG = 0
         If NewB > 255 Then NewB = 255
         If NewB < 0 Then NewB = 0
         APlot = 0
         If BeginFlashval = 0 And EndFlashval = 0 Then
             Picture7.Refresh
         End If
 
            If ManFlag = 7 Then
                Picture7.AutoRedraw = True
                'Picture7.Picture = LoadPicture()
                 'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
                 Call RedrawPlotAA(1)
                 APlot = x
                 Picture7.AutoRedraw = False
                 
                 'Form1.Picture21.Visible = False
                 Picture7.AutoRedraw = True
                 Picture7.DrawWidth = 3
                 'Picture21.Height = Picture7.Height
                 'Picture21.Width = Picture7.Width + 20
                 Picture7.ForeColor = RGB(NewR, NewG, NewB)
                 PosCount = 0
                 Dummy = MoveToEx(Picture7.hdc, 30 + Decompress((MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                 PosCount = 1
                 Pict = Picture7.hdc
     
                 Do
     
                     If PosCount > Len(StrainSeq(0)) - 3 Then
                         Exit Do
                     ElseIf MCPrintPos(PosCount) = 0 Then
                         Exit Do
                     ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                         Exit Do
                     End If
                     If MCPrintPos(PosCount) <= UBound(Decompress, 1) Then
                        If MCPrintData(x, PosCount) > MaxDistX Then
                        
                        ElseIf MCPrintData(x, PosCount - 1) > MaxDistX Then
                            Dummy = MoveToEx(Pict, 30 + Decompress((MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                        Else
                            Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                        End If
                     End If
                     PosCount = PosCount + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.DrawWidth = 2
                 Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                 PosCount = 0
                 Dummy = MoveToEx(Picture7.hdc, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                 PosCount = 1
                 Pict = Picture7.hdc
     
                 Do
     
                     If PosCount > Len(StrainSeq(0)) - 3 Then
                         Exit Do
                     ElseIf MCPrintPos(PosCount) = 0 Then
                         Exit Do
                     ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                         Exit Do
                     End If
                     If MCPrintPos(PosCount) <= UBound(Decompress, 1) Then
                        If MCPrintData(x, PosCount) > MaxDistX Then
                        
                        ElseIf MCPrintData(x, PosCount - 1) > MaxDistX Then
                            Dummy = MoveToEx(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                        Else
                            Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                        End If
                     End If
                     PosCount = PosCount + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.DrawWidth = 1
                 Picture7.ForeColor = SeqCol(RevSeq(x))
                 PosCount = 0
                 Dummy = MoveToEx(Picture7.hdc, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                 PosCount = 1
                 Pict = Picture7.hdc
     
                 Do
     
                     If PosCount > Len(StrainSeq(0)) - 3 Then
                         Exit Do
                     ElseIf MCPrintPos(PosCount) = 0 Then
                         Exit Do
                     ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                         Exit Do
                     End If
                     If MCPrintPos(PosCount) <= UBound(Decompress, 1) Then
                        If MCPrintData(x, PosCount) > MaxDistX Then
                        
                        ElseIf MCPrintData(x, PosCount - 1) > MaxDistX Then
                            Dummy = MoveToEx(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                        Else
                            Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                        End If
                     End If
                     PosCount = PosCount + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.DrawWidth = 1
     
                 Call DoLegend
     
                 Exit Sub
             ElseIf ManFlag = 4 Or ManFlag = 10 Then
                 'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
                 Call RedrawPlotAA(1)
                 If ManFlag = 10 Then
                    APlot = x + 1
                    If APlot > GPrintNum + 1 Then
                        APlot = -1
                    End If
                 Else
                    APlot = x
                    x = x - 1
                 End If
                 ReDim GOriginalCol(GPrintNum)
                 'Dim B1 As Long, G1 As Long, R1 As Long, B2 As Long, G2 As Long, R2 As Long
                 Dim BakC As Long
                 BakC = Picture7.BackColor
                 If APlot > -1 Then
                    For Z = 0 To GPrintNum
                       GOriginalCol(Z) = GPrintCol(Z)
                       
                       b1 = Int(GOriginalCol(Z) / 65536)
                       g1 = Int((GOriginalCol(Z) - b1 * 65536) / 256)
                       r1 = Int(GOriginalCol(Z) - b1 * 65536 - g1 * 256)
                       
                       b2 = Int(BakC / 65536)
                       g2 = Int((BakC - b2 * 65536) / 256)
                       r2 = Int(BakC - b2 * 65536 - g2 * 256)
                       GPrintCol(Z) = RGB(Int(r2 + (r1 - r2) / 3), Int(g2 + (g1 - g2) / 3), Int(b2 + (b1 - b2) / 3))
                      ' GPrintCol(Z) = RGB(128, 128, 128)
                    
                    Next Z
                    If x <= GPrintNum Then
                       GPrintCol(x) = GOriginalCol(x)
                    End If
                    Call RedrawPlotAA(1)
                 
                    For Z = 0 To GPrintNum
                       'GOriginalCol(Z) = GPrintCol(Z)
                       GPrintCol(Z) = GOriginalCol(Z)
                    
                    Next Z
                 Else
                    Call RedrawPlotAA(1)
                 
                 End If
                 
                 'x = x - 1
'                 Picture7.AutoRedraw = True
'                 Picture7.DrawWidth = 3
'                 Picture7.ForeColor = RGB(NewR, NewG, NewB)
'                 PosCount = 1
'                 Pict = Picture7.hdc
'                Dim GA As Single
'                If ManFlag = 10 Then
'                    GA = GPrintMin(1)
'                ElseIf ManFlag = 4 Then
'                    GA = GPrintMin(1) - GPrintMin(0)
'                End If
'
'                 Dummy = MoveToEx(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)), PntAPI)
'
'                 For PosCount = 1 To GPrintLen
'                     'If MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
'                     Dummy = LineTo(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)))
'                     'PosCount = PosCount + 1
'                 Next 'PosCount
'
'                 If BeginFlashval = 0 And EndFlashval = 0 Then
'                     Picture7.Refresh
'                 End If
'                 Picture7.DrawWidth = 2
'                 Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
'                 PosCount = 1
'                 Pict = Picture7.hdc
'
'                 Dummy = MoveToEx(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)), PntAPI)
'
'                 For PosCount = 1 To LenXoverSeq
'                     'If MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
'                     Dummy = LineTo(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)))
'                     'PosCount = PosCount + 1
'                 Next 'PosCount
'
'                 If BeginFlashval = 0 And EndFlashval = 0 Then
'                     Picture7.Refresh
'                 End If
'                 Picture7.DrawWidth = 1
'                 Picture7.ForeColor = SeqCol(RevSeq(x))
'                 PosCount = 1
'                 Pict = Picture7.hdc
'
'                 Dummy = MoveToEx(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)), PntAPI)
'
'                 For PosCount = 1 To LenXoverSeq
'                      'f MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
'                     Dummy = LineTo(Pict, 30 + (Decompress(GPrintPos(0, PosCount))) * XFactor, PicHeight - (15 + GPrint(x - 1, PosCount) / GA * (PicHeight - 35)))
'                     'PosCount = PosCount + 1
'                 Next 'PosCount
'
'                 If BeginFlashval = 0 And EndFlashval = 0 Then
'                     Picture7.Refresh
'                 End If
'                 Picture7.DrawWidth = 1
     
                 Call DoLegend
     
                 Exit Sub
             ElseIf ManFlag = 3 Then
                Call RedrawPlotAA(1)
                 'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
                 APlot = x
                 'XX = Picture7.ScaleMode
                 Picture7.AutoRedraw = True
                 PosCount = 0
                 
                 Picture7.ForeColor = RGB(NewR, NewG, NewB)
                 Picture7.DrawWidth = 3
                 Pict = Form1.Picture7.hdc
                 If x <= UBound(PltVal, 1) Then
                    Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
     
                    Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                        PosCount = PosCount + 1
                        Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                    Loop
                 End If
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 PosCount = 0
                 Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                 Picture7.DrawWidth = 2
                 Pict = Form1.Picture7.hdc
                 If x <= UBound(PltVal, 1) Then
                    Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
        
                    Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                        PosCount = PosCount + 1
                        Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                    Loop
                 End If
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.ForeColor = SeqCol(RevSeq(x))
                 Picture7.DrawWidth = 1
                 Pict = Form1.Picture7.hdc
                 PosCount = 0
                 If x <= UBound(PltVal, 1) Then
                    Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
        
                    Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                        PosCount = PosCount + 1
                        Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                    Loop
                 End If
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.DrawWidth = 1
     
                 Call DoLegend
     
                 Exit Sub
             ElseIf ManFlag = 1 Then
                 Call RedrawPlotAA(1)
                 'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
                 APlot = x
                 Picture7.AutoRedraw = True
     
                 If x = NumberOfSeqs + 1 Then x = 0
                 CurPPos = 0
                 Picture7.ForeColor = RGB(NewR, NewG, NewB)
                 Picture7.DrawWidth = 1
                 Pict = Form1.Picture7.hdc
                 'Exit Sub
     
                 Do While MCPrintData(x, CurPPos) > 0
                     MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     CurPPos = CurPPos + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 CurPPos = 0
                 Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                 Picture7.DrawWidth = 1
                 Pict = Form1.Picture7.hdc
     
                 Do While MCPrintData(x, CurPPos) > 0
                     MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     CurPPos = CurPPos + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.ForeColor = SeqCol(RevSeq(x))
                 Picture7.DrawWidth = 1
                 Pict = Form1.Picture7.hdc
                 CurPPos = 0
     
                 Do While MCPrintData(x, CurPPos) > 0
                     MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                     LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                     CurPPos = CurPPos + 1
                 Loop
     
                 If BeginFlashval = 0 And EndFlashval = 0 Then
                     Picture7.Refresh
                 End If
                 Picture7.DrawWidth = 1
     
                 Call DoLegend
     
                 Exit Sub
            ElseIf ManFlag = 60 Then
                If Button = 2 Then
                    Picture2.Enabled = False
                    CpyTreeMnu.Visible = False
                    SaveTreeBmpMnu.Visible = False
                    SaveTreeEmfMnu.Visible = False
                    CSVFlag = 1
                    SaveNHFMnu.Caption = "Save result to .csv file"
                    PopupMenu TreeMnu
                    CSVFlag = 0
                    'restore treemnu
                    SaveNHFMnu.Caption = "Save tree in Newick format"
                    CpyTreeMnu.Visible = True
                    SaveTreeBmpMnu.Visible = True
                    SaveTreeEmfMnu.Visible = True
                    Picture2.Enabled = True
                End If
                
            ElseIf ManFlag = 161 Then
                If Button = 2 Then
                    Picture2.Enabled = False
                    CpyTreeMnu.Visible = False
                    SaveTreeBmpMnu.Visible = False
                    SaveTreeEmfMnu.Visible = False
                    CSVFlag = 1
                    SaveNHFMnu.Caption = "Save result to .csv file"
                    PopupMenu TreeMnu
                    CSVFlag = 0
                    'restore treemnu
                    SaveNHFMnu.Caption = "Save tree in Newick format"
                    CpyTreeMnu.Visible = True
                    SaveTreeBmpMnu.Visible = True
                    SaveTreeEmfMnu.Visible = True
                    Picture2.Enabled = True
                End If
            End If
        
             If ManFlag = 3 Or ManFlag = 4 Or ManFlag = 7 Or ManFlag = 1 Or ManFlag = 10 Then
                 APlot = 0
     
                 Call DoLegend
     
             End If
     
         End If
     'ElseIf RIMode = 1 Then
     End If



If RIMode = 0 Then
    
End If
End Sub

Private Sub Picture2_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    If V4Adj = 0 Then V4Adj = 1
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    Dim sty As Long, Tot As Long, P2TextWidth As Single, StringWidth As Long, YPos As Long, AWid As Single, FontSizeAddjust As Single, XLegend As String, p2bc As Long, OH As Byte, CurProt As Long
    
    
    F1P1X = -1
    F1P1Y = -1
    F2P2Y = -1
    P1Seq = -1
    P1NT = -1
    F1P7X = -1
    F1P2Y = Y
    F1P3Y = -1
    F1P6Y = -1
    F2P3Y = -1
    F1P16Y = -1
    F1P26Y = -1
    F2P2Index = -1
    p2bc = Picture2.BackColor
    P2Method = -1
    FontSizeAddjust = Picture2.FontSize / 6.75
    AWid = Picture2.TextHeight("A") + 2
    If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
        Picture6.Refresh
        CurFlash = 0
        Timercheck(1) = 0
        Call Timer1_Timer
        HighlightFlag = 0
        RecSeq = 0
        PAVal = 0
        If RIMode = 1 Then
            Call MakeSummary
        End If
        
    End If
'   If DebuggingFlag < 2 Then On Error Resume Next
'    Dim OSS As Long
'    OSS = SuspendFlash
'    SuspendFlash = 1
'    Picture6.Refresh
'    SuspendFlash = OSS
'    On Error GoTo 0
    
    If RIMode = 1 Then
        
        If Form2.Visible = True And Form2.WindowState = 0 And Form2OnTopFlag = 0 And Form2.hwnd = GetForegroundWindow Then
            Dummy = SetTopMostWindow(Form2.hwnd, True)
            Form2OnTopFlag = 1
           
        End If
        Dim Mode1OS As Single, YPos2 As Single
        AWid = Picture2.TextHeight("A") + 2
        
        YPos2 = (Y + CLng(VScroll4.Value / V4Adj)) - (2 * AWid)
        YPos = Int(YPos2 / AWid) + 1
        'YPos = CLng(YPos / V4Adj)
        If YPos > 0 And YPos <= SEventNumber Then
            
            OverviewSeq = YPos
            
            StringWidth = Form1.Picture2.TextWidth("-") / 2
            Dim Yy As Long
            Dim RMPos(13) As Single
            RMPos(0) = 80
            RMPos(1) = 83.25
            RMPos(2) = 86.5
            RMPos(3) = 89.75
            RMPos(4) = 93
            RMPos(5) = 96.25
            RMPos(6) = 96.25
            RMPos(7) = 96.25
            RMPos(8) = 99.5
            RMPos(9) = 102.25
            P2TextWidth = (((Form1.Picture32.ScaleWidth) / Screen.TwipsPerPixelX) - 10) / 100
            'Command13(3).Height = XX
            'Command13(3).Width = P2TextWidth * RMPos(1) - (P2TextWidth * RMPos(0))
            Dim CBW As Single
            CBW = (P2TextWidth * RMPos(1) - (P2TextWidth * RMPos(0))) / 2
            If DebuggingFlag < 2 Then On Error Resume Next
            Dim CurE As Long
            CurE = -1
            CurE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
            On Error GoTo 0
            
            If YPos = CurE Or x = x Then
                For Yy = 0 To 8
                    If x >= 5 + (P2TextWidth * RMPos(Yy) - CBW) And x <= 5 + (P2TextWidth * RMPos(Yy) + CBW) Then '163.25, 169.75
                        P2Method = Yy
                        If YPos = CurE Then
                            P2PD = 1
                        Else
                            P2PD = 0
                        End If
                        
                        Tot = 0
                        For x = 0 To UBound(FoundMethods, 2)
                            Tot = Tot + FoundMethods(YPos, x)
                        Next x
                        If Tot > ConsensusProg Then
                            Form1.Picture2.MousePointer = 99
                            Screen.MousePointer = 99
                            If P2Method = 0 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the RDP method"
                                
                            ElseIf P2Method = 1 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the GENECONV method"
                            ElseIf P2Method = 2 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the BOOTSCAN method"
                            ElseIf P2Method = 3 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the MAXCHI method"
                            ElseIf P2Method = 4 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the CHIMAERA method"
                            ElseIf P2Method = 5 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the SISCAN method"
                            ElseIf P2Method = 8 Then
                                Form1.Picture2.ToolTipText = "Left click to test recombination event " + Trim(Str(YPos)) + " with the 3SEQ method"
                            End If
                        End If
                        'Command13(3).Visible = True
                        'Command13(3).BackColor = RGB(255, 255, 196)
                        
                        'Command13(3).Top = (Int(Y / XX)) * XX
                        'Command13(3).Left = 5 + (P2TextWidth * RMPos(YY) - Command13(3).Width / 2)
                        'command13(3).ToolTipText
                    ElseIf x < 5 + (P2TextWidth * RMPos(0) - CBW) Then
                        'Command13(3).Visible = False
                        If YPos = CurE Then
                             Form1.Picture2.MousePointer = 99
                            Screen.MousePointer = 99
                            If x >= 5 + (P2TextWidth * 15) And x <= 5 + (P2TextWidth * 35) Then
                                Form1.Picture2.ToolTipText = "Left click to go to " + Trim(OriginalName(RelX)) + ", right click for options"
                                P2CurE = RelX
                            ElseIf x >= 5 + (P2TextWidth * 35) And x <= 5 + (P2TextWidth * 55) Then
                                Form1.Picture2.ToolTipText = "Left click to go to " + Trim(OriginalName(XoverList(RelX, RelY).MajorP)) + ", right click for options"
                                P2CurE = XoverList(RelX, RelY).MajorP
                            ElseIf x >= 5 + (P2TextWidth * 55) And x <= 5 + (P2TextWidth * 75) Then
                                Form1.Picture2.ToolTipText = "Left click to go to " + Trim(OriginalName(XoverList(RelX, RelY).MinorP)) + ", right click for options"
                                P2CurE = XoverList(RelX, RelY).MinorP
                            ElseIf x >= 5 Then
                                If P2Method = -1 Then
                                    If ReassortmentFlag = 1 Then
                                        If Segbound(XoverList(BestEvent(YPos, 0), BestEvent(YPos, 1)).Ending) = 1 And Segbound(XoverList(BestEvent(YPos, 0), BestEvent(YPos, 1)).Beginning) = 1 Then
                                            If Form1.Picture2.ToolTipText <> "Left click to refresh reassortment event " + Trim(Str(YPos)) + ", right click for options" Then
                                                
                                                Form1.Picture2.ToolTipText = "Left click to refresh reassortment event " + Trim(Str(YPos)) + ", right click for options"
                                                Form1.Picture2.MousePointer = 99
                                                Screen.MousePointer = 99
                                            End If
                                        Else
                                            If Form1.Picture2.ToolTipText <> "Left click to refresh recombination event " + Trim(Str(YPos)) + ", right click for options" Then
                                                
                                                Form1.Picture2.ToolTipText = "Left click to refresh recombination event " + Trim(Str(YPos)) + ", right click for options"
                                                Form1.Picture2.MousePointer = 99
                                                Screen.MousePointer = 99
                                            End If
                                        End If
                                    Else
                                        If Form1.Picture2.ToolTipText <> "Left click to refresh recombination event " + Trim(Str(YPos)) + ", right click for options" Then
                                            
                                            Form1.Picture2.ToolTipText = "Left click to refresh recombination event " + Trim(Str(YPos)) + ", right click for options"
                                            Form1.Picture2.MousePointer = 99
                                            Screen.MousePointer = 99
                                        End If
                                    End If
                                End If
                            End If
                            
                        Else
                            P2CurE = -1
                            Tot = 0
                            
                            For x = 0 To UBound(FoundMethods, 2)
                                Tot = Tot + FoundMethods(YPos, x)
                            Next x
                            If YPos <= UBound(BestEvent, 1) Then
                                If BestEvent(YPos, 0) = 0 And BestEvent(YPos, 1) = 0 Then
                                    Form1.Picture2.ToolTipText = "Event " + Trim(Str(YPos)) + " has been merged with some other event"
                                    'Form1.Picture2.ToolTipText = "This event has been merged with some other event" '"Recombination event " + Trim(Str(YPos))
                                    Form1.Picture2.MousePointer = 0
                                    Screen.MousePointer = 0
                                Else
                                    If Tot > ConsensusProg Then
                                        If P2Method = -1 Then
                                            If ReassortmentFlag = 1 Then
                                                If Segbound(XoverList(BestEvent(YPos, 0), BestEvent(YPos, 1)).Ending) = 1 And Segbound(XoverList(BestEvent(YPos, 0), BestEvent(YPos, 1)).Beginning) = 1 Then
                                                    If Form1.Picture2.ToolTipText <> "Left click to go to reassortment event " + Trim(Str(YPos)) + ", right click for options" Then
                                                        
                                                        Form1.Picture2.ToolTipText = "Left click to go to reassortment event " + Trim(Str(YPos)) + ", right click for options"
                                                        Form1.Picture2.MousePointer = 99
                                                        Screen.MousePointer = 99
                                                    
                                                    End If
                                                Else
                                                    If Form1.Picture2.ToolTipText <> "Left click to go to recombination event " + Trim(Str(YPos)) + ", right click for options" Then
                                                        
                                                        Form1.Picture2.ToolTipText = "Left click to go to recombination event " + Trim(Str(YPos)) + ", right click for options"
                                                        Form1.Picture2.MousePointer = 99
                                                        Screen.MousePointer = 99
                                                    
                                                    End If
                                                End If
                                            Else
                                                If Form1.Picture2.ToolTipText <> "Left click to go to recombination event " + Trim(Str(YPos)) + ", right click for options" Then
                                                        
                                                    Form1.Picture2.ToolTipText = "Left click to go to recombination event " + Trim(Str(YPos)) + ", right click for options"
                                                    Form1.Picture2.MousePointer = 99
                                                    Screen.MousePointer = 99
                                                
                                                End If
    
                                            End If
                                        End If
                                    Else
                                        Form1.Picture2.ToolTipText = "Event " + Trim(Str(YPos)) + " was detected by too few methods to be included in the results below "
                                        'Form1.Picture2.ToolTipText = "This event was detected by too few methods to be included in the results below" '"Recombination event " + Trim(Str(YPos))
                                        Form1.Picture2.MousePointer = 0
                                        Screen.MousePointer = 0
                                    End If
                                End If
                            End If
                            'Form1.Picture2.ToolTipText = "Left click to go to recombination event " + Trim(Str(YPos))
                        End If
                        
                        Exit For
                    End If
                Next Yy
            Else
                Command13(3).Visible = False
            End If
            
        Else
            Form1.Picture2.ToolTipText = ""
            Form1.Picture2.MousePointer = 0
            Screen.MousePointer = 0
            OverviewSeq = -1
            Command13(3).Visible = False
        End If
        
        
    ElseIf RIMode = 0 Then
        
        Dim Extra As Integer
        YPos = Int(Y / AWid)
        
        
        
        
        
        If ManFlag > -1 Then
            Call DoLegend
        End If
        If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
            Screen.MousePointer = 0
        End If
        If (PermXVal > 0 Or PermYVal > 0) And (RecSeq <> RelX Or PAVal <> RelY) Then
            
            PAVal = RelY
            RecSeq = RelX
            OH = HighlightFlag
            'HighlightFlag = 0
            
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, 10, 10 - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            
            PAVal = RelY
            RecSeq = RelX
            HighlightFlag = OH
        End If
'        XX = Picture2.FontSize
        'Picture2.FontSize = 6.75
        Dim ModFactor As Double
'        ModFactor = 1 * 1.075 '7.2 / Picture2.FontSize + Abs(1 - 7.2 / Picture2.FontSize) / 2
'        ModFactor = ModFactor / FontSizeAddjust
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
         
        If ManFlag = 60 Then
            CurProt = Int(((Y - 20) / 12) - 1)
            If CurProt >= 0 And CurProt <= PermPDBNo Then
                Picture2.ToolTipText = "From the PDB file " & PDBFileName(ProtInfo(3, CurProt))
            Else
                Picture2.ToolTipText = ""
            End If
        ElseIf ManFlag = 161 Then
            Form1.Picture2.ToolTipText = "Orange p-values < 0.05 imply significantly more breakpoints in the orange region than in the blue region (and vice versa)"
            Picture2.MousePointer = 0
        ElseIf ManFlag > -1 Then    ' = 7 Or ManFlag = 3 Or ManFlag = 4 Or ManFlag = 1 Then
            'If ManFlag = 10 Then P2YVal = P2YVal + 2
            If P2YVal > 0 And P2YVal <= NumberOfSeqs + Extra And (ManFlag = 1 Or ManFlag = 3 Or ManFlag = 4 Or ManFlag = 7 Or ManFlag = 7) Then
                Form1.Picture2.ToolTipText = "Left click to highlight on plot, right click to select a different colour"
            Else
                'Screen.MousePointer = 0
                Form1.Picture2.ToolTipText = ""
            End If
            If SSPanel16.BackColor <> QBColor(8) Then
                
                Call DoLegend
                If Picture7.Picture = 0 Then
                    'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
                    Call RedrawPlotAA(1)
                    If ManFlag = 1 Then
                        XLegend = "-Log(KA-PVal)"
                    ElseIf ManFlag = 3 Then
                        XLegend = "Bootstrap support (%)"
                    ElseIf ManFlag = 4 Then
                        XLegend = "-Log[P(Chi2)]"
                    ElseIf ManFlag = 5 Then
                        XLegend = "Log likelihood ratio"
                    ElseIf ManFlag = 7 Then
                        XLegend = "Distance"
                    ElseIf ManFlag = 8 Then
                        XLegend = "DSS"
                    End If
                    Form1.Picture10.CurrentX = 5
                    Form1.Picture10.FontSize = 6
                    TW = Form1.Picture7.TextWidth(XLegend)
                    Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                
                    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegend, 90)
    
                    
                End If
    
            End If
    
            Extra = 0
    
            If ManFlag = 1 Then
                Extra = 1
                
                ReDim Preserve OriginalName(NextNo + 1)
                OriginalName(NextNo + 1) = "Outer fragments (potentially unknown parents)"
                OriginalName(NextNo + 1) = "Outer fragments (potentially unknown parents)"
                If NumberOfSeqs < UBound(RevSeq) Then
                    RevSeq(NumberOfSeqs + 1) = NextNo + 1
                End If
            End If
    
            P2YVal = (Y - 15) / 15
            
            If P2YVal >= 1 And P2YVal <= NumberOfSeqs + Extra And P2YVal <> HLFlag Then
                'Form1.Picture2.Refresh
                If ManFlag = 1 Or ManFlag = 3 Or ManFlag = 7 Or ManFlag = 4 Then
                    Form1.Picture2.MousePointer = 99
                Else
                    Form1.Picture2.MousePointer = 0
                End If
                PFlashed = 1
                Form1.Picture2.CurrentY = 0
                sty = 7
                Form1.Picture2.AutoRedraw = False
                'If HLFlag >= 1 And HLFlag <= NumberOfSeqs + Extra Then
                    If ManFlag <> 20 Then
                    
                        If P2YVal <= UBound(RevSeq) Then
                            If APlot = P2YVal Then
                                Call FlashName(Picture2, FFillCol(RevSeq(APlot)), OriginalName(RevSeq(P2YVal)), sty + P2YVal * 15 + 1, 25, 1, 0, 255, 0, 0, 0, 1)
                            Else
                                Call FlashName(Picture2, p2bc, OriginalName(RevSeq(P2YVal)), sty + P2YVal * 15 + 1, 25, 1, 0, 255, 0, 0, 0, 1)
                            End If
                        End If
                    End If
                    HLFlag = P2YVal
                
                'End If
                
                
    
                
                Form1.Picture2.AutoRedraw = True
            ElseIf (P2YVal <= 1 Or P2YVal >= NumberOfSeqs + Extra) And P2YVal <> HLFlag And ManFlag = -1 Then
    
                If HLFlag >= 1 And HLFlag <= NumberOfSeqs + Extra Then
                    sty = 7
                    Form1.Picture2.AutoRedraw = False
                    If HLFlag <= UBound(RevSeq) Then
                     '   Call FlashName(Picture2, p2bc, originalname(RevSeq(HLFlag)), StY + 1 + (HLFlag) * 15, 25, 1, 0, 255, 0, 0, 0, 1)
                    End If
                    'For Z = 0 To 255 Step 16
                    '    Form1.Picture2.ForeColor = RGB(255 - Z, 0, 0)
                    '    Form1.Picture2.CurrentX = 25
                    '    Form1.Picture2.CurrentY = StY + 1 + (HLFlag) * 15
                    '    If HLFlag <= UBound(RevSeq) Then
                    '        Form1.Picture2.print originalname(RevSeq(HLFlag))
                    '    End If
                    '    Form1.Picture2.ForeColor = RGB(0, 0, 0)
                    '    Sleep (5)
                    'Next 'Z
    
                    Form1.Picture2.AutoRedraw = True
                ElseIf P2YVal >= 1 And P2YVal <= NumberOfSeqs + Extra And P2YVal <> HLFlag Then
                
                End If
    
                HLFlag = 0
                Form1.Picture2.MousePointer = 0
                Form1.Picture2.Refresh
            Else
               ' If PFlashed = 1 Then
               '     X = X
               ' End If
                If P2YVal <> HLFlag Then
                    Form1.Picture2.MousePointer = 0
                    HLFlag = P2YVal
                End If
            End If
        Else
            P2YVal = Y
            If RelX > 0 Or RelY > 0 Then
                Picture2.AutoRedraw = False
                If YPos = 0 Then 'P2YVal <= 13 * ModFactor Then
                    GTCS = -4
                    Form1.Picture2.MousePointer = 99
                    Picture2.ToolTipText = "Click to select another recombination event"
                ElseIf YPos = 1 Then 'P2YVal > 13 * ModFactor And P2YVal <= 24 * ModFactor Then
                    Form1.Picture2.MousePointer = 99
                    GTCS = -3
                    
                    If XoverList(RelX, RelY).SBPFlag = 1 Or XoverList(RelX, RelY).SBPFlag = 3 Then
                        Picture2.ToolTipText = "Left click to go to beginning breakpoint position in the sequence display, right click to declare beginning breakpoint properly identified"
                    Else
                        Picture2.ToolTipText = "Left click to go to beginning breakpoint position in the sequence display, right click to declare beginning breakpoint undetermined"
                    End If
                    If FlashBeginBreakFlag = 0 Then
                        XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
                        FlashX1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
                        FlashX2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
                        FlashBeginBreakFlag = 1 'for begin break
                        If BeginFlashval > 0 Then
                            x = x
                        End If
                        BeginFlashval = 20
                        Timer1.Enabled = True
                    End If
                        
                        
    
                    
                    
                    
                ElseIf YPos = 3 Then 'P2YVal > 35 * ModFactor And P2YVal <= 46 * ModFactor Then
                    GTCS = -2
                    Form1.Picture2.MousePointer = 99
                    If XoverList(RelX, RelY).SBPFlag = 2 Or XoverList(RelX, RelY).SBPFlag = 3 Then
                        Picture2.ToolTipText = "Left click to go to ending breakpoint position in the sequence display, right click to declare ending breakpoint properly identified"
                    Else
                        Picture2.ToolTipText = "Left click to go to ending breakpoint position in the sequence display, right click to declare ending breakpoint undetermined"
                        
                    End If
                    If FlashEndBreakFlag = 0 Then
                        XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
                        FlashX1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
                        FlashX2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
                        FlashEndBreakFlag = 1 'for begin break
                        EndFlashval = 20
                        Timer1.Enabled = True
                    End If
                ElseIf YPos = 4 Then 'P2YVal >= 58 * ModFactor And P2YVal < 70 * ModFactor Then
                    If GTCS <> RecSeqX Then
                        
                        Picture2.Refresh
                        Form1.Picture2.MousePointer = 99
                        Picture2.ToolTipText = "Click to go to " & OriginalName(RecSeqX) & " in the schematic sequence display"
                        Call FlashName(Picture2, p2bc, "Recombinant: " & OriginalName(RecSeqX), 37, 2, 1, 255, 0, 192, 0, 0, 5)
                        
                        GTCS = RecSeqX
                    End If
                ElseIf YPos = 5 Then 'P2YVal >= 68 * ModFactor And P2YVal < 78 * ModFactor And (RelX > 0 Or RelY > 0) Then
                    If GTCS <> XoverList(RecSeqX, PAValX).MajorP Then
                        
                        Picture2.Refresh
                        Form1.Picture2.MousePointer = 99
                        Picture2.ToolTipText = "Click to go to " & OriginalName(XoverList(RecSeqX, PAValX).MajorP) & " in the schematic sequence display"
                        If XoverList(RecSeqX, PAValX).OutsideFlag <> 1 Then
                            Call FlashName(Picture2, p2bc, "Major Parent: " & OriginalName(XoverList(RecSeqX, PAValX).MajorP), 49, 3, 2, 255, 0, 168, 0, 0, 5)
                        Else
                            Call FlashName(Picture2, p2bc, "Major Parent: Unknown (" & OriginalName(XoverList(RecSeqX, PAValX).MajorP) & ")", 49, 3, 2, 92, 255, 92, 0, 0, 5)
                            
                        End If
                        
                    End If
                    GTCS = XoverList(RecSeqX, PAValX).MajorP
                ElseIf YPos = 6 Then 'P2YVal >= 78 * ModFactor And P2YVal < 90 * ModFactor And (RelX > 0 Or RelY > 0) Then
                    If GTCS <> XoverList(RecSeqX, PAValX).MinorP Then
                        Picture2.Refresh
                        Form1.Picture2.MousePointer = 99
                        Picture2.ToolTipText = "Click to go to " & OriginalName(XoverList(RecSeqX, PAValX).MinorP) & " in the schematic sequence display"
                        If XoverList(RecSeqX, PAValX).OutsideFlag <> 2 Then
                            Call FlashName(Picture2, p2bc, "Minor Parent: " & OriginalName(XoverList(RecSeqX, PAValX).MinorP), 61, 3, 3, 255, 0, 192, 0, 0, 5)
                        Else
                            Call FlashName(Picture2, p2bc, "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeqX, PAValX).MinorP) & ")", 62, 3, 3, 128, 0, 255, 0, 0, 5)
    
                            
                        End If
                        
                    End If
                    GTCS = XoverList(RecSeqX, PAValX).MinorP
                Else
                    If Form1.Picture2.MousePointer <> 0 Then
                        Form1.Picture2.MousePointer = 0
                        Picture2.Refresh
                        Picture2.ToolTipText = ""
                    End If
                    GTCS = -1
                End If
                Picture2.ForeColor = 0
                Picture2.AutoRedraw = True
            ElseIf RecSeq > 0 Or PAVal > 0 Then
                If YPos = 0 Then 'P2YVal <= 13 * ModFactor Then
                    GTCS = -4
                    Form1.Picture2.MousePointer = 99
                    Picture2.ToolTipText = "Click to select another recombination event"
                Else
                    GTCS = -1
                    Form1.Picture2.MousePointer = 0
                    Form1.Picture2.ToolTipText = ""
                End If
            End If
        
            
            'StY (Z - 1) * 15
        End If
    
    
    End If
    
    Dim AxLen As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    AxLen = -1
    AxLen = GYAxHi(1)
    On Error GoTo 0
    If AxLen > 0 And p7CurWinSize > 0 Then
        
        P7XP = oP7XP
        Call ShrinkZoom
        P7XP = 0
        oP7XP = 0
        Form1.Label1.Caption = ""
    End If
   
End Sub

Private Sub Picture2_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
RCAllFlag = 0
End Sub

Private Sub Picture20_DblClick()

    Dim XFactor As Double

    XFactor = (Form1.Picture20.Width) / Decompress(Len(StrainSeq(0)))

    If Int(((Pic20PointerVal) / XFactor) - 18) < Len(StrainSeq(0)) And Int(((Pic20PointerVal) / XFactor) - 18) > 0 Then
        TempVal = Int(((Pic20PointerVal) / XFactor) - 18) / (Len(StrainSeq(0)) - 40) * (HScroll1.Max)

        If TempVal >= HScroll1.Max Then
            HScroll1.Value = HScroll1.Max
        ElseIf TempVal <= HScroll1.Min Then
            HScroll1.Value = HScroll1.Min
        Else
            HScroll1.Value = TempVal
        End If

    ElseIf Int(((Pic20PointerVal) / XFactor) - 18) > Len(StrainSeq(0)) Then
        HScroll1.Value = HScroll1.Max
    ElseIf Int(((Pic20PointerVal) / XFactor) - 18) < 0 Then
        HScroll1.Value = HScroll1.Min
    End If

    'Else
    '    adjXFactor = XFactor '* (Len(strainseq(0)) / Len(xoverseq(0)))
    '    If Int(((Pic20PointerVal) / adjXFactor) - 18) < Len(StrainSeq(0)) And Int(((Pic20PointerVal) / adjXFactor) - 18) > 0 Then
    '       'HScroll1.Value = Int(((Pic7PointerVal - 10) / XFactor) - 18) / Len(strainseq(0)) * 100
    '
    '       'If Int((XPosDiff(Int((Pic20PointerVal) / adjXFactor))) - 18) / Len(XOverSeq(0)) * 100 > 0 Then
    '        'Exit Sub
    '        If Int((XPosDiff(Int((Pic20PointerVal) / adjXFactor))) - 18) / Len(XOverSeq(0)) * 100 > 0 Then
    '
    '            HScroll1.Value = Int((XPosDiff(Int((Pic20PointerVal) / adjXFactor))) - 18) / Len(XOverSeq(0)) * 100
    '        Else
    '            HScroll1.Value = 0
    '        End If
    '    ElseIf Int(((Pic20PointerVal) / adjXFactor) - 18) > Len(XOverSeq(0)) Then
    '        HScroll1.Value = 99
    '    ElseIf Int(((Pic20PointerVal) / XFactor) - 18) < 0 Then
    '        HScroll1.Value = 0
    '    End If
    '
    'End If
End Sub

Private Sub Picture20_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
'Controlls what happens when the mousepointer is moved over the ORF map at
    'the top of the plot display
    Pic20PointerVal = x
    Frame = Int(3 * (Y / Picture20.ScaleHeight))

    Dim P20XFactor As Double

    P20XFactor = Picture20.ScaleWidth / Decompress(Len(StrainSeq(0)))

    If Frame < 0 Then Frame = 0

    If Frame = 0 Then
        Y1 = 0
        Y2 = 6
    ElseIf Frame = 1 Then
        Y1 = 6
        Y2 = 12
    ElseIf Frame = 2 Then
        Y1 = 12
        Y2 = 20
    End If

    GeneNo = ORFWin(Frame, Int((x / Picture20.ScaleWidth) * Decompress(Len(StrainSeq(0)))))

    If GeneNo > 0 Then
        CurGeneNo = GeneNo
        
        Dim NameGene As String, ProtName As String
        If Right$(GeneList(CurGeneNo).Product, 1) = "*" Then
            NameGene = GeneList(CurGeneNo).Product
            Pos = InStr(1, NameGene, ":", vbBinaryCompare)
            
            'Protname = Left(GeneList(CurGeneNo).Product, Pos - 1)
            If Pos > 0 Then
                ProtName = Left(GeneList(CurGeneNo).Product, Pos - 1)
                NameGene = ProtName + " cleavage product in " + GeneList(CurGeneNo).Name
            Else
                NameGene = ProtName + " cleavage product"
            End If
        Else
            If GeneList(CurGeneNo).Name <> "" And GeneList(CurGeneNo).Name <> "" Then
                NameGene = GeneList(CurGeneNo).Name
            Else
                NameGene = "gene " + Trim(Str(Curgene))
            End If
        End If
                
        Form1.SAASeqMnu.Caption = "Save alignment file containing the coding region of " + NameGene
        
        
        Form1.PopupMenu TransSeqMnu
        If x = 12345 Then
        
            HighlightFlagII = 1
            Picture20.Refresh
            Picture20.DrawMode = 5
            Picture20.AutoRedraw = False
            Picture20.DrawWidth = 1
    
            If GeneList(GeneNo).IntronFlag = 0 Then
                Frame = Abs(GeneList(GeneNo).Frame - 3)
    
                If GeneList(GeneNo).EndInAlign > GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 1 Then
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                ElseIf GeneList(GeneNo).EndInAlign < GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 2 Then
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                ElseIf GeneList(GeneNo).Orientation = 1 Then
                    X2 = CInt(P20XFactor * 1) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                    Form1.Picture20.DrawMode = 5
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                ElseIf GeneList(GeneNo).Orientation = 2 Then
                    X2 = CInt(P20XFactor * 1) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                    Form1.Picture20.DrawMode = 5
                    X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                End If
    
                If GeneList(GeneNo).Product <> "" Then
                    Picture20.ToolTipText = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product
                Else
                    Picture20.ToolTipText = GeneList(GeneNo).Name
                End If
    
            Else
    
                If GeneList(GeneNo).ExonNumber > 1 Then
    
                    Do
                        GeneNo = GeneNo - 1
    
                        If GeneList(GeneNo).ExonNumber = 1 Then Exit Do
                    Loop
    
                End If
    
                For Z = GeneNo To GeneNo + GeneList(GeneNo).IntronFlag
                    Picture20.DrawMode = 5
                    Picture20.AutoRedraw = False
                    Frame = Abs(GeneList(Z).Frame - 3)
    
                    If Frame < 0 Then Frame = 0
    
                    If Frame = 0 Then
                        Y1 = 0
                        Y2 = 6
                    ElseIf Frame = 1 Then
                        Y1 = 6
                        Y2 = 12
                    ElseIf Frame = 2 Then
                        Y1 = 12
                        Y2 = 20
                    End If
    
                    'this needs to be sorted out
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    End If
    
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Picture20.DrawMode = 13
                    Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                Next 'Z
    
                If GeneList(GeneNo).Product <> "" Then
                    Picture20.ToolTipText = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product
                Else
                    Picture20.ToolTipText = GeneList(GeneNo).Name
                End If
    
            End If
    
            Picture20.DrawMode = 12
            Picture20.AutoRedraw = True
        End If
'    ElseIf ORFWin(Frame, Int((X / Picture20.ScaleWidth) * Len(StrainSeq(0)))) = 0 And HighlightFlagII = 1 Then
'        Picture20.Refresh
'        HighlightFlagII = 0
'        Picture20.ToolTipText = ""
    End If
End Sub

Private Sub Picture20_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    'Controlls what happens when the mousepointer is moved over the ORF map at
    'the top of the plot display
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    If Picture20.MouseIcon <> Form1.Command1.MouseIcon Then
        Picture20.MouseIcon = Form1.Command1.MouseIcon
    End If
    
    
    
    Pic20PointerVal = x
    'Frame = Int(3 * ((Y - 2) / (Picture20.ScaleHeight - 4)))

    Dim P20XFactor As Double, GeneNo As Long, oGeneNo As Long, P4H As Long, OHeight As Long

    P20XFactor = Picture20.ScaleWidth / Decompress(Len(StrainSeq(0)))
        P4H = Picture20.ScaleHeight - 3 '20
        'If Frame < 0 Then Frame = 0
        OHeight = (P4H - 2) / 3
        If Y >= 0 And Y <= OHeight Then  'P4H Then
            Frame = 0
            Y1 = 1 - 1
            Y2 = OHeight - 1 + 1
        ElseIf Y >= OHeight And Y <= OHeight * 2 Then
            Frame = 1
'            If FatGeneFlag = 1 Then
'                Y1 = 4 - 1
'                Y2 = OHeight * 2 + 2 + 1
'            Else
                
                Y1 = OHeight + 1 - 1
                Y2 = OHeight * 2 - 1 + 1
'            End If
        ElseIf Y >= OHeight * 2 And Y <= P4H Then
            Frame = 2
            Y1 = OHeight * 2 + 1 - 1
            Y2 = P4H - 3 + 1
        End If

    GeneNo = ORFWin(Frame, Int((x / Picture20.ScaleWidth) * Decompress(Len(StrainSeq(0)))))
    If GeneNo > 0 And (HighlightFlagII = 0 Or LastGeneNo <> GeneNo) Then
        HighlightFlagII = 1
        Picture20.Refresh
        Picture20.DrawMode = 5
        Picture20.AutoRedraw = False
        Picture20.DrawWidth = 1

        If GeneList(GeneNo).IntronFlag = 0 Then
            Frame = Abs(GeneList(GeneNo).Frame - 3)

            If GeneList(GeneNo).EndInAlign > GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 1 Then
                X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                LastGeneNo = GeneNo
            ElseIf GeneList(GeneNo).EndInAlign < GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 2 Then
                X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                LastGeneNo = GeneNo
            ElseIf GeneList(GeneNo).Orientation = 1 Then
                X2 = CInt(P20XFactor * 1) - 1
                X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                Form1.Picture20.DrawMode = 5
                X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                
                LastGeneNo = GeneNo
            ElseIf GeneList(GeneNo).Orientation = 2 Then
                X2 = CInt(P20XFactor * 1) - 1
                X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                Form1.Picture20.DrawMode = 5
                X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                LastGeneNo = GeneNo
            End If
            'XX = Right(GeneList(GeneNo).Name, 5)
            If GeneList(GeneNo).Product <> "" Then
            
                Picture20.ToolTipText = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product
            Else
                Picture20.ToolTipText = GeneList(GeneNo).Name
            End If

        Else
            oGeneNo = GeneNo
            If GeneList(GeneNo).ExonNumber > 1 Then

                Do
                    GeneNo = GeneNo - 1

                    If GeneList(GeneNo).ExonNumber = 1 Then Exit Do
                Loop

            End If

            For Z = GeneNo To GeneNo + GeneList(GeneNo).IntronFlag
                Picture20.DrawMode = 5
                Picture20.AutoRedraw = False
                Frame = Abs(GeneList(Z).Frame - 3)

                If Frame < 0 Then Frame = 0

                If Frame = 0 Then
                    Y1 = 1 - 1
                    Y2 = OHeight - 1 + 1
                ElseIf Frame = 1 Then
                    Y1 = OHeight + 1 - 1
                    Y2 = OHeight * 2 - 1 + 1
                ElseIf Frame = 2 Then
                    Y1 = OHeight * 2 + 1 - 1
                    Y2 = P4H - 3 + 1
                End If

                'this needs to be sorted out

                If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                    X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                    X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                ElseIf GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                    X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                    X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                    X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                    X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                    X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                    X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                End If

                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                Picture20.DrawMode = 13
                Form1.Picture20.Line (X1, Y1)-(X2, Y2), BackColours, B
                LastGeneNo = oGeneNo
            Next 'Z

            If GeneList(GeneNo).Product <> "" Then
                Picture20.ToolTipText = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product
            Else
                Picture20.ToolTipText = GeneList(GeneNo).Name
            End If
            
        End If

        Picture20.DrawMode = 12
        Picture20.AutoRedraw = True
        Picture20.MousePointer = 99
    ElseIf ORFWin(Frame, Int((x / Picture20.ScaleWidth) * Len(StrainSeq(0)))) = 0 And HighlightFlagII = 1 Then
        Picture20.Refresh
        HighlightFlagII = 0
        Picture20.ToolTipText = ""
        Picture20.MousePointer = 0
        Screen.MousePointer = 0
    End If

End Sub

Private Sub Picture21_Click()
x = x
End Sub





Private Sub Picture22_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)


Dim tTYF As Double, TYFM As Integer
If Button = 2 Then
    PopupMenu AncMnu
Else
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
    TH = (13 * tTYF + 2) * Screen.TwipsPerPixelY 'Picture22.CurrentY - (-10000) 'Picture22.TextHeight("A")
        '(13 * tTYF + 2) * Screen.TwipsPerPixelY
    
    If x > Picture11.Width Then
        AncType = Int((Y) / TH)
        
        If AncType = 0 Then
            Dim UBAP As Long
            On Error Resume Next
            UBAP = -1
            UBAP = UBound(PAncPVals, 2)
            On Error GoTo 0
            If UBAP = Len(StrainSeq(0)) Then
                For x = 0 To Len(StrainSeq(0))
                    For Y = 0 To 5
                        AncPVals(Y, x) = PAncPVals(Y, x)
'                        If PAncPVals(Y, X) <> 0 Then
'                            X = X
'                        End If
                    Next Y
                Next x
                Call HScroll1_Change
            End If
        ElseIf AncType = 1 Then
            
            On Error Resume Next
            UBAP = -1
            UBAP = UBound(AncPValsML, 2)
            On Error GoTo 0
            If UBAP = Len(StrainSeq(0)) Then
                For x = 0 To Len(StrainSeq(0))
                    For Y = 0 To 5
                        AncPVals(Y, x) = AncPValsML(Y, x)
                    Next Y
                Next x
                Call HScroll1_Change
            End If
        ElseIf AncType = 2 Then
            
            On Error Resume Next
            UBAP = -1
            UBAP = UBound(AncPValsBayes, 2)
            On Error GoTo 0
            If UBAP = Len(StrainSeq(0)) Then
                For x = 0 To Len(StrainSeq(0))
                    
                    For Y = 0 To 5
                        AncPVals(Y, x) = AncPValsBayes(Y, x)
                    Next Y
                Next x
                Call HScroll1_Change
            End If
        Else
            
        End If
        If AncType > -1 And AncType < 3 Then
            
        End If
    Else
        Picture22.MousePointer = 0
    End If
End If
End Sub

Private Sub Picture22_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim AncType As Long, TH As Long
Dim tTYF As Double, TYFM As Integer
Picture22.MouseIcon = Command1.MouseIcon
'Picture22.CurrentY = -10000
'Picture22.Print " "

Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
TH = (13 * tTYF + 2) * Screen.TwipsPerPixelY 'Picture22.CurrentY - (-10000) 'Picture22.TextHeight("A")
    '(13 * tTYF + 2) * Screen.TwipsPerPixelY

If x > Picture11.Width Then
    AncType = Int((Y) / TH)
    If AncType < 3 And AncType > -1 Then
        Picture22.MousePointer = 99
        
    Else
         Picture22.MousePointer = 0
    End If
    If AncType = 0 Then
        Picture22.ToolTipText = "Left click to display parsimony inferred nucleotide state probabilities"
    ElseIf AncType = 1 Then
        Picture22.ToolTipText = "Left click to display maximum likelihood inferred nucleotide state probabilities"
    ElseIf AncType = 2 Then
        Picture22.ToolTipText = "Left click to display MrBayes inferred nucleotide state probabilities"
    Else
        Picture22.ToolTipText = ""
    End If
Else
    Screen.MousePointer = 0
    Picture22.MousePointer = 0
    Picture22.ToolTipText = ""
End If
End Sub

Private Sub Picture23_KeyDown(Index As Integer, KeyCode As Integer, Shift As Integer)
Call DoKeydown(KeyCode)
End Sub

Private Sub Picture23_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Dim AxLen As Long


If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If

If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If

    If DebuggingFlag < 2 Then On Error Resume Next
    AxLen = -1
    AxLen = GYAxHi(1)
    On Error GoTo 0
    If AxLen > 0 And p7CurWinSize > 0 Then
        If x > Picture10.Left + Picture10.Width Then
            P7XP = AxLen

        ElseIf x <= Picture10.Left + 10 Then
            P7XP = 1

        Else
            P7XP = oP7XP

        End If
        Call ShrinkZoom
        P7XP = 0
        oP7XP = 0
        Form1.Label1.Caption = ""
        'Form1.WindowState = Form1.WindowState
    End If
End Sub

Private Sub Picture26_KeyDown(KeyCode As Integer, Shift As Integer)
    Call DoKeydown(KeyCode)
End Sub

Private Sub Picture26_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    'MatrixSaveMnu.Visible = True
        If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
            Screen.MousePointer = 0
        End If
    Picture26.MouseIcon = Command15.MouseIcon
    Picture26.MousePointer = 99
    If Button = 1 Then
        P26MD = 1
        P26MDX = x
        P26MDY = Y
    ElseIf Button = 2 Then
        If CurMatrixFlag = 0 Or CurMatrixFlag = 14 Or CurMatrixFlag = 13 Or CurMatrixFlag = 12 Or CurMatrixFlag = 2 Or CurMatrixFlag = 1 Or CurMatrixFlag = 3 Or CurMatrixFlag = 4 Then
            MatrixOptMnu.Enabled = True
        Else
            MatrixOptMnu.Enabled = False
        End If
        
        CHMatMnu.Visible = True
        MatrixMnu.Enabled = True
        MatrixSaveMnu.Enabled = True
        If NextNo >= 3 Then
            CMMnu(0).Enabled = True
            CMMnu(1).Enabled = True
        Else
            CMMnu(0).Enabled = False
            CMMnu(1).Enabled = False
        End If
        If SEventNumber > 0 Then
            RecRCMnu.Enabled = True
            RecBPMnu.Enabled = True
            RecMatMnu.Enabled = True
            ModMatMnu.Enabled = True
            If (RelX > 0 Or RelY > 0) Then
            
                MCMatMnu.Enabled = True
                LMatMnu.Enabled = True
                If (CurMatrixFlag = 8 Or CurMatrixFlag = 9 Or CurMatrixFlag = 10 Or CurMatrixFlag = 11) Then
                    'PBPMnu3.Visible = True
                    PABPMnu.Visible = True
                Else
                    'PBPMnu3.Visible = False
                    PABPMnu.Visible = False
                End If
            Else
                MCMatMnu.Enabled = False
                LMatMnu.Enabled = False
                LMatMnu.Enabled = False
                'PBPMnu3.Visible = False
                PABPMnu.Visible = False
            End If
        Else
            RecRCMnu.Enabled = False
            RecBPMnu.Enabled = False
            RecMatMnu.Enabled = False
            ModMatMnu.Enabled = False
            MCMatMnu.Enabled = False
            LMatMnu.Enabled = False
            'PBPMnu3.Visible = False
            PABPMnu.Visible = False
        End If
        If CurMatrixFlag = 0 Then
            ColMnu.Enabled = False
        Else
            ColMnu.Enabled = True
            ColMnu.Visible = True
        End If
        PopupMenu MatrixMnu
    End If

End Sub

Private Sub Picture26_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim XC As Double, YC As Double, XP As Long, YP As Long, UB As Long, AddonX As Long, AddonY As Long
Dim VSV As Long, HSV As Long
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Screen.MousePointer = 0


If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If

If CurMatrixFlag = 255 Then Exit Sub
F2P2Y = -1
P1Seq = -1
P1NT = -1
F1P7X = -1
F1P2Y = -1
F1P3Y = -1
F1P6Y = -1
F2P3Y = -1
F1P16Y = -1
F1P26Y = Y
F1P26X = x
F2P2Index = -1
If P26MD = 1 Then
    If VScroll5.Enabled = True Then
        If P26MDX <> x Or P26MDY <> Y Then
            
            
            Addj = 1 ' / Sqr(MatZoom(CurMatrixFlag))
            'If HScroll4.Value + (P26MDX - X) * Addj > 0 And HScroll4.Value + (P26MDX - X) * Addj <= HScroll4.Max Then
            HSV = HScroll4.Value + (P26MDX - x) * Addj
            If HSV < 0 Then HSV = 0
            If HSV > HScroll4.Max Then HSV = HScroll4.Max
                
            'End If
            
            VSV = VScroll5.Value + (P26MDY - Y) * Addj '/ MatZoom(CurMatrixFlag)
            If VSV < 0 Then VSV = 0
            If VSV > VScroll5.Max Then VSV = HScroll4.Max
            If P26MDX <> x And P26MDY <> Y Then
                DoVS5 = 1
                VScroll5.Value = VSV
                
                HScroll4.Value = HSV '/ MatZoom(CurMatrixFlag)\
                DoVS5 = 0
                Call HScroll4_Change
                P26MDX = x
                P26MDY = Y
                HVScrollflag = 0
            ElseIf P26MDY <> Y Then
                DoVS5 = 0
                VScroll5.Value = VSV
                P26MDY = Y
                HVScrollflag = 0
            ElseIf P26MDX <> x Then
                DoVS5 = 0
                HScroll4.Value = HSV
                P26MDX = x
                
                HVScrollflag = 0
            End If
            
            'P26MDX = X: P26MDY = Y
        End If
    End If
Else
    If CurMatrixFlag = 0 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixC, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 14 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixTB, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 1 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixR, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 2 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixM, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 3 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixRR, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 4 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixBP, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 5 Then
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixLD, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
        
    ElseIf CurMatrixFlag = 6 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixRMin, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 7 Then
        
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixRMinD, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 8 Then
            
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixMC, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 11 Then
            
        If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixL, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 12 Then
        
        If DebuggingFlag < 3 Then On Error Resume Next
            UB = 0
            UB = UBound(MatrixSH, 2) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    ElseIf CurMatrixFlag = 13 Then
        If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(MatrixRF, 1) - 1
        On Error GoTo 0
        If UB = 0 Then CurMatrixFlag = 255
    End If
    
    Dim X1 As Long, X2 As Long
    Addj = (UB / Picture26.ScaleHeight)
    If Addj = 0 Then Exit Sub
    AddonX = (MatCoord(CurMatrixFlag, 0) * MatZoom(CurMatrixFlag)) / Addj
    AddonY = (MatCoord(CurMatrixFlag, 1) * MatZoom(CurMatrixFlag)) / Addj
    'XX = MatCoord(CurMatrixFlag, 0)
    XC = (x + AddonX) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag))  'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
    YC = (Y + AddonY) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag))   'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
    
    XP = CLng((XC * UB) - 0.5)
    
    YP = CLng((YC * UB) - 0.5)
    F1P26PX = XP + 1
    F1P26PY = YP + 1
'    If F1P26PX = 2 Then
'        X = X
'    End If
     X1 = -1
    X2 = -1
    If CurMatrixFlag = 0 Then
    'MatBound(0)
        If XC >= 0 And YC >= 0 And XC <= 1 And YC <= 1 Then
            'Label7(0).Caption = "X: " + Trim(Str(VarsitesCM(CLng(XC * MatBound(0))))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))))
            'Label7(1).Caption = "Y: " + Trim(Str(VarsitesCM(CLng(YC * MatBound(0)))))  'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(0).Caption = "X: " + Trim(Str(VarsitesCM(XP + 1))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))))
            Label7(1).Caption = "Y: " + Trim(Str(VarsitesCM(YP + 1))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))

        Else
            Label7(0).Caption = "X: --" 'CLng(XC * Len(StrainSeq(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: --" 'CLng(YC * Len(StrainSeq(0))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
        End If
    ElseIf CurMatrixFlag = 14 Then
    'MatBound(0)
        If XC > 0 And YC >= 0 And XC <= 1 And YC <= 1 Then
            XP = CLng(XC * UBound(MatrixTB, 1))
            YP = CLng(YC * UBound(MatrixTB, 1))
            Label7(0).Caption = "X: " + Trim(Str(VarPosTB(XP))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))))
            Label7(1).Caption = "Y: " + Trim(Str(VarPosTB(YP)))  'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(2).Caption = Trim(Str(CLng(MatrixTB(XP, YP))))
            
                
            
            'Label7(0).Caption = "X: " + Trim(Str(VarsitesCM(XP + 1))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))))

        Else
            Label7(0).Caption = "X: --" 'CLng(XC * Len(StrainSeq(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: --" 'CLng(YC * Len(StrainSeq(0))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(2).Caption = "--"
        End If

    ElseIf CurMatrixFlag = 8 Then
    'MatBound(0)
        If XC >= 0 And YC >= 0 And XC <= 1 And YC <= 1 Then
            'NewBP(0) = VarsitesMC(CLng(XC * UBound(MatrixMC, 1)))
            'NewBP(1) = VarsitesMC(CLng(YC * UBound(MatrixMC, 1)))
            NewBP(0) = VarsitesMC(XP + 1)
            NewBP(1) = VarsitesMC(YP + 1)
            'Label7(0).Height = Label7(0).Height * 2
            'Label7(1).Height = Label7(0).Height
            If DebuggingFlag < 2 Then On Error Resume Next
            Label7(0).Caption = "X: " + Trim(Str(NewBP(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixMC, 1) - 1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: " + Trim(Str(NewBP(1))) 'Trim(Str(CLng((YC / ((UBound(MatrixMC, 1) - 1) - 1)) * Len(StrainSeq(0)))))
            On Error GoTo 0
            X1 = NewBP(0)
            X2 = NewBP(1)
           
        Else
            Label7(0).Caption = "X: --" 'CLng(XC * Len(StrainSeq(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: --" 'CLng(YC * Len(StrainSeq(0))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
        End If
        If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
            Label7(2).Caption = Trim(Str(CLng(MatrixMC(XP + 1, YP + 1)))) + "." + Right(Trim(Str(CLng(MatrixMC(XP, YP) * 10000) + 100000)), 4)
        Else
            Label7(2).Caption = "--"
        End If
    ElseIf CurMatrixFlag = 5 Or CurMatrixFlag = 6 Or CurMatrixFlag = 7 Then
        If XC >= 0 And YC >= 0 And XC <= 1 And YC <= 1 Then
            
            Label7(0).Caption = "X: " + Trim(Str(VarsitesLD(CLng(XC * Mat567Len)))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: " + Trim(Str(VarsitesLD(CLng(YC * Mat567Len))))  'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            X1 = VarsitesLD(CLng(XC * Mat567Len))
            X2 = VarsitesLD(CLng(YC * Mat567Len))
        Else
            Label7(0).Caption = "X: --" 'CLng(XC * Len(StrainSeq(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: --" 'CLng(YC * Len(StrainSeq(0))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
        End If
        If CurMatrixFlag = 5 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixLD(XP, YP) - 0.49))) + "." + Right(Trim(Str(CLng(MatrixLD(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 6 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixRMin(XP, YP) - 0.49))) + "." + Right(Trim(Str(CLng(MatrixRMin(XP, YP) * 10000) + 100000)), 4)
                'Label7(2).Caption = Trim(Str(CLng(MatrixRMin(XP, YP) - 0.49))) + "." + right(Trim(Str(CLng(MatrixRMin(XP, YP) * 10000) + 100000)), 4)
                
                'X = X
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 7 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
               Label7(2).Caption = Trim(Str(CLng(MatrixRMinD(XP, YP) - 0.49))) + "." + Right(Trim(Str(CLng(MatrixRMinD(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
        
        End If
    
    
    
    ElseIf CurMatrixFlag = 12 Then
        
        If XP < UB And YP < UB And XP >= 0 And YP >= 0 Then
            Label7(2).Caption = Trim(Str(CLng(MatrixSH(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixSH(XP, YP) * 10000) + 100000)), 4)
            V1 = XP * SHStep + SHWinLen / 2 'CLng((XP / UB) * Len(StrainSeq(0))) + CLng((1 / UB) * Len(StrainSeq(0)) / 2)
            Label7(0).Caption = "X: " + Trim(Str(V1)) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
             V1 = YP * SHStep + SHWinLen / 2 '= CLng((YP / UB) * Len(StrainSeq(0))) + CLng((1 / UB) * Len(StrainSeq(0)) / 2)
            Label7(1).Caption = "Y: " + Trim(Str(V1)) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
    
        Else
            Label7(0).Caption = "X: --"
            Label7(1).Caption = "Y: --"
            Label7(2).Caption = "--"
        End If
    ElseIf CurMatrixFlag = 13 Then
        
        If XP < UB And YP < UB And XP >= 0 And YP >= 0 Then
            Label7(2).Caption = Trim(Str(CLng(MatrixRF(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixRF(XP, YP) * 10000) + 100000)), 4)
            V1 = XP * SHStep + SHWinLen / 2 'CLng((XP / UB) * Len(StrainSeq(0))) + CLng((1 / UB) * Len(StrainSeq(0)) / 2)
            Label7(0).Caption = "X: " + Trim(Str(V1)) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
             V1 = YP * SHStep + SHWinLen / 2 '= CLng((YP / UB) * Len(StrainSeq(0))) + CLng((1 / UB) * Len(StrainSeq(0)) / 2)
            Label7(1).Caption = "Y: " + Trim(Str(V1)) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
    
        Else
            Label7(0).Caption = "X: --"
            Label7(1).Caption = "Y: --"
            Label7(2).Caption = "--"
        End If
    Else
        If XC >= 0 And YC >= 0 And XC <= 1 And YC <= 1 Then
           
            Label7(0).Caption = "X: " + Trim(Str(CLng(XC * Len(StrainSeq(0))))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: " + Trim(Str(CLng(YC * Len(StrainSeq(0))))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
           
            X1 = XC * Len(StrainSeq(0))
            X2 = YC * Len(StrainSeq(0))
        Else
            Label7(0).Caption = "X: --" 'CLng(XC * Len(StrainSeq(0))) 'Trim(Str(CLng((XC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            Label7(1).Caption = "Y: --" 'CLng(YC * Len(StrainSeq(0))) 'Trim(Str(CLng((YC / ((UBound(MatrixM, 1)-1) - 1)) * Len(StrainSeq(0)))))
            
        End If
        
        If CurMatrixFlag = 1 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixR(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixR(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 2 Then
            If XP <= UB And YP <= UBound(MatrixM, 1) And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixM(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixM(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 3 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixRR(XP, YP))))
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 4 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixBP(XP, YP))))
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 11 Then
            If XP <= UB And YP <= UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixL(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixL(XP, YP) * 10000) + 100000)), 4)
                 'Trim(Str(CLng(MatrixMC(XP, YP)-0.5))) + "." + right(Trim(Str(CLng(MatrixMC(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
            
            NewBP(0) = X1
            NewBP(1) = X2
        ElseIf CurMatrixFlag = 12 Then
            If XP < UB And YP < UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixSH(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixSH(XP, YP) * 10000) + 100000)), 4)
                 'Trim(Str(CLng(MatrixMC(XP, YP)-0.5))) + "." + right(Trim(Str(CLng(MatrixMC(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
        ElseIf CurMatrixFlag = 13 Then
            If XP < UB And YP < UB And XP >= 0 And YP >= 0 Then
                Label7(2).Caption = Trim(Str(CLng(MatrixRF(XP, YP) - 0.5))) + "." + Right(Trim(Str(CLng(MatrixRF(XP, YP) * 10000) + 100000)), 4)
                 'Trim(Str(CLng(MatrixMC(XP, YP)-0.5))) + "." + right(Trim(Str(CLng(MatrixMC(XP, YP) * 10000) + 100000)), 4)
            Else
                Label7(2).Caption = "--"
            End If
             'Label7(2).Caption = "--"
        End If
    End If
    
    If (CurMatrixFlag >= 6 And CurMatrixFlag <= 11) And X1 > -1 And X2 > -1 Then
        XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
        Picture7.DrawMode = 7
        Picture7.AutoRedraw = False
        Picture7.ForeColor = RGB(112, 112, 112)
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
        Picture7.Line (30 + Decompress(X1) * XFactor, 20)-(30 + Decompress(X1) * XFactor, PicHeight - 10)
        Picture7.Line (30 + Decompress(X2) * XFactor, 20)-(30 + Decompress(X2) * XFactor, PicHeight - 10)
        Picture7.AutoRedraw = True
        Picture7.DrawMode = 13
    End If
    
    Dim UT As Long
    Dim MT(1)
    'use the pointer to move things up, down and diagonally
    If x = 12345 Then
        If HScroll4.Enabled = True Then
            UT = Picture26.ScaleHeight - 10: MT(0) = Picture26.ScaleHeight / 2 - 10: MT(1) = Picture26.ScaleHeight / 2 + 10
            If x < 10 And HScroll4.Value - HScroll4.SmallChange * 2 >= 0 And Y < 10 And VScroll5.Value - VScroll5.SmallChange * 2 >= 0 Then
                DoVS5 = 1
                HScroll4.Value = HScroll4.Value - HScroll4.SmallChange * 2
                DoVS5 = 0
                VScroll5.Value = VScroll5.Value - VScroll5.SmallChange * 2
            ElseIf x > UT And HScroll4.Value + HScroll4.SmallChange * 2 <= HScroll4.Max And Y > UT And VScroll5.Value + VScroll5.SmallChange * 2 <= VScroll5.Max Then
                DoVS5 = 1
                HScroll4.Value = HScroll4.Value + HScroll4.SmallChange * 2
                DoVS5 = 0
                VScroll5.Value = VScroll5.Value + VScroll5.SmallChange * 2
            ElseIf x > UT And HScroll4.Value + HScroll4.SmallChange * 2 <= HScroll4.Max And Y < 10 And VScroll5.Value - VScroll5.SmallChange * 2 >= 0 Then
                DoVS5 = 1
                HScroll4.Value = HScroll4.Value + HScroll4.SmallChange * 2
                DoVS5 = 0
                VScroll5.Value = VScroll5.Value - VScroll5.SmallChange * 2
            ElseIf x < 10 And HScroll4.Value - HScroll4.SmallChange * 2 >= 0 And Y > UT And VScroll5.Value + VScroll5.SmallChange * 2 <= VScroll5.Max Then
                DoVS5 = 1
                HScroll4.Value = HScroll4.Value - HScroll4.SmallChange * 2
                DoVS5 = 0
                VScroll5.Value = VScroll5.Value + VScroll5.SmallChange * 2
            ElseIf x < 10 And HScroll4.Value - HScroll4.SmallChange * 2 >= 0 And Y > MT(0) And Y < MT(1) Then
                HScroll4.Value = HScroll4.Value - HScroll4.SmallChange * 2
            ElseIf Y < 10 And VScroll5.Value - VScroll5.SmallChange * 2 >= 0 And x > MT(0) And x < MT(1) Then
                VScroll5.Value = VScroll5.Value - VScroll5.SmallChange * 2
            ElseIf x > UT And HScroll4.Value + HScroll4.SmallChange * 2 <= HScroll4.Max And x > MT(0) And x < MT(1) Then
                HScroll4.Value = HScroll4.Value + HScroll4.SmallChange * 2
            ElseIf Y > UT And VScroll5.Value + VScroll5.SmallChange * 2 <= VScroll5.Max And Y > MT(0) And Y < MT(1) Then
                VScroll5.Value = VScroll5.Value + VScroll5.SmallChange * 2
            End If
        End If
    End If
End If
If MatZoom(CurMatrixFlag) > 1 Then
    Picture26.ToolTipText = "Hold left mouse button down and drag to move. Right click for options" '+ Chr(10) + Chr(13) + "X:"
    If P26MD = 1 Then
        Form1.Picture26.MouseIcon = Form1.Command15.MouseIcon
        Form1.Picture26.MousePointer = 99
    Else
        Form1.Picture26.MouseIcon = Form1.Command1.MouseIcon
        Form1.Picture26.MousePointer = 99
    End If
Else
    Form1.Picture26.MousePointer = 0
    Picture26.ToolTipText = "Right click for options"
End If
x = x
End Sub



Private Sub Picture26_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
If Button = 1 Then
    P26MD = 0
End If
Picture26.MouseIcon = Command1.MouseIcon
Picture26.MousePointer = 99
If Form1.Picture6.Enabled = True Then
    Form1.Picture6.SetFocus
ElseIf Form1.Picture1.Enabled = True Then
    Form1.Picture1.SetFocus
End If
End Sub

Private Sub Picture29_Click()
x = x
End Sub

Private Sub Picture3_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Dim tTYF As Double, TYFM As Integer
     Dim CurrentSeq As Integer
    If ttyfAdjust = 0 Then ttyfAdjust = 1
   ' Form1.ZOrder
    
    VSV = VScroll3.Value / ScrollSF
    Y = Y + VSV
    VSV = VSV - 1
    If ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
        If NextNo > 0 Then Picture1.Enabled = True
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        If Y > 0 And Y < ((P3Seq2Pos + 1) * 13 * tTYF * ttyfAdjust) Then
            Picture3.MousePointer = 99
            CurrentSeq = Int(Y / 13 / (tTYF * ttyfAdjust))
            GTCS = GTCSNum(CurrentSeq)
'            If CurrentSeq = 0 Then
'                GTCS = Seq1
'
'            ElseIf CurrentSeq = 1 Then
'                GTCS = Seq3
'            ElseIf CurrentSeq = 2 Then
'                GTCS = Seq2
'            Else
'                Picture3.ToolTipText = ""
'                Exit Sub
'            End If
        End If
        DontFlash = 0
        FlashY = -1
        Dim OldVal As Long, NewVal As Long
        For Y = 0 To UBound(PermArray, 2)
            If PermArray(0, Y) = GTCS Then
                
                OldVal = VScroll2.Value
                Y = (Y * 12 + 3) * SpaceAdjust
                If VScroll2.Max > 0 Then
                    If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < VScroll2.Max Then
                        If CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
                            NewVal = CLng((Y - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
                            'CLng((y - Picture6.ScaleHeight / 2) / F1VS2Adj)
                        Else
                            NewVal = 0
                        End If
                    Else
                        NewVal = VScroll2.Max
                    End If
                End If
                Call ScrollToVSPos(VScroll2, OldVal, NewVal)
                
                
                
                PermFlashY = Y
                Y = CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
                
                
                
                Picture6.Refresh
                
                
                FlashCol = 510
                
                FlashY = Y 'CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
                Timer1.Enabled = True
                Call Timer1_Timer
                Exit For
            End If
        Next Y
    
        
    ElseIf ShowSeqFlag = 0 Then
        
        HLFlag = -1
       ' LastY3 = -1
        
       
        
        
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        
        If Y > 0 And Y < ((NextNo + 1) * 13 * tTYF * ttyfAdjust) Then
            CurrentSeq = Int(Y / 13 / (tTYF * ttyfAdjust))
            GTCS = CurrentSeq
        End If
            
        If Button = 1 Then
    
            If P3MouseDown = 1 Then
                Y = MoveSeq
            Else
                P3MouseDown = 1
                Y = YStrain
            End If
    
            Form1.MaskAllMnu.Visible = True
            Form1.UnmaskAllMnu.Visible = True
            'Form1.InvertMaskMnu.Visible = True
            Form1.DisableAllMnu.Visible = True
            
           
            If Y > 0 And Y < (NextNo + 1) * 13 * tTYF * ttyfAdjust Then
                Picture3.AutoRedraw = True
                LChange = CurrentSeq
    
                If SelGrpFlag = 0 Then
                    If MaskSeq(CurrentSeq) = 0 Then
                        
                        MaskSeq(CurrentSeq) = 1
                        Picture3.Line (0, CurrentSeq * 13 * tTYF * ttyfAdjust - VSV)-(Picture3.Width, CurrentSeq * 13 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust - VSV), BackColours, BF
                        
                        
                        Picture3.ForeColor = QBColor(8)
                        Picture3.CurrentX = 0
                        Picture3.CurrentY = CurrentSeq * 13 * tTYF * ttyfAdjust - VSV '+ (Int(Y / 13))
                        Picture3.Print OriginalName(CurrentSeq)
                        Timer2.Enabled = False
                        Timer2.Enabled = True
                        Timer2.Interval = 60000
                    ElseIf MaskSeq(CurrentSeq) = 1 Then
                        
                        Picture3.Line (0, CurrentSeq * 13 * tTYF * ttyfAdjust - VSV)-(Picture3.Width, CurrentSeq * 13 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust - VSV), BackColours, BF
                        MaskSeq(CurrentSeq) = 2
                        Picture3.ForeColor = ThreeQuaterColour
                        Picture3.CurrentX = 0
                        
                        Picture3.CurrentY = CurrentSeq * 13 * tTYF * ttyfAdjust - VSV '+ (Int(Y / 13))
                        Picture3.Print OriginalName(CurrentSeq)
                        RedoReticulateFlag = 1
                        Timer2.Enabled = False
                        Timer2.Enabled = True
                        Timer2.Interval = 60000
                    ElseIf MaskSeq(CurrentSeq) = 2 Then
                        Picture3.Line (0, CurrentSeq * 13 * tTYF * ttyfAdjust - VSV)-(Picture3.Width, CurrentSeq * 13 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust - VSV), BackColours, BF
                        
                        MaskSeq(CurrentSeq) = 0
                        Picture3.ForeColor = QBColor(0)
                        Picture3.CurrentX = 0
                        Picture3.CurrentY = CurrentSeq * 13 * tTYF * ttyfAdjust - VSV '+ (Int(Y / 13))
                        Picture3.Print OriginalName(CurrentSeq)
                        Timer2.Enabled = False
                        Timer2.Enabled = True
                        Timer2.Interval = 60000
                    End If
                    
                Else
                    If GrpMaskSeq(CurrentSeq) = 1 Then
                        Picture3.Line (0, CurrentSeq * 13 * tTYF * ttyfAdjust - VSV)-(Picture3.Width, CurrentSeq * 13 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust - VSV), BackColours, BF
                            
                        GrpMaskSeq(CurrentSeq) = 0
                        If MaskSeq(CurrentSeq) = 0 Then
                            Picture3.ForeColor = QBColor(0)
                        ElseIf MaskSeq(CurrentSeq) = 1 Then
                            Picture3.ForeColor = QBColor(8)
                        Else
                            Picture3.ForeColor = ThreeQuaterColour
                        End If
                        Picture3.CurrentX = 0
                        Picture3.CurrentY = CurrentSeq * 13 * tTYF * ttyfAdjust - VSV '+ (Int(Y / 13))
                        Picture3.Print OriginalName(CurrentSeq)
                        
                    Else
                        Picture3.Line (0, CurrentSeq * 13 * tTYF * ttyfAdjust - VSV)-(Picture3.Width, CurrentSeq * 13 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust - VSV), BackColours, BF
                        GrpMaskSeq(CurrentSeq) = 1
                        If MaskSeq(CurrentSeq) = 0 Then
                            Picture3.ForeColor = RGB(0, 0, 255)
                        ElseIf MaskSeq(CurrentSeq) = 1 Then
                            Picture3.ForeColor = RGB(120, 120, 255)
                        Else
                            Picture3.ForeColor = RGB(200, 200, 255)
                        End If
                        'Picture3.ForeColor =
                        
                        Picture3.CurrentX = 0
                        Picture3.CurrentY = CurrentSeq * 13 * tTYF * ttyfAdjust - VSV '+ (Int(Y / 13))
                        Picture3.Print OriginalName(CurrentSeq)
                    End If
                End If
                Picture3.AutoRedraw = False
                Picture3.Refresh 'Picture3.Refresh
                'LastY3 = -1
                'Picture3.MousePointer = 0
                If TreeTypeFlag = 0 Or (TreeTypeFlag = 3 And (CTF = 1 Or CTF = 0)) Then
                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
                End If
            End If
            
        ElseIf Button = 2 Then
            Form1.MaskAllMnu.Visible = True
            Form1.UnmaskAllMnu.Visible = True
            'Form1.InvertMaskMnu.Visible = True
            Form1.DisableAllMnu.Visible = True
            Form1.PopupMenu MaskMnu
        End If
    End If

End Sub

Private Sub Picture3_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    

    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    Dim xY As Single, VSV As Single
    Dim tTYF As Double, TYFM As Integer
    Picture3.ScaleMode = 3
    Dim CurrentSeq As Integer
    'If ShowSeqFlag > 0 Then Exit Sub
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
    Call CheckUnFlash
    F2P2Y = -1
    P1Seq = -1
    P1NT = -1
    F1P7X = -1
    F1P2Y = -1
    F1P3Y = Y
    F1P6Y = -1
    F2P3Y = -1
    F1P16Y = -1
    F1P26Y = -1
    F2P2Index = -1
    VSV = VScroll3.Value / ScrollSF
    xY = Y
    Y = Y + VSV
    If ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        If Y > 0 And Y < ((P3Seq2Pos + 1) * 13 * tTYF * ttyfAdjust) Then
            Picture3.MousePointer = 99
            CurrentSeq = Int(Y / 13 / (tTYF * ttyfAdjust))
            GTCS = GTCSNum(CurrentSeq)
'            If CurrentSeq = 0 Then
'                GTCS = Seq1
'
'            ElseIf CurrentSeq = 1 Then
'                GTCS = Seq3
'            ElseIf CurrentSeq = 2 Then
'                GTCS = Seq2
'            Else
'                Picture3.ToolTipText = ""
'                Exit Sub
'            End If
            If GTCS <= UBound(StraiName, 1) Then
                Picture3.ToolTipText = "Click to go to " + StraiName(GTCS) + " in the schematic sequence display"
            End If
        Else
            Picture3.MousePointer = 0
            Picture3.ToolTipText = ""
        End If
        
    ElseIf ShowSeqFlag = 0 Then
    
        Timer4.Enabled = True
        
        
        'Picture3.FontBold = True
        
        Dim RFactor As Byte, GFactor As Byte, BFactor As Byte
    
        YStrain = Y
        RFactor = CByte(BkR + (255 - BkR) / 2)
        GFactor = CByte(BkG + (255 - BkG) / 2)
        BFactor = CByte(BkB + (255 - BkB) / 2)
       
        
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        
        If Y > 0 And Y < ((NextNo + 1) * 13 * tTYF * ttyfAdjust) Then
            CurrentSeq = Int(Y / 13 / (tTYF * ttyfAdjust))
        End If
    'Exit Sub
        If P3MouseDown = 0 Then
            Picture3.AutoRedraw = False
            If CurrentSeq > UBound(MaskSeq) Then UnModNextno
            If Y > 0 And Y < (NextNo + 1) * 13 * tTYF * ttyfAdjust Then
                If Screen.MousePointer <> 0 Then Screen.MousePointer = 0
                Picture3.MousePointer = 99
                
                'LastY3 = -1
                Dim P3BC As Long
                P3BC = BackColours 'Picture2.BackColor
               
                If CurrentSeq <> LastY3 Then
                    XX = LastY3
                    
                    If LastY3 > -1 Then
                        If LastY3 < CurrentSeq Then
                            For g = LastY3 + 1 To CurrentSeq
                                If g <= UBound(BusyFlashing, 1) Then
                                    If BusyFlashing(g) = 0 Then
                                        BusyFlashing(g) = 1
                                    ElseIf BusyFlashing(g) > 0 Then
                                        
                                        Dim Diffxx As Long
                                        Diffxx = (127 - BusyFlashing(g)) * 2
                                        If Diffxx < 0 Then
                                            BusyFlashing(g) = BusyFlashing(g) + Diffxx
                                        End If
                                    End If
                                End If
                            Next g
                        Else
                            For g = CurrentSeq To LastY3 - 1
                                If g <= UBound(BusyFlashing, 1) Then
                                    If BusyFlashing(g) = 0 Then
                                        BusyFlashing(g) = 1
                                    ElseIf BusyFlashing(g) > 0 Then
                                        'Dim Diffxx As Long
                                        Diffxx = (127 - BusyFlashing(g)) * 2
                                        If Diffxx < 0 Then
                                            BusyFlashing(g) = BusyFlashing(g) + Diffxx
                                        End If
                                    End If
                                End If
                            Next g
                        End If
                    Else
                        LastY = CurrentSeq
                        g = CurrentSeq
                        If g <= UBound(BusyFlashing, 1) Then
                            If BusyFlashing(g) = 0 Then
                                BusyFlashing(g) = 1
                            ElseIf BusyFlashing(g) > 0 Then
                                'Dim Diffxx As Long
                                Diffxx = (127 - BusyFlashing(g)) * 2
                                If Diffxx < 0 Then
                                    BusyFlashing(g) = BusyFlashing(g) + Diffxx
                                End If
                            End If
                        End If
                    End If
                    LastY3 = CurrentSeq
                    
                    Picture3.ToolTipText = ""
                    
                    'GoOn = 1
                    'For X = 0 To NextNo
                    '    If BusyFlashing(X) = 1 Then
                    '        Exit For
                    '        GoOn = 0
                    '    End If
                    'Next X
                    'If GoOn = 1 Then
                    '    If ShowSeqFlag = 0 Then
                    '        Call PrintNames
                    '    Else
                    '        Call PrintNames3(Form1.Picture3, XOverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
                    '    End If
                    'End If
                    If HLFlag >= 0 And HLFlag <= NextNo Then
                        If HLFlag <= UBound(MaskSeq, 1) Then
                            If MaskSeq(HLFlag) = 0 Then
                                Picture3.ForeColor = 0
                            ElseIf MaskSeq(HLFlag) = 1 Then
                                Picture3.ForeColor = QBColor(8)
                            ElseIf MaskSeq(HLFlag) = 2 Then
                                Picture3.ForeColor = ThreeQuaterColour 'RGB((255 - Int(Z / (255 / (255 - RFactor)))), GFactor, BFactor)
                            End If
                        End If
                    End If
                    If SelGrpFlag = 0 Then
                        If CurrentSeq <= UBound(MaskSeq) Then
                            If QvRFlag = 0 Then
                                
                                If MaskSeq(CurrentSeq) = 0 Then
                                    Picture3.ToolTipText = "Click to mask " & OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & ")"
                                ElseIf MaskSeq(CurrentSeq) = 1 Then
                                    Picture3.ToolTipText = "Click to disable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & ")"
                                ElseIf MaskSeq(CurrentSeq) = 2 Then
                                    Picture3.ToolTipText = "Click to enable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & ")"
                                End If
                            Else
                                If ReferenceList(CurrentSeq) > 0 Then
                                    If MaskSeq(CurrentSeq) = 0 Then
                                        Picture3.ToolTipText = "Click to mask " & OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; reference #" & Trim(Str(ReferenceList(CurrentSeq))) & ": " & RefGroupName(ReferenceList(CurrentSeq)) & ")"
                                    ElseIf MaskSeq(CurrentSeq) = 1 Then
                                        Picture3.ToolTipText = "Click to disable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; reference #" & Trim(Str(ReferenceList(CurrentSeq))) & ": " & RefGroupName(ReferenceList(CurrentSeq)) & ")"
                                    ElseIf MaskSeq(CurrentSeq) = 2 Then
                                        Picture3.ToolTipText = "Click to enable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; reference #" & Trim(Str(ReferenceList(CurrentSeq))) & ": " & RefGroupName(ReferenceList(CurrentSeq)) & ")"
                                    End If
                                Else
                                    If MaskSeq(CurrentSeq) = 0 Then
                                        Picture3.ToolTipText = "Click to mask " & OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; query sequence)"
                                    ElseIf MaskSeq(CurrentSeq) = 1 Then
                                        Picture3.ToolTipText = "Click to disable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; query sequence)"
                                    ElseIf MaskSeq(CurrentSeq) = 2 Then
                                        Picture3.ToolTipText = "Click to enable " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & "; query sequence)"
                                    End If
                                End If
                            End If
                            Label15.Caption = "Sequence " + Trim(Str(CurrentSeq))
                        End If
                    Else
                        If GrpMaskSeq(CurrentSeq) = 0 Then
                            Picture3.ToolTipText = "Click to include " & OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & " in the group"
                        ElseIf GrpMaskSeq(CurrentSeq) = 1 Then
                            Picture3.ToolTipText = "Click to exclude " + OriginalName(CurrentSeq) & "(sequence #" & Trim(Str(CurrentSeq)) & " from the group"
                        
                        End If
                    End If
                    If CurrentSeq <= UBound(OriginalName, 1) Then
                        GoToSeqMnu.Caption = "Go To " & OriginalName(CurrentSeq)
                        GoToSeqMnu.Visible = True
                    End If
                Else
                    x = x
                    
                End If
                
                HLFlag = (Int(Y / 13))
                'Picture3.Refresh
            Else
                
            End If
    
            Picture3.ForeColor = QBColor(0)
        Else
    
            If CurrentSeq <> LChange Then
                MoveSeq = Y
    
                Call Picture3_MouseDown(Button, Shift, x, xY)
    
            End If
    
        End If
    End If
Dim AxLen As Long
If DebuggingFlag < 2 Then On Error Resume Next
AxLen = -1
AxLen = GYAxHi(1)
On Error GoTo 0
If AxLen > 0 And p7CurWinSize > 0 Then
    
    P7XP = oP7XP
    Call ShrinkZoom
    P7XP = 0
    oP7XP = 0
    Form1.Label1.Caption = ""
End If
End Sub

Private Sub Picture3_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
    If ShowSeqFlag > 0 Then Exit Sub
    P3MouseDown = 0
    PrintNames
End Sub

Private Sub Picture31_Click()
x = x
End Sub

Private Sub Picture32_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub Picture4_DblClick()
    Dim XFactor As Single, Xpos As Long, WidViewWin As Long, MidNt As Long, HSV As Long
    WidViewWin = (Form1.Picture9.ScaleWidth / Form1.Picture1.TextWidth("A"))
    
    XFactor = (Form1.Picture4.ScaleWidth) / Decompress(Len(StrainSeq(0)))
    Xpos = Pic4PointerVal - (((Form1.Picture4.ScaleWidth / 2) - Pic4PointerVal) / 55)
    Xpos = Pic4PointerVal
    
    'MidNt = ((Len(StrainSeq(0)) - WidViewWin) / Form1.HScroll1.MaX) * Form1.HScroll1.Value + WidViewWin / 2
    MidNt = CLng(Pic4PointerVal / XFactor)
    If Form1.HScroll1.Max > 0 Then
        HSV = (MidNt - WidViewWin / 2) / ((Len(StrainSeq(0)) - WidViewWin) / Form1.HScroll1.Max)
    Else
        HSV = 0
    End If
    
    If HSV > Form1.HScroll1.Max Then
        HSV = Form1.HScroll1.Max
    ElseIf HSV < Form1.HScroll1.Min Then
        HSV = Form1.HScroll1.Min
    End If
    
    'Form1.HScroll1.Value = HSV
    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
        HScroll1.Value = (Pic4PointerVal / Form1.Picture4.ScaleWidth) * HScroll1.Max 'HScroll1.Value - xFactor = (Form1.Picture4.ScaleWidth) / Decompress(Len(StrainSeq(0)))
        
    Else
    
        Form1.HScroll1.Value = HSV
'        If Int(((Xpos) / XFactor)) < Decompress(Len(StrainSeq(0))) And Int(((Xpos) / XFactor)) > 0 Then
'            HScroll1.Value = Int(((Xpos) / XFactor)) / Decompress(Len(StrainSeq(0))) * (HScroll1.MaX)
'        ElseIf Int(((Xpos) / XFactor)) > Decompress(Len(StrainSeq(0))) Then
'            HScroll1.Value = HScroll1.MaX
'        ElseIf Int(((Xpos) / XFactor)) < 1 Then
'            HScroll1.Value = HScroll1.Min
'        End If
    End If

End Sub
Private Sub Picture11_DblClick()
    Dim XFactor As Single, Xpos As Long, WidViewWin As Long, MidNt As Long, HSV As Long
    WidViewWin = (Form1.Picture9.ScaleWidth / Form1.Picture1.TextWidth("A"))
    
    XFactor = (Form1.Picture4.ScaleWidth) / Decompress(Len(StrainSeq(0)))
    Xpos = Pic11PointerVal - (((Form1.Picture4.ScaleWidth / 2) - Pic4PointerVal) / 55)
    Xpos = Pic11PointerVal
    
    'MidNt = ((Len(StrainSeq(0)) - WidViewWin) / Form1.HScroll1.MaX) * Form1.HScroll1.Value + WidViewWin / 2
    MidNt = CLng(Pic11PointerVal / XFactor)
    If Form1.HScroll1.Max > 0 Then
        HSV = (MidNt - WidViewWin / 2) / ((Len(StrainSeq(0)) - WidViewWin) / Form1.HScroll1.Max)
    Else
        HSV = 0
    End If
    
    If HSV > Form1.HScroll1.Max Then
        HSV = Form1.HScroll1.Max
    ElseIf HSV < Form1.HScroll1.Min Then
        HSV = Form1.HScroll1.Min
    End If
    
    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
        HScroll1.Value = (Pic11PointerVal / Form1.Picture11.ScaleWidth) * HScroll1.Max 'HScroll1.Value - xFactor = (Form1.Picture4.ScaleWidth) / Decompress(Len(StrainSeq(0)))
        
    Else
        HScroll1.Value = HSV
'        XFactor = (Form1.Picture11.ScaleWidth) / Decompress(Len(StrainSeq(0)))
'        Pic11PointerVal = Pic11PointerVal - (((Form1.Picture11.ScaleWidth / 2) - Pic11PointerVal) / 55)
'
'        If Int(((Pic11PointerVal) / XFactor)) < Decompress(Len(StrainSeq(0))) And Int(((Pic11PointerVal) / XFactor)) > 0 Then
'            HScroll1.Value = Int(((Pic11PointerVal) / XFactor)) / Decompress(Len(StrainSeq(0))) * (HScroll1.MaX)
'        ElseIf Int(((Pic11PointerVal) / XFactor)) > Decompress(Len(StrainSeq(0))) Then
'            HScroll1.Value = HScroll1.MaX
'        ElseIf Int(((Pic11PointerVal) / XFactor)) < 1 Then
'            HScroll1.Value = HScroll1.Min
'        End If
    End If
    'Else
    '    adjXFactor = XFactor '* (Len(strainseq(0)) / Len(xoverseq(0)))
    '    If Int(((Pic11PointerVal - 10) / adjXFactor)) < Len(StrainSeq(0)) And Int(((Pic11PointerVal - 10) / adjXFactor)) > 0 Then
    '       'HScroll1.Value = Int(((Pic7PointerVal - 10) / XFactor) - 18) / Len(strainseq(0)) * 100
    '
    '       If Int((XPosDiff(Int((Pic11PointerVal - 10) / adjXFactor)))) / Len(XOverSeq(0)) * 100 > 0 Then
    '            HScroll1.Value = Int((XPosDiff(Int((Pic11PointerVal - 10) / adjXFactor)))) / Len(XOverSeq(0)) * 100
    '        Else
    '            HScroll1.Value = 0
    '        End If
    '    ElseIf Int(((Pic11PointerVal - 10) / adjXFactor)) > Len(XOverSeq(0)) Then
    '        HScroll1.Value = 99
    '    ElseIf Int(((Pic11PointerVal - 10) / XFactor)) < 0 Then
    '        HScroll1.Value = 0
    '    End If
    '
    'End If
End Sub


Private Sub Picture4_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Dim MaxID As Single, MinID As Single
    If IDDisplayMode = 0 Then
        MaxID = MaxHomology
        MinID = MinHomology
    ElseIf IDDisplayMode = 1 Then
        MaxID = MaxTajD
        MinID = MinTajD
    ElseIf IDDisplayMode = 2 Then
        MinID = MinGCContent
        MaxID = MaxGCContent
    End If
    Form1.ScaleMode = 3
    Picture12.Height = 180 '* (15 / Screen.TwipsPerPixelY)
    Picture12.Width = 75 * (14 / Screen.TwipsPerPixelX)
    Picture12.ZOrder
    '

    If Button = 1 And HomologyIndicator = 1 Then
        Picture12.Top = Y + SSPanel4.Top + 5 '+ Picture4.Top + Y
        Picture12.Left = x + SSPanel4.Left + 5 'Picture4.Left + x
        Picture12.Picture = Picture4.Picture
        Picture12.AutoRedraw = True
        Picture12.Visible = True
        'Picture12.Refresh

        Dim LPNT As POINTAPI

        'For curline = 10 To 110
        curline = 0
        Pict = Picture12.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5) ' * (15 / Screen.TwipsPerPixelY)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        RCol = 255
        Pict = Picture12.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5) '* (15 / Screen.TwipsPerPixelY)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        BCol = 255
        Pict = Picture12.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5) '* (15 / Screen.TwipsPerPixelY)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        GCol = 255
        Picture12.ForeColor = 0
        Picture12.CurrentX = 350
        Picture12.CurrentY = 75 / (15 / Screen.TwipsPerPixelY)
        Picture12.Print "-  " & (Int(MinID * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 651 / (15 / Screen.TwipsPerPixelY)
        Picture12.Print "-  " & (Int(((MaxID + MinID) / 2 + MinID) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 1227 / (15 / Screen.TwipsPerPixelY)
        Picture12.Print "-  " & (Int((MaxID + MinID) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 1803 / (15 / Screen.TwipsPerPixelY)
        Picture12.Print "-  " & (Int((MaxID + (MaxID + MinID) / 2) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 2380 / (15 / Screen.TwipsPerPixelY)
        Picture12.Print "-  " & (Int(MaxID * 100)) / 100
        'Next
        Picture12.Refresh
        'Form1.Refresh
    ElseIf Button = 2 Then
        'SHAPEScores(Pos)
        
        If GeneNumber > 0 Then
            If CurGeneNo > 0 Then
                Dim NameGene As String, ProtName As String
                If Right$(GeneList(CurGeneNo).Product, 1) = "*" Then
                    NameGene = GeneList(CurGeneNo).Product
                    Pos = InStr(1, NameGene, ":", vbBinaryCompare)
                    
                    'Protname = Left(GeneList(CurGeneNo).Product, Pos - 1)
                    If Pos > 0 Then
                        ProtName = Left(GeneList(CurGeneNo).Product, Pos - 1)
                        NameGene = ProtName + " cleavage product in " + GeneList(CurGeneNo).Name
                    Else
                        NameGene = ProtName + " cleavage product"
                    End If
                Else
                    If GeneList(CurGeneNo).Name <> "" And GeneList(CurGeneNo).Name <> "" Then
                        NameGene = GeneList(CurGeneNo).Name
                    Else
                        NameGene = "gene " + Trim(Str(Curgene))
                    End If
                End If
                        
                Form1.LoadHWSitesetMnu(9).Caption = "Save alignment file containing the coding region of " + NameGene
                Form1.LoadHWSitesetMnu(9).Visible = True
                Form1.LoadHWSitesetMnu(10).Visible = False
            Else
                Form1.LoadHWSitesetMnu(9).Visible = False
                Form1.LoadHWSitesetMnu(10).Visible = True
            
            End If
        Else
            Form1.LoadHWSitesetMnu(9).Visible = False
            Form1.LoadHWSitesetMnu(10).Visible = False
        End If
        If IDDisplayMode = 0 Then
             Form1.LoadHWSitesetMnu(3).Visible = False
             Form1.LoadHWSitesetMnu(4).Visible = True
             Form1.LoadHWSitesetMnu(5).Visible = True
        ElseIf IDDisplayMode = 1 Then
            Form1.LoadHWSitesetMnu(3).Visible = True
            Form1.LoadHWSitesetMnu(4).Visible = False
            Form1.LoadHWSitesetMnu(5).Visible = True
        ElseIf IDDisplayMode = 2 Then
            Form1.LoadHWSitesetMnu(3).Visible = True
            Form1.LoadHWSitesetMnu(4).Visible = True
            Form1.LoadHWSitesetMnu(5).Visible = False
        End If
        Form1.LoadHWSitesetMnu(0).Caption = "Change to histogram view"
        Form1.PopupMenu LoadHWSitesetMnuX
    End If

End Sub
Private Sub Picture11_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Form1.ScaleMode = 3
    Picture12.Height = 180
    Picture12.Width = 55
    Picture12.ZOrder
    '

    If Button = 2 And HomologyIndicator = 1 Then
        Picture12.Top = Y + SSPanel4.Top + 5 '+ picture11.Top + Y
        Picture12.Left = x + SSPanel4.Left + 5 'picture11.Left + x
        Picture12.Picture = Picture11.Picture
        Picture12.AutoRedraw = True
        Picture12.Visible = True
        'Picture12.Refresh

        Dim LPNT As POINTAPI

        'For curline = 10 To 110
        curline = 0
        Pict = Picture12.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        RCol = 255
        Pict = Picture12.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        BCol = 255
        Pict = Picture12.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture12.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2, curline, LPNT)
            Dummy = LineTo(Pict, 20, curline)
        Next

        GCol = 255
        Picture12.ForeColor = 0
        Picture12.CurrentX = 350
        Picture12.CurrentY = 75
        Picture12.Print "-  " & (Int(MinHomology * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 651
        Picture12.Print "-  " & (Int(((MaxHomology + MinHomology) / 2 + MinHomology) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 1227
        Picture12.Print "-  " & (Int((MaxHomology + MinHomology) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 1803
        Picture12.Print "-  " & (Int((MaxHomology + (MaxHomology + MinHomology) / 2) / 2 * 100)) / 100
        Picture12.CurrentX = 350
        Picture12.CurrentY = 2380
        Picture12.Print "-  " & (Int(MaxHomology * 100)) / 100
        'Next
        Picture12.Refresh
        'Form1.Refresh
    
        'SHAPEScores(Pos)
    ElseIf Button = 2 Then
        If GeneNumber > 0 Then
            If CurGeneNo > 0 Then
                Form1.LoadHWSitesetMnu(9).Caption = "Save alignment file containing the coding region of " + GeneList(CurGeneNo).Name
                Form1.LoadHWSitesetMnu(9).Visible = True
                Form1.LoadHWSitesetMnu(10).Visible = False
            Else
                Form1.LoadHWSitesetMnu(9).Visible = False
                Form1.LoadHWSitesetMnu(10).Visible = True
            
            End If
        Else
            Form1.LoadHWSitesetMnu(9).Visible = False
            Form1.LoadHWSitesetMnu(10).Visible = False
        End If
        If IDDisplayMode = 0 Then
             Form1.LoadHWSitesetMnu(3).Visible = False
             Form1.LoadHWSitesetMnu(4).Visible = True
             Form1.LoadHWSitesetMnu(5).Visible = True
        ElseIf IDDisplayMode = 1 Then
            Form1.LoadHWSitesetMnu(3).Visible = True
            Form1.LoadHWSitesetMnu(4).Visible = False
            Form1.LoadHWSitesetMnu(5).Visible = True
        ElseIf IDDisplayMode = 2 Then
            Form1.LoadHWSitesetMnu(3).Visible = True
            Form1.LoadHWSitesetMnu(4).Visible = True
            Form1.LoadHWSitesetMnu(5).Visible = False
        End If
        Form1.LoadHWSitesetMnu(0).Caption = "Change to colour scale view"
        Form1.PopupMenu LoadHWSitesetMnuX
    End If

End Sub
Private Sub Picture4_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim XFactor As Single, XX1 As Long, XX2 As Long
If CurrentlyRunningFlag = 1 Then Exit Sub
If StillLoadingFlag = 1 Then Exit Sub
Picture3.Refresh
Picture2.Refresh
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
    XFactor = ((Form1.Picture4.ScaleWidth) / Decompress(Len(StrainSeq(0))))
    'Exit Sub
    Pic4PointerVal = x ' / 12

    If Int(((Pic4PointerVal) / XFactor)) > 0 And Int(((Pic4PointerVal) / XFactor)) < Len(StrainSeq(0)) Then
        's = XDiffPos(408)
        
        If DebuggingFlag < 2 Then On Error Resume Next
        If IDDisplayMode = 0 Then
            Form1.Label15.Caption = (Int(10000 * BkgIdentity(Beginning + Int(((Pic4PointerVal) / (XFactor)))))) / 10000
        ElseIf IDDisplayMode = 1 Then
            Form1.Label15.Caption = (Int(10000 * TajD(Beginning + Int(((Pic4PointerVal) / (XFactor)))))) / 10000
        ElseIf IDDisplayMode = 2 Then
            Form1.Label15.Caption = (Int(10000 * GCContent(Beginning + Int(((Pic4PointerVal) / (XFactor)))))) / 10000
        End If
        On Error GoTo 0
    Else
        Form1.Label15.Caption = "--"
    End If
    CurGeneNo = 0
'    For A = 1 To GeneNumber
'        If Abs(GeneList(A).EndInAlign - GeneList(A).StartInAlign) > 30000 Then
'            x = x
'        End If
'        If Abs(GeneList(A).EndInAlign - GeneList(A).StartInAlign) < 300 Then
'            x = x
'        End If
'    Next A
    
    If ORFFlag = 1 Then
        If Picture4.MouseIcon <> Form1.Command1.MouseIcon Then
            Picture4.MouseIcon = Form1.Command1.MouseIcon
        End If
        Pic20PointerVal = x
        'Frame = Int(3 * ((Y - 2) / (picture4.ScaleHeight - 4)))
    
        Dim P20XFactor As Double, GeneNo As Long, oGeneNo As Long, P4H As Long, OHeight As Long
    
        P20XFactor = Picture4.ScaleWidth / Decompress(Len(StrainSeq(0)))
        P4H = Picture4.ScaleHeight '20
        'If Frame < 0 Then Frame = 0
        OHeight = (P4H - 2) / 3
        If Y >= 0 And Y <= OHeight Then  'P4H Then
            Frame = 0
            Y1 = 1
            Y2 = OHeight - 1
        ElseIf Y >= OHeight And Y <= OHeight * 2 Then
            Frame = 1
            If FatGeneFlag = 1 Then
                Y1 = 4
                Y2 = OHeight * 2 + 2
                If P4H = 26 Then
                    Y2 = Y2 + 1
                End If
            Else
                
                Y1 = OHeight + 1
                Y2 = OHeight * 2 - 1
            End If
        ElseIf Y >= OHeight * 2 And Y <= P4H Then
            Frame = 2
            Y1 = OHeight * 2 + 1
            Y2 = P4H - 3
        End If
        
        If FatGeneFlag = 1 Then
            If P4H = 26 Then
                FATAdj = 12
            Else
                FATAdj = 6
            End If
        Else
            FATAdj = 0
        End If
        If Int((x / Picture4.ScaleWidth) * Decompress(Len(StrainSeq(0)))) <= UBound(ORFWin, 2) Then
            'If Frame > 0 Then
            '    X = X
            'End If
            GeneNo = ORFWin(Frame, Int((x / Picture4.ScaleWidth) * Decompress(Len(StrainSeq(0)))))
        Else
            GeneNo = -1
        End If
        CurGeneNo = GeneNo
        Dim PolyPoints() As POINTAPI, MhDC As Long
        MhDC = Form1.Picture4.hdc
        ReDim PolyPoints(5)
        If GeneNo > 0 And (HighlightFlagII = 0 Or LastGeneNo <> GeneNo) Then
'            XX = GeneList(GeneNo).StartInAlign
'            XX = GeneList(GeneNo).EndInAlign
'            If GeneNo <> 2 Then
'                x = x
'            End If
            XX = GeneList(GeneNo).End
            XX = GeneList(GeneNo).Start
            XX = GeneList(GeneNo).EndInAlign
            XX = GeneList(GeneNo).StartInAlign
            
            If UBound(AVTaj, 1) <> GeneNumber Then
                ReDim Preserve AVTaj(GeneNumber), AvBKG(GeneNumber), AvGCContent(GeneNumber)
            End If
            HighlightFlagII = 1
            Picture4.Refresh
            'readd in the position indicator
            PositionIndicaterOn = 0
            DontDoH1Inc = 1
            OnlyDoPositionIndicator = 1
            Call HScroll1_Change
            DontDoH1Inc = 0
            OnlyDoPositionIndicator = 0
            PositionIndicaterOn = 0
            
            
            Picture4.DrawMode = 5
            Picture4.AutoRedraw = False
            Picture4.DrawWidth = 1
            
            
            
'            Y1 = 7
'            Y2 = 11
            If GeneList(GeneNo).IntronFlag = 0 Then
                Frame = Abs(GeneList(GeneNo).Frame - 3)
                'GeneList(GeneNo).StartInAlign = 2700
                
                
                If GeneList(GeneNo).EndInAlign > GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 1 Then
                    
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) '- 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) ' + 1
                    XX2 = GeneList(GeneNo).StartInAlign
                    XX1 = GeneList(GeneNo).EndInAlign
                    If IDDisplayMode = 0 Then
                        Dim pCounter As Long, TotVal As Single
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    
                    PolyPoints(0).x = X2 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X1 - 4 - FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X1 - 4 - FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X2 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X2 - 1: PolyPoints(5).Y = Y1
                    Form1.Picture4.FillStyle = 0
                    'Form1.Picture4.ForeColor = RGB(150, 150, 0)
                    Form1.Picture4.FillColor = RGB(150, 150, 0)
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
                    'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                    Form1.Picture4.FillColor = RGB(198, 198, 255)
                    'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    'Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    'Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture4.DrawMode = 13
'                    Form1.Picture4.FillStyle = 1
'                    Form1.Picture4.FillColor = BackColours
'                    Polygon Form1.Picture4.hDC, PolyPoints(0), 5
                    Form1.Picture4.FillStyle = 0
                    'Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).EndInAlign < GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 2 Then
                    X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) '+ 1
                    X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) ' - 1
                    XX1 = GeneList(GeneNo).StartInAlign ') '+ 1
                    XX2 = GeneList(GeneNo).EndInAlign ') ' - 1
                    
                    If IDDisplayMode = 0 Then
                       
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    
                    PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture4.FillStyle = 0
                    Form1.Picture4.FillColor = RGB(150, 150, 0)
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
                    'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                    Form1.Picture4.FillColor = RGB(198, 198, 255)
                    'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture4.FillStyle = 1
'                    Form1.Picture4.ForeColor = BackColours
'                    Polygon Form1.Picture4.hDC, PolyPoints(0), 5
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture4.DrawMode = 13
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).Orientation = 1 Then 'there is a wrap
                    X2 = CInt(P20XFactor * 1) ' - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) '+ 1
                    
                    XX2 = 1
                    XX1 = GeneList(GeneNo).EndInAlign ') '+ 1
                    
                    If IDDisplayMode = 0 Then
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            
                        End If
                    ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            
                        End If
                    End If
                    
                    
                    PolyPoints(0).x = X2 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X1 - 4 - FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X1 - 4 - FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X2 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X2 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture4.FillStyle = 0
                    Form1.Picture4.FillColor = RGB(150, 150, 0)
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
                    'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                    Form1.Picture4.FillColor = RGB(198, 198, 255)
                    'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture4.DrawMode = 13
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
'                    Form1.Picture4.DrawMode = 5
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) ' - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) '+ 1
                    XX2 = GeneList(GeneNo).StartInAlign ') ' - 1
                    XX1 = Len(StrainSeq(0)) ') '+ 1
                    
                    If IDDisplayMode = 0 Then
                        
                        If AvBKG(GeneNo) = 0 Then
                           
                            For x = XX2 To XX1
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X2 + 1: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X2 + 1: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture4.FillStyle = 0
                    Form1.Picture4.FillColor = RGB(150, 150, 0)
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                    
                    'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                    Form1.Picture4.FillColor = RGB(198, 198, 255)
                    'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                    Polygon Form1.Picture4.hdc, PolyPoints(0), 5
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture4.DrawMode = 13
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).Orientation = 2 Then
                    X2 = CInt(P20XFactor * 1) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture4.DrawMode = 13
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    Form1.Picture4.DrawMode = 5
                    X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture4.DrawMode = 13
                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                End If
                'XX = Right(GeneList(GeneNo).Name, 5)
                Dim OutString As String
                
                If IDDisplayMode = 0 Then
                    OutString = Trim(Str(AvBKG(GeneNo)))
                ElseIf IDDisplayMode = 1 Then
                    OutString = Trim(Str(AVTaj(GeneNo)))
                ElseIf IDDisplayMode = 2 Then
                    OutString = Trim(Str(AvGCContent(GeneNo)))
                End If
                If Left(OutString, 1) = "." Then OutString = "0" + OutString
                If Left(OutString, 2) = "-." Then
                    OutString = "-0" + Right(OutString, Len(OutString) - 1)
                End If
                If IDDisplayMode = 0 Then
                    OutString = " (average pairwise identity = " + OutString + ")"
                ElseIf IDDisplayMode = 1 Then
                    OutString = " (average Tajima's D = " + OutString + ")"
                ElseIf IDDisplayMode = 2 Then
                    OutString = " (average GC content = " + OutString + ")"
                End If
                
                If GeneList(GeneNo).Product <> "" Then
                    OutString = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product + OutString
                Else
                    OutString = GeneList(GeneNo).Name + OutString
                End If
                Picture4.ToolTipText = OutString
    
            Else
                oGeneNo = GeneNo
                If GeneList(GeneNo).ExonNumber > 1 Then
    
                    Do
                        GeneNo = GeneNo - 1
    
                        If GeneList(GeneNo).ExonNumber = 1 Then Exit Do
                    Loop
    
                End If
                pCounter = 0
                TotVal = 0
                For Z = GeneNo To GeneNo + GeneList(GeneNo).IntronFlag
                    Picture4.DrawMode = 5
                    Picture4.AutoRedraw = False
                    Frame = Abs(GeneList(Z).Frame - 3)
    
                    If Frame < 0 Then Frame = 0
    
                    If Frame = 0 Then
                        Y1 = 1
                        Y2 = OHeight - 1
                    ElseIf Frame = 1 Then
                       If FatGeneFlag = 1 Then
                            Y1 = 4
                            Y2 = OHeight * 2 + 2
                        Else
                            
                            Y1 = OHeight + 1
                            Y2 = OHeight * 2 - 1
                        End If
                    ElseIf Frame = 2 Then
                        Y1 = OHeight * 2 + 1
                        Y2 = P4H - 3
                    End If
    
                    'this needs to be sorted out
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        XX1 = GeneList(Z).StartInAlign + 1
                        XX2 = GeneList(Z).EndInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        XX1 = GeneList(Z).StartInAlign + 1
                        XX2 = GeneList(Z).EndInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        XX1 = GeneList(Z).StartInAlign - 1
                        XX2 = GeneList(Z).EndInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        XX1 = GeneList(Z).StartInAlign - 1
                        XX2 = GeneList(Z).EndInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    End If
                    
                    If (GeneList(Z).ExonNumber = 1 And GeneList(Z).IntronFlag > 0 And GeneList(Z).Orientation = 2) Or (GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1 And GeneList(Z).Orientation = 1) Then
                       ' GeneList(Z).StartInAlign = 1600
                        If GeneList(Z).Orientation = 1 Then
                            If X1 < X2 Then
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                       
                                        For x = XX1 To XX2
                                            
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 4 - FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 4 - FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            Else
                                
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(1).Y = Y1
                                PolyPoints(2).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                
                                
                                
                                PolyPoints(0).x = 0: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 4 - FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 4 - FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = 0: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = 0: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            End If
                        Else
                            
                            If X2 < X1 Then
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                
                                
                                
                            Else
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                PolyPoints(0).x = 0: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X1 + 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X1 + 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = 0: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = 0: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            End If
                                    
                        End If
                    Else
                        'GeneList(Z).StartInAlign = 100
                        
                        If GeneList(Z).Orientation = 2 Then
                            If X2 < X1 Then
                            
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                            
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            Else
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 - 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                PolyPoints(0).x = X1 + 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = 0: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = 0: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = 0: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 + 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 + 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            End If
                        Else
                            If X1 < X2 Then
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        If XX2 > UBound(BkgIdentity) Then XX2 = UBound(BkgIdentity)
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            If x >= 0 Then
                                                If x <= UBound(BkgIdentity, 1) Then
                                                    
                                                    TotVal = TotVal + (BkgIdentity(x))
                                                End If
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If XX2 > UBound(TajD) Then XX2 = UBound(TajD)
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            Else
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X1 - 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X1 - 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X1 - 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                    End If
                                End If
                                
                                PolyPoints(0).x = X2 + 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = 0: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = 0: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = 0: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X2 + 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X2 + 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture4.FillStyle = 0
                                Form1.Picture4.FillColor = RGB(150, 150, 0)
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                                
                                'Form1.Picture4.FillColor = RGB(BkR, BkG, BkB)
                                Form1.Picture4.FillColor = RGB(198, 198, 255)
                                'Form1.Picture4.ForeColor = Form1.Picture4.FillColor
                                Polygon Form1.Picture4.hdc, PolyPoints(0), 5
                            End If
                        End If
                    End If
                    
                    
                    
                    
    
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Picture4.DrawMode = 13
'                    Form1.Picture4.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = oGeneNo
                Next 'Z
                
                If IDDisplayMode = 0 Then
                       
                    If AvBKG(GeneNo) = 0 Then
                        If pCounter > 0 Then
                            AvBKG(GeneNo) = TotVal / pCounter
                        Else
                            AvBKG(GeneNo) = 0
                        End If
                    End If
                ElseIf IDDisplayMode = 1 Then
                    If AVTaj(GeneNo) = 0 Then
                        If pCounter > 0 Then
                            AVTaj(GeneNo) = TotVal / pCounter
                        Else
                            AVTaj(GeneNo) = 0
                        End If
                    End If
                ElseIf IDDisplayMode = 2 Then
                    If AvGCContent(GeneNo) = 0 Then
                        If pCounter > 0 Then
                            AvGCContent(GeneNo) = TotVal / pCounter
                        Else
                            AvGCContent(GeneNo) = 0
                        End If
                    End If
                End If
                
                If IDDisplayMode = 0 Then
                    OutString = Trim(Str(AvBKG(GeneNo)))
                ElseIf IDDisplayMode = 1 Then
                    OutString = Trim(Str(AVTaj(GeneNo)))
                ElseIf IDDisplayMode = 2 Then
                    OutString = Trim(Str(AvGCContent(GeneNo)))
                End If
                If Left(OutString, 1) = "." Then OutString = "0" + OutString
                If Left(OutString, 2) = "-." Then
                    OutString = "-0" + Right(OutString, Len(OutString) - 1)
                End If
                If IDDisplayMode = 0 Then
                    OutString = " (average pairwise identity = " + OutString + ")"
                ElseIf IDDisplayMode = 1 Then
                    OutString = " (average Tajima's D = " + OutString + ")"
                ElseIf IDDisplayMode = 2 Then
                    OutString = " (average GC content = " + OutString + ")"
                End If
                
                If GeneList(GeneNo).Product <> "" Then
                    OutString = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product + OutString
                Else
                    OutString = GeneList(GeneNo).Name + OutString
                End If
                Picture4.ToolTipText = OutString
                
                
                
            End If
    
            Picture4.DrawMode = 12
            Picture4.AutoRedraw = True
            Picture4.MousePointer = 99
        ElseIf ORFWin(Frame, Int((x / Picture4.ScaleWidth) * Len(StrainSeq(0)))) = 0 And HighlightFlagII = 1 Then
            'Picture4.Refresh
            'DontDoH1Inc = 1
            PositionIndicaterOn = 0
            DontDoH1Inc = 1
            OnlyDoPositionIndicator = 1
            Call HScroll1_Change
            DontDoH1Inc = 0
            OnlyDoPositionIndicator = 0
            DontDoH1Inc = 0
            HighlightFlagII = 0
            If IDDisplayMode = 0 Then
                Picture4.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 1 Then
                Picture4.ToolTipText = "Average Tajima D (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 2 Then
                Picture4.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
                
            End If
            Picture4.MousePointer = 0
        ElseIf ORFWin(Frame, Int((x / Picture4.ScaleWidth) * Len(StrainSeq(0)))) = 0 Then
            If IDDisplayMode = 0 Then
                Picture4.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 1 Then
                Picture4.ToolTipText = "Average Tajima D (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 2 Then
                Picture4.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
                
            End If
            Picture4.MousePointer = 0
        End If
    End If
    
    
    

End Sub
Private Sub Picture11_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Picture3.Refresh
Picture2.Refresh
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Dim XX1 As Long, XX2 As Long
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
    Dim XFactor As Single
    XFactor = (Form1.Picture11.ScaleWidth) / Decompress(Len(StrainSeq(0)))
    'Exit Sub
    Pic11PointerVal = x ' / 12

    If Int(((Pic11PointerVal) / XFactor)) > 0 And Int(((Pic11PointerVal) / XFactor)) < Len(StrainSeq(0)) Then
        's = XDiffPos(408)
        
        If DebuggingFlag < 2 Then On Error Resume Next
        If IDDisplayMode = 0 Then
            Form1.Label15.Caption = (Int(10000 * BkgIdentity(Beginning + Int(((Pic11PointerVal) / (XFactor)))))) / 10000
        ElseIf IDDisplayMode = 1 Then
            Form1.Label15.Caption = (Int(10000 * TajD(Beginning + Int(((Pic11PointerVal) / (XFactor)))))) / 10000
        ElseIf IDDisplayMode = 2 Then
            Form1.Label15.Caption = (Int(10000 * GCContent(Beginning + Int(((Pic11PointerVal) / (XFactor)))))) / 10000
        End If
        On Error GoTo 0
    Else
        Form1.Label15.Caption = "--"
    End If
    
    CurGeneNo = 0
    If ORFFlag = 1 Then
        If Picture11.MouseIcon <> Form1.Command1.MouseIcon Then
            Picture11.MouseIcon = Form1.Command1.MouseIcon
        End If
        Pic20PointerVal = x
        'Frame = Int(3 * ((Y - 2) / (picture11.ScaleHeight - 4)))
    
        Dim P20XFactor As Double, GeneNo As Long, oGeneNo As Long, P4H As Long, OHeight As Long
    
        P20XFactor = Picture11.ScaleWidth / Decompress(Len(StrainSeq(0)))
        P4H = Picture11.ScaleHeight '20
        'If Frame < 0 Then Frame = 0
        OHeight = (P4H - 2) / 3
        If Y >= 0 And Y <= OHeight Then  'P4H Then
            Frame = 0
            Y1 = 1
            Y2 = OHeight - 1
        ElseIf Y >= OHeight And Y <= OHeight * 2 Then
            Frame = 1
            If FatGeneFlag = 1 Then
                Y1 = 4
                Y2 = OHeight * 2 + 2
                If P4H = 26 Then
                    Y2 = Y2 + 1
                End If
            Else
                
                Y1 = OHeight + 1
                Y2 = OHeight * 2 - 1
            End If
        ElseIf Y >= OHeight * 2 And Y <= P4H Then
            Frame = 2
            Y1 = OHeight * 2 + 1
            Y2 = P4H - 3
        End If
        Dim FATAdj As Long
        If FatGeneFlag = 1 Then
            If P4H = 26 Then
                FATAdj = 4
            Else
                FATAdj = 2
            End If
        Else
            FATAdj = 0
        End If
        GeneNo = ORFWin(Frame, Int((x / Picture11.ScaleWidth) * Decompress(Len(StrainSeq(0)))))
        CurGeneNo = GeneNo
        Dim PolyPoints() As POINTAPI, MhDC As Long
        MhDC = Form1.Picture4.hdc
        ReDim PolyPoints(5)
        If GeneNo > 0 And (HighlightFlagII = 0 Or LastGeneNo <> GeneNo) Then
            If UBound(AVTaj, 1) <> GeneNumber Then
                ReDim Preserve AVTaj(GeneNumber), AvBKG(GeneNumber), AvGCContent(GeneNumber)
            End If
            HighlightFlagII = 1
            Picture11.Refresh
            PositionIndicaterOn = 0
            Form1.Picture11.DrawMode = 13 '*
            Picture11.AutoRedraw = False
            Picture11.DrawWidth = 1
    
            If GeneList(GeneNo).IntronFlag = 0 Then
                Frame = Abs(GeneList(GeneNo).Frame - 3)
    
                If GeneList(GeneNo).EndInAlign > GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 1 Then
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                    XX2 = GeneList(GeneNo).StartInAlign
                    XX1 = GeneList(GeneNo).EndInAlign
                    
                    If IDDisplayMode = 0 Then
                        Dim pCounter As Long, TotVal As Single
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                     ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    PolyPoints(0).x = X2: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X1 - 2 - FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X1 - 2 - FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X2: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X2: PolyPoints(5).Y = Y1
                    
                    Form1.Picture11.FillStyle = 0
                    Form1.Picture11.FillColor = RGB(250, 0, 0)
                    Form1.Picture11.ForeColor = RGB(250, 0, 0)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
                    Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                    Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture11.DrawMode = 13
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).EndInAlign < GeneList(GeneNo).StartInAlign And GeneList(GeneNo).Orientation = 2 Then
                    X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                    X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                    XX1 = GeneList(GeneNo).StartInAlign
                    XX2 = GeneList(GeneNo).EndInAlign
                    
                    
                    If IDDisplayMode = 0 Then
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                     ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture11.FillStyle = 0
                    Form1.Picture11.FillColor = RGB(250, 0, 0)
                    Form1.Picture11.ForeColor = RGB(250, 0, 0)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
                    Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                    Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture11.DrawMode = 13
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).Orientation = 1 Then
                    X2 = CInt(P20XFactor * 1) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) + 1
                    XX2 = 1
                    XX1 = GeneList(GeneNo).EndInAlign
                    If IDDisplayMode = 0 Then
                        If AvBKG(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            
                        End If
                     ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            
                        End If
                    End If
                    
                    PolyPoints(0).x = X2 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X1 - 4 - FATAdj: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X1 - 4 - FATAdj: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X2 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X2 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture11.FillStyle = 0
                    Form1.Picture11.FillColor = RGB(250, 0, 0)
                    Form1.Picture11.ForeColor = RGB(250, 0, 0)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
                    Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                    Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture11.DrawMode = 13
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
'                    Form1.Picture11.DrawMode = 13 '*
                    
                    
                    X2 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                    XX2 = GeneList(GeneNo).StartInAlign
                    XX1 = Len(StrainSeq(0))
                    
                    If IDDisplayMode = 0 Then
                        
                        If AvBKG(GeneNo) = 0 Then
                           
                            For x = XX2 To XX1
                                
                                If x <= UBound(BkgIdentity, 1) Then
                                    pCounter = pCounter + 1
                                    TotVal = TotVal + (BkgIdentity(x))
                                End If
                            Next x
                            AvBKG(GeneNo) = TotVal / pCounter
                        End If
                    ElseIf IDDisplayMode = 1 Then
                        If AVTaj(GeneNo) = 0 Then
                            
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (TajD(x))
                            Next x
                            AVTaj(GeneNo) = TotVal / pCounter
                        End If
                     ElseIf IDDisplayMode = 2 Then
                        If AvGCContent(GeneNo) = 0 Then
                            pCounter = 0
                            TotVal = 0
                            For x = XX2 To XX1
                                pCounter = pCounter + 1
                                TotVal = TotVal + (GCContent(x))
                            Next x
                            AvGCContent(GeneNo) = TotVal / pCounter
                        End If
                    End If
                    
                    PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                    PolyPoints(1).x = X2 + 1: PolyPoints(1).Y = Y1
                    PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                    PolyPoints(3).x = X2 + 1: PolyPoints(3).Y = Y2
                    PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                    PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                    
                    Form1.Picture11.FillStyle = 0
                    Form1.Picture11.FillColor = RGB(250, 0, 0)
                    Form1.Picture11.ForeColor = RGB(250, 0, 0)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
                    Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                    Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                    Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                    
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Form1.Picture11.DrawMode = 13
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    
                    LastGeneNo = GeneNo
                ElseIf GeneList(GeneNo).Orientation = 2 Then
                    X2 = CInt(P20XFactor * 1) - 1
                    X1 = CInt(P20XFactor * GeneList(GeneNo).StartInAlign) + 1
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture11.DrawMode = 13
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    Form1.Picture11.DrawMode = 13 '*
                    X2 = CInt(P20XFactor * GeneList(GeneNo).EndInAlign) - 1
                    X1 = CInt(P20XFactor * Len(StrainSeq(0))) + 1
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
                    Form1.Picture11.DrawMode = 13
                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = GeneNo
                End If
                'XX = Right(GeneList(GeneNo).Name, 5)
                
                Dim OutString As String
                
                If IDDisplayMode = 0 Then
                    OutString = Trim(Str(AvBKG(GeneNo)))
                ElseIf IDDisplayMode = 1 Then
                    OutString = Trim(Str(AVTaj(GeneNo)))
                ElseIf IDDisplayMode = 2 Then
                    OutString = Trim(Str(AvGCContent(GeneNo)))
                End If
                If Left(OutString, 1) = "." Then OutString = "0" + OutString
                If Left(OutString, 2) = "-." Then
                    OutString = "-0" + Right(OutString, Len(OutString) - 1)
                End If
                If IDDisplayMode = 0 Then
                    OutString = " (average pairwise identity = " + OutString + ")"
                ElseIf IDDisplayMode = 1 Then
                    OutString = " (average Tajima's D = " + OutString + ")"
                ElseIf IDDisplayMode = 2 Then
                    OutString = " (average GC content = " + OutString + ")"
                End If
                
                If GeneList(GeneNo).Product <> "" Then
                    OutString = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product + OutString
                Else
                    OutString = GeneList(GeneNo).Name + OutString
                End If
                Picture11.ToolTipText = OutString
            Else
                oGeneNo = GeneNo
                If GeneList(GeneNo).ExonNumber > 1 Then
    
                    Do
                        GeneNo = GeneNo - 1
    
                        If GeneList(GeneNo).ExonNumber = 1 Then Exit Do
                    Loop
    
                End If
                pCounter = 0
                TotVal = 0
                For Z = GeneNo To GeneNo + GeneList(GeneNo).IntronFlag
                    Picture11.DrawMode = 5
                    Picture11.AutoRedraw = False
                    Frame = Abs(GeneList(Z).Frame - 3)
    
                    If Frame < 0 Then Frame = 0
    
                    If Frame = 0 Then
                        Y1 = 1
                        Y2 = OHeight - 1
                    ElseIf Frame = 1 Then
                        If FatGeneFlag = 1 Then
                            Y1 = 4
                            Y2 = 14
                        Else
                            
                            Y1 = OHeight + 1
                            Y2 = OHeight * 2 - 1
                        End If
                    ElseIf Frame = 2 Then
                        Y1 = OHeight * 2 + 1
                        Y2 = P4H - 3
                    End If
    
                    'this needs to be sorted out
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        XX1 = GeneList(Z).StartInAlign + 1
                        XX2 = GeneList(Z).EndInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign > GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign + 1
                        XX1 = GeneList(Z).StartInAlign + 1
                        XX2 = GeneList(Z).EndInAlign - 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign - 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 2 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        XX1 = GeneList(Z).StartInAlign - 1
                        XX2 = GeneList(Z).EndInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    ElseIf GeneList(Z).StartInAlign < GeneList(Z).EndInAlign And GeneList(Z).Orientation = 1 Then
                        X1 = P20XFactor * GeneList(Z).StartInAlign - 1
                        XX1 = GeneList(Z).StartInAlign - 1
                        XX2 = GeneList(Z).EndInAlign + 1
                        X2 = P20XFactor * GeneList(Z).EndInAlign + 1
                    End If
                    
                    If (GeneList(Z).ExonNumber = 1 And GeneList(Z).IntronFlag > 0 And GeneList(Z).Orientation = 2) Or (GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1 And GeneList(Z).Orientation = 1) Then
                       ' GeneList(Z).StartInAlign = 1600
                        If GeneList(Z).Orientation = 1 Then
                            If X1 < X2 Then
                            If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                       
                                        For x = XX1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                            
                                            
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                 ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        AvGCContent(GeneNo) = TotVal / pCounter
                                    End If
                                End If
                            
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 4 - FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 4 - FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            Else
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(1).Y = Y1
                                PolyPoints(2).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = 0: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 4 - FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 4 - FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = 0: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = 0: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            End If
                        Else
                            
                            If X2 < X1 Then
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            Else
                            
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 4 + FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 4 + FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                
                                PolyPoints(0).x = 0: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X1 + 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X1 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X1 + 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = 0: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = 0: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            End If
                                    
                        End If
                    Else
                        'GeneList(Z).StartInAlign = 100
                        
                        If GeneList(Z).Orientation = 2 Then
                            If X2 < X1 Then
                            
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            Else
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX2 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 - 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 - 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 - 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX1
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = X1 + 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = 0: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = 0: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = 0: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 + 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 + 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            End If
                        Else
                            If X1 < X2 Then
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = X1 - 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X2 + 1 + FATAdj: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X2 + 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X2 + 1 + FATAdj: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X1 - 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X1 - 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            Else
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = XX1 To Len(StrainSeq(0))
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                PolyPoints(0).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(0).Y = Y1
                                PolyPoints(1).x = X1 - 1: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = X1 - 1: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = X1 - 1: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(4).Y = Y2
                                PolyPoints(5).x = P20XFactor * Len(StrainSeq(0)): PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                If IDDisplayMode = 0 Then
                       
                                    If AvBKG(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            If x <= UBound(BkgIdentity, 1) Then
                                                pCounter = pCounter + 1
                                                TotVal = TotVal + (BkgIdentity(x))
                                            End If
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 1 Then
                                    If AVTaj(GeneNo) = 0 Then
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (TajD(x))
                                        Next x
                                    End If
                                ElseIf IDDisplayMode = 2 Then
                                    If AvGCContent(GeneNo) = 0 Then
                                        pCounter = 0
                                        TotVal = 0
                                        For x = 1 To XX2
                                            pCounter = pCounter + 1
                                            TotVal = TotVal + (GCContent(x))
                                        Next x
                                        
                                    End If
                                End If
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                PolyPoints(0).x = X2 + 1: PolyPoints(0).Y = Y1
                                PolyPoints(1).x = 0: PolyPoints(1).Y = Y1
                                PolyPoints(2).x = 0: PolyPoints(2).Y = Y1 + ((Y2 - Y1) / 2)
                                PolyPoints(3).x = 0: PolyPoints(3).Y = Y2
                                PolyPoints(4).x = X2 + 1: PolyPoints(4).Y = Y2
                                PolyPoints(5).x = X2 + 1: PolyPoints(5).Y = Y1
                                
                                Form1.Picture11.FillStyle = 0
                                Form1.Picture11.FillColor = RGB(250, 0, 0)
                                Form1.Picture11.ForeColor = RGB(250, 0, 0)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                                
                                Form1.Picture11.ForeColor = RGB(BkR, BkG, BkB)
                                Form1.Picture1.FillColor = RGB(BkR, BkG, BkB)
                                Polygon Form1.Picture11.hdc, PolyPoints(0), 5
                            End If
                        End If
                    End If
    
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(150, 150, 0), BF
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), RGB(BkR, BkG, BkB), BF
'                    Picture11.DrawMode = 13
'                    Form1.Picture11.Line (X1, Y1)-(X2, Y2), BackColours, B
                    LastGeneNo = oGeneNo
                Next 'Z
    
                If IDDisplayMode = 0 Then
                       
                    If AvBKG(GeneNo) = 0 Then
                        AvBKG(GeneNo) = TotVal / pCounter
                    End If
                ElseIf IDDisplayMode = 1 Then
                    If AVTaj(GeneNo) = 0 Then
                        AVTaj(GeneNo) = TotVal / pCounter
                    End If
                ElseIf IDDisplayMode = 2 Then
                    If AvGCContent(GeneNo) = 0 Then
                        AvGCContent(GeneNo) = TotVal / pCounter
                    End If
                End If
                
                If IDDisplayMode = 0 Then
                    OutString = Trim(Str(AvBKG(GeneNo)))
                ElseIf IDDisplayMode = 1 Then
                    OutString = Trim(Str(AVTaj(GeneNo)))
                ElseIf IDDisplayMode = 2 Then
                    OutString = Trim(Str(AvGCContent(GeneNo)))
                End If
                If Left(OutString, 1) = "." Then OutString = "0" + OutString
                If Left(OutString, 2) = "-." Then
                    OutString = "-0" + Right(OutString, Len(OutString) - 1)
                End If
                If IDDisplayMode = 0 Then
                    OutString = " (average pairwise identity = " + OutString + ")"
                ElseIf IDDisplayMode = 1 Then
                    OutString = " (average Tajima's D = " + OutString + ")"
                ElseIf IDDisplayMode = 2 Then
                    OutString = " (average GC content = " + OutString + ")"
                End If
                
                If GeneList(GeneNo).Product <> "" Then
                    OutString = GeneList(GeneNo).Name & " : " & GeneList(GeneNo).Product + OutString
                Else
                    OutString = GeneList(GeneNo).Name + OutString
                End If
                Picture11.ToolTipText = OutString
                
            End If
    
            Picture11.DrawMode = 12
            Picture11.AutoRedraw = True
            Picture11.MousePointer = 99
        ElseIf ORFWin(Frame, Int((x / Picture11.ScaleWidth) * Len(StrainSeq(0)))) = 0 And HighlightFlagII = 1 Then
            DontDoH1Inc = 1
            OnlyDoPositionIndicator = 1
            Call HScroll1_Change
            OnlyDoPositionIndicator = 0
            DontDoH1Inc = 0
            HighlightFlagII = 0
            If IDDisplayMode = 0 Then
                Picture11.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 1 Then
                Picture11.ToolTipText = "Average Tajima D identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 2 Then
                Picture11.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
            End If
            Picture11.MousePointer = 0
        ElseIf ORFWin(Frame, Int((x / Picture11.ScaleWidth) * Len(StrainSeq(0)))) = 0 Then
            If IDDisplayMode = 0 Then
                Picture11.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 1 Then
                Picture11.ToolTipText = "Average Tajima D (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 2 Then
                Picture11.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
                
            End If
            Picture11.MousePointer = 0
        End If
    End If
    
End Sub

Private Sub Picture4_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Picture12.Visible = False
End Sub
Private Sub Picture11_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Picture12.Visible = False
End Sub


Private Sub Picture5_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If HighlightFlag = 1 Then 'This unhighlights a selected event in the schematic sequence dsiplay
    Picture6.Refresh
    CurFlash = 0
    Timercheck(1) = 0
    Call Timer1_Timer
    HighlightFlag = 0
    RecSeq = 0
    PAVal = 0
    If RIMode = 1 Then
        Call MakeSummary
    End If
End If
End Sub

Private Sub Picture6_KeyDown(KeyCode As Integer, Shift As Integer)

Call DoKeydown(KeyCode)
If KeyCode = vbKeyPageUp Or KeyCode = vbKeyLeft Then 'Or KeyCode = vbKeyUp
    Call GoToPreviousEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeyPageDown Or KeyCode = vbKeyRight Then 'Or KeyCode = vbKeyDown
    Call GoToNextEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeySpace Then
    Call GoToBestMnu_Click
End If

If Form1.Picture6.Enabled = True Then
    Form1.Picture6.SetFocus
End If
End Sub

Private Sub Picture6_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)
    Dim LPNT As POINTAPI, YO As Long, ENX As Long
    Dim P6Adj As Single
    P6Adj = P6Width / Form1.Picture5.Width
    x = x
    OY = Y
    YO = VScroll2.Value * F1VS2Adj
    Y = Y + YO
    If Button = 2 Then
        
        If ConsensusProg = 0 Then
            Detect1Mnu.Checked = True
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 1 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = True
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 2 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = True
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 3 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = True
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 4 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = True
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 5 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = True
            Detect7Mnu.Checked = False
        ElseIf ConsensusProg = 6 Then
            Detect1Mnu.Checked = False
            Detect2Mnu.Checked = False
            Detect3Mnu.Checked = False
            Detect4Mnu.Checked = False
            Detect5Mnu.Checked = False
            Detect6Mnu.Checked = False
            Detect7Mnu.Checked = True
        
        End If
        Form1.RSortMnu2.Caption = "Re-identify recombinant sequences for all unaccepted events"
            
        Form1.RSortMnu2.Visible = True
        Form1.RCheckMnu.Visible = True
        yPicRef = Int(((Y / SpaceAdjust) - 3) / 12)
        Z = 0
    
        If yPicRef < 0 Then Exit Sub
        If yPicRef - Z > UBound(PermArray, 2) Then Exit Sub
        Do While PermArray(0, yPicRef - Z) >= 0
            Z = Z + 1

            If yPicRef - Z <= 0 Then
                Exit Do
            End If

        Loop
        yPicRef = Int(((Y / SpaceAdjust) - 3) / 12)
        If UBound(PermArray, 2) >= (yPicRef - Z) And yPicRef - Z >= 0 Then
            tRecSeqX = Abs(PermArray(0, yPicRef - Z))
        ElseIf yPicRef > 0 Then
            tRecSeqX = NextNo
        Else
            tRecSeqX = 0
        End If
        
        If ShowAllHits(tRecSeqX) = 0 Then
            Form1.ShowAllMnu.Caption = "Show all recombintion evidence for " & OriginalName(tRecSeqX)
        Else
            Form1.ShowAllMnu.Caption = "Show only best recombination evidence for " & OriginalName(tRecSeqX)
        
        End If
        
    End If
    If MenuUpFlag = 1 Then
        MenuUpFlag = 0
        Exit Sub
    End If
    'RunFlag = 1
    If RunFlag > 0 Then
        CurrentCheck = -1
        If F2ontop = 0 Then
            Form1.ZOrder
        End If
        Dim ShowFinger As Integer, XPicRef As Long
        Dim scFactorX As Double

        ShowFinger = 0
        scFactorX = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
        XPicRef = CLng((x - 5 * P6Adj) / scFactorX)

        If x <= Form1.Picture5.ScaleWidth - 5 * P6Adj And x > 5 * P6Adj And Y >= 3 And PAVal > 0 Then
            
            Dim OffS As Long
            OffS = 0.005 * Len(StrainSeq(0))
            If OffS < 10 Then OffS = 10
            If XoverList(RecSeq, PAVal).Beginning < XoverList(RecSeq, PAVal).Ending Then

                If XPicRef >= XoverList(RecSeq, PAVal).Beginning - OffS And XPicRef <= XoverList(RecSeq, PAVal).Ending + OffS Then ShowFinger = 1
            Else
                TVar = OffS
                TVar = TVar * Len(StrainSeq(0))
                If XPicRef <= XoverList(RecSeq, PAVal).Ending + TVar Or XPicRef >= XoverList(RecSeq, PAVal).Beginning - OffS Then ShowFinger = 1
            End If

            
            'If XOverList(RecSeq, PAVal).Beginning < XOverList(RecSeq, PAVal).Ending Then'

            '    If XPicRef >= XOverList(RecSeq, PAVal).Beginning - 10 And XPicRef <= XOverList(RecSeq, PAVal).Ending + 10 Then ShowFinger = 1
            'ElseIf XOverList(RecSeq, PAVal).Beginning > XOverList(RecSeq, PAVal).Ending Then

             '   If XPicRef <= XOverList(RecSeq, PAVal).Ending + 10 Or XPicRef >= XOverList(RecSeq, PAVal).Beginning - 10 Then ShowFinger = 1
            'End If

        End If

        If ShowFinger = 0 And PAVal <= 0 Then

            If Button = 2 Then
                SaveBMPFlag = 3
                Form1.PopupMenu SchemMnu
            ElseIf Button = 1 Then
                Form1.ScaleMode = 3
                If SchemFlag = 1 Then
                    Picture12.Height = 125 * (15 / Screen.TwipsPerPixelY)
                    Picture12.Width = 80 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = OY + Picture6.Top + SSPanel5.Top + 5 - Picture12.Height '+ Picture4.Top + Y
                    Picture12.Left = x + Picture6.Left + SSPanel5.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Line (50, 50)-(200, 200), ProgColour(0), BF
                    Picture12.Line (50, 250)-(200, 400), ProgColour(1), BF
                    Picture12.Line (50, 450)-(200, 600), ProgColour(2), BF
                    Picture12.Line (50, 650)-(200, 800), ProgColour(3), BF
                    Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
                    Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
                    Picture12.Line (50, 1250)-(200, 1400), ProgColour(6), BF
                    Picture12.Line (50, 1450)-(200, 1600), ProgColour(7), BF
                    Picture12.Line (50, 1650)-(200, 1800), ProgColour(8), BF
                    
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + 14
                    Picture12.Print "RDP"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 250 + 14
                    Picture12.Print "GENECONV"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 450 + 14
                    Picture12.Print "Bootscan"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 650 + 14
                    Picture12.Print "MaxChi"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 850 + 14
                    Picture12.Print "Chimaera"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1050 + 14
                    Picture12.Print "SiScan"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1250 + 14
                    Picture12.Print "PylPro"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1450 + 14
                    Picture12.Print "LARD"
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 1650 + 14
                    Picture12.Print "3Seq"
                    
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50
                    
                    Picture12.Print "RDP"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 250
                    Picture12.Print "GENECONV"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 450
                    Picture12.Print "Bootscan"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 650
                    Picture12.Print "MaxChi"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 850
                    Picture12.Print "Chimaera"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1050
                    Picture12.Print "SiScan"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1250
                    Picture12.Print "PylPro"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1450
                    Picture12.Print "LARD"
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 1650
                    Picture12.Print "3Seq"
                    Picture12.Visible = True
                ElseIf SchemFlag = 2 Then
                    Form1.ScaleMode = 3
                    Picture12.Height = 200
                    Picture12.Width = 60 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = OY + Picture6.Top + SSPanel5.Top + 5 - Picture12.Height '+ Picture4.Top + Y
                    Picture12.Left = x + Picture6.Left + SSPanel5.Left + 5 'Picture4.Left + x
                    Picture12.Picture = LoadPicture()
                    Picture12.AutoRedraw = True
                    Picture12.Visible = True
    
                    
    
                    curline = 0
                    Pict = Picture12.hdc
                    
                    For RCol = 0 To 1020 Step 4
                        curline = RCol / 1020 * 155 + 10
                        Picture12.ForeColor = HeatMap(6, RCol)
                        Dummy = MoveToEx(Pict, 2, curline, LPNT)
                        Dummy = LineTo(Pict, 20, curline)
                    Next
    
                    
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 75 / (15 / Screen.TwipsPerPixelY)
                    MaxLogPVal = -Log10(LowestProb)
                    Picture12.Print "-  " & Int(MaxLogPVal * 10) / 10
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 651 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & (Int(((MinLogPValSch + MaxLogPVal) / 2 + MaxLogPVal) / 2 * 10)) / 10
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 1227 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & (Int((MinLogPValSch + MaxLogPVal) / 2 * 10)) / 10
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 1803 / (15 / Screen.TwipsPerPixelY)
                    
                    If (Int((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2 * 10)) / 10 < 100 Then
                        Picture12.Print "-  " & (Int((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2 * 10)) / 10
                    Else
                        Picture12.Print "-  " & (Int((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2))
                    End If
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 2380 / (15 / Screen.TwipsPerPixelY)
                    If Int(MinLogPValSch * 10) / 10 < 100 Then
                        Picture12.Print "-  " & Int(MinLogPValSch * 10) / 10
                    Else
                        Picture12.Print "-  " & Int(MinLogPValSch)
                    End If
                    Picture12.CurrentX = 70
                    Picture12.CurrentY = 2680 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-Log(P-Val)"
                    Picture12.Refresh
                ElseIf SchemFlag = 3 Then
                    Form1.ScaleMode = 3
                    Picture12.Height = 210
                    Picture12.Width = 58 * (14 / Screen.TwipsPerPixelX)
                    Picture12.ZOrder
                    Picture12.Top = OY + Picture6.Top + SSPanel5.Top + 5 - Picture12.Height '+ Picture4.Top + Y
                    Picture12.Left = x + Picture6.Left + SSPanel5.Left + 5 'Picture4.Left + x
                    Picture12.Picture = Picture4.Picture
                    Picture12.AutoRedraw = True
                    Picture12.Visible = True
    
                    
    
                    curline = 0
                    Pict = Picture12.hdc
    
                    For RCol = 0 To 1020 Step 4
                        curline = RCol / 1020 * 155 + 10
                        Picture12.ForeColor = HeatMap(6, RCol)
                        Dummy = MoveToEx(Pict, 2, curline, LPNT)
                        Dummy = LineTo(Pict, 20, curline)
                    Next
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 75 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & Int(MinDistSch * 100) / 100
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 651 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & (Int(((MaxDistSch + MinDistSch) / 2 + MinDistSch) / 2 * 100)) / 100
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 1227 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & (Int((MaxDistSch + MinDistSch) / 2 * 100)) / 100
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 1803 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & (Int((MaxDistSch + (MaxDistSch + MinDistSch) / 2) / 2 * 100)) / 100
                    Picture12.CurrentX = 350
                    Picture12.CurrentY = 2380 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "-  " & Int(MaxDistSch * 100) / 100
                    Picture12.CurrentX = 150
                    Picture12.CurrentY = 2680 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "Parental"
                    Picture12.CurrentX = 175
                    Picture12.CurrentY = 2880 / (15 / Screen.TwipsPerPixelY)
                    Picture12.Print "identity"
                    Picture12.Refresh
                End If
            End If

        Else

            If Button = 1 And ShowFinger = 1 Then
                exRelX = RelX
                exRely = RelY
                RelX = RecSeq
                RelY = PAVal
                PermXVal = x
                PermYVal = Y
                'XX = PermArray(X, Y)
            ElseIf Button = 1 And ShowFinger = 0 Then
                Exit Sub
            
            Else
                PermXVal2 = x
                PermYVal2 = Y
                x = x
            End If
            
            
            
            
    '0.00
            SS = Abs(GetTickCount)
            
            Call SchemDown(Button)
            SchemDownFlag = 1
            DontDoTimer4Flag = 1
            DontDoTimer1Flag = 1
            EE = Abs(GetTickCount)
            TT = EE - SS
            'XX = Nextno
            x = x '34.984 seconds'47.219'46.782'13.297
            'Urmilla event 1
            '6344, 6703, 5968, 5453 dropping jount treedist and distance to disk
            '209699 event 64 Fred 100000
            '12719 reclick, 12297, 11297, 11250
            
            '25.070 for 3800 flue seqs
            '27.384 with strainseq dumped to disk
            '26.879 with strainseq dumped only once
            '25.709 without form resize
            '22.807 with c++ optimization of dotreecolours
            '22.779 with MakeSC11
            '22.464 with MakeSC12
            '21.216 with all makeSCs
            '20.312 with nodearrays
            '17.877 with eraseempties
            '17.175 with maketreematrix etc
            '17.020 with new makenucs approach
            '15.382 after reordering the sequences
            If ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And XoverList(RelX, RelY).SBPFlag = 3) Then
                'This is to force the sequence display into the show all seqs setting
                '(none of the other settings work for geneconv or maxchi with entire alignment scan)
                'ShowSeqFlag = 0
                Form1.Picture3.Enabled = True
            ElseIf ShowSeqFlag > 0 Or Seq1 = Seq2 Then
                DontDoH1Inc = 1
                Call HScroll1_Change
                DontDoH1Inc = 0

            End If

            If RelX = RecSeq And PAVal = RelY Then
                DontDoH1Inc = 1
                Call HScroll1_Change
                DontDoH1Inc = 0

            End If
            If ColDistInFile = 1 Then
                If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
                   'redim SubValid(0,0)
                    ReDim SubDiffs(0, 0)
                    'redim sMat(0,0)
                    ReDim FubValid(0, 0)
                    'Erase FMat
                End If
                
                ReDim ColDist2(0)
                Timer7(1).Enabled = False
            End If
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Screen.MousePointer = 0
            SchemDownFlag = 0
            DontDoTimer4Flag = 0
            DontDoTimer1Flag = 0
        End If

    End If
    eex = Abs(GetTickCount)
    ttt = eex - SSX
    x = x
    '22.165
    '15.485 - without unnecessary distance calculations
    '14.063 - minus second upgma
    '8.453 - minus extra distancecalc in maketreeseqs
    
End Sub

Public Sub Picture6_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
Dim X2 As Long, X1 As Long, T1 As Long, TVar As Long, Z As Long, GoOn As Long, xPAVal As Long, XYPicRef As Long, GoOnX As Long, VS4 As Long, VST As Long, StepSizeX As Long, UB As Long
Dim EN As Long




If Form2.Visible = True And Form2.WindowState = 0 And Form2OnTopFlag = 0 And DontPutForm2Ontop = 0 And Form2.hwnd = GetForegroundWindow Then
    Dummy = SetTopMostWindow(Form2.hwnd, True)
    Form2OnTopFlag = 1
End If

F2P2Y = -1
P1Seq = -1
P1NT = -1
F1P7X = -1
F1P2Y = -1
F1P3Y = -1
F1P6Y = Y
F2P3Y = -1
F1P16Y = -1
F1P26Y = -1
F2P2Index = -1

If Picture5.Enabled = False Then
        Exit Sub
    End If

If NextNo <> PermNextno Then
    UnModNextno
End If
Dim P6Adj As Single
P6Adj = P6Width / Form1.Picture5.Width

If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
    ProgColour(7) = RGB(128, 64, 64)
    Dim OY As Long, YOff As Long, CurMCCorrection As Long, Px As Long, PY As Long, BEW As Byte, ENW As Byte
    Dim P1 As String, P2 As String, P3 As String, P4 As String, P5 As String, P6 As String, BPos As Long, Epos As Long
    If Picture5.Enabled = False Then
        Exit Sub
    End If
    'SSPanel16.ZOrder
    Dim XOS As Integer
    BEW = 0
    ENW = 0
    'If Form1.SchemEditMnu.Visible = True Then
    '    Exit Sub
    'End If
    'Picture6.SetFocus
    OY = Y
    YOff = VScroll2.Value * F1VS2Adj
    Px = x '364
    PY = Y '184
    Y = Y + YOff
   'XX = (OY + YOff)
    'XX = SeqSpaces(1, NextNo)
    If ScanFlagX = 0 Then
        
        Dim ShowFinger As Integer, XPicRef As Long, oldY As Integer
        Dim scFactorX As Double
        Dim SchemPic As PictureBox

        Set SchemPic = Picture6
        

        scFactorX = 1 '(Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
        If AdjArrayPos > 0 Then
            XPicRef = CInt((x * P6Adj - 5 * P6Adj) / scFactorX) / AdjArrayPos
        End If
        SchemPic.DrawMode = 13
        SchemPic.AutoRedraw = False
        XPicAddjust = AdjArrayPos ' (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
        If SpaceAdjust > 0 Then
            yPicRef = Int(((Y / SpaceAdjust) - 3) / 12)
        End If
        'If SuperEventList(XOverList(RelX, RelY).Eventnumber) = 6 Then
        '    X = X
        'End If
        If DebuggingFlag < 2 Then On Error Resume Next
          'UB = -1
          UB = UBound(PermArray, 2)
'            XX = UBound(PermArray, 1)
        On Error GoTo 0
        If UB > 0 Then
            If x * P6Adj <= Form1.Picture5.ScaleWidth - 5 * P6Adj And x * P6Adj > 5 * P6Adj And Y >= 3 And yPicRef <= UBound(PermArray, 2) And x * P6Adj - 5 * P6Adj <= UBound(PermArray, 1) Then
                'XX = UBound(PermArray, 1)
                PAVal = PermArray(x * P6Adj - 5 * P6Adj, yPicRef)
                'PAVal = PermArray((X * P6Adj - 5 * P6Adj), yPicRef)
                If PAVal = 0 Then
                    If (x * P6Adj - 5 * P6Adj) > 0 Then
                        PAVal = PermArray((x * P6Adj - 5 * P6Adj) - 1, yPicRef)
                    End If
'                ElseIf PAVal < 0 Then
'                    X = X
                End If
'                If PAVal < 0 Then
'                X = X
'            End If
        End If
            'If PAVal = 0 Then
            '     PAVal = PermArray(X, yPicRef)
            'End If
            If PAVal > 0 Then
                GoOnX = 1
                'LastPermYVal = -1
                'LastPermXVal = -1
            Else 'If X = 12345 Then
                If (PermXVal <> LastPermXVal Or PermYVal <> LastPermYVal) Then
                     
                    XYPicRef = Int(((PermYVal / SpaceAdjust) - 3) / 12)
                    If XYPicRef >= 0 Then
                        If PermXVal - 5 * P6Adj > UBound(PermArray, 1) Or XYPicRef > UBound(PermArray, 2) Then
                            Exit Sub
                        End If
                        If PermXVal < 5 * P6Adj Then
                            Exit Sub
                        End If
                        
                        xPAVal = PermArray(PermXVal - 5 * P6Adj, XYPicRef)
                        
                        If (RecSeq <> RelX Or xPAVal <> RelY) Or x = x Then
                            'SSPanel1.Caption = Str(PermXVal) + ":" + Str(PermYVal) + "," + Str(LastPermXVal) + ":" + Str(LastPermYVal)
                            PAVal = RelY
                            
                            RecSeq = RelX
                            LastPermXVal = PermXVal
                            LastPermYVal = PermYVal
                            
                            'Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value)
                            
                            x = PermXVal
                            Y = PermYVal
                            OY = Y
                            
                            Px = x '364
                            PY = Y '184
                            Y = Y + YOff
                            yPicRef = Int(((PermYVal / SpaceAdjust) - 3) / 12)
                            XPicRef = CInt((x * P6Adj - 5 * P6Adj) / scFactorX) / AdjArrayPos
                            OPAVal = -1
                            'PAVal = xPAVal
                            GoOnX = 1
                        Else
                            GoOn = 0
                        End If
                    Else
                        GoOnX = 0
                    End If
                    
                    'Exit Sub
                Else
                    'SSPanel1.Caption = ""
                    GoOnX = 0
                End If
            End If
            x = x
            If GoOnX = 1 Then 'if its past here it means the pointer is on a event block or an event name
                
                Z = 0
                If yPicRef > UBound(PermArray, 2) Then
                    yPicRef = UBound(PermArray, 2)
                End If
                If yPicRef - Z < 0 Then
                    Exit Sub
                End If
                Do While PermArray(0, yPicRef - Z) = 0
                    Z = Z + 1

                    If yPicRef - Z <= 0 Then
                        Exit Do
                    End If

                Loop
                If yPicRef - Z < 0 Then
                    Exit Sub
                End If
                If OY >= 0 Then
                
                    RecSeq = Abs(PermArray(0, yPicRef - Z))
                End If
                If RecSeq > NextNo Or PAVal > UBound(XoverList, 2) Then
                    x = Px
                    Y = PY
                    
                    Exit Sub
                End If
                oxPAVal = PAVal
                oxRecSeq = RecSeq
                ShowFinger = 0
                Dim OffS As Long
                OffS = 0.005 * Len(StrainSeq(0))
                If OffS < 10 Then OffS = 10
                If XoverList(RecSeq, PAVal).Beginning < XoverList(RecSeq, PAVal).Ending Then

                    If XPicRef >= (XoverList(RecSeq, PAVal).Beginning - OffS) And XPicRef <= (XoverList(RecSeq, PAVal).Ending + OffS) Then
                        ShowFinger = 1
                    End If
                Else
                    TVar = OffS
                    TVar = TVar * Len(StrainSeq(0))
                    If XPicRef <= XoverList(RecSeq, PAVal).Ending + TVar Or XPicRef >= XoverList(RecSeq, PAVal).Beginning - OffS Then
                        ShowFinger = 1
                    End If
                End If


                Dim PRFlag As Integer

                PRFlag = XoverList(RecSeq, PAVal).ProgramFlag

                If PRFlag > AddNum - 1 Then PRFlag = PRFlag - AddNum

                If ShowFinger = 1 And (HighlightFlag = 0 Or OPAVal <> PAVal Or Pic7GoonFlag = 1) Then
                    
                    
                    OPAVal = PAVal
                    SchemPic.MousePointer = 99
                    SchemPic.ToolTipText = "Event " + Trim(Str(SuperEventList(XoverList(RecSeq, PAVal).Eventnumber))) + ": left click to draw trees and plots, right click for options"
                    'SchemPic.ToolTipText = "Event " + Trim(Str(SuperEventList(XOverlist(RecSeq, PAVal).Eventnumber))) + ": left click to draw trees and plots, right click for options "
                    
                    T1 = yPicRef
                    
                    SchemPic.Refresh
                    CurFlash = 0
                    Timercheck(1) = 0

                    Call Timer1_Timer
                    yPicRef = T1
                    If Shift = 0 Then
                        
                        If RecSeq <> RelX Or PAVal <> RelY Then
                            If XoverList(RecSeq, PAVal).Beginning < XoverList(RecSeq, PAVal).Ending Then
                                SchemPic.DrawMode = 7 '15 12
                                X1 = XoverList(RecSeq, PAVal).Beginning * XPicAddjust
                                'XMod = (Len(StrainSeq(0)) / 2 - X1) / (Len(StrainSeq(0)) / 2) * (5 * P6Adj)
                                'X1 = X1 * XPicAddjust + XMod
                                X2 = XoverList(RecSeq, PAVal).Ending * XPicAddjust
                                'XMod = (Len(StrainSeq(0)) / 2 - X2) / (Len(StrainSeq(0)) / 2) * (5 * P6Adj)
                                'X2 = X2 * XPicAddjust + XMod
                                SchemPic.Line ((5 / P6Adj - 3 + X1), (yPicRef * 12 + 3) * SpaceAdjust - 3 - YOff)-((5 / P6Adj + 3 + X2), ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 3 - YOff), RGB(0, 0, 255), BF   '210RGB(203, 203, 171)
                                SchemPic.DrawMode = 13
                                SchemPic.Line ((5 / P6Adj - 1 + X1), (yPicRef * 12 + 3) * SpaceAdjust - 1 - YOff)-((5 / P6Adj + 1 + X2), ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 1 - YOff), mYellow, BF  '210RGB(203, 203, 171)
                                SchemPic.Line ((5 / P6Adj + X1), (yPicRef * 12 + 3) * SpaceAdjust - YOff)-((5 / P6Adj + X2), ((yPicRef + 1) * 12 + 1) * SpaceAdjust - YOff), Yellow, BF   'RGB(255, 255, 0)
                            Else
                                SchemPic.DrawMode = 7 '15 12
                                SchemPic.Line (5 / P6Adj - 3 + 1 * XPicAddjust, (yPicRef * 12 + 3) * SpaceAdjust - 3 - YOff)-(5 / P6Adj + 3 + XoverList(RecSeq, PAVal).Ending * XPicAddjust, ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 3 - YOff), RGB(0, 0, 255), BF '210RGB(203, 203, 171)
                                SchemPic.Line (5 / P6Adj - 3 + XoverList(RecSeq, PAVal).Beginning * XPicAddjust, (yPicRef * 12 + 3) * SpaceAdjust - 3 - YOff)-(5 / P6Adj + 3 + Len(StrainSeq(0)) * XPicAddjust, ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 3 - YOff), RGB(0, 0, 255), BF '210RGB(203, 203, 171)
                                SchemPic.DrawMode = 13
                                SchemPic.Line (5 / P6Adj - 1 + 1 * XPicAddjust, (yPicRef * 12 + 3) * SpaceAdjust - 1 - YOff)-(5 / P6Adj + 1 + XoverList(RecSeq, PAVal).Ending * XPicAddjust, ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 1 - YOff), LYellow, BF '210RGB(203, 203, 171)
                                SchemPic.Line ((5 / P6Adj + 1 * XPicAddjust), (yPicRef * 12 + 3) * SpaceAdjust - YOff)-((5 / P6Adj + XoverList(RecSeq, PAVal).Ending * XPicAddjust), ((yPicRef + 1) * 12 + 1) * SpaceAdjust - YOff), Yellow, BF
                                SchemPic.Line ((5 / P6Adj - 1 + XoverList(RecSeq, PAVal).Beginning * XPicAddjust), (yPicRef * 12 + 3) * SpaceAdjust - 1 - YOff)-((5 / P6Adj + 1 + Len(StrainSeq(0)) * XPicAddjust), ((yPicRef + 1) * 12 + 1) * SpaceAdjust + 1 - YOff), LYellow, BF
                                SchemPic.Line (5 / P6Adj + XoverList(RecSeq, PAVal).Beginning * XPicAddjust, (yPicRef * 12 + 3) * SpaceAdjust - YOff)-(5 / P6Adj + Len(StrainSeq(0)) * XPicAddjust, ((yPicRef + 1) * 12) * SpaceAdjust - YOff), Yellow, BF    'RGB(255, 255, 0)
                            End If
                        End If
                        CurFlash = 1
                    End If

                    HighlightFlag = 1

                    If ShowPlotFlag = 1 Or ShowPlotFlag = 2 Then
                        Frame17.Visible = False
                    End If
                    
                    
                    
                    If RIMode = 1 Then
                        EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
                        VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj
                        
                        If VS4 < 0 Then
                            VS4 = 0
                        ElseIf VS4 > VScroll4.Max Then
                            VS4 = VScroll4.Max
                        End If
                        VST = CLng(VScroll4.Value / V4Adj)
                        StepSizeX = (VS4 - VST) / 10 '7442-10594
                        If StepSizeX = 0 Then StepSizeX = 1
                        XX = PAVal
                        
                        If DSP2Flag = 0 Then
                            If VST <> VS4 Then
                                For x = VST To VS4 Step StepSizeX
                                    If x <= VScroll4.Max Then
                                        VScroll4.Value = CLng(x * V4Adj)
                                    End If
                                Next x
                            End If
                            xxPAVal = PAVal
                            xxRecSeq = RecSeq
                            PAVal = oxPAVal
                            RecSeq = oxRecSeq
                            Call MakeSummary
                            'PAVal = xxPAVal
                            'RecSeq = xxRecSeq
                            x = x
                        Else
                            EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                            If (VScroll4.Value - (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj) > ((Picture32.Height / Screen.TwipsPerPixelY) / 2.25) * V4Adj Then
                                VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 32) * V4Adj
                                
                                If VS4 < VScroll4.Min Then VS4 = VScroll4.Min
                                If VS4 > VScroll4.Max Then VS4 = VScroll4.Max
                                VScroll4.Value = VS4
                            ElseIf ((((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj - VScroll4.Value) > ((Picture32.Height / Screen.TwipsPerPixelY) / 2.7) * V4Adj Then
                                VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 1.125) * V4Adj
                                If VS4 < VScroll4.Min Then VS4 = VScroll4.Min
                                If VS4 > VScroll4.Max Then VS4 = VScroll4.Max
                                VScroll4.Value = VS4
                            End If
                        End If
                        
                        If VScroll4.Value = VS4 Then
                            
                        Else
                            If VS4 <= VScroll4.Max Then
                                If DSP2Flag = 0 Then
                                    VScroll4.Value = VS4
                                End If
                            Else
                                VScroll4.Value = VScroll4.Max
                            End If
                        End If
                        

                    ElseIf RIMode = 0 Then
                                            
                        Call MakeRecombinationInfo(RecSeq, PAVal)
                        LastPermXVal = Px
                        LastPermYVal = PY
                    End If

                    Picture2.Refresh
                ElseIf ShowFinger = 0 Then
                    
                    
                    SchemPic.ToolTipText = "Right click for options"

                    If HighlightFlag = 1 Then
                        SchemPic.Refresh
                        CurFlash = 0
                        Timercheck(1) = 0
                        Call Timer1_Timer
                        RecSeq = 0
                        PAVal = 0
                        If RIMode = 1 Then
                            If RelX = 0 And RelY = 0 Then
                            
                                Call MakeSummary
                                
                            Else
                                EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                                VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj
                                
                                If VS4 < 0 Then
                                    VS4 = 0
                                ElseIf VS4 > VScroll4.Max Then
                                    VS4 = VScroll4.Max
                                End If
                                VST = VScroll4.Value
                                StepSizeX = (VS4 - VST) / 10 '7442-10594
                                If StepSizeX = 0 Then StepSizeX = 1
                                If DSP2Flag = 0 Then
                                    If VST <> VS4 Then
                                        For x = VST To VS4 Step StepSizeX
                                            If x <= VScroll4.Max Then
                                                VScroll4.Value = x
                                            End If
                                        Next x
                                    End If
                                    If VScroll4.Value = VS4 Then
                                    Call MakeSummary
                                    Else
                                        If DSP2Flag = 0 Then
                                            VScroll4.Value = VS4
                                        End If
                                    End If
                                Else
                                
                                   ' VScroll4.Value = VS4
                                End If
                                
                                
                                
                            End If
                        ElseIf RIMode = 0 Then
                            If ManFlag > -1 Then
                                Call DoLegend
                            Else
                                
                            End If
                        
                        End If
                    Else
                       If DSP2Flag = 1 Then
                            EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                            If (VScroll4.Value - (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj) > ((Picture32.Height / Screen.TwipsPerPixelY) / 2.25) * V4Adj Then
                                VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 32) * V4Adj
                                
                                If VS4 < VScroll4.Min Then VS4 = VScroll4.Min
                                If VS4 > VScroll4.Max Then VS4 = VScroll4.Max
                                VScroll4.Value = VS4
                            ElseIf ((((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj - VScroll4.Value) > ((Picture32.Height / Screen.TwipsPerPixelY) / 2.7) * V4Adj Then
                                VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 1.125) * V4Adj
                                If VS4 < VScroll4.Min Then VS4 = VScroll4.Min
                                If VS4 > VScroll4.Max Then VS4 = VScroll4.Max
                                VScroll4.Value = VS4
                            End If
                        
                       End If
                    End If

                    HighlightFlag = 0
                    SchemPic.MousePointer = 0
                    'schempic.ToolTipText = "Schematic Sequence Diplay"
                End If

            ElseIf HighlightFlag = 1 And PAVal <= 0 Then  'If PAVal = 0 Then
                
                HighlightFlag = 0
                'schempic.ToolTipText = ""
                SchemPic.Refresh
                CurFlash = 0
                Timercheck(1) = 0
                RecSeq = 0
                PAVal = 0
                If RIMode = 1 Then
                    If RelX > 0 Or RelY > 0 Then
                        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                        VS4 = (((Picture2.TextHeight("A") + 2) * (EN - 1)) - (Picture32.ScaleHeight / Screen.TwipsPerPixelY) / 2) * V4Adj
                        VST = VScroll4.Value
                        If VS4 < 0 Then
                            VS4 = 0
                        ElseIf VS4 > VScroll4.Max Then
                            VS4 = VScroll4.Max
                        End If
                        VST = VScroll4.Value
                        StepSizeX = (VS4 - VST) / 10 '7442-10594
                        If StepSizeX = 0 Then StepSizeX = 1
                        If DSP2Flag = 0 Then
                            If VST <> VS4 Then
                                For x = VST To VS4 Step StepSizeX
                                    If x <= VScroll4.Max Then
                                        VScroll4.Value = x
                                    End If
                                Next x
                            End If
                        Else
                           ' VScroll4.Value = VS4
                        End If
                        If VScroll4.Value = VS4 Then
                            Call MakeSummary
                        Else
                            If DSP2Flag = 0 Then
                                VScroll4.Value = VS4
                            End If
                        End If
                    Else
                        Call MakeSummary
                    End If
                ElseIf RIMode = 0 Then
                    If ManFlag > -1 Then
                        Call DoLegend
                    Else
                        If (RelX > 0 Or RelY > 0) And (PAVal <= 0 And RecSeq <= 0) Then
                            Call MakeRecombinationInfo(RelX, RelY)
                        End If
                    End If
                    
                End If
                Call Timer1_Timer
                SchemPic.MousePointer = 0
                SchemPic.ToolTipText = ""
            End If

        ElseIf x > Form1.Picture5.ScaleWidth - 5 Then
            PAVal = 0
        End If
    
    End If
    x = Px: Y = PY
    Dim AxLen As Long
If DebuggingFlag < 2 Then On Error Resume Next
AxLen = -1
AxLen = GYAxHi(1)
On Error GoTo 0
If AxLen > 0 And p7CurWinSize > 0 Then
    
   ' P7XP = oP7XP
   ' Call ShrinkZoom
   ' P7XP = 0
   ' oP7XP = 0
   ' Form1.Label1.Caption = ""
   
End If

'For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
'    x = x


End Sub


Private Sub Picture6_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
Picture12.Visible = False
End Sub

Private Sub Picture6_Paint()
If Timer1.Enabled = True And SuspendFlash = 0 Then
    
    'Timer1.Enabled = False
    Timer1_Timer
    'Timercheck(1) = 0
End If
End Sub

Private Sub Picture7_Click()

    Dim x As Long, Pict As Long
    Dim LetGo As Integer
    Dim PntAPI As POINTAPI
    If DontClick = 1 Then DontClick = 0: Exit Sub
    APlot = 0
   
    Picture7.Refresh

    Dim b1 As Long, g1 As Long, b As Long, g As Long, r As Long, Bak As Long

    XFactor = (Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0)))
    Bak = P7PixCol
    b = Int(Bak / 65536)
    g = Int((Bak - b * 65536) / 256)
    r = Int(Bak - b * 65536 - g * 256)
    
    
    
    If ManFlag = 7 Then
        'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
        Call RedrawPlotAA(1)
        For x = 1 To NumberOfSeqs
            Bak = RefCol(x)
            b1 = Int(Bak / 65536)
            g1 = Int((Bak - b1 * 65536) / 256)
            r1 = Int(Bak - b1 * 65536 - g1 * 256)
            LetGo = 0

            If r <= r1 + 10 And r >= r1 - 10 Then LetGo = LetGo + 1

            If g <= g1 + 10 And g >= g1 - 10 Then LetGo = LetGo + 1

            If b <= b1 + 10 And b >= b1 - 10 Then LetGo = LetGo + 1

            If LetGo >= 2 Then 'P7PixCol = RefCol(X) Then
                APlot = x
                Picture7.AutoRedraw = True
                Picture7.DrawWidth = 3
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 2, BkG - (BkG - g1) / 2, BkB - (BkB - b1) / 2)
                PosCount = 0
                Dummy = MoveToEx(Picture7.hdc, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                PosCount = 1
                Pict = Picture7.hdc

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                    PosCount = PosCount + 1
                Loop

                Picture7.Refresh
                Picture7.DrawWidth = 2
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                PosCount = 0
                Dummy = MoveToEx(Picture7.hdc, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                PosCount = 1
                Pict = Picture7.hdc

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                    PosCount = PosCount + 1
                Loop

                Picture7.Refresh
                Picture7.DrawWidth = 1
                Picture7.ForeColor = SeqCol(RevSeq(x))
                PosCount = 0
                Dummy = MoveToEx(Picture7.hdc, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)), PntAPI)
                PosCount = 1
                Pict = Picture7.hdc

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, PosCount) / MaxDistX)) * (PicHeight - 35)))
                    PosCount = PosCount + 1
                Loop

                Picture7.Refresh
                Picture7.DrawWidth = 1

                Call DoLegend

                Exit Sub
            End If

        Next 'X

    ElseIf ManFlag = 4 Then
        'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
        Call RedrawPlotAA(1)
        For x = 1 To NumberOfSeqs
            Bak = RefCol(x)
            b1 = Int(Bak / 65536)
            g1 = Int((Bak - b1 * 65536) / 256)
            r1 = Int(Bak - b1 * 65536 - g1 * 256)
            LetGo = 0

            If r <= r1 + 10 And r >= r1 - 10 Then LetGo = LetGo + 1

            If g <= g1 + 10 And g >= g1 - 10 Then LetGo = LetGo + 1

            If b <= b1 + 10 And b >= b1 - 10 Then LetGo = LetGo + 1

            If LetGo >= 2 Then 'P7PixCol = RefCol(X) Then
                APlot = x
                Picture7.AutoRedraw = True
                Picture7.DrawWidth = 3
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 2, BkG - (BkG - g1) / 2, BkB - (BkB - b1) / 2)
                PosCount = 1
                Pict = Picture7.hdc

                

                Dummy = MoveToEx(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)), PntAPI)

            For PosCount = 1 To LenXoverSeq
                 'f MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
                Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)))
                'PosCount = PosCount + 1
            Next 'PosCount

                Picture7.Refresh
                Picture7.DrawWidth = 2
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                PosCount = 1
                Pict = Picture7.hdc

                Dummy = MoveToEx(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)), PntAPI)

                For PosCount = 1 To LenXoverSeq
                     'f MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
                    Dummy = LineTo(Pict, 30 + Decompress((MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)))
                    'PosCount = PosCount + 1
                Next 'PosCount

                Picture7.Refresh
                Picture7.DrawWidth = 1
                Picture7.ForeColor = SeqCol(RevSeq(x))
                PosCount = 1
                Pict = Picture7.hdc

                Dummy = MoveToEx(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)), PntAPI)

                For PosCount = 1 To LenXoverSeq
                     'f MCPrintPos(PosCount) - MCOverlapR > Len(StrainSeq(0)) Then Exit Do
                    Dummy = LineTo(Pict, 30 + (Decompress(MCPrintPos(PosCount))) * XFactor, PicHeight - (15 + ((-Log10(MCPrintData(x - 1, PosCount)) / MCMinChiP)) * (PicHeight - 35)))
                    'PosCount = PosCount + 1
                Next 'PosCount

                Picture7.Refresh
                Picture7.DrawWidth = 1

                Call DoLegend

                Exit Sub
            End If

        Next 'X

    ElseIf ManFlag = 3 Then
        'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
        Call RedrawPlotAA(1)
        For x = 1 To NumberOfSeqs
            Bak = RefCol(x)
            b1 = Int(Bak / 65536)
            g1 = Int((Bak - b1 * 65536) / 256)
            r1 = Int(Bak - b1 * 65536 - g1 * 256)
            LetGo = 0

            If r <= r1 + 10 And r >= r1 - 10 Then LetGo = LetGo + 1

            If g <= g1 + 10 And g >= g1 - 10 Then LetGo = LetGo + 1

            If b <= b1 + 10 And b >= b1 - 10 Then LetGo = LetGo + 1

            If LetGo >= 2 Then 'P7PixCol = RefCol(X) Then
                APlot = x
                Picture7.AutoRedraw = True
                PosCount = 0
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 2, BkG - (BkG - g1) / 2, BkB - (BkB - b1) / 2)
                Picture7.DrawWidth = 3
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)

                Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                    PosCount = PosCount + 1
                    Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                Loop

                Picture7.Refresh
                PosCount = 0
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                Picture7.DrawWidth = 2
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)

                Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                    PosCount = PosCount + 1
                    Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                Loop

                Picture7.Refresh
                Picture7.ForeColor = SeqCol(RevSeq(x))
                Picture7.DrawWidth = 1
                Pict = Form1.Picture7.hdc
                PosCount = 0
                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)

                Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
                    PosCount = PosCount + 1
                    Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(x, PosCount) / BSBootReps) * (PicHeight - 35))
                Loop

                Picture7.Refresh
                Picture7.DrawWidth = 1

                Call DoLegend

                Exit Sub
            End If

        Next 'X

    ElseIf ManFlag = 1 Then
        'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
        Call RedrawPlotAA(1)
        For x = 1 To NumberOfSeqs + 1
            Bak = RefCol(x)
            b1 = Int(Bak / 65536)
            g1 = Int((Bak - b1 * 65536) / 256)
            r1 = Int(Bak - b1 * 65536 - g1 * 256)
            LetGo = 0

            If r <= r1 + 10 And r >= r1 - 10 Then LetGo = LetGo + 1

            If g <= g1 + 10 And g >= g1 - 10 Then LetGo = LetGo + 1

            If b <= b1 + 10 And b >= b1 - 10 Then LetGo = LetGo + 1

            If LetGo >= 2 Then 'P7PixCol = RefCol(X) Then
                APlot = x
                Picture7.AutoRedraw = True

                If x = NumberOfSeqs + 1 Then x = 0
                CurPPos = 0
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 2, BkG - (BkG - g1) / 2, BkB - (BkB - b1) / 2)
                Picture7.DrawWidth = 3
                Pict = Form1.Picture7.hdc

                Do While MCPrintData(x, CurPPos) > 0
                    MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    CurPPos = CurPPos + 1
                Loop

                Picture7.Refresh
                CurPPos = 0
                Picture7.ForeColor = RGB(BkR - (BkR - r1) / 1.5, BkG - (BkG - g1) / 1.5, BkB - (BkB - b1) / 1.5)
                Picture7.DrawWidth = 2
                Pict = Form1.Picture7.hdc

                Do While MCPrintData(x, CurPPos) > 0
                    MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    CurPPos = CurPPos + 1
                Loop

                Picture7.Refresh
                Picture7.ForeColor = SeqCol(RevSeq(x))
                Picture7.DrawWidth = 1
                Pict = Form1.Picture7.hdc
                CurPPos = 0

                Do While MCPrintData(x, CurPPos) > 0
                    MoveToEx Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35), PntAPI
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 1)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (PicHeight - 35)
                    LineTo Pict, 30 + Decompress(MCPrintPos(x, CurPPos, 0)) * XFactor, 20 + (1 - MCPrintData(x, CurPPos) / MinGCP) * (PicHeight - 35)
                    CurPPos = CurPPos + 1
                Loop

                Picture7.Refresh
                Picture7.DrawWidth = 1

                Call DoLegend

                Exit Sub
            End If

        Next 'X
    
    ElseIf ManFlag = 9 Then
        If Picture12.Visible = False Then
            Call RedrawPlotAA(1)
            'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
        Else
        
        End If
    ElseIf RelX > 0 Or RelY > 0 Then
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
    
            'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
            If Picture12.Visible = False Then
                Call RedrawPlotAA(1)
                'Picture7.PaintPicture Picture21.Image, -Picture7.Left, -5
            Else
            
            End If
        End If
    End If

    If ManFlag = 3 Or ManFlag = 4 Or ManFlag = 7 Or ManFlag = 1 Then
        APlot = 0

        Call DoLegend

    End If

End Sub

Private Sub Picture7_DblClick()

    If RunFlag = 1 And ManFlag = -1 Then
        DontPutForm2Ontop = 1
        Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
        DontPutForm2Ontop = 0
    ElseIf ManFlag > -1 Then

        Call DoLegend

    End If
    'Form1.Picture7.ScaleMode = 3
    AxLen = GYAxHi(1)
    If AxLen = 0 Then
        XFactor = (Form1.Picture7.ScaleWidth - 40) / Decompress(Len(StrainSeq(0)))
    Else
        XFactor = (Form1.Picture7.ScaleWidth - 40) / AxLen
    End If
    Dim DCP As Single, PSL As Single, LSeq As Long
    LSeq = Decompress(Len(StrainSeq(0)))
    If Form3.Check2.Value < 60 Then

        If CLng(((Pic7PointerVal - 30) / XFactor) - 18) < Decompress(Len(StrainSeq(0))) And CLng(((Pic7PointerVal - 30) / XFactor) - 18) > 0 Then
            
            
            If x = x Then 'HScroll1.Max < 31833 And Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                DCP = (((Pic7PointerVal - 30) / XFactor))
                PSL = (Picture9.ScaleWidth / Picture1.TextWidth("A")) / 2
                TempVal = CLng((DCP - PSL) / ((LSeq - PSL * 2)) * HScroll1.Max)
                If TempVal >= 0 And TempVal <= HScroll1.Max Then '(HScroll1.Max * dcp / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2))) >= 0 And (HScroll1.Max * dcp / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2))) < HScroll1.Max Then
                    HScroll1.Value = TempVal 'HScroll1.Max * dcp / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2)) ' / Decompress(Len(StrainSeq(0)))
                ElseIf TempVal <= 1 Then
                    HScroll1.Value = HScroll1.Min
                Else
                    HScroll1.Value = HScroll1.Max
                End If
                x = x
            Else
                DCP = (CLng(((Pic7PointerVal - 30) / XFactor))) - (PrintSeqLen / 2)
                
                dcp2 = Decompress(Len(StrainSeq(0)))
                dcp3 = CLng(((Pic7PointerVal - 30) / XFactor))
                
                
                TempVal = (DCP / dcp2) * HScroll1.Max
                If (HScroll1.Max * DCP / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2))) >= 0 And (HScroll1.Max * DCP / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2))) < HScroll1.Max Then
                    HScroll1.Value = HScroll1.Max * DCP / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2)) ' / Decompress(Len(StrainSeq(0)))
                ElseIf (HScroll1.Max * DCP / (Decompress(Len(StrainSeq(0))) - (PrintSeqLen / 1.2))) < 1 Then
                    HScroll1.Value = HScroll1.Min
                Else
                    HScroll1.Value = HScroll1.Max
                End If
                
            End If
            
            x = x
            
            'If (HScroll1.Max - PrintSeqLen / Decompress(Len(StrainSeq(0)))) * dcp / Decompress(Len(StrainSeq(0))) < HScroll1.Max And (HScroll1.Max - PrintSeqLen / Decompress(Len(StrainSeq(0)))) * dcp / Decompress(Len(StrainSeq(0))) > 0 Then
            '    HScroll1.Value = (HScroll1.Max - PrintSeqLen / Decompress(Len(StrainSeq(0)))) * dcp / Decompress(Len(StrainSeq(0))) '- (PrintSeqLen / 2) / Decompress(Len(StrainSeq(0)))
            'ElseIf (HScroll1.Max - PrintSeqLen / Decompress(Len(StrainSeq(0)))) * dcp / Decompress(Len(StrainSeq(0))) < 0 Then
            '    HScroll1.Value = 0
            'Else
            '    HScroll1.Value = HScroll1.Max
            'End If
            
            
            
            'If tempval >= -PrintSeqLen Then
            '    If tempval >= HScroll1.Max Then
            '        HScroll1.Value = HScroll1.Max
            '    ElseIf tempval <= HScroll1.Min Then
            '        HScroll1.Value = HScroll1.Min
            '    Else
            '        HScroll1.Value = tempval
            '    End If
            'Else
            '    Exit Sub
            'End If
        ElseIf Int(((Pic7PointerVal - 30) / XFactor) - 18) > Len(StrainSeq(0)) Then
            HScroll1.Value = HScroll1.Max
        ElseIf Int(((Pic7PointerVal - 30) / XFactor) - 18) < 1 Then
            HScroll1.Value = HScroll1.Min
        End If

    Else
        XFactor = (Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0)))
        adjXFactor = XFactor '* (Len(strainseq(0)) / Len(xoverseq(0)))

        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then

            If Int(((Pic7PointerVal - 30) / adjXFactor) - 18) < Len(StrainSeq(0)) And Int(((Pic7PointerVal - 30) / adjXFactor) - 18) > 0 Then
                'HScroll1.Value = Int(((Pic7PointerVal - 10) / XFactor) - 18) / Len(strainseq(0)) * 100

                If Int((XPosDiff(Int((Pic7PointerVal - 30) / adjXFactor))) - 18) / Len(XOverSeq(0)) * 100 > HScroll1.Min Then
                    HScroll1.Value = (Int((XPosDiff(Int((Pic7PointerVal - 30) / adjXFactor))) - 18) / Len(XOverSeq(0)) * 100)
                Else
                    HScroll1.Value = HScroll1.Min
                End If

            ElseIf Int(((Pic7PointerVal - 30) / adjXFactor) - 18) > Len(XOverSeq(0)) Then
                HScroll1.Value = 99
            ElseIf Int(((Pic7PointerVal - 30) / XFactor) - 18) < HScroll1.Min Then
                HScroll1.Value = HScroll1.Min
            End If

        Else
            'XFactor =
            adjXFactor = (Form1.Picture7.Width - 40) / Decompress((Len(StrainSeq(0))))
            'Int(((Pic7PointerVal - 30) / XFactor))

            If Int(((Pic7PointerVal - 30) / adjXFactor)) < (Len(StrainSeq(0)) - 40) And Int(((Pic7PointerVal - 30) / adjXFactor) - 18) > 0 Then

                If Int(((Int((Pic7PointerVal - 30) / adjXFactor)))) / (Len(StrainSeq(0)) - 40) * 100 > HScroll1.Min Then
                    HScroll1.Value = (Int(((Int((Pic7PointerVal - 30) / adjXFactor)))) / (Len(StrainSeq(0)) - 40) * 100)
                Else
                    HScroll1.Value = HScroll1.Min
                End If

            ElseIf Int(((Pic7PointerVal - 30) / adjXFactor)) > (Len(StrainSeq(0)) - 40) Then
                HScroll1.Value = 99
            ElseIf Int(((Pic7PointerVal - 30) / adjXFactor)) < HScroll1.Min Then
                HScroll1.Value = HScroll1.Min
            End If

        End If

    End If
'    If RelX > 0 Or RelY > 0 Then
'         If Form1.Picture6.Enabled = True Then
'            Form1.Picture6.SetFocus
'        End If
'    End If
End Sub

Private Sub Picture7_DragDrop(Source As Control, x As Single, Y As Single)
If Picture12.Visible = True Then
    Picture12.Top = CInt(2 + (Y) + SSPanel8.Top + Picture7.Top + (Picture10.Top) / Screen.TwipsPerPixelY - Picture12.Height) + P12Y
    Picture12.Left = CInt(2 + (x) + SSPanel8.Left + Picture7.Left + (Picture10.Left) / Screen.TwipsPerPixelX) - P12X 'Picture4.Left + x
    Picture12.DragMode = 0
End If
End Sub

Private Sub Picture7_KeyDown(KeyCode As Integer, Shift As Integer)

Call DoKeydown(KeyCode)
If KeyCode = vbKeyPageUp Or KeyCode = vbKeyLeft Or (KeyCode = vbKeyUp And F1P7X = -1) Then
    Call GoToPreviousEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeyPageDown Or KeyCode = vbKeyRight Or (KeyCode = vbKeyDown And F1P7X = -1) Then
    Call GoToNextEventMnu_Click
    KPFlag = 1
ElseIf KeyCode = vbKeySpace Then
    Call GoToBestMnu_Click

End If


'
'If Rotation < 0 Then

'    Else

'    End If



'If Form1.Picture6.Enabled = True Then
'    Form1.Picture6.SetFocus
'End If

End Sub

Private Sub Picture7_MouseDown(Button As Integer, Shift As Integer, x As Single, Y As Single)

    Dim LongName As Long

    If Button = 2 And ManFlag > -1 And ManFlag <> 60 Then
        SaveTxtMnu.Enabled = True
        'PrintMnu.Enabled = False
        SaveBMPFlag = 2
        SaveTxtFlag = 2
        Form1.PopupMenu SaveMnu
    ElseIf Button = 2 And (ManFlag = -1 Or ManFlag = 60) Then
        'Exit Sub
        If RelX > 0 Or RelY > 0 Then
            PlaceAEBPMnu4.Enabled = True
            PlaceABBPMnu4.Enabled = True
        Else
            PlaceAEBPMnu4.Enabled = False
            PlaceABBPMnu4.Enabled = False
        End If
        If CurrentCheck = -1 And ManFlag = -1 And (XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) Then
            If RelX > 0 Or RelY > 0 Then
                SaveTxtMnu.Enabled = True
                SaveEMFMnu.Enabled = True
                CpyEMFMnu.Enabled = True
            Else
                SaveTxtMnu.Enabled = False
                SaveEMFMnu.Enabled = False
                CpyEMFMnu.Enabled = False
            End If
            
            
            'PrintMnu.Enabled = False
            SaveBMPFlag = 2
            SaveTxtFlag = 2
            Form1.PopupMenu SaveMnu
        ElseIf CurrentCheck > -1 And (CurrentCheck = 55 Or CurrentCheck = 41 Or CurrentCheck = 16 Or CurrentCheck = 15 Or CurrentCheck = 17 Or CurrentCheck = 14 Or CurrentCheck = 12 Or CurrentCheck = 13 Or CurrentCheck = 0 Or CurrentCheck = 1 Or CurrentCheck = 2 Or CurrentCheck = 3 Or CurrentCheck = 4 Or CurrentCheck = 5 Or CurrentCheck = 6 Or CurrentCheck = 7 Or CurrentCheck = 8 Or CurrentCheck = 9 Or CurrentCheck = 10 Or CurrentCheck = 20 Or CurrentCheck = 21 Or CurrentCheck = 22 Or CurrentCheck = 23) Then
            SaveTxtMnu.Enabled = True
            'PrintMnu.Enabled = False
            SaveEMFMnu.Enabled = True
            CpyEMFMnu.Enabled = True
            SaveBMPFlag = 2
            SaveTxtFlag = 2
            'X = SaveMnu.WindowList
            Form1.PopupMenu SaveMnu
        ElseIf ManFlag = 60 Then
            SaveTxtMnu.Enabled = True
            'PrintMnu.Enabled = False
            SaveEMFMnu.Enabled = True
            CpyEMFMnu.Enabled = True
            SaveBMPFlag = 2
            SaveTxtFlag = 2
             Form1.PopupMenu SaveMnu
        Else
            SaveTxtMnu.Enabled = False
            'PrintMnu.Enabled = False
            SaveEMFMnu.Enabled = False
            CpyEMFMnu.Enabled = False
            SaveBMPFlag = 2
            Form1.PopupMenu SaveMnu
        End If
    ElseIf Button = 1 And Picture12.Visible = True Then
        Picture12.Visible = False
        DontClick = 1
    ElseIf Button = 1 And ManFlag > -1 Then

        If Picture7.MousePointer <> 99 And (ManFlag = 1 Or ManFlag = 3 Or ManFlag = 7 Or ManFlag = 4) Then
            If x = 123456 Then
                ScaleMode = 3
    
                For Z = 1 To NumberOfSeqs
    
                    If Picture12.TextWidth(OriginalName(RevSeq(Z))) > LongName Then LongName = Picture12.TextWidth(OriginalName(RevSeq(Z)))
                Next 'Z
    
                Picture12.Height = (NumberOfSeqs * 200 + 100) / Screen.TwipsPerPixelY
                Picture12.Width = (314 + LongName) / Screen.TwipsPerPixelX
                Picture12.ZOrder
                Picture12.Top = CInt(2 + Y + SSPanel8.Top + Picture7.Top + (Picture10.Top) / Screen.TwipsPerPixelY - Picture12.Height)
                Picture12.Left = CInt(2 + x + SSPanel8.Left + Picture7.Left + (Picture10.Left) / Screen.TwipsPerPixelX) 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
    
                For Z = 1 To NumberOfSeqs
                    Picture12.Line (50, 50 + (Z - 1) * 200)-(200, 200 + (Z - 1) * 200), SeqCol(RevSeq(Z)), BF
                Next 'Z
    
                For Z = 1 To NumberOfSeqs
                    Picture12.ForeColor = RGB(150, 150, 150)
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + (Z - 1) * 200 + 14
                    Picture12.Print OriginalName(RevSeq(Z))
                    Picture12.ForeColor = 0
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50 + (Z - 1) * 200
                    Picture12.Print OriginalName(RevSeq(Z))
                Next 'Z
    
                Picture12.Visible = True
            End If
        ElseIf ManFlag = 9 Then
            Form1.ScaleMode = 3
            Picture12.Height = 210 * (15 / Screen.TwipsPerPixelY)
            Picture12.Width = 105 * (14 / Screen.TwipsPerPixelX)
            Picture12.ZOrder
            Picture12.Top = CInt(2 + Y + SSPanel8.Top + Picture7.Top + (Picture10.Top) / Screen.TwipsPerPixelY - Picture12.Height)
            Picture12.Left = CInt(2 + x + SSPanel8.Left + Picture7.Left + (Picture10.Left) / Screen.TwipsPerPixelX) 'Picture4.Left + x
            Picture12.Picture = LoadPicture()
            Picture12.AutoRedraw = True
            
            For x = 1 To 15
                Picture12.Line (50, 50 + 200 * (x - 1))-(200, 50 + (200 * (x - 1) + 150)), PltCol(x), BF
            Next x
            Picture12.ForeColor = RGB(150, 150, 150)
            For x = 1 To 15
                'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                Picture12.CurrentX = 250 + 14
                Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                Picture12.Print "P" & Trim$(CStr(x))
            Next x
            
            
            Picture12.ForeColor = 0
            
            For x = 1 To 15
                'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                Picture12.CurrentX = 250
                Picture12.CurrentY = 50 + (x - 1) * 200
                Picture12.Print "P" & Trim$(CStr(x))
            Next x
            
            For x = 1 To 9
                Picture12.Line (750, 50 + 200 * (x - 1))-(900, 50 + (200 * (x - 1) + 150)), PltCol2(x), BF
            Next x
            Picture12.ForeColor = RGB(150, 150, 150)
            For x = 1 To 9
                'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                Picture12.CurrentX = 950 + 14
                Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                Picture12.Print "S" & Trim$(CStr(x))
            Next x
            
            
            Picture12.ForeColor = 0
            
            For x = 1 To 9
                'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                Picture12.CurrentX = 950
                Picture12.CurrentY = 50 + (x - 1) * 200
                Picture12.Print "S" & Trim$(CStr(x))
            Next x
            
            
            Picture12.Visible = True
        
        End If
    
    ElseIf Button = 1 And ((RunFlag = 1 And RelX = 0 And RelY = 0) Or CurrentCheck = 11 Or CurrentCheck = 24) Then
        Form1.ScaleMode = 3
        'Picture12.Height = 58
        'Picture12.Width = 80
        Picture12.Height = 85 * (15 / Screen.TwipsPerPixelY)
        Picture12.Width = 80 * (14 / Screen.TwipsPerPixelX)
        Picture12.ZOrder
        Picture12.Top = CInt(2 + Y + SSPanel8.Top + Picture7.Top + (Picture10.Top) / Screen.TwipsPerPixelY - Picture12.Height)
        Picture12.Left = CInt(2 + x + SSPanel8.Left + Picture7.Left + (Picture10.Left) / Screen.TwipsPerPixelX) 'Picture4.Left + x
        Picture12.Picture = LoadPicture()
        Picture12.AutoRedraw = True
        Picture12.Line (50, 50)-(200, 200), ProgColour(0), BF
        Picture12.Line (50, 250)-(200, 400), ProgColour(1), BF
        Picture12.Line (50, 450)-(200, 600), ProgColour(2), BF
        Picture12.Line (50, 650)-(200, 800), ProgColour(3), BF
        Picture12.Line (50, 850)-(200, 1000), ProgColour(4), BF
        Picture12.Line (50, 1050)-(200, 1200), ProgColour(5), BF
        Picture12.ForeColor = RGB(150, 150, 150)
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 50 + 14
        Picture12.Print "RDP"
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 250 + 14
        Picture12.Print "GENECONV"
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 450 + 14
        Picture12.Print "Bootscan"
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 650 + 14
        Picture12.Print "MaxChi"
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 850 + 14
        Picture12.Print "Chimaera"
        Picture12.CurrentX = 250 + 14
        Picture12.CurrentY = 1050 + 14
        Picture12.Print "SiScan"
        Picture12.ForeColor = 0
        Picture12.CurrentX = 250
        Picture12.CurrentY = 50
        Picture12.Print "RDP"
        Picture12.CurrentX = 250
        Picture12.CurrentY = 250
        Picture12.Print "GENECONV"
        Picture12.CurrentX = 250
        Picture12.CurrentY = 450
        Picture12.Print "Bootscan"
        Picture12.CurrentX = 250
        Picture12.CurrentY = 650
        Picture12.Print "MaxChi"
        Picture12.CurrentX = 250
        Picture12.CurrentY = 850
        Picture12.Print "Chimaera"
        Picture12.CurrentX = 250
        Picture12.CurrentY = 1050
        Picture12.Print "SiScan"
        Picture12.Visible = True
    ElseIf Button = 1 And RelX > 0 Or RelY > 0 Then
        If (XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5) Then
            If Combo1.ListIndex = 6 Then
                Form1.ScaleMode = 3
                Picture12.Height = 210 * (15 / Screen.TwipsPerPixelY)
                Picture12.Width = 105 * (14 / Screen.TwipsPerPixelX)
                Picture12.ZOrder
                Picture12.Top = CInt(2 + Y + SSPanel8.Top + Picture7.Top + (Picture10.Top) / Screen.TwipsPerPixelY - Picture12.Height)
                Picture12.Left = CInt(2 + x + SSPanel8.Left + Picture7.Left + (Picture10.Left) / Screen.TwipsPerPixelX) 'Picture4.Left + x
                Picture12.Picture = LoadPicture()
                Picture12.AutoRedraw = True
                
                For x = 1 To 15
                    Picture12.Line (50, 50 + 200 * (x - 1))-(200, 50 + (200 * (x - 1) + 150)), PltCol(x), BF
                Next x
                Picture12.ForeColor = RGB(150, 150, 150)
                For x = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Picture12.CurrentX = 250 + 14
                    Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                    Picture12.Print "P" & Trim$(CStr(x))
                Next x
                
                
                Picture12.ForeColor = 0
                
                For x = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Picture12.CurrentX = 250
                    Picture12.CurrentY = 50 + (x - 1) * 200
                    Picture12.Print "P" & Trim$(CStr(x))
                Next x
                
                For x = 1 To 9
                    Picture12.Line (750, 50 + 200 * (x - 1))-(900, 50 + (200 * (x - 1) + 150)), PltCol2(x), BF
                Next x
                Picture12.ForeColor = RGB(150, 150, 150)
                For x = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Picture12.CurrentX = 950 + 14
                    Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                    Picture12.Print "S" & Trim$(CStr(x))
                Next x
                
                
                Picture12.ForeColor = 0
                
                For x = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Picture12.CurrentX = 950
                    Picture12.CurrentY = 50 + (x - 1) * 200
                    Picture12.Print "S" & Trim$(CStr(x))
                Next x
                
                
                Picture12.Visible = True
                Picture12.ZOrder
            Else
                DontClick = 1
            End If
        
        End If
    End If

    If NNetflag = 1 Then Call Command6_Click(3)
End Sub

Private Sub Picture7_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
'XX = PermNextno
'Picture1.Enabled = false
'3428 (793,213 - se=64,154),5883 (2601,727 - se = 99),1947 (359,93 se = 25,48,49), *3279 (3279,869 se = 192), 6659(2460,689 se = 99,163)
    'x = 689
'    For Y = 1 To CurrentXOver(x)
'        XX = SuperEventList(XOverList(x, Y).Eventnumber)
'        x = x
'    Next Y
'
'For x = 0 To NextNo
'    If OriginalPos(x) = 3428 Then
'        x = x
'
'    End If
'Next x
'XX = OriginalPos(RelX) '3428,5883,1947, *3279, 6659
'If RelX = 0 And RelY = 0 And ManFlag = -1 Then Exit Sub
'For Y = 0 To SEventNumber
'For X = 0 To Nextno
''    If Daught(SuperEventList(XOverlist(RelX, RelY).Eventnumber), X) > 0 Then
''        X = X
''    End If
'    If Daught(Y, X) > 5 Then ' (25,27);
'        X = X
'    End If
'    If MinorPar(Y, X) > 5 Then ' (25,27);
'        X = X
'    End If
'    If MajorPar(Y, X) > 5 Then ' (25,27);
'        X = X
'    End If
'Next X
'Next Y
XX = RelX '208,11  =bs; 208,14=geneconv
XX = RelY
'For X = 0 To PermNextno
'    For Y = 1 To CurrentXOver(X)
'        If XOverlist(X, Y).Eventnumber = 104 Then
'            X = X
'            XX = XOverlist(X, Y).Probability
'        End If
'    Next Y
'
'Next X
'P7MMactive = 0
SS = Abs(GetTickCount)
'Form1.Caption = SS - p7MouseMoveTime
p7MouseMoveTime = SS

If P7MMactive = 1 Then Exit Sub
P7MMactive = 1
'DoEvents

RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Dim PXP As Single, PYP As Single

Dim AcV As Long
Dim TargetWin As Long, GrowInc As Long



If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If

GrowInc = 5 'zoom window grow/shrink rate -bigger=slower
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
'    Dummy = ShowCursor(True)
'    If Dummy < 0 Then
'        Do While Dummy < 0
'            Dummy = ShowCursor(True)
'        Loop
'    End If
End If

F1P7X = x
If Screen.ActiveForm.Name = "Form1" Then
    Picture7.SetFocus
End If
    Picture3.Refresh
    Picture2.Refresh
    P1Seq = -1
    P1NT = -1
    
    F2P2Y = -1
    F1P2Y = -1
    F1P3Y = -1
    F1P6Y = -1
    F2P3Y = -1
    F1P16Y = -1
    F1P26Y = -1
    F2P2Index = -1
    'ManFlag = 60
    'Dim
     Dim IV As Double, aCap As String, bCap As String
    Dim Extra As Integer

    Pic7PointerVal = x
    
   
    
    
    
    'RefCol(0) = GetPixel(Form1.Picture7.hdc, 28, 15)
    
    Dim WinColNum As Long
    

    If (RunFlag = 0 Or (RelX = 0 And RelY = 0)) And ManFlag = -1 Then
        Picture7.MousePointer = 0
'        Dummy = ShowCursor(True)
'        If Dummy < 0 Then
'            Do While Dummy < 0
'                Dummy = ShowCursor(True)
'            Loop
'        End If
        P7MMactive = 0
        Exit Sub
    End If

    If (CurrentCheck = 11 Or CurrentCheck = 24) And ManFlag = -1 Then
        Picture7.MousePointer = 0
'        Dummy = ShowCursor(True)
'        If Dummy < 0 Then
'            Do While Dummy < 0
'                Dummy = ShowCursor(True)
'            Loop
'        End If
        P7MMactive = 0
        Exit Sub
    End If
    
    
    'DoEvents
    AxLen = GYAxHi(1)
    If AxLen = 0 Then
        P7MMactive = 0
        Exit Sub
        
    End If
    TargetWin = Len(StrainSeq(0)) / 8
    XFactor = (Form1.Picture7.ScaleWidth - 40) / AxLen
    yfactor = (PicHeight - 15 - 20)
    AcV = CLng(((Pic7PointerVal - 30) / XFactor))
    
    P7PixCol = GetPixel(Form1.Picture7.hdc, x, Y)
    Dim b As Long, g As Long, r As Long, Bak As Long

    XFactor = (Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0)))
    Bak = P7PixCol
    b = Int(Bak / 65536)
    g = Int((Bak - b * 65536) / 256)
    r = Int(Bak - b * 65536 - g * 256)
    'Form1.Caption = Str(r) + Str(g) + Str(b)
    If x <= Picture7.Width - 10 And x > 25 And Y < 20 Then
        Picture7.ToolTipText = "Positions of variable sites that have an impact on this graph"
    ElseIf x <= Picture7.Width - 10 And x > 25 And Y < PicHeight - 10 * VAddjust And Y >= 20 Then
        
        If x <> LastF1P7X Or Y <> LastF1P7Y Then
            
            Picture7.ToolTipText = ""
            If (r = 197 And g = 197 And b = 197) Or (r = 163 And g = 163 And b = 163) Then
                Picture7.ToolTipText = "99% confidence interval on breakpoint location"
            
            
            ElseIf (r = 160 And g = 160 And b = 160) Or (r = 145 And g = 145 And b = 145) Then
                Picture7.ToolTipText = "95% confidence interval on breakpoint location"
            ElseIf (r = 175 And g = 175 And b = 175) Then
                Picture7.ToolTipText = "95% confidence interval on expected bounds of random walk in the absence of recombination"
            ElseIf r = 255 And g = b And r - g > 10 Or (r = 255 And g = 185 And b = 153) Or (r = 255 And g = 153 And b = 162) Or (r = 255 And g = 162 And b = 185) Then
                Picture7.ToolTipText = "Inferred breakpoint position"
            ElseIf Abs(b - g) < 9 And r - b > 10 And (r > 200 Or r - b > 30) Then
                If r <> 84 And b <> 0 And g <> 0 Then
                    Picture7.ToolTipText = "Recombinant plot"
                End If
            ElseIf Abs(b - r) < 9 And g - b > 10 Then
                If r <> 208 And b <> 208 And g <> 220 Then
                    Picture7.ToolTipText = "Major parent plot"
                End If
            ElseIf g = 197 And r = 197 And b = 255 Then
                XX = AcV
                Dim MDI As Long, ExtraText As String
                MDI = 0
                If MissingData(Recompress(AcV), Seq1) = 1 Then
                    MDI = MDI + 1
                End If
                If MissingData(Recompress(AcV), Seq2) = 1 Then
                    MDI = MDI + 2
                End If
                If MissingData(Recompress(AcV), Seq3) = 1 Then
                    MDI = MDI + 4
                End If
                
                If Seq1 > UBound(OriginalName) Or Seq2 > UBound(OriginalName) Or Seq3 > UBound(OriginalName) Then
                    If MDI = 1 Then
                        ExtraText = "missing data and/or a recombinationationally transferred fragment in " + FullOName(OriginalPos(Seq1)) + " (the major parent)"
                    ElseIf MDI = 2 Then
                        ExtraText = "missing data and/or a recombinationationally transferred fragment in " + FullOName(OriginalPos(Seq2)) + " (the minor parent)"
                    ElseIf MDI = 3 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + FullOName(OriginalPos(Seq1)) + " (the major parent)" + " and " + FullOName(OriginalPos(Seq2)) + " (the minor parent)"
                    ElseIf MDI = 4 Then
                        ExtraText = "missing data and/or a recombinationationally transferred fragment in " + FullOName(OriginalPos(Seq3)) + " (the recombinant)"
                    ElseIf MDI = 5 Then
                        
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + FullOName(OriginalPos(Seq1)) + " (the major parent)" + " and " + FullOName(OriginalPos(Seq3)) + " (the recobinant)"
                    ElseIf MDI = 6 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + FullOName(OriginalPos(Seq2)) + " (the minor parent)" + " and " + FullOName(OriginalPos(Seq3)) + " (the recombinant)"
                    ElseIf MDI = 7 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + FullOName(OriginalPos(Seq1)) + " (the major parent)" + ", " + FullOName(OriginalPos(Seq2)) + " (the minor parent)" + " and " + FullOName(OriginalPos(Seq3)) + " (the recombinant)"
                    End If
                Else
                    If MDI = 1 Then
                        ExtraText = "missing data and/or a recombinationationally transferred fragment in " + OriginalName(Seq1) + " (the major parent)"
                    ElseIf MDI = 2 Then
                        ExtraText = "missing data and/or a recombinationationally transferred fragment in " + OriginalName(Seq2) + " (the minor parent)"
                    ElseIf MDI = 3 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + OriginalName(Seq1) + " (the major parent)" + " and " + OriginalName(Seq2) + " (the minor parent)"
                    ElseIf MDI = 4 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragment in " + OriginalName(Seq3) + " (the recombinant)"
                    ElseIf MDI = 5 Then
                        
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + OriginalName(Seq1) + " (the major parent)" + " and " + OriginalName(Seq3) + " (the recobinant)"
                    ElseIf MDI = 6 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + OriginalName(Seq2) + " (the minor parent)" + " and " + OriginalName(Seq3) + " (the recombinant)"
                    ElseIf MDI = 7 Then
                        ExtraText = "missing data and/or recombinationationally transferred fragments in " + OriginalName(Seq1) + " (the major parent)" + ", " + OriginalName(Seq2) + " (the minor parent)" + " and " + OriginalName(Seq3) + " (the recombinant)"
                    End If
                End If
                Picture7.ToolTipText = "Region excluded due to the presence of " + ExtraText
            ElseIf Abs(g - r) < 9 And b - r > 10 Then
                If (r <> 0 Or g <> 0 Or b <> 88) And (r <> 147 Or g <> 147 Or b <> 172) And (r <> 147 Or g <> 147 Or b <> 160) And (r <> 0 Or g <> 0 Or b <> 84) Then
                    Picture7.ToolTipText = "Minor parent plot"
                End If
            ElseIf r = g And (r - b) > 10 Then
                If r <> 147 And r <> 220 And b <> 127 And b <> 189 Then
                    Picture7.ToolTipText = "Minor parent vs major parent plot"
                End If
            ElseIf (r = b And r - g >= 10) Then
                If (r <> 160 Or g <> 147) And (r <> 50 Or g <> 0) Then
                    Picture7.ToolTipText = "Minor parent vs recombinant plot"
                End If
            ElseIf (g = b And g - r >= 10) Then
                If (r <> 157 Or g <> 220) And (r <> 197 Or g <> 220) And (r <> 147 Or g <> 160) And (r <> 208 Or g <> 220) Then
                    Picture7.ToolTipText = "Major parent vs recombinant plot"
                End If
            ElseIf (r = 192 And g = 215 And b = 183) Or (r = 181 And g = 204 And b = 172) Or (r = 162 And g = 185 And b = 153) Then
                Picture7.ToolTipText = "Distribution of expected heights for major parent plot in the absence of recombination"
            ElseIf (r = 183 And g = 192 And b = 215) Or (r = 172 And g = 181 And b = 204) Or (r = 153 And g = 162 And b = 185) Then
                Picture7.ToolTipText = "Distribution of expected heights for minor parent plot in the absence of recombination"
            ElseIf (r = 215 And g = 183 And b = 192) Or (r = 204 And g = 172 And b = 181) Or (r = 185 And g = 153 And b = 162) Then
                Picture7.ToolTipText = "Distribution of expected heights for recombinant plot in the absence of recombination"
            Else
                Call MakeP7Tooltip(r, g, b)
                
            End If
        End If
    
        
        
        'WinColNum = GetMatchCol(P7PixCol, GPrintCol(), GPrintNum)
        
'        If WinColNum <> -1 Then
'        X = X
'        End If
        If AcV < 1 Or AcV > AxLen Then
            aCap = "--"
        Else
            'If acv < UBound(Decompress, 1) Then
            '
            '    'If Pic7PointerVal = 812 Then
            '    '    X = X
            '    'End If
            '    acv = Decompress(acv)
            'End If
            
            aCap = CStr(AcV)
        End If
        If GPrintMin(1) > GPrintMin(0) Then
        'CStr(SSLo + (1 - ((Y - 20) / yfactor)) * (SSUp - SSLo))
            bCap = CStr((CLng((GPrintMin(0) + ((1 - ((Y - 20) / yfactor)) * (GPrintMin(1) - GPrintMin(0)))) * 10000) / 10000 + 0.00000000001))
        Else
            bCap = CStr((CLng((GPrintMin(1) + ((((Y - 20) / yfactor)) * (GPrintMin(0) - GPrintMin(1)))) * 10000) / 10000 + 0.00000000001))
        End If
        bCap = Left(bCap, 6)
        If Right(bCap, 1) = "." Then
            bCap = Left(bCap, 5)
        End If
        If GPrintMin(1) > GPrintMin(0) Then
            If val(bCap) < GPrintMin(0) Or val(bCap) > GPrintMin(1) Then
                bCap = "--"
            End If
        Else
            If val(bCap) > GPrintMin(0) Or val(bCap) < GPrintMin(1) Then
                bCap = "--"
            End If
        End If
        x = x
    Else
        Picture7.ToolTipText = ""
        aCap = "--"
        bCap = "--"
    End If
    If AcV >= 1 And AcV <= AxLen And (Y < PicHeight - 10 * VAddjust And Y >= 20) Then
        P7XP = CLng(AcV)
         If WinBusyGrowing = 1 Then
            P7MMactive = 0
            Exit Sub
        End If
        If P7ZoomLevel > 0 Then
            
            If p7CurWinSize < TargetWin * 0.9 And WinBusyGrowing = 0 Then
               
                    Call GrowZoom
                
            Else
                CycleCounterA = 0
                
               If lP7XP <> P7XP Then
                    SS = Abs(GetTickCount)
                    For Z = 1 To 1
                        lP7XP = P7XP
                        Call RedrawPlotAA(1)
                    Next Z
                    EE = Abs(GetTickCount)
                
                    TT = EE - SS '6.568(40),4.976(40) - using only one imagedata call
                    x = x '13547'13375'12906, 12875, 7187 (with do aaline xy), 5718 (fillorfwin)
                    If WinBusyGrowing = 1 Then
                        GrowInc = 20
                        TargetWin = 0
                        If DebuggingFlag < 2 Then On Error Resume Next
                        TargetWin = Recompress(GYAxHi(1) / 8)
                        On Error GoTo 0
                        If TargetWin >= 1 Then
                            p7CurWinSize = p7CurWinSize + TargetWin / (GrowInc / 2)
                            
                        End If
                        If p7CurWinSize >= TargetWin Then
                            p7CurWinSize = TargetWin
                        End If
                    End If
               End If
                
                If Timer1.Enabled = True Then
                    If Abs(EE - Timer1SS) > 100 Then
                        Timer1_Timer
                    End If
                End If
                '3.432 with colour grouping
                '2.403 doaaliney
                '1.747 doaalinex
                '9.126 for 20
                '5.523 for 20
                '4.555 with fillarray3
                '4.664
                '5.757 without maketeststrip
                '3.573 with maketeststrip
                '2.668
                '2.637 curvemid
                '2.589 fillarray3
                '2.667 curveleft
                '4.992 pre maketeststrip
                '4.867 post maketeststrip
                x = x
            End If
            'DoEvents
        End If
        oP7XP = P7XP
        
        P7XP = 0
    Else
        If Y > PicHeight - 10 * VAddjust Or Y < 20 And P7ZoomLevel > 0 Then
            If AcV < 1 Then
                P7XP = 1
            ElseIf AcV > AxLen Then
                P7XP = AxLen
            Else
                P7XP = oP7XP
            End If
            Call ShrinkZoom
            P7XP = 0
            oP7XP = 0
        ElseIf x > Picture7.Width - 10 Or x < 25 Then
            If AcV < 1 Then
                P7XP = 1
            ElseIf AcV > AxLen Then
                P7XP = AxLen
            Else
                P7XP = oP7XP
            End If
            Call ShrinkZoom
            P7XP = 0
            oP7XP = 0
        ElseIf x <= Picture7.Width - 10 And x > 25 Then
            P7XP = oP7XP
            Call ShrinkZoom
            
            
            P7XP = 0
            oP7XP = 0
        End If
    End If
    If ManFlag > -1 And ManFlag <> 60 And ManFlag <> 161 Then
        Form1.Picture2.Enabled = True
        If x < Picture7.Width - 10 And x > 25 And Y < PicHeight - 10 * VAddjust And Y >= 20 Then
            
            Dim LetGo As Integer, b1 As Long, g1 As Long
            'If APlot = 0 Then
            P7PixCol = GetPixel(Form1.Picture7.hdc, x, Y)
            RefCol(0) = GetPixel(Form1.Picture7.hdc, 5, 25)
            Bak = P7PixCol
            b = Int(Bak / 65536)
            g = Int((Bak - b * 65536) / 256)
            r = Int(Bak - b * 65536 - g * 256)
            LetGo = 0

            If (b > BkB + 5 Or b < BkB - 5) Then LetGo = LetGo + 1

            If (r > BkR + 5 Or r < BkR - 5) Then LetGo = LetGo + 1

            If (g > BkG + 5 Or g < BkG - 5) Then LetGo = LetGo + 1
            'End If
            BkR = BkR
            BkG = BkG
            BkB = BkB

            If LetGo >= 2 And (ManFlag = 1 Or ManFlag = 3 Or ManFlag = 7 Or ManFlag = 4) Then

                If ManFlag = 1 Then
                    Extra = 1
                Else
                    Extra = 0
                End If

                For Z = 1 To NumberOfSeqs + Extra
                    
                    Bak = RefCol(Z)
                    
                    'For X = PXP - 1 To PXP + 1
                        
                        LetGo = 0
                        b1 = Int(Bak / 65536)
                        g1 = Int((Bak - b1 * 65536) / 256)
                        r1 = Int(Bak - b1 * 65536 - g1 * 256)
    
                        If r <= r1 + 2 And r >= r1 - 2 Then LetGo = LetGo + 1
    
                        If g <= g1 + 2 And g >= g1 - 2 Then LetGo = LetGo + 1
    
                        If b <= b1 + 2 And b >= b1 - 2 Then LetGo = LetGo + 1
                        If UBound(RevSeq, 1) < Z Then
                            ReDim Preserve RevSeq(Z)
                        End If
                        If LetGo >= 2 Then 'P7PixCol = RefCol(X) Then
                            Picture7.MousePointer = 99
'                            Dummy = ShowCursor(True)
'                            If Dummy < 0 Then
'                                Do While Dummy < 0
'                                    Dummy = ShowCursor(True)
'                                Loop
'                            End If
                            Picture7.ToolTipText = OriginalName(Form5.Combo1.ListIndex - 1) + " scanned against " + OriginalName(RevSeq(Z))
                            Exit For
                        End If
                    'Next X
                    If Z = NumberOfSeqs Then

                        If Picture7.MousePointer <> 2 Then
'                            Dummy = ShowCursor(False)
'                            If Dummy < -1 Then
'                                Do While Dummy < -1
'                                    Dummy = ShowCursor(True)
'                                Loop
'                            End If
'
                            Picture7.MousePointer = 2
                            
                            Picture7.ToolTipText = ""
                        End If

                    End If

                Next 'Z

            Else
                If RelX > 0 Or RelY > 0 Then
'                    Dummy = ShowCursor(False)
'                    If Dummy < -1 Then
'                        Do While Dummy < -1
'                            Dummy = ShowCursor(True)
'                        Loop
'                    End If
                    Picture7.MousePointer = 2
                End If
                Picture7.ToolTipText = ""
            End If

            If BeginFlashval = 0 And EndFlashval = 0 Then
                Picture7.Refresh
            End If
            'If Picture7.MousePointer = 2 Then
            
            If RelX > 0 Or RelY > 0 Then
                Picture7.DrawMode = 7
                Picture7.AutoRedraw = False
                Picture7.ForeColor = RGB(112, 112, 112)
                Picture7.Line (x, 20)-(x, PicHeight - 10)
                Picture7.Line (25, Y)-(Picture7.Width - 10 * HAddjust, Y)
                Picture7.AutoRedraw = True
                Picture7.DrawMode = 13
            End If
            'End If
        Else
            If BeginFlashval = 0 And EndFlashval = 0 Then
                Picture7.Refresh
            End If
            Picture7.MousePointer = 0
'            Dummy = ShowCursor(True)
'            If Dummy < 0 Then
'                Do While Dummy < 0
'                    Dummy = ShowCursor(True)
'                Loop
'            End If
        End If

        

        

        
    Else
        '    Exit Sub

        If RunFlag = 1 Then 'And ( _

            Over7Flag = 1

            If RunFlag = 1 And (((XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum) Or ((XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1)) Or CurrentCheck = 21 Or CurrentCheck = 22 Or CurrentCheck = 23) And CurrentCheck <> 20 Then
                If BeginFlashval = 0 And EndFlashval = 0 Then
                    Picture7.Refresh
                End If
                Picture7.AutoRedraw = False
                Picture7.DrawMode = 7

                If x < Picture7.Width - 10 And x > 25 And Y < PicHeight - 10 And Y >= 20 Or (CurrentCheck = 23 And Y >= 15) Then
                    Dim LPNT As POINTAPI, PictX As Long
                    
                    Picture7.ForeColor = RGB(20, 20, 20)
                    'Form1.Picture7.AutoRedraw = False
                    PictX = Form1.Picture7.hdc
                    Dummy = MoveToEx(PictX, x, 20, LPNT)
                    Dummy = LineTo(PictX, x, PicHeight - 10)
                    
                    Dummy = MoveToEx(PictX, 25, Y, LPNT)
                    Dummy = LineTo(PictX, Picture7.Width - 5 * HAddjust, Y)
                    
                    
'                    Picture7.ForeColor = RGB(255, 255, 255)
'                    'Form1.Picture7.AutoRedraw = False
'                    PictX = Form1.Picture7.hdc
'                    Dummy = MoveToEx(PictX, X, Y - 10, LPNT)
'                    Dummy = LineTo(PictX, X, Y + 10)
'
'                    Dummy = MoveToEx(PictX, X - 10, Y, LPNT)
'                    Dummy = LineTo(PictX, X + 10, Y)
'
                    
                    
                    'Form1.Picture7.AutoRedraw = True
                    'Picture7.ForeColor = RGB(255, 0, 0)
                    'Picture7.Line (X, 20)-(X, PicHeight - 10)
                    'Picture7.Line (25, Y)-(Picture7.Width - 10 * HAddjust, Y)
'                    Dummy = ShowCursor(False)
'                    If Dummy > -1 Then
'                        Do While Dummy > -1
'                            Dummy = ShowCursor(False)
'                        Loop
'                    End If
                    Picture7.MousePointer = 2
                    
                    'Picture7.ForeColor = RGB(0, 0, 0)
                Else
                    
                    Picture7.MousePointer = 0
'                    ShowCursor True
'                    Dummy = ShowCursor(True)
'                    If Dummy < 0 Then
'                        Do While Dummy < 0
'                            Dummy = ShowCursor(True)
'                        Loop
'                    End If
                End If

                Picture7.AutoRedraw = True
            ElseIf RunFlag = 1 And ((XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 0) Or CurrentCheck = 20 Then
                If BeginFlashval = 0 And EndFlashval = 0 Then
                    Picture7.Refresh
                End If
                Picture7.AutoRedraw = False
                Picture7.DrawMode = 7

                If x < Picture7.Width - 8 And x > 26 And PicHeight And Y >= 30 Then
                    Picture7.ForeColor = RGB(112, 112, 112)
                    Picture7.Line (x, 30)-(x, PicHeight)
                    Picture7.Line (26, Y)-(Picture7.Width - 8 * HAddjust, Y)
'                    Dummy = ShowCursor(False)
'                    If Dummy > -1 Then
'                        Do While Dummy > -1
'                            Dummy = ShowCursor(False)
'                        Loop
'                    End If
                    Picture7.MousePointer = 2
                Else
                    Picture7.MousePointer = 0
'                    Dummy = ShowCursor(True)
'                    If Dummy < 0 Then
'                        Do While Dummy < 0
'                            Dummy = ShowCursor(True)
'                        Loop
'                    End If
                End If

                Picture7.AutoRedraw = True
            End If

            Picture7.DrawMode = 13

            If HighlightFlagII = 1 Then
                Picture20.Refresh
                HighlightFlagII = 0
                Picture20.ToolTipText = ""
            End If

            XFactor = (Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0)))

            If XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
                yfactor = (PicHeight - 15 - 20)
            Else
                yfactor = (PicHeight - 35)
            End If

            Pic7PointerVal = x

            

        Else

            If Over7Flag = 1 Then
                If BeginFlashval = 0 And EndFlashval = 0 Then
                    Picture7.Refresh
                End If
                Over7Flag = 0
            End If

            Pic7PointerVal = x

            

            
            Picture7.MousePointer = 0
'            Dummy = ShowCursor(True)
'            If Dummy < 0 Then
'                Do While Dummy < 0
'                    Dummy = ShowCursor(True)
'                Loop
'            End If
        End If

    End If
    'XX = Form1.SSPanel9.s
    'XX = Label15.Top
'    XX = Label1.Visible
'    XX = SSPanel11.Enabled
'    Label1.ZOrder
'    Label1.Top = 128
    '''XX = Form1.TextHeight("O") ' Label1.Height
    'YY = Label15.Height
    Form1.Label1.Caption = aCap & " : " & bCap
    Form1.Label1.Refresh
    'XX = Form1.Label1.Visible
    If Abs(val(aCap) - XoverList(RelX, RelY).Beginning) < 4 Then
        If Pic7BBFlag = 0 Then
            Pic7BBFlag = 1
            Pic7GoonFlag = 1
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
                
            
            'redraw picture2
        Else
            Pic7BBFlag = 1
        End If
    Else
        If Pic7BBFlag = 1 Then
            Pic7BBFlag = 0
            Pic7GoonFlag = 1
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
            'redraw picture2
        End If
        Pic7BBFlag = 0
    End If
    
    If Abs(val(aCap) - XoverList(RelX, RelY).Ending) < 4 Then
        If Pic7BBFlag = 0 Then
            Pic7EBFlag = 1
            Pic7GoonFlag = 1
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
        Else
            Pic7EBFlag = 1
        End If
    Else
        If Pic7EBFlag = 1 Then
            'redraw picture2
            Pic7EBFlag = 0
            Pic7GoonFlag = 1
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
        End If
        Pic7EBFlag = 0
    End If
    Pic7GoonFlag = 0
    'ElseIf Abs(Val(aCap) - XOverlist(RelX, RelY).Ending) < 2 Then
    
    
    Dim Vacap As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    Vacap = 0
    Vacap = val(aCap)
    If Vacap > 0 And Vacap <= Decompress(Len(StrainSeq(0))) Then
        PermSPos = Vacap
    ElseIf x < 30 Then
        PermSPos = 1
    ElseIf x > Picture7.Width - 10 Then
        PermSPos = Decompress(Len(StrainSeq(0)))
    Else
        
        PermSPos = 0
    End If
    
    LastF1P7Y = Y
    LastF1P7X = x
    
    'DoEvents
    On Error GoTo 0
    P7MMactive = 0
End Sub

Private Sub Picture7_MouseUp(Button As Integer, Shift As Integer, x As Single, Y As Single)
'Exit Sub
    If ManFlag = -1 Then
        
        If RelX > 0 Or RelY > 0 Then
            If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
                
            Else
                Picture12.Visible = False
                
            End If
        End If
    Else
        If ManFlag = 9 Then
        
            
        Else
            Picture12.Visible = False
        End If
    End If
  'picture12.Visible = False
End Sub

Private Sub Picture8_Click()
x = x
End Sub

Private Sub Picture9_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
Picture2.Refresh
Picture3.Refresh
End Sub

Private Sub PlaceABBPMnu_Click()
Dim RL As Long, LS As Long, BPos As Long, Epos As Long
Dim EV As Long, oRelX As Long, oRelY As Long
Call DisableInterface
Call SaveUndo
SS = Abs(GetTickCount)
If SeqMnuFlag = 1 Then
    Rffflag = 1
    Call Command18_Click
    SeqMnuFlag = 0
Else
    
    oRelX = RelX
    oRelY = RelY
    
    EV = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    For RelX = 0 To NextNo
        For RelY = 1 To CurrentXOver(RelX)
            If SuperEventList(XoverList(RelX, RelY).Eventnumber) = EV Then
                XoverList(RelX, RelY).Beginning = Recompress(PermSPos)
                'check to see if the new BP pos is close to misssing data
                If XoverList(RelX, RelY).SBPFlag = 1 Then
                    XoverList(RelX, RelY).SBPFlag = 0
                ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                    XoverList(RelX, RelY).SBPFlag = 2
                End If
                Call DoEnds(0)
            End If
        Next RelY
    Next RelX
    
    RelX = oRelX
    RelY = oRelY
    
    'clear tree test stats
    If DebuggingFlag < 2 Then On Error Resume Next
    asx = 0
    asx = UBound(TreeTestStats, 2)
    If asx < EV Then ReDim Preserve TreeTestStats(3, EV)
    
    
    
    For x = 0 To 3
        TreeTestStats(x, EV) = -1
    Next x
    On Error GoTo 0
    
    
    If XoverList(RelX, RelY).Accept = 1 Then
        AcceptChangeFlag = 2
        Form1.Command10.Enabled = True
       
    ElseIf AcceptChangeFlag = 0 Then
        AcceptChangeFlag = 1
    End If
    
    UpdateProgressBar = 1
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    GoOn = RedoBreakpoints(1)
    Form1.ProgressBar1.Value = 20
    Call UpdateF2Prog
    Call IntegrateXOvers(0)
    
    Form1.ProgressBar1.Value = 30
    Call UpdateF2Prog
    PermXVal = 0: PermYVal = 0
    UpdateIDFlag = 1
    
    Dim inRelX As Long, inRelY As Long
    inRelX = RelX: inRelY = RelY
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    If inRelX <> RelX Or inRelY <> RelY Then
        Call IntegrateXOvers(0)
        UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
        Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    End If
    
    Form1.ProgressBar1.Value = 80
    Call UpdateF2Prog
    
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
    
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    UpdateIDFlag = 0
    TreeImage(3) = 0
    DoneTree(0, 3) = 0
    DoneTree(1, 3) = 0
    DoneTree(2, 3) = 0
    DoneTree(3, 3) = 0
    DoneTree(4, 3) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Form2.SSPanel1(2).ZOrder
    On Error GoTo 0
End If
    
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
    UpdateProgressBar = 0
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState: Form1.Refresh
    'Form1.Caption = Label1.Top
    Call EnableInterface
    
'EE = Abs(GetTickCount)
'TT = EE - SS '80.964 seconds 3200 seqs(40.763 with no bootstrap replicates)
'X = X
End Sub

Private Sub PlaceABBPMnu4_Click()
If PermSPos > 0 And PermSPos <= Decompress(Len(StrainSeq(0))) Then
    Call PlaceABBPMnu_Click
    'Call RedrawPlotAA(1)
End If

End Sub

Private Sub PlaceAEBPMnu_Click()


Dim RL As Long, LS As Long, BPos As Long, Epos As Long
Dim EV As Long, oRelX As Long, oRelY As Long
Call DisableInterface
Call SaveUndo

oRelX = RelX
oRelY = RelY
If Eventnumber > 0 Then


    EV = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    For RelX = 0 To NextNo
        For RelY = 1 To CurrentXOver(RelX)
            If SuperEventList(XoverList(RelX, RelY).Eventnumber) = EV Then
                XoverList(RelX, RelY).Ending = Recompress(PermSPos)
                If XoverList(RelX, RelY).SBPFlag = 2 Then
                    XoverList(RelX, RelY).SBPFlag = 0
                ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                    XoverList(RelX, RelY).SBPFlag = 1
                End If
                   
                'check to see if the new BP pos is close to misssing data
                Call DoEnds(1)
                
            End If
        Next RelY
    Next RelX
End If

RelX = oRelX
RelY = oRelY

'clear tree test stats

If DebuggingFlag < 2 Then On Error Resume Next
asx = 0
asx = UBound(TreeTestStats, 2)
If asx < EV Then ReDim Preserve TreeTestStats(3, EV)



For x = 0 To 3
    TreeTestStats(x, EV) = -1
Next x
On Error GoTo 0


'If EV > UBound(TreeTestStats, 2) Then
'    ReDim Preserve TreeTestStats(3, EV)
'End If
'For X = 0 To 3
'    TreeTestStats(X, EV) = -1
'Next X


If XoverList(RelX, RelY).Accept = 1 Then
    AcceptChangeFlag = 2
    Form1.Command10.Enabled = True
    
ElseIf AcceptChangeFlag = 0 Then
    AcceptChangeFlag = 1
End If
UpdateProgressBar = 1
Form1.ProgressBar1.Value = 5
Call UpdateF2Prog
GoOn = RedoBreakpoints(1)



Form1.ProgressBar1.Value = 20
Call UpdateF2Prog
Call IntegrateXOvers(0)
Form1.ProgressBar1.Value = 30
Call UpdateF2Prog
PermXVal = 0: PermYVal = 0
UpdateIDFlag = 1

Dim inRelX As Long, inRelY As Long
inRelX = RelX: inRelY = RelY
Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
If inRelX <> RelX Or inRelY <> RelY Then
    Call IntegrateXOvers(0)
    UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
End If

Form1.ProgressBar1.Value = 80
Call UpdateF2Prog

If RIMode = 0 Then
    Call MakeRecombinationInfo(RelX, RelY)
End If
Form1.ProgressBar1.Value = 100
Call UpdateF2Prog

UpdateIDFlag = 0
DoneTree(0, 3) = 0
TreeImage(3) = 0
DoneTree(1, 3) = 0
DoneTree(2, 3) = 0
DoneTree(3, 3) = 0
DoneTree(4, 3) = 0
If DebuggingFlag < 2 Then On Error Resume Next
Form2.SSPanel1(2).ZOrder
On Error GoTo 0
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
Screen.MousePointer = 0
UpdateProgressBar = 0
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState: Form1.Refresh
Call EnableInterface
End Sub

Private Sub PlaceBBPMnu_Click()
    XoverList(RelX, RelY).Beginning = Recompress(PermSPos)
    If XoverList(RelX, RelY).SBPFlag = 1 Then
        XoverList(RelX, RelY).SBPFlag = 0
    ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
        XoverList(RelX, RelY).SBPFlag = 2
    End If

    If XoverList(RelX, RelY).Accept = 1 Then
        AcceptChangeFlag = 2
        Form1.Command10.Enabled = True
        
    ElseIf AcceptChangeFlag = 0 Then
        AcceptChangeFlag = 1
    End If
    'check to see if the new BP pos is close to misssing data
    Call DoEnds(0)
    
    
    GoOn = RedoBreakpoints(1)



    
    Call IntegrateXOvers(0)
    PermXVal = 0: PermYVal = 0
    
    UpdateIDFlag = 1
    Dim inRelX As Long, inRelY As Long
    inRelX = RelX: inRelY = RelY
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    If inRelX <> RelX Or inRelY <> RelY Then
        Call IntegrateXOvers(0)
        UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
        Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    End If
    
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
    UpdateIDFlag = 0
    
    
    'If PermXVal > 0 Or PermYVal > 0 Then
    '    PAVal = RelY
    '    RecSeq = RelX
    '    Call Picture6_MouseDown(1, 1, PermXVal, PermYVal - VScroll2.Value)
    '
    'End If
    'clear tree test stats
    EV = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    If BestEvent(EV, 0) = RelX And BestEvent(EV, 1) = RelY Then
        For x = 0 To 3
            TreeTestStats(x, EV) = -1
        Next x
    End If
    DoneTree(0, 3) = 0
    TreeImage(3) = 0
    DoneTree(1, 3) = 0
    DoneTree(2, 3) = 0
    DoneTree(3, 3) = 0
    DoneTree(4, 3) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Form2.SSPanel1(2).ZOrder
    On Error GoTo 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
End Sub

Private Sub PlaceEBPMnu_Click()
    XoverList(RelX, RelY).Ending = Recompress(PermSPos)
    If XoverList(RelX, RelY).SBPFlag = 2 Then
        XoverList(RelX, RelY).SBPFlag = 0
    ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
        XoverList(RelX, RelY).SBPFlag = 1
    End If
Call DoEnds(1)
    
    If XoverList(RelX, RelY).Accept = 1 Then
        AcceptChangeFlag = 2
        Form1.Command10.Enabled = True
        
    ElseIf AcceptChangeFlag = 0 Then
        AcceptChangeFlag = 1
    End If
    
    
    GoOn = RedoBreakpoints(1)

'Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)

    
    Call IntegrateXOvers(0)
    Timer1.Enabled = True
    'If PermXVal > 0 Or PermYVal > 0 Then
    '    PAVal = RelY
    '    RecSeq = RelX
    '    Call Picture6_MouseDown(1, 1, PermXVal, PermYVal - VScroll2.Value)
    '
    'End If
    PermXVal = 0: PermYVal = 0
    
    UpdateIDFlag = 1

    Dim inRelX As Long, inRelY As Long
    inRelX = RelX: inRelY = RelY
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    If inRelX <> RelX Or inRelY <> RelY Then
        Call IntegrateXOvers(0)
        UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
        Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
        
    End If
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
    UpdateIDFlag = 0
    
    'clear tree test stats
    EV = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    If BestEvent(EV, 0) = RelX And BestEvent(EV, 1) = RelY Then
        For x = 0 To 3
            TreeTestStats(x, EV) = -1
        Next x
    End If
    DoneTree(0, 3) = 0
    TreeImage(3) = 0
    DoneTree(1, 3) = 0
    DoneTree(2, 3) = 0
    DoneTree(3, 3) = 0
    DoneTree(4, 3) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Form2.SSPanel1(2).ZOrder
    On Error GoTo 0
    
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
    
End Sub

Private Sub PrintMnu_Click()

    Call PrintHomolPlots

End Sub

Private Sub PlaceAEBPMnu4_Click()
If PermSPos > 0 And PermSPos <= Decompress(Len(StrainSeq(0))) Then
    Call PlaceAEBPMnu_Click
    'Call RedrawPlotAA(1)
End If
End Sub

Private Sub QvRMnu_Click()
QvRFlag = 1
QvRFlagOverrideFlag = 1
QvRScanGoonFlag = 1
If RefNum < 2 Then
    MsgBox ("Before you start a query vs reference scan you will need to select a set of (preferably non-recombinant) reference sequences")
    
    Call SelRefMnu_Click
    Sleep 200
    Do While Form5.Visible = True
        DoEvents
    Loop
End If
If RefNum = 1 Then
    QvRFlag = 0
    'RefNum = 0
    SelGrpFlag = 1
    
    For x = 0 To PermNextno
        If ReferenceList(x) > 0 Then
            GrpMaskSeq(x) = 1
        Else
            GrpMaskSeq(x) = 0
        End If
        
    Next x
    Call PrintNames
End If

If QvRScanGoonFlag = 0 Or RefNum = 0 Then
    QvRScanGoonFlag = 0
    
    Exit Sub
Else
    QvRScanGoonFlag = 0
End If
Call Command22_Click
QvRFlagOverrideFlag = 0
End Sub

Private Sub RCheckMnu_Click()

Dim OFVal(3)

If RCAllFlag = 1 Then
    Call RCheckMnu2_Click
    Exit Sub

End If
OFVal(0) = Form1.Command25.Enabled
Command25.ToolTipText = "Stop the re-scan"
OFVal(1) = Form1.Frame7.Enabled
OFVal(2) = Form1.Combo1.Enabled
OFVal(3) = Form1.Command29(0).Enabled
SuspendFlash = 1
Timer1.Enabled = False
NJFlag = 0

Call DisableInterface
Call ModNextno
XX = NextNo
Form1.Command25.Enabled = True
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
Form1.Combo1.Enabled = False
 Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
Call RescanBest(SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber))
If AbortFlag = 1 Then
    AbortFlag = 0
    Call UnModNextno
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = "Rescan aborted"
    Call UpdateF2Prog
End If
Call EnableInterface
Form1.Command25.Enabled = OFVal(0)
Form1.Frame7.Enabled = OFVal(1)
Form1.Picture23(1).Enabled = OFVal(1)
Form1.Combo1.Enabled = OFVal(2)
 Form1.Command29(0).Enabled = OFVal(3)
SuspendFlash = 0
Timer1.Enabled = True

End Sub

Private Sub RCheckMnu2_Click()

Dim OFVal(3)
OFVal(0) = Form1.Command25.Enabled
Command25.ToolTipText = "Stop the rescan"
OFVal(1) = Form1.Frame7.Enabled
OFVal(2) = Form1.Combo1.Enabled
OFVal(3) = Form1.Command29(0).Enabled
SuspendFlash = 1
Timer1.Enabled = False
NJFlag = 0

Call DisableInterface

Form1.Command25.Enabled = True
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
Form1.Combo1.Enabled = False
 Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True

XX = Frame7.Enabled
XX = SSPanel10.Enabled
XX = SSPanel8.Enabled

Call RescanBest(0)
NJFlag = 0
If (RelX > 0 Or RelY > 0) And AbortFlag = 0 Then
    Call RescanBest(SuperEventList(XoverList(RelX, RelY).Eventnumber))
End If
If AbortFlag = 1 Then
    AbortFlag = 0
    Call UnModNextno
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = "Rescan aborted"
    Call UpdateF2Prog
End If
Call EnableInterface
Form1.Command25.Enabled = OFVal(0)
Form1.Frame7.Enabled = OFVal(1)
Form1.Picture23(1).Enabled = OFVal(1)
Form1.Combo1.Enabled = OFVal(2)
 Form1.Command29(0).Enabled = OFVal(3)
SuspendFlash = 0
Timer1.Enabled = True
End Sub

Private Sub RDPScanMnu_Click()
 Call DeactivateScans
    DoScans(0, 0) = 1
    Call Command22_Click

    'doscans(0,0) = ORDP
    'doscans(0,1) = OGC
    'doscans(0,2) = OBS
    'doscans(0,3) = OMC
    'doscans(0,4) = OPP
    'doscans(0,5) = OSS
End Sub

Private Sub ReassignMajorMnu_Click()

If DontSaveUndo = 0 Then
    Call SaveUndo
End If

Form1.WindowState = Form1.WindowState
MenuUpFlag = 0



If XOMiMaInFileFlag = 1 Then
        'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
    Form1.SSPanel1.Caption = "Reading minor parent lists from disk"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Form2.SSPanel3.Caption = "Reading minor parent lists from disk"
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim BestXOListMi(PermNextno, UBXOMi)
    ReDim BestXOListMa(PermNextno, UBXoMa)
    UBXoMa = UBound(BestXOListMa, 2)
    If MiRec < 1 Then
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Get #FF, , BestXOListMi()
        Close #FF
        MiRec = 1
    End If
    Form1.SSPanel1.Caption = "Reading major parent lists from disk"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Form2.SSPanel3.Caption = "Reading major parent lists from disk"
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    
    If MaRec < 1 Then
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Get #FF, , BestXOListMa()
        Close #FF
        MaRec = 1
    End If
    ChDrive oDirX
    ChDir oDirX
    
End If
Dim TempVals As XOverDefine
TempVals = XoverList(RelX, RelY)
Dim DontRedraw As Byte, TBegin As Long, DSeq As Long, TSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
'find which block must end up flashing
If RelX <> SERecSeq Or RelY <> SEPAVal Then
    DontRedraw = 1
Else
    DontRedraw = 0
End If
  'XX = NextNo
OSEPAVal = SEPAVal
DSeq = XoverList(SERecSeq, SEPAVal).Daughter
TSeq = XoverList(SERecSeq, SEPAVal).MajorP
TProg = XoverList(SERecSeq, SEPAVal).ProgramFlag
TBegin = XoverList(SERecSeq, SEPAVal).Beginning
ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
Prg = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).ProgramFlag

If MajorPar(ENumb, TSeq) = 0 And StupidWrap = 0 Then
    StupidWrap = 1
    Call ReassignMinorMnu_Click
    StupidWrap = 0
    Call GoToThis(1, BestEvent(ENumb, 0), BestEvent(ENumb, 1), PermXVal, PermYVal)
    Exit Sub
End If
    
    
    Dim InvolvedR As Byte
    InvolvedR = 0
    If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
        InvolvedR = 1
    End If
    
    Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
    Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
    Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())







Dim DoMajFlag As Byte
    
If NOPINI(0, ENumb) = 2 Then
    Call AddEvents(TraceNumbMi, TraceMi(), BCurrentXoverMi(), BestXOListMi(), BCurrentXoverMa(), BestXOListMa())
    Call AddEvents(TraceNumbD, TraceD(), CurrentXOver(), XoverList(), BCurrentXoverMi(), BestXOListMi())
    Call AddEvents(TraceNumbMa, TraceMa(), BCurrentXoverMa(), BestXOListMa(), CurrentXOver(), XoverList())
    For x = 0 To AddNum - 1
        If Confirm(ENumb, x) > 0 And ConfirmMa(ENumb, x) > 0 Then
            Temp = Confirm(ENumb, x)
            Confirm(ENumb, x) = ConfirmMa(ENumb, x)
            ConfirmMa(ENumb, x) = ConfirmMi(ENumb, x)
            ConfirmMi(ENumb, x) = Temp
            Temp = ConfirmP(ENumb, x)
            ConfirmP(ENumb, x) = ConfirmPMa(ENumb, x)
            ConfirmPMa(ENumb, x) = ConfirmPMi(ENumb, x)
            ConfirmPMi(ENumb, x) = Temp
        ElseIf Confirm(ENumb, x) > 0 And ConfirmMa(ENumb, x) = 0 Then
            ConfirmMa(ENumb, x) = Confirm(ENumb, x)
            ConfirmPMa(ENumb, x) = ConfirmP(ENumb, x)
            ConfirmMi(ENumb, x) = Confirm(ENumb, x)
            ConfirmPMi(ENumb, x) = ConfirmP(ENumb, x)
        
        End If
    Next x
        
    
    NOPINI(0, ENumb) = 0
    NOPINI(1, ENumb) = 1
    NOPINI(2, ENumb) = 2
    DR = 1: MiR = 0: MaR = 2
    
    Call CleanXOList(ENumb, BestXOListMi(), BCurrentXoverMi(), MinorPar())
ElseIf NOPINI(0, ENumb) = 1 Or NOPINI(0, ENumb) = 0 Then
    
    Call AddEvents(TraceNumbMa, TraceMa(), BCurrentXoverMa(), BestXOListMa(), CurrentXOver(), XoverList())
    Call AddEvents(TraceNumbD, TraceD(), CurrentXOver(), XoverList(), BCurrentXoverMa(), BestXOListMa())
    
    For x = 0 To AddNum - 1
        
        If Confirm(ENumb, x) > 0 And ConfirmMa(ENumb, x) > 0 Then
            Temp = Confirm(ENumb, x)
            Confirm(ENumb, x) = ConfirmMa(ENumb, x)
            ConfirmMa(ENumb, x) = Temp
            Temp = ConfirmP(ENumb, x)
            ConfirmP(ENumb, x) = ConfirmPMa(ENumb, x)
            ConfirmPMa(ENumb, x) = Temp
        ElseIf Confirm(ENumb, x) > 0 And ConfirmMa(ENumb, x) = 0 Then
            ConfirmMa(ENumb, x) = Confirm(ENumb, x)
            ConfirmPMa(ENumb, x) = ConfirmP(ENumb, x)
        End If
    Next x
    If NOPINI(0, ENumb) = 0 Then
        NOPINI(0, ENumb) = 1
        NOPINI(1, ENumb) = 0
      Else
        NOPINI(0, ENumb) = 0
        NOPINI(1, ENumb) = 1
    End If
    DR = 1: MiR = -1: MaR = 0
End If
    
'        XX = NOPINI(0, ENumb) '1, 0, 2 = the standard green-purple pattern
'        XX = NOPINI(1, ENumb) '0, 1, 2 = minor parent unknown
'        XX = NOPINI(2, ENumb) '2, 0, 1 = major paret unknown
    

Call CleanXOList(ENumb, XoverList(), CurrentXOver(), Daught())
Call CleanXOList(ENumb, BestXOListMa(), BCurrentXoverMa(), MajorPar())

Call SwapInvolved(DR, MiR, MaR, ENumb, Daught(), MinorPar(), MajorPar(), DScores()) 'sorts out the dscores, daught arrays etc

'replace udaughtbackup
If UBound(Daught, 2) > UBound(uDaught, 2) Then
    UBD = UBound(uDaught, 2)
Else
    UBD = UBound(Daught, 2)
End If
For x = 0 To UBD
    uDaught(ENumb, x) = Daught(ENumb, x)
Next x
If ExcludedEventNum > 0 Then
    If NumExcludedEventNum > 0 Then
        'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
        NF3 = FreeFile
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
        Put #NF3, 1, ExcludedEventNum
        Put #NF3, , EventsInExcludeds
        Close #NF3
        ReDim EventsInExcludeds(5, 1000)
        'ExcludedEventNum = 1If ChangeMade = 1 And NumExcludedEventNum > 0 Then
            NF3 = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Put #NF3, 1, ExcludedEventNum
            Put #NF3, , EventsInExcludeds
            Close #NF3
            'ExcludedEventNum = 1
            ChDrive oDirX
            ChDir oDirX
        
        End If
    End If
End If
        ChDrive oDirX
        ChDir oDirX
    End If
    Dim ChangeMade As Long
    For j = 0 To NumExcludedEventNum
        If NumExcludedEventNum > 0 Then
            NF3 = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Get #NF3, , ExcludedEventNum
            ReDim EventsInExcludeds(5, ExcludedEventNum)
            Get #NF3, , EventsInExcludeds
            Close #NF3
            'ExcludedEventNum = 1
            ChDrive oDirX
            ChDir oDirX
        End If
            
        ChangeMade = 0
        'I may need to also copy over for the backups of daught etc
        For x = 0 To UBound(ELLite, 2)
            If EventsInExcludeds(1, x) = -ENumb Then
                If EventsInExcludeds(0, x) = 3 Then
                    EventsInExcludeds(0, x) = 1
                    ChangeMade = 1
                    Temp = MajorPar(ENumb, EventsInExcludeds(2, x))
                    MajorPar(ENumb, EventsInExcludeds(2, x)) = Daught(ENumb, EventsInExcludeds(2, x))
                    Daught(ENumb, EventsInExcludeds(2, x)) = Temp
                    
                ElseIf EventsInExcludeds(0, x) = 1 Then
                    EventsInExcludeds(0, x) = 3
                    ChangeMade = 1
                    Temp = MajorPar(ENumb, EventsInExcludeds(2, x))
                    MajorPar(ENumb, EventsInExcludeds(2, x)) = Daught(ENumb, EventsInExcludeds(2, x))
                    Daught(ENumb, EventsInExcludeds(2, x)) = Temp
                End If
                'Daught(ENumb, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                'XX = OriginalName(EventsInExcludeds(2, x))
            End If
        Next x
        If ChangeMade = 1 And NumExcludedEventNum > 0 Then
            NF3 = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Put #NF3, 1, ExcludedEventNum
            Put #NF3, , EventsInExcludeds
            Close #NF3
            'ExcludedEventNum = 1
            ChDrive oDirX
            ChDir oDirX
        
        End If
    Next j
End If
'XX = Daught(ENumb, 192)

Call MakeBestEvent
AXONo = BestEvent(ENumb, 1)
PressFlag = 0
'TSeq = BestEvent(ENumb, 0)
If TSeq > UBound(CurrentXOver, 1) Then
    TSeq = BestEvent(ENumb, 0)
'    For x = 0 To PermNextno
'        For Y = 1 To CurrentXOver(x)
'            If TSeq = XoverList(x, Y).Daughter And SuperEventList(XoverList(x, Y).Eventnumber) = ENumb Then
'
'                TSeq = x
'                'RelY = Y
'            End If
'        Next Y
'    Next x
End If

For x = 1 To CurrentXOver(TSeq)
    If SuperEventList(XoverList(TSeq, x).Eventnumber) = ENumb Then
        If XoverList(TSeq, x).ProgramFlag = TProg Or XoverList(TSeq, x).ProgramFlag + AddNum = TProg Then
            If XoverList(TSeq, x).Beginning <> TBegin Then
                PressFlag = 1
            End If
            AXONo = x
            Exit For
        End If
    End If
Next x
   
Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
TarSeq = TSeq
AXONoY = -1
    
    'For X = 0 To NextNo
    '    If Daught(ENumb, X) > 0 And Daught(ENumb, X) < 5 Then
    '        RecSeq = X
    '        Call UpdateScheme
    '
    '    ElseIf MiR = 0 And MinorPar(ENumb, X) > 0 And MinorPar(ENumb, X) < 5 Then
    '        RecSeq = X
    '        Call UpdateScheme
    '        Call integratexovers(0)
    '    ElseIf MaR = 0 And MajorPar(ENumb, X) > 0 And MajorPar(ENumb, X) < 5 Then
    '        RecSeq = X
    '        Call UpdateScheme
    '        Call integratexovers(0)
    '    End If
    '    Form1.ProgressBar1 = (X / NextNo) * 100
    'Next X
Call IntegrateXOvers(0)
'modify daught, majorp and minorp
'Use NOPINI to determine which sequences should be Mi and Ma parents

SEPAVal = AXONo
        
If (DSeq = RelX And OSEPAVal = RelY) Then ' Or (XoverList(RelX, RelY).Daughter = DSeq And RelY = OSEPAVal) Then
    HighlightFlag = 0
    
    OSEPAVal = AXONo
    PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    DontPutForm2Ontop = 0
    If PressFlag = 1 Then
        MenuUpFlag = 0
        Call Picture6_MouseDown(1, 0, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    End If
    
    exRelX = RelX
    exRely = RelY
    Seq1 = XoverList(RelX, RelY).MajorP
    Seq2 = XoverList(RelX, RelY).MinorP
    Seq3 = XoverList(RelX, RelY).Daughter
    
    Call ModNextno
    If Form2.Visible = True Then
        For x = 0 To 3
            If TTFlag(x, 0) = 1 Then
                Y = 0
            ElseIf TTFlag(x, 1) = 1 Then
                Y = 1
            ElseIf TTFlag(x, 2) = 1 Then
                Y = 2
            ElseIf TTFlag(x, 3) = 1 Then
                Y = 3
            ElseIf TTFlag(x, 4) = 1 Then
                Y = 4
            End If
            ExtraDX = DoTreeColour(Form2.Picture2(x), Y, x)
        Next x
    End If
    
    Call UnModNextno
    
    RelX = TSeq
    RelY = AXONo
    If RelY = 0 Or RelX > PermNextno Then
        'this could be a problem - it means that the sequence labeled as the major parent doesn't have an entry in xoverlist
        'make an entry in xoverlist
        If RelX > UBound(XoverList, 1) Then
            For x = 0 To PermNextno
                For Y = 1 To CurrentXOver(x)
                    If RelX = XoverList(x, Y).Daughter And SuperEventList(XoverList(x, Y).Eventnumber) = ENumb Then
                        RelX = x
                        TSeq = x
                        RelY = Y
                    End If
                Next Y
            Next x
        End If
        
        If RelY = 0 Then
            CurrentXOver(RelX) = CurrentXOver(RelX) + 1
            
            XoverList(RelX, CurrentXOver(RelX)) = TempVals
            'xoverlist(relx,rely) =
            If XoverList(RelX, CurrentXOver(RelX)).MajorP = RelX Then
                'XX = XoverList(RelX, CurrentXOver(RelX)).Daughter
                XoverList(RelX, CurrentXOver(RelX)).Daughter = XoverList(RelX, CurrentXOver(RelX)).MajorP
                XoverList(RelX, CurrentXOver(RelX)).MajorP = XX
                Daught(ENumb, RelX) = 1
                
            ElseIf XoverList(RelX, CurrentXOver(RelX)).MinorP = RelX Then
                'XX = XoverList(RelX, CurrentXOver(RelX)).Daughter
                XoverList(RelX, CurrentXOver(RelX)).Daughter = XoverList(RelX, CurrentXOver(RelX)).MinorP
                XoverList(RelX, CurrentXOver(RelX)).MinorP = XX
                Daught(ENumb, RelX) = 1
            End If
            RelY = CurrentXOver(RelX)
        End If
    End If
    
    
    
    exRelX = RelX
    exRely = RelY
    Seq1 = XoverList(RelX, RelY).MajorP
    Seq2 = XoverList(RelX, RelY).MinorP
    Seq3 = XoverList(RelX, RelY).Daughter
    
    Call ModNextno
    
    If Form2.Visible = True Then
        Call UnModNextno
        For x = 0 To 3
            If TTFlag(x, 0) = 1 Then
                Y = 0
            ElseIf TTFlag(x, 1) = 1 Then
                Y = 1
            ElseIf TTFlag(x, 2) = 1 Then
                Y = 2
            ElseIf TTFlag(x, 3) = 1 Then
                Y = 3
            ElseIf TTFlag(x, 4) = 1 Then
                Y = 4
            End If
            ExtraDX = DoTreeColour(Form2.Picture2(x), Y, x)
        Next x
    End If
    Call UnModNextno
    If Form2.Visible = True Then
        Call UnModNextno
        For x = 0 To 3
            If x = 1 Then
                Call ModNextno
            Else
                If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                    Call UnModNextno
                End If
            End If
            Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
            x = x
        Next x
    End If
    RelX = TSeq
    RelY = AXONo
    exRelX = RelX
    exRely = RelY
    Timer1.Enabled = True
            
Else
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    DontPutForm2Ontop = 0
    If PressFlag = 1 Then
        MenuUpFlag = 0
        Call Picture6_MouseDown(1, 0, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    End If
    RelX = TSeq
    RelY = AXONo
    exRelX = RelX
    exRely = RelY
    Timer1.Enabled = False
End If
        

If (RelX > 0 Or RelY > 0) And DontRedraw = 0 Then
    PermYVal = 0: PermXVal = 0
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
End If

        
If XoverList(RelX, RelY).Accept = 1 Then
    AcceptChangeFlag = 2
    Form1.Command10.Enabled = True
ElseIf AcceptChangeFlag = 0 Then
    AcceptChangeFlag = 1
End If

If RIMode = 1 Then
    Call MakeSummary
End If
    
    
    
If XOMiMaInFileFlag = 1 Then
'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
    Form1.ProgressBar1.Value = 5
    Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
    Call UpdateF2Prog
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    UBXOMi = UBound(BestXOListMi, 2)
    UBXoMa = UBound(BestXOListMa, 2)
    
    Open "RDP5BestXOListMi" + UFTag For Binary As #FF
    Put #FF, , BestXOListMi()
    Close #FF
    MiRec = MiRec - 1
    
    Form1.ProgressBar1.Value = 60
    Form1.SSPanel1.Caption = "Writing major parent lists to disk"
    Call UpdateF2Prog
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    
    Open "RDP5BestXOListMa" + UFTag For Binary As #FF
    Put #FF, , BestXOListMa()
    Close #FF
    MaRec = MaRec - 1
    
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    Form2.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    ChDrive oDirX
    ChDir oDirX
    Erase BestXOListMi
    Erase BestXOListMa
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
End If
    
            
End Sub

Private Sub ReassignMinorMnu_Click()
If DontSaveUndo = 0 Then
    Call SaveUndo
End If
Form1.WindowState = Form1.WindowState
MenuUpFlag = 0


    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        Form1.SSPanel1.Caption = "Reading minor parent lists from disk"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Form1.SSPanel3.Caption = "Reading minor parent lists from disk"
        Form2.Refresh
        Form3.WindowState = Form3.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        Form1.SSPanel1.Caption = "Reading major parent lists from disk"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Form2.SSPanel3.Caption = "Reading major parent lists from disk"
        Form2.Refresh
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
    End If
    
Dim TempVals As XOverDefine
TempVals = XoverList(RelX, RelY)
Dim DontRedraw As Byte, PressFlag As Byte, TBegin As Long, DSeq As Long, TSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
If RelX <> SERecSeq Or RelY <> SEPAVal Then
    DontRedraw = 1
Else
    DontRedraw = 0
End If
       
OSEPAVal = SEPAVal
DSeq = XoverList(SERecSeq, SEPAVal).Daughter
TSeq = XoverList(SERecSeq, SEPAVal).MinorP
TProg = XoverList(SERecSeq, SEPAVal).ProgramFlag
TBegin = XoverList(SERecSeq, SEPAVal).Beginning
ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
 Prg = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).ProgramFlag
        
If MinorPar(ENumb, TSeq) = 0 And StupidWrap = 0 Then
    StupidWrap = 1
    Call ReassignMajorMnu_Click
    StupidWrap = 0
    Call GoToThis(1, BestEvent(ENumb, 0), BestEvent(ENumb, 1), PermXVal, PermYVal)
    Exit Sub
End If
        
Dim InvolvedR As Byte
InvolvedR = 0
If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
    InvolvedR = 1
End If
        
Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())

Dim DoMajFlag As Byte
        
If NOPINI(0, ENumb) = 0 Then
    Call AddEvents(TraceNumbMi, TraceMi(), BCurrentXoverMi(), BestXOListMi(), CurrentXOver(), XoverList())
    Call AddEvents(TraceNumbD, TraceD(), CurrentXOver(), XoverList(), BCurrentXoverMa(), BestXOListMa())
    Call AddEvents(TraceNumbMa, TraceMa(), BCurrentXoverMa(), BestXOListMa(), BCurrentXoverMi(), BestXOListMi())
    For x = 0 To AddNum - 1
        If Confirm(ENumb, x) > 0 And ConfirmMi(ENumb, x) > 0 Then
            Temp = Confirm(ENumb, x)
            Confirm(ENumb, x) = ConfirmMi(ENumb, x)
            ConfirmMi(ENumb, x) = ConfirmMa(ENumb, x)
            ConfirmMa(ENumb, x) = Temp
            Temp = ConfirmP(ENumb, x)
            ConfirmP(ENumb, x) = ConfirmPMi(ENumb, x)
            ConfirmPMi(ENumb, x) = ConfirmPMa(ENumb, x)
            ConfirmPMa(ENumb, x) = Temp
        ElseIf Confirm(ENumb, x) > 0 And ConfirmMi(ENumb, x) = 0 Then
            ConfirmPMi(ENumb, x) = ConfirmP(ENumb, x)
            ConfirmMi(ENumb, x) = Confirm(ENumb, x)
            ConfirmPMa(ENumb, x) = ConfirmP(ENumb, x)
            ConfirmMa(ENumb, x) = Confirm(ENumb, x)
        End If
    Next x
    
    NOPINI(0, ENumb) = 2
    NOPINI(1, ENumb) = 1
    NOPINI(2, ENumb) = 0
    DR = 2: MiR = 1: MaR = 0
    
    Call CleanXOList(ENumb, BestXOListMa(), BCurrentXoverMa(), MajorPar())
        
ElseIf NOPINI(0, ENumb) = 1 Or NOPINI(0, ENumb) = 2 Then
    Call AddEvents(TraceNumbMi, TraceMi(), BCurrentXoverMi(), BestXOListMi(), CurrentXOver(), XoverList()) 'this moves event coordinates listed in tracemi from
    Call AddEvents(TraceNumbD, TraceD(), CurrentXOver(), XoverList(), BCurrentXoverMi(), BestXOListMi())
    
    'this swaps the xoverlist and bestxolistmi confirm and confirmp values
    For x = 0 To AddNum - 1
        If Confirm(ENumb, x) > 0 And ConfirmMi(ENumb, x) > 0 Then
            Temp = Confirm(ENumb, x)
            Confirm(ENumb, x) = ConfirmMi(ENumb, x)
            ConfirmMi(ENumb, x) = Temp
            Temp = ConfirmP(ENumb, x)
            ConfirmP(ENumb, x) = ConfirmPMi(ENumb, x)
            ConfirmPMi(ENumb, x) = Temp
        ElseIf Confirm(ENumb, x) > 0 And ConfirmMi(ENumb, x) = 0 Then
            ConfirmPMi(ENumb, x) = ConfirmP(ENumb, x)
            ConfirmMi(ENumb, x) = Confirm(ENumb, x)
        End If
    Next x
    If NOPINI(0, ENumb) = 1 Then
        NOPINI(0, ENumb) = 2
        NOPINI(2, ENumb) = 1
      Else
        NOPINI(0, ENumb) = 1
        NOPINI(2, ENumb) = 2
    End If
    DR = 2: MiR = 0: MaR = -1
End If
       
Call CleanXOList(ENumb, XoverList(), CurrentXOver(), Daught()) 'this deletes eall ntries in xoverlist with a minus p-value
Call CleanXOList(ENumb, BestXOListMi(), BCurrentXoverMi(), MinorPar())

Call SwapInvolved(DR, MiR, MaR, ENumb, Daught(), MinorPar(), MajorPar(), DScores())

If UBound(Daught, 2) > UBound(uDaught, 2) Then
    UBD = UBound(uDaught, 2)
Else
    UBD = UBound(Daught, 2)
End If
For x = 0 To UBD
    uDaught(ENumb, x) = Daught(ENumb, x)
Next x
If ExcludedEventNum > 0 Then
    If NumExcludedEventNum > 0 Then
        'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
        NF3 = FreeFile
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
        Put #NF3, 1, ExcludedEventNum
        Put #NF3, , EventsInExcludeds
        Close #NF3
        ReDim EventsInExcludeds(5, 1000)
        'ExcludedEventNum = 1
        ChDrive oDirX
        ChDir oDirX
    End If
    Dim ChangeMade As Long
    For j = 0 To NumExcludedEventNum
        If NumExcludedEventNum > 0 Then
            NF3 = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Get #NF3, , ExcludedEventNum
            ReDim EventsInExcludeds(5, ExcludedEventNum)
            Get #NF3, , EventsInExcludeds
            Close #NF3
            'ExcludedEventNum = 1
            ChDrive oDirX
            ChDir oDirX
        End If
            
        ChangeMade = 0
        For x = 0 To UBound(EventsInExcludeds, 2)
            If EventsInExcludeds(1, x) = -ENumb Then
                If EventsInExcludeds(0, x) = 2 Then
                    EventsInExcludeds(0, x) = 3
                    ChangeMade = 1
                    Temp = MinorPar(ENumb, EventsInExcludeds(2, x))
                    MinorPar(ENumb, EventsInExcludeds(2, x)) = Daught(ENumb, EventsInExcludeds(2, x))
                    Daught(ENumb, EventsInExcludeds(2, x)) = Temp
                ElseIf EventsInExcludeds(0, x) = 3 Then
                    EventsInExcludeds(0, x) = 2
                    ChangeMade = 1
                    Temp = MinorPar(ENumb, EventsInExcludeds(2, x))
                    MinorPar(ENumb, EventsInExcludeds(2, x)) = Daught(ENumb, EventsInExcludeds(2, x))
                    Daught(ENumb, EventsInExcludeds(2, x)) = Temp
                End If
                'Daught(ENumb, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                'XX = OriginalName(EventsInExcludeds(2, x))
            End If
        Next x
        If ChangeMade = 1 And NumExcludedEventNum > 0 Then
            NF3 = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Put #NF3, 1, ExcludedEventNum
            Put #NF3, , EventsInExcludeds
            Close #NF3
            'ExcludedEventNum = 1
            ChDrive oDirX
            ChDir oDirX
        
        End If
    Next j
End If
        
Call MakeBestEvent

AXONo = BestEvent(ENumb, 1)
PressFlag = 0

If TSeq > UBound(CurrentXOver, 1) Then
    TSeq = BestEvent(ENumb, 0)
'    For x = 0 To PermNextno
'        For Y = 1 To CurrentXOver(x)
'            If TSeq = XoverList(x, Y).Daughter And SuperEventList(XoverList(x, Y).Eventnumber) = ENumb Then
'
'                TSeq = x
'                'RelY = Y
'            End If
'        Next Y
'    Next x
End If

For x = 1 To CurrentXOver(TSeq)
    If SuperEventList(XoverList(TSeq, x).Eventnumber) = ENumb Then
        If XoverList(TSeq, x).ProgramFlag = TProg Or XoverList(TSeq, x).ProgramFlag + AddNum = TProg Then
            If XoverList(TSeq, x).Beginning <> TBegin Then
                PressFlag = 1
            End If
            AXONo = x
            Exit For
        End If
    End If
Next x
'this might not be enough - it may be necessery to remake the whole of bestevent
'Call FindBestEvent(ENumb, Prg)

Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())

TarSeq = TSeq
AXONoY = -1
        'For X = 0 To NextNo
        '    If Daught(ENumb, X) > 0 And Daught(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    ElseIf MiR = 0 And MinorPar(ENumb, X) > 0 And MinorPar(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    ElseIf MaR = 0 And MajorPar(ENumb, X) > 0 And MajorPar(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    End If
        '    Form1.ProgressBar1 = (X / NextNo) * 100
        'Next X
        
Call IntegrateXOvers(0)
'modify daught, majorp and minorp
'Use NOPINI to determine which sequences should be Mi and Ma parents
       
SEPAVal = AXONo
        
If DSeq = RelX And OSEPAVal = RelY Then
    HighlightFlag = 0
                
    OSEPAVal = AXONo
    PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    DontPutForm2Ontop = 0
    If PressFlag = 1 Then
        MenuUpFlag = 0
        Call Picture6_MouseDown(1, 0, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    End If
    
    exRelX = RelX
    exRely = RelY
    Seq1 = XoverList(RelX, RelY).MajorP
    Seq2 = XoverList(RelX, RelY).MinorP
    Seq3 = XoverList(RelX, RelY).Daughter
    
    Call ModNextno
    If Form2.Visible = True Then
        For x = 0 To 3
            If TTFlag(x, 0) = 1 Then
                Y = 0
            ElseIf TTFlag(x, 1) = 1 Then
                Y = 1
            ElseIf TTFlag(x, 2) = 1 Then
                Y = 2
            ElseIf TTFlag(x, 3) = 1 Then
                Y = 3
            ElseIf TTFlag(x, 4) = 1 Then
                Y = 4
            End If
            ExtraDX = DoTreeColour(Form2.Picture2(x), Y, x)
        Next x
    End If
    
    Call UnModNextno
    
    RelX = TSeq
    RelY = AXONo
    If RelY = 0 Or RelX > PermNextno Then
        'this could be a problem - it means that the sequence labeled as the major parent doesn't have an entry in xoverlist
        'make an entry in xoverlist
        If RelX > UBound(XoverList, 1) Then
            For x = 0 To PermNextno
                For Y = 1 To CurrentXOver(x)
                    If RelX = XoverList(x, Y).Daughter And SuperEventList(XoverList(x, Y).Eventnumber) = ENumb Then
                        RelX = x
                        TSeq = x
                        RelY = Y
                    End If
                Next Y
            Next x
        End If
        
        If RelY = 0 Then
            CurrentXOver(RelX) = CurrentXOver(RelX) + 1
            
            XoverList(RelX, CurrentXOver(RelX)) = TempVals
            'xoverlist(relx,rely) =
            If XoverList(RelX, CurrentXOver(RelX)).MajorP = RelX Then
                'XX = XoverList(RelX, CurrentXOver(RelX)).Daughter
                XoverList(RelX, CurrentXOver(RelX)).Daughter = XoverList(RelX, CurrentXOver(RelX)).MajorP
                XoverList(RelX, CurrentXOver(RelX)).MajorP = XX
                Daught(ENumb, RelX) = 1
                
            ElseIf XoverList(RelX, CurrentXOver(RelX)).MinorP = RelX Then
                'XX = XoverList(RelX, CurrentXOver(RelX)).Daughter
                XoverList(RelX, CurrentXOver(RelX)).Daughter = XoverList(RelX, CurrentXOver(RelX)).MinorP
                XoverList(RelX, CurrentXOver(RelX)).MinorP = XX
                Daught(ENumb, RelX) = 1
            End If
            RelY = CurrentXOver(RelX)
        End If
    End If
    
    
    
    exRelX = RelX
    exRely = RelY
    Seq1 = XoverList(RelX, RelY).MajorP
    Seq2 = XoverList(RelX, RelY).MinorP
    Seq3 = XoverList(RelX, RelY).Daughter
    
    Call ModNextno
    
    If Form2.Visible = True Then
        Call UnModNextno
        For x = 0 To 3
            If TTFlag(x, 0) = 1 Then
                Y = 0
            ElseIf TTFlag(x, 1) = 1 Then
                Y = 1
            ElseIf TTFlag(x, 2) = 1 Then
                Y = 2
            ElseIf TTFlag(x, 3) = 1 Then
                Y = 3
            ElseIf TTFlag(x, 4) = 1 Then
                Y = 4
            End If
            ExtraDX = DoTreeColour(Form2.Picture2(x), Y, x)
        Next x
    End If
    Call UnModNextno
    If Form2.Visible = True Then
        Call UnModNextno
        For x = 0 To 3
            If x = 1 Then
                Call ModNextno
            Else
                If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                    Call UnModNextno
                End If
            End If
            Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
            x = x
        Next x
    End If
    RelX = TSeq
    RelY = AXONo
    exRelX = RelX
    exRely = RelY
    Timer1.Enabled = True
Else
    DontPutForm2Ontop = 1
    Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    DontPutForm2Ontop = 0
    If PressFlag = 1 Then
        MenuUpFlag = 0
        Call Picture6_MouseDown(1, 0, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
    End If
    RelX = TSeq
    RelY = AXONo
    exRelX = RelX
    exRely = RelY
    Timer1.Enabled = False
End If
            
If (RelX > 0 Or RelY > 0) And DontRedraw = 0 Then
    PermYVal = 0: PermXVal = 0
    Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
End If
        
If XoverList(RelX, RelY).Accept = 1 Then
    AcceptChangeFlag = 2
    Form1.Command10.Enabled = True
ElseIf AcceptChangeFlag = 0 Then
    AcceptChangeFlag = 1
End If
        
If RIMode = 1 Then
    Call MakeSummary
End If
        
If XOMiMaInFileFlag = 1 Then
     Screen.MousePointer = 11
     'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
     Form1.ProgressBar1.Value = 5
     Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
     Call UpdateF2Prog
     Form1.Refresh
     If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
     Form2.Refresh
     If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
     
     oDirX = CurDir
     ChDrive App.Path
     ChDir App.Path
     FF = FreeFile
     UBXOMi = UBound(BestXOListMi, 2)
     UBXoMa = UBound(BestXOListMa, 2)
     Open "RDP5BestXOListMi" + UFTag For Binary As #FF
     Put #FF, , BestXOListMi()
     Close #FF
     MiRec = MiRec - 1
     Form1.ProgressBar1.Value = 60
     Form1.SSPanel1.Caption = "Writing major parent lists to disk"
     Call UpdateF2Prog
     Form1.Refresh
     If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
     Form2.Refresh
     If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
     
     Open "RDP5BestXOListMa" + UFTag For Binary As #FF
     Put #FF, , BestXOListMa()
     Close #FF
    
     MaRec = MaRec - 1
     Form1.ProgressBar1.Value = 100
     Form1.Refresh
     If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
     Call UpdateF2Prog
    Form2.Refresh
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    
    ChDrive oDirX
    ChDir oDirX
    Erase BestXOListMi
    Erase BestXOListMa
    
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
End If
    

End Sub



Private Sub RecBPMnu_Click()

If ButtonScrollFlag = 0 And CurMatrixFlag = 4 Then DoneMatX(4) = 0
CurMatrixFlag = 4
Call DrawBPMatrix

CurMatrixFlag = 4
Form1.Check1.Enabled = False
Call DoMatCap
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If

Command39(0).Enabled = True
End Sub

Private Sub RecBPMnu2_Click()
Call RecBPMnu_Click
Form1.SSPanel6(2).Enabled = True
End Sub

Private Sub RecMatMnu_Click()
If ButtonScrollFlag = 0 And CurMatrixFlag = 1 Then DoneMatX(2) = 0
CurMatrixFlag = 1
 Call DrawRecMatrix(0)

CurMatrixFlag = 1
Form1.Check1.Enabled = False
Call DoMatCap
SSPanel6(2).Enabled = True
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If CurMatrixFlag < 255 Then
    If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
        Command39(1).Enabled = True
        Command39(0).Enabled = True
    End If
End If
End Sub

Private Sub RecMatMnu2_Click()
Call RecMatMnu_Click
Form1.SSPanel6(2).Enabled = True
End Sub

Private Sub RecMnu_Click(Index As Integer)
If Index = 0 Then
    QvRFlag = 0
    QvRFlagOverrideFlag = 1
    Call Command22_Click
ElseIf Index = 1 Then
    QvRFlag = 1
    QvRFlagOverrideFlag = 1
    QvRScanGoonFlag = 1
    If RefNum < 2 Then
        MsgBox ("Before you start a query vs reference scan you will need to select a set of (preferably non-recombinant) reference sequences")
        
        Call SelRefMnu_Click
        Sleep 200
        Do While Form5.Visible = True
            DoEvents
        Loop
    End If
    If RefNum = 1 Then
        QvRFlag = 0
        'RefNum = 0
        SelGrpFlag = 1
        
        For x = 0 To PermNextno
            If ReferenceList(x) > 0 Then
                GrpMaskSeq(x) = 1
            Else
                GrpMaskSeq(x) = 0
            End If
            
        Next x
        Call PrintNames
    End If
    
    If QvRScanGoonFlag = 0 Or RefNum = 0 Then
        QvRScanGoonFlag = 0
        
        Exit Sub
    Else
        QvRScanGoonFlag = 0
    End If
    Call Command22_Click
    QvRFlagOverrideFlag = 0
ElseIf Index = 2 Then
    If NextNo > 2 Then
        If DoneMatX(14) = 0 Then
            PhiTestPVal = 1
            Call CMMnu_Click(1)
            
        End If
        Dim PVS As String
        PVS = Trim(Str(PhiTestPVal))
        
        If PVS = "0" Or PhiTestPVal < 0.000001 Then
            PVS = "< 0.00001"
        ElseIf Left(PVS, 1) = "." Then
            PVS = "= 0" + PVS
        ElseIf Left(PVS, 1) = "1" And Len(PVS) = 1 Then
            PVS = "= 1.0"
        Else
            PVS = "= " + PVS
        
        End If
        If PhiTestPVal >= 0.99999999999 Then
            MsgBox ("The PHI-test was inconclusive. This can occur when there is either no evidence of recombination in an alignment, or when recombination has impacted patterns of nucleotide variation in the alignment to such a high degree that recombination cannot be differentiated from other evolutionary processes")
        ElseIf PhiTestPVal >= 0.1 Then
            MsgBox ("The PHI-test did not reveal any convincing evidence of recombination in this alignment (p-val " + PVS + ")")
        ElseIf PhiTestPVal >= 0.05 Then
            MsgBox ("The PHI-test revealed only marginal evidence of recombination in this alignment (p-val " + PVS + ")")
        ElseIf PhiTestPVal >= 0.01 Then
            MsgBox ("The PHI-test revealed some evidence of recombination in this alignment (p-val " + PVS + ")")
        ElseIf PhiTestPVal > 0.000001 Then
            MsgBox ("The PHI-test revealed good evidence of recombination in this alignment (p-val " + PVS + ")")
        Else
            MsgBox ("The PHI-test revealed very good evidence of recombination in this alignment (p-val " + PVS + ")")
        End If
    Else
        MsgBox ("The PHI-test can only be used to analyse alignments with four or more sequences")
    End If
ElseIf Index = 3 Then
    Call RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, 7, 1)
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
End If
End Sub

Private Sub RecRateMnu_Click()


    OManFlag = ManFlag
    Form5.Caption = "Select Sequences for Variable CLE Recombination Rate Scan"
    Form5.Label4.Caption = "Select four or more sequences"
    Form5.Label3.Caption = "Selected Sequences"
    Form5.Label1 = "Potential Recombinant Sequence"
    Form5.Label1.Visible = False

    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0

        For x = 0 To NextNo
            .AddItem OriginalName(x), x + 1
        Next 'X

        .ListIndex = OIndex
    End With

    Form5.Combo1.Visible = False
    Form5.Check1.Visible = False
    TManFlag = 20
    'ot1e = Form1.Timer1.Enabled
    'Form1.Timer1.Enabled = False
    ManPFlag = 0
    ManMinSeqNo = 4
    ManMaxSeqNo = NextNo + 1

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X

    

    
    
    
    
    If Form5.Combo1.ListIndex > 0 Then
        DontChangeAnything = 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        DontChangeAnything = 0
    Else
        DontChangeAnything = 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        DontChangeAnything = 0
    End If
    NoF3Check2 = 1
    Form5.Visible = True
    Form1.Enabled = False

'Call VarRecRates(GCFlag, GCTractLen, BlockPen, StartRho, MCMCUpdates, FreqCo, FreqCoMD)
End Sub

Private Sub RecRCMnu_Click()


If ButtonScrollFlag = 0 And CurMatrixFlag = 3 Then DoneMatX(3) = 0
CurMatrixFlag = 3
Call DrawRegionMatrix

CurMatrixFlag = 3
Form1.Check1.Enabled = True
        
   
Call DoMatCap
SSPanel6(2).Enabled = True
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If
Command39(0).Enabled = True
End Sub

Private Sub RecRCMnu2_Click()
Call RecRCMnu_Click
Form1.SSPanel6(2).Enabled = True
End Sub

Private Sub RejectMnu_Click()

If DontSaveUndo = 0 Then
    Call SaveUndo
End If
Form1.WindowState = Form1.WindowState
MenuUpFlag = 0
oxrelx = RelX
oxrely = RelY



    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
       Screen.MousePointer = 11
        Form1.ProgressBar1 = 2
        Form1.SSPanel1.Caption = "Loading minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        Form1.ProgressBar1 = 20
        Form1.SSPanel1.Caption = "Loading major parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
        Form1.ProgressBar1 = 40
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
    End If


If DebuggingFlag < 2 Then On Error Resume Next
XX = 0
XX = UBound(BCurrentXoverMa, 1)
If XX = 0 Then Exit Sub
On Error GoTo 0

    Dim NFD As Byte, NFMi As Byte, NFMa As Byte, TBegin As Long, DSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
    
    
    
    If x = x Then
        'OSEPAVal = SEPAVal
        DSeq = XoverList(SERecSeq, SEPAVal).Daughter
        TSeq = XoverList(SERecSeq, SEPAVal).Daughter
        TProg = XoverList(SERecSeq, SEPAVal).ProgramFlag
        
        'TBegin = XOverlist(SERecSeq, SEPAVal).Beginning
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
        ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
        
        
        AXONo = SERecSeq
        'XX = CurrentXover(3)
        
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
        
        Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())
        
        For TProg = 0 To AddNum * 2
            Call IndvrejectEvent(NFMi, DSeq, TProg, TraceNumbMi, TraceMi(), BestXOListMi())
            Call IndvrejectEvent(NFMa, DSeq, TProg, TraceNumbMa, TraceMa(), BestXOListMa())
            Call IndvrejectEvent(NFD, DSeq, TProg, TraceNumbD, TraceD(), XoverList())
        Next TProg
        
        If NFMa = 0 Then
            Ma = XoverList(SERecSeq, SEPAVal).MajorP
            Mi = XoverList(SERecSeq, SEPAVal).MinorP
            If Ma <= PermNextno Then
                BCurrentXoverMa(Ma) = BCurrentXoverMa(Ma) + 1
                UB = UBound(BestXOListMa, 2)
                If UB < BCurrentXoverMa(Ma) Then
                    UB = BCurrentXoverMa(Ma) + 10
                    UB2 = UBound(BestXOListMa, 1)
                    'Exit Sub
                    ReDim Preserve BestXOListMa(UB2, UB + 10)
                End If
                BestXOListMa(Ma, BCurrentXoverMa(Ma)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMa(Ma, BCurrentXoverMa(Ma)).Daughter = Ma
                
                If NOPINI(0, ENumb) = 2 Then
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MinorP = DSeq
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MajorP = Mi
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 2
                Else
                    If NOPINI(0, ENumb) = 0 Then
                        BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 0
                    Else
                        BestXOListMa(Ma, BCurrentXoverMa(Ma)).OutsideFlag = 2
                    End If
                    BestXOListMa(Ma, BCurrentXoverMa(Ma)).MajorP = DSeq
                End If
            Else
                BCurrentXoverMa(SERecSeq) = BCurrentXoverMa(SERecSeq) + 1
                UB = UBound(BestXOListMa, 2)
                If UB < BCurrentXoverMa(SERecSeq) Then
                    UB = BCurrentXoverMa(SERecSeq) + 10
                    UB2 = UBound(BestXOListMa, 1)
                    ReDim Preserve BestXOListMa(UB2, UB + 10)
                End If
                BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 2 Then
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MinorP = DSeq
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MajorP = Mi
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 2
                Else
                    If NOPINI(0, ENumb) = 0 Then
                        BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 0
                    Else
                        BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).OutsideFlag = 2
                    End If
                    BestXOListMa(SERecSeq, BCurrentXoverMa(SERecSeq)).MajorP = DSeq
                End If
            End If
            
            
        End If
        
        If NFMi = 0 Then
            Ma = XoverList(SERecSeq, SEPAVal).MajorP
            Mi = XoverList(SERecSeq, SEPAVal).MinorP
            If Mi <= PermNextno Then
                BCurrentXoverMi(Mi) = BCurrentXoverMi(Mi) + 1
                UB = UBound(BestXOListMi, 2)
                If UB < BCurrentXoverMi(Mi) Then
                    UB = BCurrentXoverMi(Mi) + 10
                    UB2 = UBound(BestXOListMi, 1)
                    ReDim Preserve BestXOListMi(UB2, UB)
                End If
                BestXOListMi(Mi, BCurrentXoverMi(Mi)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMi(Mi, BCurrentXoverMi(Mi)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 0 Then
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MinorP = Ma
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MajorP = DSeq
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 1
                Else
                    If NOPINI(0, ENumb) = 1 Then
                        BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 1
                    Else
                        BestXOListMi(Mi, BCurrentXoverMi(Mi)).OutsideFlag = 0
                    End If
                    BestXOListMi(Mi, BCurrentXoverMi(Mi)).MinorP = DSeq
                End If
            Else
                BCurrentXoverMi(SERecSeq) = BCurrentXoverMi(SERecSeq) + 1
                UB = UBound(BestXOListMi, 2)
                If UB < BCurrentXoverMi(SERecSeq) Then
                    UB = BCurrentXoverMi(SERecSeq) + 10
                    UB2 = UBound(BestXOListMi, 1)
                    ReDim Preserve BestXOListMi(UB2, UB + 10)
                End If
                BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)) = XoverList(SERecSeq, SEPAVal)
                BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).Daughter = Mi
                
                If NOPINI(0, ENumb) = 0 Then
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MinorP = Ma
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MajorP = DSeq
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 1
                Else
                    If NOPINI(0, ENumb) = 1 Then
                        BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 1
                    Else
                        BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).OutsideFlag = 0
                    End If
                    BestXOListMi(SERecSeq, BCurrentXoverMi(SERecSeq)).MinorP = DSeq
                End If
            End If
            
        End If
        '*****************Need to rearrange NOPINI***********************
       ' For X = 0 To 2
       '     If NOPINI(X, Enumb) = 1 Then
       '         NOPINI(X, Enumb) = 2
       '     ElseIf NOPINI(X, Enumb) = 2 Then
       '         NOPINI(X, Enumb) = 1
       '     End If
       ' Next X
        AXONo = SEPAVal
        RecSeq = DSeq
        TarSeq = SERecSeq
        
        'Call UpdateScheme
        Call UpdateEvents(ENumb)
        If ItsFinished = 0 Then
            Call IntegrateXOvers(0)
        End If
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        SSPanel6(2).Visible = False
        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        'modify daught, majorp and minorp
        'Use NOPINI to determine which sequences should be Mi and Ma parents
        'Exit Sub
        SEPAVal = AXONo
    
        'Call UpdateConfirm(ActiveSeq)
        'Call UpdateConfirm(ActiveMinorP)
        'If ItsFinished = 0 Then
        If DontSaveUndo = 0 Then
            If DSeq = RelX And OSEPAVal = RelY And (RelX > 0 Or RelY > 0) Then
                HighlightFlag = 0
                
                OSEPAVal = AXONo
                PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
                DontPutForm2Ontop = 1
                Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                DontPutForm2Ontop = 0
                RelX = TSeq
                RelY = AXONo
                exRelX = RelX
                exRely = RelY
                Timer1.Enabled = True
            Else
        
                PermXVal = 0
                PermYVal = 0
                If oxrelx > 0 Or oxrely > 0 Then
                    Call GoToThis(0, RelX, RelY, PermXVal, PermYVal)
                Else
                
                    RelX = 0: RelY = 0
                End If
            End If
        'End If
        End If
        
        DoneTree(0, 3) = 0
        DoneTree(1, 3) = 0
        DoneTree(2, 3) = 0
        DoneTree(3, 3) = 0
        DoneTree(4, 3) = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        Form2.SSPanel1(2).ZOrder
        On Error GoTo 0
        If ItsFinished = 0 Then
            If Form2.Visible = True Then
                Call UnModNextno
                    
                For x = 0 To 3
                    If x = 1 Then
                        Call ModNextno
                    Else
                        If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                            Call UnModNextno
                        End If
                    End If
                    Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
                    x = x
                Next x
            End If
        End If
        If XOMiMaInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            Form1.ProgressBar1 = 60
            Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            UBXOMi = UBound(BestXOListMi, 2)
            UBXoMa = UBound(BestXOListMa, 2)
            
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Put #FF, , BestXOListMi()
            Close #FF
            MiRec = MiRec - 1
            
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Form1.ProgressBar1 = 80
            Call UpdateF2Prog
            Form1.SSPanel1.Caption = "Writing major parent lists to disk"
            Form1.Refresh: Form2.Refresh
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Put #FF, , BestXOListMa()
            Close #FF
            MaRec = MaRec - 1
            ChDrive oDirX
            ChDir oDirX
            Erase BestXOListMi
            Erase BestXOListMa
            Form1.ProgressBar1 = 100
            
            Form1.SSPanel1.Caption = ""
            
            Form1.ProgressBar1 = 0
            Form1.Refresh: Form2.Refresh
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Screen.MousePointer = 0
        End If
        
        If RIMode = 1 Then
            Call MakeSummary
            x = x
        End If
        Exit Sub
        
       ' Exit Sub
        
    End If
    If ItsFinished = 0 Then
        If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    End If
    
    
    If ItsFinished = 0 Then
        If Form2.Visible = True Then
            Call UnModNextno
                
            For x = 0 To 3
                If x = 1 Then
                    Call ModNextno
                Else
                    If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                        Call UnModNextno
                    End If
                End If
                Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
                x = x
            Next x
        End If
    End If
    'Exit Sub
    DoneMatX(1) = 0
    DoneMatX(2) = 0
    DoneMatX(3) = 0
    DoneMatX(4) = 0
    SSPanel6(2).Visible = False
    SSPanel6(0).Visible = True
    SSPanel6(1).Visible = False
    If RIMode = 1 Then
        Call MakeSummary
        x = x
    End If
    
    If XOMiMaInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        Form1.ProgressBar1 = 60
        Form1.SSPanel1.Caption = "Writing minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        UBXOMi = UBound(BestXOListMi, 2)
        UBXoMa = UBound(BestXOListMa, 2)
        
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
        MiRec = MiRec - 1
        Form1.SSPanel1.Caption = "Writing major parent lists from disk"
        Form1.Refresh: Form2.Refresh
        
        Form1.ProgressBar1 = 80
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
        MaRec = MaRec - 1
        ChDrive oDirX
        ChDir oDirX
        Erase BestXOListMi
        Erase BestXOListMa
        Form1.ProgressBar1 = 100
        
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        Screen.MousePointer = 0
    End If
    
    
End Sub

Private Sub RejectSMnu_Click()
If DontSaveUndo = 0 Then
    Form1.SSPanel1.Caption = "Accepting evidence of recombination"
    Form1.ProgressBar1 = 2
    Call UpdateF2Prog
    Call SaveUndo
End If
Form1.WindowState = Form1.WindowState
MenuUpFlag = 0
oxrelx = RelX '21,2
oxrely = RelY



    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
       Screen.MousePointer = 11
        Form1.ProgressBar1 = 2
        Form1.SSPanel1.Caption = "Loading minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Get #FF, , BestXOListMi()
        Close #FF
        Form1.ProgressBar1 = 20
        Form1.SSPanel1.Caption = "Loading major parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
        Form1.ProgressBar1 = 40
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
    End If

Dim TBegin As Long, DSeq As Long, TSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
    
        'OSEPAVal = SEPAVal
        'DSeq = XOverList(SERecSeq, SEPAVal).Daughter
        'TSeq = XOverlist(SERecSeq, SEPAVal).Daughter
        'TProg = XOverlist(SERecSeq, SEPAVal).ProgramFlag
        'TBegin = XOverlist(SERecSeq, SEPAVal).Beginning
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
        ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
        AXONo = SERecSeq
        'XX = CurrentXover(3)
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
        
        Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())
        
        
        Call GroupRejectEvent(TraceNumbD, TraceD(), XoverList())
        Call GroupRejectEvent(TraceNumbMi, TraceMi(), BestXOListMi())
        Call GroupRejectEvent(TraceNumbMa, TraceMa(), BestXOListMa())
        
        
        '*****************Need to rearrange NOPINI***********************
       ' For X = 0 To 2
       '     If NOPINI(X, Enumb) = 1 Then
       '         NOPINI(X, Enumb) = 2
       '     ElseIf NOPINI(X, Enumb) = 2 Then
       '         NOPINI(X, Enumb) = 1
       '     End If
       ' Next X
        
        TarSeq = SERecSeq
        AXONoY = -1
        'For X = 0 To NextNo
        '    If Daught(ENumb, X) > 0 And Daught(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    End If
        '    Form1.ProgressBar1 = (X / NextNo) * 100
        'Next X
        Call IntegrateXOvers(0)
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        SSPanel6(2).Visible = False
        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        
        
        'modify daught, majorp and minorp
        'Use NOPINI to determine which sequences should be Mi and Ma parents
    
        SEPAVal = AXONo
    
        'Call UpdateConfirm(ActiveSeq)
        'Call UpdateConfirm(ActiveMinorP)
        
        If DSeq = RelX And OSEPAVal = RelY And (RelX > 0 Or RelY > 0) Then
            HighlightFlag = 0
            
            OSEPAVal = AXONo
            PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            RelX = TSeq
            RelY = AXONo
            exRelX = RelX
            exRely = RelY
            Timer1.Enabled = True
        Else
    
            'Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value)
            PermXVal = 0
            PermYVal = 0
            If oxrelx > 0 Or oxrely > 0 Then
                Call GoToThis(0, RelX, RelY, PermXVal, PermYVal)
            Else
            
                RelX = 0: RelY = 0
            End If
            Timer1.Enabled = True
        End If
         If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
        DoneTree(0, 3) = 0

        DoneTree(1, 3) = 0
        DoneTree(2, 3) = 0
        DoneTree(3, 3) = 0
        DoneTree(4, 3) = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        Form2.SSPanel1(2).ZOrder
        On Error GoTo 0
        If Form2.Visible = True Then
        Call UnModNextno
            
        For x = 0 To 3
            If x = 1 Then
                Call ModNextno
            Else
                If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                    Call UnModNextno
                End If
            End If
            Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
            x = x
        Next x
    End If
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        SSPanel6(2).Visible = False
        SSPanel6(0).Visible = True
        SSPanel6(1).Visible = False
        If RIMode = 1 Then
            Call MakeSummary
            x = x
        End If
        If XOMiMaInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Form1.ProgressBar1 = 60
            Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            UBXOMi = UBound(BestXOListMi, 2)
            UBXoMa = UBound(BestXOListMa, 2)
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Put #FF, , BestXOListMi()
            Close #FF
            
            Form1.SSPanel1.Caption = "Writing major parent lists to disk"
            Form1.ProgressBar1 = 80
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Put #FF, , BestXOListMa()
            Close #FF
            MaRec = MaRec - 1
            
            ChDrive oDirX
            ChDir oDirX
            Erase BestXOListMi
            Erase BestXOListMa
            
            Form1.ProgressBar1 = 100
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1 = 0
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Screen.MousePointer = 0
        End If
    
End Sub

Private Sub RMinDMnu_Click()
DontDoKey = 0
'If ButtonScrollFlag = 0 And CurMatrixFlag = 7 Then DoneMatX(7) = 0
CurMatrixFlag = 7
Call RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, 7, 0)

Form1.Check1.Enabled = False

Call DoMatCap
If F1MDF = 0 Then
    SSPanel6(2).Visible = True
    SSPanel6(0).Visible = False
    SSPanel6(1).Visible = False
End If
If CurMatrixFlag <= UBound(MatZoom, 1) Then
    If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
        Command39(1).Enabled = True
    End If
End If

Command39(0).Enabled = True
End Sub

Private Sub RFMatrixMnu_Click()
If NextNo >= 3 Then
    'Call SHMatrix
    If ButtonScrollFlag = 0 And CurMatrixFlag = 13 Then DoneMatX(13) = 0
    CurMatrixFlag = 13
    Call RFMatrix
    CurMatrixFlag = 13
    Form1.Check1.Enabled = False
    Call DoMatCap
    SSPanel6(2).Enabled = True
    SSPanel6(2).Enabled = True
    If F1MDF = 0 Then
        SSPanel6(2).Visible = True
        SSPanel6(0).Visible = False
        SSPanel6(1).Visible = False
    End If
    If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
        Command39(1).Enabled = True
    End If
    Command39(0).Enabled = True
End If
End Sub

Private Sub RminDMnu2_Click()
Call RMinDMnu_Click
End Sub

Private Sub RMinMnu_Click()
DontDoKey = 0
'If ButtonScrollFlag = 0 And CurMatrixFlag = 6 Then DoneMatX(6) = 0
CurMatrixFlag = 6
Call RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, 6, 0)

Form1.Check1.Enabled = False
Call DoMatCap
If F1MDF = 0 Then
            SSPanel6(2).Visible = True
            SSPanel6(0).Visible = False
            SSPanel6(1).Visible = False
        End If
If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
    Command39(1).Enabled = True
End If

Command39(0).Enabled = True
End Sub

Private Sub RMinMnu2_Click()
Call RMinMnu_Click
End Sub

Private Sub RSortMnu_Click()
If DontSaveUndo = 0 Then
    Call SaveUndo
End If
Dim TDStore() As Long, TBStore() As Long, TL(2) As Long, TB As Long
'ReDim TreeDraw(3, 3, 1, 3, (NextNo + 2) * 4), TDLen(3, 3, 1), TreeBlocks(3, 3, 4, (NextNo + 2)), TBLen(3, 3), treeblocksl(Tnum,ttype,4, 20)
CurrentlyRunningFlag = 1
 
 If PermNextno <> NextNo Then
    Call UnModNextno
End If
 ShowSeqFlag = 0
 
 XX = NextNo
 
Form1.Command10.BackColor = Form1.Command5.BackColor
Form1.Command9.Enabled = False
Form1.Command6(2).Enabled = False
Form1.Command5.Enabled = False
Form1.Command10.Enabled = False
Form1.Command29(0).Enabled = False
Form1.Command29(1).Enabled = False
Form1.SSPanel6(0).Enabled = False
Form1.SSPanel6(1).Enabled = False
Form1.SSPanel6(2).Enabled = False
Form1.SSPanel4.Enabled = False
Form1.SSPanel3.Enabled = False

Call HScroll1_Change
If ColDistInFile = 1 Then
    
    ReDim ColDist2(0)
    Timer7(1).Enabled = False
End If
Command6(0).Enabled = False
Call PrintNames
ReDim TDStore(1, 3, (NextNo + 2) * 2), TBStore(4, (NextNo + 2))


TL(0) = TDLen(0, 0, 0)
TL(1) = TDLen(0, 0, 1)
TL(2) = TDLen(0, 0, 2)
TB = TBLen(0, 0)
For Z = 0 To 1
    For Y = 0 To 3
        For x = 0 To (NextNo + 2) * 2
            
            TDStore(Z, Y, x) = TreeDraw(0, 0, Z, Y, x)
        
        Next x
    Next Y
Next Z
For Z = 0 To 4
    For Y = 0 To NextNo + 2
        
        TBStore(Z, Y) = TreeBlocks(0, 0, Z, Y)
        
    Next Y
Next Z

RelX = 0
RelY = 0
DoEvents 'covered by currentlyrunningflag
MenuUpFlag = 0
Picture5.Enabled = False
Timer1.Enabled = False
Picture6.Refresh
ReDim MissingData(Len(StrainSeq(0)), NextNo), TreeTrace(NextNo)
If ReassortmentFlag = 1 Then
    Dim tBP As Long
    If UBound(RBPPos, 1) < RBPNum Then
        ReDim Preserve RBPPos(RBPNum)
    End If
    For x = 0 To RBPNum
        tBP = RBPPos(x)
        For Y = 0 To NextNo
            MissingData(tBP, Y) = 1
        Next Y
    Next x
End If
DoneTree(0, 3) = 0
DoneTree(1, 3) = 0
Call DoRDP(0, 0)


TDLen(0, 0, 0) = TL(0)
TDLen(0, 0, 1) = TL(1)
TDLen(0, 0, 2) = TL(2)
TBLen(0, 0) = TB
For Z = 0 To 1
    For Y = 0 To 3
        For x = 0 To (NextNo + 2) * 2
            
            TreeDraw(0, 0, Z, Y, x) = TDStore(Z, Y, x)
        
        Next x
    Next Y
Next Z
For Z = 0 To 4
    For Y = 0 To NextNo + 2
        If UBound(TreeBlocks, 4) < Y Then
            ReDim Preserve TreeBlocks(3, 4, 5, Y + 10)
        End If
        TreeBlocks(0, 0, Z, Y) = TBStore(Z, Y)
        
    Next Y
Next Z

For x = 0 To AddNum - 1
    If ProgF(x) > 0 Then ProgF(x + AddNum) = 1
Next x

Call IntegrateXOvers(1)
Screen.MousePointer = 0
SSPanel1.Caption = ""
Timer1.Enabled = False
Picture5.Enabled = True
If Form1.Picture6.Enabled = True Then
    Form1.Picture6.SetFocus
End If
ProgressBar1 = 0

AcceptChangeFlag = 0

Form1.Command9.Enabled = True
Form1.Command6(2).Enabled = True
Form1.Command5.Enabled = True

Form1.SSPanel6(0).Enabled = True
Form1.SSPanel6(1).Enabled = True
Form1.SSPanel6(2).Enabled = True
Form1.SSPanel4.Enabled = True
Form1.SSPanel3.Enabled = True



CurrentlyRunningFlag = 0
OV = SkipAcceptedMnu.Checked
SkipAcceptedMnu.Checked = True
CurrentlyRunningFlag = 0
Call Command9_Click
SkipAcceptedMnu.Checked = OV
If RIMode = 1 Then
Call MakeSummary
End If
'Call GoToBestMnu_Click

End Sub

Private Sub RSortMnu2_Click()
If Form1.RSortMnu2.Caption <> "Re-identify recombinant sequences for all unaccepted events" Then
    
    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        Screen.MousePointer = 11
        Form1.ProgressBar1 = 2
        Form1.SSPanel1.Caption = "Loading minor parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        Form1.ProgressBar1 = 20
        Form1.SSPanel1.Caption = "Loading major parent lists from disk"
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
        Form1.ProgressBar1 = 40
        Call UpdateF2Prog
        Form1.Refresh: Form2.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
        
        
    End If
    If AcceptAllMnuFlag = 1 Then
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).Accept = 2 Then
                    XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNum
                End If
                XoverList(x, Y).Accept = 1
            Next Y
            For Y = 1 To BCurrentXoverMi(x)
                If BestXOListMi(x, Y).Accept = 2 Then
                    BestXOListMi(x, Y).ProgramFlag = BestXOListMi(x, Y).ProgramFlag - AddNum
                End If
                BestXOListMi(x, Y).Accept = 1
            Next Y
            For Y = 1 To BCurrentXoverMa(x)
                If BestXOListMa(x, Y).Accept = 2 Then
                    BestXOListMa(x, Y).ProgramFlag = BestXOListMa(x, Y).ProgramFlag - AddNum
                End If
                BestXOListMa(x, Y).Accept = 1
            Next Y
        Next x
    ElseIf AcceptAllMnuFlag = 2 Then
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).Accept = 2 Then
                    XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNum
                End If
                XoverList(x, Y).Accept = 0
            Next Y
            For Y = 1 To BCurrentXoverMi(x)
                If BestXOListMi(x, Y).Accept = 2 Then
                    BestXOListMi(x, Y).ProgramFlag = BestXOListMi(x, Y).ProgramFlag - AddNum
                End If
                BestXOListMi(x, Y).Accept = 0
            Next Y
            For Y = 1 To BCurrentXoverMa(x)
                If BestXOListMa(x, Y).Accept = 2 Then
                    BestXOListMa(x, Y).ProgramFlag = BestXOListMa(x, Y).ProgramFlag - AddNum
                End If
                BestXOListMa(x, Y).Accept = 0
            Next Y
    
        Next x
    End If
    If DontSaveUndo = 0 Then
        If DSeq = RelX And OSEPAVal = RelY And (RelX > 0 Or RelY > 0) Then
            HighlightFlag = 0
            
            OSEPAVal = AXONo
            PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            RelX = TSeq
            RelY = AXONo
            exRelX = RelX
            exRely = RelY
            Timer1.Enabled = True
        Else
    
            PermXVal = 0
            PermYVal = 0
            If oxrelx > 0 Or oxrely > 0 Then
                Call GoToThis(0, RelX, RelY, PermXVal, PermYVal)
            Else
            
                RelX = 0: RelY = 0
            End If
        End If
    End If
    
    If ItsFinished = 0 Then
        Call IntegrateXOvers(0)
    End If
    
    If RIMode = 1 Then
        Call MakeSummary
    End If
    
    If ItsFinished = 0 Then
            If Form2.Visible = True Then
            
                Call UnModNextno
                    
                For x = 0 To 3
                    If x = 1 Then
                        Call ModNextno
                    Else
                        If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                            Call UnModNextno
                        End If
                    End If
                    Call DoTreeColour(Form2.Picture2(0), CurTree(x), x)
                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
                    x = x
                Next x
            End If
        End If
        If XOMiMaInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            Form1.ProgressBar1 = 60
            Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
            Call UpdateF2Prog
            Form1.Refresh: Form2.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            UBXOMi = UBound(BestXOListMi, 2)
            UBXoMa = UBound(BestXOListMa, 2)
            
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Put #FF, , BestXOListMi()
            Close #FF
            MiRec = MiRec - 1
            
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Form1.ProgressBar1 = 80
            Call UpdateF2Prog
            Form1.SSPanel1.Caption = "Writing major parent lists to disk"
            Form1.Refresh: Form2.Refresh
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Put #FF, , BestXOListMa()
            Close #FF
            MaRec = MaRec - 1
            ChDrive oDirX
            ChDir oDirX
            Erase BestXOListMi
            Erase BestXOListMa
            Form1.ProgressBar1 = 100
            
            Form1.SSPanel1.Caption = ""
            
            Form1.ProgressBar1 = 0
            Form1.Refresh: Form2.Refresh
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
            Screen.MousePointer = 0
        End If
        If AcceptAllMnuFlag = 1 Then
            AcceptAllMnuFlag = 2
        Else
            AcceptAllMnuFlag = 1
        End If

Else
    Form1.SSPanel1.Caption = "Preparing to rescan"
    Call UpdateF2Prog
    Screen.MousePointer = 11
    
    If DontSaveUndo = 0 Then
        Call SaveUndo
    End If
    
    If PermNextno <> NextNo Then
        Call UnModNextno
    End If
    RelX = 0
    RelY = 0
    DoEvents 'covered by currentlyrunningflag
    Form1.WindowState = Form1.WindowState
    MenuUpFlag = 0
    Picture5.Enabled = False
    Timer1.Enabled = False
    
    Dim TDStore() As Long, TBStore() As Long, TL(2) As Long, TB As Long
    'ReDim TreeDraw(3, 3, 1, 3, (NextNo + 2) * 4), TDLen(3, 3, 1), TreeBlocks(3, 3, 4, (NextNo + 2)), TBLen(3, 3), treeblocksl(Tnum,ttype,4, 20)
        
    ReDim TDStore(1, 3, (NextNo + 2) * 2), TBStore(4, (NextNo + 2))
    
    
    Form1.Command10.BackColor = Form1.Command5.BackColor
    Form1.Command9.Enabled = False
    Form1.Command6(2).Enabled = False
    Form1.Command5.Enabled = False
    Form1.Command10.Enabled = False
    Form1.Command29(0).Enabled = False
    Form1.Command29(1).Enabled = False
    Form1.SSPanel6(0).Enabled = False
    Form1.SSPanel6(1).Enabled = False
    Form1.SSPanel6(2).Enabled = False
    Form1.SSPanel4.Enabled = False
    Form1.SSPanel3.Enabled = False
    
    ShowSeqFlag = 0
    LastBottom = -1: LastTop = -1
    Call HScroll1_Change
    CurrentlyRunningFlag = 1
    
    If ColDistInFile = 1 Then
        
        ReDim ColDist2(0)
        Timer7(1).Enabled = False
    End If
    Command6(0).Enabled = False
    Call PrintNames
    TL(0) = TDLen(0, 0, 0)
    TL(1) = TDLen(0, 0, 1)
    TL(2) = TDLen(0, 0, 2)
    TB = TBLen(0, 0)
    For Z = 0 To 1
        For Y = 0 To 3
            For x = 0 To (NextNo + 2) * 2
                
                TDStore(Z, Y, x) = TreeDraw(0, 0, Z, Y, x)
            
            Next x
        Next Y
    Next Z
    For Z = 0 To 4
        For Y = 0 To NextNo + 2
            If UBound(TreeBlocks, 4) < Y Then
                ReDim Preserve TreeBlocks(3, 4, 5, Y + 10)
            End If
            TBStore(Z, Y) = TreeBlocks(0, 0, Z, Y)
            
        Next Y
    Next Z
    
    
    ReDim MissingData(Len(StrainSeq(0)), NextNo), TreeTrace(NextNo)
    If ReassortmentFlag = 1 Then
        Dim tBP As Long
        If UBound(RBPPos, 1) < RBPNum Then
            ReDim Preserve RBPPos(RBPNum)
        End If
        For x = 0 To RBPNum
            tBP = RBPPos(x)
            For Y = 0 To NextNo
                MissingData(tBP, Y) = 1
            Next Y
        Next x
    End If
    DoneTree(0, 3) = 0
    DoneTree(1, 3) = 0
    Call DoRDP(0, 0)
    'XX = SeqCol(3) ''3445930
    For x = 0 To AddNum - 1
        If ProgF(x) > 0 Then ProgF(x + AddNum) = 1
    Next x
    
    TDLen(0, 0, 0) = TL(0)
    TDLen(0, 0, 1) = TL(1)
    TDLen(0, 0, 2) = TL(2)
    TBLen(0, 0) = TB
    For Z = 0 To 1
        For Y = 0 To 3
            For x = 0 To (NextNo + 2) * 2
                
                TreeDraw(0, 0, Z, Y, x) = TDStore(Z, Y, x)
            
            Next x
        Next Y
    Next Z
    For Z = 0 To 4
        For Y = 0 To NextNo + 2
            If UBound(TreeBlocks, 4) < Y Then
                ReDim Preserve TreeBlocks(3, 4, 5, Y + 10)
            End If
            TreeBlocks(0, 0, Z, Y) = TBStore(Z, Y)
            
        Next Y
    Next Z
    
    For x = 0 To AddNum - 1
        If ProgF(x) > 0 Then ProgF(x + AddNum) = 1
    Next x
    
    Call IntegrateXOvers(1)
    Screen.MousePointer = 0
    
    Picture5.Enabled = True
    If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    
    
    ProgressBar1 = 0
    SSPanel1.Caption = ""
    Call UpdateF2Prog
    AcceptChangeFlag = 0
    
    Form1.Command9.Enabled = True
    Form1.Command6(2).Enabled = True
    Form1.Command5.Enabled = True
    
    
    
    Form1.SSPanel6(0).Enabled = True
    Form1.SSPanel6(1).Enabled = True
    Form1.SSPanel6(2).Enabled = True
    Form1.SSPanel4.Enabled = True
    Form1.SSPanel3.Enabled = True
    OV = SkipAcceptedMnu.Checked
    SkipAcceptedMnu.Checked = True
    CurrentlyRunningFlag = 0
    Call Command9_Click
    SkipAcceptedMnu.Checked = OV
    CurrentlyRunningFlag = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    
    'Call GoToBestMnu_Click
    x = x
    'For X = 0 To 3
    '    If X = 0 Then
    '        Call DoTreeColour(Form2.Picture2(0), CurTree(X), X)
    '        Call treedrawing(0,0,TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(X).Value, X, CurTree(X), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(X))
    '
    '    Else
    '        ModNextno
    '        Call DoTreeColour(Form2.Picture2(0), CurTree(X), X)
    '        Call treedrawing(0,0,TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(X).Value, X, CurTree(X), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(X))
    '        UnModNextno
    '        X = X
    '    End If
    'Next
    On Error GoTo 0
    
    If RIMode = 1 Then
        Call MakeSummary
    End If
End If
End Sub

Private Sub SAASeqMnu_Click()

    Call SaveAASeqs
    
    Exit Sub
    Dim tSeqS() As Byte, ST As Long, EN As Long, x As Long, ORI As Byte
    ReDim tSeqS(2, Len(StrainSeq(0)))
    
    ST = GeneList(CurGenes).StartInAlign
    EN = GeneList(CurGenes).EndInAlign
    ORI = GeneList(CurGenes).Orientation
    If ORI = 1 Then '+orientation
        If EN > ST Then
            'make sequences
            For x = ST To EN
                'If SeqNum(X, Seq1) <> 46 Then tSeqs(0, X) = cLOW(SeqNum(X, Seq1))
                
            Next x
        Else
            'ie it overlaps the end of the sequence
        
        End If
    ElseIf ORI = 2 Then 'minus orientation
    
    
    
    End If
End Sub

Private Sub SaveAncSeq_Click()
Dim FF As Long, MaxP(1), WinNuc(1), NucTrans(4) As String, TString As String
NucTrans(1) = "A"
NucTrans(2) = "C"
NucTrans(3) = "G"
NucTrans(4) = "T"

    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".csv"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "Comma separated value file (*.csv)|*.csv"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "open file" action is required.
        sbmpname$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SBMPnameII = .FileTitle
    End With
   
   
   Dim ConsensusSeq As String, ConsensusSeqN As String, TestChar() As Single, HighP As Single, WinP As Long, WinP2 As Long
   ConsensusSeq = MLAncSeq
   ConsensusSeqN = MLAncSeq
   If SumAncSeq <> "" Then
        For x = 1 To Len(StrainSeq(0))
            If Mid(MLAncSeq, x, 1) <> Mid(SumAncSeq, x, 1) Or AncPValsBayes(0, x) < 0.9 Then
                If Mid(SumAncSeq, x, 1) = Mid(ParsAncSeq, x, 1) And AncPValsBayes(0, x) >= 0.9 Then
                    Mid(ConsensusSeq, x, 1) = Mid(SumAncSeq, x, 1)
                    Mid(ConsensusSeqN, x, 1) = Mid(MLAncSeq, x, 1)
                Else
                    ReDim TestChar(3, 4)
                    HighP = 0
                    For Y = 1 To 4
                        TestChar(0, Y) = PAncPVals(Y, x)
                        TestChar(1, Y) = AncPValsML(Y, x)
                        TestChar(2, Y) = AncPValsBayes(Y, x)
                        TestChar(3, Y) = (TestChar(0, Y) + TestChar(1, Y) + TestChar(2, Y)) / 3
                        If HighP < TestChar(3, Y) Then
                            HighP = TestChar(3, Y)
                            WinP = Y
                        End If
                    Next Y
                    Mid(ConsensusSeq, x, 1) = NucTrans(WinP)
                    HighP = 0
                    ReDim TestChar(3, 4)
                    For Y = 1 To 4
                        If Y <> WinP Then
                            TestChar(0, Y) = PAncPVals(Y, x)
                            TestChar(1, Y) = AncPValsML(Y, x)
                            TestChar(2, Y) = AncPValsBayes(Y, x)
                            TestChar(3, Y) = (TestChar(0, Y) + TestChar(1, Y) + TestChar(2, Y)) / 3
                            If HighP < TestChar(3, Y) Then
                                HighP = TestChar(3, Y)
                                WinP2 = Y
                            End If
                        End If
                    Next Y
                    Mid(ConsensusSeqN, x, 1) = NucTrans(WinP2)
                End If
            End If
        Next x
   Else
        For x = 1 To Len(StrainSeq(0))
                If Mid(MLAncSeq, x, 1) <> Mid(ParsAncSeq, x, 1) Or AncPValsML(0, x) < 0.95 Then
                    
                        ReDim TestChar(3, 4)
                        HighP = 0
                        For Y = 1 To 4
                            TestChar(0, Y) = PAncPVals(Y, x)
                            TestChar(1, Y) = AncPValsML(Y, x)
                            TestChar(3, Y) = (TestChar(0, Y) + TestChar(1, Y)) / 2
                            If HighP < TestChar(3, Y) Then
                                HighP = TestChar(3, Y)
                                WinP = Y
                            End If
                        Next Y
                        Mid(ConsensusSeq, x, 1) = NucTrans(WinP)
                        HighP = 0
                        ReDim TestChar(3, 4)
                        For Y = 1 To 4
                            If Y <> WinP Then
                                TestChar(0, Y) = PAncPVals(Y, x)
                                TestChar(1, Y) = AncPValsML(Y, x)
                                
                                TestChar(3, Y) = (TestChar(0, Y) + TestChar(1, Y)) / 2
                                If HighP < TestChar(3, Y) Then
                                    HighP = TestChar(3, Y)
                                    WinP2 = Y
                                End If
                            End If
                        Next Y
                        Mid(ConsensusSeqN, x, 1) = NucTrans(WinP2)
                    
                End If
        Next x
   End If
   
   Open sbmpname$ For Output As #1
   
   
   
   
   Print #1, ">Consensus"
   Print #1, ConsensusSeq
   Print #1, ">Max Parsimony"
   Print #1, ParsAncSeq
   Print #1, ">Max Likelihood"
   Print #1, MLAncSeq
   If SumAncSeq <> "" Then
        Print #1, ">Bayesian"
        Print #1, MLAncSeq
   End If
   Print #1, ""
   Print #1, "Lowest Confidence Sites"
   Dim TS As String
   If SumAncSeq <> "" Then
        Print #1, ",,,Bayesian Probs,,,,,Likelihood Probs,,,,,Parsimony Probs"
        Print #1, "Site Position, ,A,C,G,T,,A,C,G,T,,A,C,G,T,,Best guess,Next best guess"
        For x = 1 To Len(StrainSeq(0))
            If (Mid(MLAncSeq, x, 1) <> Mid(SumAncSeq, x, 1) Or AncPValsBayes(0, x) < 0.9) And Mid(SumAncSeq, x, 1) <> "-" Then
                TS = Trim(Str(x)) + ",,"
                For Y = 1 To 4
                    TS = TS + Trim(Str(AncPValsBayes(Y, x))) + ","
                Next Y
                TS = TS + ","
                For Y = 1 To 4
                    TS = TS + Trim(Str(AncPValsML(Y, x))) + ","
                Next Y
                TS = TS + ","
                For Y = 1 To 4
                    TS = TS + Trim(Str(PAncPVals(Y, x))) + ","
                Next Y
                TS = TS + ","
                TS = TS + Mid(ConsensusSeq, x, 1) + ","
                TS = TS + Mid(ConsensusSeqN, x, 1)
                Print #1, TS
            End If
        Next x
    Else
        Print #1, ",,,Likelihood Probs,,,,,Parsimony Probs"
        Print #1, "Site Position,,A,C,G,T,,A,C,G,T,,Best guess,Next best guess"
        If (Mid(MLAncSeq, x, 1) <> Mid(ParsAncSeq, x, 1) Or AncPValsML(0, x) < 0.95) And Mid(MLAncSeq, x, 1) <> "-" Then
                TS = Trim(Str(x)) + ",,"
                For Y = 1 To 4
                    TS = TS + Trim(Str(AncPValsML(Y, x))) + ","
                Next Y
                TS = TS + ","
                For Y = 1 To 4
                    TS = TS + Trim(Str(PAncPVals(Y, x))) + ","
                Next Y
                TS = TS + ","
                TS = TS + Mid(ConsensusSeq, x, 1) + ","
                TS = TS + Mid(ConsensusSeqN, x, 1)
                Print #1, TS
            End If
    End If
    
    Close #1
    
    
    
    
'    Dim TestSeqs() As String
'    ReDim TestSeqs(2)
'    For x = 1 To Len(StrainSeq(0))
'
'        For Y = 1 To 4
'            If AncPVals(Y, x) = -1 Then
'                AncPVals(Y, x) = 1
'            End If
'        Next Y
'
'    Next x
''Make a list of sites where the ML, Pars and bayesian methods differ
'If SumAncSeq <> "" Then
'    For x = 1 To Len(StrainSeq(0))
'        If Mid(ParsAncSeq, x, 1) = "-" And Mid$(MLAncSeq, x, 1) = "?" Then
'            Mid$(MLAncSeq, x, 1) = "-"
'            Mid$(SumAncSeq, x, 1) = "-"
'
'        ElseIf Mid$(MLAncSeq, x, 1) = "?" Then
'            Mid$(MLAncSeq, x, 1) = "-"
'            Mid$(SumAncSeq, x, 1) = "-"
'        End If
'
'    Next x
'Else
'    For x = 1 To Len(StrainSeq(0))
'        If Mid(ParsAncSeq, x, 1) = "-" And Mid$(MLAncSeq, x, 1) = "?" Then
'            Mid$(MLAncSeq, x, 1) = "-"
'
'        ElseIf Mid$(MLAncSeq, x, 1) = "?" Then
'            Mid$(MLAncSeq, x, 1) = "-"
'        End If
'
'    Next x
'End If
'    For x = 1 To Len(StrainSeq(0))
'        For Y = 1 To 4
'            If AncPVals(Y, x) >= 0.95 Then
'                Exit For
'            End If
'        Next Y
'        If Mid$(ParsAncSeq, x, 1) <> Mid$(MLAncSeq, x, 1) Then
'            If Mid$(ParsAncSeq, x, 1) = "-" Then
'                TestSeqs(0) = TestSeqs(0) + "-"
'                TestSeqs(1) = TestSeqs(1) + "-"
'                TestSeqs(2) = TestSeqs(2) + "-"
'                x = x
'            'ElseIf Mid$(ParsAncSeq, X, 1) = "?" Then
'            '    TestSeqs(0) = TestSeqs(0) + Mid$(SumAncSeq, X, 1)
'            '    TestSeqs(1) = TestSeqs(1) + "-"
'            Else
'
'
'                MaxP(0) = 0
'                MaxP(1) = 0
'                If Y = 5 Then
'                    'choose second highest p-value
'                    MaxP(1) = 0
'                    MaxP(0) = 0
'                    For Z = 1 To 4
'                        If AncPVals(Z, x) > MaxP(0) Then
'                            If MaxP(0) > MaxP(1) Then
'                                MaxP(1) = MaxP(0)
'                                WinNuc(1) = WinNuc(0)
'                            End If
'                            MaxP(0) = AncPVals(Z, x)
'                            WinNuc(0) = Z
'                        ElseIf AncPVals(Z, x) > MaxP(1) Then
'                            MaxP(1) = AncPVals(Z, x)
'                            WinNuc(1) = Z
'                        End If
'                    Next Z
'                    TestSeqs(1) = TestSeqs(1) + NucTrans(WinNuc(1))
'                    TestSeqs(0) = TestSeqs(0) + NucTrans(WinNuc(0))
'                    TestSeqs(2) = TestSeqs(2) + "(" + NucTrans(WinNuc(0)) + "/" + NucTrans(WinNuc(1)) + ")"
'                Else
'                    TestSeqs(0) = TestSeqs(0) + Mid$(SumAncSeq, x, 1)
'                    TestSeqs(1) = TestSeqs(1) + Mid$(SumAncSeq, x, 1)
'                    TestSeqs(2) = TestSeqs(2) + Mid$(SumAncSeq, x, 1)
'                End If
'            End If
'        Else
'            If Mid$(ParsAncSeq, x, 1) = "-" Then
'                TestSeqs(0) = TestSeqs(0) + "-"
'                TestSeqs(1) = TestSeqs(1) + "-"
'                TestSeqs(2) = TestSeqs(2) + "-"
'            Else
'                'TestSeqs(0) = TestSeqs(0) + Mid$(ParsAncSeq, X, 1)
'                MaxP(0) = 0
'                MaxP(1) = 0
'                If Y = 5 Then
'                    'choose second highest p-value
'                    MaxP(1) = 0
'                    MaxP(0) = 0
'                    For Z = 1 To 4
'                        If AncPVals(Z, x) > MaxP(0) Then
'                            If MaxP(0) > MaxP(1) Then
'                                MaxP(1) = MaxP(0)
'                                WinNuc(1) = WinNuc(0)
'                            End If
'                            MaxP(0) = AncPVals(Z, x)
'                            WinNuc(0) = Z
'                        ElseIf AncPVals(Z, x) > MaxP(1) Then
'                            MaxP(1) = AncPVals(Z, x)
'                            WinNuc(1) = Z
'                        End If
'                    Next Z
'                    TestSeqs(0) = TestSeqs(0) + NucTrans(WinNuc(0))
'                    If MaxP(0) < 0.7 And Mid$(ParsAncSeq, x, 1) = "?" Then
'                        TestSeqs(1) = TestSeqs(1) + "-"
'                    Else
'                        TestSeqs(1) = TestSeqs(1) + NucTrans(WinNuc(1))
'                    End If
'                    TestSeqs(2) = TestSeqs(2) + "(" + NucTrans(WinNuc(0)) + "/" + NucTrans(WinNuc(1)) + ")"
'                Else
'                    TestSeqs(0) = TestSeqs(0) + Mid$(SumAncSeq, x, 1)
'                    TestSeqs(1) = TestSeqs(1) + Mid$(SumAncSeq, x, 1)
'                    TestSeqs(2) = TestSeqs(2) + Mid$(SumAncSeq, x, 1)
'                End If
'            End If
'
'        End If
'    'Exit Sub
'    Next x
'     FF = FreeFile
'     If sbmpname$ = "" Then Exit Sub
'     XX = CurDir
'    Open sbmpname$ For Output As #FF
'    Print #1, "Parsimony estimate," & ParsAncSeq
'    Print #1, "Bayesian estimate," & SumAncSeq
'    Print #1, "Bayesian estimate with degeneracies," & TestSeqs(2)
'    Print #1, "Best consensus," & TestSeqs(0)
'    Print #1, "Next best consensus," & TestSeqs(1)
'    Print #1, ",Parsimony,,,,,,Bayesian,,,,,"
'    Print #1, "Position in Alignment,A,C,G,T,-,,A,C,G,T,,Best consensus,,Next best consensus"
'
'    For x = 1 To Len(StrainSeq(0))
'        TString = Str(x) + ","
'
'        If Mid$(ParsAncSeq, x, 1) = "A" Then
'            TString = TString + "1,0,0,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "C" Then
'            TString = TString + "0,1,0,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "G" Then
'            TString = TString + "0,0,1,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "T" Then
'            TString = TString + "0,0,0,1,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "-" Then
'            TString = TString + "0,0,0,0,1,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "N" Then
'            TString = TString + "0.25,0.25,0.25,0.25,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "?" Then
'            TString = TString + "0.2,0.2,0.2,0.2,0.2,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "M" Then
'            TString = TString + "0.5,0.5,0,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "R" Then
'            TString = TString + "0.5,0,0.5,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "W" Then
'            TString = TString + "0.5,0,0,0.5,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "S" Then
'            TString = TString + "0,0.5,0.5,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "Y" Then
'            TString = TString + "0,0.5,0,0.5,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "K" Then
'            TString = TString + "0,0,0.5,0.5,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "V" Then
'            TString = TString + "0.3333,0.3333,0.3333,0,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "H" Then
'            TString = TString + "0.3333,0.3333,0,0.3333,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "D" Then
'            TString = TString + "0.3333,0,0.3333,0.3333,0,,"
'        ElseIf Mid$(ParsAncSeq, x, 1) = "B" Then
'            TString = TString + "0,0.3333,0.3333,0.3333,0,,"
'        End If
'        For Y = 1 To 4
'            TString = TString + Str(AncPVals(Y, x)) + ","
'        Next Y
'        TString = TString + "," + Mid$(TestSeqs(0), x, 1) + ",," + Mid$(TestSeqs(1), x, 1)
'        Print #FF, TString
'    Next x
'
'    Close #FF
'    x = x

End Sub

Private Sub SaveARCRMnu_Click()

    Call SaveAlign("", 0, OriginalName(), 2)

End Sub

Private Sub SaveARRRMnu_Click()

    Call SaveAlign("", 0, OriginalName(), 3)

End Sub

Private Sub SaveARRSMnu_Click()
 If ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210 Then
    Call SaveAlign("", 0, OriginalName(), 7)
 Else
    Call SaveAlign("", 0, OriginalName(), 123)
 End If
End Sub

Private Sub SaveARSRMnu_Click()

    Call SaveAlign("", 0, OriginalName(), 1)

End Sub

Private Sub SaveBMPMnu_Click()

    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".bmp"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "BMP File (*.bmp)|*.bmp"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "open file" action is required.
        sbmpname$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SBMPnameII = .FileTitle
    End With

    If sbmpname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11

    If SaveBMPFlag = 1 Then
        'Picture16.BackColor = QBColor(15)
        SavePicture Picture16.Image, sbmpname$
    ElseIf SaveBMPFlag = 2 Then
        'picture21.PaintPicture picture7.Image,
        'Picture7.BackColor = QBColor(15)
        Picture21.Width = Picture10.ScaleWidth + 10
        Picture21.Height = Picture10.ScaleHeight + 20

        Dim OWid As Double, OHeight As Double

        OWid = Picture7.Width
        OHeight = Picture7.Height

        If ManFlag = 3 Or ManFlag = 4 Or ManFlag = 7 Or ManFlag = 1 Then

            If ManFlag = 1 Then
                LongName = Picture7.TextWidth("Outer fragments")
            Else
                LongName = 0
            End If

            For Z = 1 To NumberOfSeqs

                If Picture7.TextWidth(OriginalName(RevSeq(Z))) > LongName Then LongName = Picture7.TextWidth(OriginalName(RevSeq(Z)))
            Next 'Z

            If Picture7.Height < ((NumberOfSeqs * 200 + 100) / Screen.TwipsPerPixelY) Then
                Picture7.Height = (NumberOfSeqs * 200 + 100) / Screen.TwipsPerPixelY
                Picture21.Height = (NumberOfSeqs * 200 + 100) / Screen.TwipsPerPixelY
            End If

            Picture7.Width = Picture7.Width + LongName + (314 / Screen.TwipsPerPixelX) + 10
            Picture7.AutoRedraw = True
            Picture21.Width = Picture21.Width + LongName + (314 / Screen.TwipsPerPixelX) + 10

            For Z = 1 To NumberOfSeqs
                Picture7.Line (OWid + 50 / Screen.TwipsPerPixelX, 20 + (50 + (Z - 1) * 200) / Screen.TwipsPerPixelY)-(OWid + 200 / Screen.TwipsPerPixelX, 20 + (200 + (Z - 1) * 200) / Screen.TwipsPerPixelY), SeqCol(RevSeq(Z)), BF
            Next 'Z

            For Z = 1 To NumberOfSeqs
                Picture7.ForeColor = RGB(150, 150, 150)
                Picture7.CurrentX = OWid + (250 + 14) / Screen.TwipsPerPixelX
                Picture7.CurrentY = 20 + (50 + (Z - 1) * 200 + 14) / Screen.TwipsPerPixelY
                Picture7.Print OriginalName(RevSeq(Z))
                Picture7.ForeColor = 0
                Picture7.CurrentX = OWid + 250 / Screen.TwipsPerPixelX
                Picture7.CurrentY = 20 + (50 + (Z - 1) * 200) / Screen.TwipsPerPixelY
                Picture7.Print OriginalName(RevSeq(Z))
            Next 'Z

            If ManFlag = 1 Then
                Picture7.Line (OWid + 50 / Screen.TwipsPerPixelX, 20 + (50 + (Z - 1) * 200) / Screen.TwipsPerPixelY)-(OWid + 200 / Screen.TwipsPerPixelX, 20 + (200 + (Z - 1) * 200) / Screen.TwipsPerPixelY), SeqCol(RevSeq(0)), BF
                Picture7.ForeColor = RGB(150, 150, 150)
                Picture7.CurrentX = OWid + (250 + 14) / Screen.TwipsPerPixelX
                Picture7.CurrentY = 20 + (50 + (Z - 1) * 200 + 14) / Screen.TwipsPerPixelY
                Picture7.Print "Outer fragments"
                Picture7.ForeColor = 0
                Picture7.CurrentX = OWid + 250 / Screen.TwipsPerPixelX
                Picture7.CurrentY = 20 + (50 + (Z - 1) * 200) / Screen.TwipsPerPixelY
                Picture7.Print "Outer fragments"
            End If

        End If

        Picture21.Cls
        Picture21.PaintPicture Picture10.Image, 0, 10
        Picture21.PaintPicture Picture7.Image, Picture7.Left, Picture7.Top + 10

        If Picture20.Visible = True Then
            Picture21.PaintPicture Picture20.Image, Picture20.Left, Picture20.Top + 5
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        SavePicture Picture21.Image, sbmpname$
        On Error GoTo 0
        Picture7.Width = OWid
        Picture7.Height = OHeight
        Picture21.Width = Picture10.ScaleWidth + 20
        Picture21.Height = Picture10.ScaleHeight + 20
        
        Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
    ElseIf SaveBMPFlag = 3 Then
        'Picture11.BackColor = QBColor(15)
        SavePicture Picture6.Image, sbmpname$
    End If

    Screen.MousePointer = 0
End Sub

Private Sub SaveDisMnu_Click()
    Call SaveAlign("", 0, OriginalName(), 5)
    
End Sub

Private Sub SaveEAlignMnu_Click()

    Call SaveAlign("", 0, OriginalName(), 0)

End Sub

Private Sub SaveEMFMnu_Click()
    CopyFlag = 0

    Call SaveWMFPlot

End Sub

Private Sub SaveEnMnu_Click()
Call SaveAlign("", 0, OriginalName(), 6)
End Sub

Private Sub SaveMatrixCsvMnu_Click()
    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".tre"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "Comma separated value (*.csv)|*.csv"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "open file" action is required.
        snhname$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SNHFnameII = .FileTitle
    End With
    
    If snhname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Dim OutMat() As Double, RSize As Long
    
    
    If CurMatrixFlag = 0 Then
        RSize = UBound(MatPic, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatPic(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 0 Then
        RSize = UBound(MatrixTB, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixTB(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 1 Then
        RSize = UBound(MatrixR, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixR(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 2 Then
        RSize = UBound(MatrixM, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixM(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 3 Then
        If Form1.Check1 = 0 Then
            RSize = UBound(MatrixRR, 1)
            ReDim OutMat(RSize, RSize)
            For x = 0 To RSize
                For Y = 0 To RSize
                    OutMat(x, Y) = MatrixRR(x, Y)
                Next Y
            Next x
        Else
            RSize = UBound(MatrixRRP, 1)
            ReDim OutMat(RSize, RSize)
            For x = 0 To RSize
                For Y = 0 To RSize
                    OutMat(x, Y) = MatrixRRP(x, Y)
                Next Y
            Next x
        End If
    ElseIf CurMatrixFlag = 4 Then
        RSize = UBound(MatrixBP, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixBP(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 5 Then
        RSize = UBound(MatrixLD, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixLD(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 6 Then
        RSize = UBound(MatrixRMin, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixRMin(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 7 Then
        RSize = UBound(MatrixRMinD, 1)
        ReDim OutMat(RSize, RSize)
    ElseIf CurMatrixFlag = 8 Then
        RSize = UBound(MatrixMC, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixMC(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 9 Then
        RSize = UBound(MatPic, 1)
        ReDim OutMat(RSize, RSize)
    ElseIf CurMatrixFlag = 10 Then
        RSize = UBound(MatPic, 1)
        ReDim OutMat(RSize, RSize)
    ElseIf CurMatrixFlag = 11 Then
        RSize = UBound(MatrixL, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixL(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 12 Then
        RSize = UBound(MatrixSH, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixSH(x, Y)
            Next Y
        Next x
    ElseIf CurMatrixFlag = 13 Then
        RSize = UBound(MatrixRF, 1)
        ReDim OutMat(RSize, RSize)
        For x = 0 To RSize
            For Y = 0 To RSize
                OutMat(x, Y) = MatrixRF(x, Y)
            Next Y
        Next x
    End If
    Dim TString As String
    
    Open snhname$ For Output As #1
    
    For x = 0 To RSize
        TString = ""
        For Y = 0 To RSize
            TString = TString + Str(OutMat(x, Y)) + ","
        Next Y
        Print #1, TString
    Next x
    
    
    Screen.MousePointer = 0
    Close #1
    
End Sub

Private Sub SaveNHFMnu_Click()
Dim Outval As String, BackY As Long, TempS As String
If CSVFlag = 1 Then
    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".csv"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "Spreadsheet (*.csv)|*.csv"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "save file" action is required.
        sFName$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SFnameII = .FileTitle
    End With
    If sFName$ = "" Then Exit Sub
    'Screen.MousePointer = 11
    If DebuggingFlag < 2 Then On Error Resume Next
    Open sFName$ For Output As #1
    On Error GoTo 0
    Dummy = FreeFile
    If Dummy = 1 Then Exit Sub
    
    If ManFlag = 161 Then
        Print #1, ClusteringResult
    ElseIf ManFlag = 60 Then
        Print #1, "Protein number, Start in alignment, End in alignmnet, Breakpoint number, Mean E-score of real recombinants (higher E-scores = more predicted protein misfolding), Mean E-score of permuted recombination events (higher E-scores = more predicted protein misfolding), E p-value (the probability that real recombination breakpoints do not tend to avoid disrupting protein folding),Mean M-score of real recombinants (higher M-scores = more predicted protein misfolding), Mean M-score of permutation recombinants (higher M-scores = the recombinnat is more different from either of its parents), M p-value (the probability that recombinant proteins do not tend to resemble one or the other of their parents more closely than can be accounted for by chance)"
        
        For Y = 0 To PermPDBNo
           
            Outval = Trim(Str(Y + 1)) + ","
            Outval = Outval + Trim(Str(ProtInfo(0, Y))) + " , " + Trim(Str(ProtInfo(1, Y))) + ","
                        
            
            Outval = Outval + Trim(Str(NOC(Y))) + ","
            Outval = Outval + Trim(Str(MeanE(Y, 0))) + ","
            Outval = Outval + Trim(Str(MeanE(Y, 1))) + ","
            TempS = Trim(Str(LowerThanReal(Y)))
            If Left(TempS, 1) = "." Then
                TempS = "0" + TempS
            End If
            Outval = Outval + TempS + ","
            'Print #1, OutVal
            
            
            Outval = Outval + Trim(Str(MeanM(Y, 0))) + ","
            Outval = Outval + Trim(Str(MeanM(Y, 1))) + ","
            TempS = Trim(Str(LowerThanRealM(Y)))
            If Left(TempS, 1) = "." Then
                TempS = "0" + TempS
            End If
            Outval = Outval + TempS
            Print #1, Outval
        Next Y
    End If
    Close #1
Else
    Dim NHFlag As Integer
    If SaveTxtFlag = 22 Then
        snhname$ = InFileX + " ML tree with recombinant regions removed.tre"
    ElseIf SaveTxtFlag = 23 Then
        snhname$ = InFileX + " ML tree with recombinant regions separated.tre"
    Else
        With Form1.CommonDialog1
            .FileName = ""
            '.InitDir = currentdir
            .DefaultExt = ".tre"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "NH Format (*.tre)|*.tre"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            snhname$ = .FileName  'Stores selected file name in the
            'string, fname$.
            SNHFnameII = .FileTitle
        End With
    End If
    If TreeTypeFlag = 0 Then

        If CTF = 0 Then
            NHFlag = 0
        ElseIf CTF = 1 Then
            NHFlag = 4
        ElseIf CTF = 2 Then
            NHFlag = 5
        ElseIf CTF = 3 Then
            NHFlag = 6
        ElseIf CTF = 4 Then
            NHFlag = 13
        End If

    ElseIf TreeTypeFlag = 2 Then
        If CTF = 0 Then
            NHFlag = 2
        ElseIf CTF = 1 Then
            NHFlag = 7
        ElseIf CTF = 2 Then
            NHFlag = 8
        ElseIf CTF = 3 Then
            NHFlag = 9
        ElseIf CTF = 4 Then
            NHFlag = 14
        End If
    ElseIf TreeTypeFlag = 1 Then
        If CTF = 0 Then
            NHFlag = 1
        ElseIf CTF = 1 Then
            NHFlag = 10
        ElseIf CTF = 2 Then
            NHFlag = 11
        ElseIf CTF = 3 Then
            NHFlag = 12
        ElseIf CTF = 4 Then
            NHFlag = 15
        End If
    ElseIf TreeTypeFlag = 3 And CTF = 0 Then
        NHFlag = 17
    ElseIf TreeTypeFlag = 3 And CTF = 1 Then
        NHFlag = 16
    ElseIf TreeTypeFlag = 3 And CTF = 2 Then
        NHFlag = 33
    ElseIf TreeTypeFlag = 3 And CTF = 3 Then
        NHFlag = 34
    ElseIf TreeTypeFlag = 3 And CTF = 4 Then
        NHFlag = 34
    Else
        NHFlag = TreeTypeFlag
    End If

    If snhname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11
    'Picture11.BackColor = QBColor(15)
    Open snhname$ For Output As #1
    Print #1, NHString(NHFlag)
    Screen.MousePointer = 0
    Close #1
End If
End Sub

Private Sub SaveSchemBMPMnu_Click()


Call SchemDrawingEMF(1, SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag)

Exit Sub
    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".bmp"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "BMP File (*.bmp)|*.bmp"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "open file" action is required.
        sbmpname$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SBMPnameII = .FileTitle
    End With

    If sbmpname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11
    Offset = 300 * HAddjust

    Dim LPNT As POINTAPI

    'Picture11.BackColor = QBColor(15)

    If SchemFlag = 0 Then
        SavePicture Picture6.Image, sbmpname$
    ElseIf SchemFlag = 1 Then
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 90), BackColours, BF
        
        Picture6.Line (0 + Offset, 5)-(10 + Offset, 15), ProgColour(0), BF
        Picture6.Line (0 + Offset, 20)-(10 + Offset, 30), ProgColour(1), BF
        Picture6.Line (0 + Offset, 35)-(10 + Offset, 45), ProgColour(2), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 60), ProgColour(3), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 75), ProgColour(4), BF
        Picture6.Line (0 + Offset, 50)-(10 + Offset, 90), ProgColour(5), BF
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 5
        Picture6.Print "RDP"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 20
        Picture6.Print "GENECONV"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 35
        Picture6.Print "Bootscan"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 50
        Picture6.Print "MaxChi"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 65
        Picture6.Print "Chimaera"
        Picture6.CurrentX = 15 + Offset
        Picture6.CurrentY = 80
        Picture6.Print "SiScan"
        SavePicture Picture6.Image, sbmpname$
    ElseIf SchemFlag = 2 Then
        'For curline = 10 To 110
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 200), BackColours, BF
        curline = 0
        Pict = Picture6.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        RCol = 255
        Pict = Picture6.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        BCol = 255
        Pict = Picture6.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        GCol = 255
        Picture6.ForeColor = 0
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 4
        MaxLogPVal = -Log10(LowestProb)
        Picture6.CurrentX = 25 + Offset
        Picture6.Print "-  " & Int(MaxLogPVal * 10) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 42
        Picture6.Print "-  " & (Int(((MinLogPValSch + MaxLogPVal) / 2 + MaxLogPVal) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 81
        Picture6.Print "-  " & (Int((MinLogPValSch + MaxLogPVal) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 119
        Picture6.Print "-  " & (Int((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2 * 10)) / 10
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 158
        Picture6.Print "-  " & Int(MinLogPValSch * 10) / 10
        Picture6.CurrentX = 2 + Offset
        Picture6.CurrentY = 170
        Picture6.Print "-Log(P-Val)"
        SavePicture Picture6.Image, sbmpname$
        Picture6.CurrentX = 0
        Picture6.CurrentY = 0
    ElseIf SchemFlag = 3 Then
        'For curline = 10 To 110
        Picture6.Line (Offset, 5)-(Picture6.ScaleWidth, 200), BackColours, BF
        curline = 0
        Pict = Picture6.hdc

        For RCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        RCol = 255
        Pict = Picture6.hdc

        For GCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        BCol = 255
        Pict = Picture6.hdc

        For BCol = 0 To 255 Step 5
            curline = Int(10 + (RCol + GCol + BCol) / 5)
            Picture6.ForeColor = RGB(RCol, BCol, GCol)
            Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
            Dummy = LineTo(Pict, 20 + Offset, curline)
        Next

        GCol = 255
        Picture6.ForeColor = 0
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 4
        Picture6.CurrentX = 25 + Offset
        Picture6.Print "-  " & Int(MinDistX * 100) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 42
        Picture6.Print "-  " & (Int(((MaxDistX + MinDistX) / 2 + MinDistX) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 81
        Picture6.Print "-  " & (Int((MaxDistX + MinDistX) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 119
        Picture6.Print "-  " & (Int((MaxDistX + (MaxDistX + MinDistX) / 2) / 2 * 100)) / 100
        Picture6.CurrentX = 25 + Offset
        Picture6.CurrentY = 158
        Picture6.Print "-  " & Int(MaxDistX * 100) / 100
        Picture6.CurrentX = -10 + Offset
        Picture6.CurrentY = 170
        Picture6.Print "Parental identity"
        SavePicture Picture6.Image, sbmpname$
        Picture6.CurrentX = 0
        Picture6.CurrentY = 0
    
    End If

    Screen.MousePointer = 0
End Sub

Private Sub SaveTreeBmpMnu_Click()

    With Form1.CommonDialog1
        .FileName = ""
        '.InitDir = currentdir
        .DefaultExt = ".bmp"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "BMP File (*.bmp)|*.bmp"
        '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
        .Action = 2 'Specify that the "open file" action is required.
        sbmpname$ = .FileName  'Stores selected file name in the
        'string, fname$.
        SBMPnameII = .FileTitle
    End With

    If sbmpname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11
    'Picture16.BackColor = QBColor(15)
    SavePicture Picture16.Image, sbmpname$
    Screen.MousePointer = 0
End Sub

Private Sub SaveTreeEmfMnu_Click()
    If SaveTxtFlag = 22 Then
        EMFFName = InFileX + "ML tree with recombinant regions removed.emf"
    ElseIf SaveTxtFlag = 23 Then
        EMFFName = InFileX + "ML tree with recombinant regions separated.emf"
    Else
        With Form1.CommonDialog1
            .FileName = ""
            '.InitDir = currentdir
            .DefaultExt = ".bmp"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "EMF File (*.emf)|*.emf"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            EMFFName = .FileName 'Stores selected file name in the
            'string, fname$.
            semfnameII = .FileTitle
        End With
    End If
    'EMFFName = "tmp.emf"
    'SEMFnameII = "tmp.emf"

    If TreeTypeFlag = 0 And CTF <> 0 Then
        'Exit Sub

        

            Call NJEMF(CTF + 3)
    Else
    
        Call NJEMF(CTF)
    
    End If


End Sub

Private Sub SaveTxtMnu_Click()

Dim tSeq1 As Long, tSeq2 As Long, tSeq3 As Long, TempS As String

UB = -1
If DebuggingFlag < 2 Then On Error Resume Next
UB = UBound(TreeTrace, 1)
On Error GoTo 0
If UB >= 0 And UB >= Seq1 And UB >= Seq2 And UB >= Seq3 Then
    tSeq1 = TreeTrace(Seq1)
    tSeq2 = TreeTrace(Seq2)
    tSeq3 = TreeTrace(Seq3)
End If

    If SaveTxtFlag = 2 Or SaveTxtFlag = 12 Or SaveTxtFlag = 22 Then
        If CLine = "" Or CLine = " " Then
            With Form1.CommonDialog1
                .FileName = ""
                '.InitDir = currentdir
                .DefaultExt = ".rdp"   'Specify the default extension.
                'Specify which file extensions will be preferred.
                '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
                .Filter = "Plot Data (*.csv)|*.csv"
                '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
                .Action = 2 'Specify that the "open file" action is required.
                sFName$ = .FileName  'Stores selected file name in the
                'string, fname$.
                SFnameII = .FileTitle
            End With

            If sFName$ = "" Then Exit Sub
            Screen.MousePointer = 11
        Else
            If SaveTxtFlag = 12 Then
                sFName = InFileX & " breakpoint distribution.csv"
            ElseIf SaveTxtFlag = 22 Then
                sFName = InFileX & " breakpoint cluster probability distribution.csv"
            End If
        End If
        
        If DebuggingFlag < 2 Then On Error Resume Next
        Open sFName$ For Output As #1
        On Error GoTo 0
        Dummy = FreeFile

        If Dummy = 1 Then Exit Sub

        

        If ManFlag <> -1 And ManFlag <> 161 Then
            TempS = "Position in alignment"
            'Print #1, "Position in alignment" & "," & originalname(Seq1) & " - " & originalname(tseq2) & "," & originalname(Seq1) & " - " & originalname(tseq3) & "," & originalname(tseq2) & " - " & originalname(tseq3)

            If ManFlag <> 8 And ManFlag <> 9 And ManFlag <> 5 And ManFlag <> 1 And ManFlag <> 20 And ManFlag <> 22 Then

                For x = 1 To NumberOfSeqs
                    TempS = TempS + "," + OriginalName(RevSeq(0)) + " - " + OriginalName(RevSeq(x))
                Next 'X

                Print #1, TempS
            End If

            If ManFlag = 3 Then
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf PltPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (PltPos(PosCount)) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    TempS = CStr(PltPos(PosCount) - MCOverlapR)

                    For x = 1 To NumberOfSeqs
                        TempS = TempS + "," + CStr((PltVal(x, PosCount) / BSBootReps) * 100)
                    Next 'X

                    Print #1, TempS 'Str$(PltPos(PosCount) - MCOverlapR) & "," & cstr(MCPrintData(0, PosCount)) & "," & cstr(MCPrintData(1, PosCount)) & "," & cstr(MCPrintData(2, PosCount))
                    PosCount = PosCount + 1
                Loop
            ElseIf ManFlag = 20 Then
                Print #1, "Position in alignment, Mean Rho/bp, -95% CI, +95% CI"
                For x = 0 To (GPrintLen - 1) / 2 - 2
                    Print #1, CStr(GPrintPos(0, x)) + "," + CStr(GPrint(0, x)) + "," + CStr(GPrint(1, x)) + "," + CStr(GPrint(1, (GPrintLen - 1) - x))
                Next x
            ElseIf ManFlag = 22 Then
                Print #1, "Position in alignment" & "," & OriginalName(Abs(CLng(XoverList(RelX, RelY).Daughter))) & " as recombinant and " & OriginalName(tSeq2) & " and "; OriginalName(tSeq3) & " as parents" & "," & "Permutation upper bound" & "," & "Permutation lower bound"
                    For PosCount = 1 To (GPrintLen - 2) / 2
                        'GPrintLen = NSites * 2 + 2
                        'GPrint(3, X) = PermRangeS1(0, X) 'GraphPlt(1, X)
                        'GPrint(3, NSites * 2 - X) = PermRangeS1(1, X) 'GraphPlt(2, X)
                           If CStr(GPrintPos(0, PosCount)) = 0 And CStr(GPrint(0, PosCount)) = 0 Then Exit For

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(1, (GPrintLen - 2) - PosCount))
                            End If

                            
                        Next
            ElseIf ManFlag = 1 Then
                Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & OriginalName(RevSeq(0)) & " Outer fragments (potentially derived from an unknown parent)"

                Do While MCPrintData(x, CurPPos) > 0
                    Print #1, CStr(MCPrintPos(0, CurPPos, 0)) & "," & CStr(MCPrintPos(0, CurPPos, 1)) & "," & CStr(MCPrintData(0, CurPPos))
                    CurPPos = CurPPos + 1
                Loop

                CurPPos = 0

                For x = 1 To NumberOfSeqs
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & OriginalName(RevSeq(0)) & " - " & OriginalName(RevSeq(x))

                    Do While MCPrintData(x, CurPPos) > 0
                        Print #1, CStr(MCPrintPos(x, CurPPos, 0)) & "," & CStr(MCPrintPos(x, CurPPos, 1)) & "," & CStr(MCPrintData(x, CurPPos))
                        CurPPos = CurPPos + 1
                    Loop

                    CurPPos = 0
                Next 'X

            ElseIf ManFlag = 4 Then
                PosCount = 1

                For PosCount = 1 To LenXoverSeq


                    TempS = CStr(MCPrintPos(PosCount))

                    For x = 0 To NumberOfSeqs - 1
                        TempS = TempS + "," + CStr(-Log10(MCPrintData(x, PosCount)))
                    Next 'X

                    Print #1, TempS 'Str$(PltPos(PosCount) - MCOverlapR) & "," & cstr(MCPrintData(0, PosCount)) & "," & cstr(MCPrintData(1, PosCount)) & "," & cstr(MCPrintData(2, PosCount))
                    
                Next 'poscount

            ElseIf ManFlag = 5 Then
                If GPrintType = 0 Then
                        Print #1, "Position in alignment, Log likelihood ratio"
                        For x = 0 To GPrintLen
                            Print #1, CStr(GPrintPos(0, x)) + "," + CStr(GPrint(0, x))
                        Next x
                    Else
                        Print #1, "Start Position in alignment, End Position in alignment,Log likelihood ratio"
                        For x = 0 To GPrintLen
                            Print #1, CStr(GPrintPos(0, 0, x)) + "," + CStr(GPrintPos(0, 1, x)) + "," + CStr(GPrint(0, x))
                        Next x
                    End If

            ElseIf ManFlag = 7 Then
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount + 3) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    TempS = CStr(MCPrintPos(PosCount))

                    For x = 1 To NumberOfSeqs
                        TempS = TempS + "," + CStr((((MCPrintData(x, PosCount)))))
                    Next 'X

                    Print #1, TempS 'Str$(PltPos(PosCount) - MCOverlapR) & "," & cstr(MCPrintData(0, PosCount)) & "," & cstr(MCPrintData(1, PosCount)) & "," & cstr(MCPrintData(2, PosCount))
                    PosCount = PosCount + 1
                Loop
            ElseIf ManFlag = 8 Then
                    Header = "Position in alignment, TOPAL Scan"
        
                    For x = 1 To TOPerms
                        Header = Header + ",Permutation " + Trim$(CStr(x))
                    Next 'X
        
                    Print #1, Header
                    PlotPos = Int((TOWinLen + TOStepSize * (TOSmooth - 1)) / 2)
                    Y = 0
        
                    Do While PlotPos < Len(StrainSeq(0))
                        Header = ""
                        Header = Header + Str(PlotPos)
        
                        For x = 0 To TOPerms
                            Header = Header + "," + Trim$(CStr(SmoothDSS(x, Y)))
                        Next 'X
        
                        Print #1, Header
                        PlotPos = PlotPos + TOStepSize
                        Y = Y + 1
                    Loop
                ElseIf ManFlag = 9 Then
                        Print #1, "Position in alignment,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,S1,S2,S3,S4,S5,S6,S7,S8,S9"
                            
                            Z = 0
                            For x = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                                
                                OutString = Str(GPrintPos(0, Z))
                                For Y = 1 To 15
                                    OutString = OutString + "," + Str(GPrint(Y - 1, Z))
                                Next Y
                                For Y = 1 To 9
                                    OutString = OutString + "," + Str(GPrint(Y + 14, Z))
                                Next Y
                                Print #1, OutString
                                Print #1, OutString
                                Z = Z + 1
                            Next 'X
            End If

        

        Else

            If (CurrentCheck <> 9 And CurrentCheck <> 16 And CurrentCheck <> 41 And CurrentCheck <> 14 And CurrentCheck <> 15 And CurrentCheck <> 12 And CurrentCheck <> 13 And CurrentCheck <> 10 And CurrentCheck <> 1 And CurrentCheck <> 5 And CurrentCheck <> 6 And CurrentCheck <> 20 And CurrentCheck <> 22 And CurrentCheck <> 21 And CurrentCheck <> 23 And CurrentCheck > -1) Or (CurrentCheck = -1 And XoverList(RelX, RelY).ProgramFlag <> 4 And XoverList(RelX, RelY).ProgramFlag <> 6 And XoverList(RelX, RelY).ProgramFlag <> 6 + AddNum And XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum And XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum And XoverList(RelX, RelY).ProgramFlag <> 8 And XoverList(RelX, RelY).ProgramFlag <> 8 + AddNum) Then
                If CurrentCheck = -1 And (XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 3) And MCTripletFlag = 1 Then
                    Print #1, "Position in alignment" & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq2)
                   
                Else
                    Print #1, "Position in alignment" & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq2) & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq3) & "," & OriginalName(tSeq2) & " - " & OriginalName(tSeq3)
                End If
            End If
            
            If CurrentCheck > -1 Or (CurrentCheck = -1 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Then

                If CurrentCheck = 0 Then

                    For x = 0 To GPrintLen
                        Print #1, GPrintPos(0, x) & "," & GPrint(0, x) & "," & GPrint(1, x) & "," & GPrint(2, x)
                    Next 'X
                    'Exit Sub
                ElseIf CurrentCheck = 41 Then
                    Print #1, "Position in alignment" & "," & "(" & OriginalName(tSeq1) & ":" & OriginalName(tSeq2) & ")-(" & OriginalName(tSeq3) & ":SequenceX),(" & OriginalName(tSeq1) & ":" & OriginalName(tSeq3) & ")-(" & OriginalName(tSeq2) & ":SequenceX),(" & OriginalName(tSeq2) & ":" & OriginalName(tSeq3) & ")-(" & OriginalName(tSeq1) & ":SequenceX),("
                    For x = 0 To Len(StrainSeq(0))
                        Print #1, x & "," & GPrint(2, x) & "," & GPrint(0, x) & "," & GPrint(1, x)
                    Next 'X
                ElseIf CurrentCheck = 13 Then
                    PosCount = 1
                    
                    FindSubSeqPP
                    TempS = "Position in Alignment"
                    XX = Seq3
                    TempS = TempS + "," + OriginalName(Seq1) + "," + OriginalName(Seq2) + "," + OriginalName(Seq3)
                    If GPrintNum > 2 Then
                        For x = 0 To NumberOfSeqs
                            If x <> Seq1 And x <> Seq2 And x <> Seq3 Then
                                TempS = TempS + "," & OriginalName(RevSeq(x))
                            End If
                        Next x
                    End If
                    Print #1, TempS
                    For PosCount = 1 To LenXoverSeq
    
    
                        TempS = CStr(XDiffPos(PosCount))
    
                        For x = 0 To GPrintNum
                            TempS = TempS + "," + CStr(GPrint(x, PosCount))
                        Next 'X
    
                        Print #1, TempS 'Str$(PltPos(PosCount) - MCOverlapR) & "," & cstr(MCPrintData(0, PosCount)) & "," & cstr(MCPrintData(1, PosCount)) & "," & cstr(MCPrintData(2, PosCount))
                        
                    Next 'poscount
                ElseIf CurrentCheck = 1 Or (CurrentCheck = -1 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Then
                    CurPPos = 0
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq2)

                    Do While MCPrintData(0, CurPPos) > 0
                        Print #1, CStr(MCPrintPos(0, CurPPos, 0)) & "," & CStr(MCPrintPos(0, CurPPos, 1)) & "," & CStr(MCPrintData(0, CurPPos))
                        CurPPos = CurPPos + 1
                    Loop

                    CurPPos = 0
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq3)

                    Do While MCPrintData(1, CurPPos) > 0
                        Print #1, CStr(MCPrintPos(1, CurPPos, 0)) & "," & CStr(MCPrintPos(1, CurPPos, 1)) & "," & CStr(MCPrintData(1, CurPPos))
                        CurPPos = CurPPos + 1
                    Loop

                    CurPPos = 0
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & OriginalName(tSeq2) & " - " & OriginalName(tSeq3)

                    Do While MCPrintData(2, CurPPos) > 0
                        Print #1, CStr(MCPrintPos(2, CurPPos, 0)) & "," & CStr(MCPrintPos(2, CurPPos, 1)) & "," & CStr(MCPrintData(2, CurPPos))
                        CurPPos = CurPPos + 1
                    Loop

                ElseIf CurrentCheck = 2 Or CurrentCheck = 3 Then
                    PosCount = 1

                    Do

                        If PosCount > Len(StrainSeq(0)) - 3 Then
                            Exit Do
                        ElseIf MCPrintPos(PosCount + 3) = 0 Then
                            Exit Do
                        ElseIf (MCPrintPos(PosCount)) > Len(StrainSeq(0)) Then
                            Exit Do
                        End If

                        Print #1, CStr(MCPrintPos(PosCount) - MCOverlapR) & "," & CStr(MCPrintData(0, PosCount)) & "," & CStr(MCPrintData(1, PosCount)) & "," & CStr(MCPrintData(2, PosCount))
                        PosCount = PosCount + 1
                    Loop
                ElseIf CurrentCheck = 12 Then
                    Dim ENumber As Long
                    Print #1, "Recombination Event Number, Method, Recombinant, Minor Parent, Major Parent, Start in Alignmnet, End in Alignment, Best P-Value, Distance"
                    ENumber = 0
                    
                    
                    
                    For x = 1 To SEventNumber
                        If BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0 Then
                            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 Then
                                    OutString = ""
                                    ENumber = ENumber + 1
                                    OutString = Trim(Str(ENumber)) & ","
                                    PR = XoverList(BestEvent(x, 0), BestEvent(x, 1)).ProgramFlag
                                    If PR >= AddNum Then PR = PR - AddNum
                                    If PR = 0 Then
                                        OutString = OutString + "RDP,"
                                    ElseIf PR = 1 Then
                                        OutString = OutString + "GENECONV,"
                                    ElseIf PR = 2 Then
                                        OutString = OutString + "Bootscan,"
                                    ElseIf PR = 3 Then
                                        OutString = OutString + "MaxChi,"
                                    ElseIf PR = 4 Then
                                        OutString = OutString + "Chimaera,"
                                    ElseIf PR = 5 Then
                                        OutString = OutString + "SiScan,"
                                    ElseIf PR = 6 Then
                                        OutString = OutString + "Phylpro,"
                                    End If
                                    OutString = OutString + OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter) & ","
                                    OutString = OutString + OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP) & ","
                                    OutString = OutString + OriginalName(XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP) & ","
                                    OutString = OutString + Str(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) & ","
                                    OutString = OutString + Str(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) & ","
                                    OutString = OutString + Str(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability) & ","
                                    MDist = Distance(XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP, XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP)
                                    OutString = OutString & Str(MDist)
                                    Print #1, OutString
                            End If
                        End If
                    Next x
                    If PermNextno > MemPoc And x = 1234567 Then
                        ReDim Distance(0, 0)
                    End If
                ElseIf CurrentCheck = 14 Then
                    PosCount = 0
                    Print #1, "Position in alignment, Recombination event number"
                    For PosCount = 1 To Len(StrainSeq(0))

                       
                        Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr(MCPrintData(PosCount))
                        PosCount = PosCount + 1
                    Next

                ElseIf CurrentCheck = 15 And Form1.Combo1.ListIndex = 17 Then
                    PosCount = 0
                    'Print #1, "Position in " + Trim(StraiName(TypeSeqNumber)) + ", Recombination breakpoint number (" & Trim(Str(BSStepWin)) & "nt win), Upper 99% CI, Lower 99% CI, Upper 95% CI, Lower 95% CI"
                    Print #1, "Position in alignment" + ", Recombination breakpoint number (" & Trim(Str(BSStepWin)) & "nt win), Upper 99% CI, Lower 99% CI, Upper 95% CI, Lower 95% CI"
                    
                    NSites = (GPrintLen / 2)
                    For PosCount = 0 To (GPrintLen / 2) - 1
                        
                      
                            'GPrint(0, X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
                            'GPrint(0, NSites * 2 - X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
                            'GPrintPos(0, X) = X + 1 'PltPos(X)
                            'GPrintPos(0, NSites * 2 - X) = X + 1 ' PltPos(X)
                       
                        Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(2, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(0, GPrintLen - PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(1, GPrintLen - PosCount))
                        PosCount = PosCount + 1
                    Next
                    FF = FreeFile
                    If ORFFlag > 0 Then
                        
                        Open sFName$ + "ORFCoords.csv" For Output As #FF
                        Print #FF, "Start,Stop,Gene symbol"
                        For x = 1 To GeneNumber
                            Print #FF, Str(GeneList(x).StartInAlign) + "," + Str(GeneList(x).EndInAlign) + "," + GeneList(x).Name ', GeneList(x).Product
                        Next x
                        Close #FF
                    End If
                    
                    Open sFName$ + "BreakpointPositions.csv" For Output As #FF
                    Print #FF, "Breakpoint position"
                    For x = 1 To UBound(GVarPos, 2)
                        If GVarPos(0, x) > 0 Then
                            Print #FF, Str(GVarPos(0, x))
                        End If
                    Next x
                    Close #FF
                   ' XX = CurDir
                    x = x
                ElseIf CurrentCheck = 17 Or (CurrentCheck = 15 And Form1.Combo1.ListIndex = 18) Then
                    PosCount = 0
                    Print #1, "Position in alignment, Recombination breakpoint clustering log(p-val) (" & Trim(Str(BSStepWin)) & "nt win), Upper 99% CI, Lower 99% CI, Upper 95% CI, Lower 95% CI"
                   ' Print #1, "Position in " + Trim(StraiName(TypeSeqNumber)) + ", Recombination breakpoint clustering log(p-val) (" & Trim(Str(BSStepWin)) & "nt win), Upper 99% CI, Lower 99% CI, Upper 95% CI, Lower 95% CI"
                    
                    NSites = (GPrintLen / 2)
                    For PosCount = 0 To (GPrintLen / 2) - 1
                        
                        
                            'GPrint(0, X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
                            'GPrint(0, NSites * 2 - X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
                            'GPrintPos(0, X) = X + 1 'PltPos(X)
                            'GPrintPos(0, NSites * 2 - X) = X + 1 ' PltPos(X)
                       
                        Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(2, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(0, GPrintLen - PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(1, GPrintLen - PosCount))
                        PosCount = PosCount + 1
                    Next
                    FF = FreeFile
                    If ORFFlag > 0 Then
                        
                        Open sFName$ + "ORFCoords.csv" For Output As #FF
                        Print #FF, "Start,Stop,Gene symbol"
                        For x = 1 To GeneNumber
                            Print #FF, Str(GeneList(x).StartInAlign) + "," + Str(GeneList(x).EndInAlign) + "," + GeneList(x).Name ', GeneList(x).Product
                        Next x
                        Close #FF
                    End If
                    
                    Open sFName$ + "BreakpointPositions.csv" For Output As #FF
                    Print #FF, "Breakpoint position"
                    For x = 1 To UBound(GVarPos, 2)
                        If GVarPos(0, x) > 0 Then
                            Print #FF, Str(GVarPos(0, x))
                        End If
                    Next x
                    Close #FF
                ElseIf CurrentCheck = 3 Then
                    PosCount = 1

                    Do

                        If PosCount > Len(StrainSeq(0)) - 3 Then
                            Exit Do
                        ElseIf MCPrintPos(PosCount) = 0 Then
                            Exit Do
                        ElseIf (MCPrintPos(PosCount)) > Len(StrainSeq(0)) Then
                            Exit Do
                        End If

                        Print #1, CStr(MCPrintPos(PosCount) - MCOverlapR) & "," & CStr(MCPrintData(0, PosCount)) & "," & CStr(MCPrintData(1, PosCount)) & "," & CStr(MCPrintData(2, PosCount))
                        PosCount = PosCount + 1
                    Loop

                ElseIf CurrentCheck = 4 Then
                    For PosCount = 0 To GPrintLen

                           

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(2, PosCount))
                            End If

                            'Exit Sub
                        Next
                ElseIf CurrentCheck = 55 Then 'the BURT plot
                    x = x
                ElseIf CurrentCheck = 10 Then
                    Print #1, "Position in alignment" & "," & OriginalName(tSeq1)
                    For PosCount = 1 To GPrintLen

                           If CStr(GPrintPos(0, PosCount)) = -100 Then Exit For

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount))
                            End If

                            
                        Next
                        Print #1, "Position in alignment" & "," & OriginalName(tSeq2)

                        For PosCount = 1 To GPrintLen

                           
                            If CStr(GPrintPos(1, PosCount)) = -100 Then Exit For
                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(1, PosCount)) & "," & CStr(GPrint(1, PosCount))
                            End If

                            
                        Next
                        Print #1, "Position in alignment" & "," & OriginalName(tSeq3)

                        For PosCount = 1 To GPrintLen

                           

                            If PosCount > 0 Then
                                If CStr(GPrintPos(2, PosCount)) = -100 Then Exit For
                                Print #1, CStr(GPrintPos(2, PosCount)) & "," & CStr(GPrint(2, PosCount))
                            End If

                            
                        Next
                ElseIf CurrentCheck = 16 Then
                    Print #1, "Position in alignment" & "," & OriginalName(tSeq1) & "," & "Permutation upper bound" & "," & "Permutation lower bound"
                    For PosCount = 1 To (GPrintLen - 2) / 2
                        'GPrintLen = NSites * 2 + 2
                        'GPrint(3, X) = PermRangeS1(0, X) 'GraphPlt(1, X)
                        'GPrint(3, NSites * 2 - X) = PermRangeS1(1, X) 'GraphPlt(2, X)
                           If CStr(GPrintPos(0, PosCount)) = 0 And CStr(GPrint(0, PosCount)) = 0 Then Exit For

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(3, PosCount)) & "," & CStr(GPrint(3, (GPrintLen - 2) - PosCount))
                            End If

                            
                        Next
                        Print #1, "Position in alignment" & "," & OriginalName(tSeq2) & "Permutation upper bound" & "," & "Permutation lower bound"

                        For PosCount = 1 To (GPrintLen - 2) / 2

                           
                            If CStr(GPrintPos(1, PosCount)) = 0 And CStr(GPrint(1, PosCount)) = 0 Then Exit For
                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(1, PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(4, PosCount)) & "," & CStr(GPrint(4, (GPrintLen - 2) - PosCount))
                            End If

                            
                        Next
                        Print #1, "Position in alignment" & "," & OriginalName(tSeq3) & "Permutation upper bound" & "," & "Permutation lower bound"

                        For PosCount = 1 To (GPrintLen - 2) / 2

                           

                            If PosCount > 0 Then
                                If CStr(GPrintPos(2, PosCount)) = 0 And CStr(GPrint(2, PosCount)) = 0 Then Exit For
                                Print #1, CStr(GPrintPos(2, PosCount)) & "," & CStr(GPrint(2, PosCount)) & "," & CStr(GPrint(5, PosCount)) & "," & CStr(GPrint(5, (GPrintLen - 2) - PosCount))
                            End If

                            
                        Next
                ElseIf CurrentCheck = 5 Then
                    Print #1, "Position in alignment,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,S1,S2,S3,S4,S5,S6,S7,S8,S9"
                    
                    Z = 0
                    For x = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                        
                        OutString = Str(GPrintPos(0, Z))
                        For Y = 1 To 15
                            OutString = OutString + "," + Str(GPrint(Y - 1, Z))
                        Next Y
                        For Y = 1 To 9
                            OutString = OutString + "," + Str(GPrint(Y + 14, Z))
                        Next Y
                        Print #1, OutString
                        Z = Z + 1
                    Next 'X
                
                ElseIf CurrentCheck = 6 Then
                    
                    If GPrintType = 0 Then
                        Print #1, "Position in alignment, Log likelihood ratio"
                        For x = 0 To GPrintLen
                            Print #1, CStr(GPrintPos(0, x)) + "," + CStr(GPrint(0, x))
                        Next x
                    Else
                        Print #1, "Start Position in alignment, End Position in alignment,Log likelihood ratio"
                        For x = 0 To GPrintLen
                            Print #1, CStr(GPrintPos(0, 0, x)) + "," + CStr(GPrintPos(0, 1, x)) + "," + CStr(GPrint(0, x))
                        Next x
                    End If
                    

                ElseIf CurrentCheck = 7 Or CurrentCheck = 22 Then

                    Dim tempdata() As Double

                    ReDim temppos(Len(StrainSeq(0)))
                    ReDim tempdata(10, Len(StrainSeq(0)))
                    Print #1, "Position in alignment, Compatibility Matrix , Randomised 1 , Randomised 2, Randomised 3, Randomised 4, Randomised 5, Randomised 6, Randomised 7, Randomised 8, Randomised 9, Randomised 10"

                    For Y = 1 To 10
                        Offst = Int((10 - Y) * step)

                        For x = 0 To EndY - 1

                            If x + Offst > EndY - 1 Then
                                Z = x + Offst - EndY

                                If Z = 0 Then
                                    tempdata(Y, Z) = RetPlot(Y, x)
                                End If

                            Else
                                Z = x + Offst
                            End If

                            'PosCount = PosCount + 1
                            tempdata(Y, Z) = RetPlot(Y, x)
                        Next 'X

                    Next 'Y

                    For x = 0 To EndY - 1
                        'PosCount = PosCount + 1
                        Print #1, CStr(RetXPos(x)) & "," & CStr(RetPlot(0, x)) & "," & CStr(tempdata(1, x)) & "," & CStr(tempdata(2, x)) & "," & CStr(tempdata(3, x)) & "," & CStr(tempdata(4, x)) & "," & CStr(tempdata(5, x)) & "," & CStr(tempdata(6, x)) & "," & CStr(tempdata(7, x)) & "," & CStr(tempdata(8, x)) & "," & CStr(tempdata(9, x)) & "," & CStr(tempdata(10, x))
                    Next 'X

                ElseIf CurrentCheck = 8 Then
                    PosCount = 1

                    Do

                        If PosCount > Len(StrainSeq(0)) - 3 Then
                            Exit Do
                        ElseIf MCPrintPos(PosCount + 3) = 0 Then
                            Exit Do
                        ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                            Exit Do
                        End If

                        If MCPrintPos(PosCount) > MCOverlapR + 2 And PosCount > 0 Then
                            Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr((((MCPrintData(0, PosCount) / MaxDistX)))) & "," & CStr((((MCPrintData(1, PosCount) / MaxDistX)))) & "," & CStr((((MCPrintData(2, PosCount) / MaxDistX))))
                        End If

                        PosCount = PosCount + 1
                    Loop
                ElseIf CurrentCheck = 10 Then
                    MsgBox ("This option hasn't been added yet but will be avaiable soon")
                ElseIf CurrentCheck = 11 Then
                    MsgBox ("This option hasn't been added yet but will be avaiable soon")
                ElseIf CurrentCheck = 9 Then
                    Header = "Position in Alignment, TOPAL Scan"

                    For x = 1 To TOPerms
                        Header = Header + ",Permutation " + Trim$(CStr(x))
                    Next 'X

                    Print #1, Header
                    PlotPos = Int((TOWinLen + TOStepSize * (TOSmooth - 1)) / 2)
                    Y = 0

                    Do While PlotPos < Len(StrainSeq(0))
                        Header = ""
                        Header = Header + Str(PlotPos)

                        For x = 0 To TOPerms
                            Header = Header + "," + Trim$(CStr(SmoothDSS(x, Y)))
                        Next 'X

                        Print #1, Header
                        PlotPos = PlotPos + TOStepSize
                        Y = Y + 1
                    Loop

                ElseIf CurrentCheck = 23 Then

                    If tSeq1 <> tSeq2 Then
                        Print #1, "Position in alignment," & OriginalName(tSeq1) & "-" & OriginalName(tSeq2)
                    Else
                        Print #1, "Position in alignment," & OriginalName(tSeq1) & "-" & OriginalName(tSeq3)
                    End If

                    PosCount = 1

                    Do

                        If PosCount > Len(StrainSeq(0)) - 3 Then
                            Exit Do
                        ElseIf MCPrintPos(PosCount + 3) = 0 Then
                            Exit Do
                        ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                            Exit Do
                        End If

                        Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr((((MCPrintData(PosCount) / MaxDistX))))
                        PosCount = PosCount + 1
                    Loop

                ElseIf CurrentCheck = 20 Then
                    CurPPos = 0
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & " -Log 10 (Probability)"

                    Do While MCPrintData(CurPPos) > 0
                        Print #1, CStr(MCPrintPos(CurPPos, 0)) & "," & CStr(MCPrintPos(CurPPos, 1)) & "," & CStr(MCPrintData(CurPPos))
                        CurPPos = CurPPos + 1
                    Loop
                    
                ElseIf CurrentCheck = 21 Then
                    Print #1, "Position in alignment" & "," & OriginalName(tSeq1) & " - " & OriginalName(tSeq2)
                    For PosCount = 1 To LenXoverSeq
                            Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr(-Log10(MCPrintData(PosCount)))
                    Next


                End If

            ElseIf RelX > 0 Or RelY > 0 Then

                If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then

                    For x = 0 To LenXoverSeq
                        Print #1, XDiffPos(x) & "," & XOverHomologyNum(x, 0) & "," & XOverHomologyNum(x, 1) & "," & XOverHomologyNum(x, 2)
                    Next 'X
                 ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
                    Print #1, "Position in alignment" & "," & OriginalName(Abs(CLng(XoverList(RelX, RelY).Daughter))) & " as recombinant and " & OriginalName(tSeq2) & " and "; OriginalName(tSeq3) & " as parents" & "," & "Permutation upper bound" & "," & "Permutation lower bound"
                    For PosCount = 1 To (GPrintLen - 2) / 2
                        'GPrintLen = NSites * 2 + 2
                        'GPrint(3, X) = PermRangeS1(0, X) 'GraphPlt(1, X)
                        'GPrint(3, NSites * 2 - X) = PermRangeS1(1, X) 'GraphPlt(2, X)
                           If CStr(GPrintPos(0, PosCount)) = 0 And CStr(GPrint(0, PosCount)) = 0 Then Exit For

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(1, (GPrintLen - 2) - PosCount))
                            End If

                            
                        Next
                        
                    
                ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                    Print #1, "Position in alignment,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,S1,S2,S3,S4,S5,S6,S7,S8,S9"
                    
                    Z = 0
                    For x = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                        
                        OutString = Str(GPrintPos(0, Z))
                        For Y = 1 To 15
                            OutString = OutString + "," + Str(GPrint(Y - 1, Z))
                        Next Y
                        For Y = 1 To 9
                            OutString = OutString + "," + Str(GPrint(Y + 14, Z))
                        Next Y
                        Print #1, OutString
                        Z = Z + 1
                    Next 'X
                ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                    PosCount = 1
                    
                    
                    TempS = "Position in Alignment"
                    
                    For x = 0 To NumberOfSeqs
                        TempS = TempS + "," & OriginalName(RevSeq(x))
                    Next x
                    Print #1, TempS
                    For PosCount = 1 To LenXoverSeq
    
    
                        TempS = CStr(XDiffPos(PosCount))
    
                        For x = 0 To NumberOfSeqs
                            TempS = TempS + "," + CStr(PPWinScore(PosCount, x))
                        Next 'X
    
                        Print #1, TempS 'Str$(PltPos(PosCount) - MCOverlapR) & "," & cstr(MCPrintData(0, PosCount)) & "," & cstr(MCPrintData(1, PosCount)) & "," & cstr(MCPrintData(2, PosCount))
                        
                    Next 'poscount
                ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
                    ttseq1 = tSeq1
                    ttseq2 = tSeq2
                    ttseq3 = tSeq3
                    tSeq1 = Abs(CLng(XoverList(RelX, RelY).DHolder))
                        If tSeq1 = ttseq1 Then
                            tSeq2 = ttseq2
                            tSeq3 = ttseq3
                        ElseIf tSeq1 = ttseq2 Then
                            tSeq2 = ttseq1
                            tSeq3 = ttseq3
                        ElseIf tSeq1 = ttseq3 Then
                            tSeq2 = ttseq1
                            tSeq3 = ttseq2
                        End If
                    Print #1, "Position in alignment" & "," & OriginalName(Abs(CLng(XoverList(RelX, RelY).DHolder))) & " as recombinant and " & OriginalName(tSeq2) & " and "; OriginalName(tSeq3) & " as parents"
                    For PosCount = 1 To LenXoverSeq - 1
                            If PosCount > 0 Then
                                Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr(-Log10(MCPrintData(PosCount)))
                            End If
                    Next
                    tSeq1 = ttseq1
                    tSeq2 = ttseq2
                    tSeq3 = ttseq3
                ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                    CurPPos = 0
                    Print #1, "Start Position in alignment" & "," & "End Position in alignment" & "," & " -Log 10 (Probability)"

                    Do While MCPrintData(CurPPos) > 0
                        Print #1, CStr(MCPrintPos(CurPPos, 0)) & "," & CStr(MCPrintPos(CurPPos, 1)) & "," & CStr(MCPrintData(CurPPos))
                        CurPPos = CurPPos + 1
                    Loop

                ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
                    PosCount = 1

                    Do

                        If PosCount > Len(StrainSeq(0)) - 3 Then
                            Exit Do
                        ElseIf MCPrintPos(PosCount) = 0 Then
                            Exit Do
                        ElseIf (MCPrintPos(PosCount)) > Len(StrainSeq(0)) Then
                            Exit Do
                        End If

                        Print #1, CStr(MCPrintPos(PosCount) - MCOverlapR) & "," & CStr(MCPrintData(0, PosCount)) & "," & CStr(MCPrintData(1, PosCount)) & "," & CStr(MCPrintData(2, PosCount))
                        PosCount = PosCount + 1
                    Loop

                ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then

                    If MCTripletFlag = 0 Then
                        For PosCount = 0 To GPrintLen

                           

                            If PosCount > 0 Then
                                Print #1, CStr(GPrintPos(0, PosCount)) & "," & CStr(GPrint(0, PosCount)) & "," & CStr(GPrint(1, PosCount)) & "," & CStr(GPrint(2, PosCount))
                            End If

                            'Exit Sub
                        Next
                        
                    
                    Else
                        For PosCount = 1 To LenXoverSeq

                            Print #1, CStr(MCPrintPos(PosCount)) & "," & CStr(-Log10(MCPrintData(PosCount)))
                            

                            
                        Next

                    End If

                End If
            

            End If

        End If

        Close #1
    End If

    Screen.MousePointer = 0
End Sub

Private Sub SCHEMAMnu_Click()
If PermPDBNo = -1 Then
    
    MsgBox ("You must first load at least one atomic coordinate (.pdb) file")
    Call Command1_Click
    If PermPDBNo = -1 Then Exit Sub
    
    
    
    
End If

If SEventNumber = 0 Then
    Call Command22_Click
    If SEventNumber > 0 Then
        Call SCHEMA
    Else
        If CLine = "" Or CLine = " " Then
            MsgBox ("There are no detectable recombination events in this alignment.")
        End If
    End If
Else
    Call SCHEMA
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog



End Sub

Private Sub SelEventMnu_Click()
Form1.Enabled = False


'put everything back the way it was
Form7.Caption = "Select Event Number"
OSM = Form1.ScaleMode
Form1.ScaleMode = 1
If GTCS = -4 Or GTCS = -20 Then
    Form7.Top = Form1.SSPanel6(0).Top
    Form7.Left = Form1.SSPanel6(0).Left
ElseIf GTCS = -10 Then
    Form7.Top = Form1.Command22.Top
    Form7.Left = Form1.Command22.Left
'ElseIf GTCS = -20 Then
'    Form7.Top = Form1.SSPanel16.Top
'    Form7.Left = Form1.SSPanel16.Left
Else
    Form7.Top = Form1.SSPanel5.Top
    Form7.Left = Form1.SSPanel5.Left
End If
Form1.ScaleMode = OSM
F7Flag = 1
Form7.ScaleMode = 3
Form7.ScaleHeight = 50
Form7.Label1(0).Top = 5
Form7.Label1(1).Top = Form7.Label1(0).Top
Form7.Text1(0).Top = Form7.Label1(0).Top
Form7.Text1(1).Top = Form7.Label1(0).Top
Form7.Command1(0).Top = Form7.Text1(0).Top + Form7.Text1(0).Height + 5
Form7.Command1(1).Top = Form7.Command1(0).Top
Form7.Label1(0).Width = 60
Form7.Label1(1).Width = Form7.Label1(0).Width
Form7.Text1(0).Width = 50
Form7.Text1(1).Width = Form7.Text1(0).Width
Form7.Command1(0).Width = Form7.Text1(0).Width
Form7.Command1(1).Width = Form7.Text1(0).Width
Form7.ScaleMode = 3
Form7.Label1(0).Left = 5
Form7.ScaleMode = 3
Form7.Text1(0).Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5

'If X = 12345 Then
Form7.Label1(1).Left = Form7.Text1(0).Left + Form7.Text1(0).Width + 5
Form7.Text1(1).Left = Form7.Label1(1).Left + Form7.Label1(1).Width + 5
Form7.Command1(0).Left = Form7.Text1(1).Left
Form7.Command1(1).Left = Form7.Command1(0).Left + Form7.Command1(0).Width
Form7.Label1(0).Caption = "Go to event"
Form7.Label1(1).Caption = ""
Form7.Text1(0).Text = "" 'SuperEventList(XOverList(RecSeq, PAVal).Eventnumber)
Form7.Text1(1).Visible = False


Form7.Text1(0).ZOrder

Form7.Combo1.Visible = False
    
'End If
Form7.Caption = "Select Events"
Form7.Visible = True
Form7.Text1(0).Visible = True
Form7.Text1(0).SetFocus
CIndex = 1
End Sub

Private Sub SelGrpMniu_Click()
If SelGrpFlag = 1 Then
    SelGrpFlag = 0
    SelGrpMniu.Checked = 0
    SelGrpMnu.Checked = 0
Else
    SelGrpFlag = 1
    SelGrpMniu.Checked = 1
    SelGrpMnu.Checked = 1
End If
Call PrintNames
End Sub

Private Sub SelGrpMnu_Click()
Call SelGrpMniu_Click
End Sub

Private Sub SelRefMnu_Click()
    ReDim TempMaskseq(PermNextno)
    For x = 0 To PermNextno
        TempMaskseq(x) = MaskSeq(x)
        MaskSeq(x) = 0
    Next x
    Call UpdateSelectRefs
    x = x
End Sub

Private Sub SHMatrixMnu_Click()


If NextNo >= 3 Then
If ButtonScrollFlag = 0 And CurMatrixFlag = 12 Then DoneMatX(12) = 0
    CurMatrixFlag = 12
    Call SHMatrix
    'Call RFMatrix
    CurMatrixFlag = 12
    Form1.Check1.Enabled = False
    Call DoMatCap
    SSPanel6(2).Enabled = True
    SSPanel6(2).Enabled = True
    If F1MDF = 0 Then
        SSPanel6(2).Visible = True
        SSPanel6(0).Visible = False
        SSPanel6(1).Visible = False
    End If
    If (MatZoom(CurMatrixFlag) + 0.5) * Picture26.ScaleHeight - Picture26.ScaleHeight <= 32000 Then
        Command39(1).Enabled = True
    End If
    Command39(0).Enabled = True
End If

End Sub

Private Sub ShowAllAllMnu_Click()
MenuUpFlag = 0


For x = 0 To NextNo
 ShowAllHits(x) = 1
Next x



'Call UpdateScheme
Call IntegrateXOvers(0)
Timer1.Enabled = True
x = x
End Sub

Private Sub ShowAllMnu_Click()
MenuUpFlag = 0
'RecSeq = SERecSeq
RecSeq = tRecSeqX
If ShowAllHits(RecSeq) = 0 Then
    ShowAllHits(RecSeq) = 1
Else
    ShowAllHits(RecSeq) = 0
End If



'Call UpdateScheme
Call IntegrateXOvers(0)
Form1.Timer1.Enabled = True
x = x
End Sub

Private Sub ShowBestAllMnu_Click()
MenuUpFlag = 0


For x = 0 To NextNo
 ShowAllHits(x) = 0
Next x



'Call UpdateScheme
Call IntegrateXOvers(0)
End Sub

Private Sub SkipAcceptedMnu_Click()
If SkipAcceptedMnu.Checked = False Then
    SkipAcceptedMnu.Checked = True
    Command5.ToolTipText = "Go to previous unaccepted event"
    Command9.ToolTipText = "Go to next unaccepted event"
    GoToNextEventMnu.Caption = "Go to next unaccepted event             Pg Dn"
    GoToPreviousEventMnu.Caption = "Go to previous unaccepted event       Pg Up"
    
Else
    SkipAcceptedMnu.Checked = False
    Command5.ToolTipText = "Go to previous event"
    Command9.ToolTipText = "Go to next event"
    GoToNextEventMnu.Caption = "Go to next event                        Pg Dn"
    GoToPreviousEventMnu.Caption = "Go to previous event                  Pg Up"
End If
End Sub

Private Sub SkipRejectedMnu_Click()
If SkipRejectedMnu.Checked = False Then
    SkipRejectedMnu.Checked = True
Else
    SkipRejectedMnu.Checked = False
End If

End Sub

'Private Sub Slider1_Scroll()
'Dim oWin As Long
'If RelX > 0 And RelY > 0 Then
'    If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
'
'
'        Seq1 = XoverList(RelX, RelY).MajorP
'        Seq2 = XoverList(RelX, RelY).MinorP
'        Seq3 = XoverList(RelX, RelY).Daughter
'        oWin = XOverWindowX
'        XX = Slider1.MaX
'        XX = Slider1.Min
'        'XOverWindowX = oWin * Slider1.Value
'        'Call XOverIII(0)
'
'    End If
'End If

'End Sub

Private Sub SplitAliMnu_Click()
Dim SeqGrp() As Long, XP As Long, YP As Long, SES() As String, AcceptC(2) As Byte, AName As String, EName As String
ReDim SeqGrp(NextNo, NextNo), SES(NextNo)
If SaveTxtFlag = 1129 Then
    AName = InFileX
Else
   
    With Form1.CommonDialog1
        .FileName = ""
        .DefaultExt = "fas"
        .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas||Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
        .FilterIndex = 1
        .Action = 2 'Specify that the "open file" action is required.
        AName = .FileName  'Stores selected file name in the
        ANameII = .FileTitle
    End With

End If
For x = 0 To NextNo
    For Y = 0 To NextNo
        SeqGrp(x, Y) = -1
    Next Y
Next x


GoOn = 0
'For X = 0 To PermNextNo
'    For Y = 1 To CurrentXOver(X)
'        If XOverList(X, Y).Accept = 1 Then
'            GoOn = 1
'            Exit For
'        End If
'    Next Y
'    If GoOn = 1 Then Exit For
' Next X
'If GoOn = 1 Then
'    Response = MsgBox("Would you like to only account for those recombination signals that have been manually 'accepted' (i.e. those depicted by a coloured block with a red border in the bottom right program panel)?  If you would like to take every detected recombination signal into account (i.e. those that are either accepted or unaccepted) then press 'No'", vbYesNo)
'Else
'    Response = 7
'    '6=yes, 7=no
'End If

Call MakeAcceptC(23, AcceptC())

For x = 1 To SEventNumber
    XP = BestEvent(x, 0)
    YP = BestEvent(x, 1)
    If AcceptC(XoverList(XP, YP).Accept) = 1 Then
        For Y = 0 To PermNextno
            If Daught(x, Y) > 0 Then
                SES(Y) = SES(Y) + Trim(Str(x)) + " "
                x = x
            End If
        Next Y
    End If
Next x


Dim DS() As Byte, NumCat As Long, TName As String, FF As Long
ReDim DS(NextNo)
NumCat = 0
FF = FreeFile
If Len(AName) > 4 Then
    TName = Left(AName, Len(AName) - 4)
Else
    Form1.SSPanel1.Caption = ""
    Exit Sub
End If
EName = Right(AName, 4)
Form1.SSPanel1.Caption = "Splitting alignment into sub-alignments"

Dim TempName() As String, SNum
Dim TempSeq() As String

Dim GetStringA As String

For x = 0 To NextNo
    If DS(x) = 0 Then
        
        AName = TName + Trim(Str(NumCat)) + EName
        NumSeqs = 0
        For Y = x + 1 To NextNo
            If DS(Y) = 0 Then
                If SES(x) = SES(Y) Then
                    NumSeqs = NumSeqs + 1
                End If
            End If
        Next Y
        ReDim TempName(NumSeqs)
        ReDim TempSeq(NumSeqs)
        
        NumCat = NumCat + 1
        SNum = 0
        For Y = x To NextNo
            If DS(Y) = 0 Then
                If SES(x) = SES(Y) Then
                    DS(Y) = 1
                    TempName(SNum) = OriginalName(Y)
                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                        TempSeq(SNum) = StrainSeq(Y)
                    Else
                        If DebuggingFlag < 2 Then On Error Resume Next
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        On Error GoTo 0
                        
                            
                        FN = FreeFile
                        Open BIGFilename For Binary Access Read As FN
                        GetStringA = String(BigFileOffsets(Y, 1) - BigFileOffsets(Y, 0), " ")
                        Get #FN, BigFileOffsets(Y, 0), GetStringA
                        TempSeq(SNum) = GetStringA
                        Close #FN
                        'Exit Sub
                        
                        If DebuggingFlag < 2 Then On Error Resume Next
                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
        
                    End If
                    SNum = SNum + 1
                End If
            End If
        Next Y
        DS(x) = 1
        Call WriteAlignFile(NumSeqs, AName, TempName(), TempSeq())
    End If
    Form1.ProgressBar1.Value = (x / NextNo) * 100
    If NumCat = 1 Then
        Form1.SSPanel1.Caption = Str(NumCat) + " unique mosaic detected"
    Else
        Form1.SSPanel1.Caption = Str(NumCat) + " unique mosaics detected"
    End If
    Call UpdateF2Prog
Next x

Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub SSPanel1_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
'If CurrentlyRunningFlag = 1 Then Exit Sub
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel10_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
HSCrollInc = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
Picture3.Refresh
Picture2.Refresh
If Picture6.Enabled = True And CurFlash = 1 Then
    Picture6.Refresh
    CurFlash = 0
End If
    If RunFlag = 1 Or ManFlag >= 0 Then
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
        
    End If
    
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If

End Sub

Private Sub SSPanel11_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
Picture3.Refresh
    Picture2.Refresh
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub SSPanel12_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel13_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel14_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel15_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel16_Click()
HSCrollInc = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If SEventNumber > 0 Then
    GTCS = -20
    Call SelEventMnu_Click
End If
End Sub

Private Sub SSPanel16_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If SEventNumber > 0 Then
    SSPanel16.MouseIcon = Command1.MouseIcon
    SSPanel16.MousePointer = 99
    SSPanel16.ToolTipText = "Click to select event"
    
Else
    
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    SSPanel16.MousePointer = 0
    SSPanel16.ToolTipText = ""
End If
End Sub

Private Sub SSPanel2_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub SSPanel3_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    HSCrollInc = 0
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    If PositionIndicaterOn = 0 Then
        DontDoH1Inc = 1
        PositionIndicaterOn = 0
        OnlyDoPositionIndicator = 1
        Call HScroll1_Change
        OnlyDoPositionIndicator = 0
        DontDoH1Inc = 0
    End If
    Curgene = 0: Call CheckUnFlash
    Picture3.Refresh
    Picture2.Refresh
    LastY3 = -1
    Picture3.MousePointer = 0
    P1Seq = -1
    P1NT = -1
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub SSPanel4_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    HSCrollInc = 0
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    If PositionIndicaterOn = 0 Then
        DontDoH1Inc = 1
        PositionIndicaterOn = 0
        OnlyDoPositionIndicator = 1
        Call HScroll1_Change
        OnlyDoPositionIndicator = 0
        DontDoH1Inc = 0
    End If
    Curgene = 0: Call CheckUnFlash
    Label15.Caption = ""
    Picture3.Refresh
    Picture2.Refresh
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub SSPanel5_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
    If PositionIndicaterOn = 0 Then
        DontDoH1Inc = 1
        PositionIndicaterOn = 0
        OnlyDoPositionIndicator = 1
        Call HScroll1_Change
        OnlyDoPositionIndicator = 0
        DontDoH1Inc = 0
    End If
Curgene = 0: Call CheckUnFlash
Picture3.Refresh
Picture2.Refresh
P1Seq = -1
P1NT = -1
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
End Sub

Private Sub SSPanel6_MouseMove(Index As Integer, Button As Integer, Shift As Integer, x As Single, Y As Single)
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
If Form2OnTopFlag = 1 Then
    Dummy = SetTopMostWindow(Form2.hwnd, False)
    Form2OnTopFlag = 0
End If
Picture3.Refresh
Picture2.Refresh
P1Seq = -1
P1NT = -1
Timer3.Enabled = False
If Index = 2 Then
    For x = 0 To 2
    Label7(x).Caption = "--"
    Next x
End If
End Sub

Private Sub SSPanel7_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
HSCrollInc = 0
RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
If PositionIndicaterOn = 0 Then
    DontDoH1Inc = 1
    PositionIndicaterOn = 0
    OnlyDoPositionIndicator = 1
    Call HScroll1_Change
    OnlyDoPositionIndicator = 0
    DontDoH1Inc = 0
End If
Curgene = 0: Call CheckUnFlash
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
    Screen.MousePointer = 0
End If
End Sub

Private Sub SSPanel8_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
    If CurrentlyRunningFlag = 1 Then Exit Sub
    If SchemDownFlag = 1 Then Exit Sub
    RecSeq = 0
    PAVal = 0: PermXVal = 0: PermYVal = 0
    If Form2OnTopFlag = 1 Then
        Dummy = SetTopMostWindow(Form2.hwnd, False)
        Form2OnTopFlag = 0
    End If
    P1Seq = -1
    P1NT = -1
    HSCrollInc = 0
    If PositionIndicaterOn = 0 Then
        DontDoH1Inc = 1
        PositionIndicaterOn = 0
        OnlyDoPositionIndicator = 1
        Call HScroll1_Change
        OnlyDoPositionIndicator = 0
        DontDoH1Inc = 0
    End If
    Curgene = 0: Call CheckUnFlash
    Label1.Caption = ""
    If Picture6.Enabled = True And CurFlash = 1 Then
        Picture6.Refresh
         CurFlash = 0
    End If
    If RunFlag = 1 Or ManFlag >= 0 Then
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
        Picture3.Refresh
        Picture2.Refresh
    End If
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    Dim AxLen As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    AxLen = -1
    AxLen = GYAxHi(1)
    On Error GoTo 0
    If AxLen > 0 And p7CurWinSize > 0 Then
        If x > Picture10.Left + Picture10.Width Then
            P7XP = AxLen
            
        ElseIf x <= Picture10.Left + 10 Then
            P7XP = 1
            
        Else
            P7XP = oP7XP
            
        End If
        Call ShrinkZoom
        P7XP = 0
        oP7XP = 0
        Form1.Label1.Caption = ""
        'If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
End Sub

Private Sub SSPanel9_MouseMove(Button As Integer, Shift As Integer, x As Single, Y As Single)
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
    HSCrollInc = 0
    RecSeq = 0
PAVal = 0: PermXVal = 0: PermYVal = 0
    If PositionIndicaterOn = 0 Then
        DontDoH1Inc = 1
        PositionIndicaterOn = 0
        OnlyDoPositionIndicator = 1
        Call HScroll1_Change
        OnlyDoPositionIndicator = 0
        DontDoH1Inc = 0
    End If
    Curgene = 0: Call CheckUnFlash
    If RunFlag = 1 Or ManFlag >= 0 Then
        If BeginFlashval = 0 And EndFlashval = 0 Then
            Picture7.Refresh
        End If
        Picture3.Refresh
        Picture2.Refresh
    End If
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
End Sub

Private Sub SwapMajorMinorMnu_Click()
MenuUpFlag = 0
Form1.WindowState = Form1.WindowState
If DontSaveUndo = 0 Then
    Call SaveUndo
End If




    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
    End If

Dim TBegin As Long, DSeq As Long, TSeq As Long, TProg As Byte, DR As Integer, MiR As Integer, MaR As Integer, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, ENumb As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
    'find which block must end up flashing
    If x = x Then
        'OSEPAVal = SEPAVal
        'DSeq = XOverList(SERecSeq, SEPAVal).Daughter
        'TSeq = XOverlist(SERecSeq, SEPAVal).Daughter
        'TProg = XOverlist(SERecSeq, SEPAVal).ProgramFlag
        'TBegin = XOverlist(SERecSeq, SEPAVal).Beginning
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
        ENumb = SuperEventList(XoverList(SERecSeq, SEPAVal).Eventnumber)
        AXONo = SERecSeq
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
        
        Call FindSameE(InvolvedR, 0, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, BestXOListMi(), BCurrentXoverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, BestXOListMa(), BCurrentXoverMa(), TraceMa(), MajorPar())
        
        
        Call MajMinSwap(TraceNumbD, TraceD(), XoverList())
        Call MajMinSwap(TraceNumbMi, TraceMi(), BestXOListMi())
        Call MajMinSwap(TraceNumbMa, TraceMa(), BestXOListMa())
        
        Call AddEvents(TraceNumbMi, TraceMi(), BCurrentXoverMi(), BestXOListMi(), BCurrentXoverMa(), BestXOListMa())
        Call AddEvents(TraceNumbMa, TraceMa(), BCurrentXoverMa(), BestXOListMa(), BCurrentXoverMi(), BestXOListMi())
        
        Call CleanXOList(ENumb, BestXOListMi(), BCurrentXoverMi(), MinorPar())
        Call CleanXOList(ENumb, BestXOListMa(), BCurrentXoverMa(), MinorPar())
        
        Call SwapInvolved(-1, 1, 2, ENumb, Daught(), MinorPar(), MajorPar(), DScores())
        
        If ExcludedEventNum > 0 Then
            If NumExcludedEventNum > 0 Then
                'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                NF3 = FreeFile
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                Put #NF3, 1, ExcludedEventNum
                Put #NF3, , EventsInExcludeds
                Close #NF3
                ReDim EventsInExcludeds(5, 1000)
                'ExcludedEventNum = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            Dim ChangeMade As Long
            For j = 0 To NumExcludedEventNum
                If NumExcludedEventNum > 0 Then
                    NF3 = FreeFile
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                    Get #NF3, , ExcludedEventNum
                    ReDim EventsInExcludeds(5, ExcludedEventNum)
                    Get #NF3, , EventsInExcludeds
                    Close #NF3
                    'ExcludedEventNum = 1
                    ChDrive oDirX
                    ChDir oDirX
                End If
                    
                ChangeMade = 0
                For x = 0 To UBound(EventsInExcludeds, 2)
                    If EventsInExcludeds(1, x) = -ENumb Then
                        If EventsInExcludeds(0, x) = 1 Then
                            EventsInExcludeds(0, x) = 2
                            Temp = MajorPar(ENumb, EventsInExcludeds(2, x))
                            MajorPar(ENumb, EventsInExcludeds(2, x)) = MinorPar(ENumb, EventsInExcludeds(2, x))
                            MinorPar(ENumb, EventsInExcludeds(2, x)) = Temp
                            
                        ElseIf EventsInExcludeds(0, x) = 2 Then
                            EventsInExcludeds(0, x) = 1
                            Temp = MajorPar(ENumb, EventsInExcludeds(2, x))
                            MajorPar(ENumb, EventsInExcludeds(2, x)) = MinorPar(ENumb, EventsInExcludeds(2, x))
                            MinorPar(ENumb, EventsInExcludeds(2, x)) = Temp
                        End If
                        
                        'XX = OriginalName(EventsInExcludeds(2, x))
                    End If
                Next x
                If ChangeMade = 1 And NumExcludedEventNum > 0 Then
                    NF3 = FreeFile
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                    Put #NF3, 1, ExcludedEventNum
                    Put #NF3, , EventsInExcludeds
                    Close #NF3
                    'ExcludedEventNum = 1
                    ChDrive oDirX
                    ChDir oDirX
                
                End If
            Next j
        End If
        '*****************Need to rearrange NOPINI***********************
       ' For X = 0 To 2
       '     If NOPINI(X, Enumb) = 1 Then
       '         NOPINI(X, Enumb) = 2
       '     ElseIf NOPINI(X, Enumb) = 2 Then
       '         NOPINI(X, Enumb) = 1
       '     End If
       ' Next X
        
        TarSeq = SERecSeq
        AXONoY = -1
        'For X = 0 To NextNo
        '    If Daught(ENumb, X) > 0 And Daught(ENumb, X) < 5 Then
        '        RecSeq = X
        '        Call UpdateScheme
        '
        '    End If
        '    Form1.ProgressBar1 = (X / NextNo) * 100
        'Next X
        Call IntegrateXOvers(0)
        'modify daught, majorp and minorp
        'Use NOPINI to determine which sequences should be Mi and Ma parents
    
        SEPAVal = AXONo
    
        'Call UpdateConfirm(ActiveSeq)
        'Call UpdateConfirm(ActiveMinorP)
        
        If DSeq = RelX And OSEPAVal = RelY Then
            HighlightFlag = 0
            
            OSEPAVal = AXONo
            PermYVal = (AXONoY * 12 + 3) * SpaceAdjust
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            If PressFlag = 1 Then
                    MenuUpFlag = 0
                    Call Picture6_MouseDown(1, 0, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
                End If
                Call ModNextno
                If Form2.Visible = True Then
                    For x = 0 To 3
                        If TTFlag(x, 0) = 1 Then
                            Y = 0
                        ElseIf TTFlag(x, 1) = 1 Then
                            Y = 1
                        ElseIf TTFlag(x, 2) = 1 Then
                            Y = 2
                        ElseIf TTFlag(x, 3) = 1 Then
                            Y = 3
                        ElseIf TTFlag(x, 4) = 1 Then
                            Y = 4
                        End If
                        ExtraDX = DoTreeColour(Form2.Picture2(x), Y, x)
                    Next x
                End If
                Call UnModNextno
                RelX = TSeq
                RelY = AXONo
                exRelX = RelX
                exRely = RelY
                Timer1.Enabled = True
        Else
            DontPutForm2Ontop = 1
            Call Picture6_MouseMove(0, 1, PermXVal, PermYVal - VScroll2.Value * F1VS2Adj)
            DontPutForm2Ontop = 0
            Timer1.Enabled = False
        End If
        If (RelX > 0 Or RelY > 0) And DontRedraw = 0 Then
                PermYVal = 0: PermXVal = 0
                Call GoToThis(1, RelX, RelY, PermXVal, PermYVal)
        End If
        
    End If
    DoneTree(0, 3) = 0
    TreeImage(3) = 0
    DoneTree(1, 3) = 0
    DoneTree(2, 3) = 0
    DoneTree(3, 3) = 0
    DoneTree(4, 3) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Form2.SSPanel1(2).ZOrder
    On Error GoTo 0
    
    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBXOMi = UBound(BestXOListMi, 2)
        UBXoMa = UBound(BestXOListMa, 2)
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
        MiRec = MiRec - 1
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
        MaRec = MaRec - 1
        ChDrive oDirX
        ChDir oDirX
        Erase BestXOListMi
        Erase BestXOListMa
    End If
    

End Sub

Private Sub Timer2_Timer()
    If LoadBusy <> 0 Then
        Exit Sub
    End If
    If DoingShellFlag <> 0 Then
        Exit Sub
    End If
    If CurrentlyRunningFlag <> 0 Then
        Exit Sub
    End If
    If SchemDownFlag <> 0 Then
        Exit Sub
    End If
    If Form3.Visible = True Then
        Form3.ZOrder
    End If
   ' If Form2.Visible = True And F2ontop = 1 Then
   '     Form3.ZOrder
   '     'ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - VScroll2.Value)
   '     Call Picture6_MouseMove(ProxButton, ProxShift, ProxX, ProxY)
   '     F2ontop = 0
   '     'Timer2.Enabled = False
   ' End If
End Sub

Private Sub Timer3_Timer()
'Exit Sub
    If StillLoadingFlag = 1 Then Exit Sub
    If LoadBusy <> 0 Then
        Exit Sub
    End If
    If DoingShellFlag <> 0 Then
        Exit Sub
    End If
    If CurrentlyRunningFlag <> 0 Then
        Exit Sub
    End If
    If SchemDownFlag <> 0 Then
        Exit Sub
    End If
    Dim lHSCroll1Down As Long
    If Timer3.Interval = 25 Then
        Call Command39_Click(0)
    ElseIf Timer3.Interval = 26 Then
        Call Command39_Click(1)
    ElseIf Timer3.Interval = 24 Then
        'Form1.Timer3.Enabled = oF1T3E
        Dim oCurScale As Long
        Form1.Timer3.Interval = oF1T3I
        oCurScale = CurScale
        CurScale = 10
        Call C0Mnu_Click(CInt(oCurScale))
        Form1.Timer3.Enabled = False
        Exit Sub
    ElseIf Timer3.Interval = 27 Then
        H1C = 0
        Call HScroll1_Change
        Exit Sub
    End If
    If NextNo = 0 Then Exit Sub
    
    If sHSCroll1Down > 0 Then
        lHSCroll1Down = Abs(GetTickCount)
        If Abs(lHSCroll1Down - sHSCroll1Down) > 2000 Then
            If HSCrollInc < 10 And HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 1
            ElseIf HSCrollInc < 100 And HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 10
            ElseIf HSCrollInc < 1000 And HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 100
            ElseIf HSCrollInc < 10000 And HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 10000
            ElseIf HSCrollInc < 100000 And HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 50000
            ElseIf HSCrollInc < Decompress(Len(StrainSeq(0))) / 5 Then
                HSCrollInc = HSCrollInc + 100000
            Else
                HSCrollInc = Decompress(Len(StrainSeq(0))) / 5
            End If
            sHSCroll1Down = lHSCroll1Down
            'HSCrollInc = 9
        End If
        
    End If
    If F1MO > 0 Then
    F1MO = 0
Else
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
End If

    
    Exit Sub
    'If (oTwipPerPixX <> Screen.TwipsPerPixelX Or oTwipPerPixY <> Screen.TwipsPerPixelY Or oScreenHeight <> Screen.Height Or oScreenWidth <> Screen.Height) Then Sleep (15000)
'    If CLine = "" Or CLine = " " Then
'        If (oTwipPerPixX <> Screen.TwipsPerPixelX Or oTwipPerPixY <> Screen.TwipsPerPixelY Or oScreenHeight <> Screen.Height Or oScreenWidth <> Screen.Height) Then
'
'            If Form1.WindowState = 2 Then
'                Form1.WindowState = 0
'            ElseIf Form1.WindowState = 1 Then
'                Exit Sub
'            End If
'
'            oScreenHeight = Screen.Height
'            oScreenWidth = Screen.Height
'            oTwipPerPixX = Screen.TwipsPerPixelX
'            oTwipPerPixY = Screen.TwipsPerPixelY
'            'Form1.Visible = False
'
'            Call ResizeForm1
'
'            'Form1.Visible = True
'        End If
'    End If
End Sub

Private Sub Timer4_Timer()
If LoadBusy <> 0 Then
    Exit Sub
End If
If DoingShellFlag > 0 Then
    Exit Sub
End If
If CurrentlyRunningFlag <> 0 Then
    Exit Sub
End If
If SchemDownFlag <> 0 Then
    Exit Sub
End If
If DontDoTimer4Flag = 1 Then
    Exit Sub
End If
If F1MO > 0 Then
    'F1MO = 0
Else
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
End If

If P1MDStart <> -1 Then
    Dim CurTime As Long
    CurTime = Abs(GetTickCount)
    
    If Abs(CurTime - P1MDStart > 500) Then
        Picture12.Visible = True
    End If

End If


'Flashes nts
Dim Rnt As Byte, Gnt As Byte, Bnt As Byte, Rnt2 As Byte, Gnt2 As Byte, Bnt2 As Byte, IncVal As Single, CheckChange As Long, OldValue As Long
CheckChange = 0

If FlashntNum > 0 Then
    x = 1
    SS = Abs(GetTickCount)
    Do
        
        OldValue = Flashnt(3, x)
        If x <> DontFade And Flashnt(2, x) < 1000 Then
            'Flashnt(2, X) = Flashnt(2, X) - 10
            
            'If Flashnt(2, X) > 0 Then 'fade
            If Flashnt(2, x) = 900 Then
                Flashnt(3, x) = Flashnt(5, x)
            End If
            Call ConvertLongToRGB(Flashnt(3, x), Rnt, Gnt, Bnt) 'current colour
            Call ConvertLongToRGB(Flashnt(4, x), Rnt2, Gnt2, Bnt2) 'target colour
            
            If Abs(CLng(Rnt) - CLng(Rnt2)) + Abs(CLng(Gnt) - CLng(Gnt2)) + Abs(CLng(Bnt) - CLng(Bnt2)) > 7 Then
                Call ConvertLongToRGB(Flashnt(4, x), Rnt2, Gnt2, Bnt2) 'target colour
                'CheckChange = 1
                
                If Flashnt(2, x) > 700 Then
                    If Flashnt(2, x) = 800 Then
                        Flashnt(3, x) = RGB(Rnt + (CLng(Rnt2) - CLng(Rnt)) * 0.2, Gnt + (CLng(Gnt2) - CLng(Gnt)) * 0.2, Bnt + (CLng(Bnt2) - CLng(Bnt)) * 0.2)
                    ElseIf Flashnt(2, x) = 900 Then
                        Flashnt(3, x) = RGB(Rnt + (CLng(Rnt2) - CLng(Rnt)) * 0.2, Gnt + (CLng(Gnt2) - CLng(Gnt)) * 0.2, Bnt + (CLng(Bnt2) - CLng(Bnt)) * 0.2)
                    End If
                Else
                    Flashnt(3, x) = RGB(Rnt + (CLng(Rnt2) - CLng(Rnt)) * 0.5, Gnt + (CLng(Gnt2) - CLng(Gnt)) * 0.5, Bnt + (CLng(Bnt2) - CLng(Bnt)) * 0.5)
                End If
            Else
                'erase this nt
                If x = LastntNum Then LastntNum = -1
                If x = DontFade Then DontFade = -1
                If x < FlashntNum Then
                    
                    For Y = 0 To 5
                        Flashnt(Y, x) = Flashnt(Y, FlashntNum)
                    Next Y
                    If DontFade = FlashntNum Then DontFade = x
                    If LastntNum = FlashntNum Then LastntNum = x
                    x = x - 1
                End If
                FlashntNum = FlashntNum - 1
            End If
        End If
        If Flashnt(3, x) <> OldValue Then
            CheckChange = 1
        End If
        x = x + 1
        If x > FlashntNum Then Exit Do
    Loop
    TT = Abs(GetTickCount)
    EE = TT - SS
    
    If (FlashntNum > 1 Or (FlashntNum = 1 And DontFade <> 1)) And (CheckChange = 1 Or FirstFlash > 0) Then
'        FlashntX1 = PrintSeqLen
'        FlashntX2 = 1
'        Dim X2Hold As Long, X1Hold As Long, LB As Long, RB As Long
'        For X = 1 To FlashntNum
'            If Flashnt(0, X) - WinLeft + 1 > 0 And Flashnt(0, X) - WinLeft + 1 <= PrintSeqLen Then
'                If FlashntX2 - WinLeft + 1 < Flashnt(0, X) - WinLeft + 1 Then
'
'                    FlashntX2 = Flashnt(0, X) - WinLeft + 1
'                End If
'                If FlashntX1 - WinLeft + 1 > Flashnt(0, X) - WinLeft + 1 Then
'                    FlashntX1 = Flashnt(0, X) - WinLeft + 1
'                End If
'            End If
'        Next X
''        FlashntX1 = FlashntX1 - WinLeft + 1
''
''        FlashntX2 = FlashntX2 - WinLeft + 1
'        If FlashntX1 < 1 Then FlashntX1 = 1
'        If FlashntX2 < 1 Then FlashntX2 = 1
'        If FlashntX1 > PrintSeqLen Then FlashntX1 = PrintSeqLen
'        If FlashntX2 > PrintSeqLen Then FlashntX2 = PrintSeqLen
        
        DontDoH1Inc = 1
        'OnlyDoPosBar = 1
        OnlyDoFlash = 1
        SS = Abs(GetTickCount)
        'For X = 1 To 1000
        Call HScroll1_Change
        'Next X
        EE = Abs(GetTickCount)
        TT = EE - SS
        OnlyDoFlash = 0
        'OnlyDoPosBar = 0
        DontDoH1Inc = 0
        FirstFlash = FirstFlash - 1
    End If
    GoOn = 0
    
    For x = 0 To PermNextno
        If x <= UBound(BusyFlashing) Then
            If BusyFlashing(x) > 0 Then
                GoOn = 1
            End If
        Else
        
        End If
    Next x
    If GoOn = 0 And FlashntNum = 0 Then Timer4.Enabled = False
    If GoOn = 0 Then Exit Sub
    
End If



If ShowSeqFlag <> 0 Then
    ReDim BusyFlashing(PermNextno)
    Timer4.Enabled = False
    
Else
    If UBound(BusyFlashing, 1) < PermNextno Then
        ReDim Preserve BusyFlashing(PermNextno)
    End If
    For x = 0 To PermNextno
        'If X <= UBound(BusyFlashing, 1) Then
            If BusyFlashing(x) > 0 Then
                If BusyFlashing(x) <= 235 Then
                    BusyFlashing(x) = BusyFlashing(x) + 20
                Else
                    BusyFlashing(x) = 0
                End If
            End If
        
    Next x
    Call PrintNames
    If FlashntNum = 0 Then
        GoOn = 0
        
        For x = 0 To PermNextno
            If BusyFlashing(x) > 0 Then
                GoOn = 1
            End If
        Next x
    Else
        GoOn = 1
    End If
    If GoOn = 0 Then Timer4.Enabled = False
End If

End Sub



Private Sub Timer6_Timer()
If LoadBusy <> 0 Then
    Exit Sub
End If
If DoingShellFlag > 0 Then
    Exit Sub
End If
If CurrentlyRunningFlag <> 0 Then
    Exit Sub
End If
If SchemDownFlag <> 0 Then
     Exit Sub
End If
Form1.Timer6.Enabled = False

If ARFlag > 0 Then
    If ARFlag = 1 Then
         
        'RelY = TRelY
        'RelX = TRelX
        
        SERecSeq = TRelX
        SEPAVal = TRelY
        Call AcceptMnu_Click
        x = x
        'Timer6.Enabled = False
        'Form2.ZOrder
        
        
        'RelY = RRelY
        'RelX = RRelX
    ElseIf ARFlag = 2 Then
        
        Call AcceptSMnu_Click
    ElseIf ARFlag = 3 Then
        SERecSeq = TRelX
        SEPAVal = TRelY
        'RelY = TRelY
        'RelX = TRelX
        Call RejectMnu_Click
        'RelY = RRelY
        'RelX = RRelX
    ElseIf ARFlag = 4 Then
        Call RejectSMnu_Click
    End If
    ARFlag = 0
    
    'For X = 0 To 4
    '    For Y = 0 To 3
    '        If DoneTree(X, Y) = 1 Then
    '
    '
    '        End If
    '    Next Y
    '
    'Next X
    
    
    If F2TreeIndex <> 0 Then
        Call UnModNextno
        x = x
    End If
    
'    For X = 0 To 3
'        If X = 1 Then
'            Call ModNextno
'        Else
'            If X = 3 And (CurTree(X) = 0 Or CurTree(X) = 1) Then
'                Call UnModNextno
'            End If
'        End If
'        Call DoTreeColour(Form2.Picture2(0), CurTree(X), X)
'        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(X).Value, X, CurTree(X), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(X))
'        X = X
'    Next X
    
    Timer6.Enabled = False
    Form2.ZOrder
    ItsFinished = 2
    Exit Sub
End If
If ReassignPFlag > 0 Then
    DontChangeVScrollFlag = 1
    If ReassignPFlag = 1 Then 'swap recombinant with majorp
        SERecSeq = RelX
        SEPAVal = RelY
        
        Call ReassignMajorMnu_Click
        
    ElseIf ReassignPFlag = 2 Then 'swap recombinant with minorp
        SERecSeq = RelX
        SEPAVal = RelY
        Call ReassignMinorMnu_Click
    ElseIf ReassignPFlag = 3 Then 'swap major and minorp
        SERecSeq = RelX
        SEPAVal = RelY
        Call SwapMajorMinorMnu_Click
    End If
    DontChangeVScrollFlag = 0
    Form2.ZOrder
    ReassignPFlag = 0
    DontSaveUndo = 0
    Exit Sub
End If
If (CLine = "" Or CLine = " ") Then

Else
If LoadFileOnStartUpFlag = 1 Then
    LoadFileOnStartUpFlag = 0
    Call Command1_Click
    Exit Sub
ElseIf LoadFileOnStartUpFlag = 2 Then
    Dim oDir As String, FL As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    LoadFileOnStartUpFlag = 0
    InFileX = "LastSave.rdp5"
    frmSplash.Timer1.Enabled = False
    Form1.Enabled = False
    Call Command1_Click
    InFileX = ""
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    Form1.Enabled = True
    frmSplash.Timer1.Enabled = True
    'LoadFileOnStartUpFlag = 1
    'CLine = "EXCEPTION18102002"
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    If DebuggingFlag < 2 Then On Error Resume Next
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End If
End If

F1RF = 1
If F1MDF = 0 Then
    If RedoIntegrateXOversFlag = 1 Then
        GoOn = 0
        If Form1.Width < ((Command12(1).Width * 2.1) + 1000) * 2 + 500 Then
            Form1.Width = ((Command12(1).Width * 2.1) + 1000) * 2 + 500
            GoOn = 1
        End If
        If Form1.Height < Command12(1).Height * 8 + 3000 Then
            Form1.Height = Command12(1).Height * 8 + 3000
            GoOn = 1
        End If
        If GoOn = 1 Then Call ResizeForm1
        RedoIntegrateXOversFlag = 0
        Screen.MousePointer = 0
        Form1.WindowState = Form1.WindowState 'DoEvents 'XXXXXXXXXXXXXXXXXXpotentially dangerous
        Call IntegrateXOvers(0)
        Timer1.Enabled = True
    ElseIf RedoIntegrateXOversFlag > 0 Then
        GoOn = 0
        If Form1.Width < ((Command12(1).Width * 2.1) + 1000) * 2 + 500 Then
            Form1.Width = ((Command12(1).Width * 2.1) + 1000) * 2 + 500
            GoOn = 1
        End If
        If Form1.Height < Command12(1).Height * 8 + 3000 Then
            Form1.Height = Command12(1).Height * 8 + 3000
            GoOn = 1
        End If
        If GoOn = 1 Then Call ResizeForm1
        If RedoIntegrateXOversFlag > 0 Then
            RedoIntegrateXOversFlag = RedoIntegrateXOversFlag - 1
            Timer6.Enabled = True
        Else
            RedoIntegrateXOversFlag = 0
        End If
        
    End If
End If
F1RF = 0
End Sub



Private Sub Timer7_Timer(Index As Integer)
If LoadBusy <> 0 Then
    Exit Sub
End If
If DoingShellFlag <> 0 Then
    Exit Sub
End If
If CurrentlyRunningFlag <> 0 Then
    Exit Sub
End If
If SchemDownFlag <> 0 Then
    Exit Sub
End If
If Index = 0 Then
    Timer7(0).Enabled = False
    If MnuClickFlag = 0 Then
        Call GoToNextEventMnu_Click
    ElseIf MnuClickFlag = 1 Then
        Call FindSeqMnu_Click
    End If
    MnuClickFlag = 0
ElseIf Index = 1 Then
    sHSCroll1Down = 0
    If ColDistInFile = 1 Then
        
        ReDim ColDist2(0)
    End If
    Timer7(1).Enabled = False
End If

End Sub

Private Sub TreeOptMnu_Click()
If TreeOptMnu.Caption = "Determine ancestral sequence at this node" Then
    Call MakeAncMod
Else
    Call TreeOptMnu2_Click
End If
End Sub

Private Sub TreeOptMnu2_Click()
VisFrame = 11
OptFlag = 16
Form3.TabStrip2.Tabs(1).Caption = "Tree Options"
        

For x = 0 To 14

    If x = VisFrame Then
        Form3.Frame2(x).Visible = True
    Else
        Form3.Frame2(x).Visible = False
    End If

Next 'X
Form3.TabStrip2.Tabs(1).Caption = "Tree Options"
Form3.TabStrip1.Visible = False


Dim OChk As Byte
OptionsFlag = 1
OChk = NoF3Check2
NoF3Check2 = 1
Form3.Combo1.Enabled = True


Command3.SetFocus
ErrorFlag = 0

OptFlag = OptFlag
'SSPanel1(0).Enabled = False
'SSPanel1(1).Enabled = False
'SSPanel1(2).Enabled = False
'SSPanel1(3).Enabled = False
'SSPanel2.Enabled = False

SpacerFlagT = SpacerFlag

Call SetF3Vals(1)

Form2.Enabled = False
Form1.WindowState = Form1.WindowState 'DoEvents
Form3.Visible = True
Form3.Command1.SetFocus

NoF3Check2 = OChk
OptionsFlag = 0
End Sub

Private Sub UnmaskAllMnu_Click()
   
    
    For x = 0 To NextNo
        MaskSeq(x) = 0
    Next 'X
    
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    Call PrintNames
    
    LastY3 = -1
    
    Form1.MaskAllMnu.Visible = True
    Form1.UnmaskAllMnu.Visible = False
    'Form1.InvertMaskMnu.Visible = False
    Form1.DisableAllMnu.Visible = True
End Sub
Public Sub EnableAllMnu_Click()
    
    
    For x = 0 To NextNo
        MaskSeq(x) = 0
    Next 'X
    
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    Call PrintNames
    
    
    LastY3 = -1
   
    Form1.MaskAllMnu.Visible = True
    Form1.UnmaskAllMnu.Visible = False
    'Form1.InvertMaskMnu.Visible = False
    Form1.DisableAllMnu.Visible = True
End Sub

Private Sub UnmaskAllMnu2_Click()
Call UnmaskAllMnu_Click
End Sub

Private Sub UPGMAMnu_Click()
    Form1.SSPanel1.Caption = "Drawing Tree"
    NJF = 0
    CTF = 0
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    TreeTypeFlag = 0
    Form1.Picture16.Picture = Form1.Picture2.Picture
    Form1.Label14 = "UPGMA ignoring recombination"
    Dim TRXSize As Long
    
    If DebuggingFlag < 3 Then On Error Resume Next
    TRXSize = 0
    TRXSize = UBound(TreeRX, 1)
    On Error GoTo 0
    
    
    
    
    If NJFlag = 0 Or (TRXSize < NextNo And TRXSize > 0) Then
        
        
        
        Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

        NJFlag = 1
    End If

    Form1.ProgressBar1.Value = 90
    Call UpdateF2Prog
    Call DrawTree
    
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Erase TreeX
    End If
    If RelX > 0 Or RelY > 0 Then
        DoTreeColour Picture16, 0, 0
        For x = 0 To 3
            If x = 1 Then
                Call ModNextno
            Else
                If x = 3 And (CurTree(x) = 0 Or CurTree(x) = 1) Then
                    Call UnModNextno
                End If
            End If
            
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(x).Value, x, CurTree(x), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(x))
        Next x
   
    End If
    
    If TreeTypeFlag = 0 Then
        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
    End If
    
    Form1.ProgressBar1.Value = 100
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    NJDrawFlag = 1
End Sub

Private Sub VertAlignSplitMnu_Click()
Dim SeqGrp() As Long, XP As Long, YP As Long, SES() As String, AcceptC(2) As Byte, AName As String, EName As String
ReDim SeqGrp(NextNo, NextNo), SES(NextNo)



With Form1.CommonDialog1
    .FileName = ""
    .DefaultExt = "fas"
    .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
    .Action = 2 'Specify that the "save file" action is required.
    .FilterIndex = 1
    AName = .FileName  'Stores selected file name in the
    ANameII = .FileTitle
End With


Call MakeAcceptC(24, AcceptC())
'GoOn = 0
'For X = 0 To PermNextNo
'    For Y = 1 To CurrentXOver(X)
'        If XOverList(X, Y).Accept = 1 Then
'            GoOn = 1
'            Exit For
'        End If
'    Next Y
'    If GoOn = 1 Then Exit For
' Next X
'If GoOn = 1 Then
'    Response = MsgBox("Would you like to only account for those recombination signals that have been manually 'accepted' (i.e. those depicted by a coloured block with a red border in the bottom right program panel)?  If you would like to take every detected recombination signal into account (i.e. those that are either accepted or unaccepted) then press 'No'", vbYesNo)
'Else
'    Response = 7
'    '6=yes, 7=no
'End If

Dim BPMap() As Byte, BPW As Long
ReDim BPMap(Len(StrainSeq(0)))
For x = 1 To SEventNumber
    XP = BestEvent(x, 0)
    YP = BestEvent(x, 1)
    If AcceptC(XoverList(XP, YP).Accept) = 1 Then
        BPW = XoverList(XP, YP).SBPFlag
        If BPW = 0 Or BPW = 2 Then
            BPMap(XoverList(XP, YP).Beginning) = 1
        End If
        If BPW = 0 Or BPW = 1 Then
            If XoverList(XP, YP).Ending + 1 < Len(StrainSeq(0)) Then
                BPMap(XoverList(XP, YP).Ending + 1) = 1
            Else
                BPMap(Len(StrainSeq(0))) = 1
            End If
        End If
    End If
Next x


Dim DS() As Byte, NumCat As Long, TName As String, FF As Long
ReDim DS(NextNo)
NumCat = 0
FF = FreeFile
If AName = "" Then Exit Sub
TName = Left$(AName, Len(AName) - 4)
EName = Right$(AName, 4)
Form1.SSPanel1.Caption = "Splitting alignment into sub-alignments"

Dim TempName() As String, SNum
Dim TempSeq() As String

NumSeqs = NextNo


Dim LastStart As Long
LastStart = 1

ReDim TempName(NextNo)
For x = 0 To NextNo
    TempName(x) = OriginalName(x)
Next x
Z = 1
LastStart = 1
Dim CycleNo As Long
CycleNo = 0
Dim GetStringA As String
Form1.Refresh
Do
    If BPMap(Z) = 1 Or (CircularFlag = 0 And Z = Len(StrainSeq(0))) Then
        
        
        If Z <> LastStart Then
            If CircularFlag = 0 Or LastStart <> 1 Then
                ReDim TempSeq(NextNo)
                If LastStart < Z Then
                    If CircularFlag = 0 And Z = Len(StrainSeq(0)) Then
                        Z = Z + 1
                    End If
                    For x = 0 To NextNo
                        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                            TempSeq(x) = Mid$(StrainSeq(x), LastStart, Z - LastStart)
                        Else
                        
                            If DebuggingFlag < 2 Then On Error Resume Next
                            oDir = CurDir
                            ChDir App.Path
                            ChDrive App.Path
                            On Error GoTo 0
                            FN = FreeFile
                            Open BIGFilename For Binary Access Read As FN
                            GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                            Get #FN, BigFileOffsets(x, 0), GetStringA
                            
                            TempSeq(x) = Mid$(GetStringA, Decompress(LastStart), (Decompress(Z) - Decompress(LastStart)))
                            Close #FN
                            'Exit Sub
                            If DebuggingFlag < 2 Then On Error Resume Next
                            ChDir oDir
                            ChDrive oDir
                            On Error GoTo 0
                        End If
                        
                        
                    Next x
                Else
                    For x = 0 To NextNo
                        
                        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                            TempSeq(x) = Mid$(StrainSeq(x), LastStart, Len(StrainSeq(0)) + 1 - LastStart)
                            TempSeq(x) = TempSeq(x) + Mid$(StrainSeq(x), 1, Z - 1)
                        Else
                        
                            If DebuggingFlag < 2 Then On Error Resume Next
                            oDir = CurDir
                            ChDir App.Path
                            ChDrive App.Path
                            On Error GoTo 0
                            FN = FreeFile
                            Open BIGFilename For Binary Access Read As FN
                            GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                            Get #FN, BigFileOffsets(x, 0), GetStringA
                            'TempSeq(NumSeqs) = Mid$(GetStringA, Decompress(LastStart), Decompress(Z) - Decompress(LastStart))
                            TempSeq(x) = Mid$(GetStringA, Decompress(LastStart), Decompress(Len(StrainSeq(0))) + 1 - Decompress(LastStart))
                            TempSeq(x) = TempSeq(x) + Mid$(GetStringA, 1, Decompress(Z) - 1)
                            Close #FN
                            If DebuggingFlag < 2 Then On Error Resume Next
                            ChDir oDir
                            ChDrive oDir
                            On Error GoTo 0
                        End If
                        
                        
                        
                        
                    Next x
                End If
                'AName = TName + "_" + Trim(Str(Decompress(LastStart))) + "-" + Trim(Str(Decompress(Z) - 1)) + EName
                If Z <= UBound(Decompress, 1) Then
                
                    AName = TName + "_" + Trim(Str(Decompress(LastStart))) + "-" + Trim(Str(Decompress(Z) - 1)) + EName
                Else
                    AName = TName + "_" + Trim(Str(Decompress(LastStart))) + "-" + Trim(Str(Decompress(Len(StrainSeq(0))))) + EName
                    
                    
                End If
                Call WriteAlignFile(NumSeqs, AName, TempName(), TempSeq())
            End If
            LastStart = Z
            If CycleNo = 1 Then Exit Do
        End If
    End If
    Z = Z + 1
    If Z > Len(StrainSeq(0)) Then
        If CircularFlag = 1 And CycleNo = 0 Then
            Z = 1
            CycleNo = CycleNo + 1
        Else
            Exit Do
        End If
    End If
    If CycleNo = 0 Then
        Form1.ProgressBar1 = (Z / Len(StrainSeq(0))) * 100
        Call UpdateF2Prog
    End If
Loop



Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub

Private Sub VScroll1_Change()
'Exit Sub
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    If VSC1NC = 1 Then Exit Sub 'i.e. dont cahnge (used when max is changed)
    'VScroll1.Max = 32000 'Nextno * 14*12
    'Form1.VScroll1.Max = (Form1.Picture16.ScaleHeight - Form1.Picture17.ScaleHeight)
    'Picture16.Top = -VScroll1.Value
'   XX = Picture16.FontSize
    
    
    If TreeTypeFlag = 0 Or BRunning = 1 Then
        
        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, 0, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
'        X = X
    Else
        
        ModNextno
        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
        UnModNextno
        
    End If
     
    If Picture6.Enabled = True And SSPanel8.Visible = True Then
        If DontResetFocus = 0 Then
            Picture6.SetFocus
        End If
    Else
        If Command3.Enabled = True Then
            If DontResetFocus = 0 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Command3.SetFocus
                On Error GoTo 0
            End If
        End If
    End If
'    XX = VScroll1.Max
   
End Sub

Private Sub Timer1_Timer()

Dim YOff As Long, XX1 As Long, XX2 As Long, XX3 As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, Y As Long, Z As Long, DS As Long, ES As Long, LineBottom As Long, LineTop As Long, X3 As Long
Dim GoOn As Long, UB As Long, xBak As Long, x As Long, FSX As Single, TL As Long, C As Long, Target As Long, GG As Long
If LoadBusy = 1 Then Exit Sub
'If DoingShellFlag > 0 Then Exit Sub
If CurrentlyRunningFlag = 1 Then Exit Sub
If SchemDownFlag = 1 Then Exit Sub
If DontDoTimer1Flag = 1 Then
    Exit Sub
End If





'Flashes the selected event in the schematic sequence display
    If Timer1.Enabled = False Then
        
        'Exit Sub
    Else
        Timer1.Enabled = True
    End If
    Timercheck(0) = Abs(GetTickCount)
    
    If Abs(Abs(Timercheck(0)) - Abs(Timercheck(1))) < Timer1.Interval Then
        'Exit Sub
    End If
    Timercheck(1) = Timercheck(0)
    
    YOff = VScroll2.Value * F1VS2Adj
    
    
    yPicRef = Int(((PermYVal / SpaceAdjust) - 3) / 12)
    
    
    
    If GeneSEFlash = 1 Then
        Dim LastColBump As Long, GoOn2 As Long
        'LastColBump
        GoOn = 0: GoOn2 = 0
        For x = 1 To GeneNumber
            LastColBump = ColBump(x)
            If x = Curgene Then
                ColBump(x) = ColBump(x) + 25
            Else
                ColBump(x) = ColBump(x) - 10
            End If
            If ColBump(x) > 50 Then ColBump(x) = 50
            If ColBump(x) < 0 Then ColBump(x) = 0
            If LastColBump <> ColBump(x) Then GoOn = 1
            If ColBump(x) > 0 Then GoOn2 = 1
        Next x
        If GoOn = 1 Then
            DontDoH1Inc = 1
            OnlyDoPosBar = 1
            Call HScroll1_Change
            OnlyDoPosBar = 0
            DontDoH1Inc = 0
        Else
            If GoOn2 = 0 Then
                GeneSEFlash = 0
            End If
            
        End If
    End If
    
    
    
    Dim CVal As Integer

    TimerVal = TimerVal + 40
    If TimerVal > 510 Then
        TimerVal = 0
        CValCycle = CValCycle + 1
        If CValCycle > 0 Then CValCycle = 0
        RCyc = RCyc + 1
        If RCyc > 1 Then RCyc = 0
    End If
    If SSPanel6(2).Visible = True Then
        If CurMatrixFlag = 8 Or CurMatrixFlag = 9 Or CurMatrixFlag = 11 Then
            Call DoSpot(CurMatrixFlag)
        End If
    End If
    'If Len(StrainSeq(0)) = 0 Then Exit Sub
    XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
    If FlashBeginBreakFlag = 1 Or FlashEndBreakFlag = 1 Then
        Form1.Picture7.Refresh
    End If
    
    
    
    
    
    
    
    If FlashBeginBreakFlag = 1 Then
        
        If BeginFlashval <= 0 Then
            FlashBeginBreakFlag = 0
            BeginFlashval = 0
        Else
            Form1.Picture7.AutoRedraw = False
            If BeginFlashval > 10 Then
                Form1.Picture7.DrawWidth = Abs(21 - BeginFlashval)
            Else
                Form1.Picture7.DrawWidth = Abs(BeginFlashval)
            End If
            
            ColHL = RGB(0, 255, 255)
            X1 = FlashX1 '30 + Decompress(XOverlist(RelX, RelY).Beginning) * xFactor + xFactor
            X2 = FlashX2 '30 + Decompress(XOverlist(RelX, RelY).Ending) * xFactor + xFactor
            Y1 = 10
            Y2 = PicHeight - 5
            Form1.Picture7.DrawMode = 12
                      
                      
             x = x
            Form1.Picture7.Line (X1, Y1)-(X1, Y2), ColHL, BF
            'Form1.Picture7.Line (X2, Y1)-(X2, Y2), ColHL, BF
            
            'FontSizeAddjust = Picture2.FontSize / 6.75
            'XX = Picture2.TextHeight("A")
            'line
            
            
            Form1.Picture7.DrawMode = 13
            Form1.Picture7.DrawWidth = 1
            BeginFlashval = BeginFlashval - 2
            Form1.Picture7.AutoRedraw = True
        End If
    End If
    
    If FlashEndBreakFlag = 1 Then
        
        If EndFlashval <= 0 Then
            FlashEndBreakFlag = 0
            EndFlashval = 0
        Else
            Form1.Picture7.AutoRedraw = False
            If EndFlashval > 10 Then
                Form1.Picture7.DrawWidth = Abs(21 - EndFlashval)
            Else
                Form1.Picture7.DrawWidth = Abs(EndFlashval)
            End If
            
            ColHL = RGB(0, 255, 255)
            X1 = FlashX1 '30 + Decompress(XOverlist(RelX, RelY).Beginning) * xFactor + xFactor
            X2 = FlashX2 '30 + Decompress(XOverlist(RelX, RelY).Ending) * xFactor + xFactor
            Y1 = 10
            Y2 = PicHeight - 5
            Form1.Picture7.DrawMode = 12
            'Form1.Picture7.Line (X1, Y1)-(X1, Y2), ColHL, BF
            Form1.Picture7.Line (X2, Y1)-(X2, Y2), ColHL, BF
            
            'FontSizeAddjust = Picture2.FontSize / 6.75
            'XX = Picture2.TextHeight("A")
            'line
            
            
            Form1.Picture7.DrawMode = 13
            Form1.Picture7.DrawWidth = 1
            EndFlashval = EndFlashval - 2
            Form1.Picture7.AutoRedraw = True
        End If
    End If
    
    
    
    If FlashY > 0 Then
        Y = CLng((PermFlashY - VScroll2.Value * F1VS2Adj)) + 12
        FlashY = Y 'CLng((Y - VScroll2.Value * F1VS2Adj)) + 12
        Picture6.AutoRedraw = False
        Picture6.DrawMode = 13
        Picture6.DrawWidth = 3
        FlashCol = FlashCol - 50
        Z = Abs(FlashCol)
        Y = FlashY
        If Z > 255 Then
            CVal = 510 - Z
        Else
            CVal = Z
        End If
        If CVal > 0 And CVal <= 255 Then
        'Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 12), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255)), B
             Picture6.Line (4, Y - 1)-(Picture5.ScaleWidth - 3, Y + 11), RGB(BkR + (255 - BkR) * (CVal / 255), BkG - BkG * (CVal / 255), BkB - BkB * (CVal / 255)), B
             
             DS = Abs(GetTickCount)
             Do
                 ES = Abs(GetTickCount)
                 If ES - DS <> 0 Then Exit Do
                 
             Loop
            
             'VScroll2.Value = (((Y * 12 + 3) * SpaceAdjust + 10) / Picture6.ScaleHeight) * VScroll2.Max
            Picture6.AutoRedraw = True
            Picture6.DrawMode = 13
            Picture6.DrawWidth = 1
        Else
            Picture6.DrawMode = 13
            Picture6.DrawWidth = 1
            FlashY = -1
            Call VScroll2_Change
        End If
        
        Picture6.DrawMode = 13
        Picture6.DrawWidth = 1
    End If
    
    
    'flashes breakpoint locations in sequence display
    BPFlashed = 0
    If SuspendFlash = 0 Then
        If TimerVal > 255 Then
            CVal = 510 - TimerVal
        Else
            CVal = TimerVal
        End If
        
        Dim YCon As Long, tTYF As Double, TYFM As Integer
        
        
        
        
        
        If RunFlag = 1 And (RelX > 0 Or RelY > 0) And XoverList(RelX, RelY).Beginning <> XoverList(RelX, RelY).Ending Then
            If ShowSeqFlag = 0 Or ShowSeqFlag = 1 Then
                Dim BPPos As Long, WLPS As Long
                Dim PolyPoints() As POINTAPI
                ReDim PolyPoints(3)
                Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
                WLPS = WinLeft + PrintSeqLen
                LineBottom = Picture13.ScaleHeight
                LineTop = LineBottom - 2
                tTYF = p1TTYF
                GoOn = 0
                
                UB = 0
                If DebuggingFlag < 2 Then On Error Resume Next
                UB = UBound(RememberBPs, 2)
                
                On Error GoTo 0
                If UB > 0 Then
                    Picture13.BackColor = BackColours
                    
                    If ReassortmentFlag = 1 Then
                        Call ReassortmentMarker(tTYF, XConA)
                    End If
                    
                    
                    
                    If ORFFlag = 1 Then
                    
                    
                        ReDim PolyPoints(5)
                        For x = -2 To PrintSeqLen + 2
                            If WinLeft + x <= UBound(SeqFeatureTrace, 1) Then
                                ColbumpX = ColBump(SeqFeatureTrace(WinLeft + x))
                                If SeqFeatureMap(WinLeft + x) = 20 Then 'start of exon in - ori
                                    XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                                    For Y = XX1 To XX3
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    
                                
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                                    PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                                    PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(255, 255, 128)
                                    '@
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                    
                                ElseIf SeqFeatureMap(WinLeft + x) = 22 Then 'start of exon in + ori
                                    XX1 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                                    For Y = XX2 To XX3
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    
                                
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX1: PolyPoints(2).Y = Y2 / 2
                                    PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2
                                    PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(255, 230, 64)
                                    '@
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                    
                                ElseIf SeqFeatureMap(WinLeft + x) = 24 Then 'start of exon in - ori
                                    XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                                    For Y = XX1 To XX3
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    
                                
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                                    PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                                    PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(255, 255, 198 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(255, 255, 128)
                                    '@
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                    
                            ElseIf SeqFeatureMap(WinLeft + x) = 26 Then  'end of exon in - ori (donor)
                                    XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                                    For Y = XX1 To XX3
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    
                                
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                                    PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                                    PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(255, 230, 128 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(255, 230, 64)
                                    '@
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                   
                            ElseIf SeqFeatureMap(WinLeft + x) = 1 Then
                                    
                                    
                                    XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 3.5) * 8 + 6) * tTYF * XConA
                                    UB = UBound(SEPosMap, 1)
                                    For Y = XX1 To XX3 '25:375-383
                                        If Y <= UB Then
                                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                        End If
                                    Next Y
                                    
                                    
                                
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX2: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2 / 2
                                    PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                                    PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(128, 255, 128)
                                    '@
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                ElseIf SeqFeatureMap(WinLeft + x) = 6 Then
                                    
                                    
                                    XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x + 0.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                                    
                                    For Y = XX1 To XX3 '24:369-375
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                                    PolyPoints(3).x = XX1: PolyPoints(3).Y = Y2
                                    PolyPoints(4).x = XX2: PolyPoints(4).Y = Y2 / 2
                                    PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(255, 164, 164)
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                    
                                    x = x
                                ElseIf SeqFeatureMap(WinLeft + x) = 9 Then
        '                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X)
        '                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 1)
        '                            SEPosMap(X) = SeqFeatureTrace(WinLeft + X + 2)
                                    XX1 = ((x - 1.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                                    XX = LBound(SEPosMap, 1)
                                    For Y = XX1 To XX3 '26:755-763
                                        SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                    Next Y
                                    
                                    Y1 = 0
                                    Y2 = LineBottom
                                    PolyPoints(0).x = XX2: PolyPoints(0).Y = Y1
                                    PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                    PolyPoints(2).x = XX3: PolyPoints(2).Y = Y2
                                    PolyPoints(3).x = XX2: PolyPoints(3).Y = Y2
                                    '@
                                    PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2 / 2
                                    PolyPoints(5).x = XX2: PolyPoints(5).Y = Y1
                                    
                                    Form1.Picture13.FillStyle = 0
                                    Form1.Picture13.FillColor = RGB(198 - ColbumpX, 255, 198 - ColbumpX)
                                    Form1.Picture13.ForeColor = RGB(128, 255, 128)
                                    
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                ElseIf SeqFeatureMap(WinLeft + x) = 10 Then
                                    XX1 = ((x - 0.5) * 8 + 6) * tTYF * XConA
                                    XX2 = ((x + 1.5) * 8 + 6) * tTYF * XConA
                                    XX3 = ((x + 2.5) * 8 + 6) * tTYF * XConA
                                    If XX1 >= LBound(SEPosMap, 1) And XX3 <= UBound(SEPosMap, 1) Then
                                        For Y = XX1 To XX3
                                            SEPosMap(Y) = SeqFeatureTrace(WinLeft + x)
                                        Next Y
                                    
                                        Y1 = 0
                                        Y2 = LineBottom
                                        PolyPoints(0).x = XX1: PolyPoints(0).Y = Y1
                                        PolyPoints(1).x = XX3: PolyPoints(1).Y = Y1
                                        PolyPoints(2).x = XX2: PolyPoints(2).Y = Y2 / 2
                                        PolyPoints(3).x = XX3: PolyPoints(3).Y = Y2
                                        PolyPoints(4).x = XX1: PolyPoints(4).Y = Y2
                                        PolyPoints(5).x = XX1: PolyPoints(5).Y = Y1
                                        
                                        Form1.Picture13.FillStyle = 0
                                        Form1.Picture13.FillColor = RGB(255, 198 - ColbumpX, 198 - ColbumpX)
                                        Form1.Picture13.ForeColor = RGB(255, 164, 164)
                                        Polygon Form1.Picture13.hdc, PolyPoints(0), 5
                                    End If
                                End If
                            End If
                        Next x
                        Form1.Picture13.ForeColor = 0
                    End If
                    'Form1.Picture13.Refresh
                    If (RememberBPs(0, 0) > WinLeft And RememberBPs(0, 0) < WLPS) Or (RememberBPs(0, 1) > WinLeft And RememberBPs(0, 1) < WLPS) Then
                        
                        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
                        If Form1.Picture1.FontSize = P1FontSize Then 'some systems have fonts with different basic sizes
                            'XConA = Form1.Picture1.TextWidth("A")
                            YConA = Form1.Picture1.TextHeight("A")
                            'XConA = XConA / 8
                            YConA = (YConA / 16)
                            
                        Else
                           ' XConA = Form1.Picture1.TextWidth("A")
                            YConA = Form1.Picture1.TextHeight("A")
                            'XConA = XConA / 8
                            YConA = (YConA / 16)
                            'XConA = 1
                            YConA = 1.1
                        End If
                    End If
                    Dim NBPH As Long
                    NBPH = NumberBPs
                    'If NBPH > 100 Then NBPH = 500
                    Dim rBP As Long, PicHDC As Long, LPNTx As POINTAPI, tTYFxXConA As Single, xMid As Long, xLeft As Long, xRight As Long, YTop As Long, YBottom As Long
                    tTYFxXConA = tTYF * XConA
                    PicHDC = Form1.Picture13.hdc
                    YTop = LineTop - 10
                    YBottom = LineBottom - 4
                    'Form1.Picture3.AutoRedraw = False
                    If CValCycle = 0 And F1MDF = 0 Then
                        For Z = NBPH To 0 Step -1
                            
                            rBP = RememberBPs(1, Z)
                            xBak = rBP - CLng((AddNum - 2) / 2)
                            xMid = xBak
                            xLeft = 5 + xBak
                            BPPos = RememberBPs(0, Z)
                            
                            If BPPos > WinLeft And BPPos < WLPS Then
                                If Z <= 1 Then
                                    
                                    x = BPPos - WinLeft
                                    
                                    Picture13.DrawWidth = 1
                                    Picture13.FillStyle = 0
                                    P13BPFC(0) = RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    P13BPFC(1) = RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    
                                    Picture13.FillColor = P13BPFC(0)
                                    Picture13.ForeColor = P13BPFC(1)
                                    PolyPoints(0).x = (x * 8 + 6) * tTYF * XConA - 5 + xBak: PolyPoints(0).Y = LineTop - 10
                                    PolyPoints(1).x = (x * 8 + 6) * tTYF * XConA + xBak: PolyPoints(1).Y = LineBottom - 4
                                    PolyPoints(2).x = (x * 8 + 6) * tTYF * XConA + 5 + xBak: PolyPoints(2).Y = LineTop - 10
                                    PolyPoints(3).x = (x * 8 + 6) * tTYF * XConA - 5 + xBak: PolyPoints(3).Y = LineTop - 10
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 3
                                    
                                    Picture13.DrawWidth = 1
                                    Picture13.FillStyle = 1
                                    
                                    'Picture13.ForeColor = ProgColour(rBP) 'RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    
                                    If rBP >= AddNum Then
                                        Form1.Picture13.ForeColor = ProgcolourB(rBP - AddNum)
                                    Else
                                        Form1.Picture13.ForeColor = ProgcolourB(rBP)
                                    End If
                                    
                                    PolyPoints(0).x = (x * 8 + 6) * tTYF * XConA - 5 + xBak: PolyPoints(0).Y = LineTop - 10
                                    PolyPoints(1).x = (x * 8 + 6) * tTYF * XConA + xBak: PolyPoints(1).Y = LineBottom - 4
                                    PolyPoints(2).x = (x * 8 + 6) * tTYF * XConA + 5 + xBak: PolyPoints(2).Y = LineTop - 10
                                    PolyPoints(3).x = (x * 8 + 6) * tTYF * XConA - 5 + xBak: PolyPoints(3).Y = LineTop - 10
                                    Polygon Form1.Picture13.hdc, PolyPoints(0), 3
                                    BPFlashed = 1
                                    'Picture13.Line ((X * 8 + 6) * tTYF * XConA - 9, LineTop - 15)-((X * 8 + 6) * tTYF * XConA, LineBottom - 4), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    'Picture13.Line ((X * 8 + 6) * tTYF * XConA, LineBottom - 4)-((X * 8 + 6) * tTYF * XConA + 9, LineTop - 15), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    'Picture13.Line ((X * 8 + 6) * tTYF * XConA + 9, LineTop - 15)-((X * 8 + 6) * tTYF * XConA - 9, LineTop - 15), RGB(BkR + (255 - BkR) * (CVal / 255), BkG + (255 - BkG) * (CVal / 255), BkB - BkB * (CVal / 255))
                                    Picture13.DrawWidth = 1
                                    Picture13.ForeColor = 0
                                    Picture13.FillStyle = 1
                                    GoOn = 1
                                Else
                                    If ProgcolourB(rBP) <> 0 Then
                                        
                                        
                                        If rBP >= AddNum Then
                                            Form1.Picture13.ForeColor = ProgcolourB(rBP - AddNum)
                                        Else
                                            Form1.Picture13.ForeColor = ProgcolourB(rBP)
                                        End If
                                        
                                        
                                        x = BPPos - WinLeft
                                        x = (x * 8 + 6) * tTYFxXConA
                                        
                                        MoveToEx PicHDC, x - 5 + xBak, YTop, LPNTx
                                        LineTo PicHDC, x + xBak, YBottom
                                        LineTo PicHDC, x + 5 + xBak, YTop
                                        LineTo PicHDC, x - 5 + xBak, YTop
        '                                Picture13.Line (X - 5 + xBak, LineTop - 10)-(X + xBak, LineBottom - 4), ProgcolourB(RememberBPs(1, Z))
        '                                Picture13.Line (X + xBak, LineBottom - 4)-(X + 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
        '                                Picture13.Line (X + 5 + xBak, LineTop - 10)-(X - 5 + xBak, LineTop - 10), ProgcolourB(RememberBPs(1, Z))
                                    End If
                                End If
                            End If
                        Next Z
                    End If
                End If
                'Exit Sub
                Picture13.ForeColor = 0
            Pict = Picture13.hdc
            Dim OS As String, TX As Single, LV As Single, DC As Long, PAP As POINTAPI
            If Len(StrainSeq(0)) > UBound(Decompress, 1) Then Exit Sub
            DC = Decompress(Len(StrainSeq(0)))
            TX = tTYF * XConA
            LV = (LineTop * VAddjust) - (16 * VAddjust)
            If x = x Then
                '@
                FSX = Form1.Picture1.FontSize
                If FSX > 10 Then
                    TL = 5
                ElseIf FSX > 6 Then
                    TL = 10
                ElseIf FSX > 3 Then
                    TL = 20
                Else
                    TL = 50
                End If
                For x = 0 To PrintSeqLen
                    '@
                    YCon = WinLeft + x
                    If YCon <= DC Then
                        
                        X3 = (x * 8 + 6) * TX
                        
                        If (YCon) / TL = Int((YCon) / TL) Then
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop - 2)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                            '@
                            
                            Dummy = MoveToEx(Pict, X3, LineTop - 2, PAP)
                            Dummy = LineTo(Pict, X3, LineBottom)
                            '@
                            'Picture13.Refresh'
                            '@
                            C = (Picture13.TextWidth(Trim$(CStr(YCon)))) / 2
                            X3 = X3 - C
                            'Y1 = (LineTop * VAddjust) - (16 * VAddjust)
                            
                            OS = Trim$(CStr(YCon))
                            
                            Dummy = TextOut(Pict, X3, LV, OS, Len(OS))
                        Else
                            '@
                            Dummy = MoveToEx(Pict, X3, LineTop, PAP)
                            
                            Dummy = LineTo(Pict, X3, LineBottom)
                            'Picture13.Line ((x * 8 + 6) * tTYF * XConA, LineTop)-((x * 8 + 6) * tTYF * XConA, LineBottom)
                        End If
        
                    Else
                        Exit For
                    End If
        
                Next 'X
            End If
            End If
            Picture13.Refresh
            
            If CValCycle = 0 And F1MDF = 0 Then
            
                Dim BkGx As Byte, BkBx As Byte, BkRx As Byte, RCol As Long
                
    '            For SeqFL = 0 To SBlocksLen
    '                If SchemBlocks(0, 4, SeqFL) = SCol(RelX) Then
    '
    '
    '                End If
    '            Next seqf1
                
                If XoverList(RelX, RelY).Accept = 2 Then
                    RCol = Rejected
                Else
                    RCol = SchemBlocks(SchemFlag, 4, SBlockBak(RelX, RelY))
                    
                    'If SchemFlag = 0 Then
                    '    RCol = SeqCol(XOverlist(RelX, RelY).MinorP)
                    'ElseIf SchemFlag = 1 Then
                    '    RCol = ProgColour(XOverlist(RelX, RelY).ProgramFlag)
                    'ElseIf SchemFlag = 2 Then
                   '
                   ' ElseIf SchemFlag = 3 Then
                   '
                   ' End If
                End If
                
                Dim P6Adj As Single, BBY1 As Long, BBSBIndexY1 As Long
                P6Adj = P6Width / Form1.Picture5.Width
                
                
                X1 = SchemBlocks(SchemFlag, 0, SBlockBak(RelX, RelY)) / P6Adj
                X2 = SchemBlocks(SchemFlag, 2, SBlockBak(RelX, RelY)) / P6Adj
                Y1 = SchemBlocks(SchemFlag, 1, SBlockBak(RelX, RelY)) - YOff
                Y2 = SchemBlocks(SchemFlag, 3, SBlockBak(RelX, RelY)) - YOff
                BBY1 = Y1
                BBSBIndexY1 = SBlockBak(RelX, RelY)
                Call ConvertLongToRGB(RCol, BkRx, BkGx, BkBx)
                
                If RCyc = 0 Then
                    RCol = RGB(BkRx - BkRx * (CVal / 255), BkGx - BkGx * (CVal / 255), BkBx + (255 - BkBx) * (CVal / 255))
                Else
                    RCol = RGB(BkRx + (220 - BkRx) * (CVal / 255), BkGx - BkGx * (CVal / 255), BkBx - BkBx * (CVal / 255))
                End If
                Dim OAR As Long
                OAR = Picture6.AutoRedraw
                Picture6.AutoRedraw = True
                If XoverList(RelX, RelY).Accept = 1 Then
                    If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                        ReDim Preserve SchemBlocks(3, 4, SBlocksLen + 1)
                        Picture6.AutoRedraw = False
                        Picture6.DrawMode = 13
                        Picture6.Line (X1, Y1 + 1)-(X2 - 1, Y2 - 2), RCol, BF '210RGB(203, 203, 171)
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 1) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                            SchemBlocks(Z, 1, SBlocksLen + 1) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust) + 1
                            SchemBlocks(Z, 2, SBlocksLen + 1) = X2 '5 + CLng(XOverlist(RelX, RelY).Ending * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 1) = Y2 + YOff 'CLng(((yPicRef + 1) * 12 + 1) * SpaceAdjust) - 1
                            SchemBlocks(Z, 4, SBlocksLen + 1) = RCol
                        Next Z
                    Else
                        ReDim Preserve SchemBlocks(3, 4, SBlocksLen + 2)
                        
                        Picture6.AutoRedraw = False
                        'Picture6.AutoRedraw = True
                        Picture6.DrawMode = 13
                        'Picture6.Line (5 + 1 * XPicAddjust, CLng((yPicRef * 12 + 3) * SpaceAdjust) - YOff + 1)-(5 + CLng(XOverlist(RelX, RelY).Ending * XPicAddjust) - 1, CLng(((yPicRef + 1) * 12 + 1) * SpaceAdjust) - 2 - YOff), RCol, BF
                        'Picture6.Line (5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust), CLng((yPicRef * 12 + 3) * SpaceAdjust) - YOff + 1)-(5 + CLng(Len(StrainSeq(0)) * XPicAddjust) - 1, CLng(((yPicRef + 1) * 12) * SpaceAdjust) - YOff - 1), RCol, BF
                        Picture6.Line (X1, Y1 + 1)-(X2 - 1, Y2 - 2), RCol, BF
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 1) = X1 '5 + 1 * XPicAddjust
                            SchemBlocks(Z, 1, SBlocksLen + 1) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust) + 1
                            SchemBlocks(Z, 2, SBlocksLen + 1) = X2 '5 + CLng(XOverlist(RelX, RelY).Ending * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 1) = Y2 + YOff 'CLng(((yPicRef + 1) * 12 + 1) * SpaceAdjust) - 1
                            SchemBlocks(Z, 4, SBlocksLen + 1) = RCol
                        Next Z
                        
                        X1 = SchemBlocks(SchemFlag, 0, SBlockBak(RelX, RelY) + 1)
                        X2 = SchemBlocks(SchemFlag, 2, SBlockBak(RelX, RelY) + 1)
                        Y1 = SchemBlocks(SchemFlag, 1, SBlockBak(RelX, RelY) + 1) - YOff
                        Y2 = SchemBlocks(SchemFlag, 3, SBlockBak(RelX, RelY) + 1) - YOff
                        Picture6.Line (X1, Y1 + 1)-(X2 - 1, Y2 - 2), RCol, BF
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 2) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                            SchemBlocks(Z, 1, SBlocksLen + 2) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust) + 1
                            SchemBlocks(Z, 2, SBlocksLen + 2) = X2 '5 + CLng(Len(StrainSeq(0)) * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 2) = Y2 + YOff 'CLng(((yPicRef + 1) * 12) * SpaceAdjust)
                            SchemBlocks(Z, 4, SBlocksLen + 2) = RCol
                        Next Z
            
                    End If
                
                Else
                    'This is the blue flashing event block with no accept block
                    If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                        ReDim Preserve SchemBlocks(3, 4, SBlocksLen + 1)
                        Picture6.AutoRedraw = False
                        Picture6.DrawMode = 13
                        Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 1) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                            SchemBlocks(Z, 1, SBlocksLen + 1) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                            SchemBlocks(Z, 2, SBlocksLen + 1) = X2 '5 + CLng(XOverlist(RelX, RelY).Ending * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 1) = Y2 + YOff 'CLng(((yPicRef + 1) * 12 + 1) * SpaceAdjust)
                            SchemBlocks(Z, 4, SBlocksLen + 1) = RCol
                        Next Z
                    Else
                        ReDim Preserve SchemBlocks(3, 4, SBlocksLen + 2)
                        Picture6.AutoRedraw = False
                        Picture6.DrawMode = 13
                        Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 1) = X1 ' 5 + 1 * XPicAddjust
                            SchemBlocks(Z, 1, SBlocksLen + 1) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                            SchemBlocks(Z, 2, SBlocksLen + 1) = X2 '5 + CLng(XOverlist(RelX, RelY).Ending * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 1) = Y2 + YOff 'CLng(((yPicRef + 1) * 12 + 1) * SpaceAdjust)
                            SchemBlocks(Z, 4, SBlocksLen + 1) = RCol
                        Next Z
                        X1 = SchemBlocks(SchemFlag, 0, SBlockBak(RelX, RelY) + 1)
                        X2 = SchemBlocks(SchemFlag, 2, SBlockBak(RelX, RelY) + 1)
                        Y1 = SchemBlocks(SchemFlag, 1, SBlockBak(RelX, RelY) + 1) - YOff
                        Y2 = SchemBlocks(SchemFlag, 3, SBlockBak(RelX, RelY) + 1) - YOff
                        Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 2) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                            SchemBlocks(Z, 1, SBlocksLen + 2) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                            SchemBlocks(Z, 2, SBlocksLen + 2) = X2 '5 + CLng(Len(StrainSeq(0)) * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 2) = Y2 + YOff 'CLng(((yPicRef + 1) * 12) * SpaceAdjust) + 1
                            SchemBlocks(Z, 4, SBlocksLen + 2) = RCol
                        Next Z
            
                    End If
                End If
                Dim STartT As Long
                If XoverList(RelX, RelY).Daughter <> RelX Then
                    Dim DV0 As Long, DV1 As Long, DV2 As Long, DV3 As Long
                    If XoverList(RelX, RelY).BeginP < 0 Then
                        Call SplitP(-XoverList(RelX, RelY).BeginP, DV0, DV1)
                        
                    End If
                    If XoverList(RelX, RelY).EndP < 0 Then
                        Call SplitP(-XoverList(RelX, RelY).EndP, DV2, DV3)
                    End If
                    If DV1 = XoverList(RelX, RelY).Daughter Then
                        Target = SBlockBak(RelX, RelY)  'SBlockBakE(DV0) + SBlocksLen
                        STartT = SBlockBakE(DV0)
                    ElseIf DV3 = XoverList(RelX, RelY).Daughter Then
                        Target = SBlockBak(RelX, RelY) + 1 'SBlockBakE(DV2) + SBlocksLen
                        STartT = SBlockBakE(DV0)
                    Else
                        Target = SBlockBak(RelX, RelY)
                        STartT = SBlockBak(RelX, 0)
                    End If
                    BBY1 = SchemBlocks(SchemFlag, 2, STartT)
                Else
                    If RelX >= PermNextno Then
                        Target = SBlockBak(RelX, RelY) 'SBlocksLen 'BBY1 - 23 'BBSBIndexY1 - 1 'SBlocksLen
                    Else
                         Target = SBlockBak(RelX, RelY) 'SBlockBak(RelX + 1, 0) - 1 'BBY1 - 23 'BBSBIndexY1 - 1 'SBlockBak(RelX + 1, 0) - 1
                    End If
                    STartT = SBlockBak(RelX, 0)
                    'Target = STartT
                    BBY1 = SchemBlocks(SchemFlag, 2, STartT) 'the y-coord of the main block
                End If
                Dim BkGy As Byte, BkBy As Byte, BkRy As Byte, FCol As Long
                
                
                
                Call ConvertLongToRGB(FCol, BkRx, BkGx, BkBx)
                SBExtras = 0
                'These are the green flashing blocks on the main sequences
                XX = BBSBIndexY1
                XX = BBY1
                For GG = STartT To Target
                
                    If ((SchemBlocks(0, 4, GG) = SeqCol(RelX) Or SchemBlocks(0, 4, GG) = FFillCol(RelX))) And SchemBlocks(SchemFlag, 2, GG) = BBY1 Then
                        SBExtras = SBExtras + 1
                        RCol = SchemBlocks(SchemFlag, 4, GG)
                        Call ConvertLongToRGB(RCol, BkRx, BkGx, BkBx)
                        If RCyc = 0 Then
                            RCol = RGB(BkRx - BkRx * (CVal / 255), BkGx + (255 - BkGx) * (CVal / 255), BkBx - BkBx * (CVal / 255))
                        Else
                            RCol = RGB(BkRx + (220 - BkRx) * (CVal / 255), BkGx - BkGx * (CVal / 255), BkBx - BkBx * (CVal / 255))
                        End If
                        X1 = SchemBlocks(SchemFlag, 0, GG) / P6Adj
                        X2 = SchemBlocks(SchemFlag, 2, GG) / P6Adj
                        Y1 = SchemBlocks(SchemFlag, 1, GG) - YOff
                        Y2 = SchemBlocks(SchemFlag, 3, GG) - YOff
                        Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                        
                        If UBound(SchemBlocks, 3) < SBlocksLen + 2 + SBExtras Then
                            ReDim Preserve SchemBlocks(UBound(SchemBlocks, 1), UBound(SchemBlocks, 2), SBlocksLen + 2 + SBExtras)
                        End If
                        For Z = 0 To 3
                            SchemBlocks(Z, 0, SBlocksLen + 2 + SBExtras) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                            SchemBlocks(Z, 1, SBlocksLen + 2 + SBExtras) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                            SchemBlocks(Z, 2, SBlocksLen + 2 + SBExtras) = X2 '5 + CLng(Len(StrainSeq(0)) * XPicAddjust)
                            SchemBlocks(Z, 3, SBlocksLen + 2 + SBExtras) = Y2 + YOff 'CLng(((yPicRef + 1) * 12) * SpaceAdjust) + 1
                            SchemBlocks(Z, 4, SBlocksLen + 2 + SBExtras) = RCol
                        Next Z
                        
                    End If
                Next GG
                'do the "greyed out" block(s)correspondng to the recombinant regaion
                X1 = SchemBlocks(SchemFlag, 0, SBlockBak(RelX, RelY)) / P6Adj
                X2 = SchemBlocks(SchemFlag, 2, SBlockBak(RelX, RelY)) / P6Adj
                Y1 = SchemBlocks(SchemFlag, 1, STartT) - YOff
                Y2 = SchemBlocks(SchemFlag, 3, STartT) - YOff
                RCol = FFillCol(RelX)
                
                SBExtras = SBExtras + 1
                If UBound(SchemBlocks, 3) < SBlocksLen + 2 + SBExtras Then
                    ReDim Preserve SchemBlocks(UBound(SchemBlocks, 1), UBound(SchemBlocks, 2), SBlocksLen + 2 + SBExtras)
                End If
    
                Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                For Z = 0 To 3
                    SchemBlocks(Z, 0, SBlocksLen + 2 + SBExtras) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                    SchemBlocks(Z, 1, SBlocksLen + 2 + SBExtras) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                    SchemBlocks(Z, 2, SBlocksLen + 2 + SBExtras) = X2 '5 + CLng(Len(StrainSeq(0)) * XPicAddjust)
                    SchemBlocks(Z, 3, SBlocksLen + 2 + SBExtras) = Y2 + YOff 'CLng(((yPicRef + 1) * 12) * SpaceAdjust) + 1
                    SchemBlocks(Z, 4, SBlocksLen + 2 + SBExtras) = RCol
                Next Z
                If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                    X1 = SchemBlocks(SchemFlag, 0, SBlockBak(RelX, RelY) + 1)
                    X2 = SchemBlocks(SchemFlag, 2, SBlockBak(RelX, RelY) + 1)
                    Picture6.Line (X1, Y1)-(X2, Y2), RCol, BF
                    If UBound(SchemBlocks, 3) < SBlocksLen + 2 + SBExtras Then
                        ReDim Preserve SchemBlocks(UBound(SchemBlocks, 1), UBound(SchemBlocks, 2), SBlocksLen + 2 + SBExtras)
                    End If
                    For Z = 0 To 3
                        SchemBlocks(Z, 0, SBlocksLen + 2 + SBExtras) = X1 '5 + CLng(XOverlist(RelX, RelY).Beginning * XPicAddjust)
                        SchemBlocks(Z, 1, SBlocksLen + 2 + SBExtras) = Y1 + YOff 'CLng((yPicRef * 12 + 3) * SpaceAdjust)
                        SchemBlocks(Z, 2, SBlocksLen + 2 + SBExtras) = X2 '5 + CLng(Len(StrainSeq(0)) * XPicAddjust)
                        SchemBlocks(Z, 3, SBlocksLen + 2 + SBExtras) = Y2 + YOff 'CLng(((yPicRef + 1) * 12) * SpaceAdjust) + 1
                        SchemBlocks(Z, 4, SBlocksLen + 2 + SBExtras) = RCol
                    Next Z
                End If
                Picture6.AutoRedraw = OAR
                'Picture6.Refresh
            End If
        End If
        x = x
    Else
        x = x
    End If
    'flashes the rescan button
    
  
    If Form1.Command10.Enabled = True And AcceptChangeFlag = 2 Then
        Form1.Command10.BackColor = RGB(BkR + (255 - BkR) * (CVal / 255), BkG - BkG * (CVal / 255), BkB - BkB * (CVal / 255))
        Form1.Command10.MousePointer = Form1.Command9.MousePointer
        'Form1.Command10.BackColor = 0
    Else
        Form1.Command10.BackColor = Form1.BackColor
    End If
    
    
    If BranchFlashFlag > 0 Then
        Dim XMod As Single, PRat As Single, TDL1 As Long, ZZ As Byte, StartC(2) As Byte, TargetC(2) As Byte, CurR As Long, CurG As Long, CurB As Long
        
        If BranchFlashFlag = 1 Then
            PRat = TDLen(PermSelectNode(4), CurTree(PermSelectNode(4)), 2) / Form2.Picture2(PermSelectNode(4)).ScaleWidth
            XMod = TreeXScaleMod(0, PermSelectNode(4), CurTree(PermSelectNode(4)))
        
            If XMod = 0 Then Exit Sub
            PRat = PRat / XMod
            
            TDL1 = TDLen(PermSelectNode(4), CurTree(PermSelectNode(4)), 1)
        ElseIf BranchFlashFlag = 2 Then
            PRat = TDLen(TreeTypeFlag, CTF, 2) / Picture16.ScaleWidth
            XMod = TreeXScaleMod(1, TreeTypeFlag, CTF)
            If XMod = 0 Then Exit Sub
            PRat = PRat / XMod
            TDL1 = TDLen(TreeTypeFlag, CTF, 1)
        End If
        If SelectNode(0) > -1 Then
            
            ZZ = PermSelectNode(4)
            If BranchFlashFlag = 1 Then
                For Index = 0 To 3
                    If TreeDrawColBakFlag(Index) = 1 Then
                        For x = 0 To TDL1
                            If UBound(TreeDrawColBak, 1) >= x Then
                                If TreeDrawColBak(x, Index) <> TreeDrawB(4, x, Index, CurTree(Index), 1) Then
                                    Call ConvertLongToRGB(TreeDrawColBak(x, Index), TargetC(0), TargetC(1), TargetC(2))
                                    Call ConvertLongToRGB(CLng(TreeDrawB(4, x, Index, CurTree(Index), 1)), StartC(0), StartC(1), StartC(2))
                                    CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 4
                                    CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 4
                                    CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 4
                                    If CurR < 0 Then CurR = 0
                                    If CurG < 0 Then CurG = 0
                                    If CurB < 0 Then CurB = 0
                                    If CurR > 255 Then CurR = 255
                                    If CurG > 255 Then CurG = 255
                                    If CurB > 255 Then CurB = 255
                                    If BranchFlashFlag = 1 Then
                                        TreeDrawB(4, x, Index, CurTree(Index), 1) = RGB(CurR, CurG, CurB) 'TreeDrawColBak(X, Index)
                                    ElseIf BranchFlashFlag = 2 Then
                                        TreeDrawB(4, x, Index, CTF, 1) = RGB(CurR, CurG, CurB) 'TreeDrawColBak(X, Index)
                                    End If
                                End If
                            End If
                        Next x
                        
                    End If
                Next Index
            ElseIf BranchFlashFlag = 2 Then
                Index = TreeTypeFlag
                If TreeDrawColBakFlag(Index) = 1 Then
                        For x = 0 To TDL1
                            If UBound(TreeDrawColBak, 1) >= x Then
                                If TreeDrawColBak(x, Index) <> TreeDrawB(4, x, Index, CTF, 1) Then
                                    Call ConvertLongToRGB(TreeDrawColBak(x, Index), TargetC(0), TargetC(1), TargetC(2))
                                    Call ConvertLongToRGB(CLng(TreeDrawB(4, x, Index, CTF, 1)), StartC(0), StartC(1), StartC(2))
                                    CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 4
                                    CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 4
                                    CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 4
                                    If CurR < 0 Then CurR = 0
                                    If CurG < 0 Then CurG = 0
                                    If CurB < 0 Then CurB = 0
                                    If CurR > 255 Then CurR = 255
                                    If CurG > 255 Then CurG = 255
                                    If CurB > 255 Then CurB = 255
                                    TreeDrawB(4, x, Index, CTF, 1) = RGB(CurR, CurG, CurB) 'TreeDrawColBak(X, Index)
                                End If
                            End If
                        Next x
                        
                    End If
            End If
            Call ConvertLongToRGB(SelCol, TargetC(0), TargetC(1), TargetC(2))
            'Form2.Picture2(PermSelectNode(4)).Line (XFlashbound, 0)-(XFlashbound, 10000), RGB(255, 0, 0)
            Dim CTF2 As Long
            If BranchFlashFlag = 1 Then
                CTF2 = CurTree(PermSelectNode(4))
                For x = 0 To TDL1
                    If TreeDrawB(2, x, PermSelectNode(4), CTF2, 1) / PRat >= XFlashbound - 2 And TreeDrawB(0, x, PermSelectNode(4), CTF2, 1) / PRat >= XFlashbound - 2 Then
                        If TreeDrawB(1, x, PermSelectNode(4), CTF2, 1) >= YFlashBound(0) And TreeDrawB(1, x, PermSelectNode(4), CTF2, 1) <= YFlashBound(1) Then
                            
                            'Form2.Picture2(PermSelectNode(4)).Line (TreeDrawB(0, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 0)-(TreeDrawB(0, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 10000), RGB(0, 255, 0)
                            'Form2.Picture2(PermSelectNode(4)).Line (TreeDrawB(2, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 0)-(TreeDrawB(2, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 10000), RGB(0, 0, 255)
                            If BranchFlashFlag = 1 Then
                                Call ConvertLongToRGB(CLng(TreeDrawB(4, x, PermSelectNode(4), CurTree(PermSelectNode(4)), 1)), StartC(0), StartC(1), StartC(2))
                            ElseIf BranchFlashFlag = 2 Then
                                Call ConvertLongToRGB(CLng(TreeDrawB(4, x, PermSelectNode(4), CTF, 1)), StartC(0), StartC(1), StartC(2))
                            
                            End If

                            
                            CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 1.2
                            CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 1.2
                            CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 1.2
                            If CurR < 0 Then CurR = 0
                            If CurG < 0 Then CurG = 0
                            If CurB < 0 Then CurB = 0
                            If CurR > 255 Then CurR = 255
                            If CurG > 255 Then CurG = 255
                            If CurB > 255 Then CurB = 255
                            If BranchFlashFlag = 1 Then
                                TreeDrawB(4, x, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) = RGB(CurR, CurG, CurB)
                            ElseIf BranchFlashFlag = 2 Then
                                TreeDrawB(4, x, PermSelectNode(4), CTF, 1) = RGB(CurR, CurG, CurB)
                            End If
                        End If
                    End If
                Next x
            ElseIf BranchFlashFlag = 2 Then
                CTF2 = CTF
                For x = 0 To TDL1
                    If TreeDrawB(2, x, TreeTypeFlag, CTF2, 1) / PRat >= XFlashbound - 2 And TreeDrawB(0, x, TreeTypeFlag, CTF2, 1) / PRat >= XFlashbound - 2 Then
                        If TreeDrawB(1, x, TreeTypeFlag, CTF2, 1) >= YFlashBound(0) And TreeDrawB(1, x, TreeTypeFlag, CTF2, 1) <= YFlashBound(1) Then
                            
                            'Form2.Picture2(PermSelectNode(4)).Line (TreeDrawB(0, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 0)-(TreeDrawB(0, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 10000), RGB(0, 255, 0)
                            'Form2.Picture2(PermSelectNode(4)).Line (TreeDrawB(2, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 0)-(TreeDrawB(2, X, PermSelectNode(4), CurTree(PermSelectNode(4)), 1) / PRat, 10000), RGB(0, 0, 255)
                            Call ConvertLongToRGB(CLng(TreeDrawB(4, x, TreeTypeFlag, CTF, 1)), StartC(0), StartC(1), StartC(2))
                            
                            
                            
                            CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 1.2
                            CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 1.2
                            CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 1.2
                            If CurR < 0 Then CurR = 0
                            If CurG < 0 Then CurG = 0
                            If CurB < 0 Then CurB = 0
                            If CurR > 255 Then CurR = 255
                            If CurG > 255 Then CurG = 255
                            If CurB > 255 Then CurB = 255
                            TreeDrawB(4, x, TreeTypeFlag, CTF, 1) = RGB(CurR, CurG, CurB)
                           
                        End If
                    End If
                Next x
            End If
            
            
            If BranchFlashFlag = 1 Then
                For Index = 0 To 3
                
                    Call TreeDrawing(1, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                    
                    Form2.Picture2(Index).Refresh
                Next Index
             ElseIf BranchFlashFlag = 2 Then
                    Call TreeDrawing(1, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -VScroll1.Value, Index, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
                    Picture16.Refresh
             End If
'            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(ZZ).Value, ZZ, CurTree(ZZ), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(ZZ))
'            X = X
        Else
            GoOn = 0
            If BranchFlashFlag = 1 Then
                
                For Index = 0 To 3
                    If TreeDrawColBakFlag(Index) = 1 Then
                        For x = 0 To TDL1 '
                            If x <= UBound(TreeDrawColBak, 1) Then
                                If TreeDrawColBak(x, Index) <> TreeDrawB(4, x, Index, CurTree(Index), 1) Then
                                    Call ConvertLongToRGB(TreeDrawColBak(x, Index), TargetC(0), TargetC(1), TargetC(2))
                                    Call ConvertLongToRGB(CLng(TreeDrawB(4, x, Index, CurTree(Index), 1)), StartC(0), StartC(1), StartC(2))
                                    CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 4
                                    CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 4
                                    CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 4
                                    If CurR < 0 Then CurR = 0
                                    If CurG < 0 Then CurG = 0
                                    If CurB < 0 Then CurB = 0
                                    If CurR > 255 Then CurR = 255
                                    If CurG > 255 Then CurG = 255
                                    If CurB > 255 Then CurB = 255
                                    If TreeDrawB(4, x, Index, CurTree(Index), 1) <> RGB(CurR, CurG, CurB) Then
                                        TreeDrawB(4, x, Index, CurTree(Index), 1) = RGB(CurR, CurG, CurB) 'TreeDrawColBak(X, Index)
                                    
                                        GoOn = 1
                                    End If
                                End If
                            Else
                                x = x
                            End If
                        Next x
                        Call TreeDrawing(1, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                        Form2.Picture2(Index).Refresh
                    End If
                Next Index
            Else
                For x = 0 To TDL1
                    If UBound(TreeDrawColBak, 1) >= x Then
                        If TreeDrawColBak(x, TreeTypeFlag) <> TreeDrawB(4, x, TreeTypeFlag, CTF, 1) Then
                            Call ConvertLongToRGB(TreeDrawColBak(x, TreeTypeFlag), TargetC(0), TargetC(1), TargetC(2))
                            Call ConvertLongToRGB(CLng(TreeDrawB(4, x, TreeTypeFlag, CTF, 1)), StartC(0), StartC(1), StartC(2))
                            CurR = StartC(0) + (CLng(TargetC(0)) - CLng(StartC(0))) / 4
                            CurG = StartC(1) + (CLng(TargetC(1)) - CLng(StartC(1))) / 4
                            CurB = StartC(2) + (CLng(TargetC(2)) - CLng(StartC(2))) / 4
                            If CurR < 0 Then CurR = 0
                            If CurG < 0 Then CurG = 0
                            If CurB < 0 Then CurB = 0
                            If CurR > 255 Then CurR = 255
                            If CurG > 255 Then CurG = 255
                            If CurB > 255 Then CurB = 255
                            If TreeDrawB(4, x, TreeTypeFlag, CTF, 1) <> RGB(CurR, CurG, CurB) Then
                                TreeDrawB(4, x, TreeTypeFlag, CTF, 1) = RGB(CurR, CurG, CurB) 'TreeDrawColBak(X, Index)
                            
                                GoOn = 1
                            End If
                        End If
                    End If
                Next x
                Call TreeDrawing(1, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Picture16)
                Picture16.Refresh
            
            End If
            'BranchFlashFlag = 0
            If GoOn = 0 Then
                BranchFlashFlag = 0
            End If
        End If
        
        
'        'If TreeDrawColBakflag(Index) = 0 Then
'            TDL1 = TDLen(Index, CurTree(Index), 1)
'            For X = 0 To TDL1
'                TreeDrawColBak(X, Index) = TreeDrawB(4, X, Index, CurTree(Index), 1)
'            End If
'            TreeDrawColBakflag(Index) = 1
'        End If
        
    End If
    
    
    Timer1SS = Abs(GetTickCount)
     XX = HScroll1Hits
End Sub

Private Sub VScroll1_GotFocus()
    If RelX > 0 Or RelY > 0 Then
         If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    End If
End Sub

Private Sub VScroll1_Scroll()
   
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
   
   ' Picture16.Top = -VScroll1.Value
    'VScroll1.Max = 32000
    If TreeTypeFlag = 0 Or BRunning = 1 Then
        
        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -VScroll1.Value, 0, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
    Else
        ModNextno
       
        Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
        UnModNextno
        x = x
    End If
    If Picture6.Enabled = True Then
        Picture6.SetFocus
    Else
        Command3.SetFocus
    End If
   
End Sub

Private Sub VScroll2_Change()
'This is the schemdown scrollbar
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    'XX = VScroll2.MaX
    Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -VScroll2.Value, Form1.Picture6)
End Sub

Private Sub VScroll2_GotFocus()
    If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
End Sub

Private Sub VScroll2_Scroll()
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    'XX = VScroll2.Value
    'Dim Curv2Val As Long
    'Curv2Val = Form1.VScroll2.Value
    'If LastV2Val < Curv2Val Then
    '    For Z = LastV2Val + 1 To Curv2Val Step 4
            Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -VScroll2.Value, Form1.Picture6)
   '         Form1.Picture6.Refresh
   '     Next Z
   ' Else
   '     For Z = LastV2Val - 1 To Curv2Val Step -4
   '         Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -Z, Form1.Picture6)
   '         Form1.Picture6.Refresh
   '     Next Z
   ' End If
   ' LastV2Val = VScroll2.Value
End Sub

Private Sub VScroll3_Change()
   ' If Picture3.ScaleHeight <> Picture1.Height Then
   '     Picture3.Height = Picture1.Height
   ' End If
    LastVScroll3Value = VScroll3.Value
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    
    If VScroll3.Value >= 0 Then
        If H1C = 0 Then
            If DSDFlag = 0 Then
                Call DoSeqDisplay
            ElseIf DSDFlag = 1 Then
                Dim hdcHolder As Long
                hdcHolder = cDib.hdc
                Call DoSeqDisplayDIB(hdcHolder)
                cDib.PaintPicture Form1.Picture1.hdc
            ElseIf DSDFlag = 2 Then
                If HScroll1.Max <= 1 Then
                    Call HScroll1_Change
                Else
                    If HScroll1.Value > HScroll1.Min Then
                        H1C = 1
                        HScroll1.Value = HScroll1.Value - 1
                        H1C = 0
                        'H1M = 1
                        DontDoH1Inc = 1
                        HScroll1.Value = HScroll1.Value + 1
                        DontDoH1Inc = 0
                    Else
                        H1C = 1
                        HScroll1.Value = HScroll1.Value + 1
                        H1C = 1
                        'H1M = 1
                        DontDoH1Inc = 1
                        HScroll1.Value = HScroll1.Value - 1
                        DontDoH1Inc = 0
                    End If
                End If
            End If
        End If
        'Form1.Picture3.Top = -VScroll3.Value
        If ShowSeqFlag = 0 Then
            Call PrintNames
        Else
            Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
        End If
        Picture1.Refresh
        Picture3.Refresh
        LastY3 = -1
        Picture3.MousePointer = 0
        If H1C = 0 Then
            Picture1.Refresh
        End If
    End If

End Sub

Private Sub VScroll3_GotFocus()
If ShowSeqFlag = 0 Then
    Form1.Command3.SetFocus
Else
     If Form1.Picture6.Enabled = True Then
        Form1.Picture6.SetFocus
    End If
End If
End Sub

Private Sub VScroll3_Scroll()
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    LastVScroll3Value = VScroll3.Value
    If VScroll3.Value >= 0 Then
        If DSDFlag = 0 Then
            Call DoSeqDisplay
        ElseIf DSDFlag = 1 Then
                Dim hdcHolder As Long
                hdcHolder = cDib.hdc
                Call DoSeqDisplayDIB(hdcHolder)
                cDib.PaintPicture Form1.Picture1.hdc
        ElseIf DSDFlag = 2 Then
                If HScroll1.Max <= 1 Then
                    Call HScroll1_Change
                Else
                    If HScroll1.Value > HScroll1.Min Then
                        H1C = 1
                        HScroll1.Value = HScroll1.Value - 1
                        H1C = 0
                        'H1M = 1
                        DontDoH1Inc = 1
                        HScroll1.Value = HScroll1.Value + 1
                        DontDoH1Inc = 0
                    Else
                        H1C = 1
                        HScroll1.Value = HScroll1.Value + 1
                        H1C = 0
                        'H1M = 1
                        DontDoH1Inc = 1
                        HScroll1.Value = HScroll1.Value - 1
                        DontDoH1Inc = 0
                    End If
                End If
        End If
        
        'Form1.Picture1.Top = -VScroll3.Value
        'Form1.Picture3.Top = -VScroll3.Value
        If ShowSeqFlag = 0 Then
            Call PrintNames
        Else
            Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
        End If
        Picture3.MousePointer = 0
        Picture3.Refresh
        LastY3 = -1
        Picture1.Refresh
    End If

End Sub

Private Sub VScroll4_Change()
    'VScroll4.Max = Picture2.Height - Picture32.Height
    
    If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    
    If RIMode = 0 Then
        If ManFlag <> 161 Then
            Picture2.Top = (-VScroll4.Value) * Screen.TwipsPerPixelY
        
            If Picture2.Top = 0 And P2DHeight < (Picture32.ScaleHeight / Screen.TwipsPerPixelY) Then VScroll4.Enabled = False
        Else
            Call DrawCTBlocks
        End If
    ElseIf RIMode = 1 And VS4Scrolling = 0 Then
        If (ShowPlotFlag = 1 Or ShowPlotFlag = 2) Or RelX <> 0 Or RelY <> 0 Then
            Frame17.Visible = False
        End If
        ''SS = Abs(GetTickCount)
        'For X = 0 To 1000
        'RecSeq = 0
        'PAVal = 0
        Call MakeSummary
       '' X = X
        'Next X
       '' EE = Abs(GetTickCount)
        ''TT = EE - SS
        '18.564 with getcorec
        '18.970 without get corec
        '18.595
        '14.508
        '17.441 with the loop
        '17.410
        '12.964 with cached string lengths
        '9.578 swm and swp
        '8.970
        'X = X
        '2.7
        '2.324 with f1p2sh
        '2.262 with "with form1.sspanel16
        '2.309 with f1p32sh
        '2.293 stpy
        '2.247
        
        '17.612 for 100
        '6.427 using f1p2sw
        '6.256 using f1p2sw*4
        '6.458
        '6.489
        '6.380
        '6.318'currx and curry
        '6.272 'be0 and be1
        '6.224
        '6.131 with "with form1.picture2"
        '6.115
        '4.275 using maxchars
        '4.322 using xoo
        '1.981 without getcorec
        '1.950 with getcorec
        'X = X
    End If
End Sub

Private Sub VScroll4_GotFocus()
If DebuggingFlag < 2 Then On Error Resume Next
    If Form1.Picture6.Enabled = False Then
        Form1.Command3.SetFocus
    Else
         If Form1.Picture6.Enabled = True Then
            Form1.Picture6.SetFocus
        End If
    End If
On Error GoTo 0
End Sub

Private Sub VScroll4_Scroll()

'Form1.Picture2.Height = Form1.Picture1.Height
If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
    
    If RIMode = 0 Then
        If ManFlag <> 161 Then
            Picture2.Top = (-VScroll4.Value) * Screen.TwipsPerPixelY
        
            If Picture2.Top = 0 And P2DHeight < (Picture32.ScaleHeight / Screen.TwipsPerPixelY) Then VScroll4.Enabled = False
        Else
            Call DrawCTBlocks
        End If
    ElseIf RIMode = 1 And VS4Scrolling = 0 Then
        Frame17.Visible = False
        Call MakeSummary
        x = x
    End If
End Sub

Private Sub VScroll5_Change()
ButtonScrollFlag = 1

If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
DontDoKey = 1
If Command3.Enabled = True And DontResetFocus = 0 Then
    Command3.SetFocus
End If
Dim TDist(1) As Double, UB As Long
If CurMatrixFlag = 2 Then
        UB = (UBound(MatrixM, 1) - 1)
ElseIf CurMatrixFlag = 1 Then
        UB = (UBound(MatrixR, 1) - 1)
ElseIf CurMatrixFlag = 0 Then
        UB = (UBound(MatrixC, 1) - 1)
ElseIf CurMatrixFlag = 14 Then
        UB = (UBound(MatrixTB, 1) - 1)
ElseIf CurMatrixFlag = 3 Then
        UB = (UBound(MatrixRR, 1) - 1)
ElseIf CurMatrixFlag = 4 Then
        UB = (UBound(MatrixBP, 1) - 1)

ElseIf CurMatrixFlag = 5 Then
    UB = UBound(MatrixLD, 1) - 1
ElseIf CurMatrixFlag = 6 Then
    UB = UBound(MatrixRMin, 1) - 1
ElseIf CurMatrixFlag = 7 Then
    UB = UBound(MatrixRMinD, 1) - 1
ElseIf CurMatrixFlag = 8 Then
    UB = UBound(MatrixMC, 1) - 1
ElseIf CurMatrixFlag = 11 Then
        UB = UBound(MatrixL, 1) - 1
ElseIf CurMatrixFlag = 12 Then
    UB = UBound(MatrixSH, 2) - 1
ElseIf CurMatrixFlag = 13 Then
    UB = UBound(MatrixRF, 2) - 1
End If




If Form1.VScroll5.Max < 1 Or Form1.HScroll4.Max < 1 Then
    If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 32000 And (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight > 0 Then
        Form1.VScroll5.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        Form1.HScroll4.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        
       ' Form1.VScroll5.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
       ' Form1.HScroll4.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
    ElseIf (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 1 Then
        Form1.HScroll4.Max = 0: Form1.HScroll4.Enabled = False
        Form1.VScroll5.Max = 0: Form1.VScroll5.Enabled = False
    Else
        Form1.VScroll5.Max = 32000
        Form1.HScroll4.Max = 32000
        MatZoom(CurMatrixFlag) = (Form1.HScroll4.Max + Form1.Picture26.ScaleHeight) / (Form1.Picture26.ScaleHeight * 2)
    End If
    If Form1.VScroll5.Max < 1 Then
        Form1.VScroll5.Max = 0
    End If
    If Form1.HScroll4.Max < 1 Then
        Form1.HScroll4.Max = 0
        
    End If

End If
If HScroll4.Max > 0 Then
    TDist(0) = (HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
Else
    TDist(0) = 0
End If
If VScroll5.Max > 0 Then
    TDist(1) = (VScroll5.Value / VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
Else
    TDist(1) = 0
End If
If F1MDF = 0 Then
    MatCoord(CurMatrixFlag, 0) = TDist(0) '* (MatZoom(CurMatrixFlag) - 1) '(TDist(0) * MatZoom(CurMatrixFlag)) / 4.5 '- UB / 2 * MatZoom(CurMatrixFlag) ' - UB / 2) / MatZoom(CurMatrixFlag)
    'MatCoord(CurMatrixFlag, 0) = (TDist(0) * MatZoom(CurMatrixFlag) - UB / 2) / MatZoom(CurMatrixFlag)
    MatCoord(CurMatrixFlag, 1) = TDist(1) ' * MatZoom(CurMatrixFlag) - UB / 2) / MatZoom(CurMatrixFlag)
End If
'ActualMidPixelV = TDist(1) + (UB / 2) / MatZoom(CurMatrixFlag)
'ActualMidPixelH = TDist(0) + (UB / 2) / MatZoom(CurMatrixFlag)
If MatCoord(CurMatrixFlag, 1) < 0 Then MatCoord(CurMatrixFlag, 1) = 0
'If MatCoord(CurMatrixFlag, 1) > UB Then MatCoord(CurMatrixFlag, 1) = UB

If MatCoord(CurMatrixFlag, 0) < 0 Then MatCoord(CurMatrixFlag, 0) = 0
'If MatCoord(CurMatrixFlag, 0) > UB Then MatCoord(CurMatrixFlag, 0) = UB

If HScroll4.Max = 0 Or VScroll5.Max = 0 Then
    MatCoord(CurMatrixFlag, 0) = 0
    MatCoord(CurMatrixFlag, 1) = 0
End If
    
If DoVS5 = 0 And Form1.SSPanel6(2).Visible = True Then
    If CurMatrixFlag = 2 Then
        Call ModMatMnu_Click
    ElseIf CurMatrixFlag = 0 Then
        Call CMMnu_Click(0)
    ElseIf CurMatrixFlag = 14 Then
        Call CMMnu_Click(1)
    ElseIf CurMatrixFlag = 1 Then
        Call RecMatMnu_Click
    ElseIf CurMatrixFlag = 3 Then
        Call RecRCMnu_Click
    ElseIf CurMatrixFlag = 4 Then
        Call RecBPMnu_Click
    ElseIf CurMatrixFlag = 5 Then
        Call LDMatMnu_Click
    ElseIf CurMatrixFlag = 6 Then
        Call RMinMnu_Click
    ElseIf CurMatrixFlag = 7 Then
        Call RMinDMnu_Click
    ElseIf CurMatrixFlag = 8 Then
        MCMSN = 1
        Call MCMatMnu_Click
        MCMSN = 0
    ElseIf CurMatrixFlag = 11 Then
        Call LMatMnu_Click
    ElseIf CurMatrixFlag = 12 Then
        Call SHMatrixMnu_Click
    ElseIf CurMatrixFlag = 13 Then
        Call RFMatrixMnu_Click
        x = x
    End If
   
End If
ButtonScrollFlag = 0
DontDoKey = 0
End Sub

Private Sub VScroll5_GotFocus()
DoVS5 = 0
HVScrollflag = 0
End Sub

Private Sub VScroll5_Scroll()

If Screen.MousePointer = 5 Or Screen.MousePointer = 7 Or Screen.MousePointer = 9 Then
        Screen.MousePointer = 0
    End If
Call VScroll5_Change

End Sub

Private Sub XOverGoToEventMnu_Click()
GTCS = -10
Call SelEventMnu_Click
End Sub
