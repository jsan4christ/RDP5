Attribute VB_Name = "Module2"
Public Sub BSXoverR2()

    SS = Abs(GetTickCount)
    Dim FF2 As Long, Largest As Double, Smallest As Double, S1 As Long, s2 As Long, S3 As Long
    Dim Modification As Double, DoneThis() As Byte, NumDone() As Double, MidNode() As Double, TallyDist As Double, MaxCurPos As Long, TB(1) As Long, MD As Double, oRec As Long, b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
    
    Dim OrderArray() As Byte
    Dim t0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long
    ReDim DstOut(BSBootReps - 1)
    'Start the timer
    STartT = Abs(GetTickCount)
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    
    
    'Dim NTree As Tree
    
    'Dim SubGrpMaskseq() As Byte
    ReDim MidNode(2)
    'ReDim SubMaskSeq(NextNo + 1), SubGrpMaskseq(NextNo + 1)
    ReDim RevSeq(NextNo)
    'If IndividualB <> -1 Then
    
    If IndividualA <> -1 Then
        NumberOfSeqs = 0
        For x = 0 To NextNo
            If MaskSeq(x) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = x
                RevSeq(x) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
            End If
        Next 'X

        NumberOfSeqs = NumberOfSeqs - 1
        ReDim tSeqnum(Len(StrainSeq(0)), NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 1 To Len(StrainSeq(0))
                tSeqnum(Y, x) = SeqNum(Y, SubMaskSeq(x))
            Next Y
        Next x
    Else
        'If sequences have been disabled/masked
        NumberOfSeqs = 0

        For x = 0 To NextNo

            If MaskSeq(x) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = x
                RevSeq(x) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
                x = x
            End If

        Next 'X

        NumberOfSeqs = NumberOfSeqs - 1
        ReDim tSeqnum(Len(StrainSeq(0)), NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 1 To Len(StrainSeq(0))
                tSeqnum(Y, x) = SeqNum(Y, SubMaskSeq(x))
            Next Y
        Next x
    End If
    
    NameLen = Len(Trim$(CStr(NumberOfSeqs)))
    If NameLen < 2 Then NameLen = 2
    If UseALFlag = 0 Then
        SZE = CLng((NumberOfSeqs * (NumberOfSeqs + 1) * (NumberOfSeqs - 1)) / 6)
       
        
        
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    
        ReDim OrderArray(SZE)
        ReDim GoOnA(SZE)
        ReDim GoOnB(SZE)
            
        UB = -1
        UB = UBound(GoOnB, 1)
        If UB = -1 Then
            MsgBox ("There is not enough available memory to run Bootscan in primary scanning mode. It will be be run in secondary scanning mode instead.")
            Erase OrderArray
            Erase GoOnA
            Erase GoOnB
            DoScans(0, 2) = 0
            DoScans(1, 2) = 1
            Exit Sub
        End If
        
        On Error GoTo 0
        
        
        Cnt = 0
        
        
        
        For Seq1 = 0 To NumberOfSeqs - 2
            For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
                For Seq3 = Seq2 + 1 To NumberOfSeqs
                    If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                        OrderArray(Cnt) = 0
                    ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                        OrderArray(Cnt) = 1
                    ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) Then
                        OrderArray(Cnt) = 2
                    End If
                    Cnt = Cnt + 1
                Next
            Next
        Next
    ElseIf UseALFlag = 1 Then
        SZE = TripListLen
        ReDim OrderArray(SZE)
        SZE = CLng((NumberOfSeqs * (NumberOfSeqs + 1)) / 2)
        'ReDim GoOnA(SZE)
        'ReDim GoOnB(SZE)
        
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    
        'ReDim OrderArray(SZE)
        ReDim GoOnA(SZE)
        ReDim GoOnB(SZE)
            
        UB = -1
        UB = UBound(GoOnB, 1)
        If UB = -1 Then
            MsgBox ("There is not enough available memory to run Bootscan in primary scanning mode. It will be be run in secondary scanning mode instead.")
            Erase OrderArray
            Erase GoOnA
            Erase GoOnB
            DoScans(0, 2) = 0
            DoScans(1, 2) = 1
            Exit Sub
        End If
        
        On Error GoTo 0
        
        Cnt = 0
        
        ReDim Preserve Analysislist(2, TripListLen)
        If TripListLen > 1000000 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5AnalysisList" + UFTag For Binary As #FF
            Get #FF, , Analysislist
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            'Erase AnalysisList
        End If
        For x = 0 To TripListLen
            Seq1 = Analysislist(0, x)
            Seq2 = Analysislist(1, x)
            Seq3 = Analysislist(2, x)
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                OrderArray(Cnt) = 0
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                OrderArray(Cnt) = 1
            ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) Then
                OrderArray(Cnt) = 2
            End If
            Cnt = Cnt + 1
        Next x
    End If
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "RDP5BSScanData" + UFTag
    KillFile "RDP5bsfile2" + UFTag
    On Error GoTo 0
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(BSStepWin)
    ReDim Prod2(BSStepWin)
    ReDim Prod3(BSStepWin)
    ReDim Alias(BSStepWin)
    ReDim Ally(BSStepWin)
    ReDim Location(BSStepWin)
    ReDim Px(NumberOfSeqs, BSStepWin)
    ReDim ttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    ReDim DistVal(BSBootReps + 1)
    ReDim Num1(BSBootReps + 1)
    ReDim Num2(BSBootReps + 1)
    ReDim DEN(BSBootReps + 1)
    ReDim num(BSBootReps + 1)
    ReDim WeightMod(BSBootReps, BSStepWin - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim Scratch(BSStepWin)
    'Do
        Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
       
    'Loop
    COffCount = (1 - BSCutOff) * BSBootReps
    
    
    Rnd (-BSRndNumSeed)

    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    ReDim BSFilePos(NextNo, NextNo)
    ReDim PltPos(NumWins + 1)
    'Work out nt positions at the center of every window

    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    MaxCurPos = NumberOfSeqs * 4
    FF = FreeFile
    Open "RDP5BSScanData" + UFTag For Binary As #FF
    

    ReDim bttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim NodeLen(MaxCurPos)
    ReDim TempNodeOrder(MaxCurPos)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    
    'Work out file read/write parameters
    Cnt = 0
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
            BSFilePos(SubMaskSeq(x), SubMaskSeq(Y)) = Cnt
            BSFilePos(SubMaskSeq(Y), SubMaskSeq(x)) = Cnt
            Cnt = Cnt + 1
        Next 'Y
    Next 'X
    BSRWSize = BSBootReps * 2
    BSRSize = BSRWSize * (NumWins + 1)
    BSWinRWChunk = BSRWSize * (NumberOfSeqs + 1) * (NumberOfSeqs) / 2
    GlobalMemoryStatus MemSit
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    
    BufferSize = APhys / 16
    BSRWBuffer = CLng(BufferSize / BSWinRWChunk)
    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
    FCNT = 0
    Dim ValidX() As Single, DiffsX() As Single
    For b = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), b, BSStepSize, BSStepWin, ttSeqNum(0, 0), tSeqnum(0, 0)
        If BSSubModelFlag <> 3 Then
            
            If BSSubModelFlag = 0 Then
                ReDim ValidX(BSBootReps), DiffsX(BSBootReps), DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
                
                Dummy = FastBootDistIP(0, BSBootReps, NumberOfSeqs, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), ttSeqNum(0, 0), DstMat(0, 0, 0))
                x = x
            Else
                ReDim Weight(BSBootReps, BSStepWin)
                
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, NumberOfSeqs + 1, BSStepWin, ttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), num(0), WeightMod(0, 0)
            End If
        Else

            For x = 0 To BSBootReps - 1
                
                If x > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(x, Z)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                bttSeqNum(SP, Y) = ttSeqNum(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To NumberOfSeqs
                            bttSeqNum(Z, Y) = ttSeqNum(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, NumberOfSeqs + 1, BSStepWin, bttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To NumberOfSeqs - 1

                    For Z = Y + 1 To NumberOfSeqs
                        DstMat(x, Y, Z) = tMat(Y, Z)
                        DstMat(x, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

            Next 'X

        End If
        
        If BSTypeFlag > 0 Then
            
            For x = 0 To BSBootReps - 1
               
                Dim Hi As Double, Hi2 As Double
                Dim AbBe() As Byte
                ReDim AbBe(MaxCurPos)
                GoOn = 0
                Hi = 0
                Hi2 = 0
                For Y = 0 To NumberOfSeqs
                    For Z = 0 To NumberOfSeqs
                        tMat(Y, Z) = DstMat(x, Y, Z)
                        If DstMat(x, Y, Z) > 0 Then
                            If Hi = 0 Then
                                Hi = DstMat(x, Y, Z)
                            ElseIf Hi2 = 0 And DstMat(x, Y, Z) <> Hi Then
                                Hi2 = DstMat(x, Y, Z)
                                If Hi <> DstMat(x, Y, Z) Then
                                    GoOn = 1
                                End If
                            ElseIf Hi > 0 And Hi2 > 0 And DstMat(x, Y, Z) <> Hi And DstMat(x, Y, Z) <> Hi2 Then
                                
                                    GoOn = 1
                                
                            End If
                        End If
                    Next 'Z

                Next 'Y
                
                ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                If GoOn = 1 Then
                    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
                    ReDim ColTotals(NumberOfSeqs)
                    Dim Treearray() As Single
                    ReDim Treearray(NumberOfSeqs, NumberOfSeqs)
                    LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 2, NumberOfSeqs + 1, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                    
                    LTree = LTree + 1
                    
                    
                    ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                    Call Tree2Array(0, NameLen, NumberOfSeqs, LTree, SHolder(), TMat2())
                        
                     
                End If
                    
                
                'find largest and smallest distances and then standardise so that they fall between 32000 and 0
                Smallest = 1000
                Largest = -1000
                For Seq1 = 0 To NumberOfSeqs - 1
    
                    For Seq2 = Seq1 + 1 To NumberOfSeqs
                        If TMat2(Seq1, Seq2) < Smallest Then
                            
                            Smallest = TMat2(Seq1, Seq2)
                        ElseIf TMat2(Seq1, Seq2) > Largest Then
                            Largest = TMat2(Seq1, Seq2)
                        End If
                        
                    Next 'Seq2
    
                Next 'Seq1
                
                
                If (Largest - Smallest) > 0 Then
                    Modification = 1 / (Largest - Smallest)
                Else
                    Modification = 0
                End If
                If Modification > 0 Then
                
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            'TMat2(Seq1, Seq2) = (TMat2(Seq1, Seq2) - Smallest) * Modification
                            'If TMat2(Seq1, Seq2) < 0.000032 Then TMat2(Seq1, Seq2) = 0
                            DstMat(x, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(x, Seq2, Seq1) = DstMat(x, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                Else
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            DstMat(x, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(x, Seq2, Seq1) = DstMat(x, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                
                End If

            
            Next 'X

        End If
        Cnt = 0
        For x = 0 To NumberOfSeqs - 1
            For Y = x + 1 To NumberOfSeqs
                    'this coluld be speeded up with better nesting of if then's

                Dummy = ScanPositive(b, BSCutOff, COffCount, x, Y, NumberOfSeqs, BSBootReps, GoOnA(Cnt), GoOnB(Cnt), OrderArray(Cnt), DstMat(0, 0, 0))
                
                SingleToInt x, Y, BSBootReps, NumberOfSeqs, DstMat(0, 0, 0), BSFileBuffer(FCNT) 'DstOut(0)
                FCNT = FCNT + BSBootReps
                If FCNT >= BSRWBuffer * BSWinRWChunk - BSBootReps Then
                    ReDim Preserve BSFileBuffer(FCNT - 1)
                    Put #FF, , BSFileBuffer()
                    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
                    FCNT = 0
                End If
                Cnt = Cnt + Dummy
            Next 'Y
        Next 'X
       
        
        'Update progress indicaters
        
        BSEnd = Abs(GetTickCount)
        If Abs(BSEnd - LastT) > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
            LastT = BSEnd
            Hold = ((b + 1) * 0.6) / (NumWins + 1)
            With Form1
                .ProgressBar1 = (b / NumWins) * 60
                .SSPanel1.Caption = b & " of " & NumWins & " windows examined"
                .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - STartT) / Hold) - Abs(BSEnd - STartT))) & " remaining"
                .Label50(4).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart)))
                .Label50(12).Caption = DoTimeII(Abs(BSEnd - Abs(ST)))
                .WindowState = .WindowState 'covered by currentlyrunning
            End With
            
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
            End If
            
            If AbortFlag = 1 Then
                Close #FF
                Close #FF2
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                ChDir oDir
                ChDrive oDir
                On Error GoTo 0
                CurWothwhilePos = 0
                Exit Sub
                
                                                   
            End If
        End If
        'Erase DstMat
    Next 'B
    
    ReDim Preserve BSFileBuffer(FCNT - 1)
    
    Put #FF, , BSFileBuffer()
    MD = MD
    'Close #FF
    
    Erase DstMat
    Erase bttSeqNum
    Erase tMat
    Erase SHolder
    Erase NodeLen
    Erase TempNodeOrder
    Erase Weight
    Erase NodeOrder
    Erase DoneNode
    
    Erase TMat2
    
  
    Erase Prod1
    Erase Prod2
    Erase Prod3
    Erase Alias
    Erase Ally
    Erase Location
    Erase Px
    Erase ttSeqNum
    Erase DistVal
    Erase Num1
    Erase Num2
    Erase DEN
    Erase num
    Erase WeightMod
    Erase OrderArray
    Erase BSFileBuffer
    Dim ReadNo As Long
    ReadNo = (BSRWBuffer * BSWinRWChunk) / (2 * BSBootReps * (NumWins))
    'ReadNo = 2
    ReDim BSFileBuffer(BSBootReps * (NumWins) * ReadNo - 1)
    Dim PosA As Long, SortArray() As Integer
    ReDim SortArray(BSBootReps * ReadNo)
    S1 = 0
    s2 = 1
    Pos = 1
    'PosA = 0
    Dim NumPairs As Long
    NumPairs = NumberOfSeqs * (NumberOfSeqs + 1) / 2
    
    ' If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    'For X = 500 To 2000
    '
    '
    '    Close #X
    '
    'Next X
    'On Error GoTo 0
    
    'For X = 10 To 500
   '
   '
   '     Close #X
   '
   ' Next X
    
    'If AbortFlag = 1 Then
        
    'End If
    
    FF2 = FreeFile
    'for x =
    BSFileName = "RDP5bsfile2" + UFTag
    Open BSFileName For Binary As #FF2
    
    Spos = 1
    For x = 1 To NumPairs Step ReadNo
            Pos = Spos
            For Y = 0 To NumWins - 1
                PosA = 0
               Get #FF, Pos, SortArray()
                PosA = ReSortArray(Y, NumWins, PosA, ReadNo, BSBootReps, BSFileBuffer(0), SortArray(0))
                Pos = Pos + BSWinRWChunk
                XX = SortArray(16) '2385,2434(2094),1756(2434),2194(1953),2256(1756),..(2219),..(2198),..(2194)
                'pos = 60001,120001,180001
                '2385,2098,2434,1953,1756
'                If Y = 450 Then
'                    ReDim TAIX(UBound(SortArray))
'                    For AA = 0 To UBound(SortArray)
'                         TAIX(AA) = SortArray(AA)
'
'                    Next AA
'                End If
            Next Y
            
            BSEnd = Abs(GetTickCount) 'Take the time
            If BSEnd - LastT > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
                LastT = BSEnd
                If AbortFlag = 1 Then
                        Close #FF
                        Close #FF2
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
                        CurWothwhilePos = 0
                        Exit Sub
                End If
                                
                'Write progress to the screen
                                
                With Form1
                                    '.ProgressBar1 = 60 + (B / MCCorrection) * 40
                                    .SSPanel1.Caption = x & " of " & NumPairs & " pairs sorted"
                                   '.SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - StartT) / Hold) - (BSEnd - StartT))) & " remaining"
                                    '.label50(5).Caption = cstr(TotalBSRecombinants)
                                    '.label50(13).Caption = cstr( oRecombNo(100) )
                                    .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                    .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                    .Refresh: .WindowState = .WindowState
                End With
            
            End If
            Spos = Spos + ReadNo * BSBootReps * 2
            
            Put #FF2, , BSFileBuffer()
    Next x
Close #FF
If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
KillFile "RDP5BSScanData" + UFTag
On Error GoTo 0
Erase SortArray
Erase BSFileBuffer
'Close #FF2
'Exit Sub
STartT = Abs(GetTickCount)
    SS = Abs(GetTickCount)
    Dim GrpTest As Long
    'Open "RDP5BSScanData" For Binary Access Read As #FF Len = BSBootReps
    
    ReDim t0(BSBootReps * (NumWins + 1) - 1)
    ReDim T1(BSBootReps * (NumWins + 1) - 1)
    ReDim T2(BSBootReps * (NumWins + 1) - 1)
    Dim OverlapNumB As Integer
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim PltVal(2, NumWins)
    OverlapNumB = (BSStepWin / BSStepSize)
    b = 0
    If IndividualB <> -1 Then
        Seq1 = RevSeq(IndividualA)
            Seq2 = RevSeq(IndividualB)
                'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                                        
                        For Seq3 = 0 To NumberOfSeqs
                            
                            If SelGrpFlag = 1 Then
                                If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
                                    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                    Close #FF2
                                    Close #FF
                                    ChDir oDir
                                    ChDrive oDir
                                    On Error GoTo 0
                                    Exit Sub
                                End If
                            End If
                            
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 And Seq3 <> Seq2 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                           
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), t0()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  'For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                 'Next 'Y
                                           Else
                                                'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                'Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           tSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            s2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                            'Call FindSubSeqBS
                                           
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                b = b + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount) 'Take the time
                                If Abs(BSEnd - GlobalTimer) > 500 Then ' Give an update on progress every half second
                                    GlobalTimer = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                        Close #FF
                                        Close #FF2
                                        ChDir oDir
                                        ChDrive oDir
                                        On Error GoTo 0
                                        x = GetNumInList(Seq1, Seq2, Seq3)
                                        If CurWothwhilePos > x Then CurWothwhilePos = x
                                        Exit Sub
                                    End If
                                    
                                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        If 60 + (b / MCCorrection) * 40 <= 100 Then
                                            .ProgressBar1 = 60 + (b / MCCorrection) * 40
                                            .SSPanel1.Caption = b & " of " & MCCorrection & " triplets examined"
                                            .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - STartT) / Hold) - Abs(BSEnd - STartT))) & " remaining"
                                        End If
                                        UpdateRecNums (SEventNumber)
                                        .Label50(4).Caption = DoTimeII(Abs(BSEnd - BSStart)) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label50(12).Caption = DoTimeII(Abs(BSEnd - ST)) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        .Refresh: .WindowState = .WindowState
                                    End With
                                    If (CLine <> "" And CLine <> " ") Then
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole vbClearLine
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                    End If
                                End If
                            End If
                        Next 'Seq3
                    
    ElseIf IndividualA <> -1 Then
        Seq1 = RevSeq(IndividualA)
                For Seq2 = 0 To NumberOfSeqs - 1
                    If Seq2 <> Seq1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                        
                        For Seq3 = Seq2 + 1 To NumberOfSeqs
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                           
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), t0()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  'For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                 'Next 'Y
                                           Else
                                                'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                'Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           tSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            s2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                            
                                           ' Call FindSubSeqBS
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                b = b + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount) 'Take the time
                                If Abs(BSEnd - GlobalTimer) > 500 Then ' Give an update on progress every half second
                                    GlobalTimer = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        Close #FF
                                        Close #FF2
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                                        ChDir oDir
                                        ChDrive oDir
                                        On Error GoTo 0
                                        x = GetNumInList(Seq1, Seq2, Seq3)
                                        If CurWothwhilePos > x Then CurWothwhilePos = x
                                        Exit Sub
                                    End If
                                    
                                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        .ProgressBar1 = 60 + (b / MCCorrection) * 40
                                        .SSPanel1.Caption = b & " of " & MCCorrection & " triplets examined"
                                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                                        UpdateRecNums (SEventNumber)
                                        .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        .Refresh: .WindowState = .WindowState
                                    End With
                                    If (CLine <> "" And CLine <> " ") Then
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole vbClearLine
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                    End If
                
                                End If
                            End If
                        Next 'Seq3
                    End If
                Next 'Seq2

    Else
        If UseALFlag = 1 Then  'this doesnt work becaus ethe goona and goonb arrays are not properly updated
            'is it necessery to redim this here?
            
            
            For x = 0 To TripListLen
                Seq1 = Analysislist(0, x)
                Seq2 = Analysislist(1, x)
                Seq3 = Analysislist(2, x)
                
               ' If GoOn = 1 Then
                                               
                    'Establish the position of each relevent value in the distance matrices
                
                     Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), t0()
                     Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                     Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                     If ShowPlotFlag = 1 Then
                          GetPltVal2 BSBootReps, 0, NumWins, t0(0), T1(0), T2(0), PltVal(0, 0)
                     Else
                          
                          GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                     End If
                     
                     'Look for evidence of recombination when the entire plot is completed
                     tSeq1 = Seq1
                     tSeq2 = Seq2
                     tSeq3 = Seq3
                      S1 = SubMaskSeq(Seq1)
                      s2 = SubMaskSeq(Seq2)
                      S3 = SubMaskSeq(Seq3)
                      
                      
                      LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                      'Call FindSubSeqBS
                     ' zz = 0
                     'For X = 0 To Len(StrainSeq(0))
                     '     zz = zz + Scores(X, 2)
                     'Next X
                     Call ScanBSPlots(TotalCycles, 0)
                     'B = B + 1
                 'End If
                
                BSEnd = Abs(GetTickCount) 'Take the time
                If BSEnd - GlobalTimer > 500 Then ' Give an update on progress every half second
                    b = x
                    GlobalTimer = BSEnd
                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        StartPlt(2) = 1
                        oRec = oRecombNo(100)
                        Call UpdatePlotC
                    End If
                    
                    If AbortFlag = 1 Then
                        Close #FF
                        Close #FF2
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                        ChDir oDir
                        ChDrive oDir
                        x = GetNumInList(Seq1, Seq2, Seq3)
                        If CurWothwhilePos > x Then CurWothwhilePos = x
                        On Error GoTo 0
                        Exit Sub
                    End If
                    
                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                    'Write progress to the screen
                    
                    With Form1
                        PBV = (b / TripListLen)
                        If PBV > 1 Then PBV = 1
                        .ProgressBar1 = 60 + PBV * 40
                        .SSPanel1.Caption = b & " of " & TripListLen & " triplets examined"
                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                        UpdateRecNums (SEventNumber)
                        .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                        .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                        .Refresh: .WindowState = .WindowState
                    End With
                    If (CLine <> "" And CLine <> " ") Then
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole vbClearLine
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                    End If
                End If
            Next x
            TT = Abs(GetTickCount)
            If TT - GlobalTimer > 500 Then
              GlobalTimer = TT
                Form1.SSPanel1.Caption = Trim(Str(TripListLen)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                Form1.SSPanel1.Refresh
                Form1.Refresh
                If DebuggingFlag < 2 Then
                    Form1.WindowState = Form1.WindowState
                End If
            End If
        Else
        
            For Seq1 = 0 To NumberOfSeqs - 2
                'If MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                    'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                    For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
                        'If Then
                            
                            For Seq3 = Seq2 + 1 To NumberOfSeqs
                                If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                    
                                    If GoOnA(TotalCycles) > 0 Then
                                        GoOnA(TotalCycles) = 1
                                        GoOnB(TotalCycles) = NumWins
                                        If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                              
                                              If GoOnA(TotalCycles) > OverlapNumB Then
                                                    GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                                Else
                                                    GoOnA(TotalCycles) = 1
                                                End If
                                                
                                                If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                    GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                                Else
                                                    GoOnB(TotalCycles) = NumWins
                                                End If
                                                
                                                If QvRFlag = 1 Then
                                                    GoOn = 0
                                                    If ReferenceList(Seq1) = 0 Then
                                                        If ReferenceList(Seq2) <> 0 And ReferenceList(Seq3) <> 0 And ReferenceList(Seq2) <> ReferenceList(Seq3) Then GoOn = 1
                                                    ElseIf ReferenceList(Seq2) = 0 Then
                                                        If ReferenceList(Seq1) <> 0 And ReferenceList(Seq3) <> 0 And ReferenceList(Seq1) <> ReferenceList(Seq3) Then GoOn = 1
                                                    ElseIf ReferenceList(Seq3) = 0 Then
                                                        If ReferenceList(Seq2) <> 0 And ReferenceList(Seq1) <> 0 And ReferenceList(Seq2) <> ReferenceList(Seq1) Then GoOn = 1
                                                    End If
                                                ElseIf SelGrpFlag > 0 Then
                                                    GoOn = 1
                                                    GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                    If GrpTest < 2 Then
                                                        GoOn = 0
                                                    End If
                                                Else
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                
                                                
                                               
                                               'Establish the position of each relevent value in the distance matrices
                                               
                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), t0()
                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
'                                                    If Seq1 = 0 And Seq2 = 1 And Seq3 = 2 Then
'                                                        ReDim TAIX(UBound(t0))
'                                                        For AA = 0 To UBound(t0)
'                                                            TAIX(AA) = t0(AA)
'                                                        Next AA
'                                                        x = x
'                                                    End If
                                                    '1,96201,2308801
'                                                    If Seq1 = 10 And Seq2 = 19 And Seq3 = 23 Then
'                                                        XX = t0(33000) '0
'                                                        XX = T1(33000) '765
'                                                        XX = T2(33000) '765
'                                                        XX = UBound(t0) '48200
'
'                                                    End If
                                                    
                                                    If ShowPlotFlag = 1 Then
                                                         GetPltVal2 BSBootReps, 0, NumWins, t0(0), T1(0), T2(0), PltVal(0, 0)
                                                    Else
                                                         
                                                         GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                    End If
                                                    
                                                    'Look for evidence of recombination when the entire plot is completed
                                                    tSeq1 = Seq1
                                                    tSeq2 = Seq2
                                                    tSeq3 = Seq3
                                                     S1 = SubMaskSeq(Seq1)
                                                     s2 = SubMaskSeq(Seq2)
                                                     S3 = SubMaskSeq(Seq3)
                                                     
                                                     
                                                     LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                                     'Call FindSubSeqBS
                                                    ' zz = 0
                                                    'For X = 0 To Len(StrainSeq(0))
                                                    '     zz = zz + Scores(X, 2)
                                                    'Next X
                                                    Call ScanBSPlots(TotalCycles, 0)
                                                    b = b + 1
                                                End If
                                           
                '                           Else
                '                               X = X
                '                           End If
                                            
                                       End If
                                    End If
                                    
                                    TotalCycles = TotalCycles + 1
                                    'PBCount = PBCount + 1
                                    BSEnd = Abs(GetTickCount) 'Take the time
                                    If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                        LastT = BSEnd
                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(2) = 1
                                            oRec = oRecombNo(100)
                                            Call UpdatePlotC
                                        End If
                                        
                                        If AbortFlag = 1 Then
                                            Close #FF
                                            Close #FF2
                                            If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    
                                            ChDir oDir
                                            ChDrive oDir
                                            On Error GoTo 0
                                            x = GetNumInList(Seq1, Seq2, Seq3)
                                            If CurWothwhilePos > x Then CurWothwhilePos = x
                                            Exit Sub
                                        End If
                                        If b > 0 Then
'                                            If UseALFlag > 0 Then
'                                                Hold = B / TripListLen 'Work out proportion of cycles completed
'
'                                            Else
                                                Hold = b / MCCorrection 'Work out proportion of cycles completed
'                                            End If
                                        
                                        'Write progress to the screen
                                        
                                            With Form1
'                                                If UseALFlag = 1 Then
'                                                    pbv = (B / TripListLen)
'                                                Else
'                                                    pbv = (B / MCCorrection)
'                                                End If
                                                If PBV > 1 Then PBV = 1
                                                .ProgressBar1 = 60 + Hold * 40
                                                If UseALFlag = 1 Then
                                                    .SSPanel1.Caption = b & " of " & Trim(Str(TripListLen)) & " triplets examined"
                                                Else
                                                    .SSPanel1.Caption = b & " of " & Trim(Str(MCCorrection)) & " triplets examined"
                                                End If
                                                .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                                                UpdateRecNums (SEventNumber)
                                                .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                                .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                                .Refresh: .WindowState = .WindowState
                                            End With
                                            If (CLine <> "" And CLine <> " ") Then
                                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                                WriteToConsole vbClearLine
                                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                                WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                            End If
                                        End If
                        
                                    End If
                                Else
                                    TotalCycles = TotalCycles + 1
                                End If
                            Next 'Seq3
                        'End If
                    Next 'Seq2
                'End If
            Next 'Seq1
        End If
    End If
    Erase GoOnA
    Erase GoOnB
    Erase PltVal
    
    
                            BSEnd = Abs(GetTickCount) 'Take the time
                            'If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                LastT = BSEnd
                                
                                
                                'Write progress to the screen
 TT = Abs(GetTickCount)
 If Abs(TT - GlobalTimer) > 500 Or x = x Then
    GlobalTimer = TT
 
        With Form1
            UpdateRecNums (SEventNumber)
            .Label50(4).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart))) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
            .Label50(12).Caption = DoTimeII(Abs(BSEnd - Abs(ST))) 'Str$((Int((BSEnd - ST) / 100)) / 10)
            .Refresh: .WindowState = .WindowState
        End With
            x = x
                            'End If
    End If
    
    '3.127
    EE = Abs(GetTickCount)
    TT = EE - SS
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Close #FF
    Close #FF2
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub
Public Sub TreeDrawingDIB(OnlyNames, NoP3Flag, TreeBlocksL() As Long, TBLLen As Long, TNF As Byte, OriginalName() As String, IStart As Long, TNum, TType, TreeDrawB() As Single, TDLen() As Long, TreeBlocks() As Long, TBLen() As Long, PB As PictureBox)


Dim UBY As Long, UBX As Long, D As Long, Dummy As Long, VSMax As Long, OVx As Single, OM As Long, OV As Long, OVy As Long, otTYF As Single, PRat As Single, GoOn As Long, TSH As Long, PntAPI As POINTAPI, Pict3 As Long, Pict As Long, OFS As Double, x As Long, ScaleX As String, ScaleL As Double, TargY As Single
Dim tTYF As Double, TYFM As Integer, OS As Long, oTNum As Long, TSingle As Single, oTSingle As Single, TDL1 As Long, TDL0 As Long, TBL As Long
Dim UBTTS1 As Long, UBTTS2 As Long, UBTT As Long
Dim UBTD5 As Long, UBON As Long, UBTBL As Long, UBTB4 As Long, UBMB4 As Long, UBMC As Long
Dim AH1 As Long, AH2 As Long, AH3 As Long, AH4 As Long
Dim XMod As Single, TVN As String, MaxXPos As Single, CXP As Single, hdcHolder As Long
Dim LoFnt As Long, OldFont As Long, OldFont2 As Long
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number

Exit Sub
hdcHolder = tDib.hdc

If TYF2 = 0 Then Exit Sub
If CurrentlyRunningFlag = 1 Then Exit Sub

TDL1 = TDLen(TNum, TType, 1)
TDL0 = TDLen(TNum, TType, 0)

If TDL1 = 0 And TDL0 = 0 Then Exit Sub

If OnlyNamesFlag > 0 Then
    OnlyNames = 1
End If



PRat = -1: oTNum = TNum
If DebuggingFlag < 2 Then On Error Resume Next
PRat = TDLen(TNum, TType, 2) / PB.ScaleWidth '384
If PRat = -1 Then Exit Sub
On Error GoTo 0




If TDL1 = 0 Then
    NoP3Flag = 1
    TNum = 0
    TNF = 0
End If

Dim FI As Byte

PB.AutoRedraw = True
'
'PB.Picture = LoadPicture()
'XX = PB.hDC


''''
Pict = hdcHolder
'Pict = 1
'PB.Height = 2000
Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
Dim LBrush As LOGBRUSH
'Dim AdjVSVModY As Single

PEN = CreatePenIndirect(LPen)
oldpen = SelectObject(Pict, PEN)
Brush = CreateBrushIndirect(LBrush)
OldBrush = SelectObject(Pict, Brush)



            '@
LBrush.lbColor = BackColours
LPen.lopnColor = BackColours
            
PEN = CreatePenIndirect(LPen)
Pen2 = SelectObject(Pict, PEN)
Brush = CreateBrushIndirect(LBrush)
Brush2 = SelectObject(Pict, Brush)
            
DeleteObject (Pen2)
DeleteObject (Brush2)
            
Dummy = Rectangle(Pict, 0, 0, PB.Width, PB.Height)
            

''''
'PB.Line (0, 0)-(PB.Width, PB.Height), BackColours, BF 'this clears the trees


If PB.hdc = Form1.Picture16.hdc Then
    FI = 1
Else
    FI = 0
End If
' XX = PB.Height '19020,17660
'This makes sure dots etc are reset to 0
'SelectNode(0) = -1

PB.ScaleMode = 3
PB.FontSize = 8.25

PB.FontSize = PB.FontSize * TYF2

Dim TH As Single, TW As Single
TH = PB.TextHeight("O")
TW = PB.TextWidth("O")
LoFnt = CreateFont(PB.FontSize * 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture16.Font.Name)
OldFont = SelectObject(Pict, LoFnt)


Call ModOffsets(8.25, PB, tTYF, TYFM)

otTYF = tTYF
TSingle = tTYF
oTSingle = otTYF

If DebuggingFlag < 2 Then On Error Resume Next
UBMC = UBound(MultColour, 1)
If UBMC < (NextNo * 2) Then
    ReDim Preserve MultColour(NextNo * 2)
End If
UBMB4 = UBound(MapBlocks, 4)
UBTB4 = UBound(TreeBlocks, 4)
UBTD5 = UBound(TreeDraw, 5)
UBTTS2 = UBound(TreeTraceSeqs, 2)
UBTTS1 = UBound(TreeTraceSeqs, 1)
UBTT = UBound(TreeTrace, 1)
UBON = UBound(OriginalName)
UBTBL = UBound(TreeBlocksL, 4)
On Error GoTo 0

'do picture16 stuff
If FI = 1 Then 'PB = Form1.Picture16 Then
    
    
    OVy = VSC1NC
    VSC1NC = 1
    With Form1.VScroll1
        If .Max <= 0 Then .Value = 0
        OV = .Value
        OM = .Max
        If OM > 0 Then
            OVx = OV / OM
        Else
            OVx = 1
        End If
        
        If TDLen(TNum, CTF, 1) > 0 And UBTD5 >= TDLen(TNum, CTF, 1) Then
            VSMax = -PB.ScaleHeight + ((TreeDrawB(1, TDLen(TNum, CTF, 1), TNum, CTF, 1) + 1) * oTSingle) + 200 'PB.ScaleHeight = 806; ctf = 0; ottyf =1,018, treetypeflag = 2
            '464
        ElseIf UBTD5 >= TDLen(0, 1, 1) Then
            VSMax = -PB.ScaleHeight + ((TreeDrawB(1, TDLen(0, 1, 1), TNum, CTF, 1) + 1) * oTSingle) + 200
        End If
        If OM = 0 Then OM = 1
        If VSMax > 32000 Then
            F1VS1ScaleFactor = CSng(VSMax / 32000) '38409'1.033
            VSMax = 32000
        Else
            F1VS1ScaleFactor = 1
            x = x
        End If
        
        .Max = VSMax '-Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
        If .Max > 0 And OM > 0 Then
            If OVx * VSMax <= .Max Then
                .Value = OVx * VSMax
            ElseIf .Max > 0 Then
                .Value = .Max
            End If
        End If
        If .Max <= 0 Then
            .Enabled = False
        Else
            If Form1.Picture9.ScaleHeight = 0 Then Exit Sub
            .LargeChange = Form1.Picture9.ScaleHeight
            .Enabled = True
        End If
        
    End With
    VSC1NC = OVy
    IStart = IStart * F1VS1ScaleFactor
Else
    IStart = IStart * F2VSScaleFactor(TNum)
End If



'First Draw all the lines

PB.ForeColor = 0
'
PB.DrawMode = 13
TSH = PB.ScaleHeight

GoOn = 0

If PRat = 0 Then PRat = 1

'SS = Abs(GetTickCount)
Dim CharLen As Long
CharLen = PB.TextWidth("O")
MaxXPos = 0
If TDL0 > UBTD5 Then TDLen(TNum, TType, 0) = UBTD5: TDL0 = UBTD5
If (TNum = 3 And TType = 0) Or (TNum = 3 And TType = 1) Then
    For x = 0 To TDL0
            CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
            
            AH1 = TreeDrawB(2, x, TNum, TType, 0)
            If AH1 > -1 Then
                If AH1 <= UBON Then
                        
                    'TVN = OriginalName(AH1)
                    CXP = CXP + CharLen * (ONameLen(AH1) + 2)

                
                End If

            
            End If
            
            'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
            If CXP > MaxXPos Then
                MaxXPos = CXP
                
            End If
     Next x

ElseIf TNum <> 0 Then
    If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
        For x = 0 To TDL0
                CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
                
                AH1 = TreeDrawB(2, x, TNum, TType, 0)
                If AH1 > -1 Then
                    
                    If AH1 <= UBON Or TType = 2 Or TType = 4 Then
                           ' TVN = BigTreeName(AH1)
                            CXP = CXP + CharLen * (Len(BigTreeName(AH1)) + 2)
                    
                    End If

                
                End If
                
                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
                If CXP > MaxXPos Then
                    MaxXPos = CXP
                End If
         Next x
    Else
        If x = x Then
            MaxXPos = GetMaxXPosB(UBound(TreeTraceSeqs, 1), UBound(TreeTraceSeqs, 2), UBound(TreeTrace, 1), CharLen, TNum, TType, TDL0, UBON, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, ONameLen(0), TreeDrawB(0, 0, 0, 0, 0), TreeTraceSeqs(0, 0), TreeTrace(0))
        Else
            For x = 0 To TDL0
                    
                CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
                
                AH1 = TreeDrawB(2, x, TNum, TType, 0)
                If AH1 > -1 Then
                    
                    If AH1 <= UBON Then
                        
                        If UBTTS1 > 0 Then
                            If UBTTS2 >= x Then
                                AH2 = TreeTraceSeqs(1, AH1)
                                If UBTT >= AH2 Then
                                    If TreeTrace(AH2) <= UBON Then
                                        'TVN = OriginalName()
                                        CXP = CXP + CharLen * (ONameLen(TreeTrace(AH2)) + 2)
                                    End If
                                End If
                            End If
                        End If
    
                    End If
    
                End If
                
                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
                If CXP > MaxXPos Then
                    MaxXPos = CXP
                End If
             Next x
        End If
    End If

Else
     '
     If UBON > 0 Then
     'If X = X Then
        MaxXPos = GetMaxXPos(CharLen, TNum, TType, TDL0, UBON, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, ONameLen(0), TreeDrawB(0, 0, 0, 0, 0))
'     Else
'         For X = 0 To TDL0
'
'                CXP = TreeDrawB(0, X, TNum, TType, 0) / PRat
'
'                AH1 = TreeDrawB(2, X, TNum, TType, 0)
'                If AH1 > -1 Then
'                    If AH1 <= UBON Then
'                        'TVN = OriginalName(AH1)
'                        CXP = CXP + CharLen * (ONameLen(AH1) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
'
'                    End If
'
'                End If
'
'                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
'                If CXP > MaxXPos Then '569.6
'                    MaxXPos = CXP
'
'                End If
'         Next X
'    End If
    End If
    x = x
End If
'XX = MaxONameLen

TreeXScaleMod(FI, TNum, TType) = PB.ScaleWidth / MaxXPos
XMod = TreeXScaleMod(FI, TNum, TType)

PRat = PRat / XMod

'Make sure the scalebar is in black
If TDL1 > UBTD5 Then TDLen(TNum, TType, 1) = UBTD5: TDL1 = UBTD5
TreeDraw(TNum, TType, 1, 4, TDL1) = 0
TreeDrawB(4, TDL1, TNum, TType, 1) = 0

'******************
'*Draw the branches
'******************
OS = 0
GoOn = 0
Dim TargetA As Single, TSHx As Single

TSHx = (TSH - IStart) / TSingle
TargetA = -(IStart / TSingle)
'If OnlyNames = 0 Then
'    If X = 12345 Then
'        Do
'            Dummy = FindNextBranch(TSH, tTYF, IStart, TNum, TType, TDLen(TNum, TType, 1), OS, GoOn, X, TreeDraw(0, 0, 0, 0, 0))
'            If X < TDLen(TNum, ttpe, 1) Then
'                PB.ForeColor = TreeDraw(TNum, TType, 1, 4, X)
'                Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, X) / PRat, (IStart + TreeDraw(TNum, TType, 1, 1, X) * TSingle), PntAPI) '280,280,279
'                Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, X) / PRat, (IStart + TreeDraw(TNum, TType, 1, 3, X) * TSingle))
'                X = X + 1
'            Else
'               Exit Do
'            End If
'
'        Loop
'    Else
 'If X = 12345 Then
 
 
 
 'If X = X Then
    '''
    GoOn = DrawTreeLines(Pict, IStart, TSHx, TargetA, TNum, TType, TDL1, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, TSingle, OS, TreeDrawB(0, 0, 0, 0, 0))
    
 'Else
 
'        For X = 0 To TDL1
'        'For X = LastSE(TNum, TType, 0) To LastSE(TNum, TType, 1)
'
'            AH1 = TreeDrawB(1, X, TNum, TType, 1)
'
'            AH2 = TreeDrawB(3, X, TNum, TType, 1)
'
'            If AH1 >= TargetA Or AH2 >= TargetA Then
'
'
'
'                If AH1 <= TSHx Or AH2 <= TSHx Then
'                    'AH1 = X
'                    'AH2 = X
''                    If RedoLastSE(TNum) = 0 Then
''                        RedoLastSE(TNum) = 1
''                        LastSE(TNum, TType, 0) = X
''                    End If
'
'                    PB.ForeColor = TreeDrawB(4, X, TNum, TType, 1)
'
'                    Dummy = MoveToEx(Pict, TreeDrawB(0, X, TNum, TType, 1) / PRat, IStart + AH1 * TSingle, PntAPI) '280,280,279
'
'                    Dummy = LineTo(Pict, TreeDrawB(2, X, TNum, TType, 1) / PRat, IStart + AH2 * TSingle)
'                    'LastSE(TNum, TType, 1) = X
'                Else
'
'                    If AH1 > OS Then
'                        OS = AH1
'                        GoOn = 1
'                    End If
'                End If
'            End If
'        Next X
    'End If
'End If
'Form1.SSPanel6(1).Visible = True

'End If

x = TDL1 + 1

If GoOn = 0 Then
    PB.CurrentY = IStart + TreeDrawB(3, x - 1, TNum, TType, 1) * TSingle
End If

If OS < PB.CurrentY Then
    OS = PB.CurrentY + 44  'IStart + TreeDraw(TNum, TType, 1, 1, TDLen(TNum, TType, 1)) * tTYF
Else
    OS = OS + 44
End If

PB.DrawMode = 13



Dummy = SetBkMode(Pict, 1)


'*********************************
'*Then Draw all legend  blocks
'********************************
If TNum = 3 And TType >= 2 Then
    If OS < TSH And TBLLen > 0 Then
        OFS = PB.FontSize
        PB.FontSize = 7
        TH = PB.TextHeight("O")
        TW = PB.TextWidth("O")
        LoFnt = CreateFont(PB.FontSize * 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture16.Font.Name)
        OldFont2 = SelectObject(Pict, LoFnt)
        DeleteObject (OldFont2)
        'Pict = PB.hdc
        For x = 0 To UBTBL
            If TreeBlocksL(TNum, TType, 0, x) <> -1 Then
                If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                    LBrush.lbColor = TreeBlocks(TNum, TType, 4, x)
                    LPen.lopnColor = TreeBlocks(TNum, TType, 4, x)
                                
                    PEN = CreatePenIndirect(LPen)
                    Pen2 = SelectObject(Pict, PEN)
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                                
                    DeleteObject (Pen2)
                    DeleteObject (Brush2)
                    Dummy = Rectangle(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x))
                    'PB.Line (TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X))-(TreeBlocksL(TNum, TType, 2, X), OS + TreeBlocksL(TNum, TType, 3, X)), -TreeBlocksL(TNum, TType, 4, X), BF
                Else
                    If TBS(TreeBlocksL(TNum, TType, 2, x)) <> "" And TreeBlocksL(TNum, TType, 0, x) <> 0 Then '"Potential recombinant " Then
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                            'X = X
                        End If
                    Else
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                        
                            If (RelX > 0 Or RelY) > 0 And TreeBlocksL(TNum, TType, 0, x) <> 0 Then
                                Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                                x = x
                            End If
                        End If
                    End If
                End If
            End If
        Next x
        PB.FontSize = OFS
        TH = PB.TextHeight("O")
        TW = PB.TextWidth("O")
        LoFnt = CreateFont(PB.FontSize * 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture16.Font.Name)
        OldFont2 = SelectObject(Pict, LoFnt)
        DeleteObject (OldFont2)
    End If

Else

    If OS < TSH And TBLLen > 0 Then
        OFS = PB.FontSize
        PB.FontSize = 7
        'Pict = PB.hDC
        TH = PB.TextHeight("O")
        TW = PB.TextWidth("O")
        LoFnt = CreateFont(PB.FontSize * 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture16.Font.Name)
        OldFont2 = SelectObject(Pict, LoFnt)
        DeleteObject (OldFont2)
        For x = 0 To UBTBL
            If TreeBlocksL(TNum, TType, 0, x) <> -1 Then
                If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                    GoOn = 1
                    If x > 1 Then
                        
                        If TBS(TreeBlocksL(TNum, TType, 2, x + 1)) = TBS(TreeBlocksL(TNum, TType, 2, x - 1)) Then
                            GoOn = 0
                        End If
                    End If
                    If GoOn = 1 Then
                        LBrush.lbColor = -TreeBlocksL(TNum, TType, 4, x)
                        LPen.lopnColor = -TreeBlocksL(TNum, TType, 4, x)
                                    
                        PEN = CreatePenIndirect(LPen)
                        Pen2 = SelectObject(Pict, PEN)
                        Brush = CreateBrushIndirect(LBrush)
                        Brush2 = SelectObject(Pict, Brush)
                                    
                        DeleteObject (Pen2)
                        DeleteObject (Brush2)
                        Dummy = Rectangle(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x))
                        
                        
                        'PB.Line (TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X))-(TreeBlocksL(TNum, TType, 2, X), OS + TreeBlocksL(TNum, TType, 3, X)), -TreeBlocksL(TNum, TType, 4, X), BF
                    End If
                    x = x
                Else
                    If TBS(TreeBlocksL(TNum, TType, 2, x)) <> "" And TreeBlocksL(TNum, TType, 0, x) <> 0 Then '"Potential recombinant " Then
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                        End If
                    Else
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                        
                            If (RelX > 0 Or RelY) > 0 And TreeBlocksL(TNum, TType, 0, x) <> 0 Then
                                Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                                x = x
                            End If
                        End If
                    End If
                End If
            End If
        Next x
        PB.FontSize = OFS
        TH = PB.TextHeight("O")
        TW = PB.TextWidth("O")
        LoFnt = CreateFont(PB.FontSize * 1.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture16.Font.Name)
        OldFont2 = SelectObject(Pict, LoFnt)
        DeleteObject (OldFont2)
    End If
End If

'*******************************
'*mark parents and recombinants
'******************************
Dim XXMod As Single, XxXMod As Single
XxXMod = 1

If PB.FontSize = 7.5 Then
    XxXMod = 1.08
ElseIf PB.FontSize = 6.75 Then
    XxXMod = 1.05

ElseIf PB.FontSize = 5.25 Then
    XxXMod = 1.05

ElseIf PB.FontSize = 2.25 Then
    XxXMod = 1.2

ElseIf PB.FontSize = 9 Then
    XxXMod = 1.05
End If

XXMod = PB.FontSize / 8.258 * XxXMod
TBL = TBLen(TNum, TType)
 
For x = 0 To TBL
        
    If x <= UBTB4 Then
        If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle >= 0 Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle >= 0 Then
            If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle <= TSH Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle <= TSH Then
                    LBrush.lbColor = TreeBlocks(TNum, TType, 4, x)
                    LPen.lopnColor = TreeBlocks(TNum, TType, 4, x)
                                
                    PEN = CreatePenIndirect(LPen)
                    Pen2 = SelectObject(Pict, PEN)
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                                
                    DeleteObject (Pen2)
                    DeleteObject (Brush2)
                    Dummy = Rectangle(Pict, TreeBlocks(TNum, TType, 0, x) / PRat, IStart + TreeBlocks(TNum, TType, 1, x) * TSingle + 1, TreeBlocks(TNum, TType, 0, x) / PRat + (TreeBlocks(TNum, TType, 2, x) - TreeBlocks(TNum, TType, 0, x)) * XXMod, IStart + TreeBlocks(TNum, TType, 3, x) * TSingle + 1)
                    'PB.Line (TreeBlocks(TNum, TType, 0, X) / PRat, IStart + TreeBlocks(TNum, TType, 1, X) * TSingle + 1)-(TreeBlocks(TNum, TType, 0, X) / PRat + (TreeBlocks(TNum, TType, 2, X) - TreeBlocks(TNum, TType, 0, X)) * XXMod, IStart + TreeBlocks(TNum, TType, 3, X) * TSingle + 1), TreeBlocks(TNum, TType, 4, X), BF
            End If
        End If
    End If
    
Next x



If OnlyNames = 0 Then
    
    If NoP3Flag = 0 Then
        
        Form2.Picture3(TNum).ScaleMode = 3
        Form2.Picture3(TNum).AutoRedraw = True
        Form2.Picture3(TNum) = LoadPicture()
        Form2.Picture3(TNum).DrawMode = 13
        'draw the maps
        
        Dim XSize As Single
        
        'For AA = 0 To 10
        
'        If X = X Then
            
            Call DrawmapsAA(Form2.Picture3(TNum), CLng(TType), CLng(TNum), IStart, TSingle, TSH)
'        Else
'            XSize = Form2.Picture3(TNum).ScaleWidth - 10
'            For X = 1 To MapBlockNum(TType, TNum)
'                'XX = Form2.Picture2(0).AutoRedraw
'
'
'                If X <= UBMB4 Then
'
'                    AH1 = MapBlocks(TType, TNum, 2, X)
'
'                    If IStart + (AH1 + 13) * TSingle >= 0 Then
'
'
'
'                        If IStart + AH1 * TSingle <= TSH Then
'
'
'
'                                Form2.Picture3(TNum).Line ((5 + MapBlocks(TType, TNum, 0, X) * XSize), IStart + (AH1 + 4) * TSingle)-(5 + MapBlocks(TType, TNum, 1, X) * XSize, IStart + (AH1 + 13) * TSingle), MapBlocks(TType, TNum, 3, X), BF
'                                'work out antialiasing line colours above and below
'
'                               X = X
'                        End If
'                    End If
'                End If
'
'            Next X
'
'
'            BPos = XOverlist(RelX, RelY).Beginning
'            EPos = XOverlist(RelX, RelY).Ending
'
'            If TNum = 1 Then
'                If BPos < EPos Then
'                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                Else
'                    Form2.Picture3(1).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                End If
'            ElseIf TNum = 2 Then
'                If BPos < EPos Then
'                    Form2.Picture3(2).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                    Form2.Picture3(2).Line (5 + (EPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                Else
'                    Form2.Picture3(2).Line (5 + (EPos / Len(StrainSeq(0))) * XSize - 1, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize + 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                End If
'            End If
'        End If
        
       ' Next AA
        
        
        'do the legend
        OFS = PB.FontSize
        'For D = 0 To 3
        D = TNum
        
        Form2.Picture3(D).Font = Form2.Picture2(D).Font
        Form2.Picture3(D).FontSize = 7
        Pict3 = Form2.Picture3(D).hdc
        'For X = 0 To 2
        
        
        'If TreeBlocksL(TNum, TType, 0, X) <> -1 Then
            
         'Form2.Picture3(D).FontSize = Form2.Picture2(D).FontSize
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 2)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 2), RGB(128, 128, 128), BF
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 17)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 17), RGB(220, 220, 220), BF
         Dim LText As String
         LText = "Considered nt sites"
'         XX = Form2.Picture3(D).Width / Screen.TwipsPerPixelX
'         XX = Form2.Picture3(D).TextWidth(LText)
         If CurTree(D) + Form2.Picture3(D).TextWidth(LText) > Form2.Picture3(D).Width / Screen.TwipsPerPixelX Then
            LText = "Considered nts"
         End If
         'if form2.picture3
         Dummy = TextOut(Pict3, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1), LText, Len(LText))
         If LText = "Considered nts" Then
            LText = "Ignored nts"
         Else
            LText = "Ignored nt sites"
         End If
         Dummy = TextOut(Pict3, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1) + 14, LText, Len(LText))
        
        Form2.Picture3(D).FontSize = OFS
    
    End If
End If

If NextNo = -1 Then TNum = oTNum: Exit Sub

PB.DrawMode = 13

O31FS = PB.FontSize


'Then write the names etc.

If DebuggingFlag < 2 Then On Error Resume Next

UBY = UBound(TreeTraceSeqs, 2)
UBX = UBound(TreeTraceSeqs, 1)

On Error GoTo 0


If TNum = 0 And FI = 1 Then
    For x = 0 To TDL0
        'AH2 = TreeDrawB(2, X, TNum, TType, 0) 'the sequence number
        AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle 'y cocord
        If AH1 >= -16 Then
            If AH1 <= TSH + 16 Then
                AH2 = TreeDrawB(2, x, TNum, TType, 0) 'the sequence number
                    If AH2 > -1 And (AH2 <= UBON) Then
                        
                        If SelGrpFlag = 0 Then
                            If MaskSeq(AH2) = 0 Then
                                PB.ForeColor = 0
                            ElseIf MaskSeq(AH2) = 1 Then
                                PB.ForeColor = QBColor(8)
                            Else
                                PB.ForeColor = ThreeQuaterColour
                            End If
                        Else
                            If GrpMaskSeq(AH2) = 0 Then
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = 0
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = QBColor(8)
                                Else
                                    PB.ForeColor = ThreeQuaterColour
                                End If
                            Else
                                
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = RGB(0, 0, 255)
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = RGB(120, 120, 255)
                                Else
                                    PB.ForeColor = RGB(170, 200, 255)
                                End If
                            End If
                        End If
                        
                        If AH2 <= UBON Then
                            'AH3 = TreeDrawB(2, X, TNum, TType, 0)
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), ONameLen(AH2)
                        End If
                        
                    ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                        PB.FontSize = 6 * TSingle
                        PB.ForeColor = RGB(0, 100, 0)
                        ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                    Else
                        PB.FontSize = 8.25 * TSingle
                        If PB.FontSize < 7 Then PB.FontSize = 7
                        PB.ForeColor = RGB(0, 0, 0)
                        ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                        ScaleX = Trim(Str(ScaleL))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                       
                    End If
                'End If
            End If
        End If
    Next x

Else
    If TNum <> 0 Then
        
        If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
            For x = 0 To TDL0
                
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TSH + 16 Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                            If AH2 > -1 Then
                                PB.ForeColor = MultColour(BigTreeTrace(AH2))
                                'If TreeDrawB(2, X, TNum, TType, 0) <= UBON Or (TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4)) Then
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, BigTreeName(AH2), Len(BigTreeName(AH2))
                                'End If
                            ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                                PB.FontSize = 6 * TSingle
                                PB.ForeColor = RGB(0, 100, 0)
                                'PB.Print TreeDraw(TNum, TType, 0, 3, X)
                                ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                                If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                                TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                                x = x
                            Else
                                PB.FontSize = 8.25 * TSingle
                                If PB.FontSize < 7 Then PB.FontSize = 7
                                PB.ForeColor = RGB(0, 0, 0)
                                ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                                ScaleX = Trim(Str(ScaleL))
                                If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                                'PB.Print ScaleX
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                               
                            End If
                        'End If
                    End If
                End If
            Next x
        ElseIf (TNum = 3 And TType = 0) Or (TNum = 3 And TType = 1) Then
            
            For x = 0 To TDL0
                
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TSH + 16 Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                        If AH2 > -1 And AH2 <= UBON Then
                                 
                            If UBTT > 0 Then
                                If AH2 <= UBMC Then
                                    If AH2 <= UBTT Then
                                        PB.ForeColor = MultColour(TreeTrace((AH2)))
                                    End If
                                End If
                            End If
                            
                            If AH2 <= UBON Then
                                'AH1 = TreeDrawB(2, X, TNum, TType, 0)
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), ONameLen(AH2)
                                
                            End If
                            
                        ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                            PB.FontSize = 6 * TSingle
                            PB.ForeColor = RGB(0, 100, 0)
                            ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                            x = x
                        Else
                            PB.FontSize = 8.25 * TSingle
                            If PB.FontSize < 7 Then PB.FontSize = 7
                            PB.ForeColor = RGB(0, 0, 0)
                            ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                            ScaleX = Trim(Str(ScaleL))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                           
                        End If
                        
                    End If
                End If
            Next x
            
        Else
            TargY = TSH + 16
            'zzz = 0
            For x = 0 To TDL0
                '
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TargY Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                        If AH2 > -1 And (AH2 <= UBON) Then
                            AH4 = TreeTraceSeqs(1, AH2)
                            If AH2 <= UBTTS2 And UBTT >= AH4 Then
                                If AH4 <= UBTT Then
                                    AH3 = TreeTrace(AH4)
                                    If AH3 <= UBMC Then
                                        PB.ForeColor = MultColour(AH3)
                                    End If
                                
                            
                                    
                                    If AH3 <= UBON Then
                                        'zzz = zzz + 1
                                        ''''''''
                                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH3), ONameLen(AH3)
                                       ' X = X
                                    End If
                                End If
                            End If
                            
                            
                        ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                            PB.FontSize = 6 * TSingle
                            PB.ForeColor = RGB(0, 100, 0)
                            'PB.Print TreeDraw(TNum, TType, 0, 3, X)
                            ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                        Else
                            PB.FontSize = 8.25 * TSingle
                            If PB.FontSize < 7 Then PB.FontSize = 7
                            PB.ForeColor = RGB(0, 0, 0)
                            ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                            ScaleX = Trim(Str(ScaleL))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            'PB.Print ScaleX
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                           
                        End If
                        'End If
                    End If
                End If
            Next x
            x = x
        End If
    Else
        
        If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
            GoOn = 1
        Else
            GoOn = 0
        End If
        For x = 0 To TDL0
            '''
            AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
            If AH1 >= -16 Then
                If AH1 <= TSH + 16 Then
                    AH2 = TreeDrawB(2, x, TNum, TType, 0)
                    If AH2 > -1 And (AH2 <= UBON Or GoOn = 1) Then
                        If UBTT > 0 Then
                            If AH2 <= UBMC Then
                                '
                                If AH2 <= UBTT Then
                                    PB.ForeColor = MultColour(TreeTrace((AH2)))
                                End If
                            End If
                        End If
                        '
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), ONameLen(AH2)
                        
                    ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                        PB.FontSize = 6 * TSingle
                        PB.ForeColor = RGB(0, 100, 0)
                        ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                    Else
                        PB.FontSize = 8.25 * TSingle
                        If PB.FontSize < 7 Then PB.FontSize = 7
                        PB.ForeColor = RGB(0, 0, 0)
                        ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                        ScaleX = Trim(Str(ScaleL))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                       
                    End If
                End If
            End If
        Next x
    End If
End If
'On Error GoTo 0


'Clear up and close  emf
PEN = SelectObject(MhDC, oldpen)
DeleteObject (PEN)
Brush = SelectObject(MhDC, OldBrush)
DeleteObject (Brush)
LoFnt = SelectObject(MhDC, OldFont)
DeleteObject (LoFnt)
'EMFCls = CloseEnhMetaFile(MhDC)
'Dummy = DeleteEnhMetaFile(EMFCls)

BitBlt PB.hdc, 0, 0, PB.ScaleWidth, PB.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy



PB.FontSize = O31FS

TNum = oTNum
'''
PB.Refresh
If FI = 0 Then
    Form1.Picture3.Refresh
End If
If OnlyNames = 0 Then
    Form2.Picture3(TNum).Refresh
End If


End Sub
Public Function GetMatchCol(TestCol As Long, GPrintCol() As Long, NumCols)
Dim TestR As Byte, TestG As Byte, TestB As Byte, Z As Long, RefR As Byte, RefG As Byte, RefB As Byte, MinDist As Long, WinDist As Long, DistCol As Long
Call ConvertLongToRGB(TestCol, TestR, TestG, TestB)

Call ConvertLongToRGB(BackColours, RefR, RefG, RefB)
MinDist = Abs(CLng(TestR) - CLng(RefR)) + Abs(CLng(TestG) - CLng(RefG)) + Abs(CLng(TestB) - CLng(RefB)) 'Background check
WinDist = -1
If Abs(CLng(TestR) - CLng(197)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(197)) < MinDist Then '99%CI
    MinDist = Abs(CLng(TestR) - CLng(197)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(197))
    WinDist = -2
End If
If Abs(CLng(TestR) - CLng(160)) + Abs(CLng(TestG) - CLng(160)) + Abs(CLng(TestB) - CLng(160)) < MinDist Then  '95%CI
     WinDist = -3
     MinDist = Abs(CLng(TestR) - CLng(160)) + Abs(CLng(TestG) - CLng(160)) + Abs(CLng(TestB) - CLng(160))
End If
If Abs(CLng(TestR) - CLng(197)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(255)) < MinDist Then  'missing data
     WinDist = -4
     MinDist = Abs(CLng(TestR) - CLng(197)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(255))
End If
If Abs(CLng(TestR) - CLng(255)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(197)) < MinDist Then  'Breakpoint highlight
     WinDist = -5
     MinDist = Abs(CLng(TestR) - CLng(255)) + Abs(CLng(TestG) - CLng(197)) + Abs(CLng(TestB) - CLng(197))
End If
If Abs(CLng(TestR) - CLng(0)) + Abs(CLng(TestG) - CLng(0)) + Abs(CLng(TestB) - CLng(0)) < MinDist Then  'p-vlue label
     WinDist = -6
     MinDist = Abs(CLng(TestR) - CLng(0)) + Abs(CLng(TestG) - CLng(0)) + Abs(CLng(TestB) - CLng(0))
End If
If Abs(CLng(TestR) - CLng(255)) + Abs(CLng(TestG) - CLng(255)) + Abs(CLng(TestB) - CLng(255)) < MinDist Then  'p-vlue label emboss
     WinDist = -7
     MinDist = Abs(CLng(TestR) - CLng(255)) + Abs(CLng(TestG) - CLng(255)) + Abs(CLng(TestB) - CLng(255))
     
End If





For Z = 0 To NumCols
    Call ConvertLongToRGB(GPrintCol(Z), RefR, RefG, RefB)
    DistCol = Abs(CLng(TestR) - CLng(RefR)) + Abs(CLng(TestG) - CLng(RefG)) + Abs(CLng(TestB) - CLng(RefB))
    If DistCol <= MinDist Then
        WinDist = Z
        MinDist = DistCol
    End If
Next Z




If MinDist > 50 Then WinDist = -1

GetMatchCol = WinDist
End Function
'option explicit
Public Sub PartiOnB(Seq1 As Long, Seq2 As Long, Seq3 As Long)

Dim x As Long, Y As Long, Splits() As Long
ReDim Splits(Len(StrainSeq(0)))
'split = 1 (seq1 =  seq2 <> seq3)
'split = 2 (seq2 <> seq1 =  seq3)
'split = 3 (seq1 <> seq2 =  seq3)
'find splits - exclude all sequences that fall on the same branches as seq1, seq2, and seq3 - essentially using remainder of the
'tree as the fourth sequence
Dim ValidSitePos() As Long, NumValidSite As Long, ValidSite() As Long

'find valid sites
ReDim ValidSite(Len(StrainSeq(0))), ValidSitePos(Len(StrainSeq(0)))
NumValidSite = 0
For Y = 1 To Len(StrainSeq(0))
    If SeqNum(Y, Seq1) <> 46 Then
        If SeqNum(Y, Seq2) <> 46 Then
            If SeqNum(Y, Seq3) <> 46 Then
                If SeqNum(Y, Seq1) <> SeqNum(Y, Seq2) Then
                    If SeqNum(Y, Seq2) = SeqNum(Y, Seq3) Then
                        
                        NumValidSite = NumValidSite + 1
                        ValidSitePos(NumValidSite) = Y
                        ValidSite(NumValidSite) = 3
                    ElseIf SeqNum(Y, Seq1) = SeqNum(Y, Seq3) Then
                        NumValidSite = NumValidSite + 1
                        ValidSitePos(NumValidSite) = Y
                        ValidSite(NumValidSite) = 2
                    End If
                ElseIf SeqNum(Y, Seq1) <> SeqNum(Y, Seq3) Then
                    NumValidSite = NumValidSite + 1
                    ValidSitePos(NumValidSite) = Y
                    ValidSite(NumValidSite) = 1
                End If
            End If
        End If
    End If
Next Y

'find valid references
Dim ValidRef() As Long, ValidRefNum As Long, ValidRefPos() As Long, Outlyer As Long, Inlyer1 As Long, Inlyer2 As Long, InDist As Single, OutDist As Single
ReDim ValidRef(NextNo), ValidRefPos(NextNo)
ValidRefNum = 0

'work out inlyers an outlers amongst seq1,seq2 and seq3
If TreeDistance(Seq1, Seq3) = TreeDistance(Seq2, Seq3) Then
    Outlyer = Seq3
    Inlyer1 = Seq1
    Inlyer2 = Seq2
ElseIf TreeDistance(Seq1, Seq2) = TreeDistance(Seq2, Seq3) Then
    Outlyer = Seq2
    Inlyer1 = Seq1
    Inlyer2 = Seq3
ElseIf TreeDistance(Seq1, Seq3) = TreeDistance(Seq1, Seq2) Then
    Outlyer = Seq1
    Inlyer1 = Seq2
    Inlyer2 = Seq3
End If
InDist = TreeDistance(Inlyer1, Inlyer2)
OutDist = TreeDistance(Outlyer, Inlyer1)
For x = 0 To NextNo
    If x <> Seq1 Then
        If x <> Seq2 Then
            If x <> Seq3 Then
                If TreeDistance(x, Inlyer1) > InDist Then
                    If TreeDistance(x, Outlyer) = OutDist Then
                        ValidRefNum = ValidRefNum + 1
                        ValidRefPos(ValidRefNum) = x
                        ValidRef(ValidRefNum) = 1
                    End If
                    If TreeDistance(x, Outlyer) > OutDist Then
                        ValidRefNum = ValidRefNum + 1
                        ValidRefPos(ValidRefNum) = x
                        ValidRef(ValidRefNum) = 2
                    End If
                End If
            End If
        End If
    End If
Next x
Dim A As Long, b As Long

Dim ValidPair() As Long, ValidPairPos() As Long, NumValidPair As Long
ReDim ValidPair(NumValidSite), ValidPairPos(NumValidSite)

NumValidPair = 0
For b = 1 To NumValidSite
    Y = ValidSitePos(b)
    If ValidSite(b) = 1 Then
        For A = 1 To ValidRefNum
            x = ValidRefPos(A)
            If SeqNum(Y, x) = SeqNum(Y, Seq3) Then
                NumValidPair = NumValidPair + 1
                ValidPairPos(NumValidPair) = x
                ValidPair(NumValidPair) = 1
                Exit For
            End If
        Next A
    ElseIf ValidSite(b) = 2 Then
        For A = 1 To ValidRefNum
            x = ValidRefPos(A)
            If SeqNum(Y, x) = SeqNum(Y, Seq2) Then
                NumValidPair = NumValidPair + 1
                ValidPairPos(NumValidPair) = x
                ValidPair(NumValidPair) = 2
                Exit For
            End If
        Next A
    ElseIf ValidSite(b) = 3 Then
        For A = 1 To ValidRefNum
            x = ValidRefPos(A)
            If SeqNum(Y, x) = SeqNum(Y, Seq1) Then
                NumValidPair = NumValidPair + 1
                ValidPairPos(NumValidPair) = x
                ValidPair(NumValidPair) = 3
                Exit For
            End If
        Next A
    End If
Next b
Dim WindowSize As Long, MinDiffs As Long, total(3) As Long, CurSite As Long, WindowType() As Long
HWindowSize = 10
MinDiffs = 5

'DO First window
For x = 1 - HWindowSize To 1 + HWindowSize
    If x < 1 Then
        A = NumValidPair + x
    Else
        A = x
    End If
    CurSite = ValidPair(A)
    total(CurSite) = total(CurSite) + 1
    
Next x
ReDim WindowType(NumValidPair)

If total(1) > total(2) And total(1) > total(3) Then
    WindowType(1) = 1
ElseIf total(2) > total(1) And total(2) > total(3) Then
    WindowType(1) = 2
ElseIf total(3) > total(1) And total(3) > total(2) Then
    WindowType(1) = 3
End If


For x = 2 To NumValidPair
    b = x - HWindowSize
    If b < 1 Then
        A = NumValidPair + b
    Else
        A = b
    End If
    total(ValidPair(A)) = total(ValidPair(A)) - 1
    b = x + HWindowSize
    If b > NumValidPair Then
        A = b - NumValidPair
    Else
        A = b
    End If
    total(ValidPair(A)) = total(ValidPair(A)) - 1
    If total(1) > total(2) And total(1) > total(3) Then
        WindowType(x) = 1
    ElseIf total(2) > total(1) And total(2) > total(3) Then
        WindowType(x) = 2
    ElseIf total(3) > total(1) And total(3) > total(2) Then
        WindowType(x) = 3
    End If
Next x


'For X = 1 To NumValidPair
'
'
'Next X



End Sub
Public Function GetNumInList(Seq1 As Long, Seq2 As Long, Seq3 As Long) As Long
'@'@'@'@'@'@
If x = 123456 Then
    GetNumInList = GetNumInListC(Seq1, Seq2, Seq3, S1S2(0), S2S3(0))
Else
    If Seq1 < Seq2 And Seq1 < Seq3 Then
        If Seq2 < Seq3 Then
            GetNumInList = S1S2(Seq1) + S2S3(Seq2 - Seq1) - (Seq2 - Seq1 - 1) * Seq1 + Seq3 - Seq2
        Else
            GetNumInList = S1S2(Seq1) + S2S3(Seq3 - Seq1) - (Seq3 - Seq1 - 1) * Seq1 + Seq2 - Seq3
        End If
    ElseIf Seq2 < Seq1 And Seq2 < Seq3 Then
        If Seq1 < Seq3 Then
            GetNumInList = S1S2(Seq2) + S2S3(Seq1 - Seq2) - (Seq1 - Seq2 - 1) * Seq2 + Seq3 - Seq1
        Else
            GetNumInList = S1S2(Seq2) + S2S3(Seq3 - Seq2) - (Seq3 - Seq2 - 1) * Seq2 + Seq1 - Seq3
        End If
    ElseIf Seq3 < Seq2 And Seq3 < Seq1 Then
        If Seq1 < Seq2 Then
            GetNumInList = S1S2(Seq3) + S2S3(Seq1 - Seq3) - (Seq1 - Seq3 - 1) * Seq3 + Seq2 - Seq1
        Else
            GetNumInList = S1S2(Seq3) + S2S3(Seq2 - Seq3) - (Seq2 - Seq3 - 1) * Seq3 + Seq1 - Seq2
        End If
    End If
End If
End Function
Public Sub MakeS1S2S3()
Dim A As Long, b As Long, C As Long, D As Long, e As Long, F As Long, g As Long, H As Long, x As Long
ReDim S1S2(NextNo)
ReDim S2S3(NextNo)

If MaxAnalNo > MCCorrection Then
        

    For x = 1 To NextNo - 2
        S1S2(x) = ((NextNo - x + 1) * (NextNo - x)) / 2
    '    If S1S2(X) <> CLng(S1S2(X)) Then
    '        X = X
    '    End If
    Next x
    For x = 2 To NextNo - 2
        S1S2(x) = S1S2(x) + S1S2(x - 1)
        
    Next x
    
    For x = 2 To NextNo - 1
        S2S3(x) = NextNo - x + 1
    '    If S2S3(X) <> CLng(S2S3(X)) Then
    '        X = X
    '    End If
        
    Next x
    For x = 3 To NextNo - 1
       S2S3(x) = S2S3(x) + S2S3(x - 1)
    '   If S2S3(X) <> CLng(S2S3(X)) Then
    '        X = X
    '    End If
    Next x
End If
ProgBinWrite(0) = 1 'rdp
ProgBinWrite(1) = 2 'geneconv
ProgBinWrite(2) = 4 'bootscan
ProgBinWrite(3) = 8 'maxchi
ProgBinWrite(4) = 16 'chimaera
ProgBinWrite(5) = 32 'siscan
ProgBinWrite(6) = 64 '3seq
ProgBinWrite(7) = 128 'open
Dim CountX As Long, ProgBin(255) As Byte
CountX = -1
For A = 0 To 1
    For b = 0 To 1
        For C = 0 To 1
            For D = 0 To 1
                For e = 0 To 1
                    For F = 0 To 1
                        For g = 0 To 1
                            For H = 0 To 1
                                CountX = CountX + 1
                                ProgBin(CountX) = ProgBinWrite(0) * A
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(1) * b
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(2) * C
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(3) * D
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(4) * e
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(5) * F
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(6) * g
                                ProgBin(CountX) = ProgBin(CountX) + ProgBinWrite(7) * H
                                ProgBinRead(0, ProgBin(CountX)) = A
                                ProgBinRead(1, ProgBin(CountX)) = b
                                ProgBinRead(2, ProgBin(CountX)) = C
                                ProgBinRead(3, ProgBin(CountX)) = D
                                ProgBinRead(4, ProgBin(CountX)) = e
                                ProgBinRead(5, ProgBin(CountX)) = F
                                ProgBinRead(6, ProgBin(CountX)) = g
                                ProgBinRead(7, ProgBin(CountX)) = H
                                
                                
                            Next H
                        Next g
                    Next F
                Next e
            Next D
        Next C
    Next b
Next A
'If DebuggingFlag < 2 Then On Error Resume Next
'UB = -1
'UB = UBound(Worthwhilescan)
'

End Sub
Public Sub MakeLookupYZ()
    ReDim LookupYZ(NextNo)
    For x = 1 To NextNo - 2
        LookupYZ(x) = ((NextNo - x) + (NextNo - x - 1)) / 2
        
    Next x
    For x = 2 To NextNo - 2
        LookupYZ(x) = LookupYZ(x) + LookupYZ(x - 1)
    Next x
    
End Sub
Public Sub TreeZoom(IndexX As Integer)
    Dim OM As Long, TS(3) As Double, OV As Long, tTYF As Double, OFS As Double, otTYF As Double, TYFM As Integer, OFS2 As Single

      
      Form1.Picture16.FontSize = 8.25 * TYF2
      OFS = Form1.Picture16.FontSize
      TS(0) = Form1.Picture16.TextWidth("A")
      TS(2) = Form1.Picture16.TextHeight("A")
      If IndexX = 1 Then
        Form1.Command33(2).Enabled = True
        Form2.Command5.Enabled = True
        Do
              TYF2 = TYF2 + 0.075
              
              If TYF2 > 1.7 Then TYF2 = 1.7
              
              Form1.Picture16.FontSize = 8.25 * TYF2
        
RedoScaleCheck1:
             
              TS(1) = Form1.Picture16.TextWidth("A")
              TS(3) = Form1.Picture16.TextHeight("A")
              If Abs(TS(0) - TS(1)) > 0.1 And Abs(TS(2) - TS(3)) > 0.1 Then Exit Do ' = 18 Or Picture1.FontSize = 16.5 Or Picture1.FontSize = 14.25 Or Picture1.FontSize = 10.5 Or Picture1.FontSize = 2.25 Or Picture1.FontSize = 6 Or Picture1.FontSize = 8.25 Or Picture1.FontSize = 4.5 Then
              If TYF2 > 1.69 Then
                  Form1.Command33(3).Enabled = False: Form2.Command4.Enabled = False
                  Exit Sub
              End If
              '    TYF = TYF - 0.075
              '    Picture1.FontSize = 9.75 * TYF
              '    Picture3.FontSize = 7 * TYF
              '    If Picture1.FontSize = 18 Or Picture1.FontSize = 16.5 Or Picture1.FontSize = 14.25 Or Picture1.FontSize = 10.5 Or Picture1.FontSize = 2.25 Or Picture1.FontSize = 6 Or Picture1.FontSize = 8.25 Or Picture1.FontSize = 4.5 Then
              '        TYF = TYF - 0.075
              '        Picture1.FontSize = 9.75 * TYF
              '        Picture3.FontSize = 7 * TYF
              '    End If
              'End If
          Loop
      Else
        Form1.Command33(3).Enabled = True
        Form2.Command4.Enabled = True
        Form1.Picture16.FontSize = 8.25 * TYF2
        OFS = Form1.Picture16.FontSize
        TS(0) = Form1.Picture16.TextWidth("A")
        TS(2) = Form1.Picture16.TextHeight("A")
        Do
            TYF2 = TYF2 - 0.075
            '0.4
            If TYF2 < 0.175 Then TYF2 = 0.175
            
            Form1.Picture16.FontSize = 8.25 * TYF2
            '              3
RedoScaleCheck0:
            TS(1) = Form1.Picture16.TextWidth("A")
            TS(3) = Form1.Picture16.TextHeight("A")
            If Abs(TS(0) - TS(1)) > 0.1 And Abs(TS(2) - TS(3)) > 0.1 Then
            '       5       3                    7       6
                Exit Do
            End If
            If TYF2 < 0.19 Then
                If TYF2 < 0.19 Then Form1.Command33(2).Enabled = False: Form2.Command5.Enabled = False
                Exit Sub
            End If
        Loop
      End If
      
      
      
       
      
      
      'Picture16.Height = (Nextno + 6) * 15 * TYF2
      Call ModOffsets(8.25, Form1.Picture16, otTYF, TYFM)
      XX = otTYF '0.2909
      XX = TYFM '0
      If TYF2 > 1.7 Then
        Form1.Command33(3).Enabled = False
        Form2.Command4.Enabled = False
      ElseIf TYF2 < 0.19 Then
        Form1.Command33(2).Enabled = False
        Form2.Command5.Enabled = False
      End If
      tTYF = Form1.Picture16.FontSize / OFS '0.714
    
      Dim VSMax As Long
     
      Dim OVx As Double
     'Exit Sub
     DontResetFocus = 1
     With Form1.VScroll1
          If .Max <= 0 Then .Value = 0
          OV = .Value
          OM = .Max
          If OM > 0 Then
            OVx = OV / OM
          Else
            OVx = 0
          End If
          If TDLen(TreeTypeFlag, CTF, 1) > 0 Then
              VSMax = -Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
          Else
              VSMax = -Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
          End If
          
          
          If OM = 0 Then OM = 1
          If VSMax > 32000 Then
              F2VSScaleFactor(TreeTypeFlag) = VSMax / 32000
              VSMax = 32000
          Else
              F2VSScaleFactor(TreeTypeFlag) = 1
          End If
          If VSMax < 0 Then VSMax = 0
          OFS2 = Form1.Picture16.FontSize
          VSC1NC = 0
          .Max = VSMax '-Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
          VSC1NC = 0
          If .Max > 0 And OM > 0 Then
              If OVx * VSMax <= .Max Then
                  VSC1NC = 0
                  
                 .Value = OVx * VSMax
                  
                  VSC1NC = 0
              ElseIf .Max > 0 Then
                  VSC1NC = 0
                  .Value = .Max
                  VSC1NC = 0
              End If
          End If
          If OFS2 <> Form1.Picture16.FontSize Then
              If IndexX = 1 Then
                GoTo RedoScaleCheck1
              Else
                GoTo RedoScaleCheck0
              End If
          End If
          If .Max <= 0 Then
              .Enabled = False
          Else
              .LargeChange = Form1.Picture9.ScaleHeight
              .Enabled = True
          End If
      End With
      
      
      'Exit Sub
      
     ' VScroll1.Enabled = True
      UnModNextno
      If OV = Form1.VScroll1.Value Then
          If TreeTypeFlag > 0 Then Call ModNextno
          Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
          UnModNextno
      End If
      Dim Tempttyf As Double, Temptyfm As Integer
      
      XX = otTYF
      XX = TYFM
      Call ModOffsets(8.25, Form1.Picture16, otTYF, Temptyfm)
      If Form2.Visible = True Then
         
          For Index = 0 To 3
              Form2.Picture2(Index).FontSize = Form1.Picture16.FontSize
              With Form2.VScroll1(Index)
                  VSMax = .Max
                  If VSMax <= 0 Then .Value = 0
                  
                  OVx = (.Value / .Max)
                  If OVx < 0 Then OVx = 0
                  VSC1NC = 0
                  OV = .Value
                  OM = VSMax
                  If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
                      VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
                  Else
                      VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
                  End If
                  If OM = 0 Then OM = 1
                  If VSMax > 32000 Then
                      F2VSScaleFactor(Index) = VSMax / 32000
                      VSMax = 32000
                  Else
                      F2VSScaleFactor(Index) = 1
                  End If
                  
                  
                  If VSMax > 0 Then
                        VSC1NC = 1
                      .Max = VSMax
                      VSC1NC = 0
                      If F2P2Seq > -1 Then
                            Dim P2S As Long
                            If Index = 0 Or (Index = 3 And (CurTree(Index) = 0 Or CurTree(Index) = 1)) Then
                                P2S = F2P2Seq
                            Else
                                If F2P2Seq <= UBound(TreeTraceSeqs, 2) Then
                                    P2S = TreeTraceSeqs(0, F2P2Seq)
                                End If
                            End If
                            
                            MiddlePos(CurTree(Index), Index) = YCord(CurTree(Index), Index, P2S)
                            If F2P2Index = Index Then
                                'try to make sure that f2p2snum stays under the mouse pointer
                                Offset = F2P2Y - 7 * otTYF
                            Else
                                Offset = (Form2.Picture2(1).ScaleHeight / 2) - 7 * otTYF
                                'try to centre the trees on f2p2snum
                            End If
                            If (MiddlePos(CurTree(Index), Index) * otTYF - Offset) / F2VSScaleFactor(Index) > .Max Then
                                .Value = .Max
                            ElseIf (MiddlePos(CurTree(Index), Index) * otTYF - Offset) / F2VSScaleFactor(Index) < 0 Then
                                .Value = 0
                            Else
                                .Value = (MiddlePos(CurTree(Index), Index) * otTYF - Offset) / F2VSScaleFactor(Index)
                            End If
                      Else
                            If OVx * VSMax < VSMax Then
                                VSC1NC = 0
                                .Value = (OVx * (VSMax)) '0.168, 12967 ' - 200)) '(.Value / (OM / VSMax))
                                VSC1NC = 0
                            ElseIf VSMax > 0 Then
                                VSC1NC = 0
                                .Value = VSMax
                                VSC1NC = 0
                            End If
                      End If
                      VSC1NC = 0
                      If .Value > VSMax Then .Value = VSMax
                      VSC1NC = 0
                      If VSMax <= 0 Then
                          .Enabled = False
                      Else
                          .LargeChange = Form2.Picture2(Index).ScaleHeight
                          .Enabled = True
                      End If
                  End If
                  
              End With
              If Index = 1 Then Call ModNextno
              If OV = Form2.VScroll1(Index).Value Or x = x Then
                  Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                 
              End If
          Next Index
          UnModNextno
          x = x
      End If
      XX = otTYF '0.2909
      XX = TYFM '0
      XX = tTYF '0.714
      Form1.Enabled = True
      If Form2.Visible = True And Form2.Enabled = True Then
        Form2.SetFocus
    End If
    DontResetFocus = 0

End Sub
Public Sub ShrinkZoom()
Dim TargetWin As Long, GrowInc As Single, SS As Long, EE As Long, CycleNo As Long, TimePerCycle As Single, GoOn As Byte
'Exit Sub
GrowInc = 20
If p7CurWinSize <= 0 Then Exit Sub
TargetWin = 0
If DebuggingFlag < 2 Then On Error Resume Next
TargetWin = Recompress(GYAxHi(1) / 8)

On Error GoTo 0
If TargetWin < 1 Then Exit Sub
SS = Abs(GetTickCount)
CycleNo = 0
TimePerCycle = 0
GoOn = 0
Do
    CycleNo = CycleNo + 1
    p7CurWinSize = p7CurWinSize - TargetWin / (GrowInc / 2)
    If p7CurWinSize <= 0 Then
        p7CurWinSize = 0
        P7XP = 0
        Call RedrawPlotAA(1)
        Exit Do
    End If
    
    Call RedrawPlotAA(1)
    EE = Abs(GetTickCount)
    TT = Abs(EE - SS)
    TimePerCycle = TT / CycleNo
    If TimePerCycle > 100 And GoOn = 0 Then
        GrowInc = GrowInc * 100 / TimePerCycle
        GoOn = 1
    End If
    Form1.Picture7.Refresh
Loop
End Sub
Public Sub GrowZoom()
Dim TargetWin As Long, GrowInc As Single, SS As Long, EE As Long, CycleNo As Long, TimePerCycle As Single, GoOn As Byte
WinBusyGrowing = 1
GrowInc = 20
'Exit Sub
TargetWin = 0
If DebuggingFlag < 2 Then On Error Resume Next
TargetWin = Recompress(GYAxHi(1) / 8)
On Error GoTo 0

If TargetWin < 1 Then Exit Sub

'If p7CurWinSize > TargetWin Then p7CurWinSize = TargetWin: Exit Sub

SS = Abs(GetTickCount)
CycleNo = 0
TimePerCycle = 0
GoOn = 0
Do
    CycleNo = CycleNo + 1
    p7CurWinSize = p7CurWinSize + TargetWin / (GrowInc / 2)
    If p7CurWinSize >= TargetWin Then
        p7CurWinSize = TargetWin
        Call RedrawPlotAA(1)
        Exit Do
    End If
    
    Call RedrawPlotAA(1)
    
    
    EE = Abs(GetTickCount)
    TT = Abs(EE - SS)
    TimePerCycle = TT / CycleNo
    
    If p7CurWinSize < TargetWin Then
        DoEvents
    
        If TimePerCycle > 100 And GoOn = 0 Then
            GrowInc = GrowInc * 100 / TimePerCycle
            GoOn = 1
        End If
        Form1.Picture7.Refresh
    End If
    Form1.Picture7.Refresh
Loop
WinBusyGrowing = 0
End Sub
            
Public Sub NameShuffle()
Dim FN As String, OutN As String, FF As Integer, NumPerms As Long, NumFG As Long, DoneSeq() As Long, BannedSeq(), RSeed As Long, Nextseq As Long, SeqCount As Long
NumFG = 90
NumPerms = 100
RSeed = 54
Rnd (-BSRndNumSeed)
ReDim BannedSeq(NextNo)

BannedSeq(167) = 1 'force this seq to always be HIV-

For x = 1 To NumPerms
    ReDim DoneSeq(NextNo)
    If NumFG = 90 Then 'if HIV+ is in the FG
        SeqCount = 0
    ElseIf NumFG = 100 Then
        DoneSeq(167) = 1 'if HIV- is in the FG
        SeqCount = 1
    End If
    Do
        Nextseq = Int(Rnd * (NextNo + 2))
        If Nextseq <= NextNo Then
            If DoneSeq(Nextseq) = 0 And BannedSeq(Nextseq) = 0 Then
                DoneSeq(Nextseq) = 1
                SeqCount = SeqCount + 1
                If SeqCount = NumFG Then Exit Do
            End If
        End If
    Loop
    FF = FreeFile
    If NumFG = 90 Then
        OutN = PFName + "HIV_in_FG_" + Trim(Str(x)) + ".fas"
    ElseIf NumFG = 100 Then
        OutN = PFName + "HIV_in_BG_" + Trim(Str(x)) + ".fas"
    End If
    Open OutN For Output As #FF
    For Y = 0 To NextNo
        If DoneSeq(Y) = 0 Then
            FN = OriginalName(Y)
        Else
            FN = OriginalName(Y) + "{FG}"
        End If
        Print #FF, ">" + FN
        Print #FF, StrainSeq(Y)
    Next Y
    Close #FF
    Form1.SSPanel1.Caption = "Written " + Trim(Str(x)) + " of " + Trim(Str(NumPerms)) + " alignments"
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Next
x = x

End Sub
Public Sub UpdateSelectRefs()
OManFlag = ManFlag
    QvRSelectFlag = 1
    DontDoComboFlag = 1
    
    Form5.Command5.Caption = "Auto-assign"
    If QvRAutoAssignableFlag = 0 Then
        Form5.Command5.Enabled = False
    Else
        Form5.Command5.Enabled = True
    End If
    
    
    Dim RG As Long
    If RefNum = 0 Then
    
        RG = 49
        
    Else
        RG = RefNum
    End If
    ReDim Preserve RefGroupName(RG + 10)
    With Form5.Combo1
        OIndex = .ListIndex
        .Clear
        .AddItem "None", 0
        
        For x = 0 To RG
            If RefGroupName(x + 1) = "" Then
                .AddItem "Reference group " + Trim(Str(x + 1)), x + 1
            Else
                .AddItem RefGroupName(x + 1) + " (Reference group " + Trim(Str(x + 1)) + ")", x + 1
            End If
        Next 'X
        
        .ListIndex = OIndex
    End With
    
    DontDoComboFlag = 0
    If Form5.Combo1.ListIndex < 1 Then
        Form5.Combo1.ListIndex = 1
    End If
    
    Form5.Caption = "Select Reference Sequences"
    Form5.Label4.Caption = "Choose a reference group and then select one or more sequences to go in that group"
    Form5.Label3.Caption = "Sequences in reference group " + Trim(Str(Form5.Combo1.ListIndex))
    Form5.Label2.Caption = "Sequences not in reference group " + Trim(Str(Form5.Combo1.ListIndex))
    Form5.Label1 = "Current Reference Group"
    Form5.Label1.Visible = True

    

    Form5.Combo1.Visible = True
    Form5.Check1.Visible = False
    TManFlag = 1
    'ot1e = Form1.Timer1.Enabled
    'Form1.Timer1.Enabled = False
    ManPFlag = 1
    ManMinSeqNo = 2
    ManMaxSeqNo = NextNo + 1

    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X

    

    
    
    
    
    If Form5.Combo1.ListIndex > 0 Then
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
    Else
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex + 1
        Form5.Combo1.ListIndex = Form5.Combo1.ListIndex - 1
    End If
    NoF3Check2 = 1
    If Form5.Visible = False Then
        Form5.Visible = True
    End If
    Form1.Enabled = False
End Sub
Public Sub MakeRefGroupNames()
    Dim GoOnA As Byte, GoOnZ As Byte, A As Long, b As Long, C As Long, x As Long, Z As Long, DoneRefNum() As Byte, Y As Long, CurString As String, WinSize As Long, WinString As String, TestString As String
    'Try to find a substring in the sequence name that differentiates the refence groups
    ReDim DoneRefNum(RefNum), RefGroupName(PermNextno)
    For x = 0 To PermNextno
        Y = ReferenceList(x)
        If Y > 0 Then
            If DoneRefNum(Y) = 0 Then
                   DoneRefNum(Y) = 1
                   RefGroupName(Y) = OriginalName(x) 'start with this name
                   'CurString = OriginalName(X)
                   WinSize = Len(RefGroupName(Y))
                   GoOnZ = 1
                   For Z = x + 1 To PermNextno
                        If ReferenceList(Z) = Y Then
                            If WinSize > Len(OriginalName(Z)) Then
                                WinSize = Len(OriginalName(Z))
                            End If
                            GoOnA = 1
                            For A = WinSize To 1 Step -1
                                C = Len(RefGroupName(Y))
                                For b = 1 To (C - WinSize) + 1
                                    Do While WinSize > 0
                                        TestString = Mid(RefGroupName(Y), b, WinSize)
                                        Pos = InStr(1, OriginalName(Z), TestString, vbTextCompare)
                                        If Pos > 0 Then
                                            RefGroupName(Y) = TestString
                                            GoOnA = 0
                                            
                                            Exit For
                                            
                                        End If
                                        WinSize = WinSize - 1
                                    Loop
                                    If WinSize = 0 Then
                                        RefGroupName(Y) = "Reference group " + Trim(Str(Y)) + "(" + OriginalName(x) + ")"
                                        GoOnA = 0
                                        GoOnZ = 0
                                        Exit For
                                    End If
                                Next b
                                If GoOnA = 0 Then Exit For
                            Next A
                        End If
                        If GoOnZ = 0 Then Exit For
                   Next Z
            End If
        End If
    
    Next x
    
    


End Sub
Public Sub CheckQueryReference()
    Dim Z As Long, GoOn As Long, Response As Long, NumExtras As Long, MaxDist As Single, MinDist As Single, WinX As Long, WinY As Long, NumRefSets As Long, MaxMatch As Long, MinMatch As Long, NumRefs As Long, ReferenceS() As Long, x As Long, Y As Long, PosA As Long, PosB As Long, A As Long, b As Long, IDMatch() As String
    ReDim ReferenceList(NextNo)
    ReDim ReferenceS(NextNo)
    
    
    NumRefs = 0
    For x = 0 To NextNo
        If InStr(1, OriginalName(x), "ref", vbTextCompare) > 0 Then
            ReferenceList(x) = 1
            NumRefs = NumRefs + 1
            ReferenceS(NumRefs) = x
        End If
    Next x
    If QvRAutoAssignableFlag = 0 And (CLine = "" Or CLine = " ") And AutoMultFlag = 0 Then
        If NumRefs > 1 Then
            QvRAutoAssignableFlag = 1
            Response = MsgBox("I've noticed that some of the sequences may have been intentionally labeled as references.  Would you like me to automatically sort these into reference sets that could later be used for 'query vs reference' (as opposed to fully exploratory) type recombination scans?", vbYesNo)
            RefNum = 1
            If Response = 7 Then
                QvRFlag = 0
                Exit Sub
            End If
        Else
            Exit Sub
        End If
    Else
        If (CLine <> "" And CLine = " ") Or AutoMultFlag > 0 Then
            QvRFlag = 0
            Exit Sub
        End If
    End If
    QvRFlag = 1
    
    'Unmask all sequences - making is no longer desired
    ReDim MaskSeq(NextNo)
    
    'find reference groups
    
    
    
    
    
    ReDim IDMatch(NumRefs, NumRefs)
    If NumRefs > 2 Then
        For x = 1 To NumRefs - 1
            PosA = InStr(1, OriginalName(ReferenceS(x)), "ref", vbTextCompare)
            
            For Y = x + 1 To NumRefs
                
                PosB = InStr(1, OriginalName(ReferenceS(Y)), "ref", vbTextCompare)
                A = PosA + 3
                b = PosB + 3
                Do While A <= Len(OriginalName(ReferenceS(x))) And b <= Len(OriginalName(ReferenceS(Y)))
                    If LCase(Mid$(OriginalName(ReferenceS(x)), A, 1)) <> LCase(Mid$(OriginalName(ReferenceS(Y)), A, 1)) Then
                        
                        A = A - 1
                        b = b - 1
                        Exit Do
                    End If
                    A = A + 1
                    b = b + 1
                Loop
                'XX = Mid$(OriginalName(ReferenceS(X)), PosA, A - PosA + 1)
                IDMatch(x, Y) = Mid$(OriginalName(ReferenceS(x)), PosA, A - PosA + 1)
                IDMatch(Y, x) = IDMatch(x, Y)
            Next Y
        Next x
    End If
    'find shortest match
    MinMatch = 100000
    For x = 1 To NumRefs
        For Y = x + 1 To NumRefs
            If MinMatch > Len(IDMatch(x, Y)) Then
                MinMatch = Len(IDMatch(x, Y))
            End If
        Next Y
    Next x
    'trim of the left part so that the smallest match =0
    For x = 1 To NumRefs
        For Y = x + 1 To NumRefs
            'XX = Right(IDMatch(X, Y), Len(IDMatch(X, Y)) - MinMatch)
            IDMatch(x, Y) = Right(IDMatch(x, Y), Len(IDMatch(x, Y)) - MinMatch)
            IDMatch(Y, x) = IDMatch(x, Y)
        Next Y
    Next x
    
    'now use distance information to group the idmatches that are > 0 into sensible groups
    ReDim ReferenceList(NextNo)
    RefNum = 0
    
    'Work out individual maximum match score
    Dim IndividualMatch() As Long, MatchL As Long
    ReDim IndividualMatch(NumRefs)
    
    For x = 0 To NumRefs
        For Y = x + 1 To NumRefs
            MatchL = Len(IDMatch(x, Y))
            
            
            If MatchL > IndividualMatch(x) Then
                IndividualMatch(x) = MatchL
'                If ReferenceS(Y) = 208 Then
'                    X = X
'                End If
'                If ReferenceS(X) = 208 Then
'                    X = X
'                End If
            End If
            If MatchL > IndividualMatch(Y) Then
                IndividualMatch(Y) = MatchL
'                If ReferenceS(Y) = 208 Then
'                    X = X
'                End If
'                If ReferenceS(X) = 208 Then
'                    X = X
'                End If
            End If
        Next Y
    
    Next x
    
    Do
        MaxMatch = 0
        For x = 1 To NumRefs
            If ReferenceList(ReferenceS(x)) = 0 Then
                For Y = x + 1 To NumRefs
                    If ReferenceList(ReferenceS(Y)) = 0 Then
                        If MaxMatch < Len(IDMatch(x, Y)) Then
                            MaxMatch = Len(IDMatch(x, Y))
                            WinX = x
                            WinY = Y
                        End If
                    End If
                Next Y
            End If
        Next x
        If MaxMatch = 0 Then Exit Do
        RefNum = RefNum + 1
'        If RefNum = 3 Then
'            X = X
'        End If
        ReferenceList(ReferenceS(WinX)) = RefNum
        ReferenceList(ReferenceS(WinY)) = RefNum
        
        'add equal matches
        NumExtras = 0
        For x = 1 To NumRefs
            
            If ReferenceList(ReferenceS(x)) = 0 Then
                If Len(IDMatch(WinX, x)) = MaxMatch Then
                    ReferenceList(ReferenceS(x)) = RefNum
                ElseIf Len(IDMatch(WinX, x)) > 0 Then
                    NumExtras = NumExtras + 1
                End If
            End If
        Next x
        If NumExtras > 0 Then
            'now add smaller matchs that are >0 but are clustered within the actual matches
            'find smallest similarity between matches
            MinDist = 10
            For x = 1 To NumRefs
                A = ReferenceS(x)
                If ReferenceList(A) = RefNum Then
                    
                    For Y = x + 1 To NumRefs
                        b = ReferenceS(Y)
                        If ReferenceList(b) = RefNum Then
                            If MinDist > Distance(A, b) Then MinDist = Distance(A, b)
                        End If
                    Next Y
                End If
            Next x
            'collect all inlyers with partial matches to winx
            For x = 1 To NumRefs
                A = ReferenceS(x)
                If ReferenceList(A) = RefNum Then
                    
                    For Y = 1 To NumRefs
                        b = ReferenceS(Y)
                        If ReferenceList(b) = 0 Then
                            If Len(IDMatch(WinX, Y)) > 1 Then
                                If MinDist < Distance(A, b) Then
                                    ReferenceList(b) = RefNum
                                    NumExtras = NumExtras - 1
                                End If
                            End If
                        End If
                    Next Y
                End If
            Next x
            
            If NumExtras > 0 Then
                'find minimum distance between outstanding matches and winx
                MinDist = -1
                For x = 1 To NumRefs
                    A = ReferenceS(x)
                    If ReferenceList(A) = 0 Then
                        If Len(IDMatch(WinX, x)) = 0 Then
                            For Y = 1 To NumRefs
                                b = ReferenceS(Y)
                                If ReferenceList(b) = RefNum Then
                                    If MinDist < Distance(A, b) Then MinDist = Distance(A, b)
                                End If
                            Next Y
                        End If
                    End If
                Next x
                
                
                For x = 1 To NumRefs
                    A = ReferenceS(x)
                    If ReferenceList(A) = RefNum Then
                        
                        For Y = 1 To NumRefs
                            b = ReferenceS(Y)
                            If ReferenceList(b) = 0 Then
                                If Len(IDMatch(WinX, Y)) > 1 Then 'IndividualMatch(Y) Then
                                    If MinDist < Distance(A, b) Then
                                        ReferenceList(b) = RefNum
                                        NumExtras = NumExtras - 1
                                    Else
                                        
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                Next x
                If NumExtras > 0 Then 'try find all the rest
                    'find smallest similarity between matches added so far
                    MinDist = 10
                    For x = 1 To NumRefs
                        A = ReferenceS(x)
                        If ReferenceList(A) = RefNum Then
                            
                            For Y = x + 1 To NumRefs
                                b = ReferenceS(Y)
                                If ReferenceList(b) = RefNum Then
                                    If MinDist > Distance(A, b) Then MinDist = Distance(A, b)
                                End If
                            Next Y
                        End If
                    Next x
                    'collect all inlyers with partial matches to winx
                    For x = 1 To NumRefs
                        A = ReferenceS(x)
                        If ReferenceList(A) = RefNum Then
                            
                            For Y = 1 To NumRefs
                                b = ReferenceS(Y)
                                
                                If ReferenceList(b) = 0 Then
                                    If Len(IDMatch(WinX, Y)) > 1 Then
                                        If MinDist < Distance(A, b) Then
                                            ReferenceList(b) = RefNum
                                            NumExtras = NumExtras - 1
                                        End If
                                    End If
                                End If
                            Next Y
                        End If
                    Next x
                    If NumExtras > 0 Then
                        'check and see if largestmatch is to a sequence already icluded in this list
                        For x = 1 To NumRefs
                            A = ReferenceS(x)
                            If ReferenceList(A) = RefNum Then
                                For Y = 1 To NumRefs
                                    b = ReferenceS(Y)
                                    
                                    If ReferenceList(b) = 0 Then
                                        'If B = 208 And A = 206 Then
                                        '    X = X
                                        'End If
                                        If Len(IDMatch(x, Y)) = IndividualMatch(Y) Then
                                            ReferenceList(b) = RefNum
                                            NumExtras = NumExtras - 1
                                        End If
                                        
                                    End If
                                Next Y
                            End If
                        Next x
                        
                                
                    End If
                    'remove misplaced sequences
                    For x = 1 To NumRefs
                        A = ReferenceS(x)
                        If ReferenceList(A) = RefNum Then
                            GoOn = 1
                            For Y = 1 To NumRefs
                                If x <> Y Then
                                    b = ReferenceS(Y)
                                    If ReferenceList(b) = RefNum Then
                                        If Len(IDMatch(x, Y)) = IndividualMatch(x) Then
                                            GoOn = 0
                                            Exit For
                                        End If
                                    End If
                                End If
                            Next Y
                            If GoOn = 1 Then
                                ReferenceList(A) = 0
                                NumExtras = NumExtras + 1
                            End If
                        End If
                    Next x
                    'End If
                End If
            End If
        End If
        'XX = IDMatch(WinX, WinY)
'        If ReferenceList(206) > 0 Then
'            X = X
'        End If
'        If ReferenceList(207) > 0 Then
'            X = X
'        End If
'        If ReferenceList(208) > 0 Then
'            X = X
'        End If
    Loop
    
    Call UpdateRefCols
    'sort references into their input order
    
    Dim TempList() As Long, CurCount As Long, DoneThis() As Byte, TempCols() As Long
    ReDim TempList(PermNextno), DoneThis(RefNum), TempCols(RefNum)
    CurCount = 0
    For x = 0 To RefNum
        TempCols(x) = ReferenceCols(x)
    Next x
    For x = 0 To NextNo
        If ReferenceList(x) > 0 Then '122,123,124,158,159,160
            If DoneThis(ReferenceList(x)) = 0 Then
                DoneThis(ReferenceList(x)) = 1
                CurCount = CurCount + 1
                ReferenceCols(CurCount) = TempCols(ReferenceList(x))
                TempList(x) = CurCount
                For Z = x + 1 To PermNextno
                    If ReferenceList(Z) = ReferenceList(x) Then
                        TempList(Z) = CurCount
                    End If
                Next Z
            End If
        End If
    Next x
    For x = 0 To PermNextno
        ReferenceList(x) = TempList(x)
    Next x
    
    Call MakeRefGroupNames

    RedoRefNamesFlag = 0
    x = x
End Sub
Public Sub UpdateRefCols()
ReDim ReferenceCols(RefNum)
    
    Dim RX() As Long, Gx() As Long, Bx() As Long, RNums() As Long
    ReDim RNums(RefNum), RX(RefNum), Gx(RefNum), Bx(RefNum)
    
'    For X = 1 To Nextno
'        If ReferenceList(X) > 0 Then
'            RNums(ReferenceList(X)) = RNums(ReferenceList(X)) + 1
'            R = Int(SeqCol(X) / 65536)
'            G = Int((SeqCol(X) - R * 65536) / 256)
'            B = Int((SeqCol(X) - R * 65536 - G * 256))
'            If R > 255 Then R = 255
'            If R < 0 Then R = 0
'            If G > 255 Then G = 255
'            If G < 0 Then G = 0
'            If B > 255 Then B = 255
'            If B < 0 Then B = 0
'            Rx(ReferenceList(X)) = Rx(ReferenceList(X)) + R
'            Gx(ReferenceList(X)) = Gx(ReferenceList(X)) + G
'            Bx(ReferenceList(X)) = Bx(ReferenceList(X)) + B
'        End If
'    Next X
    
    Dim PosinScale As Single, ColX As Long
    
    For x = 1 To RefNum Step 5
        PosinScale = x / (RefNum + 1)
        ColX = HeatMap(0, 128 + PosinScale * 770)
        r = Int(ColX / 65536)
        g = Int((ColX - r * 65536) / 256)
        b = Int((ColX - r * 65536 - g * 256))
        If r > 255 Then r = 255
        If r < 0 Then r = 0
        If g > 255 Then g = 255
        If g < 0 Then g = 0
        If b > 255 Then b = 255
        If b < 0 Then b = 0
        ReferenceCols(x) = RGB(r, g, b) 'RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
        'ReferenceCols(X) = RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
    Next x
    For x = 3 To RefNum Step 5
        PosinScale = x / (RefNum + 1)
        ColX = HeatMap(0, 128 + PosinScale * 770)
        r = Int(ColX / 65536)
        g = Int((ColX - r * 65536) / 256)
        b = Int((ColX - r * 65536 - g * 256))
        If r > 255 Then r = 255
        If r < 0 Then r = 0
        If g > 255 Then g = 255
        If g < 0 Then g = 0
        If b > 255 Then b = 255
        If b < 0 Then b = 0
        If r < 2 Then r = 64
        If b < 2 Then b = 64
        If g < 2 Then g = 64
        ReferenceCols(x) = RGB(r, g, b) 'RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
        'ReferenceCols(X) = RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
    Next x
    For x = 5 To RefNum Step 5
        PosinScale = x / (RefNum + 1)
        ColX = HeatMap(0, 128 + PosinScale * 770)
        r = Int(ColX / 65536)
        g = Int((ColX - r * 65536) / 256)
        b = Int((ColX - r * 65536 - g * 256))
        If r > 255 Then r = 255
        If r < 0 Then r = 0
        If g > 255 Then g = 255
        If g < 0 Then g = 0
        If b > 255 Then b = 255
        If b < 0 Then b = 0
        If r < 2 Then r = 128
        If b < 2 Then b = 128
        If g < 2 Then g = 128
        ReferenceCols(x) = RGB(r, g, b) 'RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
        'ReferenceCols(X) = RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
    Next x
    For x = 2 To RefNum Step 5
        PosinScale = x / (RefNum + 1)
        ColX = HeatMap(0, 128 + PosinScale * 770)
        r = Int(ColX / 65536)
        g = Int((ColX - r * 65536) / 256)
        b = Int((ColX - r * 65536 - g * 256))
        If r > 255 Then r = 255
        If r < 0 Then r = 0
        If g > 255 Then g = 255
        If g < 0 Then g = 0
        If b > 255 Then b = 255
        If b < 0 Then b = 0
        If r < 2 Then r = 192
        If b < 2 Then b = 192
        If g < 2 Then g = 192
        ReferenceCols(x) = RGB(r, g, b) 'RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
        'ReferenceCols(X) = RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
    Next x
    For x = 4 To RefNum Step 5
        PosinScale = x / (RefNum + 1)
        ColX = HeatMap(0, 128 + PosinScale * 770)
        r = Int(ColX / 65536)
        g = Int((ColX - r * 65536) / 256)
        b = Int((ColX - r * 65536 - g * 256))
        If r > 255 Then r = 255
        If r < 0 Then r = 0
        If g > 255 Then g = 255
        If g < 0 Then g = 0
        If b > 255 Then b = 255
        If b < 0 Then b = 0
        If r < 2 Then r = 255
        If b < 2 Then b = 255
        If g < 2 Then g = 255
        ReferenceCols(x) = RGB(r, g, b) 'RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
        'ReferenceCols(X) = RGB(((Int(Rx(X) / RNums(X))) + R) / 2, (Int(Gx(X) / RNums(X)) + G) / 2, (Int(Bx(X) / RNums(X)) + B) / 2)
    Next x
'    Dim StepSize As Single, RCount As Long
'    RCount = 0
'    StepSize = RefNum / 9
'    StepSize = CInt((230 / StepSize) - 0.5)
'    For B = 10 To 240 Step StepSize
'        For G = 10 To 240 Step StepSize
'            For R = 10 To 240 Step StepSize
'                RCount = RCount + 1
'                If RCount > RefNum Then
'                    B = 240
'                    G = 240
'                    R = 240
'                    Exit For
'                End If
'                ReferenceCols(RCount) = RGB(R, G, B)
'            Next R
'        Next G
'    Next B
    
End Sub
Public Sub MakeCurveArray(PosX2)

'This does the zooming distortion of the plot display
Dim Dummy As Long, LCA As Long, x As Long, XFactor As Single, XF2 As Single, PosX As Long, xf3 As Single, IncX As Single

Dim AxLen As Long

If DebuggingFlag < 2 Then On Error Resume Next
AxLen = -1
AxLen = GYAxHi(1)
On Error GoTo 0


XFactor = ((Form1.Picture7.Width - 40) / AxLen)
XF2 = (1 / XFactor) '* 1000
If AxLen > -1 Then
    LCA = AxLen
Else
    LCA = Len(StrainSeq(0))
End If
If PosX2 > 0 And PosX < LCA Then
    PosX = PosX2 '* XF2
Else
    PosX = -1
End If
'@'@
ReDim CurveArray(LCA)
If PosX > 0 And XF2 > 1 And AxLen > -1 Then
    
    If x = x Then
        Dummy = FillArray3(LCA, CSng(1), CurveArray(0))
    Else
        For x = 0 To LCA
            CurveArray(x) = 1
        Next x
    End If
    CurveArray(PosX) = 1
Else
    If x = x Then
        Dummy = FillArray3(LCA, CSng(1), CurveArray(0))
    Else
        For x = 0 To LCA
            CurveArray(x) = 1
        Next x
    End If
    Exit Sub
End If


'these two are for awindow that is 1/4 the sequence length
Dim SWin As Single, HSWin As Single

Dim PZ2 As Single, ZoomR As Long, ZoomL As Long, ExtraBit As Long, PZ As Single, DistOnScreen As Single, RealDist As Single, MirrorDist As Long, HSWin2 As Single, IncX2 As Single
SWin = Decompress(p7CurWinSize)
    HSWin = PosX - SWin
    HSWin2 = PosX + SWin
'P7ZoomLevel = 50
If P7ZoomLevel < 0 Then P7ZoomLevel = 0
If P7ZoomLevel < 10 Then
    XF2 = 1 + P7ZoomLevel / 10
    ZoomL = HSWin - 1
    ZoomR = HSWin2 + 1
    ExtraBit = 0
    PZ2 = 1
Else
    
    XF2 = 2 '1 + P7ZoomLevel / 10 '2
    PZ = P7ZoomLevel - 9
    PZ = PZ / 43
    ExtraBit = CLng((PZ * (SWin * 2)) / 2)
    
    ZoomR = CLng(HSWin2 - ExtraBit)
    ZoomL = CLng(HSWin + ExtraBit)
    PZ2 = (1 - PZ) / 2
End If

If HSWin < 1 Then HSWin = 1
If HSWin2 > LCA Then HSWin2 = LCA
If ZoomL < 1 Then ZoomL = HSWin - 1
If ZoomR > LCA Then ZoomR = HSWin2 + 1
'XF2 = 2
'XF2 = 10 ' >1 =raised circle centred on posx'  Max raise when xf2 ~10, <1 is a spike centred on xf2
'IncX = ((XF2 - 1) / (SWin - Extrabit)) / ((SWin - Extrabit / 2) / SWin) ' - Extrabit)

'XF2 = 80
Dim AV As Single, BV As Single, CV As Single, DV As Single, AddjV As Single
If ZoomL <> HSWin - 1 Then
    AddjV = HSWin / ZoomL
    
    
    If x = x Then
        Dummy = FillArray3(ZoomL, AddjV, CurveArray(0))
    Else
        For x = 1 To ZoomL
            CurveArray(x) = AddjV
        Next x
    End If
    ''These two are for the full sequence linear increment
   ' IncX = (XF2 - 1) / (PosX + 1)
    'Dim DistOnScreen As Single, RealDist As Single, MirrorDist As Long
'    For X = 1 To HSWin
'
'        DistOnScreen = (PosX - X) * XFactor
'        RealDist = (DistOnScreen - (DistOnScreen * ((1 + (IncX * (PosX - X))) / XF2))) / XFactor
'        CurveArray(X) = ((X - RealDist) / X) '- '0.99  'IncX * X '((X - (IncX * X)) / X) 'Abs((X - (1 / (1 - IncX * X))) / X)
'
'    Next X

End If
If SWin = 0 Then
    Exit Sub
End If
IncX = ((XF2 - 1) / (SWin))




If x = x Then
    Dummy = CurveLeft(ZoomL, PosX, SWin, IncX, XFactor, PZ2, XF2, CurveArray(0))
    x = x
Else
    For x = ZoomL + 1 To PosX - 1
    
        DistOnScreen = (PosX - x) * XFactor / PZ2
        'RealDist = (DistOnScreen - (DistOnScreen * ((1 + (IncX * (PosX - X))) / XF2))) / XFactor
        DV = 1 + (IncX * (PosX - x)) ' 1 plus the difference between posx and x as a proportion of swin
        CV = DV / XF2 ' xf2 = curvature of the raised bit
        'CV = (1 / XF2 + (PosX - X) / SWin - (PosX + X) / (SWin * XF2)) * XFactor
        CV = 1 / XF2 + ((XF2 - 1) * (PosX - x)) / (SWin * XF2)
        BV = DistOnScreen * CV
        
        
        
    '    BV = ((PosX - X) ^ 2) / SWin - ((PosX - X) ^ XF2) / (SWin * 2) + (PosX - X) / XF2
    '
    '    BV = (BV * XFactor) / PZ2 '(1 - (1 - pz3) / 2) '/ PZ2'the closer pz2 is to zero the closer the nt distance get to the pixel distance
        
        AV = DistOnScreen - BV
        RealDist = AV / XFactor
        
        CurveArray(x) = ((x - RealDist) / x) '- '0.99  'IncX * X '((X - (IncX * X)) / X) 'Abs((X - (1 / (1 - IncX * X))) / X)
        If CurveArray(x) * x < 1 Then
            CurveArray(x) = 1 / (x)
        End If
        
    Next x
End If
'HSWin = HSWin - 10
'If HSWin < 1 Then HSWin = 1
'For X = PosX To HSWin + 1 Step -1
'    If CSng(CurveArray(X) * Decompress(X)) < CSng(CurveArray(X - 1) * Decompress(X - 1)) Then
'        CurveArray(X) = CSng(CurveArray(X - 1) * Decompress(X - 1) / Decompress(X))
'        CurveArray(X - 1) = CSng(CurveArray(X) * Decompress(X) / Decompress(X - 1))
'        'CurveArray(X) = CSng(CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        'GoOn = 0
'    End If
'Next X

IncX2 = (XF2 - 1) / (SWin) ' - Extrabit)

If ZoomR < LCA Then
    AddjV = (LCA - HSWin2) / (LCA - ZoomR)
    
    Dim Y As Long
    
    
    If x = x Then
        '@
        Dummy = CurveMid(LCA, ZoomR, AddjV, HSWin2, CurveArray(0))
        x = x
    Else
        For x = ZoomR To LCA
            CurveArray(x) = ((HSWin2 + (x - ZoomR) * AddjV)) / x
        Next x
    End If
End If
'For X = ZoomR To HSWin2 'ensure that all the values in this region map to hswin2
'    CurveArray(X) = HSWin2 / X
'
'Next X


If x = x Then
    'If (PosX + 1) < (ZoomR - 1) Then
        Dummy = CurveRight(LCA, ZoomR, PosX, SWin, IncX2, XFactor, PZ2, XF2, CurveArray(0))
    'Else
    '    X = X
    'End If
    x = x
Else
    For x = PosX + 1 To ZoomR - 1
        
        DistOnScreen = CSng((x - PosX) * XFactor)
        RealDist = CSng((DistOnScreen - (DistOnScreen * ((1 + (IncX2 * (x - PosX))) / XF2))) / XFactor / PZ2)
        CurveArray(x) = CSng((x + RealDist) / x) '- '0.99  'IncX * X '((X - (IncX * X)) / X) 'Abs((X - (1 / (1 - IncX * X))) / X)
        
        If (CurveArray(x) * x) > LCA Then
            CurveArray(x) = CSng(LCA / x)
        End If
        
    Next x
End If
HSWin = HSWin + 10

If HSWin = LCA Then HSWin = LCA - 1

'Do While GoOn = 0
'    GoOn = 1
'For X = PosX + 1 To HSWin
'    If CSng(CurveArray(X) * Decompress(X)) > CSng(CurveArray(X + 1) * Decompress(X + 1)) Then
'        CurveArray(X) = CSng(CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        CurveArray(X + 1) = CSng(CurveArray(X) * Decompress(X) / Decompress(X + 1))
'        'CurveArray(X) = CSng(CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        'GoOn = 0
'    End If
'Next X

'For X = PosX + 1 To HSWin
'    If CSng(CurveArray(X) * Decompress(X)) > CSng(CurveArray(X + 1) * Decompress(X + 1)) Then
'        CurveArray(X) = CSng(CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        'GoOn = 0
'    End If
'Next X
'For X = PosX + 1 To HSWin
'    If clng(CSng(CurveArray(X) * Decompress(X)) > CSng(CurveArray(X + 1) * Decompress(X + 1)) Then
'        CurveArray(X) = CSng(CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        X = X
'        'GoOn = 0
'    End If
'Next X
'For X = PosX + 1 To HSWin
'    If CurveArray(X) * Decompress(X) > CurveArray(X + 1) * Decompress(X + 1) Then
'        CurveArray(X) = (CurveArray(X + 1) * Decompress(X + 1) / Decompress(X))
'        'GoOn = 0
'    End If
'Next X
'Loop
CurveArray(0) = 1
CurveArray(1) = 1
CurveArray(LCA) = 1
''These two are for the full sequence linear increment
'IncX = (XF2 - 1) / (PosX + 1)
'Dim DistOnScreen As Single, RealDist As Single, MirrorDist As Long
'For X = 1 To PosX - 1
'
'    DistOnScreen = (PosX - X) * XFactor
'    RealDist = (DistOnScreen - (DistOnScreen * ((1 + (IncX * (PosX - X))) / XF2))) / XFactor
'    CurveArray(X) = ((X - RealDist) / X) '- '0.99  'IncX * X '((X - (IncX * X)) / X) 'Abs((X - (1 / (1 - IncX * X))) / X)
'
'Next X
'IncX = (XF2 - 1) / (LCA - PosX + 1)
'For X = PosX + 1 To LCA
'
'    DistOnScreen = (X - PosX) * XFactor
'    RealDist = (DistOnScreen - (DistOnScreen * ((1 + (IncX * (X - PosX))) / XF2))) / XFactor
'    CurveArray(X) = ((X + RealDist) / X) '- '0.99  'IncX * X '((X - (IncX * X)) / X) 'Abs((X - (1 / (1 - IncX * X))) / X)
'
'Next X

Exit Sub


x = x
'For X = PosX + 1 To LCA
'    CurveArray(X) = 1 - (PosX - X) / (PosX / 2)
'Next X
'
'For X = PosX To PosX + ((LCA - PosX) / 2)
'    CurveArray(X) = 1 + ((PosX / 2) - X) / (PosX / 2)
'Next X

'For X = PosX + ((LCA - PosX) / 2) To LCA
'    CurveArray(X) = (X - PosX) / (LCA - PosX)
'Next X

End Sub
Public Sub DoPolyPointObject(ImageData() As Byte, PB As PictureBox, LineList() As Single, OutlineCol As Long, FillCol As Long)
Dim Z As Long, x As Long, Y As Long, X3 As Single, Y3 As Single, Y1 As Single, Y2 As Single, X1 As Single, X2 As Single, M As Single, C As Single, UBFP1, UBFP2
Dim StepDir As Long, IY As Long, IX As Long, UBLL2 As Long, X4 As Single, Y4 As Single
Dim FakePicture() As Single, FakePicture2() As Single, FakePicture3() As Single





UBFP1 = UBound(ImageData, 2) + 1 'bm.bmWidth
UBFP2 = UBound(ImageData, 3) + 1 'bm.Height
ReDim FakePicture(UBFP1, UBFP2)
ReDim FakePicture2(UBFP1, UBFP2)
ReDim FakePicture3(UBFP1, UBFP2)

 '
Dim BigNum As Single, SmallNum As Single
BigNum = 10 ^ 10
SmallNum = 0.00000000000001
UBLL2 = UBound(LineList, 2)
'Exit Sub
'@
Dim UBFP32 As Long, UBFP31 As Long
 UBFP32 = UBound(FakePicture3, 2)
 UBFP31 = UBound(FakePicture3, 1)
For x = 0 To UBLL2
    If LineList(1, x) < 0 Then LineList(1, x) = 0
    If CLng(LineList(1, x)) > UBFP32 Then
        LineList(1, x) = UBFP32
    End If
    If LineList(0, x) > UBFP31 Then LineList(0, x) = UBFP31
    FakePicture3(CLng(LineList(0, x)), CLng(LineList(1, x))) = 1
Next x
Z = 0

Do
    
    
    
    Y1 = LineList(1, Z)
    Y2 = LineList(1, Z + 1)
    X1 = LineList(0, Z)
    X2 = LineList(0, Z + 1)
    'FakePicture3(CLng(X1), CLng(Y1)) = 1
    'FakePicture3(CLng(X2), CLng(Y2)) = 1
    
    If (X1 > 0 Or Y1 > 0) And (X2 > 0 Or Y2 > 0) Then
    
        'Width = 2
        If X2 <> X1 Then
            M = (Y2 - Y1) / (X2 - X1)
            'If M = 0 Then M = SmallNum
        Else
            M = BigNum
        End If
        
        C = Y1 - M * X1
        
        If X1 < X2 Then
                
        Else
            X4 = X1
            X1 = X2
            X2 = X4
        End If
        
        
        If Y1 < Y2 Then
                
        Else
            Y4 = Y1
            Y1 = Y2
            Y2 = Y4
        End If
        
        'do the middle bits
        
        '@
        If Abs((X1) - (X2)) >= Abs((Y1) - (Y2)) Then
            
            
            
            Do
            'For X = CLng(X1) To CLng(X2)
                Y3 = M * X1 + C
                x = CLng(X1)
                If (Y3 >= Y1 And Y3 <= Y2) Then
                    IY = Int(Y3)
                    
                    If Y3 <= UBFP2 - 1 Then
                        '@
                        If 1 - (Y3 - IY) > FakePicture(x, IY) Then FakePicture(x, IY) = 1 - (Y3 - IY)
                        If (Y3 - IY) > FakePicture(x, IY + 1) Then FakePicture(x, IY + 1) = (Y3 - IY)
                        
                    End If
                    FakePicture3(x, CLng(Y3)) = 1
                End If
            'Next X
                X1 = X1 + 0.5
                If X1 > X2 Then Exit Do
            Loop
        Else 'If (Y1) <> (Y2) Then 'If Abs(CLng(X1) - CLng(X2)) < Abs(CLng(Y1) - CLng(Y2)) Then
            
            If Y1 <> Y2 Then
                '&
                Do
                'For Y = CLng(Y1) To CLng(Y2)
                    Y = CLng(Y1)
                    X3 = (Y1 - C) / M
                    
                    If X3 >= X1 And X3 <= X2 Then
                        IX = Int(X3)
                        If 1 - (X3 - IX) > FakePicture(IX, Y) Then FakePicture(IX, Y) = 1 - (X3 - IX)
                        If (X3 - IX) > FakePicture(IX + 1, Y) Then FakePicture(IX + 1, Y) = (X3 - IX)
                        
                    End If
                    FakePicture3(CLng(X3), Y) = 1
                    Y1 = Y1 + 0.5
                    If Y1 > Y2 Then Exit Do
                'Next Y
                Loop
            End If
        End If
        'End If
        
        
        
        'y = m * x + c
        'c = y - m * x : c = y1 - m * x1
        'm = (y-c)/x
        'm = (y2-y1)/(x2-x1)
        'c = y1-(m*x1)
        
        'If LineList(1, Z + 1) = 0 And LineList(0, Z + 1) = 0 Then Exit Do
    End If
    Z = Z + 1
    
    If Z > UBLL2 - 1 Then Exit Do
Loop


'XX = FakePicture3(0, 0)
'XX = FakePicture3(1, 0)

If x = x Then
    '@
    Dummy = FillObject(UBFP1, UBFP2, FakePicture(0, 0), FakePicture2(0, 0), FakePicture3(0, 0))
Else
    For Y = 0 To UBFP2
        x = 0
        Do
            'For X = 0 To UBFP1
            If FakePicture3(x, Y) = 1 Then
                Z = x + 1
                Do
                    If FakePicture3(Z, Y) = 0 Then
                        Exit Do
                    End If
                    Z = Z + 1
                    If Z >= UBFP1 Then
                        Exit Do
                        x = Z
                    End If
                Loop
                If Z < UBFP1 And Z >= x + 1 Then
                    'FakePicture(X + 1, Y) = 0
                    A = Z
                    Z = A + 1
                    Do
                        If FakePicture3(Z, Y) > 0 Then
                            Z = Z - 1
                            Exit Do
                            
                        End If
                        Z = Z + 1
                        If Z >= UBFP1 Then
                            Exit Do
                            x = Z
                        End If
                    Loop
                    If Z < UBFP1 And Z >= A Then
                        For C = A To Z
                            FakePicture2(C, Y) = 1
                        Next C
                    End If
                End If
                x = Z
            End If
            'Next X
            x = x + 1
            If x > UBFP1 Then Exit Do
        Loop
    Next Y
    
    
    
    For x = 0 To UBFP1
        Y = 0
        Do
            'For X = 0 To UBFP1
            If FakePicture3(x, Y) > 0 Then
                Z = Y + 1
                Do
                    If FakePicture3(x, Z) = 0 Then
                        Exit Do
                    End If
                    Z = Z + 1
                    If Z >= UBFP2 Then
                        Y = Z
                        Exit Do
                    End If
                Loop
                If Z < UBFP2 And Z >= Y + 1 Then
                    'FakePicture(X + 1, Y) = 0
                    A = Z
                    Z = A + 1
                    Do
                        If FakePicture3(x, Z) > 0 Then
                            Z = Z - 1
                            Exit Do
                            
                        End If
                        Z = Z + 1
                        If Z >= UBFP2 Then
                            Y = Z
                            Exit Do
                        End If
                    Loop
                    If Z < UBFP2 And Z >= A Then
                        For C = A To Z
                            FakePicture2(x, C) = FakePicture2(x, C) + 1
                        Next C
                    End If
                End If
                Y = Z
            End If
            'Next X
            Y = Y + 1
            If Y > UBFP2 Then Exit Do
        Loop
    Next x
    
    For x = 0 To UBFP1
        For Y = 0 To UBFP2
            If FakePicture(x, Y) = 5 Then
                FakePicture2(x, Y) = 1
            ElseIf FakePicture2(x, Y) = 2 Then
                FakePicture2(x, Y) = 0.5
            Else
                FakePicture2(x, Y) = 0
            End If
        Next Y
    Next x
End If

Dim MaxV As Single
MaxV = 0


If x = x Then
    
    Dummy = ModFP(UBFP1, UBFP2, MaxV, FakePicture(0, 0))
Else
    For x = 0 To UBound(FakePicture, 1)
        For Y = 0 To UBound(FakePicture, 2)
            If MaxV < FakePicture(x, Y) Then MaxV = FakePicture(x, Y)
        Next Y
    Next x
    MaxV = MaxV / 2
    For x = 0 To UBound(FakePicture, 1)
        For Y = 0 To UBound(FakePicture, 2)
            If FakePicture(x, Y) < MaxV Then
                FakePicture(x, Y) = FakePicture(x, Y) / MaxV
            Else
                FakePicture(x, Y) = 1
            End If
        Next Y
    Next x
End If




Dim r As Long, g As Long, b As Long

r = Int(OutlineCol / 65536)
g = Int((OutlineCol - r * 65536) / 256)
b = Int((OutlineCol - r * 65536 - g * 256))
If r > 255 Then r = 255
If r < 0 Then r = 0
If g > 255 Then g = 255
If g < 0 Then g = 0
If b > 255 Then b = 255
If b < 0 Then b = 0
'For X = 0 To UBound(FakePicture, 1)

'If x = x Then

'this does the outlines
If x = x Then
  
    Dummy = MakeImageDataBO(r, g, b, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture(0, 0), ImageData(0, 0, 0))
Else
    For x = 0 To UBound(ImageData, 2)
        For Y = 0 To UBound(ImageData, 3)
            ImageData(0, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(0, x, Y) + r * FakePicture(x, Y))
            ImageData(1, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(1, x, Y) + g * FakePicture(x, Y))
            ImageData(2, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(2, x, Y) + b * FakePicture(x, Y))
        Next Y
    Next x
End If

'this does the fills
If FillCol <> -1 Then
    Dummy = MakeImageDataBO(r, g, b, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture2(0, 0), ImageData(0, 0, 0))
End If
'R = Int(FillCol / 65536)
'G = Int((FillCol - R * 65536) / 256)
'B = Int((FillCol - R * 65536 - G * 256))
'If R > 255 Then R = 255
'If R < 0 Then R = 0
'If G > 255 Then G = 255
'If G < 0 Then G = 0
'If B > 255 Then B = 255
'If B < 0 Then B = 0

'Dummy = MakeImageDataBO(R, G, B, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture(0, 0), ImageData(0, 0, 0))


'Next X




'    If X = 12345 Then
'        For X = 0 To UBound(ImageData, 2)
'            For Y = 0 To UBound(ImageData, 3)
'                ImageData(0, X, Y) = 255
'                ImageData(1, X, Y) = 255
'                ImageData(2, X, Y) = 255
'            Next Y
'        Next X
'
'    End If


End Sub
Public Sub DrawmapsAA(PB As PictureBox, TType As Long, TNum As Long, IStart As Long, TSingle As Single, TSH As Long)
Dim Dummy As Long, A As Long, b As Long, D As Long, C As Long, UBA As Long, UBB As Long, UBC As Long, UBD As Long, UBMBR As Long, LSeq As Long
Dim Z As Long, x As Long, Y As Long, X3 As Single, Y3 As Single, Y1 As Single, Y2 As Single, X1 As Single, X2 As Single, M As Single
Dim StepDir As Long
Dim FakePicture() As Single
Dim ImageData() As Byte, bm As BITMAP
Dim ImageData2() As Byte, bm2 As BITMAP
Dim AH1 As Single, AH2 As Single
Dim LoFnt As Long, OldFont As Long, OldFont2 As Long
    Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
    Dim LBrush As LOGBRUSH
'2.171
Dim XSize As Single, UBMB4 As Long, Side As Long
Dim MBN As Long

Dim YRes As Long, XRes As Long

YRes = CLng((0.181818 / TSingle) * 10) '/'7 'determines the resolution
If YRes < 1 Then
    YRes = 1
ElseIf YRes > 7 Then
    YRes = 7
End If

XRes = 1
'2.172

'Exit Sub
GetObject PB.Image, Len(bm), bm

'2.188


ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)

'2.343







XSize = bm.bmWidth - 10






UBMB4 = UBound(MapBlocks, 4)

MBN = MapBlockNum(TType, TNum)

'If X = X Then
    
    
    
'    UBMBR = -1
'
'    If DebuggingFlag < 2 Then On Error Resume Next
'    UBMBR = UBound(MapBlocksR, 2)
'    On Error GoTo 0
'    ubD = UBound(MapBlocks, 4)
'
'    If UBMBR < ubD Then
'
'        ubA = UBound(MapBlocks, 1)
'        ubB = UBound(MapBlocks, 2)
'        ubC = UBound(MapBlocks, 3)
'
'        ReDim MapBlocksR(ubC, ubD, ubA, ubB)
'        For A = 0 To ubA
'            For B = 0 To ubB
'                For C = 0 To ubC
'                    For D = 0 To ubD
'                        MapBlocksR(C, D, A, B) = MapBlocks(A, B, C, D)
'                    Next D
'                Next C
'            Next B
'        Next A
'    End If

'2.297
    Dim BPos As Long, Epos As Long, hdcHolder As Long
    
    Form2.Picture5.ScaleMode = 3
    Form2.Picture5.Width = bm.bmWidth * XRes * Screen.TwipsPerPixelX
    Form2.Picture5.Height = bm.bmHeight * YRes * Screen.TwipsPerPixelY
    Form2.Picture5.AutoRedraw = True
    Form2.Picture5.DrawMode = 13
    Form2.Picture5.ScaleMode = 3
    Form2.Picture5.FillColor = FormColour
    
    '@
    'Dummy = Rectangle(Form2.Picture5.hdc, 0, 0, bm.bmWidth * XRes, bm.bmHeight * YRes)
    Form2.Picture5.Picture = LoadPicture()
    If x = 12345 Then ' this is slower than the other way because of the bitblt step
        'Form2.Picture5.Picture = LoadPicture() 'dont know why the fuck I need this
        hdcHolder = gDib.hdc
        'hdcHolder = 0
        PEN = CreatePenIndirect(LPen)
        oldpen = SelectObject(hdcHolder, PEN)
        Brush = CreateBrushIndirect(LBrush)
        OldBrush = SelectObject(hdcHolder, Brush)

        LBrush.lbColor = FormColour
        LPen.lopnColor = FormColour
        
        PEN = CreatePenIndirect(LPen)
        
        Pen2 = SelectObject(hdcHolder, PEN)
        Brush = CreateBrushIndirect(LBrush)
        Brush2 = SelectObject(hdcHolder, Brush)
                    
        '@
        Dummy = Rectangle(hdcHolder, 0, 0, bm.bmWidth * XRes, bm.bmHeight * YRes)
        
        DeleteObject (Pen2)
        DeleteObject (Brush2)
        
        
        '@
        Dummy = MakeBigMap(IStart, XRes, YRes, MBN, TType, TNum, TSH, XSize, TSingle, UBound(MapBlocks, 1), UBound(MapBlocks, 2), UBound(MapBlocks, 3), UBMB4, hdcHolder, MapBlocks(0, 0, 0, 0))
        BPos = XoverList(RelX, RelY).Beginning
        Epos = XoverList(RelX, RelY).Ending
        LSeq = Len(StrainSeq(0))
        
        
        LBrush.lbColor = FormColour 'Abs(Form2.Picture3(1).BackColor)
        LPen.lopnColor = FormColour

        PEN = CreatePenIndirect(LPen)
        Pen2 = SelectObject(hdcHolder, PEN)
        Brush = CreateBrushIndirect(LBrush)
        Brush2 = SelectObject(hdcHolder, Brush)
                    
        
        If BPos > 0 Or Epos > 0 Then
            If TNum = 1 Then
                If BPos < Epos Then
                    Dummy = Rectangle(hdcHolder, (5 + (BPos / LSeq) * XSize) * XRes, 0, (5 + (Epos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes)
                Else
                    Dummy = Rectangle(hdcHolder, (5 + (1 / LSeq) * XSize) * XRes, 0, (5 + (Epos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes)
                    Dummy = Rectangle(hdcHolder, (5 + (BPos / LSeq) * XSize + 1) * XRes, 0, (5 + 1 * XSize) * XRes, (Form2.Picture3(1).Height) * YRes)
                End If
            ElseIf TNum = 2 Then
                If BPos < Epos Then
                    Dummy = Rectangle(hdcHolder, (5 + (1 / LSeq) * XSize) * XRes, 0, (5 + (BPos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes)
                    Dummy = Rectangle(hdcHolder, (5 + (Epos / LSeq) * XSize + 1) * XRes, 0, (5 + 1 * XSize) * XRes, (Form2.Picture3(1).Height) * YRes)
                Else
                    Dummy = Rectangle(hdcHolder, (5 + (Epos / LSeq) * XSize - 1) * XRes, 0, (5 + (BPos / LSeq) * XSize + 1) * XRes, (Form2.Picture3(1).Height) * YRes)
                End If
            End If
        End If
        
        DeleteObject (Pen2)
        DeleteObject (Brush2)
        '@
        'it would be ~30% faster if I worked directly with the dib.  the problem though is that the I dont know how to load the dib dircetly into imagedata2
        BitBlt Form2.Picture5.hdc, 0, 0, Form2.Picture5.ScaleWidth, Form2.Picture5.ScaleHeight, hdcHolder, 0, 0, vbSrcCopy
        
        PEN = SelectObject(hdcHolder, oldpen)
        DeleteObject (PEN)
        Brush = SelectObject(hdcHolder, OldBrush)
        DeleteObject (Brush)
    Else
        

        
        Form2.Picture5.Picture = LoadPicture()
        
        'Form2.Picture5 = LoadPicture()
        
        Dummy = MakeBigMap(IStart, XRes, YRes, MBN, TType, TNum, TSH, XSize, TSingle, UBound(MapBlocks, 1), UBound(MapBlocks, 2), UBound(MapBlocks, 3), UBMB4, Form2.Picture5.hdc, MapBlocks(0, 0, 0, 0))
        
        BPos = XoverList(RelX, RelY).Beginning
        Epos = XoverList(RelX, RelY).Ending
        LSeq = Len(StrainSeq(0))
        If TNum = 1 Then
            If BPos < Epos Then
                Form2.Picture5.Line ((5 + (BPos / LSeq) * XSize) * XRes, 0)-((5 + (Epos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
            Else
               Form2.Picture5.Line ((5 + (1 / LSeq) * XSize) * XRes, 0)-((5 + (Epos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
                Form2.Picture5.Line ((5 + (BPos / LSeq) * XSize + 1) * XRes, 0)-((5 + 1 * XSize) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
            End If
        ElseIf TNum = 2 Then
            If BPos < Epos Then
                Form2.Picture5.Line ((5 + (1 / LSeq) * XSize) * XRes, 0)-((5 + (BPos / LSeq) * XSize - 1) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
                Form2.Picture5.Line ((5 + (Epos / LSeq) * XSize + 1) * XRes, 0)-((5 + 1 * XSize) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
            Else
                Form2.Picture5.Line ((5 + (Epos / LSeq) * XSize - 1) * XRes, 0)-((5 + (BPos / LSeq) * XSize + 1) * XRes, (Form2.Picture3(1).Height) * YRes), Form2.Picture3(1).BackColor, BF
            End If
        End If
    
    End If
    
    'Dummy = MakeBigMapB(IStart, XRes, YRes, MBN, TType, TNum, TSH, XSize, TSingle, UBound(MapBlocksR, 1), UBound(MapBlocksR, 2), UBound(MapBlocksR, 3), UBound(MapBlocksR, 4), Form2.Picture5.hDC, MapBlocksR(0, 0, 0, 0))
'3.875

'Else
'
'    For X = 1 To MBN
'        'XX = Form2.Picture2(0).AutoRedraw
'
'
'        If X <= UBMB4 Then
'
'            AH1 = MapBlocks(TType, TNum, 2, X)
'
'            If IStart + (AH1 + 13) * TSingle >= 0 Then
'
'
'
'                If IStart + AH1 * TSingle <= TSH Then
'
'                        Form2.Picture5.Line (((5 + MapBlocks(TType, TNum, 0, X) * XSize) * XRes), (IStart + (AH1 + 4) * TSingle) * YRes)-((5 + MapBlocks(TType, TNum, 1, X) * XSize) * XRes, (IStart + (AH1 + 13) * TSingle) * YRes), MapBlocks(TType, TNum, 3, X), BF
'
'                End If
'            End If
'        End If
'
'    Next X
'End If

'4.00, 3.984


GetObject Form2.Picture5.Image, Len(bm2), bm2
'@
ReDim ImageData2(0 To (bm2.bmBitsPixel \ 8) - 1, 0 To bm2.bmWidth - 1, 0 To bm2.bmHeight - 1)

'

'4.687
'@
GetBitmapBits Form2.Picture5.Image, bm2.bmWidthBytes * bm2.bmHeight, ImageData2(0, 0, 0)

'5.140,5.125


 
Dim ImageX() As Long, PCount() As Long
'
ReDim ImageX(2, UBound(ImageData, 2) + 1, UBound(ImageData, 3) + 1)
ReDim PCount(UBound(ImageData, 2) + 1, UBound(ImageData, 3) + 1)

'5.812
'If X = X Then
''@
    'Dummy = DoAABlocks(XRes, YRes, UBound(PCount, 1), UBound(ImageX, 2), UBound(ImageData2, 2), UBound(ImageData2, 3), UBound(ImageData, 2), UBound(ImageData, 3), PCount(0, 0), ImageX(0, 0, 0), ImageData(0, 0, 0), ImageData2(0, 0, 0))
    Dummy = DoAABlocksP(XRes, YRes, UBound(PCount, 1), UBound(ImageX, 2), UBound(ImageData2, 2), UBound(ImageData2, 3), UBound(ImageData, 2), UBound(ImageData, 3), PCount(0, 0), ImageX(0, 0, 0), ImageData(0, 0, 0), ImageData2(0, 0, 0))
 '7.922

'Else
'    For Y = 0 To bm2.bmHeight - 1
'        For X = 0 To bm2.bmWidth - 1
'
'            A = CLng(X / XRes)
'            B = CLng(Y / YRes)
'            PCount(A, B) = PCount(A, B) + 1
'            For Z = 0 To 2
'                ImageX(Z, A, B) = ImageX(Z, A, B) + CLng(ImageData2(Z, X, Y))
'            Next Z
'        Next X
'    Next Y
'    For Y = 0 To bm.bmHeight - 1
'        For X = 0 To bm.bmWidth - 1
'
'
'            For Z = 0 To 2
'                ImageData(Z, X, Y) = CByte((ImageX(Z, X, Y) / PCount(X, Y)))
'            Next Z
'        Next X
'    Next Y
'End If
    




SetBitmapBits PB.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
'8.000
'Exit Sub


'    If X = 12345 Then
'        For X = 0 To UBound(ImageData, 2)
'            For Y = 0 To UBound(ImageData, 3)
'                ImageData(0, X, Y) = 255
'                ImageData(1, X, Y) = 255
'                ImageData(2, X, Y) = 255
'            Next Y
'        Next X
'
'    End If


End Sub
Public Sub DoBlockObject(ImageData() As Byte, PB As PictureBox, LineList() As Single, ColPix As Long, Width As Byte, Opacity As Byte)
Dim Dummy As Long, Z As Long, x As Long, Y As Long, X3 As Single, Y3 As Single, Y1 As Single, Y2 As Single, X1 As Single, X2 As Single, M As Single, C As Single
Dim StepDir As Long
Dim FakePicture() As Single



Dim UBFP1 As Long, UBFP2 As Long

UBFP1 = UBound(ImageData, 2) + 1 'bm.bmWidth
UBFP2 = UBound(ImageData, 3) + 1 'bm.Height
ReDim FakePicture(UBFP1, UBFP2)

Dim Side As Long
Z = 0 '
Do
    
    For Side = 0 To 3
        X1 = LineList(Side, 0, Z)
        Y1 = LineList(Side, 1, Z)
        
        If Side < 3 Then
        
            Y2 = LineList(Side + 1, 1, Z)
            X2 = LineList(Side + 1, 0, Z)
        Else
            Y2 = LineList(0, 1, Z)
            X2 = LineList(0, 0, Z)
        End If
        If X1 = 0 And X2 = 0 And Y1 = 0 And Y2 = 0 Then Exit Do
        Dim TopS As Single, BotS As Single, IY As Integer, IX As Integer
        
        If X1 <> X2 Then
            If X1 < X2 Then
                StepDir = 1
            Else
                StepDir = -1
            End If
            IY = Int(Y1)
            BotS = (Y1 - IY)
            TopS = 1 - BotS
            
            If Y1 <= UBFP2 Then
                
                If x = x Then
                    Dummy = AddFPX(UBFP1, StepDir, IY, CLng(X1), CLng(X2), TopS, BotS, FakePicture(0, 0))
                Else
                    For x = CLng(X1) To CLng(X2) Step StepDir
                        FakePicture(x, IY) = FakePicture(x, IY) + TopS
                        FakePicture(x, IY + 1) = FakePicture(x, IY + 1) + BotS
                    Next x
                End If
            End If
        ElseIf Y1 <> Y2 Then
            If Y1 < Y2 Then
                StepDir = 1
            Else
                StepDir = -1
            End If
            IX = Int(X1)
            BotS = (X1 - IX)
            TopS = 1 - BotS
            If x = x Then
                
                Dummy = AddFPY(UBFP1, StepDir, IX, CLng(Y1), CLng(Y2), TopS, BotS, FakePicture(0, 0))
            Else
                For Y = CLng(Y1) To CLng(Y2) Step StepDir
                    
                    FakePicture(IX, Y) = FakePicture(IX, Y) + TopS
                    FakePicture(IX + 1, Y) = FakePicture(IX + 1, Y) + BotS
                    
                Next Y
            End If
        End If
    Next Side
    
    Z = Z + 1
    If Z > UBound(LineList, 3) Then Exit Do
    
Loop

'find base-line - it'll be the highest Y value in every block

Dim MYV As Single

MYV = 0
Z = 1
For Side = 0 To 3
    
    If MYV < LineList(Side, 1, Z) Then MYV = LineList(Side, 1, Z)
    
Next Side

MYV = MYV - 1



Dim MaxV As Single
MaxV = MaxVGC
If ManFlag = 1 Then
    MaxV = 4
End If
If x = x Then
    'Dummy = ModFP(UBFP1, UBFP2, MaxV, FakePicture(0, 0))
    
    Dummy = ModFP(UBFP1, UBFP2, MaxV, FakePicture(0, 0))
    x = x
Else
    
    MaxV = 0
    For x = 0 To UBFP1
        For Y = 0 To MYV
            If MaxV < FakePicture(x, Y) Then MaxV = FakePicture(x, Y)
        Next Y
    Next x
    MaxV = 4
    For x = 0 To UBFP1
        For Y = 0 To UBFP2
            
            If FakePicture(x, Y) < MaxV Then
                FakePicture(x, Y) = FakePicture(x, Y) / MaxV
            Else
                FakePicture(x, Y) = 1
            End If
        Next Y
    Next x
End If



'GetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
Dim r As Long, g As Long, b As Long

r = Int(ColPix / 65536)
g = Int((ColPix - r * 65536) / 256)
b = Int((ColPix - r * 65536 - g * 256))
If r > 255 Then r = 255
If r < 0 Then r = 0
If g > 255 Then g = 255
If g < 0 Then g = 0
If b > 255 Then b = 255
If b < 0 Then b = 0
'For X = 0 To UBound(FakePicture, 1)

If x = x Then
    
    Dummy = MakeImageDataBO(r, g, b, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture(0, 0), ImageData(0, 0, 0))
Else
    For x = 0 To UBound(ImageData, 2)
        For Y = 0 To UBound(ImageData, 3)
            
            ImageData(0, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(0, x, Y) + r * FakePicture(x, Y))
            
            ImageData(1, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(1, x, Y) + g * FakePicture(x, Y))
            
            ImageData(2, x, Y) = CByte((1 - FakePicture(x, Y)) * ImageData(2, x, Y) + b * FakePicture(x, Y))
        Next Y
    Next x
End If
'Next X

'SetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
x = x

'    If X = 12345 Then
'        For X = 0 To UBound(ImageData, 2)
'            For Y = 0 To UBound(ImageData, 3)
'                ImageData(0, X, Y) = 255
'                ImageData(1, X, Y) = 255
'                ImageData(2, X, Y) = 255
'            Next Y
'        Next X
'
'    End If

End Sub
Public Sub DoLineObject(ImageData() As Byte, PB As PictureBox, LineList() As Single, ColPix As Long, Width As Byte, Opacity As Byte, ForcelargerX As Byte)
Dim Dummy As Long, Z As Long, x As Long, Y As Long, X3 As Single, Y3 As Single, Y1 As Single, Y2 As Single, X1 As Single, X2 As Single, M As Single, C As Single, UBFP1, UBFP2
Dim StepDir As Long, IY As Long, IX As Long, UBLL2 As Long, X4 As Single, Y4 As Single, Hold As Single, Hold2 As Single
Dim FakePicture() As Single
Dim BigNum As Single, SmallNum As Single
'Dim Forcelarger As Byte
'ForcelargerX = 1

UBFP1 = UBound(ImageData, 2) + 1 'bm.bmWidth
UBFP2 = UBound(ImageData, 3) + 1 'bm.Height
UBLL2 = UBound(LineList, 2)
ReDim FakePicture(UBFP1, UBFP2)


Z = 1 '

BigNum = 10 ^ 10
SmallNum = 0.0000000001

'Exit Sub
'ZZ = 0
If Opacity = 0 Then
    If x = x Then
    '@'@'@'@'@'@
        Dummy = DoAALineXY(UBFP1, UBFP2, UBound(LineList, 1), UBound(LineList, 2), FakePicture(0, 0), LineList(0, 0))
        x = x
    Else
        Do
    '        If Z >= 1644 Then
    '            X = X
    '        End If
            '@
            
            '@
            
            X1 = LineList(0, Z)
            
            X2 = LineList(0, Z + 1)
            
            If X2 >= X1 Then 'Or ForcelargerX = 0 Then
                
                Y1 = LineList(1, Z)
                If (X1 > 0 Or Y1 > 0) Then
                
                    '@
                    Y2 = LineList(1, Z + 1)
                    
                    If (X2 > 0 Or Y2 > 0) Then
                        '@
                        'Width = 2
                        If X2 <> X1 Then
                            M = (Y2 - Y1) / (X2 - X1)
                            'If M = 0 Then M = SmallNum
                        Else
                            M = BigNum
                        End If
                        
                        C = Y1 - M * X1
                        
                        If X1 >= X2 Then
                                
                        
                            X4 = X1
                            X1 = X2
                            X2 = X4
                        End If
                        
                        '@
                        If Y1 >= Y2 Then
                        
                            Y4 = Y1
                            Y1 = Y2
                            Y2 = Y4
                        End If
                        
                        'do the middle bits
                        
                        
                        If Abs((X1) - (X2)) >= Abs((Y1) - (Y2)) Then
                            
                            
                            
                            'If P7ZoomLevel < 10 Or X = X Then
                                '@
                                Dummy = DoAALineX(C, M, Y1, Y2, X1, X2, UBFP1, UBFP2, FakePicture(0, 0))
                                x = x
    '                        Else
    '                            Do
    '                            'For X = CLng(X1) To CLng(X2)
    '
    '                                If Y1 <> Y2 Then
    '                                    Y3 = M * X1 + C
    '                                Else
    '                                    Y3 = Y1
    '                                End If
    '                                If Y3 < UBFP2 Then
    '                                    X = CLng(X1)
    '                                    If X <= UBFP1 Then
    '                                        If (Y3 >= Y1 And Y3 <= Y2) Then
    '
    '                                            IY = Int(Y3)
    '
    '
    '                                            'If X < UBFP1 Then
    '                                                Hold2 = (Y3 - IY)
    '                                                Hold = 1 - Hold2
    '                                                If Hold > FakePicture(X, IY) Then FakePicture(X, IY) = Hold
    '                                                If Hold2 > FakePicture(X, IY + 1) Then FakePicture(X, IY + 1) = Hold2
    '                                            'End If
    '                                        End If
    '                                    End If
    '                                End If
    '                            'Next X
    '                                If X1 = X2 Then Exit Do
    '                                X1 = X1 + 0.5
    '
    '
    '
    '                                If X1 > X2 Then X1 = X2
    '
    '                            Loop
    '                        End If
                            
                        Else 'If (Y1) <> (Y2) Then 'If Abs(CLng(X1) - CLng(X2)) < Abs(CLng(Y1) - CLng(Y2)) Then
                            '@
                            If Y1 <> Y2 Then
                                '@
                              ' If P7ZoomLevel < 10 Or X = X Then
                                '@
                                    Dummy = DoAALineY(C, M, Y1, Y2, X1, X2, UBFP1, UBFP2, FakePicture(0, 0))
                                    x = x
    '                           Else
    '
    '
    '                                Do
    '                                    Y = CLng(Y1)
    '                                    If Y < UBFP2 Then
    '                                        If X1 <> X2 Then
    '                                            X3 = (Y1 - C) / M
    '                                        Else
    '                                            X3 = X1
    '                                        End If
    '                                        If X3 >= X1 Then
    '                                            If X3 <= X2 Then
    '                                                IX = Int(X3)
    '                                                If IX < UBFP1 Then
    '                                                    Hold2 = (X3 - IX)
    '                                                    Hold = 1 - Hold2
    '                                                    If Hold > FakePicture(IX, Y) Then FakePicture(IX, Y) = Hold
    '                                                    If Hold2 > FakePicture(IX + 1, Y) Then FakePicture(IX + 1, Y) = Hold2
    '                                                End If
    '                                            End If
    '                                        End If
    '                                    Else
    '                                        Exit Do
    '                                    End If
    '                                    If Y1 = Y2 Then Exit Do
    '                                    Y1 = Y1 + 0.5
    '                                    If Y1 > Y2 Then Y1 = Y2
    '                                Loop
    '                            End If
                                
                            End If
                        End If
                        'End If
                        
                        
                        
                        'y = m * x + c
                        'c = y - m * x : c = y1 - m * x1
                        'm = (y-c)/x
                        'm = (y2-y1)/(x2-x1)
                        'c = y1-(m*x1)
                        
                        'If LineList(1, Z + 1) = 0 And LineList(0, Z + 1) = 0 Then Exit Do
            '        Else
            '            ZZ = ZZ + 1
                    End If
                End If
            End If
            '@
            Z = Z + 1
            
            If Z > UBLL2 - 1 Then Exit Do
        Loop
    End If
    x = x
ElseIf Opacity = 1 Then
    
    Do
        
        Y1 = LineList(1, Z)
        Y2 = LineList(1, Z + 1)
        X1 = LineList(0, Z)
        X2 = LineList(0, Z + 1)
        If (X1 > 0 Or Y1 > 0) And (X2 > 0 Or Y2 > 0) And (X2 >= X1) Then
        
            'Width = 2
            If X2 <> X1 Then
                M = (Y2 - Y1) / (X2 - X1)
                'If M = 0 Then M = SmallNum
            Else
                M = BigNum
            End If
            
            C = Y1 - M * X1
            
            If X1 < X2 Then
                    
            Else
                X4 = X1
                X1 = X2
                X2 = X4
            End If
            
            
            If Y1 < Y2 Then
                    
            Else
                Y4 = Y1
                Y1 = Y2
                Y2 = Y4
            End If
            
            'do the middle bits
            
            
            If Abs((X1) - (X2)) >= Abs((Y1) - (Y2)) Then
                
                'If X = X Then
                    Dummy = DoAALineXT(C, M, Y1, Y2, X1, X2, UBFP1, UBFP2, FakePicture(0, 0))
'                Else
'
'                    Do
'                    'For X = CLng(X1) To CLng(X2)
'
'                        If Y1 <> Y2 Then
'                            Y3 = M * X1 + C
'                        Else
'                            Y3 = Y1
'                        End If
'                        X = CLng(X1)
'                        If (Y3 >= Y1 And Y3 <= Y2) Then
'                            IY = Int(Y3)
'
'                            If Y3 <= UBFP2 Then
'                                FakePicture(X, IY) = FakePicture(X, IY) + (1 - (Y3 - IY)) / 4
'                                FakePicture(X, IY + 1) = FakePicture(X, IY + 1) + ((Y3 - IY)) / 4
'                            End If
'                        End If
'                    'Next X
'                        X1 = X1 + 0.5
'                        If X1 > X2 Then Exit Do
'                    Loop
'                End If
            Else 'If (Y1) <> (Y2) Then 'If Abs(CLng(X1) - CLng(X2)) < Abs(CLng(Y1) - CLng(Y2)) Then
                
                If Y1 <> Y2 Then
                    
                    'If X = X Then
                        Dummy = DoAALineYT(C, M, Y1, Y2, X1, X2, UBFP1, UBFP2, FakePicture(0, 0))
                    
'                   Else
'
'                        Do
'                        'For Y = CLng(Y1) To CLng(Y2)
'                            Y = CLng(Y1)
'                            If X1 <> X2 Then
'                                X3 = (Y1 - C) / M
'                            Else
'                                X3 = X1
'                            End If
'                            If X3 >= X1 And X3 <= X2 Then
'                                IX = Int(X3)
'                                FakePicture(IX, Y) = FakePicture(IX, Y) + (1 - (X3 - IX)) / 4
'                                FakePicture(IX + 1, Y) = FakePicture(IX + 1, Y) + (X3 - IX) / 4
'                            End If
'                            Y1 = Y1 + 0.5
'                            If Y1 > Y2 Then Exit Do
'                        'Next Y
'                        Loop
'                    End If
                End If
            End If
            'End If
            
            
            
            'y = m * x + c
            'c = y - m * x : c = y1 - m * x1
            'm = (y-c)/x
            'm = (y2-y1)/(x2-x1)
            'c = y1-(m*x1)
            
            'If LineList(1, Z + 1) = 0 And LineList(0, Z + 1) = 0 Then Exit Do
        End If
        Z = Z + 1
        
        If Z > UBLL2 - 1 Then Exit Do
    Loop

End If

Dim MaxV As Single
If Opacity = 0 Then
    MaxV = 0
Else
    MaxV = 0.5
End If

'If X = X Then
    '@'@
    Dummy = ModFP(UBFP1, UBFP2, MaxV, FakePicture(0, 0))
    x = x
'Else
'    For X = 0 To UBound(FakePicture, 1)
'        For Y = 0 To UBound(FakePicture, 2)
'            If MaxV < FakePicture(X, Y) Then MaxV = FakePicture(X, Y)
'        Next Y
'    Next X
'    MaxV = MaxV / 2
'    For X = 0 To UBound(FakePicture, 1)
'        For Y = 0 To UBound(FakePicture, 2)
'            If FakePicture(X, Y) < MaxV Then
'                FakePicture(X, Y) = FakePicture(X, Y) / MaxV
'            Else
'                FakePicture(X, Y) = 1
'            End If
'        Next Y
'    Next X
'End If



'GetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
Dim r As Long, g As Long, b As Long

r = Int(ColPix / 65536)
g = Int((ColPix - r * 65536) / 256)
b = Int((ColPix - r * 65536 - g * 256))
If r > 255 Then r = 255
If r < 0 Then r = 0
If g > 255 Then g = 255
If g < 0 Then g = 0
If b > 255 Then b = 255
If b < 0 Then b = 0
'For X = 0 To UBound(FakePicture, 1)

'If X = X Then
    '@'@'@'@'@''@'@'@'@'@
    Dummy = MakeImageDataBO(r, g, b, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture(0, 0), ImageData(0, 0, 0))
    x = x
    'CycleCounterA = CycleCounterA + 1
'Else
'    For X = 0 To UBound(ImageData, 2)
'        For Y = 0 To UBound(ImageData, 3)
'            ImageData(0, X, Y) = CByte((1 - FakePicture(X, Y)) * ImageData(0, X, Y) + r * FakePicture(X, Y))
'            ImageData(1, X, Y) = CByte((1 - FakePicture(X, Y)) * ImageData(1, X, Y) + g * FakePicture(X, Y))
'            ImageData(2, X, Y) = CByte((1 - FakePicture(X, Y)) * ImageData(2, X, Y) + b * FakePicture(X, Y))
'        Next Y
'    Next X
'End If


'Dummy = MakeImageDataBO(R, G, B, UBound(FakePicture, 1), UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), FakePicture(0, 0), ImageData(0, 0, 0))


'Next X

'SetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)


'    If X = 12345 Then
'        For X = 0 To UBound(ImageData, 2)
'            For Y = 0 To UBound(ImageData, 3)
'                ImageData(0, X, Y) = 255
'                ImageData(1, X, Y) = 255
'                ImageData(2, X, Y) = 255
'            Next Y
'        Next X
'
'    End If


End Sub
Public Sub RedrawPlot(ClearScreenFlag As Long)
    Dim VOut As String
    
    Dim PolyPoints() As POINTAPI
    Dim Pen2 As Long, SP As Long, EP As Long
    Dim PColIn As Long, HFactor As Double, WFactor As Double
    Dim OldFont As Long, oldpen As Long, PEN As Long, LOffset As Long, TOffset As Long, MhDC As Long, EMFCls As Long
    Dim PntAPI As POINTAPI
    Dim LPn As LOGPEN
    Dim red As Long, Green2 As Long, blue As Long, PA As POINTAPI
    ReDim FakeP7(Form1.Picture7.ScaleWidth, Form1.Picture7.ScaleHeight, 2)
    'LPn.lopnColor = RGB(255, 0, 0)
    'LPn.lopnWidth.XPos = 5
    'LPn.lopnWidth.Y = 5
    'LPn.lopnStyle = 0
    
    'GetObject Drawbox.Image, Len(bm), bm
'    ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
'    If X = 12345 Then
'        For X = 0 To UBound(ImageData, 2)
'            For Y = 0 To UBound(ImageData, 3)
'                ImageData(0, X, Y) = 255
'                ImageData(1, X, Y) = 255
'                ImageData(2, X, Y) = 255
'            Next Y
'        Next X
'
'    End If
    
    
    If CurrentCheck = 40 Or CurrentCheck = 41 Or CurrentCheck = 11 Then
        Exit Sub
    End If
    PA.x = 0.75
    PA.Y = 0.75
    Dim rct As RECT
    Dim LoFnt As Long
                
    Dim AxLen As Long, AxStr As String
    
    If TypeSeqNumber > NextNo Then TypeSeqNumber = 0
    AxLen = GYAxHi(1)
    If AxLen = 0 Then Exit Sub
    Dim DF As Byte
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UBX = 0
    UBX = UBound(GVarPos, 2)
    UBY = UBound(GVarPos, 1)
    
    On Error GoTo 0
    
    If UBX > 0 Then
        If XX = XX Then
            DF = 1
        Else
            DF = 0
        End If
    Else
        DF = 0
    End If
    ReDim XDiffPos(Len(StrainSeq(0)))
    If UBX > 0 And UBY = 0 Then
        For x = 0 To UBX
            XDiffPos(x) = GVarPos(0, x)
        Next x
        
    End If
    LenXoverSeq = UBX
   ' Form1.SSPanel8.Visible = True
    
    If ClearScreenFlag = 1 Then
        If GYAxHi(1) <> Decompress(Len(StrainSeq(0))) Then
            
            Call DoAxes(0, 1, GYAxHi(1), -1, GPrintMin(1), GPrintMin(0), DF, GLegend)
            XFactor = ((Form1.Picture7.Width - 40) / GYAxHi(1))
        Else
            
            Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, GPrintMin(1), GPrintMin(0), DF, GLegend)
            XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
        End If
    Else
         XFactor = ((Form1.Picture7.Width - 40) / Decompress(GYAxHi(1)))
    End If
    
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    HFactor = PicHeight
   
    LOffset = 30
    TOffset = 10

    'xFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    WFactor = XFactor
    'Draw Axes
    
 
    
    
        
    'Draw variable site positions
    MhDC = Form1.Picture7.hdc
    
    
    Dim LongTXT As Long
    LongTXT = 0
    Dim LPX As Long, TOX As String
    LPX = -15
    'HLFlag
    If GBlockNum > -1 Then
        ColHL = RGB(0, 255, 255)
        
        
        For x = 0 To GBlockNum
            
            If GBlock(4, x) = RGB(255, 190, 190) Or GBlock(4, x) = RGB(255, 210, 210) Then
                Form1.Picture7.ForeColor = ColHL
                Form1.Picture7.FillColor = ColHL
                Form1.Picture7.DrawMode = 12
                YPos = TOffset
            ElseIf GBlock(4, x) = RGB(197, 197, 255) Then
                YPos = TOffset
                Form1.Picture7.DrawMode = 13
                Form1.Picture7.ForeColor = GBlock(4, x)
                Form1.Picture7.FillColor = GBlock(4, x)
            Else
                YPos = TOffset + 10
                Form1.Picture7.DrawMode = 13
                Form1.Picture7.ForeColor = GBlock(4, x)
                Form1.Picture7.FillColor = GBlock(4, x)
            End If
            Form1.Picture7.FillStyle = 0
            
            If GBlock(1, x) = 0 Then 'ie it is a block on the plot
                If Form1.Picture7.ForeColor = ColHL Then
                    If GBlock(0, x) = 1 Then
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, LOffset + Decompress(GBlock(2, x)) * XFactor, PicHeight - 15 + 10)
                        Dummy = MoveToEx(MhDC, LOffset + Decompress(GBlock(2, x)) * XFactor, PicHeight - 15, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, YPos + 10, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)

                    ElseIf GBlock(2, x) = Len(StrainSeq(0)) Then
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, LOffset + Decompress(GBlock(2, x)) * XFactor, PicHeight - 15 + 10)
                        Dummy = MoveToEx(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, YPos)
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, YPos + 10, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)

                    Else
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, LOffset + Decompress(GBlock(2, x)) * XFactor, PicHeight - 15 + 10)
                        Dummy = MoveToEx(MhDC, LOffset + Decompress(GBlock(2, x)) * XFactor, PicHeight - 15, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)
                        Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, YPos + 10, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)
                        Dummy = MoveToEx(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, YPos)
                    End If
                Else
                    Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * XFactor, PicHeight - 15, LOffset + Decompress(GBlock(2, x)) * XFactor, YPos)
                End If
            ElseIf GBlock(1, x) = 1 Then 'ie it is a block on the plot
                
            ElseIf GBlock(1, x) = 2 Then 'ie it is a block on the plot
                
            ElseIf GBlock(1, x) = 3 Then 'ie it is a query sequence reference
                
            End If
            
            Form1.Picture7.DrawMode = 13
        Next x
        
         
    End If

    
    Dim tGCritVal() As Double
    ReDim tGCritVal(10)
    If GExtraTNum > -1 Or GBlockNum > -1 Or GCritval(0) > 0 Then
        For x = 0 To UBound(GCritval, 1)
            If GCritval(x) <> 0 Then
                
                
                tGCritVal(x) = GCritval(x)
                
                
            End If
        Next x
        
    End If
    Form1.Picture7.DrawMode = 13
    Form1.Picture7.ForeColor = 0
    For x = 0 To 10
        If tGCritVal(x) <> 0 Then
        'Draw critical val co
            
            If x = 0 Then
                Form1.Picture7.DrawStyle = 2
            ElseIf x = 1 Then
                Form1.Picture7.DrawStyle = 2
            ElseIf x = 2 Then
                Form1.Picture7.DrawStyle = 2
            ElseIf x = 3 Then
                Form1.Picture7.DrawStyle = 2
            ElseIf x = 4 Then
                Form1.Picture7.DrawStyle = 2
            ElseIf x = 5 Then
                Form1.Picture7.DrawStyle = 2
            End If
           

            'If COff <= GCritval(X) Then
                If tGCritVal(x) <= GPrintMin(0) And tGCritVal(x) >= GPrintMin(1) Then
                    MoveToEx MhDC, LOffset - 5, PicHeight - (15 + ((tGCritVal(x) - GPrintMin(0)) / (GPrintMin(1) - GPrintMin(0))) * (PicHeight - 35)), PntAPI
                    LineTo MhDC, LOffset + AxLen * WFactor, PicHeight - (15 + ((tGCritVal(x) - GPrintMin(0)) / (GPrintMin(1) - GPrintMin(0))) * (PicHeight - 35))
                End If
            'End If
        End If
    Next x
    Form1.Picture7.DrawStyle = 0
        
    If GPrintType = 0 Then 'standard line plot
        Dim OriMod1 As Long, OriMod2 As Long, DiX As Double
        If GPrintMin(0) > GPrintMin(1) Then
            OriMod1 = 0
            OriMod2 = -1
            DixA = GPrintMin(0)
            DixB = GPrintMin(1)
        Else
            OriMod1 = 1
            OriMod2 = 1
            DixA = GPrintMin(1)
            DixB = GPrintMin(0)
        End If
        If DixA = 0 And DixB = 0 Then
            DixA = 0
            DixB = 1
        End If
        For Z = GPrintNum To 0 Step -1
            'Test if its a line
            FirstPos = 0: LastPos = GPrintLen
            For Y = 1 To GPrintLen
                If GPrintPos(Z, Y) > 0 Then
                    FirstPos = Y
                    Exit For
                End If
            Next Y
            For Y = GPrintLen To 0 Step -1
                If GPrintPos(Z, Y) > 0 Then
                    LastPos = Y
                    Exit For
                End If
            Next Y
            
          
            If (GPrintPos(Z, FirstPos) <> GPrintPos(Z, LastPos) And (GPrintPos(Z, LastPos) - GPrintPos(Z, FirstPos)) > 1) Or GPrintCol(Z) = 0 Then 'i.e. its a normal plot
            
                
                If ManFlag = -1 And (CurrentCheck = 5 Or (CurrentCheck = -1 And XoverList(RelX, RelY).ProgramFlag = 5)) Then  'have to do something different for siscan
                    If Z = 4 Or Z = 9 Or Z = 17 Or Z = 21 Then
                        Form1.Picture7.ForeColor = GPrintCol(4) 'mPurple 'green'
                    ElseIf Z = 1 Or Z = 7 Or Z = 15 Or Z = 18 Then
                        Form1.Picture7.ForeColor = GPrintCol(1) ' green 'mPurple
                    ElseIf Z = 2 Or Z = 8 Or Z = 16 Or Z = 19 Then
                        Form1.Picture7.ForeColor = GPrintCol(2) 'mYellow
                    Else
                        Form1.Picture7.ForeColor = RGB(240, 240, 240) 'GPrintCol(Z)
                    End If
                Else
                    Form1.Picture7.ForeColor = GPrintCol(Z)
                End If
                
                'If Z = 9 Then
                '    LPn.lopnColor = RGB(255, 0, 0)
                'End If
                'Dim LineSet() As Single
                'ReDim LineSet(UBound(GPrintPos, 2), 1)
                Y = 1
                Do
                    If GPrintPos(Z, Y) > 0 Then
                        Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, PicHeight - (15 + ((OriMod2 * GPrint(Z, Y) - DixB) / (DixA - DixB)) * (PicHeight - 35)), PntAPI)
                        Exit Do
                        
                    End If
                    Y = Y + 1
                    
                    If Y > UBound(GPrintPos, 2) Then
                        Y = Y - 1
                        Exit Do
                    End If
                Loop
                For PosCount = Y To GPrintLen
         
                    If GPrintPos(Z, PosCount) > 0 Then  'And ((OriMod1 = 1 And GPrint(Z, PosCount) >= GPrintMin(0) And (GPrint(Z, PosCount) <= GPrintMin(1) * 1.1)) Or (OriMod1 = 0 And GPrint(Z, PosCount) <= GPrintMin(0) And GPrint(Z, PosCount) >= GPrintMin(1))) Then
                     
                        If (OriMod1 = 1) Then
                          If GPrint(Z, PosCount) < GPrintMin(0) Then
                                GPrint(Z, PosCount) = GPrintMin(0)
                           ElseIf GPrint(Z, PosCount) > GPrintMin(1) Then
                                GPrint(Z, PosCount) = GPrintMin(1)
                           End If
                        ElseIf OriMod1 = 0 Then
                          If (OriMod2 * GPrint(Z, PosCount)) > (GPrintMin(0)) Then
                              GPrint(Z, PosCount) = (GPrintMin(0))
                          ElseIf (OriMod2 * GPrint(Z, PosCount)) < (GPrintMin(1)) Then
                              GPrint(Z, PosCount) = (GPrintMin(1))
                          End If
                        
                        End If
                        If GPrintPos(Z, PosCount) <= UBound(Decompress) Then
                            Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, PicHeight - (15 + ((OriMod2 * GPrint(Z, PosCount) - DixB) / (DixA - DixB)) * (PicHeight - 35)))
                        End If
                    End If
                    
                Next PosCount
                
              
            Else ' i.e. its a polygon that needs to be filled
           
                
                              
                
                Form1.Picture7.ForeColor = GPrintCol(Z)
                If GPrintCol(Z) = RGB(128, 128, 128) Then
                    Form1.Picture7.ForeColor = RGB(130, 130, 130)
                    Form1.Picture7.FillColor = RGB(150, 150, 150) 'HalfColour
                ElseIf GPrintCol(Z) = RGB(198, 198, 198) Then
                    Form1.Picture7.ForeColor = RGB(200, 200, 200)
                    Form1.Picture7.FillColor = RGB(255, 255, 255)
                End If
                Form1.Picture7.FillStyle = 0
                
                
               MhDC = Form1.Picture7.hdc
                
               
                
                ReDim PolyPoints(GPrintLen - 1)
                A = -1
                For PosCount = 1 To GPrintLen
                        If GPrintPos(Z, PosCount) > 0 Then
                            GoOn = 0
                            If PosCount > 0 Then
                                If (CLng(LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor) <> CLng(LOffset + Decompress(GPrintPos(Z, PosCount - 1)) * WFactor)) Or (CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor) <> CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount - 1) - DixB) / (DixA - DixB))) * HFactor)) Then
                                GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            If GoOn = 1 Then
                                A = A + 1
                                PolyPoints(A).x = LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor
                                PolyPoints(A).Y = PicHeight - (15 + ((GPrint(Z, PosCount) - DixB) / (DixA - DixB)) * (PicHeight - 35))
                            End If
                            x = x
                        End If
                Next PosCount
                
                'PolyPoints(0).X = 100
                'PolyPoints(0).Y = 100
                'PolyPoints(1).X = 200
                'PolyPoints(1).Y = 100
                'PolyPoints(2).X = 200
                'PolyPoints(2).X = 200
                'PolyPoints(3).X = 100
                'PolyPoints(3).Y = 100
               'ReDim Preserve PolyPoints(A)
               If A < 16000 And A > 0 Then ' for some reason ppt crashes if you give it a polygon with >16000 points
                    Polygon MhDC, PolyPoints(0), A
               Else
                    ReDim PolyPoints(GPrintLen - 1)
                    Dim SkipFact As Double
                    SkipFact = CLng(A / 16000) + 1
                    ReDim PolyPoints(GPrintLen - 1)
                     A = -1
                     For PosCount = 0 To GPrintLen Step SkipFact
                             If GPrintPos(Z, PosCount) > 0 Then
                                 GoOn = 0
                                 If PosCount > 0 Then
                                     If (CLng(LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor) <> CLng(LOffset + Decompress(GPrintPos(Z, PosCount - 1) * WFactor))) Or (CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor) <> CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount - 1) - DixB) / (DixA - DixB))) * HFactor)) Then
                                     GoOn = 1
                                     End If
                                 Else
                                     GoOn = 1
                                 End If
                                 If GoOn = 1 Then
                                     A = A + 1
                                     PolyPoints(A).x = LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor
                                     PolyPoints(A).Y = PicHeight - (15 + ((GPrint(Z, PosCount) - DixB) / (DixA - DixB)) * (PicHeight - 35))
                                     'PicHeight - (15 + ((GPrint(Z, PosCount) - dixb) / (DiXA - dixb)) * (PicHeight - 35))
                                 End If
                                 x = x
                             End If
                     Next PosCount
                     
                     'PolyPoints(0).X = 100
                     'PolyPoints(0).Y = 100
                     'PolyPoints(1).X = 200
                     'PolyPoints(1).Y = 100
                     'PolyPoints(2).X = 200
                     'PolyPoints(2).X = 200
                     'PolyPoints(3).X = 100
                     'PolyPoints(3).Y = 100
                    'ReDim Preserve PolyPoints(A)
                    Polygon MhDC, PolyPoints(0), A
                End If
            
            End If
        Next Z
        
        x = x
    ElseIf GPrintType = 1 Then 'blocks like in geneconv plot
        SS = Abs(GetTickCount)
        For AAA = 1 To 1
        For Z = 0 To GPrintNum
            
            
            Form1.Picture7.ForeColor = GPrintCol(Z)
            
            For PosCount = 0 To GPrintLen
                If PosCount <= UBound(GPrintPos, 3) Then
                    
                
                    If PosCount > 0 And Decompress(GPrintPos(Z, 1, PosCount)) = 0 Then Exit For
                    Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, PicHeight - (15 + ((GPrint(Z, PosCount) / GPrintMin(1))) * (PicHeight - 35)), PntAPI)
                    Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 1, PosCount)) * WFactor, PicHeight - (15 + ((GPrint(Z, PosCount) / GPrintMin(1))) * (PicHeight - 35)))
                    Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 1, PosCount)) * WFactor, PicHeight - (15 + ((GPrintMin(0) / GPrintMin(1))) * (PicHeight - 35)))
                    Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, PicHeight - (15 + ((GPrintMin(0) / GPrintMin(1))) * (PicHeight - 35)))
                    Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, PicHeight - (15 + ((GPrint(Z, PosCount) / GPrintMin(1))) * (PicHeight - 35)))
                'PicHeight - (15 + ((GPrint(Z, PosCount) - dixb) / (DiXA - dixb)) * (PicHeight - 35))
                End If
            Next PosCount
            
            
        Next Z
        Next AAA
        EE = Abs(GetTickCount)
        TT = EE - SS
        x = x
    End If
    'XX = Form1.Picture7.FillStyle
    Form1.Picture7.FillStyle = 1
    
    If ManFlag = -1 Then
        Dim TraceSub() As Long
        
        If CurrentCheck > -1 Then
            If CurrentCheck = 10 Or CurrentCheck = 16 Or CurrentCheck = 13 Then 'chimaera, 3seq and phylpro
                
                Call WriteNames2(WN1, WN2, WN3, GPrintCol(0), GPrintCol(1), GPrintCol(2))
                'Call WriteNames2(WN1, WN2, WN3, GPrintCol(0), GPrintCol(1), GPrintCol(2))
            ElseIf CurrentCheck = 5 Then
                
                ReDim TraceSub(NextNo)
                For x = 0 To NextNo
                    TraceSub(x) = x
                Next x
                
                Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
            ElseIf CurrentCheck = 55 Or CurrentCheck = 6 Or CurrentCheck = 9 Or CurrentCheck = 12 Or CurrentCheck = 15 Or CurrentCheck = 17 Then
            
            Else
                Call WriteNames(WN1, WN2, WN3, GPrintCol(0), GPrintCol(1), GPrintCol(2))
            End If
        Else
            If XoverList(RelX, RelY).ProgramFlag = 5 Then
                ReDim TraceSub(NextNo)
                For x = 0 To NextNo
                    TraceSub(x) = x
                Next x
                Call OrderSeqs(tSeq1, tSeq2, tSeq3, Seq1, Seq2, Seq3, TraceSub())
                Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
            ElseIf XoverList(RelX, RelY).ProgramFlag = 4 And XoverList(RelX, RelY).ProgramFlag = 7 Then
                Call WriteNames2(WN1, WN2, WN3, GPrintCol(0), GPrintCol(1), GPrintCol(2))
            ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Then
                
            ElseIf XoverList(RelX, RelY).ProgramFlag <> 4 Then
                Call WriteNames(WN1, WN2, WN3, GPrintCol(0), GPrintCol(1), GPrintCol(2))
            
            End If
        
        End If
    End If
   
    If CurrentCheck = 5 Or (CurrentCheck = -1 And XoverList(RelX, RelY).ProgramFlag = 5) Then 'need to keep a backup image of the siscan plot
        Form1.Picture21.Picture = LoadPicture()
        Form1.Picture21.Width = Form1.Picture7.Width + 100
        Form1.Picture21.Height = Form1.Picture7.Height + 100
        Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
        
        'Form1.SSPanel8.Visible = True
        'Form1.Picture21.Left = -100
        'Form1.Picture21.Visible = True
        'Form1.Picture21.ZOrder
        'If Form1.Picture21.Width < 800 Then
        '    X = X
        'End If
   End If
   
   x = x
   Exit Sub
    
    LoFnt = CreateFont(14, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    'TOffset -6 + HFactor
    
    YC = TOffset - 6 + (HFactor / 4) * 3 + (Len(GLegend) - 16) * 3 '17=5.7; 21=4.2; 16 =6.2
    
    'YC = TOffset + ((HFactor - (Len(GLegend) * 100 / Len(GLegend))) / 2) * 3
    
    TextOut MhDC, LOffset - 70, YC, GLegend, Len(GLegend)
    On Error GoTo 0

    'Clear up and close  emf
    PEN = SelectObject(MhDC, oldpen)
    DeleteObject (PEN)
    
    
    Brush = SelectObject(MhDC, OldBrush)
    DeleteObject (Brush)
            

    
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject (LoFnt)
    
    
    
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    
    
    
    If CopyFlag = 1 Then
        Clipboard.Clear
        If DebuggingFlag < 2 Then On Error Resume Next
        Clipboard.SetData LoadPicture("tmp2.emf"), 3
        
        KillFile "tmp2.emf"
        On Error GoTo 0
    End If

End Sub

Public Sub MakeRecombinationInfo(RecSeq As Long, PAVal As Long)
Dim OY As Long, YOff As Long, CurMCCorrection As Long, Px As Long, PY As Long, BEW As Byte, ENW As Byte
    Dim P1 As String, P2 As String, P3 As String, P4 As String, P5 As String, P6 As String, BPos As Long, Epos As Long, SEN As Long
 PRFlag = XoverList(RecSeq, PAVal).ProgramFlag
 If PRFlag > AddNum - 1 Then PRFlag = PRFlag - AddNum
 Form1.Picture2.ForeColor = 0
 Form1.Picture2.BackColor = BackColours + 65793 * 10
 If Form1.Picture2.Height < 15000 Then Form1.Picture2.Height = 15000
 Form1.SSPanel16.BackColor = ProgColour(PRFlag)
 Form1.SSPanel16.ForeColor = Form1.BackColor
 Form1.SSPanel16.FontSize = 13
 Form1.SSPanel16.Font.Bold = True

 
 SEN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
 
 If SEN > UBound(YannWarn, 1) Then
    ReDim Preserve YannWarn(SEN + 10)
 End If
 Form1.SSPanel16.Caption = ProgNames(PRFlag) + ":Event " + Trim(Str(SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)))
 'If PRFlag = 0 Then
 '    form1.SSPanel16.Caption = "RDP"
 'ElseIf PRFlag = 1 Then
 '    form1.SSPanel16.Caption = "GENECONV"
 'ElseIf PRFlag = 2 Then
 '    form1.SSPanel16.Caption = "BOOTSCAN"
 'ElseIf PRFlag = 3 Then
 '    form1.SSPanel16.Caption = "MAXCHI"
 'ElseIf PRFlag = 4 Then
 '    form1.SSPanel16.Caption = "CHIMAERA"
 'ElseIf PRFlag = 5 Then
 '    form1.SSPanel16.Caption = "SISCAN"
 'ElseIf PRFlag = 6 Then
 '    form1.SSPanel16.Caption = "PHYLPRO"
 'ElseIf PRFlag = 7 Then
 '    form1.SSPanel16.Caption = "LARD"
 'End If

 
 
 If XoverList(RecSeq, PAVal).ProgramFlag <> 3 Or (XoverList(RecSeq, PAVal).ProgramFlag = 3 And MCTripletFlag = 0) Then
     CurMCCorrection = MCCorrection
 ElseIf XoverList(RecSeq, PAVal).ProgramFlag = 6 Then
     CurMCCorrection = NextNo + 1
 Else
     CurMCCorrection = MCCorrect
 End If
 Form1.Picture2.CurrentY = 2
 PAValX = PAVal
 RecSeqX = RecSeq
 'If RunFlag = 0 Then X = Px: y = PY: Exit Sub
 RunFlag = 1
  EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
 XOS = 2
 
 If EN = 0 Then
     Exit Sub
 End If
 Form1.Picture2.FontBold = True
 'Picture6.FontBold = True
 Form1.Picture2.CurrentX = XOS
 If XoverList(RecSeq, PAVal).Ending < 1 Then XoverList(RecSeq, PAVal).Ending = Len(StrainSeq(0)) + XoverList(RecSeq, PAVal).Ending
 If ReassortmentFlag = 1 Then
     
     
     If UBound(RBPPos, 1) < RBPNum Then
         ReDim Preserve RBPPos(RBPNum)
     End If
     Dim Segbound() As Byte
     ReDim Segbound(Len(StrainSeq(0)))
     For x = 0 To RBPNum
         'XX = UBound(RBPPos, 1)
         tBP = RBPPos(x)
         Segbound(RBPPos(x)) = 1
     Next x
     EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
     If EN > 0 Then
         If Segbound(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Beginning) = 1 Then
             Form1.Picture2.Print "EVENT NUMBER " & Trim(Str(EN)) & " (PROBABLE REASSORTMENT)"
         Else
             Form1.Picture2.Print "EVENT NUMBER " & Trim(Str(EN)) & " (PROBABLE RECOMBINATION)"
         End If
     Else
         If Segbound(XoverList(RecSeq, PAVal).Ending) = 1 Or Segbound(XoverList(RecSeq, PAVal).Beginning) = 1 Then
             Form1.Picture2.Print "EVENT NUMBER " & Trim(Str(EN)) & " (PROBABLE REASSORTMENT)"
         Else
             Form1.Picture2.Print "EVENT NUMBER " & Trim(Str(EN)) & " (PROBABLE RECOMBINATION)"
         End If
     End If
 Else
     Form1.Picture2.Print "RECOMBINATION EVENT NUMBER " & Trim(Str(EN)) '(XOverList(RecSeq, PAVal).Beginning - SeqSpaces(XOverList(RecSeq, PAVal).Beginning, RecSeq)) & " (" & XOverList(RecSeq, PAVal).Beginning & ")"
 End If
 Form1.Picture2.FontBold = False
 'Picture6.FontBold = False

 cy = Form1.Picture2.CurrentY
 Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 48), BackColours, BF
 
 Form1.Picture2.CurrentY = cy
 
 'retreave BP confidence intervals

 EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
 
 If (ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210) And EN <= UBound(BPCIs, 2) Then
     bb1 = Abs(BPCIs(0, EN))
     ee1 = Abs(BPCIs(1, EN))
     bb2 = Abs(BPCIs(3, EN))
     ee2 = Abs(BPCIs(4, EN))
 Else
     bb1 = 0
     ee1 = 0
     bb2 = 0
     ee2 = 0
 End If
 
 Dim SSVal(6) As Long
 If SeqSpacesInFileFlag = 0 Then
     SSVal(0) = SeqSpaces(XoverList(RecSeq, PAVal).Beginning, RecSeq)
     SSVal(1) = SeqSpaces(bb1, RecSeq)
     SSVal(2) = SeqSpaces(ee1, RecSeq)
     SSVal(3) = SeqSpaces(XoverList(RecSeq, PAVal).Ending, RecSeq)
     SSVal(4) = SeqSpaces(bb2, RecSeq)
     SSVal(5) = SeqSpaces(ee2, RecSeq)
 Else
     '****************************
     'Better to read just single value from the file
     '*******************************
     'ReDim SeqSpaces(Len(StrainSeq(0)) + 2, Nextno)
     oDirX = CurDir
     ChDrive App.Path
     ChDir App.Path
     FF = FreeFile
     Dim OS1 As Long
     OS1 = RecSeq * (Len(StrainSeq(0)) + 3)
     Open "RDP5SSFile" + UFTag For Binary As #FF
     'SSVal(0) = SeqSpaces(XOverlist(RecSeq, PAVal).Beginning, RecSeq)
     Get #FF, (((XoverList(RecSeq, PAVal).Beginning + OS1) - 1) * 4) + 1, SSVal(0)
     If bb1 > 0 Then
     'SSVal(1) = SeqSpaces(bb1, RecSeq)
        Get #FF, (((bb1 + OS1) - 1) * 4) + 1, SSVal(1)
     Else
        SSVal(1) = 0
     End If
     'SSVal(2) = SeqSpaces(ee1, RecSeq)
     If ee1 > 0 Then
        Get #FF, (((ee1 + OS1) - 1) * 4) + 1, SSVal(2)
    Else
        SSVal(2) = 0
     End If
     'SSVal(3) = SeqSpaces(XOverlist(RecSeq, PAVal).Ending, RecSeq)
     
        Get #FF, (((XoverList(RecSeq, PAVal).Ending + OS1) - 1) * 4) + 1, SSVal(3)
     If bb2 > 0 Then
        'SSVal(4) = SeqSpaces(bb2, RecSeq)
        Get #FF, (((bb2 + OS1) - 1) * 4) + 1, SSVal(4)
     Else
        SSVal(4) = 0
     End If
     'SSVal(5) = SeqSpaces(ee3, RecSeq)
     If ee2 > 0 Then
        Get #FF, (((ee2 + OS1) - 1) * 4) + 1, SSVal(5)
     Else
        SSVal(5) = 0
     End If
     Close #FF
     ChDrive oDirX
     ChDir oDirX
     
     
 End If
 
 If XoverList(RecSeq, PAVal).SBPFlag = 0 Then
     If RecSeq = RelX And PAVal = RelY And Pic7BBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Beginning breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Beginning) & " in alignment"
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     
         
     End If
     Form1.Picture2.CurrentX = XOS
     
     
     Form1.Picture2.Print "Beginning breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Beginning) & " in alignment (" & Decompress(XoverList(RecSeq, PAVal).Beginning) - SSVal(0) & " without gaps)"
     Form1.Picture2.CurrentX = XOS
     If bb1 <= UBound(Decompress, 1) Then
        If bb1 <> ee1 Then
            Form1.Picture2.Print "Beginning breakpoint 99% CI: " & Decompress(bb1) & " - " & Decompress(ee1) & " in alignment (" & Decompress(bb1) - SSVal(1) & " - " & Decompress(ee1) - SSVal(2) & " without gaps)"
        Else
            Form1.Picture2.Print "Beginning breakpoint 99% CI: Undetermined"
        End If
     End If
     
     If RecSeq = RelX And PAVal = RelY And Pic7EBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Ending breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Ending) & " in alignment "
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     End If
     
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Ending breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Ending) & " in alignment (" & Decompress(XoverList(RecSeq, PAVal).Ending) - SSVal(3) & " without gaps)"
     Form1.Picture2.CurrentX = XOS
     If bb2 <> ee2 Then
         Form1.Picture2.Print "Ending breakpoint 99% CI: " & Decompress(bb2) & " - " & Decompress(ee2) & " in alignment (" & (Decompress(bb2) - SSVal(4)) & " - " & (Decompress(ee2) - SSVal(5)) & " without gaps)"
     Else
         Form1.Picture2.Print "Ending breakpoint 99% CI: Undetermined"
     End If
     x = x
 ElseIf XoverList(RecSeq, PAVal).SBPFlag = 1 Then
     If RecSeq = RelX And PAVal = RelY And Pic7BBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Beginning breakpoint: Undetermined  " & Decompress(XoverList(RecSeq, PAVal).Beginning)
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     
         
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Beginning breakpoint: Undetermined (" & Decompress(XoverList(RecSeq, PAVal).Beginning) & " [position " & Decompress(XoverList(RecSeq, PAVal).Beginning) - SSVal(0) & " without gaps])"
     Form1.Picture2.CurrentX = XOS
     If bb1 <> ee1 Then
         Form1.Picture2.Print "Beginning breakpoint 99% CI: " & Decompress(bb1) & " - " & Decompress(ee1) & " in alignment (" & Decompress(bb1) - SSVal(1) & " - " & Decompress(ee1) - SSVal(2) & " without gaps)"
     Else
         Form1.Picture2.Print "Beginning breakpoint 99% CI: Undetermined"
     End If
     
     If RecSeq = RelX And PAVal = RelY And Pic7EBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Ending breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Ending) & " in alignment"
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Ending breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Ending) & " in alignment (" & Decompress(XoverList(RecSeq, PAVal).Ending) - SSVal(3) & " without gaps)"
     Form1.Picture2.CurrentX = XOS
     If bb2 <> ee2 Then
         Form1.Picture2.Print "Ending breakpoint 99% CI: " & Decompress(bb2) & " - " & Decompress(ee2) & " in alignment (" & Decompress(bb2) - SSVal(4) & " - " & Decompress(ee2) - SSVal(5) & " without gaps)"
     Else
         Form1.Picture2.Print "Ending breakpoint 99% CI: Undetermined"
     End If
 ElseIf XoverList(RecSeq, PAVal).SBPFlag = 2 Then
     If RecSeq = RelX And PAVal = RelY And Pic7BBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Beginning breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Beginning) & " in alignment"
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     
         
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Beginning breakpoint: " & Decompress(XoverList(RecSeq, PAVal).Beginning) & " in alignment (" & Decompress(XoverList(RecSeq, PAVal).Beginning) - SSVal(0) & " without gaps)"
     Form1.Picture2.CurrentX = XOS
     If bb1 <> ee1 Then
         Form1.Picture2.Print "Beginning breakpoint 99% CI: " & Decompress(bb1) & " - " & Decompress(ee1) & " in alignment (" & Decompress(bb1) - SSVal(1) & " - " & Decompress(ee1) - SSVal(2) & " without gaps)"
     Else
         Form1.Picture2.Print "Beginning breakpoint 99% CI: Undetermined"
     End If
     If RecSeq = RelX And PAVal = RelY And Pic7EBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Ending breakpoint: Undetermined (" & Decompress(XoverList(RecSeq, PAVal).Ending) & ")"
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Ending breakpoint: Undetermined (" & Decompress(XoverList(RecSeq, PAVal).Ending) & " [position " & Decompress(XoverList(RecSeq, PAVal).Ending) - SSVal(3) & " without gaps])"
     Form1.Picture2.CurrentX = XOS
     If bb2 <> ee2 Then
         Form1.Picture2.Print "Ending breakpoint 99% CI: " & Decompress(bb2) & " - " & Decompress(ee2) & " in alignment (" & Decompress(bb2) - SSVal(4) & " - " & Decompress(ee2) - SSVal(5) & " without gaps)"
     Else
         Form1.Picture2.Print "Ending breakpoint 99% CI: Undetermined"
     End If
 ElseIf XoverList(RecSeq, PAVal).SBPFlag = 3 Then
     If RecSeq = RelX And PAVal = RelY And Pic7BBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Beginning breakpoint: Undetermined  " & Decompress(XoverList(RecSeq, PAVal).Beginning)
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Beginning breakpoint: Undetermined (" & Decompress(XoverList(RecSeq, PAVal).Beginning) & " [position " & Decompress(XoverList(RecSeq, PAVal).Beginning) - SSVal(0) & " without gaps])"
     Form1.Picture2.CurrentX = XOS
     If bb1 <> ee1 Then
         Form1.Picture2.Print "Beginning breakpoint 99% CI: " & Decompress(bb1) & " - " & Decompress(ee1) & " in alignment (" & Decompress(bb1) - SSVal(1) & " - " & Decompress(ee1) - SSVal(2) & " without gaps)"
     Else
         Form1.Picture2.Print "Beginning breakpoint 99% CI: Undetermined"
     End If
     If RecSeq = RelX And PAVal = RelY And Pic7EBFlag = 1 Then
         cy = Form1.Picture2.CurrentY
         Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 1
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.ForeColor = RGB(255, 196, 196)
         
         Form1.Picture2.DrawMode = 12
         
         Form1.Picture2.Print "Ending breakpoint: Undetermined  " & Decompress(XoverList(RecSeq, PAVal).Ending)
         Form1.Picture2.DrawMode = 13
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentY = cy
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Ending breakpoint: Undetermined (" & Decompress(XoverList(RecSeq, PAVal).Ending) & " [position " & Decompress(XoverList(RecSeq, PAVal).Ending) - SSVal(3) & " without gaps])"
     Form1.Picture2.CurrentX = XOS
     If bb2 <> ee2 Then
         Form1.Picture2.Print "Ending breakpoint 99% CI: " & Decompress(bb2) & " - " & Decompress(ee2) & " in alignment (" & Decompress(bb2) - SSVal(4) & " - " & Decompress(ee2) - SSVal(5) & " without gaps)"
     Else
        Form1.Picture2.Print "Ending breakpoint 99% CI: Undetermined"
     End If
    ' If XOverList(RecSeq, PAVal).Beginning + 10 > Len(StrainSeq(0)) Then
    '     form1.Picture2.CurrentX = XOS
    '     form1.Picture2.Print "Beginning breakpoint: " & (XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) + 10 - SeqSpaces(XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) + 10, RecSeq)) & " (" & XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) & ")"
    '     form1.Picture2.CurrentX = XOS
    '     form1.Picture2.Print "Ending breakpoint: Undetermined (" & (XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) + 10 - SeqSpaces(XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) + 10, RecSeq)) & " [" & XOverList(RecSeq, PAVal).Beginning - Len(StrainSeq(0)) & "])"
    ' Else
    '     form1.Picture2.CurrentX = XOS
    '     form1.Picture2.Print "Beginning breakpoint: " & (XOverList(RecSeq, PAVal).Beginning + 10 - SeqSpaces(XOverList(RecSeq, PAVal).Beginning + 10, RecSeq)) & " (" & XOverList(RecSeq, PAVal).Beginning & " in alignment)"
    '     form1.Picture2.CurrentX = XOS
    '     form1.Picture2.Print "Ending breakpoint: Undetermined (" & (XOverList(RecSeq, PAVal).Beginning + 10 - SeqSpaces(XOverList(RecSeq, PAVal).Beginning + 10, RecSeq)) & " [" & XOverList(RecSeq, PAVal).Beginning & "])"
    ' End If

 End If
 
 
 If bb1 < ee1 Then
     If XoverList(RecSeq, PAVal).Beginning < bb1 Or XoverList(RecSeq, PAVal).Beginning > ee1 Then
         BEW = 1
     End If
 Else
     If XoverList(RecSeq, PAVal).Beginning > ee1 And XoverList(RecSeq, PAVal).Beginning < bb1 Then
         BEW = 1
     End If
 End If
 
 If bb2 < ee2 Then
     If XoverList(RecSeq, PAVal).Ending < bb2 Or XoverList(RecSeq, PAVal).Ending > ee2 Then
         ENW = 1
     End If
 Else
     If XoverList(RecSeq, PAVal).Ending > ee2 And XoverList(RecSeq, PAVal).Ending < bb2 Then
         ENW = 1
     End If
 End If
 
 
 
 If XoverList(RecSeq, PAVal).ProgramFlag = 6 Then
 
 Else
     If pMCFlag = 0 Then
         P1 = XoverList(RecSeq, PAVal).Probability
         P2 = XoverList(RecSeq, PAVal).Probability / CurMCCorrection
     ElseIf pMCFlag = 2 Then
         P1 = XoverList(RecSeq, PAVal).Probability
         P2 = StepUp(XoverList(RecSeq, PAVal).ProgramFlag, XoverList(RecSeq, PAVal).Probability)
     Else
         P1 = XoverList(RecSeq, PAVal).Probability * CurMCCorrection
         P2 = XoverList(RecSeq, PAVal).Probability
     End If
 End If
 Pos = InStr(1, P1, "E", vbBinaryCompare)
 If Pos > 0 Then
     P1 = Left(P1, 5) & " " & Right(P1, Len(P1) - Pos + 1)
 End If
 
 Pos = InStr(1, P2, "E", vbBinaryCompare)
 If Pos > 0 Then
     P2 = Left(P2, 5) & " " & Right(P2, Len(P2) - Pos + 1)
 End If
 P3 = XoverList(RecSeq, PAVal).Probability * CurMCCorrection
 Pos = InStr(1, P3, "E", vbBinaryCompare)
 If Pos > 0 Then
     P3 = Left(P3, 5) & " " & Right(P3, Len(P3) - Pos + 1)
 End If
 P4 = 0 'XoverList(RecSeq, PAVal).BeginP
 Pos = InStr(1, P4, "E", vbBinaryCompare)
 If Pos > 0 Then
     P4 = Left(P4, 5) & " " & Right(P4, Len(P4) - Pos + 1)
 End If
 P5 = 0 'XoverList(RecSeq, PAVal).BeginP * CurMCCorrection
 Pos = InStr(1, P5, "E", vbBinaryCompare)
 If Pos > 0 Then
     P5 = Left(P5, 5) & " " & Right(P5, Len(P5) - Pos + 1)
 End If
 P6 = 0 'XoverList(RecSeq, PAVal).EndP
 Pos = InStr(1, P6, "E", vbBinaryCompare)
 If Pos > 0 Then
     P6 = Left(P6, 5) & " " & Right(P6, Len(P6) - Pos + 1)
 End If
 BPos = XoverList(RecSeq, PAVal).Beginning
 Epos = XoverList(RecSeq, PAVal).Ending
 Dim OI As Double, II As Double, DS As Long, MiS As Long, MaS As Long
 DS = XoverList(RecSeq, PAVal).Daughter
 MiS = XoverList(RecSeq, PAVal).MinorP
 MaS = XoverList(RecSeq, PAVal).MajorP

 Call CalcPSim(II, OI, BPos, Epos, DS, MiS, MaS, RecSeq, PAVal)


 If UBound(OriginalName, 1) < PermNextno Then
     ReDim Preserve OriginalName(PermNextno)
     For r = 0 To PermNextno
         If r <= UBound(StraiName, 1) Then
             OriginalName(r) = StraiName(r)
         End If
     Next r
 End If
 
 'XOverList(RecSeq, PAVal).OutsideFlag = XOverList(RecSeq, PAVal).OutsideFlag
 If PRFlag = 8 Then
     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
          If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
'            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter) 'FullOName(XoverList(RecSeq, PAVal).EndP)
'         Else
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.CurrentX = XOS + 1
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 92, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 128)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
         End If
     End If
     Dim ExtraT As String
     If XoverList(RecSeq, PAVal).PermPVal = 1 Then
         ExtraT = " (approximated)"
     Else
         ExtraT = ""
     End If
     
     
     oldY = Form1.Picture2.CurrentY
     
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 23), BackColours, BF
     
     
     
     
     Form1.Picture2.CurrentX = 0
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Uncorrected): "; P2 & ExtraT 'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Corrected): "; P1 & ExtraT 'XOverList(RecSeq, PAVal).Probability * CurMCCorrection
 ElseIf PRFlag = 0 Then
     
     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
          If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
'            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter) 'FullOName(XoverList(RecSeq, PAVal).EndP)
'         Else
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.CurrentX = XOS + 1
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 92, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 128)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
         End If
     End If

     oldY = Form1.Picture2.CurrentY
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 23), BackColours, BF
     Form1.Picture2.CurrentX = 0
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Uncorrected): "; P2 'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Corrected): "; P1 'XOverList(RecSeq, PAVal).Probability * CurMCCorrection

 ElseIf PRFlag = 1 Then
     
     If pGCTripletflag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         If XoverList(RecSeq, PAVal).OutsideFlag < 2 Then

             If XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
                 Form1.Picture2.ForeColor = RGB(0, 0, 128)
                 Form1.Picture2.CurrentX = XOS + 1
                 Form1.Picture2.Print "Minor Parent: Unknown " '(" & originalname(XOverList(recseq, paval).MinorP) & ")"
             Else
                 Form1.Picture2.ForeColor = RGB(0, 0, 255)
                 Form1.Picture2.CurrentX = XOS + 1
                 Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
             End If

             Form1.Picture2.ForeColor = RGB(0, 0, 0)
             Form1.Picture2.CurrentX = XOS + 1
             Form1.Picture2.Print "Major Parent: Undetermined"
         Else

             If XoverList(RecSeq, PAVal).MajorP <> XoverList(RecSeq, PAVal).Daughter Then
                 Form1.Picture2.ForeColor = RGB(0, 0, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 Form1.Picture2.Print "Minor Parent: Unknown " '(" & originalname(XOverList(recseq, paval).MinorP) & ")"
                 Form1.Picture2.ForeColor = RGB(0, 192, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
             Else
                 Form1.Picture2.ForeColor = RGB(0, 0, 255)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                    Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)" '(" & originalname(XOverList(recseq, paval).MinorP) & ")"
                 End If
                 Form1.Picture2.ForeColor = RGB(0, 0, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 Form1.Picture2.Print "Major Parent: Unknown "
             End If

         End If
     Else
         If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             Form1.Picture2.ForeColor = RGB(0, 192, 0)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
             End If
             Form1.Picture2.ForeColor = RGB(0, 0, 255)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
            End If
         ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             Form1.Picture2.ForeColor = RGB(0, 92, 0)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
             End If
             Form1.Picture2.ForeColor = RGB(0, 0, 255)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
             End If
         Else
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             Form1.Picture2.ForeColor = RGB(0, 192, 0)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
             End If
             Form1.Picture2.ForeColor = RGB(0, 0, 128)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
             End If
         End If
     End If
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     oldY = Form1.Picture2.CurrentY
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 35), BackColours, BF
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.Print "KA P-Value: "; P2 'XOverList(RecSeq, PAVal).Probability / GCMCCorrection
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Global KA P-Value: "; P1 'XOverList(RecSeq, PAVal).Probability

     If GCNumPerms > 0 Then

         If XoverList(RecSeq, PAVal).PermPVal > 0 Then
             Form1.Picture2.CurrentX = XOS
             Form1.Picture2.Print "Permutation P-Value: "; XoverList(RecSeq, PAVal).PermPVal
         Else
             Form1.Picture2.CurrentX = XOS
             Form1.Picture2.Print "Permutation P-Value:  < 0" & Trim$(CStr(1 / GCNumPerms))
         End If

     Else
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Permutation P-Value:  No permutations done"
     End If

 ElseIf PRFlag = 2 Then

     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 92, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
          If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 128)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
         End If
     End If

     oldY = Form1.Picture2.CurrentY
     If pBSPValFlag = 0 Then
         Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 23), BackColours, BF
     Else
         Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 35), BackColours, BF
     End If
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     If pBSPValFlag = 0 Then
         Form1.Picture2.Print "Probability:  Undetermined"
     ElseIf pBSPValFlag = 1 Then
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Binomial Probability (MC Uncorrected): "; P2 'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Binomial Probability (MC Corrected): "; P1 'XOverList(RecSeq, PAVal).Probability * CurMCCorrection

     ElseIf pBSPValFlag = 2 Then
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Chi Square Probability (MC Uncorrected): "; P2 'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Chi Square Probability (MC Corrected): "; P1 'XOverList(RecSeq, PAVal).Probability * CurMCCorrection

     End If
     If XoverList(RecSeq, PAVal).Probability = (1 / (BSBootReps * 10)) Then
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Average Bootstrap Support:  "; "100" & "% similarity"
     Else
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Average Bootstrap Support:  "; (1 - XoverList(RecSeq, PAVal).PermPVal) * 100 & "% similarity"
     End If
 ElseIf PRFlag = 6 Then

     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
          If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 92, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 128)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
         End If
     End If

     oldY = Form1.Picture2.CurrentY
     
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     
     P1 = XoverList(RecSeq, PAVal).PermPVal
     If P1 = 0 Then
         If pMCFlag = 0 Or pMCFlag = 2 Then
             P1 = (1 / PPPerms) * (NextNo + 1)
             
         ElseIf pMCFlag = 1 Then
             P1 = (1 / PPPerms)
         
         End If
     End If
     If pMCFlag = 0 Then
         CV = P1
         ucv = val(P1) / (NextNo + 1)
     ElseIf pMCFlag = 1 Then
         CV = val(P1) * (NextNo + 1)
         ucv = P1
     ElseIf pMCFlag = 2 Then
         CV = P1
         ucv = StepUp(RecSeq, PAVal)
     End If
     P1 = CV
     P2 = ucv
     Pos = InStr(1, P1, "E", vbBinaryCompare)
     If Pos > 0 Then
         P1 = Left(P1, 6) & " " & Right(P1, Len(P1) - Pos + 1)
     End If
     
     Pos = InStr(1, P2, "E", vbBinaryCompare)
     If Pos > 0 Then
         P2 = Left(P2, 6) & " " & Right(P2, Len(P2) - Pos + 1)
     End If
     If XoverList(RecSeq, PAVal).PermPVal = 0 Then
         Form1.Picture2.Print "Perm. P-Val. (MC Uncorrected): < " & P2
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Perm. P-Val. (MC Corrected): < " & P1
     ElseIf Abs(XoverList(RecSeq, PAVal).PermPVal > 0) Then
         Form1.Picture2.Print "Perm. P-Val. (MC Uncorrected): " & P2
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Perm. P-Val. (MC Corrected): " & P1
     End If
     
 ElseIf PRFlag = 5 Then

     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 92, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
         End If
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 128)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
         End If
     End If

     oldY = Form1.Picture2.CurrentY
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 23), BackColours, BF
     Form1.Picture2.CurrentX = 0
     Form1.Picture2.CurrentY = oldY
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     Form1.Picture2.CurrentX = XOS

     
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Uncorrected): "; P2  'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "Probability (MC Corrected): "; P1  ' XOverList(RecSeq, PAVal).Probability * CurMCCorrection
    
 ElseIf PRFlag = 3 Or PRFlag = 4 Then

     If XoverList(RecSeq, PAVal).SBPFlag <= 3 Then

         If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             Form1.Picture2.ForeColor = RGB(0, 192, 0)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MajorP <> XoverList(RecSeq, PAVal).Daughter Then
                If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                    Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
                 End If
             Else
                 Form1.Picture2.ForeColor = RGB(0, 0, 0)
                 Form1.Picture2.Print "Major Parent: Undetermined"
                 
             End If
             Form1.Picture2.ForeColor = RGB(0, 0, 255)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
             End If
         ElseIf XoverList(RecSeq, PAVal).OutsideFlag > 0 Then
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             If XoverList(RecSeq, PAVal).OutsideFlag = 3 Then
                 Form1.Picture2.ForeColor = RGB(0, 192, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MajorP <> XoverList(RecSeq, PAVal).Daughter Then
                    If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                        Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
                    End If
                 Else
                     Form1.Picture2.ForeColor = RGB(0, 0, 0)
                     Form1.Picture2.Print "Major Parent: Undetermined"
                     
                 End If
                 
                 Form1.Picture2.ForeColor = RGB(0, 0, 128)
                 Form1.Picture2.CurrentX = XOS + 1
                 
                 If XoverList(RecSeq, PAVal).MajorP <> XoverList(RecSeq, PAVal).MinorP Then
                     If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                        Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
                     End If
                 Else
                     Form1.Picture2.ForeColor = RGB(0, 0, 0)
                     Form1.Picture2.Print "Minor Parent: Undetermined"
                     Form1.Picture2.ForeColor = RGB(0, 0, 255)
                 End If
                 'form1.Picture2.Print "Minor Parent: Unknown (" & originalname(XOverList(RecSeq, PAVal).MinorP) & ")"
             ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
                 Form1.Picture2.ForeColor = RGB(0, 92, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                    Form1.Picture2.Print "Major Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ")"
                 End If
                 Form1.Picture2.ForeColor = RGB(0, 0, 255)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MajorP <> XoverList(RecSeq, PAVal).MinorP Then
                     Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
                 Else
                     Form1.Picture2.ForeColor = RGB(0, 0, 0)
                     Form1.Picture2.Print "Minor Parent: Undetermined"
                     Form1.Picture2.ForeColor = RGB(0, 0, 255)
                 End If
                 
             Else
                 
                 Form1.Picture2.ForeColor = RGB(0, 192, 0)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                    Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
                 End If
                 Form1.Picture2.ForeColor = RGB(0, 0, 128)
                 Form1.Picture2.CurrentX = XOS + 1
                 If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                    Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
                 End If
             End If
             

         Else
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
                Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
             End If
             Form1.Picture2.ForeColor = RGB(0, 192, 0)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Major Parent: " & OriginalName(XoverList(RecSeq, PAVal).MajorP) & " (" & Trim(Str(OI)) & "% similarity)"
             End If
             Form1.Picture2.ForeColor = RGB(0, 0, 128)
             Form1.Picture2.CurrentX = XOS + 1
             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: Unknown (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
             End If
         End If

         oldY = Form1.Picture2.CurrentY
         Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 58), BackColours, BF
         Form1.Picture2.CurrentX = 0
         Form1.Picture2.CurrentY = oldY
     Else
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
            Form1.Picture2.Print "Recombinant: " & OriginalName(XoverList(RecSeq, PAVal).Daughter)
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 255)
         Form1.Picture2.CurrentX = XOS + 1
         If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                Form1.Picture2.Print "Minor Parent: " & OriginalName(XoverList(RecSeq, PAVal).MinorP) & " (" & Trim(Str(II)) & "% similarity)"
            
         End If
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         Form1.Picture2.CurrentX = XOS + 1
         Form1.Picture2.Print "Major Parent: Undetermined"
         oldY = Form1.Picture2.CurrentY
         Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 35), BackColours, BF
         Form1.Picture2.CurrentX = 0
         Form1.Picture2.CurrentY = oldY
     End If
  
     Form1.Picture2.ForeColor = RGB(0, 0, 0)

'     If XoverList(RecSeq, PAVal).SBPFlag = 0 Then
'
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Beginning breakpoint probability: " & P4 'XOverList(RecSeq, PAVal).BeginP
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Ending breakpoint probability:  " & P6 'XOverList(RecSeq, PAVal).EndP
'
'
'
'
'     ElseIf XoverList(RecSeq, PAVal).SBPFlag = 1 Then
'
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Beginning breakpoint probability: Undetermined"
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Ending breakpoint probability:  " & P6 ' XOverList(RecSeq, PAVal).EndP
'
'
'
'     ElseIf XoverList(RecSeq, PAVal).SBPFlag = 2 Then
'
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Beginning breakpoint probability: " & P4 'XOverList(RecSeq, PAVal).BeginP
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Ending breakpoint probability:  Undetermined"
'     ElseIf XoverList(RecSeq, PAVal).SBPFlag = 3 Then
'
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Beginning breakpoint probability: " & P4 'XOverList(RecSeq, PAVal).BeginP
'         Form1.Picture2.CurrentX = XOS
'         Form1.Picture2.Print "Ending breakpoint probability:  " & P6
'
'     End If

     

     If XoverList(RecSeq, PAVal).SBPFlag < 3 Or x = x Then
         Form1.Picture2.CurrentX = XOS + 1
         Form1.Picture2.Print "Region probability (MC uncorrected): " & P2 'XOverList(RecSeq, PAVal).Probability / CurMCCorrection
         Form1.Picture2.CurrentX = XOS + 1
         Form1.Picture2.Print "Region probability (MC corrected): " & P1 'XOverList(RecSeq, PAVal).Probability
         
         
         Form1.Picture2.CurrentX = XOS + 1
         
         Form1.Picture2.Print "Region permutation probability: Undetermined"
         
     Else
         'form1.Picture2.Print "Mean Probability (MC Corrected): " & XOverList(recseq, paval).Probability * GCMCCorrection
     End If

     MCMaxP = LowestProb

     
     

 End If
 
     
 If EN <= UBound(TreeTestStats, 2) Then
     If TreeTestStats(0, EN) > 0 Then
         
             oldY = Form1.Picture2.CurrentY
             Form1.Picture2.Line (0, Form1.Picture2.CurrentY - 1)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 47), BackColours, BF
             Form1.Picture2.CurrentX = 0
             Form1.Picture2.CurrentY = oldY
         If TreeTestStats(0, EN) = 0.00001 Then
             Crap = "<0.0001"
         Else
             Crap = Trim(Str(TreeTestStats(0, EN)))
             If Left(Crap, 1) = "." Then Crap = "0" + Crap
         End If
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "SH tree topology test p-value using sites " + Trim(Str(XoverList(RecSeq, PAVal).Beginning)) + " - " + Trim(Str(XoverList(RecSeq, PAVal).Ending)) + ": " + Crap
         
         If TreeTestStats(1, EN) = 0.00001 Then
             Crap = "<0.0001"
         Else
             Crap = Trim(Str(TreeTestStats(1, EN)))
             If Left(Crap, 1) = "." Then Crap = "0" + Crap
         End If
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "AU tree topology test p-value using sites " + Trim(Str(XoverList(RecSeq, PAVal).Beginning)) + " - " + Trim(Str(XoverList(RecSeq, PAVal).Ending)) + ": " + Crap
         
         Form1.Picture2.CurrentX = XOS
         If TreeTestStats(2, EN) = 0.00001 Then
             Crap = "<0.0001"
         Else
             Crap = Trim(Str(TreeTestStats(2, EN)))
             If Left(Crap, 1) = "." Then Crap = "0" + Crap
         End If
         Form1.Picture2.Print "SH tree topology test p-value using sites " + Trim(Str(XoverList(RecSeq, PAVal).Ending + 1)) + " - " + Trim(Str(XoverList(RecSeq, PAVal).Beginning - 1)) + ": " + Crap
         
         If TreeTestStats(3, EN) = 0.00001 Then
             Crap = "<0.0001"
         Else
             Crap = Trim(Str(TreeTestStats(3, EN)))
             If Left(Crap, 1) = "." Then Crap = "0" + Crap
         End If
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "AU tree topology test p-value using sites " + Trim(Str(XoverList(RecSeq, PAVal).Ending + 1)) + " - " + Trim(Str(XoverList(RecSeq, PAVal).Beginning - 1)) + ": " + Crap
         
         x = x
     End If
 End If
                    
 If YannWarn(SEN) = 1 Then
    Form1.Picture2.ForeColor = RGB(255, 0, 0)
    Form1.Picture2.CurrentX = XOS
    Form1.Picture2.Print "RECOMBINATION SIGNAL MAY BE ATRIBUTABLE TO A PROCESSS OTHER THAN RECOMBINATION"
    Form1.Picture2.ForeColor = RGB(0, 0, 0)
 
 End If
                    
 If PRFlag = 3 Or PRFlag = 4 Then
     If XoverList(RecSeq, PAVal).SBPFlag = 0 Then

'         If XoverList(RecSeq, PAVal).BeginP > MCMaxP And XoverList(RecSeq, PAVal).BeginP > XoverList(RecSeq, PAVal).EndP Then
'             Form1.Picture2.ForeColor = RGB(255, 0, 0)
'             Form1.Picture2.CurrentX = XOS
'             Form1.Picture2.Print "POSSIBLE MISIDENTIFICATION OF BEGINNING BREAKPOINT"
'             Form1.Picture2.ForeColor = RGB(0, 0, 0)
'         ElseIf XoverList(RecSeq, PAVal).EndP > MCMaxP Then
'             Form1.Picture2.ForeColor = RGB(255, 0, 0)
'             Form1.Picture2.CurrentX = XOS
'             Form1.Picture2.Print "POSSIBLE MISIDENTIFICATION OF ENDING BREAKPOINT"
'             Form1.Picture2.ForeColor = RGB(0, 0, 0)
'         End If
     
     End If

 
 End If
 If BEW = 1 Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "BEGINNING BREAKPOINT OUTSIDE OF CONFIDENCE INTERVAL"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
 End If
 If ENW = 1 Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "ENDING BREAKPOINT OUTSIDE OF CONFIDENCE INTERVAL"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
 End If
 If XoverList(RecSeq, PAVal).SBPFlag = 1 Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "NO BEGINNING BREAKPOINT IDENTIFIED"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
 ElseIf XoverList(RecSeq, PAVal).SBPFlag = 2 Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "NO ENDING BREAKPOINT IDENTIFIED"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
 ElseIf XoverList(RecSeq, PAVal).SBPFlag = 3 Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "NEITHER BEGINNING NOR ENDING BREAKPOINTS IDENTIFIED"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
 Else
     If bb1 = ee1 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "IDENTIFIED BEGINNING BREAKPOINT POSITION VERY UNCERTAIN"
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
     End If
     If bb2 = ee2 Then
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "IDENTIFIED ENDING BREAKPOINT POSITION VERY UNCERTAIN"
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
     End If
 
 End If
 
 
 

 
 If XoverList(RecSeq, PAVal).OutsideFlag > 0 Then
     'form1.Picture2.FontSize = 7
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "ONLY ONE PARENTAL SEQUENCE IN TRIPLET"
 End If
   'Exit Sub
 If XoverList(RecSeq, PAVal).MissIdentifyFlag > 0 Or DScores(10, 0, EN) < DScores(10, 1, EN) Or DScores(10, 0, EN) < DScores(10, 2, EN) Then
     If XoverList(RecSeq, PAVal).MissIdentifyFlag >= 10 Or DScores(10, 0, EN) < DScores(10, 1, EN) Or DScores(10, 0, EN) < DScores(10, 2, EN) Then
             
             'form1.Picture2.FontSize = 7
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
             Form1.Picture2.CurrentX = XOS
             Form1.Picture2.Print "POSSIBLE MISSIDENTIFICATION OF RECOMBINANT"
             
             'form1.Picture2.FontSize = 7
             EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
             For x = 1 To 2
                 If DScores(10, 0, EN) + DScores(10, 1, EN) + DScores(10, 2, EN) > 0 Then
                 
                     If (DScores(0, x, EN) / (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN))) > 0.3 Or (DScores(10, x, EN) / (DScores(10, 0, EN) + DScores(10, 1, EN) + DScores(10, 2, EN))) > 0.3 Then
                         If x = 1 Then
                             Form1.Picture2.CurrentX = XOS
                             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                                Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MajorP) + " MAY BE ACTUAL RECOMBINANT"
                             End If
                         Else
                             Form1.Picture2.CurrentX = XOS
                             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                                Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MinorP) + " MAY BE ACTUAL RECOMBINANT"
                             End If
                         End If
                     End If
                 Else
                     If (DScores(0, x, EN) / (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN))) > 0.3 Then
                         If x = 1 Then
                             Form1.Picture2.CurrentX = XOS
                             If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
                                Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MajorP) + " MAY BE ACTUAL RECOMBINANT"
                             End If
                         Else
                             Form1.Picture2.CurrentX = XOS
                             If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
                                Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MinorP) + " MAY BE ACTUAL RECOMBINANT"
                             End If
                         End If
                     End If
                 End If
             Next x
             
     End If
     If XoverList(RecSeq, PAVal).MissIdentifyFlag = 2 Or XoverList(RecSeq, PAVal).MissIdentifyFlag = 12 Then
         'form1.Picture2.FontSize = 7
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "POSSIBLE MISALIGNMENT ARTIFACT"
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         'form1.Picture2.FontSize = 7
     ElseIf XoverList(RecSeq, PAVal).MissIdentifyFlag = 3 Or XoverList(RecSeq, PAVal).MissIdentifyFlag = 13 Then
         'form1.Picture2.FontSize = 7
         Form1.Picture2.ForeColor = RGB(255, 0, 0)
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "PROBABLE MISALIGNMENT ARTIFACT"
         Form1.Picture2.ForeColor = RGB(0, 0, 0)
         'form1.Picture2.FontSize = 7
     End If
 End If
 

 
 If XoverList(RecSeq, PAVal).Probability > LowestProb Then
     Form1.Picture2.ForeColor = RGB(255, 0, 0)
     Form1.Picture2.CurrentX = XOS
     Form1.Picture2.Print "ONLY TRACE EVIDENCE OF EVENT " & Trim(Str(EN)) & " DETECTED"
     Form1.Picture2.ForeColor = RGB(0, 0, 0)
     
 End If
 
 If QvRFlag = 1 Then
    Dim MessageFlagA As Byte, MessageFlagB As Byte, MessageFlagC As Byte
    For x = 0 To NextNo
        If Daught(EN, x) = 1 Then
            If ReferenceList(x) > 0 Then
                MessageFlagA = 1
            End If
        ElseIf Daught(EN, x) = 2 Then
            If ReferenceList(x) > 0 Then
                MessageFlagB = 1
            End If
        ElseIf Daught(EN, x) > 2 Then
            If ReferenceList(x) > 0 Then
                MessageFlagC = 1
            End If
        
        
        End If
    Next x
    If MessageFlagA = 1 Or MessageFlagB = 1 Or MessageFlagC = 1 Then
        Form1.Picture2.ForeColor = RGB(255, 128, 0)
        
        Form1.Picture2.CurrentX = XOS
        If RecSeq <= UBound(ReferenceList) Then
            If ReferenceList(RecSeq) = 0 Then
                If MessageFlagA = 1 Then
                    Form1.Picture2.Print "ONE OR MORE REFERENCE SEQUENCEs ALSO CARRY EVIDENCE OF THIS EVENT"
                ElseIf MessageFlagB = 1 Then
                    Form1.Picture2.Print "ONE OR MORE REFERENCE SEQUENCES ALSO CARRY PARTIAL EVIDENCE OF THIS EVENT"
                ElseIf MessageFlagC = 1 Then
                    Form1.Picture2.Print "ONE OR MORE REFERENCE SEQUENCES ALSO CARRY TRACE EVIDENCE OF THIS EVENT"
                End If
            Else
                If XoverList(RecSeq, PAVal).Probability < LowestProb Then
                    Form1.Picture2.Print "THIS REFERENCE SEQUENCE MAY BE RECOMBINANT"
                Else
               
                    Form1.Picture2.Print "THIS REFERENCE SEQUENCE MAY CARRY TRACE EVIDENCE OF RECOMBINATION EVENT " & Trim(Str(EN))
                End If
            End If
        End If
    End If
    Form1.Picture2.ForeColor = RGB(0, 0, 0)
 End If
 Form1.Picture2.ForeColor = RGB(0, 0, 0)
 If PRFlag = 1 And pGCTripletflag = 0 Then
     oldY = Form1.Picture2.CurrentY
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.CurrentY + 47), BackColours, BF
     Form1.Picture2.CurrentX = 0
     Form1.Picture2.CurrentY = oldY

     If XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Number of Polymorphic Sites: " & XoverList(RecSeq, PAVal).LHolder
         Form1.Picture2.CurrentX = XOS
         'XXXZZZ  form1.Picture2.Print "Number of Mismatches in Fragment: " & XOverlist(RecSeq, PAVal).NumDiffs
         Form1.Picture2.CurrentX = XOS
         'XXXZZZ  form1.Picture2.Print "Total Number of Mismatches: " & XOverlist(RecSeq, PAVal).TotDiffs
         Form1.Picture2.CurrentX = XOS + 1
         'XXXZZZ  form1.Picture2.Print "Mismatch penalty: " & XOverlist(RecSeq, PAVal).MisPen
     Else
         Form1.Picture2.CurrentX = XOS
         Form1.Picture2.Print "Number of Polymorphic Sites: " & XoverList(RecSeq, PAVal).LHolder
         Form1.Picture2.CurrentX = XOS
  'XXXZZZ        form1.Picture2.Print "Number of Non-unique sites in Fragment: " & XOverlist(RecSeq, PAVal).NumDiffs
         Form1.Picture2.CurrentX = XOS
  'XXXZZZ         form1.Picture2.Print "Total Number of Non-unique sites: " & XOverlist(RecSeq, PAVal).TotDiffs
         Form1.Picture2.CurrentX = XOS + 1
  'XXXZZZ         form1.Picture2.Print "Mismatch penalty: " & XOverlist(RecSeq, PAVal).MisPen
     End If

 Else
     oldY = Form1.Picture2.CurrentY
     Form1.Picture2.Line (0, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth * 4, Form1.Picture2.ScaleHeight), BackColours, BF
     Form1.Picture2.CurrentX = 0
     Form1.Picture2.CurrentY = oldY
 End If
 
 
 
'XXXZZZ                 form1.Picture2.Print XOverlist(RecSeq, PAVal).TreePos(0), XOverlist(RecSeq, PAVal).TreePos(1), XOverlist(RecSeq, PAVal).TreePos(2)
 
 
 '**********************
 'form1.Picture2.Print RecSeq, PAVal
 '***********************
 
 'form1.Picture2.Print RecSeq, PAVal
 
 
 '***********************
 'If LongWindedFlag = 1 Then
 '    form1.Picture2.Print XOverList(RecSeq, PAVal).Eventnumber, SuperEventlist(XOverList(RecSeq, PAVal).Eventnumber)
 'End If
 '**********************
 'form1.Picture2.Print XOverList(RecSeq, PAVal).Daughter, XOverList(RecSeq, PAVal).MinorP, XOverList(RecSeq, PAVal).MajorP
 
 
 'Put in all the confirmatory data

 Dim TaH As Long

 TaH = Form1.Picture2.TextHeight("O") * (AddNum - 1 + 4.5)
 'cy = form1.Picture2.ScaleHeight - TaH - 10
 cy = Form1.Picture2.CurrentY + 5
 Form1.Picture2.CurrentY = cy
 Form1.Picture2.Line (5, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth - 5, Form1.Picture2.CurrentY + TaH), ThreeQuaterColour, BF
 Form1.Picture2.CurrentY = cy
 Form1.Picture2.FontBold = True
 Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 3 - Form1.Picture2.TextWidth("Confirmation Table") / 2
 Form1.Picture2.Print "Confirmation Table"
 Form1.Picture2.FontBold = False
 Form1.Picture2.Line (10, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth - 10, Form1.Picture2.CurrentY), 0
 Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 5
 cy = Form1.Picture2.CurrentY
 Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 1 - Form1.Picture2.TextWidth("Methods") / 2
 Form1.Picture2.Print "Methods"
 Form1.Picture2.CurrentY = cy
 Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 3 - Form1.Picture2.TextWidth("# seqs detected in") / 2
 Form1.Picture2.Print "# seqs detected in"
 Form1.Picture2.CurrentY = cy
 Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 5 - Form1.Picture2.TextWidth("Av. P-Val") / 2
 Form1.Picture2.Print "Av. P-Val"
 Form1.Picture2.Line (10, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth - 10, Form1.Picture2.CurrentY), 0
 Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 5
 Form1.Picture2.CurrentX = 5

 Dim PV As String
 Dim EX As String
 Dim HN As String
 Dim OS As Integer, OF As Integer, SP As Integer
' Exit Sub
 Dim PValCon As Double
 If LongWindedFlag = 0 Then
     EN = XoverList(RecSeq, PAVal).Eventnumber
 Else
     EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
 End If
 'Confirm(EN, 5) = 0
 
 Dim AA As Long
 For AA = 0 To AddNum - 1
 
    If AA = 6 Then
        Z = 8
    ElseIf AA = 8 Then
        Z = 6
    Else
        Z = AA
    End If
     EX = ""
     cy = Form1.Picture2.CurrentY
     Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 1 - Form1.Picture2.TextWidth(ProgNames(AA)) / 2
     If AA = 6 Then
        Form1.Picture2.Print "3Seq"
     ElseIf AA = 8 Then
        Form1.Picture2.Print "Phylpro"
     Else
        Form1.Picture2.Print ProgNames(AA)
     End If
     Form1.Picture2.CurrentY = cy

     If Confirm(EN, Z) > 0 Then
         
         
         PValCon = ConfirmP(EN, Z) / Confirm(EN, Z)
         
         PValCon = 10 ^ (-PValCon)
         PV = Trim$(CStr(CDbl(PValCon)))
         If PV < 1 Then
             If Len(PV) > 3 Then

                 If Mid$(PV, Len(PV) - 3, 1) = "E" Then
                     EX = Right$(PV, 2)
                 ElseIf Len(PV) > 4 Then

                     If Mid$(PV, Len(PV) - 4, 1) = "E" Then
                         EX = Right$(PV, 3)
                     ElseIf Len(PV) > 5 Then

                         If Mid$(PV, Len(PV) - 5, 1) = "E" Then
                             EX = Right$(PV, 4)
                         End If

                     End If

                 End If

             End If

             If Left$(PV, 1) = "." Then
                 PV = "0" + PV
             End If

             If Len(PV) >= 5 And Len(EX) = 0 Then
                 SP = 3

                 Do

                     If Mid$(PV, SP, 1) <> "0" Then
                         PV = Mid$(PV, SP, 1) & "." & Mid$(PV, SP + 1, 3)
                         EX = Trim$(CStr(SP - 2))

                         If SP - 2 < 10 Then
                             EX = "0" + EX
                         End If

                         Exit Do
                     End If

                     SP = SP + 1
                 Loop

             End If

             If Len(PV) < 5 Then
                 PV = PV + String$(5 - Len(PV), "0")
             End If

             If Len(EX) > 0 Then
                 PV = Left$(PV, 5)
                 PV = PV & " X 10"
                 OS = Form1.Picture2.TextWidth(PV)
                 PV = PV + String$(Len(EX) + 1, " ")
             End If

             HN = Trim$(CStr(Confirm(EN, Z)))
         Else
             PV = ">1.0"
             HN = Trim$(CStr(Confirm(EN, Z)))
         End If
     Else
         PV = "--"
         HN = "--"
     End If
     
     Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 3 - Form1.Picture2.TextWidth(HN) / 2
     Form1.Picture2.Print HN
     Form1.Picture2.CurrentY = cy
     Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 5 - Form1.Picture2.TextWidth(PV) / 2
     cx = Form1.Picture2.CurrentX + OS
     Form1.Picture2.Print PV

     If Len(EX) > 0 Then
         Form1.Picture2.CurrentX = cx
         Form1.Picture2.CurrentY = cy - 2
         OF = Form1.Picture2.FontSize
         Form1.Picture2.FontSize = Form1.Picture2.FontSize - 1
         Form1.Picture2.Print "-" & EX
         Form1.Picture2.FontSize = OF
         Form1.Picture2.CurrentY = cy
         Form1.Picture2.Print
     End If

 Next 'Z
     
 'Draw the recombinant support graphs
 
 
 
     
 Form1.Picture2.Line (10, Form1.Picture2.CurrentY)-(Form1.Picture2.ScaleWidth - 10, Form1.Picture2.CurrentY), 0
 
 Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 15
 
 
 Form1.Picture2.FontBold = True
 Form1.Picture2.CurrentX = ((Form1.Picture2.ScaleWidth - 10) / 6) * 3 - Form1.Picture2.TextWidth("Recombinant sequence identification graphs") / 2
 Form1.Picture2.Print "Recombinant sequence identification graphs"
 Form1.Picture2.FontBold = False
 
 'form1.Picture2.CurrentY = form1.Picture2.CurrentY + 5
 
 Dim MWid As Long
 MWid = 0
 For x = 0 To 25
     If MWid < Form1.Picture2.TextWidth(TestName(x)) Then MWid = Form1.Picture2.TextWidth(TestName(x))
 Next x
 
 Dim xScale As Single
 xScale = (Form1.Picture2.ScaleWidth - 10 - MWid) / 40
 
 Form1.Picture2.CurrentX = 7 + MWid + (((Form1.Picture2.ScaleWidth - 10 - MWid)) - (7 + MWid) - Form1.Picture2.TextWidth("Recombinant score")) / 2
 Form1.Picture2.Print "Recombinant score"
 
 By = Form1.Picture2.CurrentY
 
 
 'form1.Picture2.Line (5, form1.Picture2.CurrentY)-(40 * 3 + MWid + 10, form1.Picture2.CurrentY + 13 * 26), ThreeQuaterColour, BF
 Form1.Picture2.Line (7 + MWid, Form1.Picture2.CurrentY)-(35 * xScale + 10 + MWid, Form1.Picture2.CurrentY), 0
 Form1.Picture2.Line (7 + MWid, Form1.Picture2.CurrentY)-(7 + MWid, Form1.Picture2.CurrentY + 18 * 34), 0
 
 Form1.Picture2.CurrentY = By + 26 * 5
 
 tby = Form1.Picture2.CurrentY
 'make the red block in the legend
 Form1.Picture2.Line (25 * xScale + 10 + MWid, Form1.Picture2.CurrentY)-(25 * xScale + 8 + 10 + MWid, Form1.Picture2.CurrentY + 8), RGB(255, 0, 0), BF
 
 xtby = Form1.Picture2.CurrentY
 Form1.Picture2.CurrentY = tby
 Form1.Picture2.CurrentX = 25 * xScale + MWid + 18 + 5
 Form1.Picture2.ForeColor = 0
 If XoverList(RecSeq, PAVal).Daughter <= UBound(OriginalName) Then
    Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).Daughter)
 End If
 Form1.Picture2.CurrentY = xtby
 tby = Form1.Picture2.CurrentY + 4
 'make the green block in the legend
 Form1.Picture2.Line (25 * xScale + 10 + MWid, Form1.Picture2.CurrentY + 4)-(25 * xScale + 8 + 10 + MWid, Form1.Picture2.CurrentY + 12), RGB(0, 192, 0), BF
 
 xtby = Form1.Picture2.CurrentY
 Form1.Picture2.CurrentY = tby
 Form1.Picture2.CurrentX = 25 * xScale + MWid + 18 + 5
 Form1.Picture2.ForeColor = 0
 If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
     Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MajorP)
 End If
 Form1.Picture2.CurrentY = xtby
 tby = Form1.Picture2.CurrentY + 4
 'make the blue block in the legend
 Form1.Picture2.Line (25 * xScale + 10 + MWid, Form1.Picture2.CurrentY + 4)-(25 * xScale + 8 + 10 + MWid, Form1.Picture2.CurrentY + 12), RGB(0, 0, 255), BF
 
 xtby = Form1.Picture2.CurrentY
 Form1.Picture2.CurrentY = tby
 Form1.Picture2.CurrentX = 25 * xScale + MWid + 18 + 5
 Form1.Picture2.ForeColor = 0
 If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
    Form1.Picture2.Print OriginalName(XoverList(RecSeq, PAVal).MinorP)
 End If
 Form1.Picture2.CurrentY = xtby
 tby = Form1.Picture2.CurrentY
 
 Form1.Picture2.CurrentY = By + 2
 Dim OSt As String, DBl As Double, NCY As Long, NCY2 As Long, FS As Double, TDAdd As Single
 For A = 0 To 17
 'this adds all the modifiers to the histograms
     
'     If A = 15 Then
'        X = X
'     End If
     For Z = 0 To 2
        'dscores(20 is likely free for the Neural Net
        'If DScores(20, Z, EN) <> 0 Then
        '    x = x
        'End If
         If A = 8 Then
            TDAdd = DScores(19, Z, EN) + DScores(21, Z, EN)
         ElseIf A = 1 Then
            TDAdd = DScores(19, Z, EN) '+ DScores(20, Z, EN)
         ElseIf A = 2 Then
            TDAdd = DScores(24, Z, EN)
         ElseIf A = 4 Then
            TDAdd = DScores(24, Z, EN)
         ElseIf A = 9 Then
            TDAdd = 0 'DScores(20, Z, EN)
         ElseIf A = 3 Then
            TDAdd = DScores(21, Z, EN)
         ElseIf A = 5 Then
            TDAdd = DScores(22, Z, EN)
         ElseIf A = 6 Then
            TDAdd = DScores(23, Z, EN)
         ElseIf A = 7 Then
            TDAdd = DScores(23, Z, EN) + DScores(24, Z, EN)
         Else
            TDAdd = 0
         End If
         If A <> 11 Then
            TDAdd = TDAdd + 0.5
         End If
         'TDAdd = 0
         If Z = 0 Then
             Form1.Picture2.ForeColor = RGB(255, 0, 0)
         ElseIf Z = 1 Then
             Form1.Picture2.ForeColor = QBColor(0)
             Form1.Picture2.CurrentX = 5 + MWid - Form1.Picture2.TextWidth(TestName(A))
             By = Form1.Picture2.CurrentY
             Form1.Picture2.CurrentY = Form1.Picture2.CurrentY - 1
             Form1.Picture2.Print (TestName(A))
             Form1.Picture2.CurrentY = By
             Form1.Picture2.ForeColor = RGB(0, 192, 0)
         Else
             Form1.Picture2.ForeColor = RGB(0, 0, 255)
         End If
         NCY = Form1.Picture2.CurrentY
         'draw a histogram bar
         Form1.Picture2.Line (MWid + 10, Form1.Picture2.CurrentY)-((DScores(A, Z, EN) + TDAdd) * xScale + MWid + 10, Form1.Picture2.CurrentY + 9), , BF
         NCY2 = Form1.Picture2.CurrentY
         If A = 0 Then ' need to add in the LR and NN consensus graphs
             'Label the decision tree bar
             
             ocy = Form1.Picture2.CurrentY
             FS = Form1.Picture2.FontSize
             Form1.Picture2.ForeColor = 0
             Form1.Picture2.FontSize = Form1.Picture2.FontSize ' - 1
             Form1.Picture2.CurrentY = NCY - 1
             Form1.Picture2.CurrentX = Form1.Picture2.CurrentX + 5
             
             If (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN)) > 0 Then
                 DBl = DScores(0, Z, EN) / (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN))
             Else
                 DBl = -10
             End If
             'exit sub
             If DBl <> -10 Then
                DBl = DBl * 1000
                DBl = CLng(DBl)
                DBl = DBl / 1000
                DBl = DBl + 0.0000001
                
                OSt = "0" + Left(Trim(Str(DBl)), 4)
             Else
                OSt = "--"
             End If
             Form1.Picture2.Print OSt + " (DT)"
             Form1.Picture2.CurrentY = NCY2 + 1
             Form1.Picture2.FontSize = FS
             
             Form1.Picture2.CurrentY = ocy
             If Z = 0 Then
                Form1.Picture2.ForeColor = RGB(255, 0, 0)
            ElseIf Z = 1 Then
                Form1.Picture2.ForeColor = RGB(0, 192, 0)
            Else
                Form1.Picture2.ForeColor = RGB(0, 0, 255)
            End If
             
             NCY = Form1.Picture2.CurrentY
             'now do the Logistic Regression bar
             Form1.Picture2.Line (MWid + 10, Form1.Picture2.CurrentY)-((DScores(18, Z, EN) + TDAdd) * xScale + MWid + 10, Form1.Picture2.CurrentY + 9), , BF
            'Form1.Picture2.Line (MWid + 10, Form1.Picture2.CurrentY)-((DScores(20, Z, EN) + TDAdd) * xScale + MWid + 10, Form1.Picture2.CurrentY + 9), , BF
             NCY2 = Form1.Picture2.CurrentY
             If (DScores(18, 0, EN) + DScores(18, 1, EN) + DScores(18, 2, EN)) > 0 Then
                 DBl = DScores(18, Z, EN) / (DScores(18, 0, EN) + DScores(18, 1, EN) + DScores(18, 2, EN))
             Else
                 DBl = -10
             End If
             'exit sub
             
             FS = Form1.Picture2.FontSize
             Form1.Picture2.ForeColor = 0
             Form1.Picture2.FontSize = Form1.Picture2.FontSize ' - 1
             Form1.Picture2.CurrentY = NCY
             Form1.Picture2.CurrentX = Form1.Picture2.CurrentX + 5
             
             
             'exit sub
             If DBl <> -10 Then
                DBl = DBl * 1000
                DBl = CLng(DBl)
                DBl = DBl / 1000
                DBl = DBl + 0.0000001
                
                OSt = "0" + Left(Trim(Str(DBl)), 4)
             Else
                OSt = "--"
             End If
             Form1.Picture2.Print OSt + " (LR)"
             Form1.Picture2.CurrentY = NCY2 + 1
             Form1.Picture2.FontSize = FS
             NCY2 = Form1.Picture2.CurrentY
             
             
             'Form1.Picture2.CurrentY = ocy
             If Z = 0 Then
                Form1.Picture2.ForeColor = RGB(255, 0, 0)
            ElseIf Z = 1 Then
                Form1.Picture2.ForeColor = RGB(0, 192, 0)
            Else
                Form1.Picture2.ForeColor = RGB(0, 0, 255)
            End If
             
             NCY = Form1.Picture2.CurrentY
             'now do the Logistic Regression bar
             Form1.Picture2.Line (MWid + 10, Form1.Picture2.CurrentY)-((DScores(20, Z, EN) + TDAdd) * xScale + MWid + 10, Form1.Picture2.CurrentY + 9), , BF
            'Form1.Picture2.Line (MWid + 10, Form1.Picture2.CurrentY)-((DScores(20, Z, EN) + TDAdd) * xScale + MWid + 10, Form1.Picture2.CurrentY + 9), , BF
             NCY2 = Form1.Picture2.CurrentY
             If (DScores(20, 0, EN) + DScores(20, 1, EN) + DScores(20, 2, EN)) > 0 Then
                 DBl = DScores(20, Z, EN) / (DScores(20, 0, EN) + DScores(20, 1, EN) + DScores(18, 2, EN))
             Else
                 DBl = -10
             End If
             'exit sub
             
             FS = Form1.Picture2.FontSize
             Form1.Picture2.ForeColor = 0
             Form1.Picture2.FontSize = Form1.Picture2.FontSize ' - 1
             Form1.Picture2.CurrentY = NCY
             Form1.Picture2.CurrentX = Form1.Picture2.CurrentX + 5
             
             If DBl <> -10 Then
                DBl = DBl * 1000
                DBl = CLng(DBl)
                DBl = DBl / 1000
                DBl = DBl + 0.0000001
                
                OSt = "0" + Left(Trim(Str(DBl)), 4)
             Else
                OSt = "--"
             End If
             Form1.Picture2.Print OSt + " (NN)"
             Form1.Picture2.CurrentY = NCY2 + 1
             Form1.Picture2.FontSize = FS
             NCY2 = Form1.Picture2.CurrentY
             
             
         End If
         
         
         
         
'         If A = 0 Then
'             FS = Form1.Picture2.FontSize
'             Form1.Picture2.ForeColor = 0
'             Form1.Picture2.FontSize = Form1.Picture2.FontSize ' - 1
'             Form1.Picture2.CurrentY = NCY - 1
'             Form1.Picture2.CurrentX = Form1.Picture2.CurrentX + 5
'             If (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN)) > 0 Then
'                 DBl = DScores(0, Z, EN) / (DScores(0, 0, EN) + DScores(0, 1, EN) + DScores(0, 2, EN))
'             Else
'                 DBl = 1
'             End If
'             'exit sub
'             DBl = DBl * 1000
'             DBl = CLng(DBl)
'             DBl = DBl / 1000
'             DBl = DBl + 0.0000001
'             OSt = "0" + Left(Trim(Str(DBl)), 4)
'             Form1.Picture2.Print OSt
'             Form1.Picture2.CurrentY = NCY2 + 1
'             Form1.Picture2.FontSize = FS
'         End If
         
     Next Z
     Form1.Picture2.CurrentY = Form1.Picture2.CurrentY + 6
 Next A
 Form1.Picture2.ForeColor = 0
 
 P2DHeight = Form1.Picture2.CurrentY + 15
 
 If P2DHeight > (Form1.Picture32.ScaleHeight / Screen.TwipsPerPixelY) Then
     Form1.VScroll4.Max = P2DHeight - (Form1.Picture32.ScaleHeight / Screen.TwipsPerPixelY)
     Form1.VScroll4.Enabled = True
 Else

     If Form1.Picture2.Top = 0 Then Form1.VScroll4.Enabled = False
 End If
 
 

End Sub
Public Sub PrintNames()
Dim TH As Long, x As Long, UB As Long, Pict As Long, tTYF As Double, TYFM As Integer, YP As Double, VSV As Long, P1H, Y1 As Long
' XX = Maskseq(17)
If CLine <> "" Then Exit Sub
Form1.Picture3.Enabled = False
'@
Form1.Picture3.AutoRedraw = True


If ttyfAdjust = 0 Then ttyfAdjust = 1

'@
Form1.Picture3.Line (0, 0)-(Form1.Picture3.ScaleWidth, Form1.Picture3.ScaleHeight), BackColours, BF
'Form1.Picture3.Picture = LoadPicture()

Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
YP = 13 * tTYF 'Y position determinant
If ScrollSF > 0 Then
    VSV = Form1.VScroll3.Value / ScrollSF
Else
    VSV = Form1.VScroll3.Value
End If
P1H = Form1.Picture9.ScaleHeight
'@
'Pict = Form1.Picture3.hDC

If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(GrpMaskSeq, 1)
On Error GoTo 0

If PermNextno > UB Then ReDim Preserve GrpMaskSeq(PermNextno)
Dim RecName(2) As Long
If RelX > 0 Or RelY > 0 Then
    RecName(0) = XoverList(RelX, RelY).Daughter
    RecName(1) = XoverList(RelX, RelY).MajorP
    RecName(2) = XoverList(RelX, RelY).MinorP
Else
    RecName(0) = -1
    RecName(1) = -1
    RecName(2) = -1
End If

If QvRFlag = 1 Then
If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(ReferenceCols, 1)
    If UB < RefNum Then
        ReDim Preserve ReferenceCols(RefNum)
    End If
    
On Error GoTo 0
End If


'If SelGrpFlag = 1 Then
'    If UBound(ReferenceList, 1) < PermNextno Then
        ReDim Preserve ReferenceList(PermNextno)
'    End If
'End If


Dim WhiteCol As Long
WhiteCol = RGB(255, 255, 255)
Pict = Form1.Picture3.hdc
For x = 0 To PermNextno
    
    
    Y1 = (x * YP * ttyfAdjust - VSV + 1)
    If Y1 > -20 And Y1 < P1H Then
        If x = SelectedSeqNumber Then
            TH = Form1.Picture3.TextHeight("A")
            'Y2 = Y1 + TH
            Call HighlightFound(Y1, TH, WhiteCol)
            
        
        '    BusyFlashing(X) = 1
       '
        End If
    'Form1.Picture3.CurrentY = ((X * 13)) * tTYF
        If SelGrpFlag = 0 Then
            If GrpMaskSeq(x) = 0 Or x = x Then
                 If x > UBound(MaskSeq, 1) Then
                    ReDim Preserve MaskSeq(x + 10)
                End If
                If x = RecName(2) Then
                    If BusyFlashing(x) = 0 Then
                        
                        Form1.Picture3.ForeColor = RGB(0, 0, 255)
                        
                        
                    Else
                        Form1.Picture3.ForeColor = FlashArray(3, BusyFlashing(x))
                    End If
                ElseIf x = RecName(1) Then
                    If BusyFlashing(x) = 0 Then
                        Form1.Picture3.ForeColor = RGB(0, 200, 0)
                    Else
                        Form1.Picture3.ForeColor = FlashArray(5, BusyFlashing(x))
                    End If
                ElseIf x = RecName(0) Then
                    If BusyFlashing(x) = 0 Then
                        Form1.Picture3.ForeColor = RGB(255, 0, 0)
                    Else
                        Form1.Picture3.ForeColor = FlashArray(4, BusyFlashing(x))
                    End If
                ElseIf MaskSeq(x) = 1 Or x = RecName(2) Then
                    If BusyFlashing(x) = 0 Then
                        
                        Form1.Picture3.ForeColor = QBColor(8)
                        
                    Else
                        
                        Form1.Picture3.ForeColor = FlashArray(1, BusyFlashing(x))
                    End If
                    If BusyFlashing(x) = 0 Then
                        Form1.Picture3.ForeColor = QBColor(8)
                        
                    Else
                        Form1.Picture3.ForeColor = FlashArray(1, BusyFlashing(x))
                    End If
                    
                ElseIf MaskSeq(x) = 2 Then
                    'Form1.Picture3.ForeColor = ThreeQuaterColour
                    If BusyFlashing(x) = 0 Then
                        Form1.Picture3.ForeColor = RGB(255, 255, 255)
                    Else
                        Form1.Picture3.ForeColor = FlashArray(2, BusyFlashing(x))
                    End If
                ElseIf MaskSeq(x) = 0 Then
                    'If X <= UBound(BusyFlashing, 1) Then
                        If BusyFlashing(x) = 0 Then
                            If QvRFlag = 1 Then
                                If ReferenceList(x) > 0 Then
                                    Form1.Picture3.ForeColor = ReferenceCols(ReferenceList(x))
                                Else
                                    Form1.Picture3.ForeColor = 0
                                End If
                            Else
                            
                                Form1.Picture3.ForeColor = QBColor(0)
                            End If
                            If RelX > 0 Or RelY > 0 Then
                                If x = Seq1 Then
                                    Form1.Picture3.ForeColor = RGB(0, 200, 0)
                                ElseIf x = Seq2 Then
                                    Form1.Picture3.ForeColor = RGB(0, 0, 255)
                                ElseIf x = Seq3 Then
                                    Form1.Picture3.ForeColor = RGB(255, 0, 0)
                                End If
                            End If
                        Else
                            If QvRFlag = 1 And ReferenceList(x) > 0 Then
                                Form1.Picture3.ForeColor = ReferenceCols(ReferenceList(x))
                            Else
                                Form1.Picture3.ForeColor = FlashArray(0, BusyFlashing(x))
                            End If
                        End If
                   'End If
                End If
            Else
                If BusyFlashing(x) = 0 Then
                        If MaskSeq(x) = 0 Then
                            Form1.Picture3.ForeColor = RGB(0, 0, 255)
                        ElseIf MaskSeq(x) = 1 Then
                            Form1.Picture3.ForeColor = RGB(120, 120, 255)
                        Else
                            Form1.Picture3.ForeColor = RGB(170, 200, 255)
                        End If
                Else
                    Form1.Picture3.ForeColor = FlashArray(3, BusyFlashing(x))
                End If
            End If
            x = x
        Else
            If GrpMaskSeq(x) = 1 Then
                If BusyFlashing(x) = 0 Then
                    If MaskSeq(x) = 0 Then
                        Form1.Picture3.ForeColor = RGB(0, 0, 255)
                    ElseIf MaskSeq(x) = 1 Then
                        Form1.Picture3.ForeColor = RGB(120, 120, 255)
                    Else
                        Form1.Picture3.ForeColor = RGB(170, 200, 255)
                    End If
                Else
                    
                    If MaskSeq(x) = 0 Then
                        Form1.Picture3.ForeColor = FlashArray(3, BusyFlashing(x))
                    ElseIf MaskSeq(x) = 1 Then
                        Form1.Picture3.ForeColor = FlashArray(6, BusyFlashing(x))
                    Else
                        Form1.Picture3.ForeColor = FlashArray(7, BusyFlashing(x))
                    End If
                End If
            ElseIf GrpMaskSeq(x) = 0 Then
                If BusyFlashing(x) = 0 Then
                    If QvRFlag = 1 Then
                        If ReferenceList(x) > 0 Then
                            Form1.Picture3.ForeColor = ReferenceCols(ReferenceList(x))
                        Else
                            Form1.Picture3.ForeColor = 0
                        End If
                    ElseIf MaskSeq(x) = 0 Then
                        Form1.Picture3.ForeColor = 0
                    ElseIf MaskSeq(x) = 1 Then
                        Form1.Picture3.ForeColor = QBColor(8)
                    Else
                        Form1.Picture3.ForeColor = ThreeQuaterColour
                    End If
                Else
                    If MaskSeq(x) = 0 Then
                        Form1.Picture3.ForeColor = FlashArray(0, BusyFlashing(x))
                    ElseIf MaskSeq(x) = 1 Then
                        Form1.Picture3.ForeColor = FlashArray(1, BusyFlashing(x))
                    Else
                        Form1.Picture3.ForeColor = FlashArray(2, BusyFlashing(x))
                    End If
                End If
                
            End If
        End If
        'Form1.Picture3.print originalname(X)
        TextOut Pict, 0, Y1, OriginalName(x), Len(OriginalName(x))
    End If
Next 'X
'@
Form1.Picture3.Enabled = True
Form1.Picture3.AutoRedraw = False
 'XX = Maskseq(17)
End Sub
Public Sub HighlightFound(Y1 As Long, TH As Long, WhiteCol As Long)
Form1.Picture3.Line (0, Y1)-(Form1.Picture3.ScaleWidth, Y1 + TH), WhiteCol, BF

End Sub

Public Sub SchemDrawing(SB() As Long, SBL As Long, SS() As Long, SSL As Long, CWin, OriginalName() As String, IStart As Long, PB As PictureBox)


'BB = Abs(GetTickCount)
Dim UBXX As Long, Y As Long, Dummy As Long, x As Long, XAdj As Single, Pict As Long, PH As Long, LBrush As LOGBRUSH, IStartX As Long
PB.AutoRedraw = True
PB.Picture = LoadPicture()
PB.ScaleMode = 3
PB.FontSize = 6.75
PH = PB.ScaleHeight
IStartX = CLng(IStart * F1VS2Adj)


'First Draw all the lines
SSS = Abs(GetTickCount)
P6HSF = P6OSize / Form1.Picture5.Width


If UBound(SB, 3) = 0 Then Exit Sub

'
'ExtFloodFill Form1.hdc, 1, 1, 0, 0
'Form1.Picture6.AutoRedraw = True
'For zz = 0 To 100
Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
'For zz = 0 To 1000
Dim LPNT As POINTAPI
'If X = 12345 Then 'Draw this only with the API - its actually slower because of all the screwing about
'                    'making sure there are no memory leaks
'    Pict = Form1.Picture6.hDC
'
'
'    'Form1.Picture6.FillStyle = 0
'    'Dummy = SetPolyFillMode(Pict, 0)
'
'    PEN = CreatePenIndirect(LPen)
'    OldPen = SelectObject(Pict, PEN)
'    Brush = CreateBrushIndirect(LBrush)
'    OldBrush = SelectObject(Pict, Brush)
'    oB = LBrush
'    OP = LPen
'    For X = 0 To SBL
'        If IStartX + SB(CWin, 1, X) >= 0 Or IStartX + SB(CWin, 3, X) >= 0 Then
'            If IStartX + SB(CWin, 1, X) <= PH Or IStartX + SB(CWin, 3, X) <= PH Then
'                If SB(CWin, 4, X) >= 0 Then
'                    'PB.Line (SB(CWin, 0, x), istartx + SB(CWin, 1, x))-(SB(CWin, 2, x), istartx + SB(CWin, 3, x)), SB(CWin, 4, x), BF
'                    'Form1.Picture6.ForeColor = SB(CWin, 4, x)
'                    'Form1.Picture6.FillColor = SB(CWin, 4, x)
'
'
'
'
'                    LPen.lopnColor = SB(CWin, 4, X)
'                    PEN = CreatePenIndirect(LPen)
'                    Pen2 = SelectObject(Pict, PEN)
'                    LBrush.lbColor = SB(CWin, 4, X)
'                    LBrush.lbStyle = 0
'                    Brush = CreateBrushIndirect(LBrush)
'                    Brush2 = SelectObject(Pict, Brush)
'                    Dummy = Rectangle(Pict, SB(CWin, 0, X) / P6HSF, IStartX + SB(CWin, 1, X), SB(CWin, 2, X) / P6HSF, IStartX + SB(CWin, 3, X))
'                    'Pen = SelectObject(Pict, OldPen)
'                    DeleteObject (Pen2)
'                    DeleteObject (Brush2)
'
'
'
'
'
'
'                    'Dummy = ExtFloodFill(Pict, SB(CWin, 0, x) + 2, istartx + SB(CWin, 1, x) + 2, SB(CWin, 4, x), 0)
'
'
'
'                Else
'                    'PB.Line (SB(CWin, 0, x), istartx + SB(CWin, 1, x))-(SB(CWin, 2, x), istartx + SB(CWin, 3, x)), RGB(255, 0, 0), B
'
'                    'Form1.Picture6.ForeColor = RGB(255, 0, 0)
'                    'Form1.Picture6.DrawWidth = 1
'
'                    LPen.lopnColor = RGB(255, 0, 0)
'                    PEN = CreatePenIndirect(LPen)
'                    Pen2 = SelectObject(Pict, PEN)
'
'                    Dummy = Rectangle(Pict, SB(CWin, 0, X) / P6HSF, IStartX + SB(CWin, 1, X), SB(CWin, 2, X) / P6HSF, IStartX + SB(CWin, 3, X))
'                    DeleteObject (Pen2)
'                    'Dummy = FloodFill(Pict, SB(CWin, 0, x) + 1, istartx + SB(CWin, 1, x) + 1, RGB(255, 0, 0))
'                End If
'            End If
'        End If
'    Next X
'    'Brush = CreateBrushIndirect(obrush)
'    'Brush = oB
'
'    Brush = SelectObject(Pict, OldBrush)
'    DeleteObject (Brush)
'    PEN = SelectObject(Pict, OldPen)
'    DeleteObject (PEN)
'
'
'ElseIf X = X Then
    
    Pict = Form1.Picture6.hdc
    Form1.Picture6.FillStyle = 0
    'Dummy = SetPolyFillMode(Pict, 0)
    Dim Frm1Pic5ScaleWidth As Long

    Frm1Pic5ScaleWidth = Form1.Picture5.ScaleWidth - 10
    'SpaceAdjust = 1
    'YAdj = Int((Y * 12 + 3) * SpaceAdjust)
    'YAdj2 = Int((Y * 12 + 13) * SpaceAdjust)
    XAdj = (Frm1Pic5ScaleWidth) / Len(StrainSeq(0))
    If RelX <> 0 Or RelY <> 0 Then
        Form1.Picture6.ForeColor = FourQuaterColour
        Form1.Picture6.FillColor = FourQuaterColour
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Dummy = Rectangle(Pict, 5 + XoverList(RelX, RelY).Beginning * XAdj, 0, 5 + XoverList(RelX, RelY).Ending * XAdj, Form1.Picture6.Height)
        Else
            Dummy = Rectangle(Pict, 5 + XoverList(RelX, RelY).Beginning * XAdj, 0, 5 + Len(StrainSeq(0)) * XAdj, Form1.Picture6.Height)
            Dummy = Rectangle(Pict, 5 + 1 * XAdj, 0, 5 + XoverList(RelX, RelY).Ending * XAdj, Form1.Picture6.Height)
        End If
'        Dummy = MoveToEx(Pict, 5 + XoverList(RelX, RelY).Beginning * XAdj, 0, LPNT)
'        Dummy = LineTo(Pict, 5 + XoverList(RelX, RelY).Beginning * XAdj, Form1.Picture6.Height)
'
'        Dummy = MoveToEx(Pict, 5 + XoverList(RelX, RelY).Ending * XAdj, IStartX + 0, LPNT)
'        Dummy = LineTo(Pict, 5 + XoverList(RelX, RelY).Ending * XAdj, Form1.Picture6.Height)
    End If
    For x = 0 To UBound(SB, 3)
        If IStartX + SB(CWin, 1, x) >= 0 Or IStartX + SB(CWin, 3, x) >= 0 Then
            If IStartX + SB(CWin, 1, x) <= PH Or IStartX + SB(CWin, 3, x) <= PH Then
                If SB(CWin, 4, x) >= 0 Then
                    'PB.Line (SB(CWin, 0, x), istartx + SB(CWin, 1, x))-(SB(CWin, 2, x), istartx + SB(CWin, 3, x)), SB(CWin, 4, x), BF
                    Form1.Picture6.ForeColor = SB(CWin, 4, x)
                    Form1.Picture6.FillColor = SB(CWin, 4, x)
                    Dummy = Rectangle(Pict, SB(CWin, 0, x) / P6HSF, IStartX + SB(CWin, 1, x), SB(CWin, 2, x) / P6HSF, IStartX + SB(CWin, 3, x))
                    'Dummy = ExtFloodFill(Pict, SB(CWin, 0, x) + 2, istartx + SB(CWin, 1, x) + 2, SB(CWin, 4, x), 0)
                    'XX = Form1.Picture1.ScaleWidth
                    x = x
                    If ReassortmentFlag = 1 And SB(CWin, 0, x) <= 6 And SB(CWin, 2, x) >= Frm1Pic5ScaleWidth - 6 Then
                        Form1.Picture6.ForeColor = Form1.Picture6.BackColor
                        For Y = 2 To RBPNum - 1
                            Dummy = MoveToEx(Pict, 5 + RBPPos(Y) * XAdj, IStartX + SB(CWin, 1, x), LPNT)
                            Dummy = LineTo(Pict, 5 + RBPPos(Y) * XAdj, IStartX + SB(CWin, 3, x))
                        Next Y
                        x = x
                    End If
                
                End If
            End If
        End If
    Next x
    
    
    For x = 0 To UBound(SB, 3)
        If IStartX + SB(CWin, 1, x) >= 0 Or IStartX + SB(CWin, 3, x) >= 0 Then
            If IStartX + SB(CWin, 1, x) <= PH Or IStartX + SB(CWin, 3, x) <= PH Then
                If SB(CWin, 4, x) >= 0 Then

                Else
                    Form1.Picture6.ForeColor = RGB(255, 0, 0)
                    If SB(CWin, 4, x - 1) >= 0 Then
                        Form1.Picture6.FillColor = SB(CWin, 4, x - 1)
                    Else
                        If ReassortmentFlag = 1 Then
                            Form1.Picture6.FillColor = RGB(128, 128, 128)
                        End If
                    End If
                    Dummy = Rectangle(Pict, SB(CWin, 0, x) / P6HSF, IStartX + SB(CWin, 1, x), SB(CWin, 2, x) / P6HSF, IStartX + SB(CWin, 3, x))
                    x = x
                End If
            End If
        End If
    Next x
    
    'Brush = CreateBrushIndirect(obrush)
    'Brush = oB
    
   
'Else
'    For X = 0 To SBL
'        If IStartX + SB(CWin, 1, X) >= 0 Or IStartX + SB(CWin, 3, X) >= 0 Then
'            If IStartX + SB(CWin, 1, X) <= PH Or IStartX + SB(CWin, 3, X) <= PH Then
'                If SB(CWin, 4, X) >= 0 Then
'                    PB.Line (SB(CWin, 0, X) / P6HSF, IStartX + SB(CWin, 1, X))-(SB(CWin, 2, X) / P6HSF, IStartX + SB(CWin, 3, X)), SB(CWin, 4, X), BF
'                Else
'                    PB.Line (SB(CWin, 0, X) / P6HSF, IStartX + SB(CWin, 1, X))-(SB(CWin, 2, X) / P6HSF, IStartX + SB(CWin, 3, X)), RGB(255, 0, 0), B
'                End If
'            End If
'        End If
'    Next X
'End If
Form1.Picture6.FillStyle = 1
'Next zz
'EE = Abs(GetTickCount)
'TT = EE - SSS
'Then print the names
If DebuggingFlag < 2 Then On Error Resume Next
UBXX = 0
UBXX = UBound(OriginalName, 1)

On Error GoTo 0

If UBXX < NextNo + 1 Then
ReDim Preserve OriginalName(NextNo + 1)
Else
    x = x
End If
OriginalName(NextNo + 1) = "Unknown"
Pict = PB.hdc
For x = 0 To SSL
    If IStartX + SS(CWin, 1, x) + 10 >= 0 Then
        If IStartX + SS(CWin, 1, x) <= PH Then
            PB.ForeColor = SS(CWin, 3, x)
            If SS(CWin, 2, x) <= UBound(OriginalName) And SS(CWin, 2, x) >= 0 Then
                TextOut Pict, SS(CWin, 0, x) / P6HSF, IStartX + SS(CWin, 1, x), OriginalName(SS(CWin, 2, x)), Len(OriginalName(SS(CWin, 2, x)))
            Else
                TextOut Pict, SS(CWin, 0, x) / P6HSF, IStartX + SS(CWin, 1, x), FullOName(Abs(SS(CWin, 2, x))), Len(FullOName(Abs(SS(CWin, 2, x))))
            End If
        End If
    End If
Next x

PB.Refresh
PB.AutoRedraw = False
End Sub
Public Sub SchemDrawingEMF(SaveFlag, SB() As Long, SBL As Long, SS() As Long, SSL As Long, CWin)


Dim Pict As Long, PH As Long, LBrush As LOGBRUSH

'First Draw all the lines
SSS = Abs(GetTickCount)
 

Dim rct As RECT
    Dim LoFnt As Long

    If SaveFlag = 1 Then

        With Form1.CommonDialog1
            .FileName = ""
            '.InitDir = currentdir
            .DefaultExt = ".emf"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "EMF File (*.emf)|*.emf"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            semfname$ = .FileName  'Stores selected file name in the
            'string, fname$.
            semfnameII = .FileTitle
        End With

    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "tmp2.emf"
        On Error GoTo 0
        semfnameII = "tmp2.emf"
        semfname$ = "tmp2.emf"
    End If
'Exit Sub

Dim PointY As Double, PointX As Double
'points = pixels * 96 / 72

    PointX = GetDeviceCaps(Form1.Picture1.hdc, 88) '88 = logpixelsx
    PointY = GetDeviceCaps(Form1.Picture1.hdc, 90) '90 = logpixelsy
    PointX = (Form1.Picture6.ScaleWidth * PointX / 72) * Screen.TwipsPerPixelX
    PointY = ((UBound(PermArray, 2) * 11) * PointY / 72) * Screen.TwipsPerPixelY
    
    'XX = (UBound(PermArray, 2) / 36) * 10000
    rct.Bottom = PointY  '(UBound(PermArray, 2) / 36) * 10000 '10000 =29 rows
    
    'Exit Sub
    rct.Left = 0
    rct.Top = 0
    rct.Right = PointX '22000
    
    


Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
'For zz = 0 To 1000
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, semfname$, rct, "")
    
    
'    xdim = GetDeviceCaps(MhDC, 88) '88 = logpixelsx
'    ydim = GetDeviceCaps(MhDC, 90) '90 = logpixelsy
    x = x
    
    
    Form1.Picture1.AutoRedraw = True
    'Get original Metafile font and pen
    
    
    LoFnt = CreateFont(10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    Pict = MhDC
    
    
    'Form1.Picture6.FillStyle = 0
    'Dummy = SetPolyFillMode(Pict, 0)
    
    PEN = CreatePenIndirect(LPen)
    oldpen = SelectObject(Pict, PEN)
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    oB = LBrush
    OP = LPen
    
    IStart = 0
    'For zz = 0 To 1
    Frm1Pic5ScaleWidth = Form1.Picture5.ScaleWidth - 10
    'SpaceAdjust = 1
    'YAdj = Int((Y * 12 + 3) * SpaceAdjust)
    'YAdj2 = Int((Y * 12 + 13) * SpaceAdjust)
    XAdj = (Frm1Pic5ScaleWidth) / Len(StrainSeq(0))
    Dim LPNT As POINTAPI
    For x = 0 To SBL
        'If IStart + SB(CWin, 1, x) >= 0 Or IStart + SB(CWin, 3, x) >= 0 Then
            'If IStart + SB(CWin, 1, x) <= PH Or IStart + SB(CWin, 3, x) <= PH Then
                If SB(CWin, 4, x) >= 0 Then
                    'PB.Line (SB(CWin, 0, x), IStart + SB(CWin, 1, x))-(SB(CWin, 2, x), IStart + SB(CWin, 3, x)), SB(CWin, 4, x), BF
                    'Form1.Picture6.ForeColor = SB(CWin, 4, x)
                    'Form1.Picture6.FillColor = SB(CWin, 4, x)
                    
                    
                   
                    
                    LPen.lopnColor = SB(CWin, 4, x)
                    PEN = CreatePenIndirect(LPen)
                    Pen2 = SelectObject(Pict, PEN)
                    LBrush.lbColor = SB(CWin, 4, x)
                    LBrush.lbStyle = 0
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                    
                    Dummy = Rectangle(Pict, SB(CWin, 0, x), IStart + SB(CWin, 1, x), SB(CWin, 2, x), IStart + SB(CWin, 3, x))
                    'Pen = SelectObject(Pict, OldPen)
                    
                    
                    If ReassortmentFlag = 1 And SB(CWin, 0, x) <= 6 And SB(CWin, 2, x) >= Frm1Pic5ScaleWidth - 6 Then
                        Form1.Picture6.ForeColor = Form1.Picture6.BackColor
                        LPen.lopnColor = RGB(255, 255, 255)
                        PEN = CreatePenIndirect(LPen)
                        Pen2 = SelectObject(Pict, PEN)
                        For Y = 2 To RBPNum - 1
                            Dummy = MoveToEx(Pict, 5 + RBPPos(Y) * XAdj, IStartX + SB(CWin, 1, x), LPNT)
                            Dummy = LineTo(Pict, 5 + RBPPos(Y) * XAdj, IStartX + SB(CWin, 3, x))
                        Next Y
                        x = x
                    End If
                    
                    
                    
                    DeleteObject (Pen2)
                    DeleteObject (Brush2)
                    
                    
                    
                    
                    
                   
                    'Dummy = ExtFloodFill(Pict, SB(CWin, 0, x) + 2, IStart + SB(CWin, 1, x) + 2, SB(CWin, 4, x), 0)
                    
                    
                    
                Else
                    'PB.Line (SB(CWin, 0, x), IStart + SB(CWin, 1, x))-(SB(CWin, 2, x), IStart + SB(CWin, 3, x)), RGB(255, 0, 0), B
                    
                    'Form1.Picture6.ForeColor = RGB(255, 0, 0)
                    'Form1.Picture6.DrawWidth = 1
                    
                    LPen.lopnColor = RGB(255, 0, 0)
                    PEN = CreatePenIndirect(LPen)
                    Pen2 = SelectObject(Pict, PEN)
                    LBrush.lbColor = SB(CWin, 4, x - 1)
                    LBrush.lbStyle = 0
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                    
                    Dummy = Rectangle(Pict, SB(CWin, 0, x), IStart + SB(CWin, 1, x), SB(CWin, 2, x), IStart + SB(CWin, 3, x))
                    DeleteObject (Pen2)
                    'Dummy = FloodFill(Pict, SB(CWin, 0, x) + 1, IStart + SB(CWin, 1, x) + 1, RGB(255, 0, 0))
                End If
            'End If
        'End If
    Next x
    'Brush = CreateBrushIndirect(obrush)
    'Brush = oB
    
'Next zz
    
    

'Then print the names
ReDim Preserve OriginalName(NextNo + 1)
OriginalName(NextNo + 1) = "Unknown"
Pict = MhDC

For x = 1 To SSL Step 2
    'If IStart + SS(CWin, 1, x) + 10 >= 0 Then
        'If IStart + SS(CWin, 1, x) <= PH Then
            
            SetTextColor Pict, SS(CWin, 3, x)
            If SS(CWin, 2, x) <= UBound(OriginalName) Then
                TextOut Pict, SS(CWin, 0, x), IStart + SS(CWin, 1, x), OriginalName(SS(CWin, 2, x)), Len(OriginalName(SS(CWin, 2, x)))
            End If
            DeleteObject (Pen2)
        'End If
    'End If
Next x


Offset = 300 * HAddjust
SetTextColor Pict, 0
If SchemFlag = 1 Then
    
    For x = 0 To AddNum - 1
        LPen.lopnColor = ProgColour(x)
        
        PEN = CreatePenIndirect(LPen)
        Pen2 = SelectObject(Pict, PEN)
        LBrush.lbColor = ProgColour(x)
        LBrush.lbStyle = 0
        Brush = CreateBrushIndirect(LBrush)
        Brush2 = SelectObject(Pict, Brush)
        
        Dummy = Rectangle(Pict, Offset, x * 15 + 5, 10 + Offset, x * 15 + 15)
        'Pen = SelectObject(Pict, OldPen)
        DeleteObject (Pen2)
        DeleteObject (Brush2)
        
        TextOut Pict, 15 + Offset, x * 15 + 5, ProgNames(x), Len(ProgNames(x))
    Next x
    
    
ElseIf SchemFlag = 2 Or SchemFlag = 3 Then
    Dim PVO As String

    curline = 0
    
    For RCol = 0 To 1020 Step 3
        curline = RCol / 1020 * 155 + 10
        LPen.lopnColor = HeatMap(6, RCol)
        'LPen.lopnWidth = x
        PEN = CreatePenIndirect(LPen)
        Pen2 = SelectObject(Pict, PEN)
        Dummy = MoveToEx(Pict, 2 + Offset, curline, LPNT)
        Dummy = LineTo(Pict, 20 + Offset, curline)
        DeleteObject (Pen2)
    Next
    
    If SchemFlag = 2 Then
        MaxLogPVal = -Log10(LowestProb)
        
        
        PVO = "-  " & CLng(MaxLogPVal * 1000) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 5, PVO, Len(PVO)
        
        PVO = "-  " & (CLng(((MinLogPValSch + MaxLogPVal) / 2 + MaxLogPVal) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 43, PVO, Len(PVO)
        
        PVO = "-  " & (CLng((MinLogPValSch + MaxLogPVal) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 82, PVO, Len(PVO)
        
        PVO = "-  " & (CLng((MinLogPValSch + (MinLogPValSch + MaxLogPVal) / 2) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 120, PVO, Len(PVO)
        
        PVO = "-  " & CLng(MinLogPValSch * 1000) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 159, PVO, Len(PVO)
               
        PVO = "-Log(P-Val)"
        
        TextOut Pict, 2 + Offset, 170, PVO, Len(PVO)
    Else
        
        
        PVO = "-  " & CLng(MinDistSch * 1000) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 5, PVO, Len(PVO)
        
        PVO = "-  " & (CLng(((MaxDistSch + MinDistSch) / 2 + MinDistSch) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 43, PVO, Len(PVO)
        
        PVO = "-  " & (CLng((MaxDistSch + MinDistSch) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 84, PVO, Len(PVO)
        
        PVO = "-  " & (CLng((MaxDistSch + (MaxDistSch + MinDistSch) / 2) / 2 * 1000)) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 120, PVO, Len(PVO)
        
        PVO = "-  " & CLng(MaxDistSch * 1000) / 1000
        Call MakePVO5(8, PVO)
        TextOut Pict, 25 + Offset, 159, PVO, Len(PVO)
               
        PVO = "Parental identity"
        
        TextOut Pict, -10 + Offset, 170, PVO, Len(PVO)
    
    
    End If
    
End If


Brush = SelectObject(Pict, OldBrush)
DeleteObject (Brush)
PEN = SelectObject(Pict, oldpen)
DeleteObject (PEN)

LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject (LoFnt)
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    
    If SaveFlag = 0 Then
        Clipboard.Clear
        If DebuggingFlag < 2 Then On Error Resume Next
        Clipboard.SetData LoadPicture("tmp2.emf"), 3
        
        KillFile "tmp2.emf"
        On Error GoTo 0
    End If

EE = Abs(GetTickCount)
TT = EE - BB

End Sub
Public Sub TreeDrawingx(OnlyNames, NoP3Flag, TreeBlocksL() As Long, TBLLen As Long, TNF As Byte, OriginalName() As String, IStart As Long, TNum, TType, TreeDrawB() As Single, TDLen() As Long, TreeBlocks() As Long, TBLen() As Long, PB As PictureBox)

Dim PRat As Single, GoOn As Long, TSH As Long, PntAPI As POINTAPI, Pict As Long, OFS As Double, NLen As Single, OLen As Single, x As Long, ScaleX As String, ScaleL As Double
Dim tTYF As Double, TYFM As Integer, OS As Long, oTNum As Long, TSingle As Single, oTSingle As Single
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
If OnlyNamesFlag > 0 Then
    OnlyNames = 1
End If
IStart = IStart * F2VSScaleFactor(TNum)
If CurrentlyRunningFlag = 1 Then Exit Sub




PRat = -1: oTNum = TNum
If DebuggingFlag < 2 Then On Error Resume Next
PRat = TDLen(TNum, TType, 2) / PB.ScaleWidth '384
If PRat = -1 Then Exit Sub

On Error GoTo 0
If TDLen(TNum, TType, 1) = 0 Then
    NoP3Flag = 1
    TNum = 0
    TNF = 0
    
End If

Dim FI As Byte
If PB.hdc = Form1.Picture16.hdc Then
    FI = 1
Else
    FI = 0
End If
 
'This makes sure dots etc are reset to 0
SelectNode(0) = -1

PB.AutoRedraw = True


If OnlyNames = 0 Then
    
    PB.Picture = LoadPicture()
End If
PB.ScaleMode = 3
PB.FontSize = 8.25

OLen = PB.TextWidth("AAA")

If TYF2 = 0 Then Exit Sub

PB.FontSize = PB.FontSize * TYF2
'XX = Form2.VScroll1(Index).Max
'XX = tTYF

x = x
Call ModOffsets(8.25, PB, tTYF, TYFM)
'If PersistantP2tTYF = 0 Then
'    Call ModOffsets(8.25, PB, tTYF, TYFM)
'    PersistantP2tTYF = tTYF
'    PersistantP2TYFM = TYFM
'Else
'    tTYF = PersistantP2tTYF
'    TYFM = PersistantP2TYFM
'End If
otTYF = tTYF
TSingle = tTYF
oTSingle = otTYF



Dim UBTTS1 As Long, UBTTS2 As Long, UBTT As Long
Dim UBTD5 As Long, UBON As Long, UBTBL As Long, UBTB4 As Long, UBMB4 As Long, UBMC As Long
Dim AH1 As Long, AH2 As Long, AH3 As Long

If DebuggingFlag < 2 Then On Error Resume Next
UBMC = UBound(MultColour, 1)
If UBMC < (NextNo * 2) Then
    ReDim Preserve MultColour(NextNo * 2)
End If
UBMB4 = UBound(MapBlocks, 4)
UBTB4 = UBound(TreeBlocks, 4)
UBTD5 = UBound(TreeDraw, 5)
UBTTS2 = UBound(TreeTraceSeqs, 2)
UBTTS1 = UBound(TreeTraceSeqs, 1)
UBTT = UBound(TreeTrace, 1)
UBON = UBound(OriginalName)
UBTBL = UBound(TreeBlocksL, 4)
On Error GoTo 0
If PB = Form1.Picture16 Then
    
    
    OVy = VSC1NC
    VSC1NC = 1
    With Form1.VScroll1
        If .Max <= 0 Then .Value = 0
        OV = .Value
        OM = .Max
        If OM > 0 Then
            OVx = OV / OM
        Else
            OVx = 1
        End If
        If TDLen(TNum, CTF, 1) > 0 And UBTD5 >= TDLen(TNum, CTF, 1) Then
            VSMax = -PB.ScaleHeight + ((TreeDraw(TNum, CTF, 1, 1, TDLen(TNum, CTF, 1)) + 1) * oTSingle) + 200 'PB.ScaleHeight = 806; ctf = 0; ottyf =1,018, treetypeflag = 2
            '464
        Else
            VSMax = -PB.ScaleHeight + ((TreeDraw(TNum, CTF, 1, 1, TDLen(0, 1, 1)) + 1) * oTSingle) + 200
        End If
        If OM = 0 Then OM = 1
        If VSMax > 32000 Then
            F1VS1ScaleFactor = VSMax / 32000 '38409'1.033
            VSMax = 32000
        Else
            F1VS1ScaleFactor = 1
        End If
        
        .Max = VSMax '-Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
        If .Max > 0 And OM > 0 Then
            If OVx * VSMax <= .Max Then
                .Value = OVx * VSMax
            ElseIf .Max > 0 Then
                .Value = .Max
            End If
        End If
        If .Max <= 0 Then
            .Enabled = False
        Else
            If Form1.Picture9.ScaleHeight = 0 Then Exit Sub
            .LargeChange = Form1.Picture9.ScaleHeight
            .Enabled = True
        End If
        
    End With
    VSC1NC = OVy
    
Else
   ' With Form2.VScroll1(0)
   '     If .Max <= 0 Then .Value = 0: .Max = 1
   '     OV = .Value
   '
   '     OM = .Max
   '     .Max = -PB.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
   '
   '     If OV / (OM / .Max) <= .Max Then
   '         .Value = OV / (OM / .Max)
   '     ElseIf .Max > 0 Then
   '         .Value = .Max
   '     End If
   '
   '     If .Max <= 0 Then
   '         .Enabled = False
   '     Else
   '         .LargeChange = Form2.Picture2(0).ScaleHeight
   '         .Enabled = True
   '     End If
   '
   ' End With
   ' For XX = 1 To 2
   '     Form2.VScroll1(XX).Max = Form2.VScroll1(0).Max
   '     Form2.VScroll1(XX).LargeChange = Form2.VScroll1(0).LargeChange
   '     Form2.VScroll1(XX).Enabled = Form2.VScroll1(0).Enabled
   '     Form2.VScroll1(XX).Value = Form2.VScroll1(0).Value
   ' Next XX
End If
'XX = TNum
NLen = PB.TextWidth("AAA") * TSingle
NLen = NLen / OLen
SS = Abs(GetTickCount)
'First Draw all the lines
Pict = PB.hdc
PB.ForeColor = 0
TSH = PB.ScaleHeight
GoOn = 0

'XX = TDLen(TNum, TType, 2)
If PRat = 0 Then PRat = 1

Dim XMod As Single, TVN As String, MaxXPos As Single, CXP As Single
PB.DrawMode = 13


SS = Abs(GetTickCount)
Dim CharLen As Long
CharLen = PB.TextWidth("O")

'UBON = UBound(OriginalName, 1)
If TreeXScaleMod(FI, TNum, TType) = 0 Or x = x Then 'work out xscalemod so that sequence names will appear properly within the tree window
     
     MaxXPos = 0
     If TDLen(TNum, TType, 0) > UBTD5 Then TDLen(TNum, TType, 0) = UBTD5
     
     For x = 0 To TDLen(TNum, TType, 0)
        'If IStart + TreeDraw(TNum, TType, 0, 1, X) * tTYF >= -16 And IStart + TreeDraw(TNum, TType, 0, 1, X) * tTYF <= TSH + 16 Then
            
            CXP = TreeDraw(TNum, TType, 0, 0, x) / PRat
            AH1 = TreeDraw(TNum, TType, 0, 2, x)
            If AH1 > -1 Then
                
                If (AH1 <= UBON Or (TNum = 3 And TType = 2) Or (TNum = 3 And TType = 1)) Then
                
                    
                    'If TreeDraw(TNum, TType, 0, 2, X) <= UBON Or (TNum = 3 And TType = 2) Or (TNum = 3 And TType = 1) Then
                        
                        If TNum = 3 And TType = 0 Then
                            
                            TVN = OriginalName(AH1)
                        ElseIf TNum <> 0 Then
                            
                            
                            If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                                TVN = BigTreeName(AH1)
                            ElseIf TNum = 3 And TType = 1 Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                                TVN = BigTreeNameU(AH1)
                            Else
                                
                                If UBTTS1 > 0 Then
                                    If UBTTS2 >= x Then
                                        If UBTT >= TreeTraceSeqs(1, AH1) Then
                                            AH2 = TreeTraceSeqs(1, AH1)
                                            If TreeTrace(AH2) <= UBON Then
                                                TVN = OriginalName(TreeTrace(AH2))
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        
                        Else
                            
                            TVN = OriginalName(TreeDraw(TNum, TType, 0, 2, x))
                        End If
                    
                    'End If
                ElseIf TreeDraw(TNum, TType, 0, 3, x) > 0 Then
                    TVN = ""
                Else
                    TVN = ""
                End If
                
            ElseIf TreeDraw(TNum, TType, 0, 3, x) > 0 Then
                TVN = ""
            Else
                TVN = ""
            End If
            
            CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
            'CXP = CXP + PB.TextWidth(UCase(TVN))
            
            If CXP > MaxXPos Then
                MaxXPos = CXP
                
            End If
        'End If
     Next x
     
    'XX = OriginalName(wx)
     
    'If PB.hdc <> Form1.Picture16.hdc Then
    TreeXScaleMod(FI, TNum, TType) = PB.ScaleWidth / MaxXPos
    'End If
End If

XMod = TreeXScaleMod(FI, TNum, TType)

PRat = PRat / XMod

'Make sure the scalebar is in black
If TDLen(TNum, TType, 1) > UBTD5 Then TDLen(TNum, TType, 1) = UBTD5
TreeDraw(TNum, TType, 1, 4, TDLen(TNum, TType, 1)) = 0

'Draw the branches

OS = 0
GoOn = 0

If OnlyNames = 0 Then
    If x = 12345 Then
        Do
            Dummy = FindNextBranch(TSH, tTYF, IStart, TNum, TType, TDLen(TNum, TType, 1), OS, GoOn, x, TreeDraw(0, 0, 0, 0, 0))
            If x < TDLen(TNum, ttpe, 1) Then
                PB.ForeColor = TreeDraw(TNum, TType, 1, 4, x)
                Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 1, 1, x) * TSingle), PntAPI) '280,280,279
                Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, x) / PRat, (IStart + TreeDraw(TNum, TType, 1, 3, x) * TSingle))
                x = x + 1
            Else
               Exit Do
            End If
        
        Loop
    Else
    
        For x = 0 To TDLen(TNum, TType, 1)
            
            AH1 = IStart + TreeDraw(TNum, TType, 1, 1, x) * TSingle

            AH2 = IStart + TreeDraw(TNum, TType, 1, 3, x) * TSingle
            
            If AH1 >= 0 Or AH2 >= 0 Then
                
                If AH1 <= TSH Or AH2 <= TSH Then
                    
                    
                    PB.ForeColor = TreeDraw(TNum, TType, 1, 4, x)
                    Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, x) / PRat, AH1, PntAPI) '280,280,279
                    
                    Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, x) / PRat, AH2)
                   x = x
                Else
                    
                    If AH1 > OS Then
                        OS = AH1
                        GoOn = 1
                    End If
                End If
            End If
        Next x
    End If
End If
'Form1.SSPanel6(1).Visible = True




If GoOn = 0 Then
    PB.CurrentY = IStart + TreeDraw(TNum, TType, 1, 3, x - 1) * TSingle
End If

If OS < PB.CurrentY Then
    OS = PB.CurrentY + 44  'IStart + TreeDraw(TNum, TType, 1, 1, TDLen(TNum, TType, 1)) * tTYF
Else
    OS = OS + 44
End If
PB.DrawMode = 13
If OnlyNames = 0 Then
'Then Draw all legend the blocks
    
    If OS < TSH And TBLLen > 0 Then
        OFS = PB.FontSize
        PB.FontSize = 7
        Pict = PB.hdc
        If DebuggingFlag < 2 Then On Error Resume Next
       ' If TBS(TreeBlocksL(TNum, TType, 3, TBLLen + 1)) = "Major Parent" Then
       '     X = X
       ' End If
        On Error GoTo 0
        For x = 0 To UBTBL
            If TreeBlocksL(TNum, TType, 0, x) <> -1 Then
                If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                    GoOn = 1
                    If x > 1 Then
                        
                        If TBS(TreeBlocksL(TNum, TType, 2, x + 1)) = TBS(TreeBlocksL(TNum, TType, 2, x - 1)) Then
                            GoOn = 0
                        End If
                    End If
                    If GoOn = 1 Then
                        'PB.DrawMode = 9
                        PB.Line (TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x))-(TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x)), -TreeBlocksL(TNum, TType, 4, x), BF
                    End If
                    x = x
                Else
                    If TBS(TreeBlocksL(TNum, TType, 2, x)) <> "" And TreeBlocksL(TNum, TType, 0, x) <> 0 Then '"Potential recombinant " Then
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                            x = x
                        End If
                    Else
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                        
                            If (RelX > 0 Or RelY) > 0 And TreeBlocksL(TNum, TType, 0, x) <> 0 Then
                                Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                                x = x
                            End If
                        End If
                    End If
                End If
            End If
        Next x
        PB.FontSize = OFS
    End If
    
End If


PB.DrawMode = 13

'draw the maps


Dim XXMod As Single, XxXMod As Single
XxXMod = 1
If PB.FontSize = 8.25 Then
    XXMod = 1
ElseIf PB.FontSize = 7.5 Then
    XxXMod = 1.08
ElseIf PB.FontSize = 6.75 Then
    XxXMod = 1.05
ElseIf PB.FontSize = 6 Then
    XXMod = -30
   ' XXMod = 1
ElseIf PB.FontSize = 5.25 Then
    XxXMod = 1.05
ElseIf PB.FontSize = 4.5 Then
    XXMod = 1
ElseIf PB.FontSize = 3 Then
    XXMod = 0.98
ElseIf PB.FontSize = 2.25 Then
    XxXMod = 1.2
ElseIf PB.FontSize = 1.5 Then
    XXMod = 1
ElseIf PB.FontSize = 9 Then
    XxXMod = 1.05
ElseIf PB.FontSize = 9.75 Then
    XXMod = 1
ElseIf PB.FontSize = 11.25 Then
    XXMod = 1
ElseIf PB.FontSize = 12 Then
    XXMod = 1
ElseIf PB.FontSize = 13.5 Then

    XXMod = 1
ElseIf PB.FontSize = 14.25 Then

    XXMod = 1
ElseIf PB.FontSize = 15.75 Then
    XXMod = 1
ElseIf PB.FontSize = 16.5 Then
    XXMod = 1
Else
    XXMod = 1
End If
'XXMod = 1



XXMod = PB.FontSize / 8.258 * XxXMod
If OnlyNames = 0 Then
    
     'mark parents and recombinants
     For x = 0 To TBLen(TNum, TType)
            'XX = Form2.Picture2(0).AutoRedraw
            
            If x <= UBTB4 Then
                If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle >= 0 Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle >= 0 Then
                    If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle <= TSH Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle <= TSH Then
                            PB.DrawMode = 13
                            'If PRat > 1 Then
                            '    xPRat = PRat / (PRat ^ 0.55)
                            '    'xPRat = PRat
                            'Else
                            '    xPRat = PRat
                            'End If
                            
                            
                            PB.Line (TreeBlocks(TNum, TType, 0, x) / PRat, IStart + TreeBlocks(TNum, TType, 1, x) * TSingle + 1)-(TreeBlocks(TNum, TType, 0, x) / PRat + (TreeBlocks(TNum, TType, 2, x) - TreeBlocks(TNum, TType, 0, x)) * XXMod, IStart + TreeBlocks(TNum, TType, 3, x) * TSingle + 1), TreeBlocks(TNum, TType, 4, x), BF
                            x = x
                            'ttyf=0.566
                            'XX = ((TreeBlocks(TNum, TType, 0, X) + (TreeBlocks(TNum, TType, 2, X))) - TreeBlocks(TNum, TType, 0, X)) * XXMod - TreeBlocks(TNum, TType, 0, X)
                            'X = X
                    End If
                End If
            End If
        
    Next x
End If




If OnlyNames = 0 Then
    
    If NoP3Flag = 0 Then
        
        Form2.Picture3(TNum).ScaleMode = 3
        Form2.Picture3(TNum).AutoRedraw = True
        Form2.Picture3(TNum) = LoadPicture()
        Form2.Picture3(TNum).DrawMode = 13
        'draw the maps
        
        Dim XSize As Single
        SS = Abs(GetTickCount)
        'For AA = 0 To 10
        
        If x = x Then
        
            Call DrawmapsAA(Form2.Picture3(TNum), CLng(TType), CLng(TNum), IStart, TSingle, TSH)
        Else
            XSize = Form2.Picture3(TNum).ScaleWidth - 10
            For x = 1 To MapBlockNum(TType, TNum)
                'XX = Form2.Picture2(0).AutoRedraw
                
                
                If x <= UBMB4 Then
                    
                    AH1 = MapBlocks(TType, TNum, 2, x)
                    
                    If IStart + (AH1 + 13) * TSingle >= 0 Then
                        
                        
                        
                        If IStart + AH1 * TSingle <= TSH Then
                                
                                
                                
                                Form2.Picture3(TNum).Line ((5 + MapBlocks(TType, TNum, 0, x) * XSize), IStart + (AH1 + 4) * TSingle)-(5 + MapBlocks(TType, TNum, 1, x) * XSize, IStart + (AH1 + 13) * TSingle), MapBlocks(TType, TNum, 3, x), BF
                                'work out antialiasing line colours above and below
                                
                               x = x
                        End If
                    End If
                End If
                  
            Next x
        
            
            BPos = XoverList(RelX, RelY).Beginning
            Epos = XoverList(RelX, RelY).Ending
        
            If TNum = 1 Then
                If BPos < Epos Then
                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize, 0)-(5 + (Epos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                Else
                    Form2.Picture3(1).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (Epos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                End If
            ElseIf TNum = 2 Then
                If BPos < Epos Then
                    Form2.Picture3(2).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                    Form2.Picture3(2).Line (5 + (Epos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                Else
                    Form2.Picture3(2).Line (5 + (Epos / Len(StrainSeq(0))) * XSize - 1, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize + 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                End If
            End If
        End If
        
       ' Next AA
        EE = Abs(GetTickCount)
        TT = EE - SS
        x = x
        
        'do the legend
        OFS = PB.FontSize
        'For D = 0 To 3
        D = TNum
        Form2.Picture3(D).FontSize = 7
        Pict = Form2.Picture3(D).hdc
        'For X = 0 To 2
        
        
        'If TreeBlocksL(TNum, TType, 0, X) <> -1 Then
            
        
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 2)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 2), RGB(128, 128, 128), BF
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 17)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 17), RGB(220, 220, 220), BF
         Dim LText As String
         LText = "Considered nt sites"
         Dummy = TextOut(Pict, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1), LText, Len(LText))
         LText = "Ignored nt sites"
         Dummy = TextOut(Pict, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1) + 14, LText, Len(LText))
        
        Form2.Picture3(D).FontSize = OFS
   ' Next D
    'PB.FontSize = OFS
    x = x
    
    End If
End If
'Form2.ZOrder
'XX = IStart
'XX = PB.ScaleHeight
If NextNo = -1 Then TNum = oTNum: Exit Sub

PB.DrawMode = 13

O31FS = PB.FontSize
'Then write the names etc.
'Exit Sub
Pict = PB.hdc
'If DebuggingFlag < 2 Then On Error Resume Next

If DebuggingFlag < 2 Then On Error Resume Next

UBY = UBound(TreeTraceSeqs, 2)
UBX = UBound(TreeTraceSeqs, 1)


On Error GoTo 0

For x = 0 To TDLen(TNum, TType, 0)
    
    AH1 = IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle
    If AH1 >= -16 Then
        If AH1 <= TSH + 16 Then
            'PB.CurrentX = TreeDraw(TNum, TType, 0, 0, X)
            'PB.CurrentY = IStart + TreeDraw(TNum, TType, 0, 1, X) * tTYF
            AH2 = TreeDraw(TNum, TType, 0, 2, x)
            If OnlyNames = 0 Or AH2 = OnlyNamesFlag - 1 Then
                If AH2 > -1 And (AH2 <= UBON Or (TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4)) Or (TNum = 3 And TType = 1)) Then
                    If TNum = 0 And PB.hdc = Form1.Picture16.hdc Then
                        If SelGrpFlag = 0 Then
                            If MaskSeq(AH2) = 0 Then
                                PB.ForeColor = 0
                            ElseIf MaskSeq(AH2) = 1 Then
                                PB.ForeColor = QBColor(8)
                            Else
                                PB.ForeColor = ThreeQuaterColour
                            End If
                        Else
                            If GrpMaskSeq(AH2) = 0 Then
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = 0
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = QBColor(8)
                                Else
                                    PB.ForeColor = ThreeQuaterColour
                                End If
                            Else
                                
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = RGB(0, 0, 255)
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = RGB(120, 120, 255)
                                Else
                                    PB.ForeColor = RGB(170, 200, 255)
                                End If
                            End If
                        End If
                    
                    
                    Else
                        
                        If LongWindedFlag = 1 Then
                            If TNum <> 0 Then 'Or (TNum <> 3 And TType = 0) Then
                                  'Exit Sub
                                 'XX = PermNextNo
                                If (TNum = 3 And TType = 1) Then
                                    PB.ForeColor = MultColour(BigTreeTraceU(AH2))
                                ElseIf TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
                                    PB.ForeColor = MultColour(BigTreeTrace(AH2))
                                
                                ElseIf TNum = 3 And TType = 0 Then
                                    
                                    If UBTT > 0 Then
                                        If TreeDraw(TNum, TType, 0, 2, x) <= UBMC Then
                                            If TreeDraw(TNum, TType, 0, 2, x) <= UBTT Then
                                                PB.ForeColor = MultColour(TreeTrace((AH2)))
                                            End If
                                        End If
                                    End If
                               
                                Else
                                    If TreeDraw(TNum, TType, 0, 2, x) <= UBTTS2 Then
                                        If TreeTraceSeqs(1, AH2) <= UBTT Then
                                            
                                            If TreeTrace(TreeTraceSeqs(1, TreeTrace(AH2))) <= UBMC Then
                                                PB.ForeColor = MultColour(TreeTrace(TreeTraceSeqs(1, TreeTrace(AH2))))
                                            End If
                                        End If
                                    End If
                                End If
                            
                            Else
                                
                                If UBTT > 0 Then
                                    If AH2 <= UBMC Then
                                        If AH2 <= UBTT Then
                                            PB.ForeColor = MultColour(TreeTrace((AH2)))
                                        End If
                                    End If
                                End If
                            End If
                        Else
                            PB.ForeColor = MultColour(AH2)
                            
                        End If
                    End If
                    'PB.print originalname(TreeDraw(TNum, TType, 0, 2, X))
                    'If originalname(TreeDraw(TNum, TType, 0, 2, X)) = "SACMV-[M12].seq" Then
                    '    X = X
                    'End If
                    If TreeDraw(TNum, TType, 0, 2, x) <= UBON Or (TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4)) Or (TNum = 3 And TType = 1) Then
                        If TNum <> 0 Then
                            'If TreeDraw(TNum, TType, 0, 2, X) = 13 Then
                            '    X = X
                            'End If
                            If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                                TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), BigTreeName(TreeDraw(TNum, TType, 0, 2, x)), Len(BigTreeName(TreeDraw(TNum, TType, 0, 2, x)))
                                'If X = 40 Then
                                '    X = X
                                'End If
                            ElseIf TNum = 3 And TType = 1 Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                                TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), BigTreeNameU(TreeDraw(TNum, TType, 0, 2, x)), Len(BigTreeNameU(TreeDraw(TNum, TType, 0, 2, x)))
                                x = x
                            ElseIf TNum = 3 And TType = 0 Then
                                TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), OriginalName(TreeDraw(TNum, TType, 0, 2, x)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                                x = x
                            Else
                                'If TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, X)) <= UBound(OriginalName, 1) Then
                                'TextOut Pict, TreeDraw(TNum, TType, 0, 0, X) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, X) * tTYF), OriginalName(TreeDraw(TNum, TType, 0, 2, X)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, X)))
                                AH1 = TreeDraw(TNum, TType, 0, 2, x)
                                If UBTTS2 >= AH1 And UBTT >= TreeTraceSeqs(1, AH1) Then
                                    If TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x))) <= UBON Then
                                        
                                        AH2 = TreeTraceSeqs(1, AH1)
                                        AH3 = TreeTrace(AH2)
                                        TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), OriginalName(AH3), Len(OriginalName(AH3))
                                        x = x
                                        
                                    End If
                                End If
                                'Else
                                    x = x 'acdblmm
                                'End If
                            End If
                        
                        Else
                            
                            AH1 = TreeDraw(TNum, TType, 0, 2, x)
                            
                            TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), OriginalName(AH1), Len(OriginalName(AH1))
                            x = x
                        End If
                        x = x
                    End If
                    
                ElseIf TreeDraw(TNum, TType, 0, 3, x) > 0 Then
                    PB.FontSize = 6 * TSingle
                    PB.ForeColor = RGB(0, 100, 0)
                    'PB.Print TreeDraw(TNum, TType, 0, 3, X)
                    ScaleX = Trim(Str(TreeDraw(TNum, TType, 0, 3, x)))
                    If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                    TextOut Pict, (TreeDraw(TNum, TType, 0, 0, x) + 1) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), ScaleX, Len(ScaleX)
                    x = x
                Else
                    PB.FontSize = 8.25 * TSingle
                    If PB.FontSize < 7 Then PB.FontSize = 7
                    PB.ForeColor = RGB(0, 0, 0)
                    ScaleL = -TreeDraw(TNum, TType, 0, 3, x) / 10000
                    ScaleX = Trim(Str(ScaleL))
                    If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                    'PB.Print ScaleX
                    TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat, (IStart + TreeDraw(TNum, TType, 0, 1, x) * TSingle), ScaleX, Len(ScaleX)
                   
                End If
            End If
        End If
    End If
Next x
'On Error GoTo 0

'For X = 0 To TDLen(TNum, TType, 0) - 1
   ' If BigTreeName(70) = Trim("0.0001") Then
   '     X = X
   ' End If
'Next X
PB.FontSize = O31FS




x = x
'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=sequencename,1 = line)
        'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = bs value)
        'E = element number
  TNum = oTNum
  
  
  If Form2.Visible = True And x = 12345 Then
        Index = TNum
        'For Index = 0 To 3
            With Form2.VScroll1(Index)
                
                VSMax = .Max
                If VSMax <= 0 Then .Value = 0
                OV = .Value
                OM = VSMax
                If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBTD5 Then
                    VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * oTSingle) + 200
                Else
                    VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * oTSingle) + 200
                End If
                If OM = 0 Then OM = 1
                If VSMax > 32000 Then
                    F2VSScaleFactor(Index) = VSMax / 32000
                    VSMax = 32000
                Else
                    F2VSScaleFactor(Index) = 1
                End If
                If DebuggingFlag < 2 Then On Error Resume Next
               ' If .Value / (OM / VSMax) <= VSMax Then
               '     .Value = (.Value / (OM / VSMax))
               ' ElseIf VSMax > 0 Then
               '     .Value = VSMax
               ' End If
                If VSMax <= 0 Then
                    .Enabled = False
                Else
                    .LargeChange = Form2.Picture2(Index).ScaleHeight
                    .Enabled = True
                End If
                .Max = VSMax
                On Error GoTo 0
    
                If TDLen(Index, CurTree(Index), 1) > 0 Then
                    If ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * oTSingle) + 200 <= Form2.Picture2(Index).ScaleHeight Then
                         If .Value > 0 Then .Value = 0
                        .Enabled = False
                    Else
                        .Enabled = True
                        
                        '.VScroll1(X).Max = -.Picture2(X).ScaleHeight + (Nextno + 6) * 17
                        '.VScroll1(X).LargeChange = .Picture2(X).ScaleHeight
                    End If
                Else
                    .Enabled = False
                End If
            End With
        'Next Index
    End If
  PB.Refresh
Form2.Picture3(TNum).Refresh

End Sub
Public Sub TreeDrawing(OnlyNames, NoP3Flag, TreeBlocksL() As Long, TBLLen As Long, TNF As Byte, OriginalName() As String, IStart As Long, TNum, TType, TreeDrawB() As Single, TDLen() As Long, TreeBlocks() As Long, TBLen() As Long, PB As PictureBox)


Dim UBY As Long, UBX As Long, D As Long, Dummy As Long, VSMax As Long, OVx As Single, OM As Long, OV As Long, OVy As Long, otTYF As Single, PRat As Single, GoOn As Long, TSH As Long, PntAPI As POINTAPI, Pict3 As Long, Pict As Long, OFS As Double, x As Long, ScaleX As String, ScaleL As Double, TargY As Single
Dim tTYF As Double, TYFM As Integer, OS As Long, oTNum As Long, TSingle As Single, oTSingle As Single, TDL1 As Long, TDL0 As Long, TBL As Long
Dim UBTTS1 As Long, UBTTS2 As Long, UBTT As Long
Dim UBTD5 As Long, UBON As Long, UBTBL As Long, UBTB4 As Long, UBMB4 As Long, UBMC As Long
Dim AH1 As Long, AH2 As Long, AH3 As Long, AH4 As Long
Dim XMod As Single, TVN As String, MaxXPos As Single, CXP As Single
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number


If TYF2 = 0 Then Exit Sub
If CurrentlyRunningFlag = 1 Then Exit Sub

TDL1 = TDLen(TNum, TType, 1)
TDL0 = TDLen(TNum, TType, 0)

If TDL1 = 0 And TDL0 = 0 Then Exit Sub

If OnlyNamesFlag > 0 Then
    OnlyNames = 1
End If

Dim tONameLen() As Integer
ReDim tONameLen(UBound(ONameLen))
For x = 0 To UBound(ONameLen)
    If ONameLen(x) > 40 Then
        tONameLen(x) = 40
    Else
        tONameLen(x) = ONameLen(x)
    End If
Next x

PRat = -1: oTNum = TNum
If DebuggingFlag < 2 Then On Error Resume Next
PRat = TDLen(TNum, TType, 2) / PB.ScaleWidth '384
If PRat = -1 Then Exit Sub
On Error GoTo 0




If TDL1 = 0 Then
    NoP3Flag = 1
    TNum = 0
    TNF = 0
End If

Dim FI As Byte

PB.AutoRedraw = True
'
'PB.Picture = LoadPicture()
'XX = PB.hDC


''''
Pict = PB.hdc
'Pict = 1
'PB.Height = 2000
''''
PB.Line (0, 0)-(PB.Width, PB.Height), BackColours, BF 'this clears the trees

If Pict = Form1.Picture16.hdc Then
    FI = 1
Else
    FI = 0
End If
' XX = PB.Height '19020,17660
'This makes sure dots etc are reset to 0
'SelectNode(0) = -1

PB.ScaleMode = 3
PB.FontSize = 8.25

PB.FontSize = PB.FontSize * TYF2

Call ModOffsets(8.25, PB, tTYF, TYFM)

otTYF = tTYF
TSingle = tTYF
oTSingle = otTYF

If DebuggingFlag < 2 Then On Error Resume Next
UBMC = UBound(MultColour, 1)
If UBMC < (NextNo * 2) Then
    ReDim Preserve MultColour(NextNo * 2)
End If
UBMB4 = UBound(MapBlocks, 4)
UBTB4 = UBound(TreeBlocks, 4)
UBTD5 = UBound(TreeDraw, 5)
UBTTS2 = UBound(TreeTraceSeqs, 2)
UBTTS1 = UBound(TreeTraceSeqs, 1)
UBTT = UBound(TreeTrace, 1)
UBON = UBound(OriginalName)
UBTBL = UBound(TreeBlocksL, 4)
On Error GoTo 0
'TDHits = TDHits + 1
'Form2.Caption = TDHits
'do picture16 stuff
If FI = 1 Then 'PB = Form1.Picture16 Then
    
    
    OVy = VSC1NC
    VSC1NC = 1
    With Form1.VScroll1
        If .Max <= 0 Then .Value = 0
        OV = .Value
        OM = .Max
        If OM > 0 Then
            OVx = OV / OM
        Else
            OVx = 1
        End If
        
        If TDLen(TNum, CTF, 1) > 0 And UBTD5 >= TDLen(TNum, CTF, 1) Then
            VSMax = -PB.ScaleHeight + ((TreeDrawB(1, TDLen(TNum, CTF, 1), TNum, CTF, 1) + 1) * oTSingle) + 200 'PB.ScaleHeight = 806; ctf = 0; ottyf =1,018, treetypeflag = 2
            '464
        ElseIf UBTD5 >= TDLen(0, 1, 1) Then
            VSMax = -PB.ScaleHeight + ((TreeDrawB(1, TDLen(0, 1, 1), TNum, CTF, 1) + 1) * oTSingle) + 200
        End If
        If OM = 0 Then OM = 1
        If VSMax > 32000 Then
            F1VS1ScaleFactor = CSng(VSMax / 32000) '38409'1.033
            VSMax = 32000
        Else
            F1VS1ScaleFactor = 1
            x = x
        End If
        
        .Max = VSMax '-Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
        If .Max > 0 And OM > 0 Then
            If OVx * VSMax <= .Max Then
                .Value = OVx * VSMax
            ElseIf .Max > 0 Then
                .Value = .Max
            End If
        End If
        If .Max <= 0 Then
            .Enabled = False
        Else
            If Form1.Picture9.ScaleHeight = 0 Then Exit Sub
            .LargeChange = Form1.Picture9.ScaleHeight
            .Enabled = True
        End If
        
    End With
    VSC1NC = OVy
    IStart = IStart * F1VS1ScaleFactor
Else
    IStart = IStart * F2VSScaleFactor(TNum)
End If



'First Draw all the lines

PB.ForeColor = 0
'
PB.DrawMode = 13
TSH = PB.ScaleHeight

GoOn = 0

If PRat = 0 Then PRat = 1

'SS = Abs(GetTickCount)
Dim CharLen As Long
CharLen = PB.TextWidth("O")
MaxXPos = 0
If TDL0 > UBTD5 Then TDLen(TNum, TType, 0) = UBTD5: TDL0 = UBTD5
If (TNum = 3 And TType = 0) Or (TNum = 3 And TType = 1) Then
    For x = 0 To TDL0
            CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
            
            AH1 = TreeDrawB(2, x, TNum, TType, 0)
            If AH1 > -1 Then
                If AH1 <= UBON Then
                        
                    'TVN = OriginalName(AH1)
                    CXP = CXP + CharLen * (tONameLen(AH1) + 2)

                
                End If

            
            End If
            
            'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
            If CXP > MaxXPos Then
                MaxXPos = CXP
                
            End If
     Next x

ElseIf TNum <> 0 Then
    If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
        For x = 0 To TDL0
                CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
                
                AH1 = TreeDrawB(2, x, TNum, TType, 0)
                If AH1 > -1 Then
                    
                    If AH1 <= UBON Or TType = 2 Or TType = 4 Then
                           ' TVN = BigTreeName(AH1)
                            CXP = CXP + CharLen * (Len(BigTreeName(AH1)) + 2)
                    
                    End If

                
                End If
                
                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
                If CXP > MaxXPos Then
                    MaxXPos = CXP
                End If
         Next x
    Else
        If x = x Then
            MaxXPos = GetMaxXPosB(UBound(TreeTraceSeqs, 1), UBound(TreeTraceSeqs, 2), UBound(TreeTrace, 1), CharLen, TNum, TType, TDL0, UBON, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, tONameLen(0), TreeDrawB(0, 0, 0, 0, 0), TreeTraceSeqs(0, 0), TreeTrace(0))
            x = x
'            If MaxXPos < PB.Width / 10 Then
'                MaxXPos = PB.Width / 10
'            End If
            'MaxXPos = PB.ScaleWidth
        Else
            For x = 0 To TDL0
                    
                CXP = TreeDrawB(0, x, TNum, TType, 0) / PRat
                
                AH1 = TreeDrawB(2, x, TNum, TType, 0)
                If AH1 > -1 Then
                    
                    If AH1 <= UBON Then
                        
                        If UBTTS1 > 0 Then
                            If UBTTS2 >= x Then
                                AH2 = TreeTraceSeqs(1, AH1)
                                If UBTT >= AH2 Then
                                    If TreeTrace(AH2) <= UBON Then
                                        'TVN = OriginalName()
                                        CXP = CXP + CharLen * (tONameLen(TreeTrace(AH2)) + 2)
                                    End If
                                End If
                            End If
                        End If
    
                    End If
    
                End If
                
                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
                If CXP > MaxXPos Then
                    MaxXPos = CXP
                End If
             Next x
        End If
    End If

Else
     '
     If UBON > 0 Then
'     If X = 12345 Then
        MaxXPos = GetMaxXPos(CharLen, TNum, TType, TDL0, UBON, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, tONameLen(0), TreeDrawB(0, 0, 0, 0, 0))
       
'    Else
'         For X = 0 To TDL0
'
'                CXP = TreeDrawB(0, X, TNum, TType, 0) / PRat
'
'                AH1 = TreeDrawB(2, X, TNum, TType, 0)
'                If AH1 > -1 Then
'                    If AH1 <= UBON Then
'                        'TVN = OriginalName(AH1)
'                        CXP = CXP + CharLen * (ONameLen(AH1) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
'
'                    End If
'
'                End If
'
'                'CXP = CXP + CharLen * (Len(TVN) + 2) 'PB.TextWidth(String(Len(TVN) + 2, "O"))
'                If CXP > MaxXPos Then '569.6
'                    MaxXPos = CXP
'
'                End If
'         Next X
'    End If
        
    End If
    x = x
End If
'XX = MaxONameLen
TreeXScaleMod(FI, TNum, TType) = PB.ScaleWidth / MaxXPos
XMod = TreeXScaleMod(FI, TNum, TType)

PRat = PRat / XMod

'Make sure the scalebar is in black
If TDL1 > UBTD5 Then TDLen(TNum, TType, 1) = UBTD5: TDL1 = UBTD5
TreeDraw(TNum, TType, 1, 4, TDL1) = 0
TreeDrawB(4, TDL1, TNum, TType, 1) = 0

'******************
'*Draw the branches
'******************
OS = 0
GoOn = 0
Dim TargetA As Single, TSHx As Single

TSHx = (TSH - IStart) / TSingle
TargetA = -(IStart / TSingle)
'If OnlyNames = 0 Then
'    If X = 12345 Then
'        Do
'            Dummy = FindNextBranch(TSH, tTYF, IStart, TNum, TType, TDLen(TNum, TType, 1), OS, GoOn, X, TreeDraw(0, 0, 0, 0, 0))
'            If X < TDLen(TNum, ttpe, 1) Then
'                PB.ForeColor = TreeDraw(TNum, TType, 1, 4, X)
'                Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, X) / PRat, (IStart + TreeDraw(TNum, TType, 1, 1, X) * TSingle), PntAPI) '280,280,279
'                Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, X) / PRat, (IStart + TreeDraw(TNum, TType, 1, 3, X) * TSingle))
'                X = X + 1
'            Else
'               Exit Do
'            End If
'
'        Loop
'    Else
 'If X = 12345 Then
 
 
 
' If X = 12345 Then
    '''
    GoOn = DrawTreeLines(Pict, IStart, TSHx, TargetA, TNum, TType, TDL1, UBound(TreeDrawB, 1), UBound(TreeDrawB, 2), UBound(TreeDrawB, 3), UBound(TreeDrawB, 4), PRat, TSingle, OS, TreeDrawB(0, 0, 0, 0, 0))
    
' Else
'
'        For X = 0 To TDL1
'        'For X = LastSE(TNum, TType, 0) To LastSE(TNum, TType, 1)
'
'            AH1 = TreeDrawB(1, X, TNum, TType, 1)
'
'            AH2 = TreeDrawB(3, X, TNum, TType, 1)
'
'            If AH1 >= TargetA Or AH2 >= TargetA Then
'
'
'
'                If AH1 <= TSHx Or AH2 <= TSHx Then
'                    'AH1 = X
'                    'AH2 = X
''                    If RedoLastSE(TNum) = 0 Then
''                        RedoLastSE(TNum) = 1
''                        LastSE(TNum, TType, 0) = X
''                    End If
'
'                    PB.ForeColor = TreeDrawB(4, X, TNum, TType, 1)
'
'                    Dummy = MoveToEx(Pict, TreeDrawB(0, X, TNum, TType, 1) / PRat, IStart + AH1 * TSingle, PntAPI) '280,280,279
'
'                    Dummy = LineTo(Pict, TreeDrawB(2, X, TNum, TType, 1) / PRat, IStart + AH2 * TSingle)
'                    'LastSE(TNum, TType, 1) = X
'                Else
'
'                    If AH1 > OS Then
'                        OS = AH1
'                        GoOn = 1
'                    End If
'                End If
'            End If
'        Next X
'    End If

'Form1.SSPanel6(1).Visible = True

'End If

x = TDL1 + 1

If GoOn = 0 Then
    PB.CurrentY = IStart + TreeDrawB(3, x - 1, TNum, TType, 1) * TSingle
End If

If OS < PB.CurrentY Then
    OS = PB.CurrentY + 44  'IStart + TreeDraw(TNum, TType, 1, 1, TDLen(TNum, TType, 1)) * tTYF
Else
    OS = OS + 44
End If

PB.DrawMode = 13


'*********************************
'*Then Draw all legend  blocks
'********************************
If TNum = 3 And TType >= 2 Then
    If OS < TSH And TBLLen > 0 Then
        OFS = PB.FontSize
        PB.FontSize = 7
        Pict = PB.hdc
        For x = 0 To UBTBL
            If TreeBlocksL(TNum, TType, 0, x) <> -1 Then
                If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                    PB.Line (TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x))-(TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x)), -TreeBlocksL(TNum, TType, 4, x), BF
                Else
                    If TBS(TreeBlocksL(TNum, TType, 2, x)) <> "" And TreeBlocksL(TNum, TType, 0, x) <> 0 Then '"Potential recombinant " Then
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                            'X = X
                        End If
                    Else
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                        
                            If (RelX > 0 Or RelY) > 0 And TreeBlocksL(TNum, TType, 0, x) <> 0 Then
                                Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                                x = x
                            End If
                        End If
                    End If
                End If
            End If
        Next x
        PB.FontSize = OFS
    End If

Else

    If OS < TSH And TBLLen > 0 Then
        OFS = PB.FontSize
        PB.FontSize = 7
        'Pict = PB.hDC
        
        For x = 0 To UBTBL
            If TreeBlocksL(TNum, TType, 0, x) <> -1 Then
                If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                    GoOn = 1
                    If x > 1 Then
                        
                        If TBS(TreeBlocksL(TNum, TType, 2, x + 1)) = TBS(TreeBlocksL(TNum, TType, 2, x - 1)) Then
                            GoOn = 0
                        End If
                    End If
                    If GoOn = 1 Then
                        PB.Line (TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x))-(TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x)), -TreeBlocksL(TNum, TType, 4, x), BF
                    End If
                    x = x
                Else
                    If TBS(TreeBlocksL(TNum, TType, 2, x)) <> "" And TreeBlocksL(TNum, TType, 0, x) <> 0 Then '"Potential recombinant " Then
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                        End If
                    Else
                        GoOn = 1
                        If x > 1 Then
                            
                            If TBS(TreeBlocksL(TNum, TType, 2, x)) = TBS(TreeBlocksL(TNum, TType, 2, x - 2)) Then
                                GoOn = 0
                            End If
                        End If
                        If GoOn = 1 Then
                        
                            If (RelX > 0 Or RelY) > 0 And TreeBlocksL(TNum, TType, 0, x) <> 0 Then
                                Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                                x = x
                            End If
                        End If
                    End If
                End If
            End If
        Next x
        PB.FontSize = OFS
    End If
End If

'*******************************
'*mark parents and recombinants
'******************************
Dim XXMod As Single, XxXMod As Single
XxXMod = 1

If PB.FontSize = 7.5 Then
    XxXMod = 1.08
ElseIf PB.FontSize = 6.75 Then
    XxXMod = 1.05

ElseIf PB.FontSize = 5.25 Then
    XxXMod = 1.05

ElseIf PB.FontSize = 2.25 Then
    XxXMod = 1.2

ElseIf PB.FontSize = 9 Then
    XxXMod = 1.05
End If

XXMod = PB.FontSize / 8.258 * XxXMod
TBL = TBLen(TNum, TType)
 
For x = 0 To TBL
        
    If x <= UBTB4 Then
        If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle >= 0 Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle >= 0 Then
            If IStart + TreeBlocks(TNum, TType, 1, x) * TSingle <= TSH Or IStart + TreeBlocks(TNum, TType, 3, x) * TSingle <= TSH Then
                    
                    PB.Line (TreeBlocks(TNum, TType, 0, x) / PRat, IStart + TreeBlocks(TNum, TType, 1, x) * TSingle + 1)-(TreeBlocks(TNum, TType, 0, x) / PRat + (TreeBlocks(TNum, TType, 2, x) - TreeBlocks(TNum, TType, 0, x)) * XXMod, IStart + TreeBlocks(TNum, TType, 3, x) * TSingle + 1), TreeBlocks(TNum, TType, 4, x), BF
            End If
        End If
    End If
    
Next x



If OnlyNames = 0 Then
    
    If NoP3Flag = 0 Then
        
        Form2.Picture3(TNum).ScaleMode = 3
        Form2.Picture3(TNum).AutoRedraw = True
        Form2.Picture3(TNum) = LoadPicture()
        Form2.Picture3(TNum).DrawMode = 13
        'draw the maps
        
        Dim XSize As Single
        
        'For AA = 0 To 10
        
'        If X = X Then
'            SS = abs(gettickcount)
'            For X = 1 To 1000
                Call DrawmapsAA(Form2.Picture3(TNum), CLng(TType), CLng(TNum), IStart, TSingle, TSH)
'            Next X
'            EE = abs(gettickcount)
'            TT = EE - SS '6.422'8.569 seconds using dibsection'21.969
            x = x
'        Else
'            XSize = Form2.Picture3(TNum).ScaleWidth - 10
'            For X = 1 To MapBlockNum(TType, TNum)
'                'XX = Form2.Picture2(0).AutoRedraw
'
'
'                If X <= UBMB4 Then
'
'                    AH1 = MapBlocks(TType, TNum, 2, X)
'
'                    If IStart + (AH1 + 13) * TSingle >= 0 Then
'
'
'
'                        If IStart + AH1 * TSingle <= TSH Then
'
'
'
'                                Form2.Picture3(TNum).Line ((5 + MapBlocks(TType, TNum, 0, X) * XSize), IStart + (AH1 + 4) * TSingle)-(5 + MapBlocks(TType, TNum, 1, X) * XSize, IStart + (AH1 + 13) * TSingle), MapBlocks(TType, TNum, 3, X), BF
'                                'work out antialiasing line colours above and below
'
'                               X = X
'                        End If
'                    End If
'                End If
'
'            Next X
'
'
'            BPos = XOverlist(RelX, RelY).Beginning
'            EPos = XOverlist(RelX, RelY).Ending
'
'            If TNum = 1 Then
'                If BPos < EPos Then
'                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                Else
'                    Form2.Picture3(1).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                End If
'            ElseIf TNum = 2 Then
'                If BPos < EPos Then
'                    Form2.Picture3(2).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                    Form2.Picture3(2).Line (5 + (EPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                Else
'                    Form2.Picture3(2).Line (5 + (EPos / Len(StrainSeq(0))) * XSize - 1, 0)-(5 + (BPos / Len(StrainSeq(0))) * XSize + 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
'                End If
'            End If
'        End If
        
       ' Next AA
        
        
        'do the legend
        OFS = PB.FontSize
        'For D = 0 To 3
        D = TNum
        
        Form2.Picture3(D).Font = Form2.Picture2(D).Font
        Form2.Picture3(D).FontSize = 7
        Pict3 = Form2.Picture3(D).hdc
        'For X = 0 To 2
        
        
        'If TreeBlocksL(TNum, TType, 0, X) <> -1 Then
            
         'Form2.Picture3(D).FontSize = Form2.Picture2(D).FontSize
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 2)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 2), RGB(128, 128, 128), BF
         Form2.Picture3(D).Line (TreeBlocksL(D, CurTree(D), 0, 0), OS + TreeBlocksL(D, CurTree(D), 1, 0) + 17)-(TreeBlocksL(D, CurTree(D), 2, 0), OS + TreeBlocksL(D, CurTree(D), 3, 0) + 17), RGB(220, 220, 220), BF
         Dim LText As String
         LText = "Considered nt sites"
'         XX = Form2.Picture3(D).Width / Screen.TwipsPerPixelX
'         XX = Form2.Picture3(D).TextWidth(LText)
         If CurTree(D) + Form2.Picture3(D).TextWidth(LText) > Form2.Picture3(D).Width / Screen.TwipsPerPixelX Then
            LText = "Considered nts"
         End If
         'if form2.picture3
         Dummy = TextOut(Pict3, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1), LText, Len(LText))
         If LText = "Considered nts" Then
            LText = "Ignored nts"
         Else
            LText = "Ignored nt sites"
         End If
         Dummy = TextOut(Pict3, TreeBlocksL(D, CurTree(D), 0, 1), OS + TreeBlocksL(D, CurTree(D), 1, 1) + 14, LText, Len(LText))
        
        Form2.Picture3(D).FontSize = OFS
    
    End If
End If

If NextNo = -1 Then TNum = oTNum: Exit Sub

PB.DrawMode = 13

O31FS = PB.FontSize


'Then write the names etc.

If DebuggingFlag < 2 Then On Error Resume Next

UBY = UBound(TreeTraceSeqs, 2)
UBX = UBound(TreeTraceSeqs, 1)

On Error GoTo 0


If TNum = 0 And FI = 1 Then
    For x = 0 To TDL0
        'AH2 = TreeDrawB(2, X, TNum, TType, 0) 'the sequence number
        AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle 'y cocord
        If AH1 >= -16 Then
            If AH1 <= TSH + 16 Then
                AH2 = TreeDrawB(2, x, TNum, TType, 0) 'the sequence number
                    If AH2 > -1 And (AH2 <= UBON) Then
                        
                        If SelGrpFlag = 0 Then
                            If MaskSeq(AH2) = 0 Then
                                PB.ForeColor = 0
                            ElseIf MaskSeq(AH2) = 1 Then
                                PB.ForeColor = QBColor(8)
                            Else
                                PB.ForeColor = ThreeQuaterColour
                            End If
                        Else
                            If GrpMaskSeq(AH2) = 0 Then
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = 0
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = QBColor(8)
                                Else
                                    PB.ForeColor = ThreeQuaterColour
                                End If
                            Else
                                
                                If MaskSeq(AH2) = 0 Then
                                    PB.ForeColor = RGB(0, 0, 255)
                                ElseIf MaskSeq(AH2) = 1 Then
                                    PB.ForeColor = RGB(120, 120, 255)
                                Else
                                    PB.ForeColor = RGB(170, 200, 255)
                                End If
                            End If
                        End If
                        
                        If AH2 <= UBON Then
                            'AH3 = TreeDrawB(2, X, TNum, TType, 0)
'                            If AH2 > 19 Then
'                                X = X
'                            End If
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), Len(OriginalName(AH2))
                        End If
                        
                    ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                        PB.FontSize = 6 * TSingle
                        PB.ForeColor = RGB(0, 100, 0)
                        ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                    Else
                        PB.FontSize = 8.25 * TSingle
                        If PB.FontSize < 7 Then PB.FontSize = 7
                        PB.ForeColor = RGB(0, 0, 0)
                        ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                        ScaleX = Trim(Str(ScaleL))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                       
                    End If
                'End If
            End If
        End If
    Next x

Else
    If TNum <> 0 Then
        
        If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
            For x = 0 To TDL0
                
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TSH + 16 Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                            If AH2 > -1 Then
                                PB.ForeColor = MultColour(BigTreeTrace(AH2))
                                'If TreeDrawB(2, X, TNum, TType, 0) <= UBON Or (TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4)) Then
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, BigTreeName(AH2), Len(BigTreeName(AH2))
                                'End If
                            ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                                PB.FontSize = 6 * TSingle
                                PB.ForeColor = RGB(0, 100, 0)
                                'PB.Print TreeDraw(TNum, TType, 0, 3, X)
                                ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                                If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                                TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                                x = x
                            Else
                                PB.FontSize = 8.25 * TSingle
                                If PB.FontSize < 7 Then PB.FontSize = 7
                                PB.ForeColor = RGB(0, 0, 0)
                                ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                                ScaleX = Trim(Str(ScaleL))
                                If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                                'PB.Print ScaleX
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                               
                            End If
                        'End If
                    End If
                End If
            Next x
        ElseIf (TNum = 3 And TType = 0) Or (TNum = 3 And TType = 1) Then
            
            For x = 0 To TDL0
                
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TSH + 16 Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                        If AH2 > -1 And AH2 <= UBON Then
                                 
                            If UBTT > 0 Then
                                If AH2 <= UBMC Then
                                    If AH2 <= UBTT Then
                                        PB.ForeColor = MultColour(TreeTrace((AH2)))
                                    End If
                                End If
                            End If
                            
                            If AH2 <= UBON Then
                                'AH1 = TreeDrawB(2, X, TNum, TType, 0)
                                TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), tONameLen(AH2)
                                
                            End If
                            
                        ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                            PB.FontSize = 6 * TSingle
                            PB.ForeColor = RGB(0, 100, 0)
                            ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                            x = x
                        Else
                            PB.FontSize = 8.25 * TSingle
                            If PB.FontSize < 7 Then PB.FontSize = 7
                            PB.ForeColor = RGB(0, 0, 0)
                            ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                            ScaleX = Trim(Str(ScaleL))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                           
                        End If
                        
                    End If
                End If
            Next x
            
        Else
            TargY = TSH + 16
            'zzz = 0
            For x = 0 To TDL0
                '
                AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
                If AH1 >= -16 Then
                    If AH1 <= TargY Then
                        AH2 = TreeDrawB(2, x, TNum, TType, 0)
                        If AH2 > -1 And (AH2 <= UBON) Then
                            AH4 = TreeTraceSeqs(1, AH2)
                            If AH2 <= UBTTS2 And UBTT >= AH4 Then
                                If AH4 <= UBTT Then
                                    AH3 = TreeTrace(AH4)
                                    If AH3 <= UBMC Then
                                        PB.ForeColor = MultColour(AH3)
                                    End If
                                
                            
                                    
                                    If AH3 <= UBON Then
                                        'zzz = zzz + 1
                                        ''''''''
                                        'prat=797
                                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH3), Len(OriginalName(AH3))
                                       
                                       ' X = X
                                    End If
                                End If
                            End If
                            
                            
                        ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                            PB.FontSize = 6 * TSingle
                            PB.ForeColor = RGB(0, 100, 0)
                            'PB.Print TreeDraw(TNum, TType, 0, 3, X)
                            ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                        Else
                            PB.FontSize = 8.25 * TSingle
                            If PB.FontSize < 7 Then PB.FontSize = 7
                            PB.ForeColor = RGB(0, 0, 0)
                            ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                            ScaleX = Trim(Str(ScaleL))
                            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                            'PB.Print ScaleX
                            TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                           
                        End If
                        'End If
                    End If
                End If
            Next x
            x = x
        End If
    Else
        
        If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
            GoOn = 1
        Else
            GoOn = 0
        End If
        For x = 0 To TDL0
            '''
            AH1 = IStart + TreeDrawB(1, x, TNum, TType, 0) * TSingle
            If AH1 >= -16 Then
                If AH1 <= TSH + 16 Then
                    AH2 = TreeDrawB(2, x, TNum, TType, 0)
                    If AH2 > -1 And (AH2 <= UBON Or GoOn = 1) Then
                        If UBTT > 0 Then
                            If AH2 <= UBMC Then
                                '
                                If AH2 <= UBTT Then
                                    PB.ForeColor = MultColour(TreeTrace((AH2)))
                                End If
                            End If
                        End If
                        '
                        
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, OriginalName(AH2), Len(OriginalName(AH2))
                        
                    ElseIf TreeDrawB(3, x, TNum, TType, 0) > 0 Then
                        PB.FontSize = 6 * TSingle
                        PB.ForeColor = RGB(0, 100, 0)
                        ScaleX = Trim(Str(TreeDrawB(3, x, TNum, TType, 0)))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, (TreeDrawB(0, x, TNum, TType, 0) + 1) / PRat, AH1, ScaleX, Len(ScaleX)
                    Else
                        PB.FontSize = 8.25 * TSingle
                        If PB.FontSize < 7 Then PB.FontSize = 7
                        PB.ForeColor = RGB(0, 0, 0)
                        ScaleL = -TreeDrawB(3, x, TNum, TType, 0) / 10000
                        ScaleX = Trim(Str(ScaleL))
                        If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                        TextOut Pict, TreeDrawB(0, x, TNum, TType, 0) / PRat, AH1, ScaleX, Len(ScaleX)
                       
                    End If
                End If
            End If
        Next x
    End If
End If
'On Error GoTo 0


PB.FontSize = O31FS

TNum = oTNum
'''
PB.Refresh
If FI = 0 Then
    Form1.Picture3.Refresh
End If
If OnlyNames = 0 Then
    Form2.Picture3(TNum).Refresh
End If


End Sub

Public Sub TreedrawingEMF(TreeBlocksL() As Long, TBLLen As Long, TNF As Byte, OriginalName() As String, IStart As Long, TNum, TType, TreeDrawB() As Single, TDLen() As Long, TreeBlocks() As Long, TBLen() As Long, PB As PictureBox)

Dim GoOn As Byte, TSH As Long, PntAPI As POINTAPI, Pict As Long, OFS As Double, NLen As Double, OLen As Double, x As Long, ScaleX As String, ScaleL As Double
Dim O31FS As Double, tTYF As Double, TYFM As Integer, OS As Long
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
    
Dim MhDC As Long, PH As Long, LBrush As LOGBRUSH

'First Draw all the lines
SSS = Abs(GetTickCount)
 

Dim rct As RECT
    Dim LoFnt As Long

    If SaveFlag = 1 Then

        With Form1.CommonDialog1
            .FileName = ""
            '.InitDir = currentdir
            .DefaultExt = ".emf"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "EMF File (*.emf)|*.emf"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            semfname$ = .FileName  'Stores selected file name in the
            'string, fname$.
            semfnameII = .FileTitle
        End With

    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "tmp2.emf"
        On Error GoTo 0
        semfnameII = "tmp2.emf"
        semfname$ = "tmp2.emf"
    End If
'Exit Sub
    
    PointX = GetDeviceCaps(Form1.Picture16.hdc, 88) '88 = logpixelsx
    PointY = GetDeviceCaps(Form1.Picture16.hdc, 90) '90 = logpixelsy
    
    PointX = (Form1.Picture16.ScaleWidth * PointX / 72) * Screen.TwipsPerPixelX
    PointY = ((NextNo * 12) * PointY / 72) * Screen.TwipsPerPixelY
    
    rct.Bottom = PointY '(Nextno * 12)
    
    'Exit Sub
    rct.Left = 0
    rct.Top = 0
    rct.Right = PointX '18000
    


Dim LFnt2 As Long, Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
'For zz = 0 To 1000
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, semfname$, rct, "")
    Form1.Picture1.AutoRedraw = True
    'Get original Metafile font and pen
    
    
    LoFnt = CreateFont(8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    Pict = MhDC
    
    
    'Form1.Picture6.FillStyle = 0
    'Dummy = SetPolyFillMode(Pict, 0)
    
    PEN = CreatePenIndirect(LPen)
    oldpen = SelectObject(Pict, PEN)
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    

TYF = 1
tTYF = 1
OLen = 36
NLen = 1


'First Draw all the lines
Pict = MhDC


GoOn = 0
IStart = 0
TSH = 100000
For x = 0 To TDLen(TNum, TType, 1)
    'If IStart + TreeDraw(TNum, TType, 1, 1, X) * tTYF >= 0 Or IStart + TreeDraw(TNum, TType, 1, 3, X) * tTYF >= 0 Then
        'If IStart + TreeDraw(TNum, TType, 1, 1, X) * tTYF <= TSH Or IStart + TreeDraw(TNum, TType, 1, 3, X) * tTYF <= TSH Then
            'PB.Line (TreeDraw(TNum, TType, 1, 0, X), IStart + TreeDraw(TNum, TType, 1, 1, X) * tTYF)-(TreeDraw(TNum, TType, 1, 2, X), IStart + TreeDraw(TNum, TType, 1, 3, X) * tTYF), 0
            LBrush.lbColor = TreeDraw(TNum, TType, 1, 4, x)
            Brush = CreateBrushIndirect(LBrush)
            Dummy = SelectObject(Pict, Brush)
            Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, x), IStart + TreeDraw(TNum, TType, 1, 1, x) * tTYF, PntAPI)
            Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, x), IStart + TreeDraw(TNum, TType, 1, 3, x) * tTYF)
        'Else
        '    If IStart + TreeDraw(TNum, TType, 1, 1, X) * tTYF > OS Then
        '        OS = IStart + TreeDraw(TNum, TType, 1, 1, X) * tTYF
        '        GoOn = 1
        '    End If
        'End If
    'End If
Next x

If x = 12345 Then
'Then Draw all the blocks

'If OS < TSH And TBLLen > 0 Then
    OFS = PB.FontSize
    PB.FontSize = 7
    Pict = PB.hdc
    For x = 0 To TBLLen
        If TreeBlocksL(TNum, TType, 3, x) > 0 Then
            PB.DrawMode = 9
            PB.Line (TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x))-(TreeBlocksL(TNum, TType, 2, x), OS + TreeBlocksL(TNum, TType, 3, x)), -TreeBlocksL(TNum, TType, 4, x), BF
        Else
            Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x), TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
        End If
    Next x
    
'End If

For x = 0 To TBLen(TNum, TType)
    If IStart + TreeBlocks(TNum, TType, 1, x) * tTYF >= 0 Or IStart + TreeBlocks(TNum, TType, 3, x) * tTYF >= 0 Then
        If IStart + TreeBlocks(TNum, TType, 1, x) * tTYF <= TSH Or IStart + TreeBlocks(TNum, TType, 3, x) * tTYF <= TSH Then
                PB.DrawMode = 9
                PB.Line (TreeBlocks(TNum, TType, 0, x), IStart + TreeBlocks(TNum, TType, 1, x) * tTYF)-(TreeBlocks(TNum, TType, 0, x) + (TreeBlocks(TNum, TType, 2, x) - TreeBlocks(TNum, TType, 0, x) + 5) * tTYF, IStart + TreeBlocks(TNum, TType, 3, x) * tTYF), TreeBlocks(TNum, TType, 4, x), BF
        End If
    End If
Next x
XX = PB.ScaleHeight
If NextNo = -1 Then Exit Sub
If UBound(MultColour, 1) < (NextNo * 2) Then
ReDim Preserve MultColour(NextNo * 2)
End If
PB.DrawMode = 13

O31FS = PB.FontSize
'Then write the names etc.
'Exit Sub
Pict = PB.hdc
'If DebuggingFlag < 2 Then On Error Resume Next



For x = 0 To TDLen(TNum, TType, 0)
    If IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF >= -16 And IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF <= TSH + 16 Then
        'PB.CurrentX = TreeDraw(TNum, TType, 0, 0, X)
        'PB.CurrentY = IStart + TreeDraw(TNum, TType, 0, 1, X) * tTYF
        If TreeDraw(TNum, TType, 0, 2, x) > -1 And TreeDraw(TNum, TType, 0, 2, x) <= NextNo Then
            If TNF = 0 Then
                If SelGrpFlag = 0 Then
                    If MaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 0 Then
                        PB.ForeColor = 0
                    ElseIf MaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 1 Then
                        PB.ForeColor = QBColor(8)
                    Else
                        PB.ForeColor = ThreeQuaterColour
                    End If
                Else
                    If GrpMaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 0 Then
                        PB.ForeColor = 0
                    Else
                        PB.ForeColor = RGB(0, 0, 255)
                    End If
                End If
            Else
                If TNum <> 0 Then
                      'Exit Sub
                     'XX = PermNextNo
                    If TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x))) <= UBound(MultColour, 1) Then
                        PB.ForeColor = MultColour(TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x))))
                    End If
                Else
                    If TreeDraw(TNum, TType, 0, 2, x) <= UBound(MultColour, 1) Then
                        PB.ForeColor = MultColour(TreeTrace((TreeDraw(TNum, TType, 0, 2, x))))
                    End If
                End If
            End If
            'PB.print originalname(TreeDraw(TNum, TType, 0, 2, X))
            'If originalname(TreeDraw(TNum, TType, 0, 2, X)) = "SACMV-[M12].seq" Then
            '    X = X
            'End If
            If TreeDraw(TNum, TType, 0, 2, x) <= UBound(OriginalName, 1) Then
                If TNum <> 0 Then
                    TextOut Pict, TreeDraw(TNum, TType, 0, 0, x), IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF, OriginalName(TreeDraw(TNum, TType, 0, 2, x)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                Else
                    TextOut Pict, TreeDraw(TNum, TType, 0, 0, x), IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF, OriginalName(TreeDraw(TNum, TType, 0, 2, x)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                End If
            Else
                x = x
            End If
        ElseIf TreeDraw(TNum, TType, 0, 3, x) > 0 Then
            PB.FontSize = 6 * tTYF
            PB.ForeColor = RGB(0, 100, 0)
            'PB.Print TreeDraw(TNum, TType, 0, 3, X)
            ScaleX = Trim(Str(TreeDraw(TNum, TType, 0, 3, x)))
            TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) + 1, IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF, ScaleX, Len(ScaleX)
        Else
            PB.FontSize = 8.25 * tTYF
            If PB.FontSize < 7 Then PB.FontSize = 7
            PB.ForeColor = RGB(0, 0, 0)
            ScaleL = -TreeDraw(TNum, TType, 0, 3, x) / 10000
            ScaleX = Trim(Str(ScaleL))
            If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
            'PB.Print ScaleX
            TextOut Pict, TreeDraw(TNum, TType, 0, 0, x), IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF, ScaleX, Len(ScaleX)
        End If
    End If
Next x
'On Error GoTo 0

End If
Brush = SelectObject(Pict, OldBrush)
DeleteObject (Brush)
PEN = SelectObject(Pict, oldpen)
DeleteObject (PEN)

LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject (LoFnt)
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    
    If SaveFlag = 0 Then
        Clipboard.Clear
        If DebuggingFlag < 2 Then On Error Resume Next
        Clipboard.SetData LoadPicture("tmp2.emf"), 3
        
        KillFile "tmp2.emf"
        On Error GoTo 0
    End If

'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=sequencename,1 = line)
        'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = bs value)
        'E = element number
        

End Sub
Public Sub ModOffsets(OSize As Double, RefPic As PictureBox, tTYF As Double, TYFM As Integer)
    
    Dim FS As Double
    If OSize = 0 Then: tTYF = 1: Exit Sub
    XX = RefPic.FontSize
    tTYF = RefPic.FontSize / OSize
    FS = RefPic.FontSize
    If tTYF = 1 Then
        If Form1.Picture1.FontSize = P1FontSize Then 'some systems have fonts with different basic sizes
            
            XConA = Form1.Picture1.TextWidth("A")
            XConA = XConA / 8
            
        Else
            
            XConA = 1
            
        End If
        
        Exit Sub
    Else
        'XConA = Form1.Picture1.TextWidth("A")
        'XConA = XConA / 8
    End If
    If FS >= 19.1 And FS <= 20 Then '19.5
        
        XConA = Form1.Picture1.TextWidth("A") / 16
        If XConA = 1 Then
            tTYF = tTYF * 1
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 1
    ElseIf FS >= 18.25 And FS < 19.1 Then '18.75
        
        XConA = Form1.Picture1.TextWidth("A") / 15
        If XConA = 1 Then
            tTYF = tTYF * 0.975
        Else
            tTYF = tTYF * 0.968
        End If
        TYFM = 1
    ElseIf FS >= 17.75 And FS < 18.25 Then '18
        
        XConA = Form1.Picture1.TextWidth("A") / 14
        If XConA = 1 Then
            tTYF = tTYF * 0.948
        Else
            tTYF = tTYF * 0.933
        End If
        TYFM = 1
    ElseIf FS >= 17.45 And FS < 17.75 Then 'FS = 17.25 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 14
        If XConA = 1 Then
            tTYF = tTYF * 0.989
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 1
    ElseIf FS >= 17.35 And FS < 17.45 Then 'FS = 17.25 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 14
        If XConA = 1 Then
            tTYF = tTYF * 0.989
        Else
            tTYF = tTYF * 0.966
        End If
        TYFM = 1
    ElseIf FS >= 16.75 And FS < 17.35 Then 'FS = 17.25 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 14
        If XConA = 1 Then
            tTYF = tTYF * 0.9895
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 1
    ElseIf FS >= 16# And FS < 16.75 Then   'FS = 16.5 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 13
        If XConA = 1 Then
            tTYF = tTYF * 0.961
        Else
            tTYF = tTYF * 0.963
        End If
        TYFM = 1
    ElseIf FS >= 15.25 And FS < 16 Then 'FS = 15.75 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 13
        If XConA = 1 Then
            tTYF = tTYF * 1.007
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 1
    ElseIf FS >= 14.75 And FS < 15.25 Then  'FS = 15 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 12
        If XConA = 1 Then
            tTYF = tTYF * 0.975
        Else
            tTYF = tTYF * 0.96
        End If
        TYFM = 1
    ElseIf FS >= 13.9 And FS < 14.75 Then  'FS = 14.25 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 11
        If XConA = 1 Then
            tTYF = tTYF * 0.943
        Else
            tTYF = tTYF * 0.917
        End If
        TYFM = 1
    ElseIf FS >= 13 And FS < 13.9 Then  'FS = 13.5 Then
        
        
         XConA = Form1.Picture1.TextWidth("A") / 11
        If XConA = 1 Then
            tTYF = tTYF * 0.9935
        ElseIf XConA > 1.27 And XConA < 1.28 And tTYF > 1.43 And tTYF < 1.44 Then
            tTYF = tTYF * 0.957
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 1
    ElseIf FS >= 12.5 And FS < 13 Then  'FS = 12.75 Then
        XConA = Form1.Picture1.TextWidth("A") / 10
        
        If XConA = 1 Then
            tTYF = tTYF * 0.956
        ElseIf XConA = 1.3 And tTYF > 1.312 And tTYF < 1.313 Then
            tTYF = tTYF * 0.953
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 2
    ElseIf FS >= 11.75 And FS < 12.5 Then  'FS = 12 Then
        XConA = Form1.Picture1.TextWidth("A") / 10
        If XConA = 1 Then
            tTYF = tTYF * 1.0158
        Else
            tTYF = tTYF * 1
        End If
        TYFM = 2
    ElseIf FS >= 11.05 And FS < 11.75 Then 'FS = 11.25 Then
        XConA = Form1.Picture1.TextWidth("A") / 9
        If XConA = 1 Then
            tTYF = tTYF * 0.975
        Else
            tTYF = tTYF * 0.947
        End If
        
        TYFM = 2
    ElseIf FS >= 10.75 And FS < 11.05 Then 'FS = 10.8 Then
        
        XConA = Form1.Picture1.TextWidth("A") / 8
        If XConA = 1 Then
            tTYF = tTYF * 0.9775
        ElseIf XConA = 1.375 And tTYF > 1.125 And tTYF < 1.126 Then
            tTYF = tTYF * 0.89
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 3
    ElseIf FS >= 10.25 And FS < 10.75 Then 'FS = 10.5 Then
         XConA = Form1.Picture1.TextWidth("A") / 8
        If XConA = 1 Then
            tTYF = tTYF * 0.9287
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 3
    ElseIf FS >= 9.5 And FS < 10.25 Then 'FS = 9.75 Then
         XConA = Form1.Picture1.TextWidth("A") / 8
        If XConA = 1 Then
            tTYF = tTYF * 1
        ElseIf XConA = 1.25 And tTYF > 1.062 And tTYF < 1.063 Then
            tTYF = tTYF * 0.941
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 2
        
    ElseIf FS >= 8.75 And FS < 9.5 Then 'FS = 9# Then
         XConA = Form1.Picture1.TextWidth("A") / 7
        If XConA = 1 Then
            tTYF = tTYF * 0.948
        Else
            tTYF = tTYF * 0.934
        End If
        
        
        TYFM = 2
    ElseIf FS >= 7.9 And FS < 8.75 Then 'FS = 8.25 Then
         XConA = Form1.Picture1.TextWidth("A") / 7
        If XConA = 1 Then
            tTYF = tTYF * 1.03425
        Else
            tTYF = tTYF * 1
        End If
        
       
        TYFM = 2
    ElseIf FS >= 7.25 And FS < 7.9 Then 'FS = 7.5 Then
         XConA = Form1.Picture1.TextWidth("A") / 6
        If XConA = 1 Then
            tTYF = tTYF * 0.975
        Else
            tTYF = tTYF * 0.924
        End If
        
        
        TYFM = 1
    ElseIf FS >= 6.5 And FS < 7.25 Then 'FS = 6.75 Then
        XConA = Form1.Picture1.TextWidth("A") / 5
        If XConA = 1 Then
            tTYF = tTYF * 0.903
        ElseIf XConA = 1.4 And tTYF >= 0.75 And tTYF < 0.76 Then
            tTYF = tTYF * 0.834
        ElseIf XConA = 1.4 And tTYF >= 0.65 And tTYF < 0.75 Then
            tTYF = tTYF * 0.91
        ElseIf XConA = 1.4 And tTYF >= 0.91 And tTYF < 0.93 Then
            tTYF = tTYF * 0.69
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 3
    ElseIf FS >= 5.75 And FS < 6.5 Then 'FS = 6# Then
         XConA = Form1.Picture1.TextWidth("A") / 5
        If XConA = 1 Then
            tTYF = tTYF * 1.016
        Else
            tTYF = tTYF * 1
        End If
        
        
        TYFM = -1
    ElseIf FS >= 4.9 And FS < 5.75 Then 'FS = 5.25 Then
         XConA = Form1.Picture1.TextWidth("A") / 4
        If XConA = 1 Then
            tTYF = tTYF * 0.9287
        Else
            tTYF = tTYF * 0.89
        End If
        
        
        TYFM = 1
    ElseIf FS >= 4.3 And FS < 4.9 Then 'FS = 4.5 Then
         XConA = Form1.Picture1.TextWidth("A") / 4
        If XConA = 1 Then
            tTYF = tTYF * 1.084
        Else
            tTYF = tTYF * 1
        End If
        
        
        TYFM = -1
    ElseIf FS >= 4.1 And FS < 4.3 Then 'FS = 4.5 Then
        XConA = Form1.Picture1.TextWidth("A") / 4
        If XConA = 1 Then
            tTYF = tTYF * 1.143
        Else
            tTYF = tTYF * 1
        End If
        
        
        TYFM = -1
    ElseIf FS >= 3.4 And FS < 4.1 Then 'FS = 3.75 Then
     XConA = Form1.Picture1.TextWidth("A") / 3
        If XConA = 1 Then
            tTYF = tTYF * 0.975
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 0
       
    ElseIf FS >= 2.75 And FS < 3.4 Then 'FS = 3# Then
        
         XConA = Form1.Picture1.TextWidth("A") / 2
        If XConA = 1 Then
            tTYF = tTYF * 0.8125
        Else
            tTYF = tTYF * 0.8
        End If
        
        TYFM = 0
    ElseIf FS >= 1.8 And FS < 2.75 Then 'FS = 2.25 Then
         XConA = Form1.Picture1.TextWidth("A") / 2
        If XConA = 1 And tTYF > 0.249 And tTYF < 0.251 Then
            tTYF = tTYF * 1
        ElseIf XConA = 1 Then
            tTYF = tTYF * 1.0834
        Else
            tTYF = tTYF * 1
        End If
        
        
        TYFM = -1
    ElseIf FS < 1.8 Then 'FS = 1.5 Then
        
         XConA = Form1.Picture1.TextWidth("A") / 1
        If XConA = 1 Then
            tTYF = tTYF * 0.81
        ElseIf XConA = 2 And tTYF > 0.187 And tTYF < 0.188 Then
            tTYF = tTYF * 0.66
        Else
            tTYF = tTYF * 1
        End If
        
        TYFM = 0
    End If
   
End Sub

Public Sub PrintNames3(P3 As PictureBox, Prg As Byte, NumberOfSeqs As Long, RevSeq() As Integer, SSOLSeqName As String)
Dim x As Long, NumAdd As Long, tTYF As Double, num As Long, TYFM As Integer
If RelX = 0 And RelY = 0 Then Exit Sub
P3.Enabled = False
P3.AutoRedraw = True
P3.Picture = LoadPicture()
VSV = Form1.VScroll3.Value / ScrollSF
ReDim GTCSNum(NextNo)
Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
If XoverList(RelX, RelY).OutsideFlag <> 1 Then
    P3.ForeColor = RGB(0, 192, 0)
Else
    P3.ForeColor = RGB(0, 92, 0)
End If
If ttyfAdjust = 0 Then ttyfAdjust = 1
P3.CurrentX = 1
P3.CurrentY = -VSV + 0
P3.Print OriginalName(TreeTrace(Seq1))
GTCSNum(0) = TreeTrace(Seq1)

P3.ForeColor = RGB(255, 0, 0)


If (Prg = 1 Or Prg = 1 + AddNum) And GCtripletflag = 0 Then
    
        If Seq1 <> Seq2 Then
            P3.CurrentX = 1
            P3.CurrentY = -VSV + 13 * tTYF * ttyfAdjust
            P3.Print OriginalName(TreeTrace(Seq2))
            GTCSNum(1) = TreeTrace(Seq2)
            P3Seq2Pos = 1
            If SpacerNo > 0 Then
                P3.ForeColor = QBColor(8)
                UB = UBound(SpacerSeqs, 1)
                For x = 1 To SpacerNo
                    P3.CurrentX = 1
                    P3.CurrentY = -VSV + 26 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust * NumAdd
                    NumAdd = NumAdd + 1
                    If x <= UB Then
                        If TreeTrace(SpacerSeqs(x)) <= UBound(OriginalName, 1) Then
                            P3.Print OriginalName(TreeTrace(SpacerSeqs(x)))
                            GTCSNum(NumAdd) = TreeTrace(TreeTrace(SpacerSeqs(x)))
                        Else
                            x = x
                            'P3.Print StraiName(TreeTrace(SpacerSeqs(X)))
                        End If
                    End If
                Next 'X
    
            End If
    
        Else
    
            If SpacerNo > 0 Then
                P3.ForeColor = QBColor(8)
                UB = UBound(SpacerSeqs, 1)
                For x = 1 To SpacerNo
                    
                    P3.CurrentX = 1
                    P3.CurrentY = -VSV + x * 13 * tTYF * ttyfAdjust
                    If x <= UB Then
                        If TreeTrace(SpacerSeqs(x)) <= UBound(OriginalName, 1) Then
                            P3.Print OriginalName(TreeTrace(SpacerSeqs(x)))
                            GTCSNum(x + 1) = TreeTrace(TreeTrace(SpacerSeqs(x)))
                        End If
                    End If
                Next 'X
    
            End If
    
        End If
    
ElseIf (Prg = 3 Or Prg = 3 + AddNum) And MCTripletFlag = 1 Then
    P3.CurrentX = 1
    P3.CurrentY = -VSV + 13 * tTYF * ttyfAdjust
    P3.Print OriginalName(TreeTrace(Seq2))
    GTCSNum(2) = TreeTrace(TreeTrace(Seq2))
    P3Seq2Pos = 2
    P3.ForeColor = QBColor(8)
    If SpacerNo > 0 Then
        UB = UBound(SpacerSeqs, 1)
        For x = 1 To SpacerNo
            
            P3.CurrentX = 1
            P3.CurrentY = -VSV + (x + 1) * 13 * tTYF * ttyfAdjust
            If x <= UB Then
                If TreeTrace(SpacerSeqs(x)) <= UBound(OriginalName, 1) Then
                    P3.Print OriginalName(TreeTrace(SpacerSeqs(x)))
                End If
            End If
        Next 'X
        
    End If
ElseIf (Prg = 6 Or Prg = 6 + AddNum) Then
    
    P3.CurrentX = 1
    P3.CurrentY = -VSV + 13 * tTYF * ttyfAdjust
    P3.Print OriginalName(TreeTrace(Seq3))
    GTCSNum(1) = TreeTrace(TreeTrace(Seq3))
    P3.CurrentX = 1
    P3.CurrentY = -VSV + 25 * tTYF * ttyfAdjust
    
    If XoverList(RelX, RelY).OutsideFlag <> 2 Then
        P3.ForeColor = RGB(0, 0, 255)
    Else
        P3.ForeColor = RGB(0, 0, 128)
    End If
    
    P3.Print OriginalName(TreeTrace(Seq2))
    GTCSNum(2) = TreeTrace(TreeTrace(Seq2))
    P3Seq2Pos = 2
    P3.ForeColor = QBColor(8)
    num = 2
    For x = 0 To NumberOfSeqs
        If RevSeq(x) <> Seq1 And RevSeq(x) <> Seq2 And RevSeq(x) <> Seq3 Then
            num = num + 1
            P3.CurrentX = 1
            P3.CurrentY = -VSV + num * 13 * tTYF * ttyfAdjust
            P3.Print OriginalName(TreeTrace(RevSeq(x)))
            GTCSNum(num) = TreeTrace(TreeTrace(RevSeq(x)))
        End If
    Next 'X

Else
    P3.CurrentX = 1
    P3.CurrentY = -VSV + 13 * tTYF * ttyfAdjust
    If TreeTrace(Seq3) <= UBound(OriginalName, 1) Then
        P3.Print OriginalName(TreeTrace(Seq3))
        GTCSNum(1) = TreeTrace(TreeTrace(Seq3))
    End If
    
    Dim SEN As Long
    NumAdd = 0
    SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    P3.ForeColor = RGB(255, 128, 128)
    
    If ShowSeqFlag = 1 And Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
        For x = 0 To PermNextno
            If x <> TreeTrace(Seq3) And Daught(SEN, TreeTrace(x)) > 0 Then
                
                P3.CurrentY = -VSV + 26 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust * NumAdd
                NumAdd = NumAdd + 1
                P3.Print OriginalName(TreeTrace(x))
                GTCSNum(NumAdd + 1) = TreeTrace(TreeTrace(TreeTrace(x)))
            End If
        Next x
    End If
    P3.CurrentX = 1
    P3.CurrentY = -VSV + 26 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust * NumAdd
    
    If XoverList(RelX, RelY).OutsideFlag <> 2 Then
        P3.ForeColor = RGB(0, 0, 255)
    Else
        P3.ForeColor = RGB(0, 0, 128)
    End If
    
    P3.Print OriginalName(TreeTrace(Seq2))
    GTCSNum(NumAdd + 2) = TreeTrace(TreeTrace(Seq2))
    P3Seq2Pos = NumAdd + 2
    NumAdd = NumAdd + 1
    
    If Prg = 5 Or Prg = 5 + AddNum Then
        P3.ForeColor = QBColor(8)
        P3.CurrentX = 1
        
        P3.CurrentY = -VSV + 26 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust * NumAdd
        P3.Print "Outlyer (" & SSOLSeqName & ")"
        P3.ForeColor = QBColor(0)
    ElseIf SpacerNo > 0 Then
        P3.ForeColor = QBColor(8)
        UB = UBound(SpacerSeqs, 1)
        For x = 1 To SpacerNo
            P3.CurrentX = 1
            
            P3.CurrentY = -VSV + 26 * tTYF * ttyfAdjust + 13 * tTYF * ttyfAdjust * NumAdd
            NumAdd = NumAdd + 1
            If x <= UB Then
                If TreeTrace(SpacerSeqs(x)) <= UBound(OriginalName, 1) Then
                    P3.Print OriginalName(TreeTrace(SpacerSeqs(x)))
                    GTCSNum(NumAdd) = TreeTrace(TreeTrace(SpacerSeqs(x)))
                Else
                    x = x
                    'P3.Print StraiName(TreeTrace(SpacerSeqs(X)))
                End If
            End If
        Next 'X

    End If
                
End If




P3.ForeColor = QBColor(0)
P3.Refresh
P3.Enabled = True
P3.AutoRedraw = False

End Sub


Public Sub RecombMapPerms(CV() As Double, Win As Long, PermNum As Long, RNDSEED As Long)
    Dim PPos As Long, Target(1) As Long, MaxV(1) As Double, MaxP(1) As Long, MaxVals() As Long, NewStart As Long, S As Long, NS As Long, NE As Long, LSSeq As Long, RecSize As Long, MaxS As Long, MaP() As Integer, Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    
    If PermSeqNumInFile = 1 Then
        
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    
    End If
    
    
    ReDim MaP(1, Len(StrainSeq(0)), PermNum), MaxVals(1, PermNum)
    Rnd (-BSRndNumSeed)
    For x = 1 To ENumb
        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).MissIdentifyFlag <> 3 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).MissIdentifyFlag <> 13 Then
            If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 Then
                CNum = 0
                If LongWindedFlag = 0 Then
                    SEN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber
                Else
                    SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
                End If
                
                For Z = 0 To AddNum - 1
                    If Confirm(SEN, Z) > 0 Then
                        CNum = CNum + 1
                    End If
                Next Z
                
                If CNum > ConsensusProg Then
                    D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                    P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                    P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    
                    'Make variable sites array
                    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
                    LSSeq = 0
                    For A = 1 To Len(StrainSeq(0))
                        
                        XPosDiff(A) = LSSeq
                        If PermSeqNum(A, D) <> 46 Then
                            If PermSeqNum(A, P1) <> 46 Then
                                If PermSeqNum(A, P2) <> 46 Then
                                    If PermSeqNum(A, D) <> PermSeqNum(A, P1) Or PermSeqNum(A, D) <> PermSeqNum(A, P2) Then
                                        LSSeq = LSSeq + 1
                                        XPosDiff(A) = LSSeq
                                        XDiffPos(LSSeq) = A
                                    End If
                                End If
                            End If
                        End If
                    Next A
                    If EN > ST Then
                        RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                    Else
                        RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                    End If
                    If CircularFlag = 1 Then
                        MaxS = LSSeq - RecSize
                    Else
                        MaxS = LSSeq
                    End If
                    'Make new ending and start for this event
                
                    For A = 1 To PermNum
                        NewStart = Int((MaxS * Rnd) + 1)
                        NS = XDiffPos(NewStart)
                        If NewStart + RecSize <= LSSeq Then
                            NE = XDiffPos(NewStart + RecSize)
                        Else
                            NE = XDiffPos((NewStart + RecSize) - LSSeq)
                        End If
                    
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                            For D = 0 To 1
                            
                                If D = 0 Then
                                    GoOn = 0
                                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 Then
                                        S = NS: GoOn = 1
                                    End If
                                Else
                                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 Then
                                        S = NE: GoOn = 1
                                    End If
                                End If
                            
                                If GoOn = 1 Then
                                    For b = S - Int(Win / 2) To S + Int(Win / 2)
                                        If b < 1 Then
                                            C = Len(StrainSeq(0)) + b
                                        ElseIf b > Len(StrainSeq(0)) Then
                                            C = b - Len(StrainSeq(0))
                                        Else
                                            C = b
                                        End If
                                        MaP(0, C, A) = MaP(0, C, A) + 1
                                    Next b
                                End If
                            Next D
                        End If
                        If NS < NE Then
                            For b = NS To NE
                                MaP(1, b, A) = MaP(1, b, A) + 1
                            Next b
                        
                        Else
                            For b = NS To Len(StrainSeq(0))
                                MaP(1, b, A) = MaP(1, b, A) + 1
                            Next b
                            For b = 1 To NE
                                MaP(1, b, A) = MaP(1, b, A) + 1
                            Next b
                            
                        End If
                     Next A
                
               
                    
    
                End If
            End If
    
        End If
    Next x
    
    
    If PermSeqNumInFile = 1 Then
        
        ReDim PermSeqNum(0, 0)
        
    End If
    
    'get maxes
    For x = 1 To PermNum
        For Y = 1 To Len(StrainSeq(0))
            If MaxVals(0, x) < MaP(0, Y, x) Then MaxVals(0, x) = MaP(0, Y, x)
            If MaxVals(1, x) < MaP(1, Y, x) Then MaxVals(1, x) = MaP(1, Y, x)
        Next Y
        x = x
    Next x
    'sort through the top 5% and get the 99% and 95% highest scores
    
    Target(1) = CLng(0.05 * PermNum)
    Target(0) = CLng(0.01 * PermNum)
    For Z = 0 To 1
        If Target(Z) < 1 Then Target(Z) = 1
    Next Z
    For Z = 1 To Target(1)
        MaxV(0) = 0
        MaxV(1) = 0
        For x = 0 To PermNum
            If MaxV(0) < MaxVals(0, x) Then
                MaxV(0) = MaxVals(0, x)
                MaxP(0) = x
            End If
            If MaxV(1) < MaxVals(1, x) Then
                MaxV(1) = MaxVals(1, x)
                MaxP(1) = x
            End If
        Next x
        If Z = Target(0) Then
            CV(0, 0) = MaxV(0)
            CV(1, 0) = MaxV(1)
        End If
        If Z = Target(1) Then
            CV(0, 1) = MaxV(0)
            CV(1, 1) = MaxV(1)
        End If
        MaxVals(0, MaxP(0)) = 0
        MaxVals(1, MaxP(1)) = 0
    Next Z
    
End Sub
Public Sub DoProgLine(TotT As Double)
Dim PWidth As Long, PHeight As Long, CurXpos As Long
PWidth = Form3.Picture27.Width - 100
    PHeight = Form3.Picture27.Height - 50
    CurXpos = 25
    Form3.Picture27.Picture = LoadPicture()
    If TotT = 0 Then TotT = 1
    If DoScans(0, 0) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-((CurXpos + AnalT(0) / TotT * PWidth), Form3.Picture27.Height - 50), ProgColour(0), BF
        CurXpos = CurXpos + AnalT(0) / TotT * PWidth
    End If

    CurXpos = CurXpos + 1

    If DoScans(0, 1) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(1) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(1), BF
        CurXpos = CurXpos + AnalT(1) / TotT * PWidth
    End If

    If DoScans(0, 2) = 1 Or DoScans(1, 2) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(2) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(2), BF
        CurXpos = CurXpos + AnalT(2) / TotT * PWidth
    End If

    If DoScans(0, 3) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(3) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(3), BF
        CurXpos = CurXpos + AnalT(3) / TotT * PWidth
    End If

    If DoScans(0, 4) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(4) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(4), BF
        CurXpos = CurXpos + AnalT(4) / TotT * PWidth
    End If

    If DoScans(0, 5) = 1 Or DoScans(1, 5) = 1 Then
        Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(5) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(5), BF
        CurXpos = CurXpos + AnalT(5) / TotT * PWidth
    End If
    
    If DoScans(0, 6) = 1 Then
         Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(6) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(6), BF
        CurXpos = CurXpos + AnalT(6) / TotT * PWidth
    
    End If
    If DoScans(0, 8) = 1 Then
         Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(8) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(8), BF
        CurXpos = CurXpos + AnalT(8) / TotT * PWidth
    
    End If
    If DoScans(0, 7) = 1 Or DoScans(1, 7) = 1 Then
         Form3.Picture27.Line (CurXpos, 20)-(CurXpos + AnalT(7) / TotT * PWidth, Form3.Picture27.Height - 50), ProgColour(7), BF
        CurXpos = CurXpos + AnalT(7) / TotT * PWidth
    
    End If
    
    Form3.Picture27.Refresh
End Sub
Public Sub GetTot(TotT As Double)
    Dim TempTot As Single, TempDiv As Single, oSEventNumber As Long, EE As Long, SS As Long, Cnt As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, x As Long, TimeMod As Double, GoOn As Byte, LRDMod As Variant, ModifierX As Variant
    
    TimeMod = 1
    If ShowPlotFlagT = 1 Then
        TimeMod = TimeMod * 1.5
    ElseIf ShowPlotFlagT = 2 Then
        TimeMod = TimeMod * 1.25
    End If
    If Form3.Check13 = 1 Then
        TimeMod = TimeMod * 4
    End If
    
    If NextNo > 0 Then
        LenStrainSeq = Len(StrainSeq(0))
    Else
        Exit Sub
    End If
    For x = 0 To 7
        TBench(x) = 0
    Next x
    
    
    AnalT(1) = 0
    AnalT(0) = 0
    AnalT(1) = 0
    AnalT(2) = 0
    AnalT(3) = 0
    AnalT(4) = 0
    AnalT(5) = 0
    AnalT(6) = 0
    AnalT(7) = 0
    AnalT(8) = 0
    
    If NextNo > 0 And RelX = 0 And RelY = 0 Then
        Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
    End If
    
    
    
    
    AnalT(6) = 20
    If DoScans(1, 7) > 0 Then
        'If LRDRegion = 1 Then
        '    AnalT(7) = 20
        'Else
            ModifierX = ((Len(StrainSeq(0)) / LRDStep) * (Len(StrainSeq(0)) / LRDStep)) * 0.1
            AnalT(7) = (NextNo + 1) * ModifierX
        'End If
        If NextNo < 0 Then
            AnalT(7) = AnalT(7) * (LRDStep / 10000)
        End If
    End If
    
    
    TotT = 0
    oSeq1 = Seq1
    oSeq2 = Seq2
    oSeq3 = Seq3
    GoOn = 1: Cnt = 0
    If DoScans(0, 0) = 1 Or x = x Then
        ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
        ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
        ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
        ReDim XDiffPos(Len(StrainSeq(0)) + 200)
        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        If NextNo > 1 Then
            SS = Abs(GetTickCount)
            Cnt = 0
            For Seq1 = 0 To NextNo - 2
                For Seq2 = Seq1 + 1 To NextNo - 1
                    For Seq3 = Seq2 + 1 To NextNo
                        'Do
                        'Open "xx" For Output As #1
                        'Print #1, Seq1
                        'Print #1, Seq2
                        'Print #1, Seq3
                        'Close #1
                            Cnt = Cnt + 1
                            
                            
                            XoverWindow = XOverWindowX / 2
                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                            EE = Abs(GetTickCount)
                            If Abs(EE - SS) > 50 Then
                                GoOn = 0
                                Exit For
                            End If
                            'Call NextSeqs(GoOn)
                            If GoOn = 0 Then Exit For
                        'Loop
                        Next
                        If GoOn = 0 Then Exit For
                    Next
                If GoOn = 0 Then Exit For
            Next
            x = x
            TBench(0) = (Abs(EE - SS) / Cnt)
            If TBench(0) = 0 Then TBench(0) = 0.00001
        End If
        AnalT(0) = 1
        TotT = TotT + AnalT(0)
        Erase XoverSeqNum
        Erase XoverSeqNumW
        
        Erase XOverHomologyNum
    Else
        Form3.Check4.Value = 0
    End If
    GoOn = 1: Cnt = 0
    If DoScans(0, 1) = 1 Or x = x Then
        
        ReDim SubSeq(Len(StrainSeq(0)), 6)
        ReDim XDiffPos(Len(StrainSeq(0)) + 200)
        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
        ReDim FragMaxScore(GCDimSize, 5)
        ReDim MaxScorePos(GCDimSize, 5)
        ReDim PVals(GCDimSize, 5)
        ReDim FragSt(GCDimSize, 6)
        ReDim FragEn(GCDimSize, 6)
        ReDim FragScore(GCDimSize, 6)
        ReDim DeleteArray(Len(StrainSeq(0)) + 1)
        AnalT(1) = 2
        TotT = TotT + AnalT(1)
        If NextNo > 1 Then
            SS = Abs(GetTickCount)
            Cnt = 0
            For Seq1 = 0 To NextNo - 2
            For Seq2 = Seq1 + 1 To NextNo - 1
            For Seq3 = Seq2 + 1 To NextNo
            'Do
                Cnt = Cnt + 1
                
                
                
                Call GCXoverD(0)
                EE = Abs(GetTickCount)
                If Abs(EE - SS) > 50 Then
                    GoOn = 0
                    Exit For
                End If
                'Call NextSeqs(GoOn)
                If GoOn = 0 Then Exit For
            'Loop
            Next
            If GoOn = 0 Then Exit For
            Next
            If GoOn = 0 Then Exit For
            Next
            TBench(1) = Abs((EE - SS) / Cnt)
            If TBench(1) = 0 Then TBench(1) = 0.00001
        End If
        Erase SubSeq
        Erase FragMaxScore
        Erase MaxScorePos
        Erase PVals
        Erase FragSt
        Erase FragEn
        Erase FragScore
        Erase DeleteArray
        
    End If

    If DoScans(0, 2) = 1 Then
        AnalT(2) = 6
        TotT = TotT + AnalT(2)
        If DoScans(1, 2) = 1 Then
            TotT = TotT + AnalT(2) / 5
            AnalT(2) = AnalT(2) + AnalT(2) / 5
        End If
    Else
    
        If DoScans(1, 2) = 1 Then
            TotT = TotT + 6 / 5
            AnalT(2) = 6 / 5
        End If
    End If
    oSEventNumber = SEventNumber 'this is necessary to avoid a crash in finddaughter
    SEventNumber = 0
    GoOn = 1: Cnt = 0
    If DoScans(0, 3) = 1 Or x = x Then
        ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
        ReDim Chivals(Len(StrainSeq(0)), 2)
        ReDim SmoothChi(Len(StrainSeq(0)), 2)
        ReDim XDiffPos(Len(StrainSeq(0)) + 200)
        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
        ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
        AnalT(3) = 1
        TotT = TotT + AnalT(3)
        If NextNo > 1 Then
            SS = Abs(GetTickCount)
            Cnt = 0
            For Seq1 = 0 To NextNo - 2
            For Seq2 = Seq1 + 1 To NextNo - 1
            For Seq3 = Seq2 + 1 To NextNo
            'Do
                Cnt = Cnt + 1
                
                
                
                Call MCXoverF(0, 0, 0)
                EE = Abs(GetTickCount)
                If Abs(EE - SS) > 50 Then
                    GoOn = 0
                    Exit For
                End If
                'Call NextSeqs(GoOn)
                If GoOn = 0 Then Exit For
               'Open "c:\drop.txt" For Output As #1
               'Print #1, Str(Seq1) & Str(Seq2) & Str(Seq3)
               'Close #1
               
            'Loop
            Next
            If GoOn = 0 Then Exit For
            Next
            If GoOn = 0 Then Exit For
            Next
            TBench(3) = (Abs(EE - SS) / Cnt)
        End If
        Erase Scores
        Erase Winscores
        Erase Chivals
        Erase SmoothChi
        
    End If
    
    GoOn = 1: Cnt = 0
    If DoScans(0, 4) = 1 Or x = x Then
        ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
        ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
        ReDim ChiValsX(Len(StrainSeq(0)))
        ReDim SmoothChiX(Len(StrainSeq(0)))
        AnalT(4) = 1
        TotT = TotT + AnalT(4)
        If NextNo > 1 Then
            SS = Abs(GetTickCount)
            Cnt = 0
            For Seq1 = 0 To NextNo - 2
            For Seq2 = Seq1 + 1 To NextNo - 1
            For Seq3 = Seq2 + 1 To NextNo
            'Do
                Cnt = Cnt + 1
                
                
                
                Call CXoverA(0, 0, 0)
                EE = Abs(GetTickCount)
                If Abs(EE - SS) > 50 Then
                    GoOn = 0
                    Exit For
                End If
                'Call NextSeqs(GoOn)
                If GoOn = 0 Then Exit For
            'Loop
            Next
            If GoOn = 0 Then Exit For
            Next
            If GoOn = 0 Then Exit For
            Next
            TBench(4) = (Abs(EE - SS) / Cnt) * 3
            
        End If
        Erase ScoresX
        Erase WinScoresX
        Erase ChiValsX
        Erase SmoothChiX
    End If
    
    SEventNumber = oSEventNumber
    
    If DoScans(0, 5) = 1 Then
        AnalT(5) = 10
        TotT = TotT + AnalT(5)
        If DoScans(1, 5) = 1 Then
            TotT = TotT + AnalT(5) / 5
            AnalT(5) = AnalT(5) + AnalT(5) / 5
        End If
    ElseIf DoScans(1, 5) = 1 Then
        AnalT(5) = 0.5
            TotT = TotT + AnalT(5) / 5
    End If
    
    If DoScans(0, 6) = 1 Then
        TotT = TotT + AnalT(6)
    End If
    If DoScans(0, 7) = 1 Then
        'AnalT(7) = 100
        TotT = TotT + AnalT(7)
        If DoScans(0, 7) = 1 Then
            TotT = TotT + AnalT(7) / 5
        End If
    ElseIf DoScans(1, 7) = 1 Then
        'AnalT(7) = 20
        TotT = TotT + AnalT(7)
        
    End If
'    XX = AnalT(8)
    AnalT(8) = AnalT(4)
    TBench(8) = TBench(4)
    If DoScans(0, 8) = 1 Then
        TotT = TotT + AnalT(8)
    End If
    
    
    TempTot = 0: TempDiv = 0
    For x = 0 To AddNum - 1
        If TBench(x) > 0 Then
            TempTot = TempTot + TBench(x)
            TempDiv = TempDiv + 1
        End If
    Next x
   Dim LongMod As Double
   If TempDiv > 0 Then
        TempTot = TempTot / TempDiv
        
        If DoScans(0, 2) = 1 Then
             LongMod = ((NextNo * NextNo) / 2) / 5
             
             TBench(2) = TempTot * 10
             If DoScans(1, 2) = 1 Then
                 TBench(2) = TBench(2) + TempTot * 2
             End If
        ElseIf DoScans(1, 2) = 1 Then
            TBench(2) = TempTot * 1
        End If
        
        If DoScans(0, 5) = 1 Then
             TBench(5) = TempTot * 15
             If DoScans(1, 5) = 1 Then
                 TBench(5) = TBench(5) + TBench(5) / 20
             End If
        ElseIf DoScans(1, 5) = 1 Then
            TBench(5) = TempTot * 1
        
        End If
        If DoScans(0, 7) = 1 Then
             TBench(7) = TempTot * 4000
             If DoScans(1, 7) = 1 Then
                 TBench(7) = TBench(7) + TBench(7) / 5
             End If
        ElseIf DoScans(1, 7) = 1 Then
            LRDMod = Len(StrainSeq(0)) / LRDStep
            LRDMod = LRDMod * LRDMod
            LRDMod = LRDMod * NextNo
            LRDMod = LRDMod * 0.0002
            TBench(7) = LRDMod 'temptot * 50
        End If
        
        TotT = 0
        For x = 0 To AddNum - 1
            If DoScans(0, x) = 1 Or DoScans(1, x) = 1 Then
                AnalT(x) = TBench(x)
                TotT = TotT + AnalT(x)
            End If
        Next x
        Dim totx As Double
        
        
        
        Form3.Label60 = "Estimated analysis time: " & DoTime(TotT * MCCorrection * TimeMod * 2)
        
    Else
        TotT = 0
        For x = 0 To AddNum - 1
            If DoScans(0, x) = 1 Or DoScans(1, x) = 1 Then
                
                TotT = TotT + AnalT(x)
            End If
        Next x
        Form3.Label60 = "Estimated analysis time: Unknown"
    End If
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
    
End Sub
Public Sub GetPermSeqs(FName As String, LS As Long, ToNumSeqs As Long, SeqNum() As Integer)

Dim TSeqSpaces() As Long, TOSeq() As String, TOSeqX() As String, LastPos As Long, Pos As Long, FF2 As Long, oDir As String, Header As String, Target As String

ReDim TOSeq(ToNumSeqs)
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0

FF2 = FreeFile

Open FName For Input As #FF2
    
If LOF(FF2) = 0 Then
    If CLine = "" Or CLine = " " Then
        MsgBox ("An error occured during Generation of permuted sequences.  The problem appears to be SEQGEN.")
    End If
    AbortFlag = 1
    Close #FF2
    Exit Sub
End If
    
Line Input #FF2, Header
    
If Len(Header) = LOF(FF2) Then 'some systems will not simply read lines - they go for the entire file
    Close #FF2
    Target = Chr$(10)
    LastPos = 1
    
    Do
        Pos = InStr(LastPos, Header, Target, vbBinaryCompare)
    
        If Pos > 0 Then
            Header = Left$(Header, Pos - 1) + Chr$(13) + Right$(Header, Len(Header) - (Pos - 1))
            LastPos = Pos + 3
        Else
            Exit Do
        End If
    
    Loop
    
    Open FName For Output As #FF2
    
    Print #FF2, Header
    
    Close #FF2
    
    Open FName For Input As #FF2
    Line Input #FF2, Header
End If
    
For Y = 0 To ToNumSeqs
    Header = ""
    
    Do Until Len(Header) > 0
        Line Input #FF2, Header
    Loop
    
    TOSeq(Y) = Right$(Header, Len(Header) - 10)
    XX = x
Next 'Y
    
Close #FF2
'ReDim TOSeqX(TONumSeqs)
Dim TS As String
For x = 0 To ToNumSeqs
    
    TOSeq(x) = Mid$(TOSeq(x), 1, LS)
    If Len(TOSeq(x)) < LS Then
        TOSeq(x) = TOSeq(x) + Left(TOSeq(x), LS - Len(TOSeq(x)))
    End If
    
    
Next x
        
ReDim SeqNum(Len(TOSeq(0)), ToNumSeqs), TSeqSpaces(Len(TOSeq(0)), ToNumSeqs)

For Z = 0 To ToNumSeqs
    Dummy = CopyString(Len(TOSeq(0)), SeqNum(0, Z), TOSeq(Z), TSeqSpaces(0, Z))
Next 'Z
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
On Error GoTo 0
End Sub
Public Sub MakeSeqGenBat(OutName As String, CurPerm As Long, NumRates As Long, Fraglen As Long, TOModel As Integer, TOTvTs As Double, TOFreqFlag As Double, TOFreqA As Double, TOFreqC As Double, TOFreqG As Double, TOFreqT As Double)

Dim FFX As Long, oDir As String, ToSeqGenCLine As String, AF As Double, CF As Double, GF As Double, TF As Double
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path

FFX = FreeFile

Open "seqgen.bat" For Output As #FFX
    'different cline parametes must be given for different models
    'onlt JC model options are given
    'Note that for JN and ML extra things must be either calculated
    'Shape parameter alpha distribution for JN and bpfrequencies for
    'ML).
    If NumRates > 0 Then
        ToSeqGenCLine = "seq-gen -p" & Trim(Str(NumRates))
    Else
        ToSeqGenCLine = "seq-gen"
    End If
    
    If TOModel = 0 Then
        ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t0.5"
    ElseIf TOModel = 1 Then
        ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t" & TOTvTs
    ElseIf TOModel = 2 Then
            ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t" & TOTvTs
    Else
        ToSeqGenCLine = ToSeqGenCLine & " -mF84 -t" & TOTvTs
    
        If TOFreqFlag = 0 Then
    
            Call CalcBPFreqs(AF, CF, GF, TF)
    
            ToSeqGenCLine = ToSeqGenCLine & " -f " & AF & " " & CF & " " & GF & " " & TF
        Else
            ToSeqGenCLine = ToSeqGenCLine & " -f " & TOFreqA & " " & TOFreqC & " " & TOFreqG & " " & TOFreqT
        End If
    
    End If
    
    ToSeqGenCLine = ToSeqGenCLine & " -z" & Trim(Str(CurPerm + 10))
    If NumRates > 0 Then
        If LS < 32000 Then
            ToSeqGenCLine = ToSeqGenCLine & " -l" & Trim(Str(NumRates * Fraglen)) & " -n1 <simtree > out"
        Else
            ToSeqGenCLine = ToSeqGenCLine & " -l32000 -n1 <simtree > out"
        End If
    Else
        If LS < 32000 Then
            ToSeqGenCLine = ToSeqGenCLine & " -l" & Trim(Str(Len(StrainSeq(0)))) & " -n1 <simtree > out"
        Else
            ToSeqGenCLine = ToSeqGenCLine & " -l32000 -n1 <simtree > out"
        End If
    End If
    Print #FFX, ToSeqGenCLine
    Print #FFX, "del " + OutName
    Print #FFX, "rename out " + OutName
    
Close #FFX


ChDir oDir
ChDrive oDir
On Error GoTo 0
End Sub


Public Sub MakeTreeString(Treestring As String, LS As Long, NextNo As Long, SeqNum() As Integer)

Dim Z As Long, Alias() As Long, Ally() As Long, Weight() As Long, Location() As Long, Px() As Integer, XX1() As Integer, XX2() As Integer, Prod1() As Double, Prod2() As Double, Prod3() As Double, tMat() As Single
Dim ColTotals() As Single, LTree As Long, SHolder() As Byte, Treearray() As Single

ReDim Alias(LS), Ally(LS), Weight(0, LS), Location(LS), Px(NextNo, LS), XX1(3), XX2(3), Prod1(LS), Prod2(LS), Prod3(LS), tMat(NextNo, NextNo)
ReDim SHolder((NextNo + 1) * 40 * 2)
ReDim ColTotals(NextNo), Treearray(NextNo, NextNo)

Dummy = DNADIST(TCoeffVar, TTVRat, TBaseFreqFlag, TModel, TAfreq, TCFreq, TGFreq, TTFreq, NextNo + 1, LS, SeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0))

LTree = NEIGHBOUR(1, 0, -BSRndNumSeed, NextNo + 1, NextNo + 1, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))

Treestring = ""
For Z = 1 To LTree
    Treestring = Treestring + Chr(SHolder(Z))
Next Z '

End Sub

Public Sub MakeSimTree(FName As String, Treestring As String, NumRates As Long, Fraglen As Long, RatesArray() As Double)
'This makes the seqgen input file for seqgen simulated permutated datasets

Dim FF As Long, oDir As String, x As Long

'Make sure everything is written to the app path
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0
FF = FreeFile
Open FName For Output As #FF
If NumRates > 0 Then
    For x = 1 To NumRates
        If RatesArray(x) < 1 Then
        Print #FF, "[" + Trim(Str(Fraglen)) + ", " + "0" + Trim(Str(RatesArray(x))) + "]" + Treestring
        
        Else
        Print #FF, "[" + Trim(Str(Fraglen)) + ", " + Trim(Str(RatesArray(x))) + "]" + Treestring
        End If
    Next x
Else
    Print #FF, "[" + Trim(Str(Len(StrainSeq(0)))) + ", 1]" + Treestring
End If
Close #FF

'Restore to old path
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
On Error GoTo 0
End Sub
Public Sub DoSeqGenPerms()


Dim Treestring As String, NumPerms As Long, LS As Long, TreeType As Byte, x As Long, A As Long, NumRates As Long, Fraglen As Long


If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0

LS = Len(StrainSeq(0))
TreeType = 1 'ie njtree
Fraglen = 20
NumPerms = 3




For x = 0 To NumPerms
    
    
        
        
Next x
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
On Error GoTo 0
End Sub
Public Sub MakeMCCorrection(NextNo As Long, MaskSeq() As Integer, MCCorrection As Long, MCCorrect As Long, GCMCCorrection As Long, NumberOfSeqs As Long, IndividualA As Integer, IndividualB As Integer)
    Dim Scor As Long, x As Long, NS As Long, TempV As Variant
    
    IndividualA = -1
    IndividualB = -1
    
    NumberOfSeqs = -1
    For x = 0 To NextNo
        If MaskSeq(x) = 0 Then
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next x
    
    NS = NumberOfSeqs + 1
    GCMCCorrection = (NS) * (NS - 1) / 2
    If QvRFlag = 1 Then
        If TripListLen = 0 Or MCCorrection = 0 Then
            Call MakeAnalysisListQvR
        End If
        'Else
        '    MCCorrection = TripListLen
        'End If
        UseALFlag = 1
    ElseIf SelGrpFlag = 0 Then
        
        
        If NS = 1 Then
            MCCorrection = 0
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    IndividualA = x
                    Exit For
                End If
            Next 'X
            MCCorrection = (NextNo * (NextNo - 1)) / 2
            MCCorrect = NextNo
        ElseIf NS = 2 Then
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    If IndividualA > -1 Then
                        IndividualB = x
                        Exit For
                    Else
                        IndividualA = x
                    End If
                End If
            Next 'X
            MCCorrection = NextNo - 1
            MCCorrect = 1
        Else
            TempV = NS * (NS - 1)
            MCCorrect = TempV / 2
            TempV = TempV * (NS - 2)
            TempV = TempV / 6
            If TempV < (255 ^ 4) / 2 Then
               MCCorrection = TempV
            Else
                MCCorrection = (255 ^ 4) / 2
            End If
        End If
    Else
        MCCorrection = 0
        If NS = 1 Then
            
            MCCorrect = NextNo
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    IndividualA = x
                    Exit For
                End If
            Next 'X
            For Seq1 = 0 To NextNo
                For Seq2 = Seq1 + 1 To NextNo
                    For Seq3 = Seq2 + 1 To NextNo
                        If Seq1 = IndividualA Or Seq2 = IndividualA Or Seq3 = IndividualA Then
                            If GrpMaskSeq(Seq1) = 1 Or GrpMaskSeq(Seq2) = 1 Or GrpMaskSeq(Seq3) = 1 Then
                                MCCorrection = MCCorrection + 1
                            End If
                        End If
                    Next
                Next
            Next
        ElseIf NS = 2 Then
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    If IndividualA > -1 Then
                        IndividualB = x
                        Exit For
                    Else
                        IndividualA = x
                    End If
                End If
            Next 'X
            For Seq1 = 0 To NextNo
                For Seq2 = Seq1 + 1 To NextNo
                    For Seq3 = Seq2 + 1 To NextNo
                        Scor = 0
                        If (Seq1 = IndividualA Or Seq1 = IndividualB) Then
                            Scor = Scor + 1
                        End If
                        If (Seq2 = IndividualA Or Seq2 = IndividualB) Then
                            Scor = Scor + 1
                        End If
                        If (Seq3 = IndividualA Or Seq3 = IndividualB) Then
                            Scor = Scor + 1
                        End If
                        If Scor = 2 Then
                            If GrpMaskSeq(Seq1) = 1 Or GrpMaskSeq(Seq2) = 1 Or GrpMaskSeq(Seq3) = 1 Then
                                MCCorrection = MCCorrection + 1
                            End If
                        End If
                    Next
                Next
            Next
        Else
            
'            If X = 12345 Then
'
'                Dim NumUnmasked As Long
'                Dim NumUnmaskedInGroup As Long, NumUnmaskedOutGroup As Long
'                NumUnmaskedOutGroup = 0
'                NumUnmaskedInGroup = 0
'                For X = 1 To Nextno
'                    If Maskseq(X) = 0 Then
'
'                        If GrpMaskSeq(X) = 0 Then
'                            NumUnmaskedOutGroup = NumUnmaskedOutGroup + 1
'                        Else
'                            NumUnmaskedInGroup = NumUnmaskedInGroup + 1
'                        End If
'                    End If
'
'                Next X
'
'                NumUnmasked = NumUnmaskedOutGroup + NumUnmaskedInGroup
'
'                mcx = ((NumUnmaskedInGroup * (NumUnmaskedInGroup - 1)) / 2)
'                'XX = mcx * (NumUnmaskedInGroup - 2)
'                mcx = mcx + mcx * NumUnmaskedOutGroup
'
'                MCCorrection = mcx + ((NumUnmaskedInGroup * (NumUnmaskedInGroup - 1) * (NumUnmaskedInGroup - 2)) / 6)
'
'
'
'            ElseIf X = X Then
                MCCorrection = ScanNums(NextNo, GrpMaskSeq(0), MaskSeq(0))
                
                
'            Else
'
'                X = X
'
'
'                If X = 12345 Then
'                    MCCorrection = 0
'                    ZZ = 0
'                    For Seq1 = 0 To Nextno
'                        If Maskseq(Seq1) = 0 Then
'                            For Seq2 = Seq1 + 1 To Nextno
'                                If Maskseq(Seq2) = 0 Then
'                                    For Seq3 = Seq2 + 1 To Nextno
'                                        If Maskseq(Seq3) = 0 Then
'
'                                            If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) > 1 Then
'                                                MCCorrection = MCCorrection + 1
'                                                If GrpMaskSeq(Seq1) = 1 And GrpMaskSeq(Seq2) = 1 And GrpMaskSeq(Seq3) = 1 Then
'                                                    'ZZ = ZZ + 1
'                                                ElseIf GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) = 2 Then
'                                                    ZZ = ZZ + 1
'                                                End If
'
'                                            End If
'                                        End If
'                                    Next
'                                End If
'                            Next
'                            Form1.SSPanel1.Caption = "Counting triplets (" + Trim(Str(MCCorrection)) + " so far)"
'                            'Form1.ProgressBar1.Value = (Seq1 / Nextno) * 100
'                            Form1.SSPanel1.Refresh
'                            Form1.Refresh
'                        End If
'                    Next
'                End If
'            End If
            MCCorrect = (NS - 1) * (NS) / 2
            x = x
        End If
        
    End If
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    'Form1.ProgressBar1.Value = 0
End Sub
Public Sub SetUpFrame17()
Dim x As Long, LeftCorner As Long, TopCorner As Long, NumProgs As Integer, ColSpace As Integer, ColWidth As Double
    
NumProgs = 0
Form1.Picture7.ScaleHeight = Form1.Picture10.Height
Form1.Picture7.Top = 0
Form1.Label3.Width = 10
Form1.Label3.Top = 0
Form1.Label3.Left = 0
ReDim ProgF(100)

Form1.Label50(12) = "--"
Form1.Label50(13) = "--"
If DoScans(0, 0) = 1 Then
    ProgF(0) = 1
            Form1.Label54(0).Visible = True
            Form1.Label50(0).Visible = True
            Form1.Label50(1).Visible = True
            Form1.Label50(0).Caption = "--"
            Form1.Label50(1).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(0).Visible = False
            Form1.Label50(0).Visible = False
            Form1.Label50(1).Visible = False
        End If
    
        If DoScans(0, 1) = 1 Then
            ProgF(1) = 1
            Form1.Label54(1).Visible = True
            Form1.Label50(2).Visible = True
            Form1.Label50(3).Visible = True
            Form1.Label50(2).Caption = "--"
            Form1.Label50(3).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(1).Visible = False
            Form1.Label50(2).Visible = False
            Form1.Label50(3).Visible = False
        End If
    
        If DoScans(0, 2) = 1 Then
            ProgF(2) = 1
            Form1.Label54(2).Visible = True
            Form1.Label50(4).Visible = True
            Form1.Label50(5).Visible = True
            Form1.Label50(4).Caption = "--"
            Form1.Label50(5).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(2).Visible = False
            Form1.Label50(4).Visible = False
            Form1.Label50(5).Visible = False
        End If
    
        If DoScans(0, 3) = 1 Then
            ProgF(3) = 1
            Form1.Label54(3).Visible = True
            Form1.Label50(6).Visible = True
            Form1.Label50(7).Visible = True
            Form1.Label50(6).Caption = "--"
            Form1.Label50(7).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(3).Visible = False
            Form1.Label50(6).Visible = False
            Form1.Label50(7).Visible = False
        End If
    
        If DoScans(0, 4) = 1 Then
            ProgF(4) = 1
            Form1.Label54(4).Visible = True
            Form1.Label50(8).Visible = True
            Form1.Label50(9).Visible = True
            Form1.Label50(8).Caption = "--"
            Form1.Label50(9).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(4).Visible = False
            Form1.Label50(8).Visible = False
            Form1.Label50(9).Visible = False
        End If
    
        If DoScans(0, 5) = 1 Then
            ProgF(5) = 1
            Form1.Label54(5).Visible = True
            Form1.Label50(10).Visible = True
            Form1.Label50(11).Visible = True
            Form1.Label50(10).Caption = "--"
            Form1.Label50(11).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(5).Visible = False
            Form1.Label50(10).Visible = False
            Form1.Label50(11).Visible = False
        End If
        
        If DoScans(0, 8) = 1 Then
            NumProgs = NumProgs + 1
            ProgF(8) = 1
            Form1.Label54(9).Visible = True
            Form1.Label50(14).Visible = True
            Form1.Label50(15).Visible = True
            Form1.Label50(14).Caption = "--"
            Form1.Label50(15).Caption = "--"
            NumProgs = NumProgs + 1
        Else
            Form1.Label54(9).Visible = False
            Form1.Label50(14).Visible = False
            Form1.Label50(15).Visible = False
        End If
        
        If ShowPlotFlag = 0 Then
            Form1.ScaleMode = 1
            Form1.Frame17.Top = Form1.SSPanel8.Top + Form1.Picture10.Top + 2 * Screen.TwipsPerPixelY
            Form1.Frame17.Left = Form1.SSPanel8.Left + Form1.Picture10.Left + 2 * Screen.TwipsPerPixelX
            Form1.Frame17.Width = Form1.Picture10.Width - 4 * Screen.TwipsPerPixelX '(form1.Picture7.Width - 1) * Screen.TwipsPerPixelX
            Form1.Frame17.Height = Form1.Picture10.Height - 4 * Screen.TwipsPerPixelY '(form1.Picture7.Height - 1) * Screen.TwipsPerPixelY
        ElseIf (ShowPlotFlag = 2 Or ShowPlotFlag = 1) And (CLine = "" Or CLine = " ") Then
            Form1.ScaleMode = 1
            Form1.Frame17.Top = Form1.SSPanel6(0).Top + Form1.Picture32.Top + 2 * Screen.TwipsPerPixelY
            Form1.Frame17.Left = Form1.SSPanel6(0).Left + Form1.Picture32.Left + 2 * Screen.TwipsPerPixelX
            Form1.Frame17.Width = Form1.Picture32.Width - 4 * Screen.TwipsPerPixelX
            Form1.Frame17.Height = Form1.Picture32.Height - 4 * Screen.TwipsPerPixelY
        End If
        
        'RowSpace = Int(RSpace - 100 * (NumProgs / 6))
        LeftCorner = Form1.Frame17.Width / 16 '800
        ColSpace = (Form1.Frame17.Width - LeftCorner * 2) / 3
        ColWidth = ColSpace
    
        If ShowPlotFlag = 0 Then ' ie no overview and no plots
            TopCorner = (Form1.Frame17.Height - RowSpace * (NumProgs + 2)) / 2
            Form1.Label54(6).Left = (ColSpace / 1.3 + LeftCorner)
            Form1.Label54(6).Top = (RowSpace * 0 + TopCorner)
            Form1.Label54(6).Width = ColWidth / 3
            Form1.Label54(6).Height = RowSpace * 0.7
            Form1.Label54(7).Left = (ColSpace * 1.5 + LeftCorner)
            Form1.Label54(7).Top = (RowSpace * 0 + TopCorner)
            Form1.Label54(7).Width = ColWidth + ColWidth * 2 / 3
            Form1.Label54(7).Height = RowSpace * 0.7
        ElseIf (ShowPlotFlag = 2 Or ShowPlotFlag = 1) And (CLine = "" Or CLine = " ") Then
            TopCorner = (Form1.Frame17.Height - RowSpace * (NumProgs + 3)) / 2
            Form1.Label54(6).Left = (ColSpace / 1.3 + LeftCorner)
            Form1.Label54(6).Top = (RowSpace * 0 + TopCorner) - RowSpace * 0.7
            Form1.Label54(6).Width = ColWidth / 1.5
            Form1.Label54(6).Height = RowSpace * 1.4
            Form1.Label54(7).Left = (ColSpace * 1.3 + LeftCorner)
            Form1.Label54(7).Top = (RowSpace * 0 + TopCorner) - RowSpace * 0.7
            Form1.Label54(7).Width = ColWidth * 2
            Form1.Label54(7).Height = RowSpace * 1.4
        End If
    
        NumProgs = 0
        
        If DoScans(0, 0) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(0).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(0).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(0).Width = ColWidth
            Form1.Label50(0).Left = Form1.Label54(6).Left
            Form1.Label50(0).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(0).Width = Form1.Label54(6).Width
            Form1.Label50(0).Height = 250
            Form1.Label50(1).Left = Form1.Label54(7).Left
            Form1.Label50(1).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(1).Width = Form1.Label54(7).Width
            Form1.Label50(1).Height = 250
        End If
    
        If DoScans(0, 1) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(1).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(1).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(1).Width = ColWidth
            Form1.Label50(2).Left = Form1.Label54(6).Left
            Form1.Label50(2).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(2).Width = Form1.Label54(6).Width
            Form1.Label50(2).Height = 250
            Form1.Label50(3).Left = Form1.Label54(7).Left
            Form1.Label50(3).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(3).Width = Form1.Label54(7).Width
            Form1.Label50(3).Height = 250
        End If
    
        If DoScans(0, 2) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(2).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(2).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(2).Width = ColWidth
            Form1.Label50(4).Left = Form1.Label54(6).Left
            Form1.Label50(4).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(4).Width = Form1.Label54(6).Width
            Form1.Label50(4).Height = 250
            Form1.Label50(5).Left = Form1.Label54(7).Left
            Form1.Label50(5).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(5).Width = Form1.Label54(7).Width
            Form1.Label50(5).Height = 250
        End If
    
        If DoScans(0, 3) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(3).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(3).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(3).Width = ColWidth
            Form1.Label50(6).Left = Form1.Label54(6).Left
            Form1.Label50(6).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(6).Width = Form1.Label54(6).Width
            Form1.Label50(6).Height = 250
            Form1.Label50(7).Left = Form1.Label54(7).Left
            Form1.Label50(7).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(7).Width = Form1.Label54(7).Width
            Form1.Label50(7).Height = 250
        End If
    
        If DoScans(0, 4) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(4).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(4).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(4).Width = ColWidth
            Form1.Label50(8).Left = Form1.Label54(6).Left
            Form1.Label50(8).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(8).Width = Form1.Label54(6).Width
            Form1.Label50(8).Height = 250
            Form1.Label50(9).Left = Form1.Label54(7).Left
            Form1.Label50(9).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(9).Width = Form1.Label54(7).Width
            Form1.Label50(9).Height = 250
        End If
    
        If DoScans(0, 5) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(5).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(5).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(5).Width = ColWidth
            Form1.Label50(10).Left = Form1.Label54(6).Left
            Form1.Label50(10).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(10).Width = Form1.Label54(6).Width
            Form1.Label50(10).Height = 250
            Form1.Label50(11).Left = Form1.Label54(7).Left
            Form1.Label50(11).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(11).Width = Form1.Label54(7).Width
            Form1.Label50(11).Height = 250
        End If
        If DoScans(0, 8) = 1 Then
            NumProgs = NumProgs + 1
            Form1.Label54(9).Left = (ColSpace * 0 + LeftCorner)
            Form1.Label54(9).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label54(9).Width = ColWidth
            Form1.Label50(14).Left = Form1.Label54(6).Left
            Form1.Label50(14).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(14).Width = Form1.Label54(6).Width
            Form1.Label50(14).Height = 250
            Form1.Label50(15).Left = Form1.Label54(7).Left
            Form1.Label50(15).Top = (RowSpace * NumProgs + TopCorner)
            Form1.Label50(15).Width = Form1.Label54(7).Width
            Form1.Label50(15).Height = 250
        End If
        NumProgs = NumProgs + 1
        'Form1.Frame17.Visible = True
        Form1.Frame17.ZOrder
        Form1.Label54(8).Left = (ColSpace * 0 + LeftCorner)
        Form1.Label54(8).Top = (RowSpace * NumProgs + TopCorner)
        Form1.Label54(8).Width = ColWidth
        Form1.Label50(12).Left = Form1.Label54(6).Left
        Form1.Label50(12).Top = (RowSpace * NumProgs + TopCorner)
        Form1.Label50(12).Width = Form1.Label54(6).Width
        Form1.Label50(12).Height = 250
        Form1.Label50(13).Left = Form1.Label54(7).Left
        Form1.Label50(13).Top = (RowSpace * NumProgs + TopCorner)
        Form1.Label50(13).Width = Form1.Label54(7).Width
        Form1.Label50(13).Height = 250
        Form1.Line44(0).X1 = (ColSpace * 0 + LeftCorner)
        Form1.Line44(0).Y1 = (RowSpace * 0.75 + TopCorner)
        Form1.Line44(0).X2 = (ColSpace * 3 + LeftCorner)
        Form1.Line44(0).Y2 = (RowSpace * 0.75 + TopCorner)
        Form1.Line44(1).X1 = (ColSpace * 0 + LeftCorner)
        Form1.Line44(1).Y1 = (RowSpace * (NumProgs - 0.25) + TopCorner)
        Form1.Line44(1).X2 = (ColSpace * 3 + LeftCorner)
        Form1.Line44(1).Y2 = (RowSpace * (NumProgs - 0.25) + TopCorner)
        Form1.Line44(2).X1 = (ColSpace * 0 + LeftCorner)
        Form1.Line44(2).Y1 = (RowSpace * (NumProgs + 0.75) + TopCorner)
        Form1.Line44(2).X2 = (ColSpace * 3 + LeftCorner)
        Form1.Line44(2).Y2 = (RowSpace * (NumProgs + 0.75) + TopCorner)
        
        Form1.Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Form1.Command25.Enabled = True
       
        
        ReDim Preserve MaskSeq(NextNo)
        'Prepare form1.PictureBoxes
        CurrentCheck = -1
        Form1.Picture10.Picture = LoadPicture()
        Form1.Picture10.Refresh
        Screen.MousePointer = 11
        
        'form1.Command9.style = 0
        'Form1.Command9.BackColor = Form3.Command4.BackColor
        Form1.Combo1.Clear
        Form1.Combo1.BackColor = Form1.BackColor
        Form1.Combo1.Enabled = False
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
        
        Form1.Frame17.BackColor = BackColours
        
        For x = 0 To AddNum - 1
            ProgF(x) = 1
        Next x
End Sub
Public Sub ReplaceNames(OriginalName() As String, NumberOfSeqs As Long, NHString As String)
Dim NLen As Integer, TName As String, x As Long, Pos As Long, FxName As String

NLen = Len(Trim(Str(NumberOfSeqs)))
If NLen = 1 Then NLen = 2
For x = NumberOfSeqs To 0 Step -1
            'If NJF = 1 Or X = X Then
                
                TName = Trim$(CStr(x))
                TName = String(NLen - Len(TName), "0") & TName
                TName = "S" & TName
            'Else
            '    TName = "S" & Trim$(CStr(X))
            'End If
            Pos = InStr(1, NHString, TName, vbBinaryCompare)

            If Pos > 1 Then
            
                If x = x Then
                    'If F2TreeIndex = 1 Or F2TreeIndex = 2 Then
                        If DebuggingFlag < 2 Then On Error Resume Next
                        UB = -1
                        UB = UBound(TreeTraceSeqs, 2)
                        
                        On Error GoTo 0
                    'Else
                    
                    'End If
                     
                     If x <= UB Or UB = -1 Or (F2TreeIndex = 3 And CTF > 0) Then
                         If F2TreeIndex = 0 Or UB = 0 Or (F2TreeIndex = 3 And (CTF = 1 Or CTF = 0)) Then
                            If NumberOfSeqs > UBound(PermOriginalName) Then
                                If x <= UBound(PermOriginalName) Then
                                    If Left(PermOriginalName(x), 10) = Left(OriginalName(x), 10) Then
                                        FxName = PermOriginalName(x)
                                    Else
                                        FxName = OriginalName(x)
                                    End If
                                Else
                                    FxName = OriginalName(x)
                                End If
                            ElseIf x <= UBound(PermOriginalName, 1) Then
                                FxName = PermOriginalName(x)
                            
                            End If
                         
                         Else
                             If F2TreeIndex = 3 And CTF = 1 Then
                                 FxName = BigTreeNameU(x) 'BigTreeTraceU(TreetraceSeqs(1, CurrentSeq)))  'OriginalName(TreeTrace(CurrentSeq))
                             ElseIf F2TreeIndex = 3 And CTF = 2 Then
                                 If DebuggingFlag < 2 Then On Error Resume Next
                                 UB = -1
                                 UB = UBound(BigTreeName)
                                 On Error GoTo 0
                                 If UB >= x Then
                                    FxName = BigTreeName(x) 'BigTreeTraceU(TreetraceSeqs(1, CurrentSeq)))  'OriginalName(TreeTrace(CurrentSeq))
                                 Else
                                    'UnModNextno
                                    If x <= UBound(StraiName, 1) Then
                                        FxName = StraiName(x)
                                    End If
                                    'UnModNextno
                                 End If
                             ElseIf F2TreeIndex = 3 And CTF = 0 Then
                                 FxName = PermOriginalName(x)
                             Else
                                 If TreeTrace(TreeTraceSeqs(1, x)) <= UBound(OriginalName, 1) Then
                                     FxName = OriginalName(TreeTrace(TreeTraceSeqs(1, x))) 'OriginalName(TreeTrace(CurrentSeq))
                                 End If
                             End If
                         End If
                     ElseIf UB = 0 Then
                        If x <= UBound(PermOriginalName, 1) Then
                            FxName = PermOriginalName(x)
                        End If
                     End If
                     x = x
                Else
                    'do check of originalname
                    If x <= UBound(OriginalName) Then
                        FxName = OriginalName(x)
                    Else
                        If x <= UBound(StraiName) Then
                            FxName = StraiName(x)
                        Else
                            FxName = ""
                        End If
                    End If
                End If
                'If X = 32 Then
                '    X = X
                'End If
                If FxName <> "" Then
                    Call FixName(FxName)
                    NHString = Left$(NHString, Pos - 1) + FxName + Right$(NHString, Len(NHString) - (Pos - 1) - Len(TName))
                Else
                    x = x
                End If
            Else
                x = x
            End If
            'Px = InStr(1, NHString(NHFlag), originalname(5), vbBinaryCompare)
            'If Px = 0 Then
            '    X = X
            'End If
        Next 'X
        x = x
        
End Sub
Public Sub ReplaceNamesB(NumberOfSeqs As Long, NHString As String)
Dim NLen As Integer, TName As String, x As Long, Pos As Long, FxName As String

For x = NumberOfSeqs To 0 Step -1
            'If NJF = 1 Or X = X Then
                NLen = Len(Trim(Str(NumberOfSeqs)))
                If NLen = 1 Then NLen = 2
                TName = Trim$(CStr(x))
                TName = String(NLen - Len(TName), "0") & TName
                TName = "S" & TName
            'Else
            '    TName = "S" & Trim$(CStr(X))
            'End If
            FxName = OriginalName(x)
            Pos = InStr(1, NHString, FxName, vbBinaryCompare)
            If Pos = 0 Then
                FxName = StraiName(x)
                Pos = InStr(1, NHString, FxName, vbBinaryCompare)
            End If
            
            If Pos > 1 Then
                'do check of originalname
                GoOn = 0
                Pos2 = Pos
                Do While Pos > 0
                    If Pos + 1 < Len(NHString) Then
                        tchar = Mid$(NHString, Pos + 1, 1)
                        If tchar = ":" Or tchar = ";" Or tchar = ")" Or tchar = "," Then
                            GoOn = 1
                            Exit Do
                        End If
                        Pos = Pos + 1
                    Else
                        Pos = InStr(1, NHString, FxName, vbBinaryCompare) + Len(FxName)
                        GoOn = 1
                        Exit Do
                    End If
                    
                Loop
                If GoOn = 1 Then
                    NHString = Left$(NHString, Pos2 - 1) + TName + Right$(NHString, Len(NHString) - (Pos - 1) - 1)
                End If
'                Open "testN.txt" For Output As #1
'                Print #1, NHString
'                Close #1
                x = x
            End If
            'Px = InStr(1, NHString(NHFlag), originalname(5), vbBinaryCompare)
            'If Px = 0 Then
            '    X = X
            'End If
        Next 'X
        x = x
    
End Sub
Public Sub FixName(FxName As String)
Call ReplaceChar(FxName, ",", "_")
Call ReplaceChar(FxName, " ", "_")
Call ReplaceChar(FxName, "(", "|")
Call ReplaceChar(FxName, ")", "|")
Call ReplaceChar(FxName, ":", "_")
Call ReplaceChar(FxName, ";", "_")
Call ReplaceChar(FxName, "]", "|")
Call ReplaceChar(FxName, "[", "|")
Call ReplaceChar(FxName, "}", "|")
Call ReplaceChar(FxName, "{", "|")
End Sub
Public Sub ReplaceChar(InString As String, ReplacedChar As String, ReplaceWithChar As String)

Do
    Pos = InStr(1, InString, ReplacedChar)
    If Pos > 0 Then
        Mid$(InString, Pos, 1) = ReplaceWithChar
    Else
        Exit Do
    End If
Loop
End Sub
Public Sub MakeOUCheck(NextNo As Long, ISeqs() As Long, MinPair() As Byte, INList() As Byte, FAMat() As Single, SAMat() As Single, OuCheck() As Long)
Dim x As Long
'This is now using FAMatSmall and SAMatSmall
ReDim OuCheck(2)
        'Check for possibility that NO,NI and PI might be recombinant looking at sequences in
        'the tree that are:
        '(1) more distantly realetd to NO and PI than they are to one another
        'but more closely realted to these sequences than they are to NI in the BR
        '(2) more closely related to NI than to NO and PI in the BR
        For x = 0 To NextNo
            If FAMat(INList(0), x) > FAMat(INList(0), ISeqs(INList(1))) And FAMat(INList(0), x) < FAMat(INList(0), ISeqs(INList(2))) Then
                If SAMat(INList(1), x) < SAMat(INList(0), x) Then
                    OuCheck(INList(0)) = OuCheck(INList(0)) + 1
                    OuCheck(INList(1)) = OuCheck(INList(1)) - 1
                    OuCheck(INList(2)) = OuCheck(INList(2)) - 1
                ElseIf SAMat(INList(1), x) > SAMat(INList(0), x) Then
                    OuCheck(INList(0)) = OuCheck(INList(0)) - 1
                    OuCheck(INList(1)) = OuCheck(INList(1)) + 1
                    OuCheck(INList(2)) = OuCheck(INList(2)) - 1
                ElseIf SAMat(INList(1), x) > SAMat(INList(0), ISeqs(INList(1))) Then
                    OuCheck(INList(0)) = OuCheck(INList(0)) - 1
                    OuCheck(INList(1)) = OuCheck(INList(1)) - 1
                    OuCheck(INList(2)) = OuCheck(INList(2)) + 1
                End If
            
            End If
        Next x
End Sub
Public Sub CollapseNodes(NextNo As Long, Cutoff As Double, DLen() As Single, TraceBak() As Single, PAMat() As Single, CMat() As Single)

Dim Dummy As Long, T(1) As Long, x As Long, Y As Long, Z As Long, LODist As Single, AMat() As Single
If AbortFlag = 1 Then Exit Sub

ReDim CMat(NextNo, NextNo)
'redim AMat(NextNo, NextNo)
'
'
''SS = Abs(GetTickCount)
''Maybe encorporate this into collapsenodes
'For x = 0 To NextNo
'    For Y = 0 To NextNo
'        AMat(x, Y) = PAMat(x, Y)
'    Next Y
'    'TraceBak(X) = CLng(TraceBak(X) * 10000) / 10000
'Next x
'EE = Abs(GetTickCount)
'TT = EE - SS
'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
'This could be parallelised
SS = Abs(GetTickCount)
If x = x Then
    Dummy = CollapseNodesXP3(NextNo, Cutoff, T(0), DLen(0), CMat(0, 0), PAMat(0, 0), TraceBak(0))
'    Dim CMat2() As Single
'    'ReDim CMat2(NextNo, NextNo)
'    Dummy = CollapseNodesXP(NextNo, Cutoff, T(0), DLen(0), CMat(0, 0), PAMat(0, 0), TraceBak(0))
'    LD = 0
    
ElseIf x = 1234567 Then
    ReDim AMat(NextNo, NextNo)
    For x = 0 To NextNo
        For Y = 0 To NextNo
            AMat(x, Y) = PAMat(x, Y)
        Next Y
        'TraceBak(X) = CLng(TraceBak(X) * 10000) / 10000
    Next x
    Dummy = CollapseNodesXP(NextNo, Cutoff, T(0), DLen(0), CMat(0, 0), AMat(0, 0), TraceBak(0))
    x = x
Else
    ReDim AMat(NextNo, NextNo)
    For x = 0 To NextNo
        For Y = 0 To NextNo
            AMat(x, Y) = PAMat(x, Y)
        Next Y
        'TraceBak(X) = CLng(TraceBak(X) * 10000) / 10000
    Next x
'    XX = AMat(21, 24)
'    XX = AMat(21, 36)
'    XX = AMat(21, 186)
'    XX = AMat(24, 36)
'    XX = AMat(24, 186)
'    XX = AMat(36, 186)
'
'    XX = AMat(22, 155)
    Dim FP As Long
    Dim SeqSet() As Long, SeqCount() As Long, BN As Long
    ReDim SeqSet(NextNo, NextNo), SeqCount(NextNo)
    'For x = 0 To NextNo
'        For Y = 0 To NextNo
'            For Z = Y + 1 To NextNo
'                BN = AMat(Y, Z) * 1000
'                SeqCount(BN) = SeqCount(BN) + 1
'                SeqSet(BN, SeqCount(BN)) = Z
'                SeqCount(BN) = SeqCount(BN) + 1
'                SeqSet(BN, SeqCount(BN)) = Y
'            Next Z
'        Next Y
    'Next x
    For x = 0 To NextNo

'XX = TraceBak(NextNo - 2)

        If TraceBak(x) > 0 Then
            If (DLen(x) < Cutoff) Then
    
                '//First find two sequences with this dist
                GoOn = 0
                LODist = 100000
                FP = 0
                For Y = 0 To NextNo
                    
                    For Z = Y + 1 To NextNo
    '                    If FP = 1 Then
    '                            x = x
    '                        End If
                        If (AMat(Y, Z) = TraceBak(x)) Then '21,24:
                            GoOn = 1
    '                        If FP = 1 Then
    '                            x = x
    '                        End If
                            'XX = AMat(21, 36)
                            For A = 0 To NextNo
                                If (AMat(A, Z) = AMat(A, Y)) Then
                                    If AMat(A, Z) > TraceBak(x) And AMat(A, Z) < LODist Then '36,186
'                                        If FP = 1 Then
'                                            x = x
'                                        End If
                                        LODist = AMat(A, Z)
                                        
                                    End If
                                End If
                            Next A
                            'FP = 1
                            'If LODist < 100000 Then Exit For 'FP = 1
                            Exit For
                        End If
                    Next Z
                    If GoOn = 1 Then Exit For
                    'If LODist < 100000 Then Exit For
                Next Y
    
                '//Find next lowest dist
                If GoOn = 1 Then
    
                    If LODist < 100000 Then
                        
                        For Y = 0 To NextNo
                            
                            For Z = Y + 1 To NextNo
                                If AMat(Z, Y) = TraceBak(x) Then
                                    If Y = 21 Or Z = 21 Then
                                    If Y = 24 Or Z = 24 Then
                                        x = x
                                    End If
                                    End If
                                    For A = 0 To NextNo
                                        If AMat(A, Y) > AMat(Y, Z) And AMat(A, Y) < LODist Then
                                            AMat(A, Y) = LODist
                                            AMat(Y, A) = LODist
                                            AMat(A, Z) = LODist
                                            AMat(Z, A) = LODist
                                        End If
                                    Next A
                                    AMat(Y, Z) = (LODist) '0.125, 0.126
                                    AMat(Z, Y) = (LODist)
                                    
                                End If
                            Next Z
                        Next Y
                        
                    Else
                        For Y = 0 To NextNo - 1
                            
                            For Z = Y + 1 To NextNo
    
                                If AMat(Z, Y) = TraceBak(x) Then
'                                    If Y = 0 And Z = 37 Then
'                                        x = x
'                                    End If
                                    CMat(Y, Z) = TraceBak(x)
                                    CMat(Z, Y) = TraceBak(x)
    
                                End If
    
                            Next Z
                        Next Y
                    End If
    
                Else
                    x = x
                End If
            
            Else
                For Y = 0 To NextNo
                    
                    For Z = Y To NextNo
                        If AMat(Z, Y) = TraceBak(x) Then
    '                        If Y = 0 And Z = 37 Then
    '                                    x = x
    '                                End If
                            CMat(Y, Z) = TraceBak(x)
                            CMat(Z, Y) = TraceBak(x)
    
                        End If
                    Next Z
                Next Y
            End If
        End If
    Next x
'    For x = 0 To NextNo
'        If TraceBak(x) = 0.19 Then '0.126 = 125; 0.19 = 189
'            x = x
'        End If
'    Next x
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            If LD < CMat(x, Y) And CMat(x, Y) < 0.193 Then LD = CMat(x, Y)
'            If CMat2(x, Y) <> CMat(x, Y) Then '0,37; 0,74; 0,75; 0,85; 0,87
'                x = x
'            End If
'        Next Y
'    Next x
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            If PAMat(x, Y) = 0.126 Then '1,154; 2,154; 4,154
'                x = x
'            End If
'            If PAMat(x, Y) = 0.19 Then '0,105; 1,105; 2,105,3,105, 5,105
'                x = x
'            End If
'        Next Y
'    Next x
End If


'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X

End Sub
Public Sub MakeDLen(NextNo As Long, DLen() As Single, LLen() As Single, NHNodeDepth() As Long, NodeDepth() As Integer, BootDepth() As Integer, RevC() As Long)

Dim x As Long, Y As Long, MatchNode() As String
If AbortFlag = 1 Then Exit Sub
ReDim MatchNode(NextNo, 5)
ReDim RevC(NextNo * 2)
For x = 0 To NextNo
    MatchNode(x, 0) = String$(NextNo + 1, "0")
    MatchNode(x, 1) = String$(NextNo + 1, "0")
    MatchNode(x, 2) = String$(NextNo + 1, "1")
    MatchNode(x, 3) = String$(NextNo + 1, "1")
    MatchNode(x, 4) = String$(NextNo + 1, "0")
    MatchNode(x, 5) = String$(NextNo + 1, "1")
Next x

'make a binary string representing presence(1) or absence (0) of individual sequences
'above each tree node

For x = 0 To NextNo
    For Y = 0 To NextNo
        If NodeDepth(x, Y) > -1 And NodeDepth(x, Y) <= NextNo Then
            Mid$(MatchNode(x, 0), NodeDepth(x, Y) + 1, 1) = 1
            Mid$(MatchNode(x, 2), NodeDepth(x, Y) + 1, 1) = 0
        Else
            x = x
        End If
        
        If NHNodeDepth(x, Y) > -1 And NHNodeDepth(x, Y) <= NextNo Then
            Mid$(MatchNode(x, 4), NHNodeDepth(x, Y) + 1, 1) = 1
            Mid$(MatchNode(x, 5), NHNodeDepth(x, Y) + 1, 1) = 0
            
        Else
            x = x
        End If
        If BootDepth(x, Y) > -1 And BootDepth(x, Y) < Len(MatchNode(x, 1)) Then
            Mid$(MatchNode(x, 1), BootDepth(x, Y) + 1, 1) = 1
            Mid$(MatchNode(x, 3), BootDepth(x, Y) + 1, 1) = 0
           
        End If
        If NodeDepth(x, Y) = -1 And BootDepth(x, Y) = -1 And NHNodeDepth(x, Y) = -1 Then Exit For
    Next Y
    x = x
Next x
       
ReDim DLen(NextNo)
       
For x = 0 To NextNo
    For Y = 0 To NextNo
        
        If MatchNode(x, 0) = MatchNode(Y, 1) Or MatchNode(x, 2) = MatchNode(Y, 1) Or MatchNode(x, 0) = MatchNode(Y, 3) Then
            DLen(x) = LLen(Y)
           
        End If
    Next 'Y
Next 'X

For x = 0 To NextNo
    For Y = 0 To NextNo
        
        If MatchNode(x, 4) = MatchNode(Y, 1) Or MatchNode(x, 5) = MatchNode(Y, 1) Or MatchNode(x, 4) = MatchNode(Y, 3) Or MatchNode(x, 5) = MatchNode(Y, 3) Then
            
            RevC(x) = LLen(Y)
           
        End If
    Next 'Y
Next 'X
If x = 123456 Then
    For x = 0 To NextNo
        'If RevC(X) = 0 Then
            For Y = x + 1 To NextNo
                'If DLen(Y) > 0 Then
                    If MatchNode(x, 4) = MatchNode(Y, 4) Or MatchNode(x, 5) = MatchNode(Y, 5) Or MatchNode(x, 4) = MatchNode(Y, 5) Or MatchNode(x, 5) = MatchNode(Y, 4) Then
                    x = x
                    '80,81
                    '80,82
                    '80,83
                    '80,84
                    '118,119
                    '140,141
                    '144,145
                    '144,146
                    '144,151
                    '145,146
                    '145,151
                    '167,168
                    '172,173
                    '174,175
                    '174,176
                    '185,186
                    '185,187
                    '193,194
                    '204,207
                    '215,217
                    '215,219
                    '216,218
                    '221,222
                    '226,228
                    '242,249
                    '242,250
                    '242,260
                    '242,261
                       x = x
                    End If
                'End If
            Next 'Y
        'End If
    Next 'X
    
    For x = 0 To NextNo
        If Left$(MatchNode(x, 4), 28) = String(20, "1") Or Left$(MatchNode(x, 5), 28) = String(20, "1") Then
            x = x
        End If
    Next x
    
    Open "RDP5BS2" + UFTag For Output As #1
    For x = 0 To NextNo
        Print #1, MatchNode(x, 4)
    
    Next x
    Close #1
End If
'XX = CurDir
'For X = 0 To NextNo
'    If LLen(X) = 100 Then
'        X = X '4,5,6,265
'    End If
'Next X

x = x
'For X = 0 To NextNo
'    XX = DLen(X)
'Next X
End Sub
Public Sub MakeBootDepth(TBSReps As Integer, NumberOfSeqs As Long, Getstring As String, LLen() As Single, BootDepth() As Integer, Treebyte() As Byte)

Dim CSeq As Long, PosP As Long, x As Long, Y As Long, SCount As Long, DCount As Long, LPos As Long, CCount As Long, Done() As Byte
If AbortFlag = 1 Then Exit Sub


ReDim BootDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), LLen(NumberOfSeqs + 1), Done(NumberOfSeqs + 1)

For x = 0 To NumberOfSeqs + 1
    For Y = 0 To NumberOfSeqs + 1
        BootDepth(x, Y) = -1
    Next Y
Next x

'sort out sequence order
SCount = 0: DCount = 0: LPos = 1: CCount = -1

Do While LPos < Len(Getstring)
    If Treebyte(LPos - 1) = 40 Then '(
        'find the matching )
        CCount = CCount + 1
        DCount = 1
        SCount = 0
        TPos = LPos + 1
        Do
            If Treebyte(TPos - 1) = 40 Then '(
                DCount = DCount + 1
            ElseIf Treebyte(TPos - 1) = 41 Then ')
                DCount = DCount - 1
                If DCount = 0 Then
                    If Treebyte(TPos) = 58 Then ':
                        If Treebyte(TPos + 8) = 46 Then '.
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 9))) / TBSReps) * 100)
                        ElseIf Treebyte(TPos + 7) = 46 Then '.
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 8))) / TBSReps) * 100)
                        ElseIf Treebyte(TPos + 6) = 46 Then '.
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 7))) / TBSReps) * 100)
                        ElseIf Treebyte(TPos + 5) = 46 Then '.
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 6))) / TBSReps) * 100)
                        ElseIf Treebyte(TPos + 4) = 46 Then '.
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 5))) / TBSReps) * 100)
                            XX = XX
                        Else
                            LLen(CCount) = CInt(((val(Mid$(Getstring, TPos + 2, 4))) / TBSReps) * 100)
                        End If

                    Else
                        LLen(CCount) = 0
                    End If

                    Exit Do
                End If

            ElseIf Treebyte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                PosP = InStr(TPos, Getstring, ":", vbBinaryCompare)
                If PosP = 0 Then Exit Sub
                CSeq = val(Mid$(Getstring, TPos + 1, PosP - TPos - 1))
                BootDepth(CCount, SCount) = CSeq
                SCount = SCount + 1
                If UBound(Done, 1) >= CSeq Then
                    If Done(CSeq) = 0 Then
                        Done(CSeq) = 1
                    End If
                Else
                    Exit Sub
                End If
            End If

            TPos = TPos + 1
        Loop

    End If

    LPos = LPos + 1
Loop
'For X = 0 To NextNo
'    For Y = 0 To NextNo
'        XX = BootDepth(X, Y)
'    Next Y
'    XX = LLen(X)
'Next X
x = x
End Sub

Public Sub MakeNodeDepth(NextNo As Long, TraceBak() As Single, DMat() As Single, NodeDepth() As Integer)
Dim Dummy As Long, FirstA As Byte, A As Long, b As Long, x As Long, Y As Long, Counter As Long, DoneDist() As Byte

ReDim NodeDepth(NextNo + 1, NextNo + 1)
ReDim DoneDist(PermNextno * 2, PermNextno)
ReDim TraceBak(NextNo)

If x = 12345 Then
    Dummy = MakeNodeDepthC(NextNo, PermNextno, UBound(NodeDepth, 1), UBound(DMat, 1), UBound(DoneDist, 1), DoneDist(0, 0), NodeDepth(0, 0), DMat(0, 0), TraceBak(0))
Else
    For x = 0 To NextNo + 1
        For Y = 0 To NextNo + 1
            NodeDepth(x, Y) = -1
        Next Y
    Next x

    '***************************Make a c++ version****************************
    'x@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    XX = UBound(DMat, 1)
    For x = 0 To PermNextno
        For Y = x + 1 To PermNextno
            If x <= XX And Y <= XX Then
            'if y < = ubound(dmat,1)
                DoneDist(CLng(DMat(x, Y) * 1000), x) = 1
                DoneDist(CLng(DMat(x, Y) * 1000), Y) = 1

            End If
        Next Y
    Next x
    A = -1: b = 0

    '***************************Make a c++ version****************************
    'x@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    For x = 0 To PermNextno * 2
        FirstA = 0
        For Y = 0 To PermNextno
            If DoneDist(x, Y) = 1 Then
                If FirstA = 0 Then
                    FirstA = 1
                    A = A + 1
                    b = 0
                End If
                NodeDepth(A, b) = Y
                TraceBak(A) = x / 1000
                b = b + 1
            End If
        Next Y
    Next x
End If
End Sub
Public Sub ReadTreeFile(NextNo As Long, V1, V2, FName As String, Getstring As String, Treebyte() As Byte)
Dim FF As Long, TS As String, FxName As String

FF = 25
Close #25 'FreeFile
RC = 0
SS = Abs(GetTickCount)
Redo:

'Read Treefile into getstring and treebyte
If FName <> "" Then
    Open FName For Binary Access Read As #FF
    'Open space for the entire treefile (Both a string and a byte array)
    Getstring = String$(LOF(FF), " ")
    ReDim Treebyte(LOF(FF))
    Get #FF, 1, Getstring
    Get #FF, 1, Treebyte()
    Close #FF
    If Getstring = "" Then ' something went wrong - it is probable that the phyml output tree couldnt be renamed treefile
        If BSTreeStrat = 0 Or BSTreeStrat = 1 Or BSTreeStrat = 2 Or BSTreeStrat = 3 Then
            FName = "infile_phyml_tree.txt"
            RC = RC + 2
            If RC > 3 Then Exit Sub
            GoTo Redo
            
        End If
    
    End If
    
Else
    'this converts nhstring back into getstring and treebyte
    Getstring = NHString(V1)
    Dim Nam As String
    If NextNo < 100 Then
        NLen = 2
    ElseIf NextNo < 1000 Then
        NLen = 3
    ElseIf NextNo < 10000 Then
        NLen = 4
    ElseIf NextNo < 100000 Then
        NLen = 5
    ElseIf NextNo < 1000000 Then
        NLen = 6
    End If
    For x = 0 To NextNo
        FxName = OriginalName(x)
        Call FixName(FxName)
        Pos = InStr(1, Getstring, FxName, vbBinaryCompare)
        If Pos > 0 Then
            XX = Len(Trim(Str(x)))
            Nam = "S" & String((NLen - Len(Trim(Str(x)))), "0") & Trim(Str(x))
            'Nam = "S" + Name
            'Nam = Nam + Trim(Str(X))
            oGetString = Getstring
            Getstring = Left(Getstring, Pos - 1) & Nam & Right(Getstring, Len(Getstring) - Pos - Len(FxName) + 1)
            'GetString = oGetString
            x = x
        End If
    
    Next x
    ReDim Treebyte(Len(Getstring))
    For x = 1 To Len(Getstring)
        Treebyte(x - 1) = Asc(Mid(Getstring, x, 1))
    Next x
End If
Dim TName2 As String
Dim TName As String
Pos = InStr(1, Getstring, "#NEXUS", vbBinaryCompare)
If Pos > 0 Then
    'its a nexus file so some work is needed
    Pos = InStr(Pos + 1, Getstring, "tree con_50_majrule", vbBinaryCompare)
    
    'Pos = InStr(Pos + 10, GetString, "tree con_50_majrule", vbBinaryCompare)
    LPos = Pos
    '22
    Pos = InStr(LPos, Getstring, ";", vbBinaryCompare)
    TS = Trim(Mid$(Getstring, LPos + 22, Pos - (LPos + 22) + 1))
    
    'now go through ts and remove everything between square brackets except the probabilities
    Pos = InStr(1, TS, "(", vbBinaryCompare)
    TS = Right(TS, Len(TS) - Pos + 1)
    Pos = 0
    Do
        Pos = InStr(Pos + 1, TS, "[", vbBinaryCompare)
        If Pos > 0 Then
            Pos1 = InStr(Pos + 1, TS, "]", vbBinaryCompare)
            
            CC = Mid$(TS, Pos, Pos1 - Pos)
            Pos2 = InStr(1, CC, "&prob=", vbBinaryCompare)
            If Pos2 > 0 And Mid$(TS, Pos - 1, 2) = ")[" Then
                
                CC = Mid$(CC, 8, Len(CC))
                Pos3 = InStr(Pos2 + 1, CC, ",prob", vbBinaryCompare)
                CC = Left(CC, Pos3 - 1)
                x = x
                'CC = Right(CC, Len(CC) - 1)
                x = x
            Else
                CC = ""
            End If
            
            AA = Left(TS, Pos - 1)
            BB = Mid$(TS, Pos1 + 1, Len(TS))
            TS = AA + CC + BB
            x = x
        Else
            Exit Do
        End If
    Loop
    
    'now go through and replace short numbers with sequence numbers
    
    NLen = Len(Trim(Str(NextNo)))
    If NLen = 1 Then NLen = 2
    For x = NextNo To 0 Step -1
            'If NJF = 1 Or X = X Then
                
        TName = Trim$(CStr(x))
        TName = String(NLen - Len(TName), "0") & TName
        TName = "S" & TName
        TName2 = "(" + Trim(CStr(x + 1)) + ":"
        Pos = 0
        Pos = InStr(1, TS, TName2, vbBinaryCompare)
        If Pos = 0 Then
            TName2 = "," + Trim(CStr(x + 1)) + ":"
            Pos = InStr(1, TS, TName2, vbBinaryCompare)
            x = x
            
        End If
        If Pos > 0 Then
            AA = Left(TS, Pos)
            BB = Mid$(TS, Pos + (Len(TName2) - 1), Len(TS))
            x = x
            TS = AA + TName + BB
            XX = XX
        Else
            x = x
            Open "treefile2" + UFTag For Output As #FF
            Print #FF, TS
            Close #FF
            x = x
        End If
    Next x
    Kill FName
    Open FName For Output As #FF
    Print #FF, TS
    Close #FF
    XX = Right(TS, 20)
    GoTo Redo
End If
Dim NumTaxa() As Long, NC As Long, BD As Long, BL As Long, BDH As String, BLH As String, PosOC() As Long, SRedoFlag As Byte
'check for trifurcations+
ReDim NumTaxa(NextNo)
'XX = UBound(NumTaxa, 1)
NC = -1
x = 1
'first find the number of characters in the bootstrap value and the number of characters in the branch length
'this is simply the shortest distance between a bracket close and a : and a : and a , respectively
Pos = InStr(1, Getstring, ")", vbBinaryCompare)
If Pos > 0 Then
    Pos2 = InStr(Pos, Getstring, ":", vbBinaryCompare)
Else
    Pos2 = 0
End If
If Pos2 > 0 Then
    Pos3 = InStr(Pos2, Getstring, ",", vbBinaryCompare)
End If
BD = Pos2 - Pos - 1
BL = Pos3 - Pos2 - 1
If BD > 0 Then
    If BD > 2 Then
        BDH = "0." & String(BD - 2, "0")
    Else
         BDH = "0"
    End If
Else
    BDH = ""
End If
If BL > 2 Then
    BLH = "0." & String(BL - 2, "0")
Else
    BLH = ""
End If

ReDim PosOC(1, NextNo * 2)
x = 1
NC = 0
SRedoFlag = 0
Do While x <= Len(Getstring)
    
    If Mid$(Getstring, x, 1) = "(" Then
        NC = NC + 1
        PosOC(0, NC) = x 'records positions where barckets open
    ElseIf Mid$(Getstring, x, 1) = "," Then
        NumTaxa(NC) = NumTaxa(NC) + 1
        If NumTaxa(NC) > 1 And NC > 1 Then 'trifurcation found
            TS = Left(Getstring, PosOC(0, NC)) + "(" + Mid$(Getstring, PosOC(0, NC) + 1, x - PosOC(0, NC) - 1) + ")" + BDH + ":" + BLH + Mid$(Getstring, x, Len(Getstring))
            
            Open "RDP5treefile2" + UFTag For Output As #FF
            Print #FF, TS
            Close #FF
            Getstring = TS
            SRedoFlag = 1
            'UB = UBound(PosOC, 2) + 1
            ReDim PosOC(1, NextNo * 2), NumTaxa(NextNo)
            x = 0
            NC = 0
            Exit Do
        End If
    ElseIf Mid$(Getstring, x, 1) = ")" Then
        PosOC(1, NC) = x 'records positions where they close
        
        Dummy = ClearNumTaxa(NC, NextNo, NumTaxa(0))
        
        'For Z = NC To Nextno
        '    NumTaxa(Z) = 0
        'Next Z
        
        
        
        NC = NC - 1
    End If
    x = x + 1
Loop
If SRedoFlag = 1 Then
    SRedoFlag = 0
    'XX = CurDir
    
    Close #FF
    Close #1
    'XX = CurDir + "\" + FName
    If Dir(CurDir + "\" + FName) <> "" Then
        Kill FName
        Sleep 100
    End If
    Close #26
    FF = 26
    Open FName For Output As #FF
    Print #FF, Getstring
    Close #FF
    GoTo Redo
End If
EE = Abs(GetTickCount)
TT = EE - SS
x = x
End Sub

Public Sub MakeConsenseFiles(NSeqs As Long)
'Make Batch File
Dim FF As Long

FF = FreeFile
If DebuggingFlag < 2 Then On Error Resume Next
Open "consense.bat" For Output As #FF
Print #FF, "consense <optfilec"
'Print #FF, "rename outfile outfilex"
'Print #FF, "del consense.bat"
Close #FF
On Error GoTo 0
Open "optfilec" For Output As #FF
Print #FF, "o"
Print #FF, Trim(Str(NSeqs + 1))
Print #FF, "2"
Print #FF, "1"
Print #FF, "y"
Close #FF

End Sub

Public Sub MakeETSeqNum(NextNo As Long, TSeqLen As Long, RS As Long, RE As Long, ETSeqNum() As Integer, TreeSeqNum() As Integer)
Dim Dummy As Long, x As Long, Y As Long, UBSN1 As Long, UBSN2 As Long, FF As Long
If RS < 1 Then RS = Len(StrainSeq(0))
If RE > Len(StrainSeq(0)) Then RE = 1
If RS < RE Then
    TSeqLen = RE - RS + 1 'Len(StrainSeq(0))
    
Else
    TSeqLen = RE + (Len(StrainSeq(0)) - RS) + 1
End If
Dim tez() As Integer

If TSeqLen > 50000 Then TSeqLen = 50000

If UBound(TreeSeqNum, 1) = 0 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "RDP5TreeSeqNum" + UFTag For Binary As #FF
    Get #FF, , UBSN1
    Get #FF, , UBSN2
    ReDim TreeSeqNum(UBSN1, UBSN2)
    Get #FF, , TreeSeqNum()
    Close #FF
    Kill "RDP5TreeSeqNum" + UFTag
End If

If ((TSeqLen * NextNo) > 20000000) Then  ' need to first create etseqnum on disk, then drop treeseqnum to disk, erase it, redim tseqnum and load it from disk
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim ETSeqNum(TSeqLen)
        Open "RDP5ETSeqnum" + UFTag For Binary As #FF
        For x = 0 To NextNo
                Dummy = MakeETSeqNumX(0, Len(StrainSeq(0)), TSeqLen, RS, RE, ETSeqNum(0), TreeSeqNum(0, x))
                'Dummy = MaketSeqNum2(Len(StrainSeq(0)), 0, tSeqNum2(0), SeqNum(0, x), tListToRedo(0))
'                For Y = 1 To Len(StrainSeq(0))
'                    If ETSeqNum(Y) <> TreeSeqNum(Y + RS - 1, x) Then
'                        x = x
'                    End If
'                Next Y
                Put #FF, , ETSeqNum()
        Next x
        Close #FF
        LoadSeqNumFromFile = 1
        UBSN1 = UBound(TreeSeqNum, 1)
        UBSN2 = UBound(TreeSeqNum, 2)
        '@'@'@'@'@
        Open "RDP5TreeSeqNum" + UFTag For Binary As #FF
        Put #FF, , UBSN1
        Put #FF, , UBSN2
        Put #FF, , TreeSeqNum()
        Close #FF
        'XX = UBound(PDistPlt, 1)
        ChDrive oDirX
        ChDir oDirX
        ReDim TreeSeqNum(0, 0)
        ReDim ETSeqNum(TSeqLen, NextNo)
        Open "RDP5ETSeqnum" + UFTag For Binary As #FF
            Get #FF, , ETSeqNum()
        Close #FF
        Kill "RDP5ETSeqnum" + UFTag
    
    Else
        '@'@
        ReDim ETSeqNum(TSeqLen, NextNo)
        '@
        Dummy = MakeETSeqNumX(NextNo, Len(StrainSeq(0)), TSeqLen, RS, RE, ETSeqNum(0, 0), TreeSeqNum(0, 0))
    End If
    



'Counter = TSeqLen
'SS = Abs(GetTickCount)
'For Z = 0 To 100




    



End Sub
Public Sub CopyExtraHits(ENumb As Long, ExtraHits() As Byte, tExtrahits() As Byte)
Dim x As Long

    For x = 0 To PermNextno
        ExtraHits(x, ENumb) = tExtrahits(x)
    Next x

End Sub
Public Sub SwapInvolved(DR As Integer, MiR As Integer, MaR As Integer, ENumb As Long, DI() As Byte, MiI() As Byte, MaI() As Byte, DScores() As Double)
Dim TDr() As Byte, tMi() As Byte, tMa() As Byte, TScore() As Double
ReDim TDr(NextNo), tMi(NextNo), tMa(NextNo), TScore(25, 2)


If DR > -1 Then
    For x = 0 To NextNo
        TDr(x) = DI(ENumb, x)
    Next x
    For x = 0 To 25
        TScore(x, 0) = DScores(x, 0, ENumb)
    Next x
End If

If MiR > -1 Then
    For x = 0 To NextNo
        tMi(x) = MiI(ENumb, x)
    Next x
    For x = 0 To 25
        TScore(x, 2) = DScores(x, 2, ENumb)
    Next x
End If
If MaR > -1 Then
    For x = 0 To NextNo
        tMa(x) = MaI(ENumb, x)
    Next x
    For x = 0 To 25
        TScore(x, 1) = DScores(x, 1, ENumb)
    Next x
End If

If DR = 1 Then
    For x = 0 To NextNo
        DI(ENumb, x) = tMa(x)
    Next x
    For x = 0 To 25
        DScores(x, 0, ENumb) = TScore(x, 1)
    Next x
ElseIf DR = 2 Then
    For x = 0 To NextNo
        DI(ENumb, x) = tMi(x)
    Next x
    For x = 0 To 25
        DScores(x, 0, ENumb) = TScore(x, 2)
    Next x
End If
If MiR = 1 Then
    For x = 0 To NextNo
        MiI(ENumb, x) = tMa(x)
    Next x
    For x = 0 To 25
        DScores(x, 2, ENumb) = TScore(x, 1)
    Next x
ElseIf MiR = 0 Then
    For x = 0 To NextNo
        MiI(ENumb, x) = TDr(x)
    Next x
    For x = 0 To 25
        DScores(x, 2, ENumb) = TScore(x, 0)
    Next x
End If

'XX = Daught(ENumb, 192)
If MaR = 0 Then
    For x = 0 To NextNo
        MaI(ENumb, x) = TDr(x)
    Next x
    For x = 0 To 25
        DScores(x, 1, ENumb) = TScore(x, 0)
    Next x
ElseIf MaR = 2 Then
    For x = 0 To NextNo
        MaI(ENumb, x) = tMi(x)
    Next x
    For x = 0 To 25
        DScores(x, 1, ENumb) = TScore(x, 2)
    Next x
End If

End Sub
Public Sub MajMinSwap(TraceNumb As Long, Trace() As Long, XoverList() As XOverDefine)
Dim x As Long, TLong As Long
For x = 0 To TraceNumb
    
    TLong = XoverList(Trace(0, x), Trace(1, x)).Beginning - 1
    If TLong < 1 Then TLong = Len(StrainSeq(0))
    
    XoverList(Trace(0, x), Trace(1, x)).Beginning = XoverList(Trace(0, x), Trace(1, x)).Ending + 1
    If XoverList(Trace(0, x), Trace(1, x)).Beginning > Len(StrainSeq(0)) Then
        XoverList(Trace(0, x), Trace(1, x)).Beginning = 1
    End If
    
    XoverList(Trace(0, x), Trace(1, x)).Ending = TLong
    
    TLong = XoverList(Trace(0, x), Trace(1, x)).MinorP
    XoverList(Trace(0, x), Trace(1, x)).MinorP = XoverList(Trace(0, x), Trace(1, x)).MajorP
    XoverList(Trace(0, x), Trace(1, x)).MajorP = TLong
    
    If XoverList(Trace(0, x), Trace(1, x)).OutsideFlag = 1 Then
        XoverList(Trace(0, x), Trace(1, x)).OutsideFlag = 2
    ElseIf XoverList(Trace(0, x), Trace(1, x)).OutsideFlag = 2 Then
        
        XoverList(Trace(0, x), Trace(1, x)).OutsideFlag = 1
    End If
Next x
End Sub
Public Sub GroupRejectEvent(TraceNumb As Long, Trace() As Long, XoverList() As XOverDefine)
Dim x As Long, TLong As Long
For x = 0 To TraceNumb
    
    If XoverList(Trace(0, x), Trace(1, x)).Accept = 1 Then
        XoverList(Trace(0, x), Trace(1, x)).Accept = 0
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
    ElseIf XoverList(Trace(0, x), Trace(1, x)).Accept = 0 Then
        XoverList(Trace(0, x), Trace(1, x)).Accept = 2
        XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = XoverList(Trace(0, x), Trace(1, x)).ProgramFlag + AddNum
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
    End If
    
Next x
End Sub
Public Sub IndvAcceptEvent(NFound As Byte, TSeq As Long, TPrg As Byte, TraceNumb As Long, Trace() As Long, XoverList() As XOverDefine)
Dim x As Long, TLong As Long
For x = 0 To TraceNumb
   ' If Trace(0, X) = 1 And Trace(1, X) = 2 Then
   '     X = X
   ' End If
    If XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = TPrg Or XoverList(Trace(0, x), Trace(1, x)).ProgramFlag - AddNum = TPrg Then
        If XoverList(Trace(0, x), Trace(1, x)).Daughter = TSeq Or ((XoverList(Trace(0, x), Trace(1, x)).MinorP = TSeq Or XoverList(Trace(0, x), Trace(1, x)).MajorP = TSeq) And DontSaveUndo = 0) Then 'the dontsaveundo here is to ensure that only the selected events in xolist is accepted if a multiple accept is attempted from the tree
            If XoverList(Trace(0, x), Trace(1, x)).Accept = 0 Then
                XoverList(Trace(0, x), Trace(1, x)).Accept = 1
                DoneMatX(1) = 0
                DoneMatX(2) = 0
                DoneMatX(3) = 0
                DoneMatX(4) = 0
            ElseIf XoverList(Trace(0, x), Trace(1, x)).Accept = 2 Then
                XoverList(Trace(0, x), Trace(1, x)).Accept = 1
                DoneMatX(1) = 0
                DoneMatX(2) = 0
                DoneMatX(3) = 0
                DoneMatX(4) = 0
                DoneTree(0, 3) = 0
                DoneTree(1, 3) = 0
                DoneTree(2, 3) = 0
                DoneTree(3, 3) = 0
                DoneTree(4, 3) = 0
                If XoverList(Trace(0, x), Trace(1, x)).ProgramFlag >= AddNum Then
                    XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = XoverList(Trace(0, x), Trace(1, x)).ProgramFlag - AddNum
                End If
                NFound = 1
            End If
        End If
    End If
    
Next x
End Sub
Public Sub IndvrejectEvent(NFound As Byte, TSeq As Long, TPrg As Byte, TraceNumb As Long, Trace() As Long, XoverList() As XOverDefine)
Dim x As Long, TLong As Long


If DebuggingFlag < 2 Then On Error Resume Next
XX = 0
XX = UBound(XoverList, 1)
If XX = 0 Then Exit Sub
On Error GoTo 0

For x = 0 To TraceNumb
    If XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = TPrg Or XoverList(Trace(0, x), Trace(1, x)).ProgramFlag - AddNum = TPrg Then
        If XoverList(Trace(0, x), Trace(1, x)).Daughter = TSeq Or XoverList(Trace(0, x), Trace(1, x)).MinorP = TSeq Or XoverList(Trace(0, x), Trace(1, x)).MajorP = TSeq Then
            If XoverList(Trace(0, x), Trace(1, x)).Accept = 1 Then
                XoverList(Trace(0, x), Trace(1, x)).Accept = 0
                DoneMatX(1) = 0
                DoneMatX(2) = 0
                DoneMatX(3) = 0
                DoneMatX(4) = 0
            ElseIf XoverList(Trace(0, x), Trace(1, x)).Accept = 0 Then
                XoverList(Trace(0, x), Trace(1, x)).Accept = 2
                XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = XoverList(Trace(0, x), Trace(1, x)).ProgramFlag + AddNum
                NFound = 1
                DoneMatX(1) = 0
                DoneMatX(2) = 0
                DoneMatX(3) = 0
                DoneMatX(4) = 0
            End If
        End If
    End If
    
Next x
End Sub
Public Sub GroupAcceptEvent(TraceNumb As Long, Trace() As Long, XoverList() As XOverDefine)
Dim x As Long, TLong As Long
For x = 0 To TraceNumb
    
    If XoverList(Trace(0, x), Trace(1, x)).Accept = 0 Then
        XoverList(Trace(0, x), Trace(1, x)).Accept = 1
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
    ElseIf XoverList(Trace(0, x), Trace(1, x)).Accept = 2 Then
        XoverList(Trace(0, x), Trace(1, x)).Accept = 0
        If XoverList(Trace(0, x), Trace(1, x)).ProgramFlag > AddNum - 1 Then
            XoverList(Trace(0, x), Trace(1, x)).ProgramFlag = XoverList(Trace(0, x), Trace(1, x)).ProgramFlag - AddNum
        End If
        DoneMatX(1) = 0
        DoneMatX(2) = 0
        DoneMatX(3) = 0
        DoneMatX(4) = 0
        
        DoneTree(0, 3) = 0
        DoneTree(1, 3) = 0
        DoneTree(2, 3) = 0
        DoneTree(3, 3) = 0
        DoneTree(4, 3) = 0

    End If
    
Next x

End Sub
Public Sub AddEvents(TraceNumb As Long, Trace() As Long, CurrentXOver() As Integer, XoverList() As XOverDefine, CurrentXoverR() As Integer, XOverListR() As XOverDefine)
Dim UB As Long, UB2 As Long, x As Long
For x = 0 To TraceNumb
    CurrentXoverR(Trace(0, x)) = CurrentXoverR(Trace(0, x)) + 1
    UB = UBound(XOverListR, 2)
    If CurrentXoverR(Trace(0, x)) > UB Then
        UB = UB + 10
        UB2 = UBound(XOverListR, 1)
        ReDim Preserve XOverListR(UB2, UB)
    End If
    XOverListR(Trace(0, x), CurrentXoverR(Trace(0, x))) = XoverList(Trace(0, x), Trace(1, x))
    'XX = XOverListR(Trace(0, X), CurrentXoverR(Trace(0, X))).ProgramFlag
    'XX = SuperEventlist(XOverListR(80, 1).Eventnumber)
Next x

'Mark events for removal
For x = 0 To TraceNumb
    XoverList(Trace(0, x), Trace(1, x)).Probability = -1
Next x

End Sub
Public Sub CleanXOList(ENumb As Long, XoverList() As XOverDefine, CurrentXOver() As Integer, Involved() As Byte)

For x = 0 To PermNextno
    If Involved(ENumb, x) > 0 And Involved(ENumb, x) < 5 Then
        Y = CurrentXOver(x)
        If Y <= UBound(XoverList, 2) Then
            Do While Y > 0
                If XoverList(x, Y).Probability = -1 Then
                    If Y < CurrentXOver(x) Then
                        XoverList(x, Y) = XoverList(x, CurrentXOver(x))
'                    Else
'                        XX = XoverList(x, Y).Beginning
'                        XX = XoverList(x, Y).Ending
                        
                    End If
                    CurrentXOver(x) = CurrentXOver(x) - 1 '13,16
                End If
                Y = Y - 1
            Loop
        End If
    End If
Next x
x = x
End Sub

Public Sub FindSameE(InvolvedR, OnlyAccept, TraceNumb As Long, ENumb As Long, XoverList() As XOverDefine, CurrentXOver() As Integer, Trace() As Long, Involved() As Byte)
Dim XX As Long, x As Long, Y As Long, UB As Long
TraceNumb = 0
If DebuggingFlag < 2 Then On Error Resume Next
XX = 0
XX = UBound(CurrentXOver, 1)
If XX = 0 Then Exit Sub



On Error GoTo 0
XX = SEPAVal

'if extraevents are involved then need to circumvent the involved check.


For x = 0 To PermNextno
'If X = 703 Then
'    X = X
'End If
'If X = 50 Then
'    X = X
'End If
'    If X = 808 Then
'        X = X
'        End If
    If x <= UBound(Involved, 2) Then
    If Involved(ENumb, x) > 0 Or InvolvedR = 1 Then '670,672,673
        
        For Y = 1 To CurrentXOver(x) 'Daught:22,25,29,33:Min:0,1
            
            UB = UBound(XoverList, 2)
            If CurrentXOver(x) <= UB Then
            If XoverList(x, Y).Eventnumber <= UBound(SuperEventList, 1) Then
                If SuperEventList(XoverList(x, Y).Eventnumber) = ENumb Then
                    If XoverList(x, Y).Probability > -1 Then
                        If OnlyAccept = 0 Or (XoverList(x, Y).Accept = 1 Or XoverList(x, Y).Accept = 3) Then
                            UB = UBound(Trace, 2)
                            If TraceNumb > UB Then
                                UB = UB + 10
                                ReDim Preserve Trace(1, UB)
                            End If
                            Trace(0, TraceNumb) = x
                            Trace(1, TraceNumb) = Y
                            TraceNumb = TraceNumb + 1
                            If Involved(ENumb, x) = 0 Then
                                
                                If XoverList(x, Y).Probability < LowestProb And XoverList(x, Y).Probability > 0 Then
                                    Involved(ENumb, x) = 1
                                
                                Else
                                    Involved(ENumb, x) = 5
                                End If
                            End If
                        End If
                    End If
                End If
            End If
            End If
        Next Y
    End If
    End If
Next x

'XX = UBound(XoverList, 2)

TraceNumb = TraceNumb - 1
'If TraceNumb < 0 Then
'    Trace(0, TraceNumb) = BestEvent(ENumb, 0)
'    Trace(1, TraceNumb) = BestEvent(ENumb, 1)
'    TraceNumb = TraceNumb + 1
'End If
End Sub
Public Function GetMSize(XoverList() As XOverDefine)
Dim x As Long, Y As Long

MSize = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If MSize < XoverList(x, Y).Daughter Then MSize = XoverList(x, Y).Daughter
        If MSize < XoverList(x, Y).MinorP Then MSize = XoverList(x, Y).MinorP
        If MSize < XoverList(x, Y).MajorP Then MSize = XoverList(x, Y).MajorP
    Next Y
Next x
GetMSize = MSize
End Function

Public Sub DoPermsB()
'I havn't implemented this for bootscan and siscan
Dim TXOS As Long
GRndSeed = 3

Dim PMaxListSize As Long, Treestring As String, RatesArray() As Double, LS As Long, Fraglen As Long, NumRates As Long, PValPos(1) As Long, PListSize As Long, LowSize As Long, PValList() As Long, TargetProb As Long, WinPos As Long, tTopP As Double, TopP As Double, RandNum As Long, LSeq As Long, THold As Integer, tBestPermP() As Double, CurrentNo As Long
PMaxListSize = 10
ReDim PermsCurrentXOver(GPerms, NextNo), PermsXOverList(GPerms, NextNo, PMaxListSize)
If DebuggingFlag < 2 Then On Error Resume Next
PermTypeFlag = 1
oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0

LS = Len(StrainSeq(0))
Fraglen = 20





ReDim BestPermP(GPerms, AddNum - 1)
LowSize = Int(-Log10(LowestProb))
PListSize = 100 + LowSize
'seed the rnd number generator
Rnd (-BSRndNumSeed)
'Randomize GRndSeed
LSeq = Len(StrainSeq(0))

APermFlag = 0
For x = 0 To AddNum - 1
    CritPVals(x) = LowestProb
Next x
If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim ValidSpacer(NextNo)
    ReDim SpacerSeqs(NextNo)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
End If

If DoScans(0, 1) = 1 Then

    If GCtripletflag = 1 Then
                ReDim SubSeq(Len(StrainSeq(0)), 6)
                ReDim XDiffPos(Len(StrainSeq(0)) + 200)
                ReDim XPosDiff(Len(StrainSeq(0)) + 200)
                ReDim FragMaxScore(GCDimSize, 5)
                ReDim MaxScorePos(GCDimSize, 5)
                ReDim PVals(GCDimSize, 5)
                ReDim FragSt(GCDimSize, 6)
                ReDim FragEn(GCDimSize, 6)
                ReDim FragScore(GCDimSize, 6)
                ReDim DeleteArray(Len(StrainSeq(0)) + 1)
    End If

End If

If DoScans(0, 3) = 1 Then
    If MCTripletFlag = 0 Then
            HWindowWidth = CLng(MCWinSize / 2)
            ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
            ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
            ReDim Chivals(Len(StrainSeq(0)), 2)
         
            ReDim SmoothChi(Len(StrainSeq(0)), 2)
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
            If MCProportionFlag = 0 Then
                Call GetCriticalDiff(0)
                If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
                    MCWinSize = HWindowWidth * 2
                End If
            End If
    End If
End If
If DoScans(0, 4) = 1 Then
    HWindowWidth = CLng(CWinSize / 2)
    ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim ChiValsX(Len(StrainSeq(0)))
   
    ReDim SmoothChiX(Len(StrainSeq(0)))
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    Call GetCriticalDiff(1)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
            CWinSize = HWindowWidth * 2
        End If
    
End If

If DoScans(0, 5) = 1 Then
        Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte
        
        'Dimension horizontal randomisation array if necessary
        If SSOutlyerFlag = 0 Or x = x Then
            ReDim HRandTemplate(SSWinLen)
            ReDim TakenPos(SSWinLen)
        End If
        ReDim VRandTemplate(0, 0)
        GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwTotalPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        LmB = Len(StrainSeq(0))
        LmB = LmB * SSNumPerms
        LmB = LmB * 12
        If APhys < LmB Then
                OP = SSNumPerms
                SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
                pSSNumPerms = SSNumPerms
                If SSNumPerms < 100 Then
                    If CLine = "" Or CLine = " " Then
                        MsgBox ("There is not enough free memory available to perform a SiScans in either exploratory or checking modes - Both modes will, therefore, be disabled.  Perhaps if you close some programs the situation will improve.")
                    End If
                    DoScans(0, 5) = 0
                    DoScans(1, 5) = 0
                Else
                    If CLine = "" Or CLine = " " Then
                        MsgBox ("You have specified that you would like to do a scan with " + Trim(Str(OP)) + " permutations. There is, however, only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations.")
                    End If
                End If
            End If
        'Dimension vertical randomisation array
        ReDim VRandTemplate(Len(StrainSeq(0)), SSNumPerms)
        
        Dim DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte
        ReDim DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)
        
        Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
        
End If





'XX = CurDir
Form1.SSPanel1.Caption = "0 of " & Trim(Str(GPerms)) & " permutations completed"
Dim SEFNum As Byte, EMapNum As Byte, BPMapNum As Byte



'Set up all the output files
SEFNum = FreeFile + 80
'If DebuggingFlag < 2 Then On Error Resume Next
'killfile "SEList.csv"
'On Error GoTo 0
Open "SEList.csv" For Output As #SEFNum
EMapNum = SEFNum + 1
Open "EMap.csv" For Output As #EMapNum
BPMapNum = SEFNum + 2
Open "BPMap.csv" For Output As #BPMapNum


XX = -Log10(1)
x = x
Dim TempString(1)  As String, NameString As String
NameString = ",RDP,GENECONV,BOOTSCAN,MAXCHI,CHIMAERA,SISCAN,PHYLPRO,Consensus,"
TempString(0) = "Permutation #,"
For x = LowSize To PListSize
    XX = 1 - x / 10

    TempString(0) = TempString(0) + ",,<" + Str(1 - x / 10) + ",,,,,,,"
    TempString(1) = TempString(1) + NameString
Next x
Print #SEFNum, TempString(0)
Print #SEFNum, TempString(1)
TempString(0) = ""

For x = LowSize To PListSize
    TempString(0) = TempString(0) + ",<" + Str(1 - x / 10)
   
Next x
Print #EMapNum, TempString(0)
Print #BPMapNum, TempString(0)


ReDim BSFilePos(NextNo, NextNo)


ReDim BPListHolder(Len(StrainSeq(0)), GPerms)
ST = Abs(GetTickCount)
OSt = ST
For CPermNo = 0 To GPerms
    ST2 = Abs(GetTickCount)
    ST = OSt
    ReDim CurrentXOver(NextNo + 1)
    ReDim XoverList(NextNo, XOverListSize), MissingData(Len(StrainSeq(0)), NextNo), TreeTrace(NextNo)
    ReDim MaxXOP(AddNum - 1, NextNo)
    Call SetupGlobals2
    ReDim oRecombNo(100)
    SEventNumber = 0
    'ReDim XOverlist(Nextno, XOverListSize)
    
    XX = UBound(SeqNum, 1)
    'Randomise the sequence
    If CPermNo > 0 Then
        
        If PermTypeFlag = 1 Then 'This does an alignment column shuffle
            For Y = 1 To Len(StrainSeq(0))
                RandNum = Int((LSeq * Rnd) + 1)
                For Z = 0 To NextNo
                    THold = SeqNum(Y, Z)
                    SeqNum(Y, Z) = SeqNum(RandNum, Z)
                    SeqNum(RandNum, Z) = THold
                Next Z
            Next Y
        Else 'this is for seqgen generated perms
            If CPermNo = 1 Then
'                Dim DelSeqNum() As Integer
'                ReDim DelSeqNum(Len(StrainSeq(0)), Nextno)
'                Dummy = CopySeqs(Len(StrainSeq(0)), Nextno, SeqNum(0, 0), DelSeqNum(0, 0))
'                ''Make RatesArray
'                Call MakeRatesArray(RatesArray(), LS, Nextno, Fraglen, NumRates, DelSeqNum())
                
                'Make a newik format tree of the entire alignment for use in seqgen sims
                Call MakeTreeString(Treestring, LS, NextNo, SeqNum())
                
                'add the treestring and rates together to make the seqgen infile
                Call MakeSimTree("simtree", Treestring, NumRates, Fraglen, RatesArray())
            
            End If
            Call MakeSeqGenBat("outfilex", CPermNo, NumRates, Fraglen, TOModel, TOTvTs, TOFreqFlag, TOFreqA, TOFreqC, TOFreqG, TOFreqT)
            ShellAndClose "seqgen.bat", 0
            Call GetPermSeqs("outfilex", LS, NextNo, SeqNum())
            
            If DebuggingFlag < 2 Then On Error Resume Next
            If UBound(SeqCol, 1) < NextNo Or UBound(FFillCol, 1) < NextNo Then
                ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
            End If
            
            If UBound(XCord, 3) < NextNo + 2 Or UBound(YCord, 3) < NextNo + 2 Or UBound(RYCord, 3) < NextNo + 2 Then
                ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
            End If
            
            On Error GoTo 0
            ReDim TreeDistance(NextNo, NextNo)
            ReDim Distance(NextNo, NextNo)
            ReDim Preserve OriginalName(NextNo)
                
            Udst = DistanceCalc(NextNo, Len(StrainSeq(0)) + 1, SeqNum(0, 0), Distance(0, 0), AvDst)
            
            
            For x = 0 To NextNo
                Distance(x, x) = 1
            Next x
                
            DistanceFlag = 0
            TreeDistFlag = 0
            Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
            Call DrawTree
            
            If PermNextno > MemPoc And TreeXInFileFlag = 0 Then
                TreeXUB = UBound(TreeX, 1)
                TreeXInFileFlag = 1
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                FF = FreeFile
                Open "RDP5TreeX" + UFTag For Binary As #FF
                Put #FF, , TreeX()
                Close #FF
                ChDir oDir
                ChDrive oDir
                Erase TreeX
            End If
            
        End If
    End If
    
    If CPermNo > 0 And x = 12345 Then
        Dim tStrainseq() As String
        ReDim tStrainseq(NextNo)
        XX = CurDir
        Open Trim(Str(CPermNo)) & ".fas" For Output As #1
        For x = 0 To NextNo
            
            For Y = 1 To Len(StrainSeq(0))
                tStrainseq(x) = tStrainseq(x) + Chr(SeqNum(Y, x) - 1)
            Next Y
        Next x
        For x = 0 To NextNo
            Print #1, ">" & OriginalName(x)
            Print #1, tStrainseq(x)
            Print #1, ""
        Next x
        Close #1
    End If
    Z = 0
    
    For Seq1 = 0 To NextNo - 2
        If MaskSeq(Seq1) = 0 Then
            For Seq2 = Seq1 + 1 To NextNo - 1
                If MaskSeq(Seq2) = 0 Then
                    For Seq3 = Seq2 + 1 To NextNo
                        If MaskSeq(Seq3) = 0 Then
                            
                            If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                             
                                    
                                If DoScans(0, 1) = 1 Then Call GCXoverD(0)
                                
                                If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
                                If DoScans(0, 4) = 1 Then
                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                            
                                    Call CXoverA(0, 0, 0)
                                            
                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                            
                                    Call CXoverA(0, 0, 0)
                                            
                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                            
                                    Call CXoverA(0, 0, 0)
                                            
                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                End If
                                If DoScans(0, 8) = 1 Then
                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                            
                                    Call TSXOver(0)
                                            
                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                            
                                    Call TSXOver(0)
                                            
                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                            
                                    Call TSXOver(0)
                                            
                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                End If
                                b = b + 1
                            End If
                            
                            
                        Next Seq3
                End If
                ET = Abs(GetTickCount)
                If Abs(ET - GlobalTimer) > 500 Then
                    
                    XX = (ET - ST2)
                    Form1.Label50(0).Caption = DoTimeII(ET - ST2)
                    Form1.Label50(12).Caption = DoTimeII(ET - ST)
                    UpdateRecNums (SEventNumber)
                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        'StartPlt(0) = 1
                        'StartPlt(1) = 1
                        'StartPlt(2) = 1
                        'StartPlt(3) = 1
                        'StartPlt(4) = 1
                        'StartPlt(5) = 1
                        'StartPlt(6) = 1
                        oRec = oRecombNo(100)
                        Call UpdatePlotC
                    End If
                    GlobalTimer = ET
                    If (b + 1) < MCCorrection Then
                        Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
                        Form1.SSPanel13.Caption = "Approximately " & DoTime((ET - ST2) * (100 / Form1.ProgressBar1.Value) - (ET - ST)) & " remaining"
                        Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
                        Call UpdateF2Prog
                    End If
                    Form1.Refresh
                    If AbortFlag = 1 Then
                        
                        Exit Sub
                    End If
                End If
            Next Seq2
        End If
    Next Seq1
    

    '
    'Form1.Label50(0).Caption = DoTimeII(ET - ST2)
    'Form1.label50(12).Caption = DoTimeII(ET - ST)
   ' If doscans(0,2) = 1 Then
   '     'BSStepsize = BSStepsize
   '     Call BSXoverR '(BackupNextno, Seq1, Seq2, Seq3, TraceSub(), SimSeqMap())
   ' End If
   ' If doscans(0,5) = 1 Then
   '     Call SSXoverC(0,Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
   '     SSOutlyerFlag = pSSOutlyerFlag
  '  End If
    oRecombNo(100) = 0
    
    Form1.SSPanel1.Caption = Trim(Str(CPermNo)) & " of " & Trim(Str(GPerms)) & " permutations completed"
    Form1.ProgressBar1 = CPermNo / GPerms * 100
    Call UpdateF2Prog
    Print #SEFNum, ""
    DoneTree(0, 3) = 0
    DoneTree(1, 3) = 0
    Call DoRDP(0, CPermNo)
    
    ReDim PValList(AddNum, PListSize)
    
    'ConsensusProg = 1
    'I'm counting the same events in diffrent sequences as though they were unique here
    '- I must look exclusively at the bestevenst list
    If CPermNo > 0 Then
        For x = 1 To SEventNumber
            'Do Consensus
            If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).ProgramFlag < AddNum Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                PermsCurrentXOver(CPermNo, D) = PermsCurrentXOver(CPermNo, D)
                UB = UBound(PermsXOverList, 3)
                If PermsCurrentXOver(CPermNo, D) > UB Then
                    ReDim Preserve PermsXOverList(GPerms, NextNo, UB + 10)
                End If
                PermsXOverList(CPermNo, D, PermsCurrentXOver(CPermNo, D)) = XoverList(BestEvent(x, 0), BestEvent(x, 1))
                CNum = 0
                For Z = 0 To AddNum - 1
                    If Confirm(SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber), Z) > 0 Then
                        CNum = CNum + 1
                    End If
                Next Z
                'store how much support there is for this event
                PermsXOverList(CPermNo, D, PermsCurrentXOver(CPermNo, D)).LHolder = CNum
            End If
            
            
        Next x
    End If
    
            
    For x = 1 To SEventNumber
        'Do Consensus
        If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).ProgramFlag < AddNum Then
            CNum = 0
            For Z = 0 To AddNum - 1
                If Confirm(SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber), Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            If CNum > ConsensusProg Or ConsensusProg = 0 Then
                PValPos(1) = Int((-Log10(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability)) * 10)
                PValPos(0) = AddNum
                If PValPos(1) > PListSize Then PValPos(1) = PListSize
                PValList(PValPos(0), PValPos(1)) = PValList(PValPos(0), PValPos(1)) + 1
            End If
        End If
        
        
    Next x
    
     
    Dim Done2() As Byte
    ReDim Done2(SEventNumber, AddNum)
    ReDim DoneOne(NextNo, UBound(XoverList, 2))
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If DoneOne(x, Y) = 0 Then
                DoneOne(x, Y) = 1
                PValPos(1) = Int((-Log10(XoverList(x, Y).Probability)) * 10)
                PValPos(0) = XoverList(x, Y).ProgramFlag
                If PValPos(0) < AddNum Then
                    ENumb = SuperEventList(XoverList(x, Y).Eventnumber)
                    If Done2(ENumb, PValPos(0)) = 0 Then
                        Done2(ENumb, PValPos(0)) = 1
                         For A = 0 To NextNo
                            For b = 1 To CurrentXOver(A)
                                If DoneOne(A, b) = 0 And XoverList(A, b).ProgramFlag = PValPos(0) And SuperEventList(XoverList(A, b).Eventnumber) = ENumb Then
                                    DoneOne(A, b) = 1
                                    If PValPos(1) < Int((-Log10(XoverList(A, b).Probability)) * 10) Then
                                        PValPos(1) = Int((-Log10(XoverList(A, b).Probability)) * 10)
                                    End If
                                End If
                            Next b
                        Next A
                        If PValPos(1) > PListSize Then PValPos(1) = PListSize
                        PValList(PValPos(0), PValPos(1)) = PValList(PValPos(0), PValPos(1)) + 1
                        
                    End If
                End If
            End If
        Next Y
    Next x
    
   'For X = 0 To 11
   '     XX = PValList(0, X)
   '     XX = PValList(7, X)
   ' Next X
    
    For x = 0 To AddNum
        For Y = LowSize To PListSize
            For Z = Y + 1 To PListSize
                PValList(x, Y) = PValList(x, Y) + PValList(x, Z)
            Next Z
        Next Y
    Next x
    
    TempString(0) = Str(CPermNo) + ","
    For x = LowSize To PListSize
        For Y = 0 To AddNum
            TempString(0) = TempString(0) + Str(PValList(Y, x)) + ","
        Next Y
        TempString(0) = TempString(0) + ","
    Next x
    'XX = SEFNum
    Print #SEFNum, TempString(0)
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

    'work out maximum event and breakpoint density for plots with different P-value cutoffs
    'Call SetUpEvents
    If CPermNo > 0 Then
        
       
        Dim RecMap() As Long, PVCO As Double
        ReDim RecMap(Len(StrainSeq(0)))
        
        TempString(0) = Str(CPermNo)
        TempString(1) = Str(CPermNo)
        
        For A = LowSize To PListSize
            ReDim RecMap(Len(StrainSeq(0)))
            PVCO = 10 ^ (-A)
            For x = 1 To SEventNumber
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 Then
                    CNum = 0
                    For Z = 0 To AddNum - 1
                        If Confirm(SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber), Z) > 0 Then
                            CNum = CNum + 1
                        End If
                    Next Z
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability < PVCO And (CNum > ConsensusProg Or ConsensusProg = 0) Then
                        ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                        EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                        If ST < EN Then
                            For Y = ST To EN
                                RecMap(Y) = RecMap(Y) + 1
                            Next Y
                        Else
                            For Y = ST To Len(StrainSeq(0))
                                RecMap(Y) = RecMap(Y) + 1
                            Next Y
                            For Y = 1 To EN
                                RecMap(Y) = RecMap(Y) + 1
                            Next Y
                        End If
                        C = C + 1
                    End If
                ElseIf XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability = 0 Then
                    b = b + 1
                End If
                
                
            Next x
            PPMax = 0
            For x = 1 To Len(StrainSeq(0))
                If RecMap(x) > PPMax Then PPMax = RecMap(x)
            Next x
            
            TempString(0) = TempString(0) + "," & Str(PPMax)
            Dim RecMapSmooth() As Double, Win As Long
            ReDim RecMap(Len(StrainSeq(0)))
            ReDim RecMapSmooth(Len(StrainSeq(0)))
            
            Win = 100
            b = 0
            C = 0
            For x = 1 To SEventNumber
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).ProgramFlag < AddNum Then
                    CNum = 0
                    For Z = 0 To AddNum - 1
                        If Confirm(SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber), Z) > 0 Then
                            CNum = CNum + 1
                        End If
                    Next Z
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability < PVCO And (CNum > ConsensusProg Or ConsensusProg = 0) Then
                        
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                            ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                            RecMap(ST) = RecMap(ST) + 1
                        End If
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                            EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                            RecMap(EN) = RecMap(EN) + 1
                        End If
                    End If
                
                End If
            
                
            Next x
            PPMax = 0
            For x = 1 To Len(StrainSeq(0))
                If RecMap(x) > PPMax Then PPMax = RecMap(x)
            Next x
            Dim hWin As Long
            hWin = CLng(Win / 2)
            
            If CircularFlag = 0 Then
                ST = CLng(Win / 2)
                EN = Len(StrainSeq(0)) - ST
            Else
                ST = 1
                EN = Len(StrainSeq(0))
            End If
            Tot = 0
            For x = ST To EN
                If x = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                        Else
                            Tot = Tot + RecMap(Z)
                        End If
                        
                    Next Z
                    
                Else
                    Z = x - hWin
                    If Z < 1 Then
                        Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                    Else
                        Tot = Tot - RecMap(Z)
                    End If
                    Z = x + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                    Else
                        Tot = Tot + RecMap(Z)
                    End If
                    
                End If
                RecMapSmooth(x) = Tot / Win
            Next x
            If A = LowSize Then
                For x = 0 To Len(StrainSeq(0))
                    BPListHolder(x, CPermNo) = RecMap(x)
                Next x
            End If
            PPMax = 0
            For x = 0 To Len(StrainSeq(0))
                If RecMapSmooth(x) > PPMax Then PPMax = RecMapSmooth(x)
            Next x
            TempString(1) = TempString(1) + "," & Str(PPMax)
            
        Next A
        Print #EMapNum, TempString(0)
        Print #BPMapNum, TempString(1)
    End If
    
    
    x = x
Next CPermNo
Close #SEFNum
Close #EMapNum
Close #BPMapNum


If PermSeqNumInFile = 1 Then
        
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If PermNextno < NextNo Then
            ReDim SeqNum(Len(StrainSeq(0)), NextNo)
        End If
        
Else
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            SeqNum(Y, x) = PermSeqNum(Y, x)
        Next Y
    Next x
End If
ReDim CurrentXOver(NextNo + 1)
ReDim XoverList(NextNo, XOverListSize), MissingData(Len(StrainSeq(0)), NextNo)
ReDim MaxXOP(AddNum - 1, NextNo)
Call ResetMaxPVCO(NextNo)
SEventNumber = 0

If DebuggingFlag < 2 Then On Error Resume Next
If UBound(SeqCol, 1) < NextNo Or UBound(FFillCol, 1) < NextNo Then
    ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
End If

If UBound(XCord, 3) < NextNo + 2 Or UBound(YCord, 3) < NextNo + 2 Or UBound(RYCord, 3) < NextNo + 2 Then
    ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
End If

On Error GoTo 0

ReDim Preserve OriginalName(NextNo)
Udst = PermUDst
AvDst = PermAvDst

'get permanent copies of treedistance and distance from file

oDir = CurDir
ChDir App.Path
ChDrive App.Path

ReDim Distance(PermNextno, PermNextno)
ReDim TreeDistance(PermNextno, PermNextno)


FF = FreeFile
Open "RDP5PermDistance" + UFTag For Binary As #FF
Get #FF, , Distance()
Close #FF

Open "RDP5PermTreeDistance" + UFTag For Binary As #FF
Get #FF, , TreeDistance()
Close #FF

ReDim PermValid(PermNextno, PermNextno)
ReDim PermDIffs(PermNextno, PermNextno)

Open "RDP5PPermValid" + UFTag For Binary As #FF
Get #FF, , PermValid()
Close #FF

Open "RDP5PPermDiffs" + UFTag For Binary As #FF
Get #FF, , PermDIffs()
Close #FF

ChDir oDir
ChDrive oDir


'UDst = DistanceCalc(NextNo, Len(StrainSeq(0)) + 1, SeqNum(0, 0), Distance(0, 0), AvDst)
                

'Call  UPGMA(Strainame(),TempNHF,SeqNum(),DistanceFlag, NodeLength(), TreeX(), TreeY(),AvDst,0,0)
'Call DrawTree

If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
On Error GoTo 0
Exit Sub

'order the scores
CurrentNo = 0

For Z = 1 To GPerms
    For Y = 0 To AddNum - 1
        TopP = 1
        For x = Z To GPerms
            If TopP > BestPermP(x, Y) Then
                TopP = BestPermP(x, Y)
                WinPos = x
            End If
        Next x
        tTopP = BestPermP(Z, Y)
        BestPermP(Z, Y) = BestPermP(WinPos, Y)
        BestPermP(WinPos, Y) = tTopP
    Next Y
Next Z
APermFlag = 0

TargetProb = Int((LowestProb * GPerms))
TargetProb = Int((0.8 * GPerms))
If TargetProb < 1 Then TargetProb = 1

For x = 0 To AddNum - 1
    CritPVals(x) = BestPermP(TargetProb, x)
    CritPVals(x) = LowestProb
Next x

End Sub

'adds items in xoverlist to pxolist and redims tempxolist to the same size as xosize
Public Sub CopyXOLists(XOSize As Long, DoneSeq() As Byte, TempXOList() As XOverDefine, PXOList() As XOverDefine, PCurrentXover() As Integer, XoverList() As XOverDefine, CurrentXOver() As Integer, NumRecsI() As Long)
Dim Z As Long, x As Long, Y As Long, UB As Long, DA As Long, Ma As Long, Mi As Long, TestSize As Variant, ReduceX As Single, TempMax As Long, PropP As Single, PropC As Single
Dim Dummy As Long, MaxSize As Long, RDFlag As Byte, WorstP As Double, WorstOne As Long, UB1 As Long, UB2 As Long, UB3 As Long, UB4 As Long
'XX = XoverList(93, 12).Probability
GlobalMemoryStatus MemSit
    
APhys = Abs(MemSit.dwTotalPhys)
'APhys = Abs(MemSit.dwAvailVirtual)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000

MaxSize = 0
If NextNo > UBound(PCurrentXover, 1) Then
    ReDim Preserve PCurrentXover(NextNo)
End If
For x = 0 To NextNo
    If PCurrentXover(x) + CurrentXOver(x) > MaxSize Then
        MaxSize = PCurrentXover(x) + CurrentXOver(x)
    End If
Next x
'XX = UBound(CurrentXOver)
x = x
RDFlag = 0
If MaxSize > UBound(PXOList, 2) Then
    XOSize = MaxSize + 10
    UB = UBound(PXOList, 1)
    TestSize = (UB + 1) * (XOSize + 1) * 55
    If TestSize > 40000000 Or XOSize > MaxXOListSize Then
        
        ReduceX = (TestSize - APhys) / 55 'the number of signals that must be removed per sequence
        ReduceX = CLng(ReduceX / NextNo)
        If (XOSize - MaxXOListSize) < ReduceX Then 'choose whichever is the lowest number
            ReduceX = CLng(XOSize - MaxXOListSize)
        End If
        
        TempMax = XOSize - ReduceX
        
        
        
        'need to shed some signals
        
        'Do
        For x = 0 To NextNo
            If PCurrentXover(x) + CurrentXOver(x) > TempMax Then 'this one is over the max
                
                PropP = (PCurrentXover(x)) / (PCurrentXover(x) + CurrentXOver(x))
                PropC = (CurrentXOver(x)) / (PCurrentXover(x) + CurrentXOver(x))
                
                PropP = CLng(PropP * (PCurrentXover(x) + CurrentXOver(x) - TempMax))
                PropC = CLng(PropC * (PCurrentXover(x) + CurrentXOver(x) - TempMax))
                If PropP > 0 Then
                    For Z = 1 To PropP
                        WorstP = 0
                        WorstOne = -1
                        For Y = 1 To PCurrentXover(x)
                            If PXOList(x, Y).Probability > WorstP And PXOList(x, Y).Accept <> 1 Then
                                WorstP = PXOList(x, Y).Probability
                                WorstOne = Y
                            End If
                        Next Y
                        If WorstOne > -1 Then
                            
                            Call AddToRedoList(PXOList(x, WorstOne).ProgramFlag, PXOList(x, WorstOne).Daughter, PXOList(x, WorstOne).MajorP, PXOList(x, WorstOne).MinorP)
                            If WorstOne <> PCurrentXover(x) Then
                                PXOList(x, WorstOne) = PXOList(x, PCurrentXover(x))
                            End If
                            PCurrentXover(x) = PCurrentXover(x) - 1
                        End If
                    Next Z
                End If
                
                If PropC > 0 Then
                    For Z = 1 To PropC
                        WorstP = 0
                        WorstOne = -1
                        For Y = 1 To CurrentXOver(x)
                            If XoverList(x, Y).Probability > WorstP And XoverList(x, Y).Accept <> 1 Then
                                WorstP = XoverList(x, Y).Probability
                                WorstOne = Y
                            End If
                        Next Y
                        If WorstOne > -1 Then
                            Call AddToRedoList(XoverList(x, WorstOne).ProgramFlag, XoverList(x, WorstOne).Daughter, XoverList(x, WorstOne).MajorP, XoverList(x, WorstOne).MinorP)
                            If WorstOne <> CurrentXOver(x) Then
                                XoverList(x, WorstOne) = XoverList(x, CurrentXOver(x))
                            End If
                            CurrentXOver(x) = CurrentXOver(x) - 1
                        End If
                    Next Z
                End If
                
                
            End If
        Next x
        'Loop
        
        
        MaxSize = 0
        For x = 0 To NextNo
            If PCurrentXover(x) + CurrentXOver(x) > MaxSize Then
                MaxSize = PCurrentXover(x) + CurrentXOver(x)
            End If
        Next x
        XOSize = MaxSize + 10
    End If
    
    
    If DebuggingFlag < 2 Then On Error Resume Next
    'XOSize = 1087
    '$'$
    ReDim Preserve PXOList(UB, XOSize)
    XOSize = UBound(PXOList, 2)
    On Error GoTo 0
    
    UB = UBound(DoneSeq, 1)
    
    ReDim Preserve DoneSeq(UB, XOSize)
    RDFlag = 1
End If

If x = x Then
'    XX = XoverList(93, 12).Probability
'    XX = PXOList(93, 12).Probability
'    XX = UBound(PXOList, 1)

'    If NextNo > UBound(PXOList, 1) Or NextNo > UBound(XoverList, 1) Then
'
'        x = x
'    End If
        If UBound(PXOList, 2) < UBound(XoverList, 2) Then
            ReDim Preserve PXOList(UBound(PXOList, 1), UBound(XoverList, 2))
        End If
'        If UBound(PXOList, 2) > UBound(XoverList, 2) Then
'            ReDim Preserve XoverList(UBound(XoverList, 1), UBound(PXOList, 2))
'        End If
    'End If
    UB1 = UBound(PXOList, 1)
    UB3 = UBound(PXOList, 2)
    UB2 = UBound(XoverList, 1)
    UB4 = UBound(XoverList, 2)
    Dummy = CopyXOListsX(UB1, UB3, UB2, UB4, NextNo, CurrentXOver(0), PCurrentXover(0), PXOList(0, 0), XoverList(0, 0), NumRecsI(0))
    For x = 0 To NextNo
        If PCurrentXover(x) > 0 Then
            x = x
        End If
    Next x
    x = x
Else

    For x = 0 To NextNo
        If CurrentXOver(x) > 0 Then
            
            For Y = 1 To CurrentXOver(x)
                PCurrentXover(x) = PCurrentXover(x) + 1
                
                PXOList(x, PCurrentXover(x)) = XoverList(x, Y)
                
                DA = PXOList(x, PCurrentXover(x)).Daughter
                Ma = PXOList(x, PCurrentXover(x)).MajorP
                Mi = PXOList(x, PCurrentXover(x)).MinorP
                If DA <= NextNo Then
                    NumRecsI(DA) = NumRecsI(DA) + 1
                End If
                If Ma <= NextNo Then
                    NumRecsI(Ma) = NumRecsI(Ma) + 1
                End If
                If Mi <= NextNo Then
                    NumRecsI(Mi) = NumRecsI(Mi) + 1
                End If
                'XX = NextNo
            Next Y
        End If
    Next x
End If
If RDFlag = 1 Then
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = UBound(TempXOList, 1)
    '@'$'$
    ReDim Preserve TempXOList(UB, XOSize)
    On Error GoTo 0
End If

End Sub
Public Sub MakeConsensusB(RCompatC() As Long, RCompatD() As Long, RCompat2() As Long, RCompat3() As Long, RCompat4() As Long, RCompatS() As Long, RCompatS2() As Long, RCompatS3() As Long, RCompatS4() As Long, SSDist() As Double, OUIndexA() As Byte, DScores() As Double, Consensus() As Double, INList() As Byte, CompMat() As Long, SubScore2() As Double, SubPhPrScore2() As Double, ListCorr3() As Single, SubScore() As Double, PhPrScore2() As Double, ListCorr() As Single, ListCorr2() As Single, TrpScore() As Double, PhPrScore() As Double, SubPhPrScore() As Double, OuCheck() As Long, BadDists() As Single, RCompat() As Long, tListCorr() As Single)
For x = 0 To 2
    TrpScore(x) = CLng(TrpScore(x) * 10000) / 10000
    'SimScoreB(X) = CLng(SimScoreB(X) * 100000) / 100000
    PhPrScore(x) = CLng(PhPrScore(x) * 100000) / 100000
    PhPrScore2(x) = CLng(PhPrScore2(x) * 100000) / 100000
    'PhPrScore3(X) = CLng(PhPrScore3(X) * 100000) / 100000
    SSDist(x) = CLng(SSDist(x) * 100000) / 100000
    SubPhPrScore(x) = CLng(SubPhPrScore(x) * 100000) / 100000
    SubScore(x) = CLng(SubScore(x) * 100000) / 100000
    SubPhPrScore2(x) = CLng(SubPhPrScore2(x) * 100000) / 100000
    SubScore2(x) = CLng(SubScore2(x) * 100000) / 100000
    ListCorr(x) = CLng(ListCorr(x) * 100000) / 100000
    ListCorr2(x) = CLng(ListCorr2(x) * 100000) / 100000
    ListCorr3(x) = CLng(ListCorr3(x) * 100000) / 100000
Next x

Dim C As Long


    For C = 0 To 2
        If OUIndexA(C) = 1 Then
            Consensus(C, 2) = Consensus(C, 2) + 5
            DScores(1 + 15, C) = 5
        End If
            If SSDist(C) <= SSDist(CompMat(C, 0)) And SSDist(C) <= SSDist(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 14, C) = 5
            ElseIf SSDist(C) < SSDist(CompMat(C, 0)) Or SSDist(C) < SSDist(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 14, C) = 5
            End If
            If OuCheck(INList(C)) > 0 Then
                Consensus(INList(C), 0) = Consensus(INList(C), 0) + 1
                Consensus(INList(C), 1) = Consensus(INList(C), 1) + 1
                Consensus(INList(C), 2) = Consensus(INList(C), 2) + 5
                DScores(1 + 4, C) = 10
            ElseIf OuCheck(INList(C)) < 0 Then
                Consensus(INList(C), 0) = Consensus(INList(C), 0) - 1
                Consensus(INList(C), 1) = Consensus(INList(C), 1) - 1
                Consensus(INList(C), 2) = Consensus(INList(C), 2) - 5
                DScores(1 + 4, C) = 0
            Else
                DScores(1 + 4, C) = 5
            End If
            
            
            'If X = 12345 Then
                If BadDists(C) <= BadDists(CompMat(C, 0)) And BadDists(C) <= BadDists(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 1, C) = 10
                ElseIf BadDists(C) < BadDists(CompMat(C, 0)) Or BadDists(C) < BadDists(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 1, C) = 5
                End If
            
            If RCompat(0) <> RCompat(1) Or RCompat(0) <> RCompat(2) Then
                If RCompat(C) <= RCompat(CompMat(C, 0)) And RCompat(C) <= RCompat(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompat(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                    End If
                ElseIf RCompat(C) < RCompat(CompMat(C, 0)) Or RCompat(C) < RCompat(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 0, C) = 5
                End If
            ElseIf RCompat2(0) <> RCompat2(1) Or RCompat2(0) <> RCompat2(2) Then
                If RCompat2(C) <= RCompat2(CompMat(C, 0)) And RCompat2(C) <= RCompat2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompat2(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                    End If
                ElseIf RCompat2(C) < RCompat2(CompMat(C, 0)) Or RCompat2(C) < RCompat2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 0, C) = 5
                End If
            ElseIf RCompat3(0) <> RCompat3(1) Or RCompat3(0) <> RCompat3(2) Then
                If RCompat3(C) <= RCompat3(CompMat(C, 0)) And RCompat3(C) <= RCompat3(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompat3(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                    End If
                ElseIf RCompat3(C) < RCompat3(CompMat(C, 0)) Or RCompat3(C) < RCompat3(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 0, C) = 5
                End If
            ElseIf RCompat4(0) <> RCompat4(1) Or RCompat4(0) <> RCompat4(2) Then
                If RCompat4(C) <= RCompat4(CompMat(C, 0)) And RCompat4(C) <= RCompat4(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompat4(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                    End If
                ElseIf RCompat4(C) < RCompat4(CompMat(C, 0)) Or RCompat4(C) < RCompat4(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 0, C) = 5
                End If
            End If
            If RCompatS(0) <> RCompatS(1) Or RCompatS(0) <> RCompatS(2) Then
                If RCompatS(C) <= RCompatS(CompMat(C, 0)) And RCompatS(C) <= RCompatS(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompatS(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                    End If
                ElseIf RCompatS(C) < RCompatS(CompMat(C, 0)) Or RCompatS(C) < RCompatS(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 13, C) = 5
                End If
            ElseIf RCompatS2(0) <> RCompatS2(1) Or RCompatS2(0) <> RCompatS2(2) Then
                If RCompatS2(C) <= RCompatS2(CompMat(C, 0)) And RCompatS2(C) <= RCompatS2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompatS2(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                    End If
                ElseIf RCompatS2(C) < RCompatS2(CompMat(C, 0)) Or RCompatS2(C) < RCompatS2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 13, C) = 5
                End If
            ElseIf RCompatS3(0) <> RCompatS3(1) Or RCompatS3(0) <> RCompatS3(2) Then
                If RCompatS3(C) <= RCompatS3(CompMat(C, 0)) And RCompatS3(C) <= RCompatS3(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompatS3(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                    End If
                ElseIf RCompatS3(C) < RCompatS3(CompMat(C, 0)) Or RCompatS3(C) < RCompatS3(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 13, C) = 5
                End If
            ElseIf RCompatS4(0) <> RCompatS4(1) Or RCompatS4(0) <> RCompatS4(2) Then
                If RCompatS4(C) <= RCompatS4(CompMat(C, 0)) And RCompatS4(C) <= RCompatS4(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    If RCompatS4(C) = 0 Then
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    Else
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                    End If
                ElseIf RCompatS4(C) < RCompatS4(CompMat(C, 0)) Or RCompatS4(C) < RCompatS4(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 13, C) = 5
                End If
            End If
            'If X = 12345 Then
            '    If tListCorr(C, 0) >= tListCorr(CompMat(C, 0), 0) And tListCorr(C, 0) >= tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 0) > tListCorr(CompMat(C, 0), 0) Or tListCorr(C, 0) > tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 1) >= tListCorr(CompMat(C, 0), 1) And tListCorr(C, 1) >= tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 1) > tListCorr(CompMat(C, 0), 1) Or tListCorr(C, 1) > tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 2) >= tListCorr(CompMat(C, 0), 2) And tListCorr(C, 2) >= tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 3
            '    ElseIf tListCorr(C, 2) > tListCorr(CompMat(C, 0), 2) Or tListCorr(C, 2) > tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1.5
            '    End If
            'End If
            'If X = 12345 Then
                If TrpScore(C) >= TrpScore(CompMat(C, 0)) And TrpScore(C) >= TrpScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 8, C) = 8
                ElseIf TrpScore(C) > TrpScore(CompMat(C, 0)) Or TrpScore(C) > TrpScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 8, C) = 4
                End If
            'End If
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 0)) And SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 2, C) = 10
                ElseIf SubPhPrScore(C) > SubPhPrScore(CompMat(C, 0)) Or SubPhPrScore(C) > SubPhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 2, C) = 5
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 0)) And SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 5, C) = 8
                ElseIf SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 0)) Or SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 5, C) = 4
                End If
            End If
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If SubScore(C) >= SubScore(CompMat(C, 0)) And SubScore(C) >= SubScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 2
                    DScores(1 + 12, C) = 2
                ElseIf SubScore(C) > SubScore(CompMat(C, 0)) Or SubScore(C) > SubScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 1
                    DScores(1 + 12, C) = 1
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If SubScore2(C) >= SubScore2(CompMat(C, 0)) And SubScore2(C) >= SubScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 3, C) = 10
                ElseIf SubScore2(C) > SubScore2(CompMat(C, 0)) Or SubScore2(C) > SubScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 3, C) = 5
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If PhPrScore2(C) <= PhPrScore2(CompMat(C, 0)) And PhPrScore2(C) <= PhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 18
                    DScores(1 + 6, C) = 18
                ElseIf PhPrScore2(C) < PhPrScore2(CompMat(C, 0)) Or PhPrScore2(C) < PhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 14
                    DScores(1 + 6, C) = 14
                End If
            End If
            If ListCorr(C) <= ListCorr(CompMat(C, 0)) And ListCorr(C) <= ListCorr(CompMat(C, 1)) Then
                Consensus(C, 0) = Consensus(C, 0) + 1
                Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 4
                DScores(1 + 11, C) = 4
            ElseIf ListCorr(C) < ListCorr(CompMat(C, 0)) Or ListCorr(C) < ListCorr(CompMat(C, 1)) Then
                Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 2
                DScores(1 + 11, C) = 2
            End If
            'If X = 1234 Then
                If ListCorr2(C) >= ListCorr2(CompMat(C, 0)) And ListCorr2(C) >= ListCorr2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 20
                    DScores(1 + 16, C) = 20
                ElseIf ListCorr2(C) > ListCorr2(CompMat(C, 0)) Or ListCorr2(C) > ListCorr2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 20
                    DScores(1 + 16, C) = 15
                End If
           '
           '     If ListCorr3(C) <= ListCorr3(CompMat(C, 0)) And ListCorr3(C) <= ListCorr3(CompMat(C, 1)) Then
           '         Consensus(C, 0) = Consensus(C, 0) + 1
           '         Consensus(C, 1) = Consensus(C, 1) + 1
           '         Consensus(C, 2) = Consensus(C, 2) + 1
           '     ElseIf ListCorr3(C) < ListCorr3(CompMat(C, 0)) Or ListCorr3(C) < ListCorr3(CompMat(C, 1)) Then
           '         Consensus(C, 1) = Consensus(C, 1) + 1
           '         Consensus(C, 2) = Consensus(C, 2) + 0.5
           '     End If
           ' End If
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If PhPrScore(C) <= PhPrScore(CompMat(C, 0)) And PhPrScore(C) <= PhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 7, C) = 8
                ElseIf PhPrScore(C) < PhPrScore(CompMat(C, 0)) Or PhPrScore(C) < PhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 7, C) = 4
                End If
            End If
            
        Next C
        Dim Tot As Double
        
        Tot = 0
        
           ' For X = 0 To 2
           '     If RCompatC(X) < RCompatD(X) Then
           '         Consensus(X, 2) = Consensus(X, 2) - RCompatC(X) * 10
           '     Else
           '         Consensus(X, 2) = Consensus(X, 2) - RCompatD(X) * 10
           '     End If
           ' Next X
            Tot = 0
            For x = 0 To 2
                If Consensus(x, 2) < Tot Then
                    Tot = Consensus(x, 2)
                End If
            Next x
            For x = 0 To 2
                Consensus(x, 2) = Consensus(x, 2) - Tot
            Next x
        
        Tot = 0
        For x = 0 To 2
            If Tot < Consensus(x, 2) Then Tot = Consensus(x, 2)
        Next x
        For x = 0 To 2
            DScores(0, x) = (Consensus(x, 2) / Tot) * 30
        Next x
        
End Sub
Public Sub MakeConsensusC(SetTot() As Long, OUList() As Byte, RankF() As Long, dMax() As Single, SimScore() As Byte, SimScoreB() As Double, PhPrScore3() As Double, RCompatC() As Long, RCompatD() As Long, RCompat2() As Long, RCompat3() As Long, RCompat4() As Long, RCompatS() As Long, RCompatS2() As Long, RCompatS3() As Long, RCompatS4() As Long, SSDist() As Double, OUIndexA() As Byte, DScores() As Double, Consensus() As Double, INList() As Byte, CompMat() As Long, SubScore2() As Double, SubPhPrScore2() As Double, ListCorr3() As Single, SubScore() As Double, PhPrScore2() As Double, ListCorr() As Single, ListCorr2() As Single, TrpScore() As Double, PhPrScore() As Double, SubPhPrScore() As Double, OuCheck() As Long, BadDists() As Single, RCompat() As Long, tListCorr() As Single)

Dim x As Long, PS1 As Byte, PS2 As Byte, PS3 As Byte
Dim A As Long, C As Long, SDNum As Long

'do the logistic regression model recombinant identification stuff
ReDim StatsList(50, 2)
For C = 0 To 2
    'SDNum = C
    
    StatsList(0, C) = ListCorr(C)
    StatsList(1, C) = SimScoreB(C)
    StatsList(2, C) = SimScore(C)
    StatsList(3, C) = PhPrScore(C)
    StatsList(4, C) = PhPrScore2(C)
    StatsList(5, C) = PhPrScore3(C)
    StatsList(6, C) = SubScore(C)
    StatsList(7, C) = SSDist(C)
    StatsList(8, C) = OUIndexA(C)
    StatsList(9, C) = SubPhPrScore(C)
    StatsList(10, C) = SubScore2(C)
    StatsList(11, C) = SubPhPrScore2(C)
    'Statslist( 12, c) = SRCompatF(C)
    'Statslist( 13, c) = SRCompatS(C)
    StatsList(14, C) = RCompat(C)
    StatsList(15, C) = RCompat2(C)
    StatsList(16, C) = RCompat3(C)
    StatsList(17, C) = RCompat4(C)
    StatsList(18, C) = RCompatS(C)
    StatsList(19, C) = RCompatS2(C)
    StatsList(20, C) = RCompatS3(C)
    StatsList(21, C) = RCompatS4(C)
    'Statslist( 22, c) = RCompatXF(C)
    'Statslist( 23, c) = RCompatXS(C)
    StatsList(24, C) = RCompatC(C)
    StatsList(25, C) = RCompatD(C)
    StatsList(26, C) = TrpScore(C)
    StatsList(27, C) = BadDists(C)
    StatsList(28, C) = OUList(C)
    StatsList(29, C) = ListCorr2(C)
    StatsList(30, C) = ListCorr3(C)
'    StatsList(31, C) = Consensus(C, 0)
'    StatsList(32, C) = Consensus(C, 1)
'    StatsList(33, C) = Consensus(C, 2)
    StatsList(34, C) = OuCheck(C)
    StatsList(35, C) = SetTot(0, C)
    'StatsList(36, C) = SetTot(1, C)     ', PhPrScore3(C), SubScore3(C), SubPhPrScore3(C),   TrpScore2(C), RCompat2(C) ', SubScore2(C), SubPhPrScore2(C), ListCorr4(C), tListCorr2(C, 0), tListCorr2(C, 1), tListCorr2(C, 2), ListCorr5(C), ListCorr6(C)
    StatsList(37, C) = RankF(C, 0)
    StatsList(38, C) = RankF(C, 1)
    StatsList(39, C) = dMax(C)  '1.01,0.488 (19), 0.435(16)
Next C
Dim StdScaledX() As Double, DotProd As Double, ZS As Double
ReDim StdScaledX(50, 2)
For C = 0 To 2
    DotProd = 0
    For x = 0 To 39
        If LogisticRWeights(x) <> 0 Then
            StdScaledX(x, C) = (StatsList(x, C) - LogisticRMean(x)) / LogisticRSD(x)
            DotProd = DotProd + StdScaledX(x, C) * LogisticRWeights(x)
        End If
        
    Next x
    ZS = DotProd - 1.1543829
    SigmoidX(C) = 1 / (1 + Exp(-ZS)) '2,2,2,1,1,0
    'XX = StraiName(ISeqs(C))
Next C

'do the old consensus
If DebuggingFlag < 2 Then On Error Resume Next
For x = 0 To 2
    TrpScore(x) = TrpScore(x) * 1000000
    TrpScore(x) = CLng(TrpScore(x))
    TrpScore(x) = TrpScore(x) / 1000000
    
    
    SimScoreB(x) = SimScoreB(x) * 100000
    SimScoreB(x) = CLng(SimScoreB(x))
    SimScoreB(x) = SimScoreB(x) / 100000
    
    
    PhPrScore(x) = PhPrScore(x) * 100000
    PhPrScore(x) = CLng(PhPrScore(x))
    PhPrScore(x) = PhPrScore(x) / 100000
    
    
    PhPrScore2(x) = PhPrScore2(x) * 100000
    PhPrScore2(x) = CLng(PhPrScore2(x))
    PhPrScore2(x) = PhPrScore2(x) / 100000
    
        
    PhPrScore3(x) = PhPrScore3(x) * 100000
    PhPrScore3(x) = CLng(PhPrScore3(x))
    PhPrScore3(x) = PhPrScore3(x) / 100000
    
    If SSDist(x) < 10000 Then
        SSDist(x) = CLng(SSDist(x) * 100000) / 100000
    End If
    SubPhPrScore(x) = CLng(SubPhPrScore(x) * 10000) / 10000
    If Abs(SubScore(x)) < 100 Then
        SubScore(x) = CLng(SubScore(x) * 1000000) / 1000000
    End If
    SubPhPrScore2(x) = CLng(SubPhPrScore2(x) * 100000) / 100000
    If SubScore2(x) > 100000 Then
        SubScore2(x) = 100000
    End If
    SubScore2(x) = CLng(SubScore2(x) * 100000) / 100000
    ListCorr(x) = CLng(ListCorr(x) * 100000) / 100000
    If ListCorr2(x) > 0 Then
        ListCorr2(x) = CLng(ListCorr2(x) * 100000) / 100000
    End If
    If ListCorr3(x) > 0 Then
        ListCorr3(x) = CLng(ListCorr3(x) * 100000) / 100000
    End If

Next x

On Error GoTo 0
PS1 = 3: PS2 = 3: PS3 = 3
For x = 0 To 2
    If Abs(PhPrScore(x)) < 0.999999 Then
        PS1 = PS1 + 1
    End If
    If Abs(PhPrScore2(x)) < 0.999999 Then
        PS2 = PS2 + 1
    End If
    If Abs(PhPrScore3(x)) < 0.999999 Then
        PS3 = PS3 + 1
    End If
Next x
For x = 0 To 2
    If Abs(PhPrScore(x)) = 1 Then
        PS1 = 0
    End If
    If Abs(PhPrScore2(x)) = 1 Then
        PS2 = 0
    End If
    If Abs(PhPrScore3(x)) = 1 Then
        PS3 = 0
    End If
Next x


'If SEventNumber = 81 Then
'    X = X
'End If

'Abs(PhPrScore(0)) < 0.999999 or Abs(PhPrScore(1)) < 0.999999 or Abs(PhPrScore(2)) < 0.999999 Then
    ReDim DScores(25, 2)
    For C = 0 To 2
        
        If (dMax(CompMat(C, 0)) + dMax(C) + dMax(CompMat(C, 1))) > 0 Then
        
            DScores(10, C) = (dMax(C) / (dMax(CompMat(C, 0)) + dMax(C) + dMax(CompMat(C, 1)))) * 20
        
        Else
            DScores(10, C) = 0
        End If
'        If SEventNumber = 26 Then
'            X = X
'        End If
        Consensus(C, 2) = DScores(10, C)
        If dMax(C) >= dMax(CompMat(C, 0)) * 1.1 And dMax(C) >= dMax(CompMat(C, 1)) * 1.1 Then
            'DScores(10, C) = DScores(10, C) + 10
            Consensus(C, 2) = Consensus(C, 2) + 30
        ElseIf dMax(C) >= dMax(CompMat(C, 0)) And dMax(C) >= dMax(CompMat(C, 1)) Then
        
            Consensus(C, 2) = Consensus(C, 2) + 20
        ElseIf dMax(C) >= dMax(CompMat(C, 0)) * 1.1 Then
            Consensus(C, 2) = Consensus(C, 2) + 10
        ElseIf dMax(C) >= dMax(CompMat(C, 1)) * 1.1 Then
            Consensus(C, 2) = Consensus(C, 2) + 10
        ElseIf dMax(C) >= dMax(CompMat(C, 0)) Then
            Consensus(C, 2) = Consensus(C, 2) + 5
        ElseIf dMax(C) >= dMax(CompMat(C, 1)) Then
            Consensus(C, 2) = Consensus(C, 2) + 5
        End If
        'If dMax(C) > dMax(CompMat(C, 0)) And dMax(C) >= dMax(CompMat(C, 1)) Then
        '    DScores(10, C) = 4
        'ElseIf dMax(C) > dMax(CompMat(C, 0)) Or dMax(C) >= dMax(CompMat(C, 1)) Then
        '    DScores(10, C) = 2
        'End If
        If OUIndexA(C) = 1 Then
            Consensus(C, 2) = Consensus(C, 2) + 5
            DScores(1 + 15, C) = 5
        End If
            If SSDist(C) <> SSDist(CompMat(C, 0)) And SSDist(C) <> SSDist(CompMat(C, 1)) Then
            
            
                If SSDist(C) >= SSDist(CompMat(C, 0)) And SSDist(C) >= SSDist(CompMat(C, 1)) Then
                       ' Consensus(C, 0) = Consensus(C, 0) + 1
                       ' Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 5
                        DScores(1 + 14, C) = 5
                ElseIf SSDist(C) > SSDist(CompMat(C, 0)) Or SSDist(C) > SSDist(CompMat(C, 1)) Then
                       ' Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 2.5
                        DScores(1 + 14, C) = 2.5
                End If
            End If
            If OuCheck(C) > 0 Then
               ' Consensus(C, 0) = Consensus(C, 0) + 1
               ' Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 5
                DScores(1 + 4, C) = 10
            ElseIf OuCheck(C) < 0 Then
               ' Consensus(C, 0) = Consensus(C, 0) - 1
               ' Consensus(C, 1) = Consensus(C, 1) - 1
                Consensus(C, 2) = Consensus(C, 2) - 5
                DScores(1 + 4, C) = 0
            Else
                DScores(1 + 4, C) = 5
            End If
                
            'If X = 12345 Then
            If DontRedoQuickDistFlag = 0 Or x = x Then
                If BadDists(C) = BadDists(CompMat(C, 0)) And BadDists(C) = BadDists(CompMat(C, 1)) Then
                '    Consensus(C, 0) = Consensus(C, 0) + 1
                '    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 1
                    DScores(1 + 1, C) = 1
                Else
                    If BadDists(C) <= BadDists(CompMat(C, 0)) And BadDists(C) <= BadDists(CompMat(C, 1)) Then
                 '       Consensus(C, 0) = Consensus(C, 0) + 1
                  '      Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 1, C) = 10
                    ElseIf BadDists(C) < BadDists(CompMat(C, 0)) Or BadDists(C) < BadDists(CompMat(C, 1)) Then
                   '     Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 5
                        DScores(1 + 1, C) = 5
                    
                    End If
                End If
            End If
            If DontRedoQuickDistFlag = 0 Or x = x Then
                If RCompat(0) <> RCompat(1) Or RCompat(0) <> RCompat(2) Then 'first prize only bother if there is some info here
                    
                    If RCompat(C) <= RCompat(CompMat(C, 0)) And RCompat(C) <= RCompat(CompMat(C, 1)) Then
                        
                    '    Consensus(C, 0) = Consensus(C, 0) + 1
                    '    Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                        
                    ElseIf RCompat(C) < RCompat(CompMat(C, 0)) Or RCompat(C) < RCompat(CompMat(C, 1)) Then
                        
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                        
                     '   Consensus(C, 1) = Consensus(C, 1) + 1
                        
                    End If
                   
                ElseIf RCompat2(0) <> RCompat2(1) Or RCompat2(0) <> RCompat2(2) Then 'second prize - check if there is some info here
                    If RCompat2(C) <= RCompat2(CompMat(C, 0)) And RCompat2(C) <= RCompat2(CompMat(C, 1)) Then
                      '  Consensus(C, 0) = Consensus(C, 0) + 1
                      '  Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                        
                    ElseIf RCompat2(C) < RCompat2(CompMat(C, 0)) Or RCompat2(C) < RCompat2(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                      '  Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                ElseIf RCompat3(0) <> RCompat3(1) Or RCompat3(0) <> RCompat3(2) Then 'third prize check if there is info here
                    If RCompat3(C) <= RCompat3(CompMat(C, 0)) And RCompat3(C) <= RCompat3(CompMat(C, 1)) Then
                      '  Consensus(C, 0) = Consensus(C, 0) + 1
                      '  Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20

                    ElseIf RCompat3(C) < RCompat3(CompMat(C, 0)) Or RCompat3(C) < RCompat3(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                        
                       ' Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                ElseIf RCompat4(0) <> RCompat4(1) Or RCompat4(0) <> RCompat4(2) Then '4th prize
                    If RCompat4(C) <= RCompat4(CompMat(C, 0)) And RCompat4(C) <= RCompat4(CompMat(C, 1)) Then
                       ' Consensus(C, 0) = Consensus(C, 0) + 1
                       ' Consensus(C, 1) = Consensus(C, 1) + 1
                        
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 0, C) = 20
                        
                    ElseIf RCompat4(C) < RCompat4(CompMat(C, 0)) Or RCompat4(C) < RCompat4(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 0, C) = 10
                        
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                End If
                If RCompatS(0) <> RCompatS(1) Or RCompatS(0) <> RCompatS(2) Then 'first prize for inner parsiomony
                    If RCompatS(C) <= RCompatS(CompMat(C, 0)) And RCompatS(C) <= RCompatS(CompMat(C, 1)) Then
                        'Consensus(C, 0) = Consensus(C, 0) + 1
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                        
                    ElseIf RCompatS(C) < RCompatS(CompMat(C, 0)) Or RCompatS(C) < RCompatS(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                ElseIf RCompatS2(0) <> RCompatS2(1) Or RCompatS2(0) <> RCompatS2(2) Then
                    If RCompatS2(C) <= RCompatS2(CompMat(C, 0)) And RCompatS2(C) <= RCompatS2(CompMat(C, 1)) Then
                        'Consensus(C, 0) = Consensus(C, 0) + 1
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    ElseIf RCompatS2(C) < RCompatS2(CompMat(C, 0)) Or RCompatS2(C) < RCompatS2(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                ElseIf RCompatS3(0) <> RCompatS3(1) Or RCompatS3(0) <> RCompatS3(2) Then
                    If RCompatS3(C) <= RCompatS3(CompMat(C, 0)) And RCompatS3(C) <= RCompatS3(CompMat(C, 1)) Then
                        'Consensus(C, 0) = Consensus(C, 0) + 1
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                    ElseIf RCompatS3(C) < RCompatS3(CompMat(C, 0)) Or RCompatS3(C) < RCompatS3(CompMat(C, 1)) Then
                        
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                       
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                ElseIf RCompatS4(0) <> RCompatS4(1) Or RCompatS4(0) <> RCompatS4(2) Then
                    If RCompatS4(C) <= RCompatS4(CompMat(C, 0)) And RCompatS4(C) <= RCompatS4(CompMat(C, 1)) Then
                        'Consensus(C, 0) = Consensus(C, 0) + 1
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 20
                        DScores(1 + 13, C) = 20
                        
                    ElseIf RCompatS4(C) < RCompatS4(CompMat(C, 0)) Or RCompatS4(C) < RCompatS4(CompMat(C, 1)) Then
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 13, C) = 10
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                    End If
                End If
            End If
            'If X = 12345 Then
            '    If tListCorr(C, 0) >= tListCorr(CompMat(C, 0), 0) And tListCorr(C, 0) >= tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 0) > tListCorr(CompMat(C, 0), 0) Or tListCorr(C, 0) > tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 1) >= tListCorr(CompMat(C, 0), 1) And tListCorr(C, 1) >= tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 1) > tListCorr(CompMat(C, 0), 1) Or tListCorr(C, 1) > tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 2) >= tListCorr(CompMat(C, 0), 2) And tListCorr(C, 2) >= tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 3
            '    ElseIf tListCorr(C, 2) > tListCorr(CompMat(C, 0), 2) Or tListCorr(C, 2) > tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1.5
            '    End If
            'End If
            'If X = 12345 Then
            If PermNextno > 10 Then
                If TrpScore(C) >= TrpScore(CompMat(C, 0)) And TrpScore(C) >= TrpScore(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 8, C) = 8
                ElseIf TrpScore(C) > TrpScore(CompMat(C, 0)) Or TrpScore(C) > TrpScore(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 8, C) = 4
                End If
            End If
            If PS1 >= 2 Then
                
                If (SubPhPrScore(0) <> -1 And SubPhPrScore(0) <> 1) Or (SubPhPrScore(1) <> -1 And SubPhPrScore(1) <> 1) Or (SubPhPrScore(2) <> -1 And SubPhPrScore(2) <> 1) Then
                    If SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 0)) And SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 1)) Then
                        'Consensus(C, 0) = Consensus(C, 0) + 1
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 10
                        DScores(1 + 2, C) = 10
                    ElseIf SubPhPrScore(C) > SubPhPrScore(CompMat(C, 0)) Or SubPhPrScore(C) > SubPhPrScore(CompMat(C, 1)) Then
                        'Consensus(C, 1) = Consensus(C, 1) + 1
                        Consensus(C, 2) = Consensus(C, 2) + 5
                        DScores(1 + 2, C) = 5
                    End If
                End If
                If SubScore(C) >= SubScore(CompMat(C, 0)) And SubScore(C) >= SubScore(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 2
                    DScores(1 + 12, C) = 2
                ElseIf SubScore(C) > SubScore(CompMat(C, 0)) Or SubScore(C) > SubScore(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 1
                    DScores(1 + 12, C) = 1
                End If
                If PhPrScore(C) <= PhPrScore(CompMat(C, 0)) And PhPrScore(C) <= PhPrScore(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 7, C) = 8
                ElseIf PhPrScore(C) < PhPrScore(CompMat(C, 0)) Or PhPrScore(C) < PhPrScore(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 7, C) = 4
                End If

            End If
            If PS2 >= 2 Then
                If SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 0)) And SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 5, C) = 8
                ElseIf SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 0)) Or SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 5, C) = 4
                End If
                If SubScore2(C) >= SubScore2(CompMat(C, 0)) And SubScore2(C) >= SubScore2(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 3, C) = 10
                ElseIf SubScore2(C) > SubScore2(CompMat(C, 0)) Or SubScore2(C) > SubScore2(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 3, C) = 5
                End If
                If PhPrScore2(C) <= PhPrScore2(CompMat(C, 0)) And PhPrScore2(C) <= PhPrScore2(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 18
                    DScores(1 + 6, C) = 18
                ElseIf PhPrScore2(C) < PhPrScore2(CompMat(C, 0)) Or PhPrScore2(C) < PhPrScore2(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 14
                    DScores(1 + 6, C) = 14
                End If
            End If
            If ListCorr(C) <= ListCorr(CompMat(C, 0)) And ListCorr(C) <= ListCorr(CompMat(C, 1)) Then
                'Consensus(C, 0) = Consensus(C, 0) + 1
                'Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 4
                DScores(1 + 11, C) = 4
            ElseIf ListCorr(C) < ListCorr(CompMat(C, 0)) Or ListCorr(C) < ListCorr(CompMat(C, 1)) Then
                'Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 2
                DScores(1 + 11, C) = 2
            End If
            If ListCorr2(C) > 0 And NextNo > 10 Then
                If ListCorr2(C) >= ListCorr2(CompMat(C, 0)) And ListCorr2(C) >= ListCorr2(CompMat(C, 1)) Then
                    'Consensus(C, 0) = Consensus(C, 0) + 1
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 20
                    DScores(1 + 16, C) = 20
                ElseIf ListCorr2(C) > ListCorr2(CompMat(C, 0)) Or ListCorr2(C) > ListCorr2(CompMat(C, 1)) Then
                    'Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 15
                    DScores(1 + 16, C) = 15
                End If
           '
           '     If ListCorr3(C) <= ListCorr3(CompMat(C, 0)) And ListCorr3(C) <= ListCorr3(CompMat(C, 1)) Then
           '         Consensus(C, 0) = Consensus(C, 0) + 1
           '         Consensus(C, 1) = Consensus(C, 1) + 1
           '         Consensus(C, 2) = Consensus(C, 2) + 1
           '     ElseIf ListCorr3(C) < ListCorr3(CompMat(C, 0)) Or ListCorr3(C) < ListCorr3(CompMat(C, 1)) Then
           '         Consensus(C, 1) = Consensus(C, 1) + 1
           '         Consensus(C, 2) = Consensus(C, 2) + 0.5
           '     End If
            Else
                DScores(1 + 16, C) = 0
            End If
            
           Dim SMaxS As Double, MaxS As Double, MidS As Double, MinS As Double, LowS As Double
                SMaxS = 20
                MaxS = SMaxS / 2
                MidS = MaxS / 2
                MinS = MidS / 2
                LowS = MinS / 2
            
            
            
                If PS1 >= 2 Then
                    If SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 0)) And SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 1)) Then
                        If PS3 >= 2 Then
                            If PhPrScore3(C) <= PhPrScore3(CompMat(C, 0)) And PhPrScore3(C) <= PhPrScore3(CompMat(C, 1)) Then
                                Consensus(C, 2) = Consensus(C, 2) + SMaxS
                                DScores(21, C) = SMaxS / 2
                            End If
                        End If
                    End If
                    If DontRedoQuickDistFlag = 0 Or x = x Then
                        If PhPrScore(C) <= PhPrScore(CompMat(C, 0)) And PhPrScore(C) <= PhPrScore(CompMat(C, 1)) Then
                            If RCompat(C) <> RCompat(CompMat(C, 0)) Or RCompat(C) <> RCompat(CompMat(C, 1)) Then
                                If RCompat(C) <= RCompat(CompMat(C, 0)) And RCompat(C) <= RCompat(CompMat(C, 1)) Then
                                    Consensus(C, 2) = Consensus(C, 2) + MaxS
                                    DScores(19, C) = MaxS / 2
                                End If
                            End If
                        End If
                    End If
                End If
                If DontRedoQuickDistFlag = 0 Or x = x Then
                    If RCompatS(C) <> RCompatS(CompMat(C, 0)) Or RCompatS(C) <> RCompatS(CompMat(C, 1)) Then
                        If RCompatS(C) <= RCompatS(CompMat(C, 0)) And RCompatS(C) <= RCompatS(CompMat(C, 1)) Then
                            If TrpScore(C) >= TrpScore(CompMat(C, 0)) And TrpScore(C) >= TrpScore(CompMat(C, 1)) Then
                                Consensus(C, 2) = Consensus(C, 2) + MaxS
                                DScores(25, C) = MaxS / 2
                            End If
                        End If
                    End If
                End If
                If OuCheck(C) <> OuCheck(CompMat(C, 0)) Or OuCheck(C) <> OuCheck(CompMat(C, 1)) Then
                    If OuCheck(C) >= OuCheck(CompMat(C, 0)) And OuCheck(C) >= OuCheck(CompMat(C, 1)) Then
                        If SimScore(C) = 1 Then
                            Consensus(C, 2) = Consensus(C, 2) + MaxS
                            DScores(22, C) = SMaxS / 2
                        End If
                    End If
                    
                End If
                If PS2 >= 2 Then
                    If SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 0)) And SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 1)) Then
                        If SimScoreB(C) >= SimScoreB(CompMat(C, 0)) And SimScoreB(C) >= SimScoreB(CompMat(C, 1)) Then
                            Consensus(C, 2) = Consensus(C, 2) + MidS
                            DScores(23, C) = MidS / 2
                        End If
                    End If
                    If SubScore2(C) >= SubScore2(CompMat(C, 0)) And SubScore2(C) >= SubScore2(CompMat(C, 1)) Then
                        If DontRedoQuickDistFlag = 0 Or x = x Then
                    'If PhPrScore2(C) <= PhPrScore2(CompMat(C, 0)) And PhPrScore2(C) <= PhPrScore2(CompMat(C, 1)) Then
                             If BadDists(C) <> BadDists(CompMat(C, 0)) Or BadDists(C) <> BadDists(CompMat(C, 1)) Then
                                If BadDists(C) <= BadDists(CompMat(C, 0)) And BadDists(C) <= BadDists(CompMat(C, 1)) Then
                                   Consensus(C, 2) = Consensus(C, 2) + MidS
                                   DScores(24, C) = MidS / 3
                                End If
                            End If
                        End If
                    End If
                    
                End If
                
            
            
            x = x
        Next C
        
        
        
        
        For x = 0 To 2
            DScores(11, x) = ((RankF(x, 1) - RankF(x, 0)) / NextNo) * 10
            If DScores(11, x) < 0 Then DScores(11, x) = 0
            'Consensus(x, 2) = Consensus(x, 2) + DScores(11, x)
            
        Next x
        
        
        Dim Tot As Double
        
        Tot = 0
        If x = x Then
            If DontRedoQuickDistFlag = 0 Then
                For x = 0 To 2
                    If RCompatC(x) < RCompatD(x) Then
                        If RCompatC(x) > 1 Then
                            Consensus(x, 2) = Consensus(x, 2) - (RCompatC(x) - 1) * 10
                        End If
                    Else
                        If RCompatD(x) > 1 Then
                            Consensus(x, 2) = Consensus(x, 2) - (RCompatD(x) - 1) * 10
                        End If
                    End If
                Next x
            End If
            Tot = 0
            For x = 0 To 2
                If Consensus(x, 2) < Tot Then
                    Tot = Consensus(x, 2)
                End If
            Next x
            For x = 0 To 2
                Consensus(x, 2) = Consensus(x, 2) - Tot
            Next x
        End If
        
        'If ConsensusStrat = 1 Then
            Tot = 0
            For x = 0 To 2
                Tot = Tot + SigmoidX(x)
            Next x

            'Logistic regression scores
            DScores(18, 0) = (SigmoidX(0) / Tot) * 30 '0.9969
            DScores(18, 1) = (SigmoidX(1) / Tot) * 30 '0.004
            DScores(18, 2) = (SigmoidX(2) / Tot) * 30 '0.0096
        'Else
            
            'Original RDP decision tree scores
            Tot = 0
            For x = 0 To 2
                Tot = Tot + Consensus(x, 2)
            Next x
'            For x = 0 To 2
'                If Tot < Consensus(x, 2) Then Tot = Consensus(x, 2)
'            Next x
            If Tot = 0 Then Tot = 1
            For x = 0 To 2
                DScores(0, x) = (Consensus(x, 2) / Tot) * 30
            Next x
            
            
            
            
            
        'End If
        If ConsensusStrat = 1 Then 'the decider statistic is stored in constsus (by default the number there is that of the original RDP decision tree)
                                    
            For x = 0 To 2
                Consensus(x, 2) = SigmoidX(x)
            Next x
        End If
End Sub
Public Sub MakeConsensus(DScores() As Double, Consensus() As Double, INList() As Byte, CompMat() As Long, SubScore2() As Double, SubPhPrScore2() As Double, ListCorr3() As Single, SubScore() As Double, PhPrScore2() As Double, ListCorr() As Single, ListCorr2() As Single, TrpScore() As Double, PhPrScore() As Double, SubPhPrScore() As Double, OuCheck() As Long, BadDists() As Single, RCompat() As Long, tListCorr() As Single)


Dim C As Long
    For C = 0 To 2
            If OuCheck(INList(C)) > 0 Then
                Consensus(INList(C), 0) = Consensus(INList(C), 0) + 1
                Consensus(INList(C), 1) = Consensus(INList(C), 1) + 1
                Consensus(INList(C), 2) = Consensus(INList(C), 2) + 5
                DScores(1 + 4, C) = 10
            ElseIf OuCheck(INList(C)) < 0 Then
                Consensus(INList(C), 0) = Consensus(INList(C), 0) - 1
                Consensus(INList(C), 1) = Consensus(INList(C), 1) - 1
                Consensus(INList(C), 2) = Consensus(INList(C), 2) - 5
                DScores(1 + 4, C) = 0
            Else
                DScores(1 + 4, C) = 5
            End If
            
            
            'If X = 12345 Then
                If BadDists(C) <= BadDists(CompMat(C, 0)) And BadDists(C) <= BadDists(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 1, C) = 10
                ElseIf BadDists(C) < BadDists(CompMat(C, 0)) Or BadDists(C) < BadDists(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 1, C) = 5
                End If
           
            If RCompat(C) <= RCompat(CompMat(C, 0)) And RCompat(C) <= RCompat(CompMat(C, 1)) Then
                Consensus(C, 0) = Consensus(C, 0) + 1
                Consensus(C, 1) = Consensus(C, 1) + 1
                If RCompat(C) = 0 Then
                    Consensus(C, 2) = Consensus(C, 2) + 20
                    DScores(1 + 0, C) = 20
                Else
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 0, C) = 10
                End If
            ElseIf RCompat(C) < RCompat(CompMat(C, 0)) Or RCompat(C) < RCompat(CompMat(C, 1)) Then
                Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 5
                DScores(1 + 0, C) = 5
            End If
            'If X = 12345 Then
            '    If tListCorr(C, 0) >= tListCorr(CompMat(C, 0), 0) And tListCorr(C, 0) >= tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 0) > tListCorr(CompMat(C, 0), 0) Or tListCorr(C, 0) > tListCorr(CompMat(C, 1), 0) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 1) >= tListCorr(CompMat(C, 0), 1) And tListCorr(C, 1) >= tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1
            '    ElseIf tListCorr(C, 1) > tListCorr(CompMat(C, 0), 1) Or tListCorr(C, 1) > tListCorr(CompMat(C, 1), 1) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 0.5
            '    End If
            '    If tListCorr(C, 2) >= tListCorr(CompMat(C, 0), 2) And tListCorr(C, 2) >= tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 0) = Consensus(C, 0) + 1
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 3
            '    ElseIf tListCorr(C, 2) > tListCorr(CompMat(C, 0), 2) Or tListCorr(C, 2) > tListCorr(CompMat(C, 1), 2) Then
            '        Consensus(C, 1) = Consensus(C, 1) + 1
            '        Consensus(C, 2) = Consensus(C, 2) + 1.5
            '    End If
            'End If
            'If X = 12345 Then
                If TrpScore(C) >= TrpScore(CompMat(C, 0)) And TrpScore(C) >= TrpScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 8, C) = 8
                ElseIf TrpScore(C) > TrpScore(CompMat(C, 0)) Or TrpScore(C) > TrpScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 8, C) = 4
                End If
            'End If
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 0)) And SubPhPrScore(C) >= SubPhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 2, C) = 10
                ElseIf SubPhPrScore(C) > SubPhPrScore(CompMat(C, 0)) Or SubPhPrScore(C) > SubPhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 2, C) = 5
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 0)) And SubPhPrScore2(C) >= SubPhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 5, C) = 8
                ElseIf SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 0)) Or SubPhPrScore2(C) > SubPhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 5, C) = 4
                End If
            End If
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If SubScore(C) >= SubScore(CompMat(C, 0)) And SubScore(C) >= SubScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 2
                    DScores(1 + 12, C) = 2
                ElseIf SubScore(C) > SubScore(CompMat(C, 0)) Or SubScore(C) > SubScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 1
                    DScores(1 + 12, C) = 1
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If SubScore2(C) >= SubScore2(CompMat(C, 0)) And SubScore2(C) >= SubScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 10
                    DScores(1 + 3, C) = 10
                ElseIf SubScore2(C) > SubScore2(CompMat(C, 0)) Or SubScore2(C) > SubScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 5
                    DScores(1 + 3, C) = 5
                End If
            End If
            If Abs(PhPrScore2(0)) < 1 And Abs(PhPrScore2(1)) < 1 And Abs(PhPrScore2(2)) < 1 Then
                If PhPrScore2(C) <= PhPrScore2(CompMat(C, 0)) And PhPrScore2(C) <= PhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 6, C) = 8
                ElseIf PhPrScore2(C) < PhPrScore2(CompMat(C, 0)) Or PhPrScore2(C) < PhPrScore2(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 6, C) = 4
                End If
            End If
            If ListCorr(C) <= ListCorr(CompMat(C, 0)) And ListCorr(C) <= ListCorr(CompMat(C, 1)) Then
                Consensus(C, 0) = Consensus(C, 0) + 1
                Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 4
                DScores(1 + 11, C) = 4
            ElseIf ListCorr(C) < ListCorr(CompMat(C, 0)) Or ListCorr(C) < ListCorr(CompMat(C, 1)) Then
                Consensus(C, 1) = Consensus(C, 1) + 1
                Consensus(C, 2) = Consensus(C, 2) + 2
                DScores(1 + 11, C) = 2
            End If
            
            If Abs(PhPrScore(0)) < 1 And Abs(PhPrScore(1)) < 1 And Abs(PhPrScore(2)) < 1 Then
                If PhPrScore(C) <= PhPrScore(CompMat(C, 0)) And PhPrScore(C) <= PhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 0) = Consensus(C, 0) + 1
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 8
                    DScores(1 + 7, C) = 8
                ElseIf PhPrScore(C) < PhPrScore(CompMat(C, 0)) Or PhPrScore(C) < PhPrScore(CompMat(C, 1)) Then
                    Consensus(C, 1) = Consensus(C, 1) + 1
                    Consensus(C, 2) = Consensus(C, 2) + 4
                    DScores(1 + 7, C) = 4
                End If
            End If
            
        Next C
        Dim Tot As Double
        For x = 0 To 2
            If Tot < Consensus(x, 2) Then Tot = Consensus(x, 2)
        Next x
        For x = 0 To 2
            DScores(0, x) = (Consensus(x, 2) / Tot) * 30
        Next x
        
        
End Sub
Public Sub MakeListCorr(ISeqs() As Long, INList() As Byte, EList() As Integer, ttrcorr() As Single, RNum() As Long, RList() As Long, RInv() As Single, AcList() As Integer, ListCorr3() As Single, ListCorr2() As Single, ListCorr() As Single, tListCorr() As Single, RCorrWarn() As Byte)
Dim b As Long, CAcList() As Integer, tRCorr() As Single
Dim NScoresX() As Long, x As Long, A As Long, Z As Long, Y As Long
ReDim CAcList(2, NextNo), tRCorr(2, 2, 4, NextNo)

For x = 0 To 2
    For Y = 0 To 2
        For Z = 0 To 4
            For A = 0 To NextNo
                If ttrcorr(x, Y, Z, A) > 0.5 And ttrcorr(x, Y, Z, A) < 1 Then
                    tRCorr(x, Y, Z, A) = ttrcorr(x, Y, Z, A)
                End If
            Next A
        Next Z
    Next Y
Next x '

For x = 0 To 2
    If RCorrWarn(x) = 1 Then
        For Y = 0 To 4
            For Z = 0 To NextNo
                For A = 0 To 2
                    tRCorr(A, x, Y, Z) = 0
                Next A
            Next Z
        Next Y
    End If
Next x





    For x = 0 To 2
        For Z = 0 To 2
            For Y = 0 To NextNo
                AcList(x, Z, Y) = -1
            Next Y
        Next Z
    Next x
    
    
    For x = 0 To 2
        For Z = 0 To 2
            For Y = 0 To RNum(x)
                AcList(x, Z, RList(x, Y)) = RInv(x, Z, RList(x, Y))
            Next Y
        Next Z
    Next x
    
    For x = 0 To 2
        For Z = 0 To NextNo
            If AcList(x, 0, Z) > -1 Or AcList(x, 1, Z) > -1 Or AcList(x, 2, Z) > -1 Then '1,4,4
                If AcList(x, 0, Z) = 1 Or AcList(x, 1, Z) = 1 Or AcList(x, 2, Z) = 1 Then
                    CAcList(x, Z) = 1
                ElseIf AcList(x, 0, Z) = 2 Or AcList(x, 1, Z) = 2 Or AcList(x, 2, Z) = 2 Then
                    CAcList(x, Z) = 2
                ElseIf AcList(x, 0, Z) = 4 Or AcList(x, 1, Z) = 4 Or AcList(x, 2, Z) = 4 Then
                    CAcList(x, Z) = 4
                End If
            Else
                CAcList(x, Z) = -1
            End If
        Next Z
                 
    Next x
    For x = 0 To 2
        For Y = 0 To 2
            For Z = 0 To NextNo
                If tRCorr(x, Y, 2, Z) > tRCorr(x, Y, 3, Z) Then
                    tRCorr(x, Y, 3, Z) = tRCorr(x, Y, 2, Z)
                Else
                    tRCorr(x, Y, 2, Z) = tRCorr(x, Y, 3, Z)
                End If
            Next Z
        Next Y
    Next x
    
  '  If SEventNumber = 4 Then
  '      Open "el.csv" For Output As #1
  '      For Y = 0 To 2
  '          For X = 0 To PermNextNo
  '          'For X = PermNextno To 0 Step -1
  '              'Print #1, EList(INList(0), INList(Y), X) & "," & EList(INList(1), INList(Y), X) & "," & EList(INList(2), INList(Y), X)
  '              Print #1, CAcList(INList(Y), X) '& "," & EList(INList(1), INList(Y), X) & "," & EList(INList(2), INList(Y), X)'

  '          Next X
   '         Print #1, ""
  '      Next Y
  '      Close #1
  '      X = X
  '  End If
    '@
    For x = 0 To 2 'winpp
        For Z = 0 To NextNo
            If CAcList(x, Z) > -1 Then
                For A = 0 To 2 'NO,PI,NI
                    If CAcList(x, Z) <> EList(A, x, Z) Then
                        ListCorr(INList(A)) = ListCorr(INList(A)) + 1
                        
                    End If
                    If EList(A, x, Z) > -1 Then
                        If Abs(tRCorr(x, 0, EList(A, x, Z), Z)) < 1 And Abs(tRCorr(x, 1, EList(A, x, Z), Z)) < 1 And Abs(tRCorr(x, 2, EList(A, x, Z), Z)) < 1 Then
                            If tRCorr(x, 0, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 0) = tListCorr(INList(A), 0) + tRCorr(x, 0, EList(A, x, Z), Z)
                            End If
                            If tRCorr(x, 1, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 1) = tListCorr(INList(A), 1) + tRCorr(x, 1, EList(A, x, Z), Z)
                            End If
                            If tRCorr(x, 2, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 2) = tListCorr(INList(A), 2) + tRCorr(x, 2, EList(A, x, Z), Z)
                            End If
                        End If
                    End If
                Next A
            End If
                     
        Next Z
             'Next Y
    Next x
         
         
    ReDim NScoresX(2, 1)
    'For X = 0 To 2 'winpp
    '    For Z = 0 To NextNo
    '        For A = 0 To 2 'NO,PI,NI
    '            If EList(A, X, Z) > -1 Then
    '                ListCorr2(INList(A)) = ListCorr2(INList(A)) + tRCorr(X, 0, EList(A, X, Z), Z) + tRCorr(X, 1, EList(A, X, Z), Z) + tRCorr(X, 2, EList(A, X, Z), Z)
    '                NScoresX(INList(A), 0) = NScoresX(INList(A), 0) + 1
    '            Else
    '                ListCorr3(INList(A)) = ListCorr3(INList(A)) + tRCorr(X, 0, 0, Z) + tRCorr(X, 1, 0, Z) + tRCorr(X, 2, 0, Z)
    '                NScoresX(INList(A), 1) = NScoresX(INList(A), 1) + 1
    '            End If
    '        Next A
    '    Next Z
    '         'Next Y
    'Next X
    
    For x = 0 To 2 'winpp
        For Z = 0 To NextNo
            For A = 0 To 2 'NO,PI,NI
                If EList(A, x, Z) > -1 Then
                    For b = 0 To 2
                        If tRCorr(x, b, EList(A, x, Z), Z) > 0 Then
                            ListCorr2(INList(A)) = ListCorr2(INList(A)) + tRCorr(x, b, EList(A, x, Z), Z)
                            'NScoresX(INList(A), 0) = NScoresX(INList(A), 0) + 1
                        End If
                    Next b
                    NScoresX(INList(A), 0) = NScoresX(INList(A), 0) + 3
                Else
                    For b = 0 To 2
                        If tRCorr(x, b, 0, Z) > 0 Then
                            ListCorr3(INList(A)) = ListCorr3(INList(A)) + tRCorr(x, b, 0, Z)
                            
                        End If
                    Next b
                    NScoresX(INList(A), 1) = NScoresX(INList(A), 1) + 3
                End If
            Next A
        Next Z
             'Next Y
    Next x
   
    
    For x = 0 To 2
        If NScoresX(x, 0) = 0 Or NScoresX(x, 1) = 0 Then
           For Y = 0 To 2
                ListCorr2(Y) = 0
                ListCorr3(Y) = 0
           Next Y
           Exit Sub
        Else
           
                ListCorr2(x) = ListCorr2(x) / NScoresX(x, 0)
                ListCorr3(x) = ListCorr3(x) / NScoresX(x, 1)
            
        End If
    Next x
    

End Sub
Public Sub MakeListCorrOld(ISeqs() As Long, INList() As Byte, EList() As Integer, tRCorr() As Single, RNum() As Long, RList() As Long, RInv() As Single, AcList() As Integer, ListCorr3() As Single, ListCorr2() As Single, ListCorr() As Single, tListCorr() As Single)
Dim CAcList() As Integer
Dim NScoresX() As Long, x As Long, A As Long, Z As Long, Y As Long
ReDim CAcList(2, NextNo)

    For x = 0 To 2
        For Z = 0 To 2
            For Y = 0 To NextNo
                AcList(x, Z, Y) = -1
            Next Y
        Next Z
    Next x
    
    
    For x = 0 To 2
        For Z = 0 To 2
            For Y = 0 To RNum(x)
                AcList(x, Z, RList(x, Y)) = RInv(x, Z, RList(x, Y))
            Next Y
        Next Z
    Next x
    
    For x = 0 To 2
        For Z = 0 To NextNo
            If AcList(x, 0, Z) > -1 Or AcList(x, 1, Z) > -1 Or AcList(x, 2, Z) > -1 Then '1,4,4
                If AcList(x, 0, Z) = 1 Or AcList(x, 1, Z) = 1 Or AcList(x, 2, Z) = 1 Then
                    CAcList(x, Z) = 1
                ElseIf AcList(x, 0, Z) = 2 Or AcList(x, 1, Z) = 2 Or AcList(x, 2, Z) = 2 Then
                    CAcList(x, Z) = 2
                ElseIf AcList(x, 0, Z) = 4 Or AcList(x, 1, Z) = 4 Or AcList(x, 2, Z) = 4 Then
                    CAcList(x, Z) = 4
                End If
            Else
                CAcList(x, Z) = -1
            End If
        Next Z
                 
    Next x
    For x = 0 To 2
        For Y = 0 To 2
            For Z = 0 To NextNo
                If tRCorr(x, Y, 2, Z) > tRCorr(x, Y, 3, Z) Then
                    tRCorr(x, Y, 3, Z) = tRCorr(x, Y, 2, Z)
                Else
                    tRCorr(x, Y, 2, Z) = tRCorr(x, Y, 3, Z)
                End If
            Next Z
        Next Y
    Next x
    
    If SEventNumber = 4 Then
        Open "el.csv" For Output As #1
        For Y = 0 To 2
            For x = 0 To PermNextno
            'For X = PermNextno To 0 Step -1
                'Print #1, EList(INList(0), INList(Y), X) & "," & EList(INList(1), INList(Y), X) & "," & EList(INList(2), INList(Y), X)
                Print #1, CAcList(INList(Y), x) '& "," & EList(INList(1), INList(Y), X) & "," & EList(INList(2), INList(Y), X)

            Next x
            Print #1, ""
        Next Y
        Close #1
        x = x
    End If
    
    For x = 0 To 2 'winpp
        For Z = 0 To NextNo
            If CAcList(x, Z) > -1 Then
                For A = 0 To 2 'NO,PI,NI
                    If CAcList(x, Z) <> EList(A, x, Z) Then
                        ListCorr(INList(A)) = ListCorr(INList(A)) + 1
                        If A = 2 Then
                            x = x
                        End If
                    End If
                    If EList(A, x, Z) > -1 Then
                        If Abs(tRCorr(x, 0, EList(A, x, Z), Z)) < 1 And Abs(tRCorr(x, 1, EList(A, x, Z), Z)) And Abs(tRCorr(x, 2, EList(A, x, Z), Z)) Then
                            If tRCorr(x, 0, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 0) = tListCorr(INList(A), 0) + tRCorr(x, 0, EList(A, x, Z), Z)
                            End If
                            If tRCorr(x, 1, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 1) = tListCorr(INList(A), 1) + tRCorr(x, 1, EList(A, x, Z), Z)
                            End If
                            If tRCorr(x, 2, EList(A, x, Z), Z) > 0 Then
                                tListCorr(INList(A), 2) = tListCorr(INList(A), 2) + tRCorr(x, 2, EList(A, x, Z), Z)
                            End If
                        End If
                    End If
                Next A
            End If
                     
        Next Z
             'Next Y
    Next x
         
         
    ReDim NScoresX(2, 1)
    For x = 0 To 2 'winpp
        For Z = 0 To NextNo
            For A = 0 To 2 'NO,PI,NI
                If EList(A, x, Z) > -1 Then
                    ListCorr2(INList(A)) = ListCorr2(INList(A)) + tRCorr(x, 0, EList(A, x, Z), Z) + tRCorr(x, 1, EList(A, x, Z), Z) + tRCorr(x, 2, EList(A, x, Z), Z)
                    NScoresX(INList(A), 0) = NScoresX(INList(A), 0) + 1
                Else
                    ListCorr3(INList(A)) = ListCorr3(INList(A)) + tRCorr(x, 0, 0, Z) + tRCorr(x, 1, 0, Z) + tRCorr(x, 2, 0, Z)
                    NScoresX(INList(A), 1) = NScoresX(INList(A), 1) + 1
                End If
            Next A
        Next Z
             'Next Y
    Next x
    
    
    For x = 0 To 2
        ListCorr2(x) = ListCorr2(x) / NScoresX(x, 0)
        ListCorr3(x) = ListCorr3(x) / NScoresX(x, 1)
    Next x

End Sub
Public Sub CopyBXOList(TraceSub() As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer, tBXOList() As XOverDefine, tBCurrentXover() As Integer)
    
    Dim UB As Long, Y As Long, x As Long, BXOSize As Long
    
    For x = 0 To NextNo
        If tBCurrentXover(x) > 0 Then
            For Y = 1 To tBCurrentXover(x)
                BCurrentXOver(TraceSub(x)) = BCurrentXOver(TraceSub(x)) + 1
                BXOSize = UBound(BestXOList, 2)
                If BXOSize < 1500 Then
                '@'@'@
                If BCurrentXOver(TraceSub(x)) > BXOSize Then
                    BXOSize = BCurrentXOver(TraceSub(x)) + 10
                    UB = UBound(BestXOList, 1)
                    UB2 = UBound(BestXOList, 2)
                    On Error Resume Next
                    ReDim Preserve BestXOList(UB, BXOSize)
                    On Error GoTo 0
                End If
                If BCurrentXOver(TraceSub(x)) > UBound(BestXOList, 2) Then
                    RF1Count = RF1Count + 1
                    BCurrentXOver(TraceSub(x)) = BCurrentXOver(TraceSub(x)) - 1
                Else
                
                    BestXOList(x, BCurrentXOver(TraceSub(x))) = tBXOList(x, Y)
                End If
                Else
                    ''''''''''''''''''''''''''''''''''''''''''''
                    'Copy to an overflow xolist
                    
                    XX = RF1Count
                    RF1Count = RF1Count + 1
                    BCurrentXOver(TraceSub(x)) = BCurrentXOver(TraceSub(x)) - 1
                End If
            Next Y
        End If
    Next x
    x = x
End Sub
Public Sub MakeBreaks(BPos, Epos, DMiMa() As Long, MiF As Byte, SwapFlag As Byte, MissIDFlag As Byte, CompMat() As Long, WinPP As Long, ISeqs() As Long, FMatSmall() As Single, SMatSmall() As Single, FAMat() As Single, SAMat() As Single, RecombNo() As Long, MinPair() As Byte, Breaks() As Long, BestXOList() As XOverDefine, RNum() As Long, TraceSub() As Long, RList() As Long, WinnerPos() As Long)
Dim A As Long, LowP As Double, TWinner As Long, x As Long, Z As Long, WinPPY As Long, BestPX As Double, SQ() As Long, tWinPP As Byte, MaxPos() As Double, MinPos() As Double
Dim TS As Long, EN As Long, MaxSeq() As Long, MinSeq() As Long
Dim DDTS As Byte
DDTS = 0
Dim LegitP() As Byte
ReDim LegitP(AddNum * 2)
If DoScans(0, 0) = 1 Then LegitP(0) = 1: LegitP(0 + AddNum) = 1
If DoScans(0, 1) = 1 Then LegitP(1) = 1: LegitP(1 + AddNum) = 1
If DoScans(0, 3) = 1 Then LegitP(3) = 1: LegitP(3 + AddNum) = 1
If DoScans(0, 4) = 1 Then LegitP(4) = 1: LegitP(4 + AddNum) = 1
If DoScans(0, 2) = 1 Then LegitP(2) = 1: LegitP(2 + AddNum) = 1
If DoScans(0, 5) = 1 Then LegitP(5) = 1: LegitP(5 + AddNum) = 1


ReDim DoneProg(AddNum), MaxPos(RNum(WinPP), AddNum, 1), MinPos(RNum(WinPP), AddNum, 1), MaxSeq(RNum(WinPP), AddNum, 1), MinSeq(RNum(WinPP), AddNum, 1)
ReDim SQ(2)
For WinPPY = 0 To RNum(WinPP)
    For Z = 0 To AddNum
        For x = 0 To 1
            MaxPos(WinPPY, Z, x) = 0
            MinPos(WinPPY, Z, x) = 1000000
            
        Next x
    Next Z
Next WinPPY

For WinPPY = 0 To RNum(WinPP)
    TWinner = TraceSub(RList(WinPP, WinPPY))
    For Z = 0 To AddNum
        If WinnerPos(WinPPY, Z) > 0 Then
            SQ(0) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter
            SQ(1) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP
            SQ(2) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP
            If BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP < 0 Then 'at least one of the esequences is an extra/exclude
                DDTS = 1
            End If
            If DoneProg(BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag) = 0 Then
                RecombNo(BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag) = RecombNo(BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag) + 1
                DoneProg(BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag) = 1
            End If
            For x = 0 To 2
                If SQ(x) = RList(WinPP, WinPPY) Then Exit For
            Next x
            tWinPP = x
            If tWinPP < 3 Then
                For x = 0 To 1
                    If SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) > MaxPos(WinPPY, Z, 1) Then
                        MaxPos(WinPPY, Z, 1) = SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MaxSeq(WinPPY, Z, 1) = SQ(CompMat(tWinPP, x))
                    End If
                    If SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) < MinPos(WinPPY, Z, 1) Then
                        MinPos(WinPPY, Z, 1) = SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MinSeq(WinPPY, Z, 1) = SQ(CompMat(tWinPP, x))
                    End If
                    If FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) > MaxPos(WinPPY, Z, 0) Then
                        MaxPos(WinPPY, Z, 0) = FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MaxSeq(WinPPY, Z, 0) = SQ(CompMat(tWinPP, x))
                    End If
                    If FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) < MinPos(WinPPY, Z, 0) Then
                        MinPos(WinPPY, Z, 0) = FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MinSeq(WinPPY, Z, 0) = SQ(CompMat(tWinPP, x))
                    End If
                Next x
            End If
        End If
    Next Z
Next WinPPY

ReDim SQ(RNum(WinPP), 2)
'If SEventNumber = 15 Then
'    X = X
'End If
Dim WinX As Long
For x = 0 To RNum(WinPP)
    If RList(WinPP, x) = ISeqs(WinPP) Then
        WinX = x
        Exit For
    End If
Next x

Dim BestPr As Long
BestPr = 0
BestPX = 1000000


For WinPPY = 0 To RNum(WinPP)
    TWinner = TraceSub(RList(WinPP, WinPPY))
    BestPX = 1000000
    For Z = 0 To AddNum - 1
        If WinnerPos(WinPPY, Z) > 0 Then 'CollectEvents(WinPPY, Z).Probability > 0 Then
            SQ(WinPPY, 0) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter
            SQ(WinPPY, 1) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP
            SQ(WinPPY, 2) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP
            If TWinner = 0 And WinnerPos(WinPPY, Z) = 4 Then
                x = x
            End If
            For x = 0 To 2
                If SQ(WinPPY, x) = RList(WinPP, WinPPY) Then Exit For
            Next x
                
            tWinPP = x
            If tWinPP < 3 Then
                
                If LegitP(BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag) = 1 And BestPX > BestXOList(TWinner, WinnerPos(WinPPY, Z)).Probability And (BestPX <> LowP) Then
                    BestPX = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Probability
                    'If BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = BestPr Or WinnerPos(WinPPY, BestPr) = 0 Then
                        Breaks(0, WinPPY) = BPos 'BestXOList(TWinner, WinnerPos(WinPPY, Z)).Beginning
                        Breaks(1, WinPPY) = Epos 'BestXOList(TWinner, WinnerPos(WinPPY, Z)).Ending
                    'End If
                End If
                
                BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter = (SQ(WinPPY, tWinPP))
                
                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MissIdentifyFlag = MissIDFlag
                
                If MissIDFlag = 3 Or MissIDFlag = 13 Then
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).Accept = 2
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag + AddNum
                Else
                    
                        BestXOList(TWinner, WinnerPos(WinPPY, Z)).Accept = 0
                    
                End If
'                If QvRRejectFlag = 1 Then
'                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).Accept = 3
'                Else
                If MinPair(0) <> MinPair(1) Then 'And MaxSeq(WinPPY, Z, 1) <> MinSeq(WinPPY, Z, 1) Then   ' ie there is a change in relative tree positions
                    'Is winner the outlyer or an inlyer
                    If MaxPos(WinPPY, Z, 0) = MinPos(WinPPY, Z, 0) Then 'ie it is an outlyer in the BR so
                                                        'it must be an inlyer in the region
                        If MaxSeq(WinPPY, Z, 1) <> MinSeq(WinPPY, Z, 1) Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                            For A = 0 To 3
                                If A <> WinPP And ISeqs(A) <> MaxSeq(WinPPY, Z, 1) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(A)
                                    Exit For
                                End If
                            Next A
                        End If
                        BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                    Else ' it is an inlyer in BR
                        'is it an inlyer in the recombinant region?
                        If MaxPos(WinPPY, Z, 1) = MinPos(WinPPY, Z, 1) Then
                            'it is an outlyer in the recombinant region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MinSeq(WinPPY, Z, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MaxSeq(WinPPY, Z, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                        Else
                            'it is an inlyer in the recombinant region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                        End If
                    End If
                Else
                    'is it an inlyer or an outlyer?
                    If MaxPos(WinPPY, Z, 1) <> 0 Or MinPos(WinPPY, Z, 1) <> 0 Then 'you can only tell this if there are more than 3 sequences in the alignment
                        If MaxPos(WinPPY, Z, 1) = MinPos(WinPPY, Z, 1) Then
                            'it is an outlyer in the BR and recomb region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (SQ(WinPPY, CompMat(tWinPP, 0)))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (SQ(WinPPY, CompMat(tWinPP, 1)))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                        Else
                                
                            If FMatSmall(WinPP, MinSeq(WinPPY, Z, 1)) > SMatSmall(WinPP, MinSeq(WinPPY, Z, 1)) Then
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                            Else
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MaxSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MinSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                            End If
                        End If
                    Else
                        If FMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(CompMat(WinPP, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = ISeqs(CompMat(WinPP, 0))
                            If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                                Else
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                                End If
                            End If
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(CompMat(WinPP, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = ISeqs(CompMat(WinPP, 1))
                            If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                                Else
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                                End If
                            
                            End If
                        End If
                    End If
                End If
                
                If BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = 5 Or BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = 8 Then
                    EN = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Eventnumber
                    If CLng(Abs(BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder)) <= NextNo And BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder > -1000000 Then
                        TS = CLng(Abs(BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder))
                        If BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder < 0 Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = -TraceSub(TS) - 0.0000001
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = TraceSub(TS) 'TS TraceSub(CLng(Abs((BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder))))
                        End If
                    Else
                        BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder - 10000000
                    End If
                End If
                
                If TWinner < PermNextno And TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter) <> TWinner And BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP >= 0 Then
                    x = x
                End If
                If DDTS = 0 Then
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter)
                    
                    
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP)
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP)
               Else
                    x = x
                    If BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP >= 0 Or x = x Then
                     'BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -100
                        
                        'XoverList(x, Y).BeginP = -100
                        If BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                        'XX = bestxolist(twinner, winnerpos(winppy,z)).EndP '0
                        End If
'                        If BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
'                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter + 1)
'                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno Then
'                           BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP + 1)
'                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno Then
'                           BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP + 1)
'                        End If
                    End If
                        
               End If
                    
            End If
        
        End If
        
    Next Z
Next WinPPY



End Sub
Public Sub MakeAlternative(BPos, Epos, tEHits() As Byte, DMiMa() As Long, MiF As Byte, SwapFlag As Byte, MissIDFlag As Byte, CompMat() As Long, WinPP As Long, ISeqs() As Long, FMatSmall() As Single, SMatSmall() As Single, FAMat() As Single, SAMat() As Single, MinPair() As Byte, BestXOList() As XOverDefine, RNum() As Long, TraceSub() As Long, RList() As Long, WinnerPos() As Long)
Dim A As Long, LowP As Double, TWinner As Long, x As Long, Z As Long, WinPPY As Long, BestPX As Double, SQ() As Long, tWinPP As Byte, MaxPos() As Double, MinPos() As Double
Dim TS As Long, EN As Long, MaxSeq() As Long, MinSeq() As Long
Dim DDTS As Byte
If RNum(WinPP) = -1 Then RNum(WinPP) = 0
ReDim MaxPos(RNum(WinPP), AddNum, 1), MinPos(RNum(WinPP), AddNum, 1), MaxSeq(RNum(WinPP), AddNum, 1), MinSeq(RNum(WinPP), AddNum, 1)
ReDim SQ(2)

For WinPPY = 0 To RNum(WinPP)
    For Z = 0 To AddNum
        For x = 0 To 1
            MaxPos(WinPPY, Z, x) = 0
            MinPos(WinPPY, Z, x) = 1000000
        Next x
    Next Z
Next WinPPY
DDTS = 0
For WinPPY = 0 To RNum(WinPP)
    TWinner = TraceSub(RList(WinPP, WinPPY))
    For Z = 0 To AddNum
        If WinnerPos(WinPPY, Z) > 0 Then
            SQ(0) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter
            SQ(1) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP
            SQ(2) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP
            If BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP < 0 Then 'this means that at least one fo the sequences is an extrahit/exclude
                DDTS = 1
            End If
            For x = 0 To 2
                If SQ(x) = RList(WinPP, WinPPY) Then Exit For
            Next x
            
            tWinPP = x
            
            If tWinPP < 3 Then
                For x = 0 To 1
                    If SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) > MaxPos(WinPPY, Z, 1) Then
                        MaxPos(WinPPY, Z, 1) = SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MaxSeq(WinPPY, Z, 1) = SQ(CompMat(tWinPP, x))
                    End If
                    If SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) < MinPos(WinPPY, Z, 1) Then
                        MinPos(WinPPY, Z, 1) = SAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MinSeq(WinPPY, Z, 1) = SQ(CompMat(tWinPP, x))
                    End If
                    If FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) > MaxPos(WinPPY, Z, 0) Then
                        MaxPos(WinPPY, Z, 0) = FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MaxSeq(WinPPY, Z, 0) = SQ(CompMat(tWinPP, x))
                    End If
                    If FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x))) < MinPos(WinPPY, Z, 0) Then
                        MinPos(WinPPY, Z, 0) = FAMat(SQ(tWinPP), SQ(CompMat(tWinPP, x)))
                        MinSeq(WinPPY, Z, 0) = SQ(CompMat(tWinPP, x))
                    End If
                Next x
            End If
        End If
    Next Z
Next WinPPY
'If tEHits(ISeqs(WinPP)) = 0 Then SwapFlag = 1
ReDim SQ(RNum(WinPP), 2)

For WinPPY = 0 To RNum(WinPP)
    TWinner = TraceSub(RList(WinPP, WinPPY))
    BestPX = 100
    For Z = 0 To AddNum - 1
        If WinnerPos(WinPPY, Z) > 0 Then 'CollectEvents(WinPPY, Z).Probability > 0 Then
            SQ(WinPPY, 0) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter
            SQ(WinPPY, 1) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP
            SQ(WinPPY, 2) = BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP
                
            For x = 0 To 2
                If SQ(WinPPY, x) = RList(WinPP, WinPPY) Then Exit For
            Next x
                
            tWinPP = x
            If tWinPP < 3 Then
                If BestPX > BestXOList(TWinner, WinnerPos(WinPPY, Z)).Probability And (BestPX <> LowP) Then
                    BestPX = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Probability
                End If
                
                BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter = (SQ(WinPPY, tWinPP))
                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MissIdentifyFlag = MissIDFlag
                
                If MissIDFlag = 3 Or MissIDFlag = 13 Then
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).Accept = 2
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag + AddNum
                Else
                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).Accept = 0
                End If
                
                If MinPair(0) <> MinPair(1) Then 'And MaxSeq(WinPPY, Z, 1) <> MinSeq(WinPPY, Z, 1) Then   ' ie there is a change in relative tree positions
                    'Is winner the outlyer or an inlyer
                    If MaxPos(WinPPY, Z, 0) = MinPos(WinPPY, Z, 0) Then 'ie it is an outlyer in the BR so
                                                        'it must be an inlyer in the region
                        If MaxSeq(WinPPY, Z, 1) <> MinSeq(WinPPY, Z, 1) Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                            For A = 0 To 3
                                If A <> WinPP And ISeqs(A) <> MaxPos(WinPPY, Z, 0) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(A)
                                    Exit For
                                End If
                            Next A
                        End If
                        BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                    Else ' it is an inlyer in BR
                        'is it an inlyer in the recombinant region?
                        If MaxPos(WinPPY, Z, 1) = MinPos(WinPPY, Z, 1) Then
                            'it is an outlyer in the recombinant region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MinSeq(WinPPY, Z, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MaxSeq(WinPPY, Z, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                        Else
                            'it is an inlyer in the recombinant region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                        End If
                    End If
                Else
                    'is it an inlyer or an outlyer?
                    If MaxPos(WinPPY, Z, 1) <> 0 Or MinPos(WinPPY, Z, 1) <> 0 Then
                        If MaxPos(WinPPY, Z, 1) = MinPos(WinPPY, Z, 1) Then
                            'it is an outlyer in the BR and recomb region
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (SQ(WinPPY, CompMat(tWinPP, 0)))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (SQ(WinPPY, CompMat(tWinPP, 1)))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                        Else
                                
                            If FMatSmall(WinPP, MinSeq(WinPPY, Z, 1)) > SMatSmall(WinPP, MinSeq(WinPPY, Z, 1)) Then
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MinSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MaxSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                            Else
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = (MaxSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = (MinSeq(WinPPY, Z, 1))
                                BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                            End If
                        End If
                    
                    Else
                        If FMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(CompMat(WinPP, 1))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = ISeqs(CompMat(WinPP, 0))
                            If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                                Else
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                                End If
                            End If
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = ISeqs(CompMat(WinPP, 0))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = ISeqs(CompMat(WinPP, 1))
                            If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 1
                                Else
                                    BestXOList(TWinner, WinnerPos(WinPPY, Z)).OutsideFlag = 2
                                End If
                            
                            End If
                        End If
                    End If
                End If
                
                If BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = 5 Or BestXOList(TWinner, WinnerPos(WinPPY, Z)).ProgramFlag = 8 Then
                    EN = BestXOList(TWinner, WinnerPos(WinPPY, Z)).Eventnumber
                    If CLng(Abs(BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder)) <= NextNo And BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder > -1000000 Then
                        TS = CLng(Abs(BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder))
                        If BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder < 0 Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = -TraceSub(TS) - 0.0000001
                        Else
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = TraceSub(TS) 'TS TraceSub(CLng(Abs((BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder))))
                        End If
                    Else
                        BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder = BestXOList(TWinner, WinnerPos(WinPPY, Z)).DHolder - 10000000
                    End If
                    
                End If
                If DDTS = 0 Then
                     BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter)
                     
                    
                     BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP)
                     BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP = TraceSub(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP)
                
                 Else
                    x = x
                        If BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno And BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MajorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).MinorP))
                        ElseIf BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter > PermNextno Then
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).EndP = 0
                            BestXOList(TWinner, WinnerPos(WinPPY, Z)).BeginP = -CombineP(OSNPos(BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter), (BestXOList(TWinner, WinnerPos(WinPPY, Z)).Daughter))
                        'XX = bestxolist(twinner, winnerpos(winppy,z)).EndP '0
                        End If
                 End If
            End If
        End If
    Next Z
Next WinPPY
'For X = 0 To Nextno
'    For Y = 1 To 6
'        If BestXOList(X, Y).Daughter = BestXOList(X, Y).MajorP Or BestXOList(X, Y).Daughter = BestXOList(X, Y).MinorP Then
'            X = X
'        End If
'    Next Y
'Next X
End Sub
Public Sub MakeCollecteventsY(SMat() As Single, ISeqs() As Long, LowP As Double, WinPP As Long, Epos As Long, BPos As Long, OLSeq() As Long, RSize() As Long, CompMat() As Long, Relevant() As Long, PCurrentXover() As Integer, CollectEvents() As XOverDefine, PXOList() As XOverDefine, RNum() As Long, RList() As Long)


'XX = ISeqs(1) '33,37
Dim Dummy As Long, OLSize As Long, GoOn As Long, CTest As Long, CPar As Long, Hits(1) As Single, TotS(1) As Single, NearPair As Long, tWinPP As Long, CSeq(1) As Long, A As Long, Z As Long, x As Long, Y As Long, SQ() As Long, oldY As Long, FoundOne() As Long
Dim tMatch(1) As Double, tMatchX() As Long, BPos2 As Long, EPos2 As Long
Dim ZZZX As Long, ZZX As Long, BestOL() As Double, BestPV() As Double


'If SEventNumber = 18 Then
'    X = X
'End If

If RNum(WinPP) = -1 Then Exit Sub

ReDim BestOL(RNum(WinPP), AddNum * 2), BestPV(RNum(WinPP), AddNum * 2)
'SS = Abs(GetTickCount) '

For x = 0 To RNum(WinPP)
    For Y = 0 To AddNum
        BestPV(x, Y) = 1
    Next Y
Next x

'exclude gap positons in rsize1
'Dim MissAdjust As Long, WinSeq As Long
'WinSeq = ISeqs(WinPP)
'MissAdjust = 0
'If BPos < EPos Then
'    For X = 1 To BPos - 1
'        MissAdjust = MissAdjust + MissingData(X, WinSeq)
'    Next X
'    For X = EPos + 1 To Len(StrainSeq(0))
'        MissAdjust = MissAdjust + MissingData(X, WinSeq)
'    Next X
'Else
'    For X = EPos + 1 To BPos - 1
'        MissAdjust = MissAdjust + MissingData(X, WinSeq)
'    Next X
'End If


If SMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) < (SMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) * 0.8) Then
    NearPair = 0
ElseIf SMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) < (SMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) * 0.95) Then
    NearPair = 1
Else
    NearPair = 2
End If

ReDim SQ(2)
Dim tDon() As Byte
Dim TList() As Byte, TrS(2) As Long
'ReDim TList(2, NextNo)
'For X = 0 To 2
'    For Y = 0 To RNum(X)
'        TList(X, RList(X, Y)) = 1
'    Next Y
'Next X

ReDim TList(2, NextNo)
TList(CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 0))) = 1
TList(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 1))) = 1
For Y = 0 To RNum(WinPP)
    TList(WinPP, RList(WinPP, Y)) = 1
Next Y

'XX = TList(WinPP, 881)

' XX = PXOList(19, 38).Probability
' XX = PXOList(19, 38).Beginning
ReDim FoundOne(NextNo)
            
            For x = 0 To NextNo
'                If X = 881 Then
'                    X = X
'                End If
                If TList(WinPP, x) = 1 Or ISeqs(CompMat(WinPP, 0)) = x Or ISeqs(CompMat(WinPP, 1)) = x Then
                    oldY = -1
                    For Y = 1 To PCurrentXover(x)
'                        If X = 19 And Y = 174 Then
'                            X = X
'                        End If
                        
'                        If Y = 163 Then
'                            X = X
'                        End If
                        If oldY <> Y Then
                        
                            ReDim tDon(5)
                            oldY = Y
                            ZZX = 0
                        Else
                            ZZX = ZZX + 1
                            If ZZX > 6 Then
                                ReDim tDon(5)
                                oldY = Y
                                Y = Y + 1
                                ZZX = 0
                                If Y > PCurrentXover(x) Then Exit For
                                
                            End If
                            If Y = oldY Then
                                ZZZX = 0
                                For A = 0 To 5
                                    ZZZX = ZZZX + tDon(A)
                                Next A
                                If ZZZX = 6 Then
                                    Y = Y + 1
                                    ReDim tDon(5)
                                    oldY = Y
                                    ZZX = 0
                                    ZZZX = 0
                                    If Y > PCurrentXover(x) Then Exit For
                                End If
                                
                            End If
                        End If
                        If Y <= UBound(PXOList, 2) Then
                            
                        
                        SQ(1) = PXOList(x, Y).MajorP
                        
                        If SQ(1) <= UBound(TList, 2) Then
                            If TList(WinPP, SQ(1)) = 1 Or ISeqs(CompMat(WinPP, 0)) = SQ(1) Or ISeqs(CompMat(WinPP, 1)) = SQ(1) Then
                                GoOn = 0
                                SQ(2) = PXOList(x, Y).MinorP
                                If SQ(2) <= UBound(TList, 2) Then
                                    If TList(WinPP, SQ(2)) = 1 Or ISeqs(CompMat(WinPP, 0)) = SQ(2) Or ISeqs(CompMat(WinPP, 1)) = SQ(2) Then
                                        SQ(0) = PXOList(x, Y).Daughter
                                        'SQ(0) = x'PXOList(X, Y).Daughter
                                        
                                        
                                        tMatch(0) = 0
                                        If tDon(0) = 0 And TList(0, SQ(0)) = 1 And TList(1, SQ(1)) = 1 And TList(2, SQ(2)) = 1 Then
                                            tDon(0) = 1: TrS(0) = SQ(0): TrS(1) = SQ(1): TrS(2) = SQ(2): tMatch(0) = 3
                                        ElseIf tDon(1) = 0 And TList(0, SQ(0)) = 1 And TList(1, SQ(2)) = 1 And TList(2, SQ(1)) = 1 Then
                                            tDon(1) = 1: TrS(0) = SQ(0): TrS(1) = SQ(2): TrS(2) = SQ(1): tMatch(0) = 3
                                        ElseIf tDon(2) = 0 And TList(0, SQ(1)) = 1 And TList(1, SQ(2)) = 1 And TList(2, SQ(0)) = 1 Then
                                            tDon(2) = 1: TrS(0) = SQ(1): TrS(1) = SQ(2): TrS(2) = SQ(0): tMatch(0) = 3
                                        ElseIf tDon(3) = 0 And TList(0, SQ(1)) = 1 And TList(1, SQ(0)) = 1 And TList(2, SQ(2)) = 1 Then
                                            tDon(3) = 1: TrS(0) = SQ(1): TrS(1) = SQ(0): TrS(2) = SQ(2): tMatch(0) = 3
                                        ElseIf tDon(4) = 0 And TList(0, SQ(2)) = 1 And TList(1, SQ(1)) = 1 And TList(2, SQ(0)) = 1 Then
                                            tDon(4) = 1: TrS(0) = SQ(2): TrS(1) = SQ(1): TrS(2) = SQ(0): tMatch(0) = 3
                                        ElseIf tDon(5) = 0 And TList(0, SQ(2)) = 1 And TList(1, SQ(0)) = 1 And TList(2, SQ(1)) = 1 Then
                                            tDon(5) = 1: TrS(0) = SQ(2): TrS(1) = SQ(0): TrS(2) = SQ(1): tMatch(0) = 3
                                        End If
                                            
                                        If tMatch(0) = 3 Then
                                        
                                            For A = 0 To 2
                                                If TrS(WinPP) = SQ(A) Then
                                                    
                                                    Exit For
                                                End If
                                            Next A
                                            'If InvS(Compmat(WinPP, 0), TrS(Compmat(WinPP, 0))) = 0 And InvS(Compmat(WinPP, 1), TrS(Compmat(WinPP, 1))) = 0 Then
                                                For A = 0 To RNum(WinPP)
                                                    If RList(WinPP, A) = TrS(WinPP) Then
                                                        Exit For
                                                    End If
                                                Next A
                                                            
                                                If A > RNum(WinPP) Then
                                                    tMatch(0) = 0
                                                Else
                                                    CSeq(1) = A
                                                    GoOn = 1
                                                End If
                                            'Else
                                            '    tMatch(0) = 0
                                            'End If
                                        End If
                                        
                                        'ie an event involving a potentially recombinant sequence is found.
                                        If tMatch(0) = 3 And GoOn = 1 Then
                                            'check for region overlap
                                            BPos2 = PXOList(x, Y).Beginning
                                            EPos2 = PXOList(x, Y).Ending
                                           ' If BPos2 = 1294 And EPos2 = 1372 Then
                                           '     XX = PXOList(X, Y).ProgramFlag
                                           ' End If
                                            OLSize = FindOverlap(Len(StrainSeq(0)), BPos2, EPos2, RSize(0), OLSeq(0))
                                            If OLSize > 0 Then
                                                'RSize(1) = RSize(1) - MissAdjust
'                                                If SEventNumber = 7 Then
'                                                    If PXOList(X, Y).ProgramFlag = 8 Then
'                                                        X = X
'                                                    End If
'                                                End If
                                                tMatch(1) = (OLSize * 2) / (RSize(0) + RSize(1))
                                            Else
                                                tMatch(1) = 0
                                            End If
                                           
                                            tMatch(1) = CLng(tMatch(1) * 100000) / 100000
                                            
                                            If ((tMatch(0) * tMatch(1) > 1) Or ((Abs(BPos2 - BPos) < 30 Or Abs(EPos2 - Epos) < 30 Or Abs(EPos2 - BPos) < 30 Or Abs(BPos2 - Epos) < 30) And ((OLSize / RSize(0) > 0.9 And OLSize / RSize(0) < 1.1) Or (OLSize / RSize(1) > 0.9 And OLSize / RSize(1) < 1.1)))) And tMatch(1) >= BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) Then
                                                'If SEventNumber = 2 And WinPP = 2 Then
                                                '    X = X
                                                ''End If
                                                'check to see if this hit is the best identity match too
                                                CTest = RList(WinPP, CSeq(1))
                                                If x = x Then
                                                    Dummy = CalcHits(WinPP, Len(StrainSeq(0)), CTest, BPos2, EPos2, UBound(SeqNum, 1), UBound(CompMat, 1), SeqNum(0, 0), ISeqs(0), CompMat(0, 0), Hits(0), TotS(0))
                                                    
                                                    x = x
                                                Else
                                                
                                                
        '                                            For A = 0 To 1
        '                                                Tots(A) = 0
        '                                                Hits(A) = 0
        '                                                CPar = ISeqs(CompMat(WinPP, A))
        '                                                If BPos2 < EPos2 Then
        '
        '                                                    For B = BPos2 To EPos2
        '                                                        If SeqNum(B, CTest) <> 46 Then
        '                                                            If SeqNum(B, CPar) <> 46 Then
        '                                                                Tots(A) = Tots(A) + 1
        '                                                                If SeqNum(B, CPar) <> SeqNum(B, CTest) Then
        '                                                                    Hits(A) = Hits(A) + 1
        '                                                                End If
        '                                                            End If
        '                                                        End If
        '                                                    Next B
        '                                                Else
        '                                                    For B = 1 To EPos2
        '                                                        If SeqNum(B, CTest) <> 46 Then
        '                                                            If SeqNum(B, CPar) <> 46 Then
        '                                                                Tots(A) = Tots(A) + 1
        '                                                                If SeqNum(B, CPar) <> SeqNum(B, CTest) Then
        '                                                                    Hits(A) = Hits(A) + 1
        '                                                                End If
        '                                                            End If
        '                                                        End If
        '                                                    Next B
        '                                                    For B = BPos2 To Len(StrainSeq(0))
        '                                                        If SeqNum(B, CTest) <> 46 Then
        '                                                            If SeqNum(B, CPar) <> 46 Then
        '                                                                Tots(A) = Tots(A) + 1
        '                                                                If SeqNum(B, CPar) <> SeqNum(B, CTest) Then
        '                                                                    Hits(A) = Hits(A) + 1
        '                                                                End If
        '                                                            End If
        '                                                        End If
        '                                                    Next B
        '                                                End If
        '                                                If Tots(A) > 0 Then
        '                                                    Hits(A) = Hits(A) / Tots(A)
        '                                                Else
        '                                                    Hits(A) = 0
        '                                                End If
        '                                                X = X
        '                                            Next A
                                                    
                                                    
                                                    'the point of all this is to exclude the wrong bit of partially overlapping recombination signals -
                                                End If
                                                If NearPair = 0 Then
                                                    If Hits(1) >= Hits(0) Then
                                                        GoOn = 1
                                                    Else
                                                        If (Hits(1) * 1.1) > Hits(0) Then
                                                            If tMatch(1) > 0.5 Then
                                                                GoOn = 1
                                                            End If
                                                        End If
                                                    End If
                                                ElseIf NearPair = 1 Then
                                                    If Hits(0) > Hits(1) Then
                                                        GoOn = 1
                                                    Else
                                                        If (Hits(0) * 1.1) > Hits(1) Then
                                                            If tMatch(1) > 0.5 Then
                                                                GoOn = 1
                                                            End If
                                                        End If
                                                    End If
                                                Else
                                                    
                                                    GoOn = 1
                                                End If
                                                
                                                
                                                If SQ(0) = ISeqs(0) Or SQ(0) = ISeqs(1) Or SQ(0) = ISeqs(2) Then
                                                    If SQ(1) = ISeqs(0) Or SQ(1) = ISeqs(1) Or SQ(1) = ISeqs(2) Then
                                                        If SQ(2) = ISeqs(0) Or SQ(2) = ISeqs(1) Or SQ(2) = ISeqs(2) Then
                                                            GoOn = 1
                                                        End If
                                                    End If
                                                End If
                                                
                                                If GoOn = 1 Then
                                                    If tMatch(1) = BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) Then
                                                        If BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) > PXOList(x, Y).Probability Or BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = 0 Then
                                                            BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                                
                                                            BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                                   
                                                            CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                                
                                                        
                                                        End If
                                                    Else
                                                        BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                                
                                                        BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                               
                                                        CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                        'X = X
                                                        '1,1,2
'                                                        XX = RNum(WinPP) ' RList(WinPP, 1)
'                                                        XX = RList(WinPP, CSeq(1))
                                                        'If RList(WinPP, CSeq(1)) = 15 And SEventNumber = 71 Then
                                                        '    X = X
                                                        '    XX = (31 - SQ(0)) '21
                                                        '    XX = (31 - SQ(1)) '9
                                                        '    XX = (31 - SQ(2)) '15
                                                        'End If
                                                    End If
                                                End If
                                                Y = Y - 1
                                            Else
                                                Y = Y - 1
                                            End If
                                            If x = 12345 And tMatch(0) * tMatch(1) > 1 And (tMatch(1) >= BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) / 1.0000000001 Or -Log10(BestPV(CSeq(1), PXOList(x, Y).ProgramFlag)) * 0.8 < -Log10(PXOList(x, Y).Probability)) Then '(tMatch(1) > BestOL(CSeq(1), PXOList(X, Y).ProgramFlag) / 1.0000000001 And tMatch(1) < BestOL(CSeq(1), PXOList(X, Y).ProgramFlag) * 1.0000000001) Then
                                                If (tMatch(1) > BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) / 1.0000000001 And tMatch(1) < BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) * 1.0000000001) Then
                                                                
                                                    If BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) > PXOList(x, Y).Probability Or BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = 0 Then
                                                       ' If CSeq(1) = 7 Then
                                                       ' X = X
                                                       ' XX = RList(WinPP, CSeq(1))
                                                       '
                                                    'End If
                                                        BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                        'If BestOL(CSeq(1), PXOList(X, Y).ProgramFlag) < tMatch(1) Then
                                                            BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                        'End If
                                                        CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                        
                                                        Y = Y - 1
                                                    End If
                                                Else
                                                    'If CSeq(1) = 7 And PXOList(X, Y).ProgramFlag = 0 Then
                                                    '    X = X
                                                    
'                                                        XX = RList(WinPP, CSeq(1))
'                                                        XX = PXOList(X, Y).Beginning
'                                                        XX = PXOList(X, Y).Ending
'                                                        XX = PXOList(X, Y).ProgramFlag
'                                                    'End If
                                                    
                                                    If -Log10(BestPV(CSeq(1), PXOList(x, Y).ProgramFlag)) * 0.8 < -Log10(PXOList(x, Y).Probability) Or BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = 0 Then
                                                    'If BestPV(CSeq(1), PXOList(X, Y).ProgramFlag) > PXOList(X, Y).Probability Then
                                                        If BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) < PXOList(x, Y).Probability Then BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                        If BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) > tMatch(1) Then BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                        CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                        
                                                        Y = Y - 1
                                                    End If
                                                End If
                                            End If
                                        Else
                                            Y = Y - 1
                                        End If
                                    End If
                                End If
                            End If
                            End If
                        End If
                    Next Y
                End If
            Next x
'EE = Abs(GetTickCount)
'tttt = EE - SS
'X = X
End Sub
Public Sub MakeCollectevents(LowP As Double, WinPP As Long, Epos As Long, BPos As Long, OLSeq() As Long, RSize() As Long, CompMat() As Long, Relevant() As Long, PCurrentXover() As Integer, CollectEvents() As XOverDefine, PXOList() As XOverDefine, RNum() As Long, RList() As Long)

Dim tWinPP As Long, CSeq(1) As Long, A As Long, Z As Long, x As Long, Y As Long, SQ() As Long, oldY As Long, FoundOne() As Long
Dim tMatch(1) As Double, tMatchX() As Long, BPos2 As Long, EPos2 As Long
Dim BestOL(), BestPV()

ReDim BestOL(RNum(WinPP), AddNum * 2), BestPV(RNum(WinPP), AddNum * 2)
ReDim SQ(2)


For x = 0 To NextNo
    'If X = 23 Then
    '    X = X
    'End If
    If Relevant(x) = 1 Then
        oldY = -1
        For Y = 1 To PCurrentXover(x)
            'If Y = 13 Then
            '    X = X
            'End If
            SQ(1) = PXOList(x, Y).MajorP
            If Relevant(SQ(1)) = 1 Then
                If oldY <> Y Then
                    ReDim FoundOne(2)
                    oldY = Y
                End If
                SQ(2) = PXOList(x, Y).MinorP
                
                If Relevant(SQ(2)) = 1 Then
                    SQ(0) = x
                    
                    GoOnX = TestRList(WinPP, A, Z, FoundOne(0), RNum(0), SQ(0), RList(0, 0))
                    If GoOnX = 1 Then
                        'ie an event involving a potentially recombinant sequence is found.
                         
                        CSeq(1) = A
                        tWinPP = Z
                        CSeq(0) = RList(WinPP, A)
                        FoundOne(tWinPP) = 1
                                
                                
                        ReDim tMatchX(1, 1)
                                
                        'If (PXOList(X, Y).Probability < LowP * 1.000000001 And PXOList(X, Y).Probability > LowP / 1.000000001) Or (CollectEvents(CSeq(1), PXOList(X, Y).ProgramFlag).Probability <> LowP And (PXOList(X, Y).Probability < CollectEvents(CSeq(1), PXOList(X, Y).ProgramFlag).Probability Or CollectEvents(CSeq(1), PXOList(X, Y).ProgramFlag).Probability = 0)) Then
                            Dummy = MakeTMatch2(tWinPP, WinPP, tMatchX(0, 0), SQ(0), tMatch(0), RNum(0), RList(0, 0), CompMat(0, 0))
                            If tMatch(0) = 3 Then
                                
                                'Check for region overlap
                                BPos2 = PXOList(x, Y).Beginning
                                EPos2 = PXOList(x, Y).Ending
                                 '9293-9713 1-558
                                'XX = Len(StrainSeq(0))
                               ' For Z = 1 To Len(StrainSeq(0))
                               '     If OLSeq(Z) = 0 Then
                               '         X = X '1-558, 2328-9714
                               '     End If
                               ' Next Z
                                OLSize = FindOverlap(Len(StrainSeq(0)), BPos2, EPos2, RSize(0), OLSeq(0))
                                        
                                If OLSize > 0 Then
                                    tMatch(1) = (OLSize * 2) / (RSize(0) + RSize(1))
                                Else
                                    tMatch(1) = 0
                                End If
                                 
                                If tMatch(0) * tMatch(1) > 1 And tMatch(0) = 3 And tMatch(1) >= (BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) / 1.0000000001) Then '(tMatch(1) > BestOL(CSeq(1), PXOList(X, Y).ProgramFlag) / 1.0000000001 And tMatch(1) < BestOL(CSeq(1), PXOList(X, Y).ProgramFlag) * 1.0000000001) Then
                                    'If (PXOList(X, Y).Probability < LowP * 1.000000001 And PXOList(X, Y).Probability > LowP / 1.000000001) Or (CollectEvents(CSeq(1), PXOList(X, Y).ProgramFlag).Probability <> LowP) Then
                                        'If PXOList(X, Y).ProgramFlag = 1 Then
                                        '            X = X
                                         '       End If
                                        If (tMatch(1) > BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) / 1.0000000001 And tMatch(1) < BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) * 1.0000000001) Then
                                            
                                            If BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) > PXOList(x, Y).Probability Or BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = 0 Then
                                                'If CSeq(1) = 1 And PXOList(X, Y).ProgramFlag = 1 Then
                                                '    X = X
                                                'End If
                                                BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                Y = Y - 1
                                         '       If PXOList(X, Y).ProgramFlag = 1 Then
                                         '           X = X
                                         '       End If
                                            End If
                                        Else
                                                BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                Y = Y - 1
                                                XX = RList(WinPP, CSeq(1))
                                            'End If
                                        End If
                                    'End If
                                    'End If
                                End If
                            End If
                                    
                                    '*************Should I check for converse overlap?****************
                        'Else
                        '    Y = Y - 1
                        'End If
                    Else
                        ReDim FoundOne(2)
                    End If
                End If
            End If
        Next Y
    End If
Next x
x = x
End Sub
Public Sub MakeCollecteventsX(Trace() As Long, SMat() As Single, ISeqs() As Long, LowP As Double, WinPP As Long, Epos As Long, BPos As Long, OLSeq() As Long, RSize() As Long, CompMat() As Long, Relevant() As Long, PCurrentXover() As Integer, CollectEvents() As XOverDefine, PXOList() As XOverDefine, RNum() As Long, RList() As Long)

    Dim Dummy As Long, OLSize As Long, GoOn As Long, CTest As Long, CPar As Long, Hits(1) As Single, TotS(1) As Single, NearPair As Long, tWinPP As Long, CSeq(1) As Long, A As Long, Z As Long, x As Long, Y As Long, SQ() As Long, oldY As Long, FoundOne() As Long
    Dim tMatch(1) As Double, tMatchX() As Long, BPos2 As Long, EPos2 As Long
    Dim ZZZX As Long, ZZX As Long, BestOL() As Double, BestPV() As Double
    
    
'SS = abs(gettickcount)
'For ZZZ = 0 To 500
If x = x Then
    Dummy = MakeCollecteventsC(NextNo, Len(StrainSeq(0)), WinPP, RSize(0), OLSeq(0), UBound(CompMat, 1), CompMat(0, 0), UBound(RList, 1), RList(0, 0), RNum(0), AddNum, UBound(SMatSmall, 1), SMatSmall(0, 0), ISeqs(0), Trace(0), PCurrentXover(0), UBound(PXOList, 1), PXOList(0, 0), UBound(CollectEvents, 1), CollectEvents(0, 0))
    x = x
Else
    
    If RNum(WinPP) = -1 Then Exit Sub
    'XX = RNum(2)
    ReDim BestOL(RNum(WinPP), AddNum * 2), BestPV(RNum(WinPP), AddNum * 2)
    
    For x = 0 To RNum(WinPP)
        For Y = 0 To AddNum
            BestPV(x, Y) = 1
        Next Y
    Next x
    
    If SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < (SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) * 0.8) Then
        NearPair = 0
    ElseIf SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) < (SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) * 0.95) Then
        NearPair = 1
    Else
        NearPair = 2
    End If
    
    ReDim SQ(2)
    Dim tDon() As Byte
    Dim TList() As Byte, TrS(2) As Long
    
    ReDim TList(2, NextNo)
    For Y = 0 To RNum(WinPP)
        TList(WinPP, RList(WinPP, Y)) = 1
    Next Y
    For Y = 0 To RNum(CompMat(WinPP, 0))
        TList(CompMat(WinPP, 0), RList(CompMat(WinPP, 0), Y)) = 1
    Next Y
    For Y = 0 To RNum(CompMat(WinPP, 1))
        TList(CompMat(WinPP, 1), RList(CompMat(WinPP, 1), Y)) = 1
    Next Y
    
    
    ReDim FoundOne(NextNo)
                '@'@'@'@'@'@'@'@
                For Z = 0 To NextNo
                    x = Z
                    For Y = 1 To PCurrentXover(Z)
                        SQ(0) = PXOList(x, Y).Daughter
                        If TList(WinPP, SQ(0)) = 1 Or TList(CompMat(WinPP, 0), SQ(0)) = 1 Or TList(CompMat(WinPP, 1), SQ(0)) = 1 Then
                            
                            SQ(1) = PXOList(x, Y).MajorP
                            If SQ(1) <= UBound(TList, 2) Then
                                If TList(WinPP, SQ(1)) = 1 Or TList(CompMat(WinPP, 0), SQ(1)) = 1 Or TList(CompMat(WinPP, 1), SQ(1)) = 1 Then
                                    
                                    SQ(2) = PXOList(x, Y).MinorP
                                    If SQ(2) <= UBound(TList, 2) Then
                                        If TList(WinPP, SQ(2)) = 1 Or TList(CompMat(WinPP, 0), SQ(2)) = 1 Or TList(CompMat(WinPP, 1), SQ(2)) = 1 Then
                                            tMatch(0) = 3
                                            
                                            'ie an event involving a potentially recombinant sequence is found.
                                                'check for region overlap
                                                BPos2 = PXOList(x, Y).Beginning
                                                EPos2 = PXOList(x, Y).Ending
                                                
                                                OLSize = FindOverlap(Len(StrainSeq(0)), BPos2, EPos2, RSize(0), OLSeq(0))
                                                If OLSize > 0 Then
                                                    
                                                    tMatch(1) = (OLSize * 2) / (RSize(0) + RSize(1))
                                                Else
                                                    tMatch(1) = 0
                                                End If
                                               
                                                tMatch(1) = CLng(tMatch(1) * 100000) / 100000
                                                
                                                If tMatch(1) > 0.1 Then
                                                    
                                                    
                                                        GoOn = 0
                                                        For A = 0 To RNum(WinPP)
                                                            If RList(WinPP, A) = SQ(0) Or RList(WinPP, A) = SQ(1) Or RList(WinPP, A) = SQ(2) Then
                                                                CSeq(1) = A
    
                                                                GoOn = 1
                                                                Exit For
                                                            End If
                                                        Next A
                                                        
                                                        If GoOn = 1 And (BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) > PXOList(x, Y).Probability Or BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = 0) Then
                                                            BestPV(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y).Probability
                                                            BestOL(CSeq(1), PXOList(x, Y).ProgramFlag) = tMatch(1)
                                                            CollectEvents(CSeq(1), PXOList(x, Y).ProgramFlag) = PXOList(x, Y)
                                                            
                                                        
                                                        End If
    
                                                
                                                End If
                                                
                                            
                                        End If
                                    End If
                                End If
                            End If
                        End If
                        
                    Next Y
                Next Z
    'need to make sure that the event pointed to by trace(0) and trace(1) is represented in collectevents
    For A = 0 To RNum(WinPP)
        If RList(WinPP, A) = ISeqs(0) Or RList(WinPP, A) = ISeqs(1) Or RList(WinPP, A) = ISeqs(2) Then
            CSeq(1) = A
            Exit For
        End If
    Next A
    
    CollectEvents(CSeq(1), PXOList(Trace(0), Trace(1)).ProgramFlag) = PXOList(Trace(0), Trace(1))
    x = x
End If
'Next ZZZ
'EE = abs(gettickcount)
'TT = EE - SS '3.781, 0.250
x = x
'For x = 0 To UBound(CollectEvents, 1)
'    For Y = 0 To UBound(CollectEvents, 2)
''        If CollectEvents2(x, Y).Daughter > 0 Then
''            x = x
''        End If
'        If CollectEvents(x, Y).Daughter <> CollectEvents2(x, Y).Daughter Then '103-0,14-0,176-0,14-0,14-0,176-0
'            x = x
'        End If
'    Next Y
'Next x
'x = x
End Sub

Public Sub MakeBestXOList(EventAdd As Long, BXOSize As Long, WinPP As Long, RCorr() As Single, ExtraHits() As Byte, SuperEventList() As Long, TraceSub() As Long, WinnerPos() As Long, RList() As Long, RNum() As Long, BCurrentXOver() As Integer, BestXOList() As XOverDefine, CollectEvents() As XOverDefine)

Dim UB2 As Long, UB As Long, MinP As Double, x As Long, oEventAdd As Long, WinPPY As Long, TWinner As Long

EventAdd = -1
WinPPY = 0
'XX = SEventNumber
If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(BreaksExist, 3)
On Error GoTo 0

If UB < NextNo Then
    If UB = -1 Then
        ReDim BreaksExist(2, 1, NextNo)
    Else
        ReDim Preserve BreaksExist(UBound(BreaksExist, 1), UBound(BreaksExist, 2), NextNo)
    End If
End If

'If SEventNumber = 382 Then
'    x = x
'End If
'If SEventNumber = 5 And WinPP = 0 Then
'    x = x
'End If
'XX = SuperEventList(7) 'should be 5
Dim PRX As Long, ProbX As Double, MaxPr As Double, WinPos As Long

Do While WinPPY <= RNum(WinPP)
    TWinner = RList(WinPP, WinPPY)
    oEventAdd = EventAdd
    MinP = LowestProb * 10000
    For x = 0 To AddNum
        If CollectEvents(WinPPY, x).Probability > 0 Then
            EventAdd = EventAdd + 1
            
            BCurrentXOver(TraceSub(TWinner)) = BCurrentXOver(TraceSub(TWinner)) + 1
            BXOSize = UBound(BestXOList, 2)
            If BCurrentXOver(TraceSub(TWinner)) > BXOSize Then
                BXOSize = BCurrentXOver(TraceSub(TWinner)) + 10
                UB2 = UBound(BestXOList, 1)
                On Error Resume Next
                ReDim Preserve BestXOList(UB2, BXOSize)
                If UBound(BestXOList, 2) <> BXOSize Then
                    On Error GoTo 0
                    BXOSize = UBound(BestXOList, 2)
                    'MsgBox ("There is not enough free memory available right now. Perhaps if you close some programs the situation will improve.")
                    BCurrentXOver(TraceSub(TWinner)) = BCurrentXOver(TraceSub(TWinner)) - 1
                    'find the worst p-val for this method and replace it with tracesub(twinner)
                    PRX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).ProgramFlag
                    ProbX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Probability
                    MaxPr = 0
                    WinPos = -1
                    'Z = 0
                    For Z = 1 To BCurrentXOver(TraceSub(TWinner)) - 1
                        If BestXOList(TraceSub(TWinner), Z).ProgramFlag = PRX Then
                            If BestXOList(TraceSub(TWinner), Z).DHolder < 0 Then
                                If BestXOList(TraceSub(TWinner), Z).Probability > MaxPr Then
                                   WinPos = Z
                                   MaxPr = BestXOList(TraceSub(TWinner), Z).Probability
                                End If
                            End If
                        End If
                    Next Z
                    If WinPos > -1 And WinPos < BCurrentXOver(TraceSub(TWinner)) Then
                        BestXOList(TraceSub(TWinner), WinPos) = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner)))
                    End If
                Else
                    On Error GoTo 0
                End If
                
                
            End If
            WinnerPos(WinPPY, x) = BCurrentXOver(TraceSub(TWinner))
            
            BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))) = CollectEvents(WinPPY, x)
'            XX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Daughter
'            XX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).MinorP
'            XX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).MajorP
'            XX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).PermPVal
'            XX = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).ProgramFlag
'
            If QvRRejectFlag = 1 Then
                BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Accept = 2
            End If
            BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Eventnumber = Eventnumber + EventAdd
            If MinP > BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Probability Then
                MinP = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Probability
            End If
            ReDim Preserve SuperEventList(Eventnumber + EventAdd)
                    
            SuperEventList(Eventnumber + EventAdd) = SEventNumber
        End If
    Next x
    GoOn = 0
    If BusyWithExcludes = 1 Then
        If TWinner > PermNextno Then 'means it is an actual exclude
            ExcludedEventNum = ExcludedEventNum + 1
            ExcludedEventBPNum = ExcludedEventBPNum + 1
            If ExcludedEventNum < ExcludedEventNumThresh Then
                If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
                    ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
                End If
            Else
                
                Dim NF3 As Long
                NF3 = FreeFile
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                NumExcludedEventNum = NumExcludedEventNum + 1
                Put #NF3, 1, ExcludedEventNum
                Put #NF3, , EventsInExcludeds
                Close #NF3
                ReDim EventsInExcludeds(5, 1000)
                ExcludedEventNum = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            EventsInExcludeds(0, ExcludedEventNum) = 3 'should be the discard number but here it indicates it is the recomb
            EventsInExcludeds(1, ExcludedEventNum) = -SEventNumber '79923,79924,79925
            EventsInExcludeds(2, ExcludedEventNum) = TWinner 'should be the position of this sequence in the excludes file
            EventsInExcludeds(3, ExcludedEventNum) = CurSeedExtras 'sequence this exclude is most similar to
            EventsInExcludeds(4, ExcludedEventNum) = OSNPos(TWinner)
            
            If (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 4
            ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 2
            ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 3
            Else
                EventsInExcludeds(5, ExcludedEventNum) = 1
            End If
            GoOn = 1
        End If
        
    End If
    'DoEvents
    If oEventAdd = EventAdd Then 'And (BusyWithExcludes = 0 Or ConservativeGroup = 1) Then
        
        If BusyWithExcludes = 0 Or GoOn = 0 Then
            If WinPPY < RNum(WinPP) Then
                RList(WinPP, WinPPY) = RList(WinPP, RNum(WinPP))
                For x = 0 To AddNum
                    CollectEvents(WinPPY, x) = CollectEvents(RNum(WinPP), x)
                Next x
            End If
            RNum(WinPP) = RNum(WinPP) - 1
        Else
            WinPPY = WinPPY + 1
        End If
    Else
        If BusyWithExcludes = 0 Or TWinner <= PermNextno Then
            If MinP > LowestProb Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 5
            ElseIf (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 4
            ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 2
            ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 3
            Else
                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 1
            End If
        End If
'            If MinP > LowestProb Then
'                ExtraHits(TWinner, SEventNumber) = 5
'            ElseIf (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 4
'            ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 2
'            ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 3
'            Else
'                ExtraHits(TraceSub(RList(WinPP, WinPPY)), SEventNumber) = 1
'            End If
'        End If
        
        WinPPY = WinPPY + 1
    End If
    
Loop
x = x
End Sub
Public Sub MakeNextBestXOLists(Par As Long, RCorr() As Single, ExtraHits() As Byte, EventAdd As Long, WinPP As Long, SuperEventList() As Long, TraceSub() As Long, WinnerPos() As Long, RList() As Long, RNum() As Long, BCurrentXOver() As Integer, BestXOList() As XOverDefine, CollectEvents() As XOverDefine)

Dim BXOSize As Long, UB As Long, MinP As Double, x As Long, oEventAdd As Long, WinPPY As Long, TWinner As Long
''If SEventNumber = 2 And WinPP = 2 Then
'    X = X
'End If

If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(BreaksExist, 3)
On Error GoTo 0

If UB < NextNo Then
    If UB = -1 Then
        ReDim BreaksExist(2, 1, NextNo)
    Else
        ReDim Preserve BreaksExist(UBound(BreaksExist, 1), UBound(BreaksExist, 2), NextNo)
    End If
End If

EventAdd = -1
Do While WinPPY <= RNum(WinPP)
    TWinner = RList(WinPP, WinPPY)
    oEventAdd = EventAdd
    MinP = LowestProb * 10000
'    If SEventNumber = 17 Then
'        x = x
'    End If
    For x = 0 To AddNum
        If CollectEvents(WinPPY, x).Probability > 0 Then
            EventAdd = EventAdd + 1
'             XX = collectevents(WinPPY, x).Daughter
'            XX = collectevents(WinPPY, x).MajorP
'            XX = collectevents(WinPPY, x).MinorP
'            XX = collectevents(WinPPY, x).BeginP
            BCurrentXOver(TraceSub(TWinner)) = BCurrentXOver(TraceSub(TWinner)) + 1
            BXOSize = UBound(BestXOList, 2)
            If BCurrentXOver(TraceSub(TWinner)) > BXOSize Then
                BXOSize = BCurrentXOver(TraceSub(TWinner)) + 10
                UB = UBound(BestXOList, 1)
                ReDim Preserve BestXOList(UB, BXOSize)
            End If
            WinnerPos(WinPPY, x) = BCurrentXOver(TraceSub(TWinner))
            BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))) = CollectEvents(WinPPY, x)
            If MinP > BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Probability Then
                MinP = BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Probability
            End If
            
            BestXOList(TraceSub(TWinner), BCurrentXOver(TraceSub(TWinner))).Eventnumber = Eventnumber + EventAdd
            If UBound(SuperEventList, 1) < Eventnumber + EventAdd Then
                ReDim Preserve SuperEventList(Eventnumber + EventAdd)
                SuperEventList(Eventnumber + EventAdd) = SEventNumber
            End If
                    'if ExtraHits(TraceSub(Rlist(WinPP, WinPPY)), SEventNumber)
        End If
    Next x
    GoOn = 0
    If BusyWithExcludes = 1 Then
        If TWinner > PermNextno Then 'means it is an actual exclude
        
            ExcludedEventNum = ExcludedEventNum + 1
            ExcludedEventBPNum = ExcludedEventBPNum + 1
            If ExcludedEventNum < ExcludedEventNumThresh Then
                If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
                    ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
                End If
            Else
                
                Dim NF3 As Long
                NF3 = FreeFile
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                NumExcludedEventNum = NumExcludedEventNum + 1
                Put #NF3, 1, ExcludedEventNum
                Put #NF3, , EventsInExcludeds
                Close #NF3
                ReDim EventsInExcludeds(5, 1000)
                ExcludedEventNum = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            EventsInExcludeds(0, ExcludedEventNum) = Par 'should be the discard number but here it indicates which parent it is (1=major, 2= minor)
            EventsInExcludeds(1, ExcludedEventNum) = -SEventNumber
            EventsInExcludeds(2, ExcludedEventNum) = TWinner 'should be the position of this sequence in the excludes file
            EventsInExcludeds(3, ExcludedEventNum) = CurSeedExtras 'sequence this exclude is most similar to
            EventsInExcludeds(4, ExcludedEventNum) = OSNPos(TWinner)
            
            If (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 4
            ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 2
            ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                EventsInExcludeds(5, ExcludedEventNum) = 3
            Else
                EventsInExcludeds(5, ExcludedEventNum) = 1
            End If
            GoOn = 1
        End If
    End If
    If oEventAdd = EventAdd Then 'And (BusyWithExcludes = 0 Or ConservativeGroup = 1) Then
        If BusyWithExcludes = 0 Or GoOn = 0 Then
            If WinPPY < RNum(WinPP) Then
                RList(WinPP, WinPPY) = RList(WinPP, RNum(WinPP))
                For x = 0 To AddNum
                    CollectEvents(WinPPY, x) = CollectEvents(RNum(WinPP), x)
                Next x
                
            End If
            RNum(WinPP) = RNum(WinPP) - 1
        Else
            WinPPY = WinPPY + 1
        End If
    Else
        If BusyWithExcludes = 0 Or TWinner <= PermNextno Then
            If MinP > LowestProb Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY))) = 5
            ElseIf (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY))) = 4
            ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY))) = 2
            ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
                ExtraHits(TraceSub(RList(WinPP, WinPPY))) = 3
            Else
                ExtraHits(TraceSub(RList(WinPP, WinPPY))) = 1
            End If
        End If

        WinPPY = WinPPY + 1
    End If
    
Loop

'For X = 0 To Nextno
'    For Y = 1 To BCurrentXOver(X)
'        If BestXOList(X, Y).Daughter = BestXOList(X, Y).MajorP Or BestXOList(X, Y).Daughter = BestXOList(X, Y).MinorP Then
'            X = X
'        End If
'    Next Y
'Next X
End Sub
Public Sub DropRedolist()
    Dim FF As Long, oDirX As String, Iter As Long
    FF = FreeFile
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    XX = RedoListSize
    Iter = 0
    Do While Iter < 100
        If Dir("RDP5Redolist" + Str(Iter) + UFTag) = "" Then
            Open "RDP5Redolist" + Str(Iter) + UFTag For Binary As #FF
            Put #FF, , UBound(RedoList, 2)
            Put #FF, , RedoList()
            Close #FF
            Exit Do
        Else
            Iter = Iter + 1
        End If
        
    Loop
    ReDim RedoList(3, 10)
    RedoListSize = 0
    ChDrive oDirX
    ChDir oDirX
End Sub
Public Sub SetupGlobals()
    Dim x As Long, Y As Long
  
    
    'Work out distances between sequences
    oDMax = 1
    If DistanceFlag = 0 Then  'If distancematrix not yet calculated and if a "spacer" is required
        Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
    End If
     
    If XOverWindowX <> CDbl(Form1.Text5.Text) And Form1.Text5.Text <> "" Then XOverWindowX = CDbl(Form1.Text5.Text)
    IndividualA = -1: IndividualB = -1
    
    If RedoListSize > 0 Then
        Call DropRedolist
        RedoListSize = 0
    End If
    
    ReDim RedoList(3, 10)
    ReDim FMat(NextNo, NextNo)
    ReDim SMat(NextNo, NextNo)
    ReDim SubValid(NextNo, NextNo)
    ReDim SubDiffs(NextNo, NextNo)
    
   
    
    RedoListSize = 0
    ExcludedEventNum = 0
    ExcludedEventBPNum = 0
    PN = 0
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then PN = PN + 1
    Next x
    'If DoScans(0, 9) = 1 Then PN = PN + 1
    ReDim MaxXOP(AddNum - 1, NextNo), RecombNo(AddNum), ShowAllHits(NextNo), MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2), CritPVals(AddNum - 1)
    Call ResetMaxPVCO(NextNo)
    ReDim oRecombNo(100)
    
    XoverWindow = Int(XOverWindowX / 2)
    LenStrainSeq = Len(StrainSeq(0)) + 1
    TargetX = CLng(0.1 * Len(StrainSeq(0)))
    
    'Store variable states at start of analysis
    pMCTripletFlag = MCTripletFlag
    pMCProportionFlag = MCProportionFlag
    pMCStart = MCStart
    pMCEnd = MCEnd
    pMCMaxP = MCMaxP
    pMCSteplen = MCSteplen
    pMCWinSize = MCWinSize
    pMCWinFract = MCWinFract
    pMCStripGapsFlag = MCStripGapsFlag
    pMCFlag = MCFlag
    pXOverWindowX = XOverWindowX
    pCircularFlag = CircularFlag
    pSpacerFlag = SpacerFlag
    If LowestProb = 0 Then LowestProb = 0.05
    pLowestProb = LowestProb
    pBSTypeFlag = BSTypeFlag
    pBSStepSize = BSStepSize
    pBSStepWin = BSStepWin
    pBSBootReps = BSBootReps
    For x = 0 To AddNum - 1
        pDoScans(0, x) = DoScans(0, x)
    Next x
    
    pBSCutoff = BSCutOff
    pBSPValFlag = BSPValFlag
    pSSGapFlag = SSGapFlag
    pSSVarPFlag = SSVarPFlag
    pSSOutlyerFlag = SSOutlyerFlag
    pSSRndSeed = SSRndSeed
    pSSWinLen = SSWinLen
    pSSStep = SSStep
    pSSNumPerms = SSNumPerms
    pSSNumPerms2 = SSNumPerms2
    pGCTripletflag = GCtripletflag
    pPPStripGaps = PPStripGaps
        
    pGCMissmatchPen = GCMissmatchPen
    pGCIndelFlag = GCIndelFlag
    pGCMinFragLen = GCMinFragLen
    pGCMinPolyInFrag = GCMinPolyInFrag
    pGCMinPairScore = GCMinPairScore
    pGCMaxOverlapFrags = GCMaxOverlapFrags
        
    pCWinFract = CWinFract
    pCProportionFlag = CProportionFlag
    pCWinSize = CWinSize
        
    ReDim pMaskSeq(NextNo)
    For x = 0 To NextNo
        pMaskSeq(x) = MaskSeq(x)
    Next 'X
    
    ExeCheckFlag = 0
    NoMCFlag = 0
    LongWindedFlag = 1
    SEventNumber = 0
    GCMCCheckFlag = 0
    RelX = 0
    RelY = 0
    ScanFlagX = 1
    oRecombNo(100) = 0
    RunFlag = 1
    If TreeTypeFlag <> 3 Then
        TreeTypeFlag = 2
        CTF = 0
    End If
    MaxHits = 10
    SaveFlag = 0
    If LowestProb = 0 Then LowestProb = 0.05
    pLowestProb = LowestProb
    'PermNextNo = NextNo
    
    ReDim PValCat(AddNum, 100), MaxPValCat(AddNum, 100), MissingData(Len(StrainSeq(0)), NextNo)
    
    
    For x = 0 To AddNum - 1
        For Y = 0 To NextNo
            DonePVCO(x, Y) = -1
        Next Y
    Next x
    
    
    
End Sub
Public Sub SetupGlobals2()
    Dim x As Long
    ReDim FMat(NextNo, NextNo), SMat(NextNo, NextNo), SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo)
    
    
    If RedoListSize > 0 Then
        Call DropRedolist
        
    End If
    ReDim RedoList(3, 10)
    RedoListSize = 0
    
    
            
    PN = 0
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then PN = PN + 1
        
    Next x
    ReDim MaxXOP(AddNum - 1, NextNo), RecombNo(AddNum), ShowAllHits(NextNo), MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2), CritPVals(AddNum - 1)
    Call ResetMaxPVCO(NextNo)
    ReDim Preserve oRecombNo(100)
    
    XoverWindow = Int(XOverWindowX / 2)
    LenStrainSeq = Len(StrainSeq(0)) + 1
    TargetX = CLng(0.1 * Len(StrainSeq(0)))
    
    'ReStore variable states at start of analysis
    MCTripletFlag = pMCTripletFlag
    MCProportionFlag = pMCProportionFlag
    MCStart = pMCStart
    MCEnd = pMCEnd
    MCMaxP = pMCMaxP
    MCSteplen = pMCSteplen
    MCWinSize = pMCWinSize
    MCWinFract = pMCWinFract
    MCStripGapsFlag = pMCStripGapsFlag
    MCFlag = pMCFlag
    XOverWindowX = pXOverWindowX
    CircularFlag = pCircularFlag
    SpacerFlag = pSpacerFlag
    LowestProb = pLowestProb
    BSTypeFlag = pBSTypeFlag
    BSStepSize = pBSStepSize
    BSStepWin = pBSStepWin
    BSBootReps = pBSBootReps
     For x = 0 To AddNum - 1
        pDoScans(0, x) = DoScans(0, x)
    Next x
    BSCutOff = pBSCutoff
    BSPValFlag = pBSPValFlag
    SSGapFlag = pSSGapFlag
    SSVarPFlag = pSSVarPFlag
    SSOutlyerFlag = pSSOutlyerFlag
    SSRndSeed = pSSRndSeed
    SSWinLen = pSSWinLen
    SSStep = pSSStep
    SSNumPerms = pSSNumPerms
    SSNumPerms2 = pSSNumPerms2
    GCtripletflag = pGCTripletflag
    PPStripGaps = pPPStripGaps
    'If GCtripletflag = 1 Then
        
        GCMissmatchPen = pGCMissmatchPen
        GCIndelFlag = pGCIndelFlag
        GCMinFragLen = pGCMinFragLen
        GCMinPolyInFrag = pGCMinPolyInFrag
        GCMinPairScore = pGCMinPairScore
        GCMaxOverlapFrags = pGCMaxOverlapFrags
        
    CWinFract = pCWinFract
        CProportionFlag = pCProportionFlag
        CWinSize = pCWinSize
End Sub
Public Sub BuildFirstXOList(SPY, SPX As Byte, AgeScore() As Single, EventScore() As Long, MinSeqSize As Long, JumpFlag As Byte, MissingData() As Byte, TraceSub() As Long, NextNo As Long, StepNo As Long, Steps() As Long, ExtraHits() As Byte, ExtraHitsMa() As Byte, ExtraHitsMi() As Byte, NOPINI() As Long, Eventnumber As Long, SEventNumber As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer, XoverList() As XOverDefine, CurrentXOver() As Integer, XOverListMi() As XOverDefine, CurrentXOverMi() As Integer, XOverListMa() As XOverDefine, CurrentXOverMa() As Integer, Daught() As Byte, MinorPar() As Byte, MajorPar() As Byte)

Dim oDirX As String, LSeq As Long, OP As Long, LmB As Long, BeginningX As Long, EndingX As Long, TAgeEvent() As Double, tDscores() As Double, ENumb As Long, tNextno As Long, BB As Long, BE As Long, BestP() As Double, BestT() As Long, tNopini() As Byte, DEN As Long, MiEN As Long, MaEN As Long, EN As Long, TSEList() As Long, tENumb As Long, TraceNumbD As Long, TraceNumbMi As Long, TraceNumbMa As Long, x As Long, Y As Long, TraceD() As Long, TraceMi() As Long, TraceMa() As Long
Dim AP() As Byte, TXOLMa() As XOverDefine, TXOLMi() As XOverDefine, CurXOMa() As Integer, CurXOMi() As Integer
Dim WinPPY As Long, WinNum As Long, MinOverlap As Long, oSE As Long, b As Long
Dim WinPP As Long, UB As Long, A As Long, Z As Long, CurAge As Double, Curscore As Long, DoPairs() As Byte, oDir As String, FF As Long
Dim NumInList As Long, GoOn As Long, dX As Long, MiX As Long, Max As Long, oCap As String, XXX As Variant, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
ReDim TXOLMa(NextNo, 10), TXOLMa(NextNo, 10), BestXOList(NextNo, 10), BCurrentXOver(NextNo, 10)
ReDim CurXOMa(NextNo), CurXOMi(NextNo)
EN = 1

ReDim tDscores(25, 2, SEventNumber), TAgeEvent(1, SEventNumber)
oSE = SEventNumber
If SEventNumber = 0 Then ReDim SuperEventList(0)



SEventNumber = 0
ReDim TSEList(100)
ReDim AP(AddNum * 2), ExtraHits(NextNo, 1), ExtraHitsMa(NextNo, 1), ExtraHitsMi(NextNo, 1)
ReDim CurXOMi(NextNo), TXOLMi(NextNo, 10), CurXOMa(NextNo), TXOLMa(NextNo, 10), BestXOList(NextNo, 10), BCurrentXOver(NextNo)

Dim tSteps() As Long, tStepno As Long
ReDim tSteps(UBound(Steps, 1), UBound(Steps, 2))
For x = 0 To UBound(Steps, 1)
    For Y = 0 To UBound(Steps, 2)
        tSteps(x, Y) = Steps(x, Y)
    Next Y
Next x
tStepno = StepNo

ReDim Steps(4, 100)
StepNo = 0
'ReDim DoPairs(PermNextno, PermNextno)
'For X = 0 To Nextno
'    For Y = 1 To CurrentXOver(X)
'        'XOverlist(X, Y).DHolder = Abs(XOverlist(X, Y).DHolder)
'         Dx = XOverlist(X, Y).Daughter
'         MiX = XOverlist(X, Y).MinorP
'         MaX = XOverlist(X, Y).MajorP
'         DoPairs(Dx, MiX) = 1
'         DoPairs(MiX, Dx) = 1
'         DoPairs(Dx, MaX) = 1
'         DoPairs(MaX, Dx) = 1
'         DoPairs(MiX, MaX) = 1
'         DoPairs(MaX, MiX) = 1
'    Next Y
'Next X

DoneTree(0, 3) = 0
TreeImage(3) = 0
DoneTree(1, 3) = 0
DoneTree(2, 3) = 0
DoneTree(3, 3) = 0
DoneTree(4, 3) = 0
If DebuggingFlag < 2 Then On Error Resume Next
Form2.SSPanel1(2).ZOrder
On Error GoTo 0
CurTree(3) = 0

Call UnModNextno




NumberOfSeqs = 0
If UBound(MaskSeq, 1) < PermNextno Then
    ReDim Preserve MaskSeq(PermNextno)
End If
For x = 0 To PermNextno
    
    If MaskSeq(x) < 1 Then
        
        NumberOfSeqs = NumberOfSeqs + 1
    End If
Next 'X
NumberOfSeqs = NumberOfSeqs - 1

Call MakeMCCorrection(PermNextno, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
'XX = MCCorrection
x = x
Dim TotE() As Long
ReDim TotE(30, oSE)

ReDim oRecombNo(100), RecombNo(100)
If AllowConflict = 0 Then
    ReDim AgeScore(Len(StrainSeq(0)), PermNextno), EventScore(Len(StrainSeq(0)), PermNextno)
    
    For x = 0 To NextNo
        For Y = 0 To Len(StrainSeq(0))
            AgeScore(Y, x) = -1
        Next Y
    Next x
End If
If UBound(CurrentXOver, 1) < PermNextno Then
    ReDim Preserve CurrentXOver(PermNextno)
End If
For x = 0 To PermNextno
    For Y = 1 To CurrentXOver(x)
        If XoverList(x, Y).Probability < LowestProb And XoverList(x, Y).Probability > 0 And (XoverList(x, Y).Accept = 1 Or XoverList(x, Y).Accept = 3) Then
            If XoverList(x, Y).ProgramFlag < AddNum Then
                TotE(XoverList(x, Y).ProgramFlag, SuperEventList(XoverList(x, Y).Eventnumber)) = TotE(XoverList(x, Y).ProgramFlag, SuperEventList(XoverList(x, Y).Eventnumber)) + 1
            Else
                TotE(XoverList(x, Y).ProgramFlag - AddNum, SuperEventList(XoverList(x, Y).Eventnumber)) = TotE(XoverList(x, Y).ProgramFlag - AddNum, SuperEventList(XoverList(x, Y).Eventnumber)) + 1
            End If
        End If
    Next Y
Next x




For x = 0 To AddNum - 1
    TotUSignals(x) = 0
    TotSignals(x) = 0
Next x
For x = 0 To AddNum - 1
    For Y = 1 To oSE
        If TotE(x, Y) > 0 Then
            TotUSignals(x) = TotUSignals(x) + 1
            TotSignals(x) = TotSignals(x) + TotE(x, Y)
        End If
    Next Y
    oRecombNo(x) = TotSignals(x)
    RecombNo(x) = TotUSignals(x)
Next x



Call SetUpScanArrays(0)
'XX = DoScans(0, 0)
If DoScans(0, 5) = 1 Then
    Dim OnlySiScan As Byte
    If DoScans(0, 0) = 0 And DoScans(0, 1) = 0 And DoScans(0, 2) = 0 And DoScans(0, 3) = 0 And DoScans(0, 4) = 0 Then
        OnlySiScan = 1
    Else
        OnlySiScan = 0
    End If
    CurrentCorrect = 5
    Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte
    
    'Dimension horizontal randomisation array if necessary
    If SSOutlyerFlag = 0 Or SSOutlyerFlag = 1 Or x = x Then 'new
        ReDim HRandTemplate(SSWinLen)
        ReDim TakenPos(SSWinLen)
    End If
    ReDim VRandTemplate(0, 0)
    GlobalMemoryStatus MemSit
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    LmB = Len(StrainSeq(0))
    LmB = LmB * SSNumPerms
    LmB = LmB * 12
    
    If APhys < LmB Then
        OP = SSNumPerms
        SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
        pSSNumPerms = SSNumPerms
        If SSNumPerms < 100 Then
            If CLine = "" Or CLine = " " Then
                MsgBox ("There is not enough free memory available to perform a SiScans in either exploratory or checking modes - Both modes will, therefore, be disabled.  Perhaps if you close some programs the situation will improve.")
            End If
            DoScans(0, 5) = 0
            DoScans(1, 5) = 0
        Else
            If CLine = "" Or CLine = " " Then
                MsgBox ("You have specified that you would like to do a Sisscan with " + Trim(Str(OP)) + " permutations. There is, however, only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations.")
            End If
        End If
    End If
    'Dimension vertical randomisation array
    ReDim VRandTemplate(Len(StrainSeq(0)), SSNumPerms)
    'XX = SEventNumber
    Dim DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte
    ReDim DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)
    
    Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
    Rnd (-BSRndNumSeed)
    LSeq = Len(StrainSeq(0))
    WinNum = CLng(LSeq / SSStep + 1)
    TotalSSRecombinants = 0
    
    'Make sure it will still run even in the event of a user messup
    If SSNumPerms2 = 0 Then
        SSNumPerms2 = 10
    End If
    
    Dim CorrectP As Double, oSeq As Long, PermSScores() As Long, PScoreHolder() As Long, SScoreHolder() As Long, PermPScores() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double
    ReDim SeqScore3(Len(StrainSeq(0))), MeanPScore(15), SDPScore(15)
    ReDim PermSScores(SSNumPerms, 15), PermPScores(SSNumPerms, 15), SScoreHolder(WinNum, 14), PScoreHolder(WinNum, 15)
    
    Dim SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double
    ReDim SeqMap(Len(StrainSeq(0)))
    ReDim ZPScoreHolder(WinNum, 15)
    ReDim ZSScoreHolder(WinNum, 14)
    If SSOutlyerFlag = 2 Then
        Call GetOutie
        oSeq = Outie
    End If
    If MCFlag = 0 Then
        CorrectP = LowestProb / MCCorrection
    Else
        CorrectP = LowestProb
    End If
End If

StepNo = 0

tNextno = NextNo
MinOverlap = 0

If DoScans(0, 0) = 1 Then
    AP(0) = 1
    If Int(XOverWindowX / 2) > MinOverlap Then MinOverlap = Int(XOverWindowX / 2)
End If
If DoScans(0, 1) = 1 Then
    AP(1) = 1
    MinOverlap = 5
End If
If DoScans(0, 2) = 1 Then
    If BSStepWin > MinOverlap Then MinOverlap = BSStepWin
    AP(2) = 1
End If
If DoScans(0, 3) = 1 Then
    If MCProportionFlag = 0 Then
        If CriticalDiff * 2 > MinOverlap Then MinOverlap = CriticalDiff * 2
    
    End If
    AP(3) = 1
End If
If DoScans(0, 4) = 1 Then
    If CProportionFlag = 0 Then
        If CriticalDiff * 2 > MinOverlap Then MinOverlap = CriticalDiff * 2
    
    End If
    AP(4) = 1
End If
If DoScans(0, 5) = 1 Then
    AP(5) = 1
    If SSWinLen > MinOverlap Then MinOverlap = SSWinLen
End If
If DoScans(0, 6) = 1 Then
    AP(6) = 1
    If MinOverlap < 100 Then MinOverlap = 100
End If
If DoScans(0, 7) = 1 Then
    AP(7) = 1
     If MinOverlap < 100 Then MinOverlap = 100
End If
If DoScans(0, 8) = 1 Then
    AP(8) = 1
    If MinOverlap < 10 Then MinOverlap = 10
End If

Dim Trace(1) As Long, LowP As Double

LowP = 1



For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        XoverList(x, Y).DHolder = Abs(XoverList(x, Y).DHolder)
'         Dx = XOverlist(X, Y).Daughter
'         MiX = XOverlist(X, Y).MinorP
'         MaX = XOverlist(X, Y).MajorP
'         DoPairs(Dx, MiX) = 1
'         DoPairs(MiX, Dx) = 1
'         DoPairs(Dx, MaX) = 1
'         DoPairs(MaX, Dx) = 1
'         DoPairs(MiX, MaX) = 1
'         DoPairs(MaX, MiX) = 1
    Next Y
Next x
Dim RDF As Byte, oLowPX As Long
RDF = 0

Dim tYannWarn() As Byte
ReDim tYannWarn(UBound(YannWarn, 1))

Form1.SSPanel1.Caption = "Decomposing accepted recombinant sequences into their constituent parts"
Form1.Refresh
Dim tEventsInExcludeds() As Long, tExcludedEventNum As Long, tExcludedEventBPNum As Long
ReDim tEventsInExcludeds(UBound(EventsInExcludeds, 1), UBound(EventsInExcludeds, 2))
ReDim tEventsInExcludedsBP(UBound(EventsInExcludedsBP, 1), UBound(EventsInExcludedsBP, 2))
tExcludedEventNum = 0
tExcludedEventBPNum = 0
'ExcludedEventBPNum = ExcludedEventBPNum + 1
Do While LowP < 1000000000
    LowP = 1000000000
    For x = 0 To PermNextno
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).BeginP >= 0 Then 'first do all the events that do not directly involve teh excludelist
                If ((XoverList(x, Y).Accept = 1 Or XoverList(x, Y).Accept = 3) Or SuperEventList(XoverList(x, Y).Eventnumber) < SPX) And XoverList(x, Y).Probability > -1 Then
                      If SuperEventList(XoverList(x, Y).Eventnumber) < LowP And SuperEventList(XoverList(x, Y).Eventnumber) > oLowPX And SuperEventList(XoverList(x, Y).Eventnumber) > 0 Then
                        LowP = SuperEventList(XoverList(x, Y).Eventnumber)
                        Trace(0) = x
                        Trace(1) = Y
                      End If
                End If
                If XoverList(x, Y).Accept = 3 Then
                    RDF = 1
                End If
            End If
        Next Y
    Next x
    If LowP = 1000000000 Then 'if no more events found then look for events that directly involve the excludelist
        oLowPX = 0
        For x = 0 To PermNextno
'
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).BeginP < 0 Then 'i.e. this event directly involves sequences in the excludelist
                    If ((XoverList(x, Y).Accept = 1 Or XoverList(x, Y).Accept = 3) Or SuperEventList(XoverList(x, Y).Eventnumber) < SPX) And XoverList(x, Y).Probability > -1 Then
                          If SuperEventList(XoverList(x, Y).Eventnumber) < LowP And SuperEventList(XoverList(x, Y).Eventnumber) > oLowPX And SuperEventList(XoverList(x, Y).Eventnumber) > 0 Then
                            LowP = SuperEventList(XoverList(x, Y).Eventnumber)
                            Trace(0) = x
                            Trace(1) = Y
                          End If
                    End If
                    If XoverList(x, Y).Accept = 3 Then
                        RDF = 1
                    End If
                End If
            Next Y
        Next x
    
    End If
    If LowP < 1000000000 Then
        If LowP = oLowPX Then
            
            'SEventNumber = SEventNumber - 1
            Exit Do
        End If
        oLowPX = LowP
        If XoverList(BestEvent(LowP, 0), BestEvent(LowP, 1)).DHolder > 0 Then
            XoverList(BestEvent(LowP, 0), BestEvent(LowP, 1)).DHolder = XoverList(BestEvent(LowP, 0), BestEvent(LowP, 1)).DHolder * -1
        Else
            XoverList(BestEvent(LowP, 0), BestEvent(LowP, 1)).DHolder = -0.00001
        End If
        x = Trace(0)
        Y = Trace(1)
        JumpFlag = 1
        SEventNumber = SEventNumber + 1
        
        
        ReDim Preserve tNopini(2, SEventNumber)
        ReDim Preserve ExtraHits(NextNo, SEventNumber), ExtraHitsMa(NextNo, SEventNumber), ExtraHitsMi(NextNo, SEventNumber)
        ENumb = SuperEventList(XoverList(x, Y).Eventnumber)
        
        
        
        
        
        'transfer over the confidence interval information
        For Z = 0 To 9
            BPCIs(Z, SEventNumber) = BPCIs(Z, ENumb)
        
        Next Z
        
        'transfer information into extrahits that will be needed to make minorpar and majorpar lists after the dordp scan is completed
        For Z = 0 To PermNextno
            
            ExtraHitsMi(Z, SEventNumber) = MinorPar(ENumb, Z)
            ExtraHitsMa(Z, SEventNumber) = MajorPar(ENumb, Z)
                
        Next Z
        
        'transfer information on tests to determine which sequence was the recombinant (the etsts used to make teh graphs at the bottom of recombination info display)
        For Z = 0 To 25
            For A = 0 To 2
                If UBound(tDscores, 3) <= SEventNumber Then
                    ReDim Preserve tDscores(25, 2, SEventNumber + 100)
                End If
                tDscores(Z, A, SEventNumber) = DScores(Z, A, ENumb)
            Next A
        Next Z
        
        'transfer over info on the phitests and homoplay styled rdp and maxchi tests that are used to make warnings in recombination info and tree displays
        tYannWarn(SEventNumber) = YannWarn(ENumb)
        If DebuggingFlag < 2 Then On Error Resume Next
        
        'transfer info on the treetests (SH etc at bottom of the tree display)
        If SEventNumber > UBound(TreeTestStats, 2) Then
            ReDim Preserve TreeTestStats(3, SEventNumber)
        End If
        If ENumb > UBound(TreeTestStats, 2) Then
            ReDim Preserve TreeTestStats(3, ENumb)
        End If
        
        On Error GoTo 0
        For Z = 0 To 3
            TreeTestStats(Z, SEventNumber) = TreeTestStats(Z, ENumb)
        Next Z
        
        If UBound(TAgeEvent, 2) < SEventNumber Then
            ReDim Preserve TAgeEvent(1, SEventNumber + 100)
        End If
        
        'This agevent stuff is not used but might get reactivated later
        ReDim Preserve AgeEvent(1, oSE)
        TAgeEvent(0, SEventNumber) = AgeEvent(0, ENumb)
        TAgeEvent(1, SEventNumber) = AgeEvent(1, ENumb)
        UB = UBound(TSEList, 1)
        If SEventNumber > UB Then
            ReDim Preserve TSEList(UB + 10)
        End If
            
        ReDim TraceD(1, 10), TraceMa(1, 10), TraceMi(1, 10)
            
        
        If RDF = 1 Then
            If SEventNumber > UBound(RepeatCycles, 1) Then
                ReDim Preserve RepeatCycles(SEventNumber)
            End If
            
            If SEventNumber <= UBound(RepeatCycles, 1) And ENumb <= UBound(RepeatCycles, 1) Then
            
                RepeatCycles(SEventNumber) = RepeatCycles(ENumb)
            
            End If
            
        End If
        'trace the stuff used to work out the relationships between recombinant and the other two sequences used to infer the recombination event
        tNopini(0, SEventNumber) = NOPINI(0, ENumb)
        tNopini(1, SEventNumber) = NOPINI(1, ENumb)
        tNopini(2, SEventNumber) = NOPINI(2, ENumb)
            
        Dim InvolvedR As Byte
        InvolvedR = 0
        If XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).BeginP < 0 Then
            InvolvedR = 1
        End If
            
        Call FindSameE(InvolvedR, 1, TraceNumbD, ENumb, XoverList(), CurrentXOver(), TraceD(), Daught())
        For Z = 0 To TraceNumbD
            If Daught(ENumb, TraceD(0, Z)) = 0 Then
                
                Daught(ENumb, TraceD(0, Z)) = 2
            End If
            ExtraHits(TraceD(0, Z), SEventNumber) = Daught(ENumb, TraceD(0, Z))
        Next Z
        
        Call FindSameE(InvolvedR, 0, TraceNumbMi, ENumb, XOverListMi(), CurrentXOverMi(), TraceMi(), MinorPar())
        Call FindSameE(InvolvedR, 0, TraceNumbMa, ENumb, XOverListMa(), CurrentXOverMa(), TraceMa(), MajorPar())
            
       
        
            
        DEN = EN
        ReDim BestT(1, NextNo)
        ReDim BestP(NextNo)
        For Z = 0 To NextNo
            BestP(Z) = 1000000
        Next Z
        
        
        For Z = 0 To TraceNumbD
            
            XoverList(TraceD(0, Z), TraceD(1, Z)).Eventnumber = DEN
            
            If DEN > UBound(TSEList, 1) Then
                ReDim Preserve TSEList(DEN + 10)
            End If
            TSEList(DEN) = SEventNumber
           
            If XoverList(TraceD(0, Z), TraceD(1, Z)).Probability < BestP(TraceD(0, Z)) Then
                If AP(XoverList(TraceD(0, Z), TraceD(1, Z)).ProgramFlag) = 1 Then
                    BestP(TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Probability
                    BestT(0, TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Beginning
                    BestT(1, TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Ending
                End If
            End If
            DEN = DEN + 1
        Next Z
        
        For Z = 0 To TraceNumbD
            If XoverList(TraceD(0, Z), TraceD(1, Z)).Probability > 0 Then
                 
                 
                 If BestP(TraceD(0, Z)) = 1000000 Then
                     'If AP(XOverList(TraceD(0, Z), TraceD(1, Z)).ProgramFlag) = 0 Then
                         BestP(TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Probability
                         BestT(0, TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Beginning
                         BestT(1, TraceD(0, Z)) = XoverList(TraceD(0, Z), TraceD(1, Z)).Ending
                     'End If
                 End If
                 
            End If
        Next Z
        'XX = SuperEventlist(XOverList(80, 1).Eventnumber)
        Dim BP As Double
        BP = 100
        For Z = 0 To NextNo
            If BestP(Z) < BP Then
                BP = BestP(Z)
            End If
        Next Z
        
        BB = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Beginning
        BE = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Ending
        
        
        Dim IncX As Long
        
        GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwTotalPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        If Len(StrainSeq(0)) * (tNextno + 30) * 16 > APhys Then
            IncX = 3
        Else
            IncX = 30
        End If
        
        
        ReDim Preserve GrpMaskSeq(tNextno + IncX), MaskSeq(tNextno + IncX), OriginalName(tNextno + IncX), NumRecsI(tNextno + IncX), SubMaskSeq(tNextno + IncX), MissingData(Len(StrainSeq(0)), tNextno + IncX), SeqNum(Len(StrainSeq(0)), tNextno + IncX), TraceSub(tNextno + IncX)
        
        
        
        'if there are events in the excludedeventlist then the seventnumbers referenced in these lists need to be updated to the new seventnumber
        'Also, if some of the involved sequences are excludes we need to add steps so that they will be added to seqnum by modseqnum
        Dim j As Long, BstB As Long, BstE As Long, DoneD() As Long, DealtWithExcludes As Byte
        ReDim DoneD(NextnoBak)
        DealtWithExcludes = 0
        If ExcludedEventNum > 0 Then
            If NumExcludedEventNum > 0 Then
                'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                NF3 = FreeFile
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                Put #NF3, 1, ExcludedEventNum
                Put #NF3, , EventsInExcludeds
                Close #NF3
                ReDim EventsInExcludeds(5, 1000)
                'ExcludedEventNum = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            For j = 0 To NumExcludedEventNum
                If NumExcludedEventNum > 0 Then
                    NF3 = FreeFile
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                    Get #NF3, , ExcludedEventNum
                    ReDim EventsInExcludeds(5, ExcludedEventNum)
                    Get #NF3, , EventsInExcludeds
                    Close #NF3
                    'ExcludedEventNum = 1
                    ChDrive oDirX
                    ChDir oDirX
                End If
                For x = 0 To UBound(EventsInExcludeds, 2)
                   If Abs(EventsInExcludeds(1, x)) = ENumb Then
                        tExcludedEventNum = tExcludedEventNum + 1
                        tExcludedEventBPNum = tExcludedEventBPNum + 1
                        For Z = 0 To UBound(EventsInExcludeds, 1)
                            tEventsInExcludeds(Z, tExcludedEventNum) = EventsInExcludeds(Z, x)
                            
                        Next Z
                        For Z = 0 To UBound(EventsInExcludedsBP, 1)
                            tEventsInExcludedsBP(Z, tExcludedEventBPNum) = EventsInExcludedsBP(Z, x)
                            
                        Next Z
                        'update the seventnumber reference
                        If EventsInExcludeds(1, x) < 0 Then
                            DealtWithExcludes = 1
                            tEventsInExcludeds(1, tExcludedEventNum) = -SEventNumber
                            If x = x Then 'DoneD(EventsInExcludeds(3, x)) = 0 Then
                                'need to add some steps here
                                'DoneD(EventsInExcludeds(2, x)) = 1
                                For Z = 0 To tStepno
                                    If Abs(tSteps(4, Z)) = ENumb + 1 Then
                                        Exit For
                                    End If
                                    
                                Next Z
                                Z = Z - 1
                                'find the first tsteps(0,x) =6 preceeding this event
                                For g = Z To 0 Step -1
                                    If tSteps(0, g) = 6 Then
                                        Exit For
                                    End If
                                
                                Next g
                                x = x
    '                            'find the first tsteps(0,x) =6 following this event
    '                            For AA = Z To tStepno
    '                                If tSteps(0, AA) = 6 Then
    '                                    Exit For
    '                                End If
    '                            Next AA
    '                                    'now step backwards and find the first tsteps(o,z) that has a minus value - this will be the last of the
    '                                    'sequences added in addsomeextras
    '                            For Z = AA - 1 To G Step -1
    '                                If tSteps(2, Z) < 0 Then
    '                                    Exit For
    '                                End If
    '                            Next Z
                                For AA = g To Z
                                    For BB = 0 To UBound(Steps, 1)
                                        Steps(BB, StepNo) = tSteps(BB, AA)
                                    Next BB
                                    'SEventNumber 1
                                    Steps(4, StepNo) = SEventNumber
                                    StepNo = StepNo + 1
                                    UB = UBound(Steps, 2)
                                    If StepNo > UB Then
                                        ReDim Preserve Steps(4, UB + 100)
                                    End If
                                Next AA
                                Steps(0, StepNo) = 7 'this can be used in modseqnum to reset seqnum and missingdata to state it was in before this event was handled
                                Steps(4, StepNo) = SEventNumber + 1
                                
                                StepNo = StepNo + 1
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            End If
                            
                        Else
                            tEventsInExcludeds(1, tExcludedEventNum) = SEventNumber
                        End If
                   End If
                Next x
            Next j
            
            
            
        End If
        
        
        If DealtWithExcludes = 0 Then 'only bother with this if we're not dealing with excludeds
            Dim SSize As Long
            For Z = 0 To tNextno
                If Daught(ENumb, TraceSub(Z)) > 0 And TraceSub(Z) <= PermNextno Then
                    If BestP(TraceSub(Z)) < 100 Then
                        BeginningX = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Beginning 'BestT(0, TraceSub(Z))
                        EndingX = XoverList(BestEvent(ENumb, 0), BestEvent(ENumb, 1)).Ending 'BestT(1, TraceSub(Z))
                        SSize = 0
                        If BeginningX < EndingX Then
                            For A = BeginningX To EndingX
                                If SeqNum(A, Z) <> 46 Then
                                    SSize = SSize + 1
                                End If
                            Next A
                        Else
                           For A = BeginningX To Len(StrainSeq(0))
                                If SeqNum(A, Z) <> 46 Then
                                    SSize = SSize + 1
                                End If
                            Next A
                            For A = 1 To EndingX
                                If SeqNum(A, Z) <> 46 Then
                                    SSize = SSize + 1
                                End If
                            Next A
                        End If
                        If SSize >= MinSeqSize And (ReassortmentFlag = 0 Or tNextno < 3500) Then
                        
                            Steps(0, StepNo) = 1 'ie create a new sequence ....
                            Steps(1, StepNo) = Z 'using this seqence.....
                            Steps(2, StepNo) = BeginningX 'from this position....
                            Steps(3, StepNo) = EndingX 'to this position....
                            Steps(4, StepNo) = SEventNumber + 1
                            StepNo = StepNo + 1
                            
                            UB = UBound(Steps, 2)
                            If StepNo > UB Then
                                ReDim Preserve Steps(4, UB + 100)
                            End If
                            tNextno = tNextno + 1
                            If tNextno > UBound(MaskSeq, 1) Then
                                ReDim Preserve GrpMaskSeq(tNextno + IncX), MaskSeq(tNextno + IncX), OriginalName(tNextno + IncX), NumRecsI(tNextno + IncX), SubMaskSeq(tNextno + IncX), MissingData(Len(StrainSeq(0)), tNextno + IncX), SeqNum(Len(StrainSeq(0)), tNextno + IncX), TraceSub(tNextno + IncX)
                            End If
                            TraceSub(tNextno) = TraceSub(Z)
                            MaskSeq(tNextno) = MaskSeq(Z)
                            GrpMaskSeq(tNextno) = GrpMaskSeq(Z)
                            If BeginningX < EndingX Then
                                For A = 1 To BeginningX - 1
                                    SeqNum(A, tNextno) = 46
                                    MissingData(A, tNextno) = 1
                                    
                                Next A
                                For A = BeginningX To EndingX
                                    SeqNum(A, tNextno) = SeqNum(A, Z)
                                Next A
                                For A = EndingX + 1 To Len(StrainSeq(0))
                                    SeqNum(A, tNextno) = 46
                                    MissingData(A, tNextno) = 1
                                Next A
                            Else
                                For A = 1 To EndingX
                                    SeqNum(A, tNextno) = SeqNum(A, Z)
                                Next A
                                For A = EndingX + 1 To BeginningX - 1
                                    SeqNum(A, tNextno) = 46
                                    MissingData(A, tNextno) = 1
                                Next A
                                For A = BeginningX To Len(StrainSeq(0))
                                    SeqNum(A, tNextno) = SeqNum(A, Z)
                                Next A
                            End If
                        End If
                    Else
                        BeginningX = BB
                        EndingX = BE
                    End If
                    'XX = TraceSub(62)
                    CurAge = AgeEvent(1, LowP)
                    Curscore = SEventNumber
                    Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                    Steps(1, StepNo) = Z  'from this seqence.....
                    Steps(2, StepNo) = BeginningX 'from this position....
                    Steps(3, StepNo) = EndingX 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    Call UpdateAgeScore(TraceSub(Z), CurAge, Curscore, BeginningX, EndingX, AgeScore(), EventScore())
                    If BeginningX < EndingX Then
                        For A = BeginningX To EndingX
                            SeqNum(A, Z) = 46
                            MissingData(A, Z) = 1
                            
                        Next A
                    Else
                        For A = 1 To EndingX
                            SeqNum(A, Z) = 46
                            MissingData(A, Z) = 1
                            
                        Next A
                        For A = BeginningX To Len(StrainSeq(0))
                            SeqNum(A, Z) = 46
                            MissingData(A, Z) = 1
                            
                        Next A
                    End If
                End If
            Next Z
        End If
            
        
            
            
        MiEN = EN
       
        For Z = 0 To TraceNumbMi
            XOverListMi(TraceMi(0, Z), TraceMi(1, Z)).Eventnumber = MiEN
            UB = UBound(TSEList, 1)
            If MiEN > UB Then
                ReDim Preserve TSEList(UB + 10)
            End If
            TSEList(MiEN) = SEventNumber
            MiEN = MiEN + 1
        Next Z
         
        MaEN = EN
            
        For Z = 0 To TraceNumbMa
            XOverListMa(TraceMa(0, Z), TraceMa(1, Z)).Eventnumber = MaEN
            UB = UBound(TSEList, 1)
            If MaEN > UB Then
                ReDim Preserve TSEList(UB + 10)
            End If
            TSEList(MaEN) = SEventNumber
            MaEN = MaEN + 1
        Next Z
            
        If MaEN >= DEN And MaEN >= MiEN Then
            EN = MaEN
        ElseIf MiEN >= DEN And MiEN >= MaEN Then
            EN = MiEN
        Else
            EN = DEN
        End If
            
        
        Call AddEvents(TraceNumbD, TraceD(), CurrentXOver(), XoverList(), BCurrentXOver(), BestXOList())
        Call AddEvents(TraceNumbMi, TraceMi(), CurrentXOverMi(), XOverListMi(), CurXOMi(), TXOLMi())
        Call AddEvents(TraceNumbMa, TraceMa(), CurrentXOverMa(), XOverListMa(), CurXOMa(), TXOLMa())
    
    ElseIf oSE > 0 Then
        JumpFlag = 1
        ReDim Preserve tNopini(2, SEventNumber)
        ReDim Preserve ExtraHits(NextNo, SEventNumber), ExtraHitsMa(NextNo, SEventNumber), ExtraHitsMi(NextNo, SEventNumber)
        If LowP = 0 Then Exit Sub
    End If
 Loop
 

Dim MCCorrectX As Double

Erase Daught
Erase MajorPar
Erase MinorPar
XX = StepNo

If Form1.Frame17.Visible = False Then
    Call SetUpFrame17
    Form1.Frame17.Visible = True
End If

If JumpFlag = 0 Then
    Call SetupGlobals2
ElseIf JumpFlag = 1 Then
    'Call SetUpFrame17
    ReDim SuperEventList(EN)
    ReDim Preserve TSEList(EN)
    ReDim DScores(25, 2, SEventNumber)
    
    For x = 0 To EN
        
        SuperEventList(x) = TSEList(x)
        
    Next x
    If RDF = 1 Then
        For x = SEventNumber + 1 To UBound(RepeatCycles, 1)
            RepeatCycles(x) = 0
        Next x
    End If
    For x = 1 To SEventNumber
        For Z = 0 To 25
            For A = 0 To 2
                    DScores(Z, A, x) = tDscores(Z, A, x)
            Next A
        Next Z
        YannWarn(x) = tYannWarn(x)
        AgeEvent(0, x) = TAgeEvent(0, x)
        AgeEvent(1, x) = TAgeEvent(1, x)
    Next x
    ReDim XOverListMi(PermNextno, UBound(TXOLMi, 2)), XOverListMa(PermNextno, UBound(TXOLMa, 2))
    For x = 0 To PermNextno
        CurrentXOverMi(x) = CurXOMi(x)
        For Y = 1 To CurrentXOverMi(x)
            XOverListMi(x, Y) = TXOLMi(x, Y)
        Next Y
        CurrentXOverMa(x) = CurXOMa(x)
        For Y = 1 To CurrentXOverMa(x)
            XOverListMa(x, Y) = TXOLMa(x, Y)
        Next Y
    Next x
    ReDim NOPINI(2, SEventNumber)
    
    If SEventNumber > 0 Then
        For x = 0 To SEventNumber
            NOPINI(0, x) = tNopini(0, x)
            NOPINI(1, x) = tNopini(1, x)
            NOPINI(2, x) = tNopini(2, x)
        Next x
    End If
    NextNo = tNextno
    
    Call SetupGlobals2
    
    ReDim CurrentXOver(NextNo)
    XOverListSize = 100
    ReDim XoverList(NextNo, 100)
    ReDim MaxXOP(AddNum - 1, NextNo)
    
    Dim ActualSeqSize()
    ReDim ActualSeqSize(NextNo)
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            If SeqNum(Y, x) > 46 Then
                ActualSeqSize(x) = ActualSeqSize(x) + 1
            End If
        Next Y
    Next x
    
    If tExcludedEventNum > 1000 Then
        ReDim EventsInExcludeds(5, tExcludedEventNum)
    Else
        ReDim EventsInExcludeds(5, 1000)
    End If
    If ExcludedEventNum > 0 Then
       
        For x = 0 To tExcludedEventNum
            For Z = 0 To UBound(EventsInExcludeds, 1)
                EventsInExcludeds(Z, x) = tEventsInExcludeds(Z, x)
            Next Z
        Next x
        ExcludedEventNum = tExcludedEventNum
        ExcludedEventBPNum = tExcludedEventBPNum
        If NumExcludedEventNum > 0 Then
            On Error Resume Next
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            
            For x = 0 To NumExcludedEventNum
                Kill "ExcludedEventNum" + Str(x) + UFTag
            Next x
            ChDrive oDirX
            ChDir oDirX
            On Error GoTo 0
            NumExcludedEventNum = 0
        End If
    End If
   ' XX = MCCorrection
    'If LowMemThreshold < PermNextno Then
    
    'End If
    If DebuggingFlag < 2 Then On Error Resume Next
    If UBound(SeqCol, 1) < NextNo Or UBound(FFillCol, 1) < NextNo Then
        ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
    End If
    
    If UBound(XCord, 3) < NextNo + 2 Or UBound(YCord, 3) < NextNo + 2 Or UBound(RYCord, 3) < NextNo + 2 Then
        ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
    End If
    
    On Error GoTo 0
    
    oCap = Form1.SSPanel1.Caption
    Form1.SSPanel1.Caption = "Calculating distances"
    
    
    DistanceFlag = 0
    TreeDistFlag = 0
    
    Form1.SSPanel1.Caption = oCap
    

    ReDim Distance(PermNextno, PermNextno), PermValid(PermNextno, PermNextno), PermDIffs(PermNextno, PermNextno), TreeDistance(NextNo, NextNo)
    
    
    Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
                    
    Call DrawTree
    
    If PermNextno > MemPoc And TreeXInFileFlag = 0 Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Erase TreeX
    End If
        
'XX = Distance(0, 0)
    
    
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim Preserve MaskSeq(NextNo), GrpMaskSeq(NextNo)
    For x = 0 To NextNo
        MaskSeq(x) = MaskSeq(TraceSub(x))
        GrpMaskSeq(x) = GrpMaskSeq(TraceSub(x))
    Next x
    b = 0
    XXX = (NextNo + 1) * NextNo
    XXX = XXX * (NextNo - 1) / 6
    MCCorrectX = XXX
    
    SSS = Abs(GetTickCount)
    'zzzz = 0
    For x = 0 To AddNum - 1
        oRecombNo(x) = TotSignals(x)
        RecombNo(x) = TotUSignals(x)
    Next x
    
    Dim PBS As Long, PBE As Long
    If SPY = 0 Then
        PBS = 0: PBE = 100
        ST = Abs(GetTickCount)
        ST = Abs(ST)
    Else
        PBS = Form1.ProgressBar1.Value - 10: PBE = Form1.ProgressBar1.Value
        If PBS < 0 Then PBS = 0
        
    End If
    Dim SAll As Long
    SAll = Abs(GetTickCount)
    SAll = Abs(SAll)
    
    If MaxAnalNo < MCCorrection Then
        UseALFlag = 1
    End If
    
    'sometimes files will have been loaded with a maxed out worthwhilescan
    'this detects those files, erases worthwhilescan and sets a flag to say all triplets must be rescreened
    Dim UBWWS As Long, WWSReprieve As Long
    UBWWS = UBound(Worthwhilescan)
    
    For x = 1 To UBWWS
        If Worthwhilescan(x) < 127 Then
            GoOn = 1
            Exit For
        End If
    Next x
    If GoOn = 0 Then
        ReDim Worthwhilescan(UBWWS)
        WWSReprieve = 1
    Else
        WWSReprieve = 0
    End If
    
    'Makes sure that the worthwhilescan array has some entries (with .rdp files it will normally be loaded without entries)
    GoOn = 0
    For x = 1 To UBWWS
        If Worthwhilescan(x) > 0 Then
            GoOn = 1
            Exit For
        End If
    Next x
    If GoOn = 0 Then
        For x = 1 To UBWWS
            Worthwhilescan(x) = 1 + 2 + 4 + 8 + 16 + 32 + 64 'this means that all methods should be used to scan
        Next x
    
    
    End If
    
    If UseALFlag = 1 Then 'use the analysislist and not a brute force all triplet scan
        
        
        
        GoOn = 0
        
        
        If TripListLen > 1000000 Then
            On Error Resume Next
                UB = -1
                UB = UBound(Analysislist, 2)
            On Error GoTo 0
            If UB = -1 Then
                ReDim Preserve Analysislist(2, TripListLen)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5AnalysisList" + UFTag For Binary As #FF
                Get #FF, , Analysislist
                Close #FF
                
                ChDrive oDirX
                ChDir oDirX
            End If
        End If
        
        
        Dim TargetVal As Long
        If UBound(Worthwhilescan, 1) < TripListLen Then
            TargetVal = UBound(Worthwhilescan, 1)
        Else
            TargetVal = TripListLen
        End If
        If x = x Then
            Dim FindAllFlagX As Byte
            If DoScans(0, 0) = 1 Or DoScans(0, 1) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 3) = 1 Then
        
                Dim AList() As Integer
                Dim BAL As Variant, ALC As Long
                Dim RedoL3() As Byte, StepsX As Long, EPX As Long
                Call MakeScanCompressArrays(NextNo, SeqNum())
                Dim UCThresh As Double
                If MCFlag = 0 Then
                    UCThresh = LowestProb / MCCorrection
                Else
                    UCThresh = LowestProb
                End If
                If DoScans(0, 0) = 1 Then
                    ReDim RestartPos(2)
                    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
                    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
                    BAL = TargetVal
                    ReDim AList(2, TargetVal)
                    ALC = -1
                    '@'$
                    'ALC = MakeAListISP(0, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
                    For x = 1 To TargetVal
                        CurrentTripListNum = x
                        Seq1 = Analysislist(0, x)
                        Seq2 = Analysislist(1, x)
                        Seq3 = Analysislist(2, x)
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > 20 Then
                                        If PermValid(Seq1, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq2) > 20 Then
                                                 If ProgBinRead(0, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    'If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    ALC = ALC + 1
                                                    AList(0, ALC) = Seq1
                                                    AList(1, ALC) = Seq2
                                                    AList(2, ALC) = Seq3
                                                    
                                                 End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next x
                    'XX = CurrentlyRunningFlag
                    If ALC > -1 Then
                        ReDim RedoL3(ALC)
                        StepsX = CLng(100000000 / Len(StrainSeq(0)))
                        UseCompress = 1
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'@
                            NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                            'If NumRedos > 0 Then
                                
                            For x = Y To EPX
            '                    If x = 475 Then
            '                        x = x
            '                    End If
                                If RedoL3(x) > 0 Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    
                                    ' Print #1, Str(Seq1) + "," + Str(Seq2) + "," + Str(Seq3)
                                    ''22,245,285
                                    CurrentTripListNum = x
                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                Else
                                    x = x
                                End If
                                x = x
                            Next x
                            'End If
                            
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                GlobalTimer = ET
                                LT = ET
                                'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined with RDP"
                                Form1.SSPanel1.Refresh
                                Form1.Refresh
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'                                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                                    StartPlt(0) = 1
'                                    oRec = oRecombNo(100)
'                                    Call UpdatePlotC
'                                    ET = Abs(GetTickCount)
'                                End If
                                If Abs(ET - ELT) > 2000 Then
                                    ELT = ET
                                    If oTotRecs > 0 Then
                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                        If PBV > Form1.ProgressBar1 Then
                                            Form1.ProgressBar1 = PBV
                                            Call UpdateF2Prog
                                        End If
                                    End If
                                            
                                End If
                                xNextno = NextNo
                                
                                DoEvents 'covered by currentlyrunningflag
                                NextNo = xNextno
                                If AbortFlag = 1 Then
                                    WinPPY = NextNo
                                    g = NextNo
                                    H = NextNo
                                End If
                                UpdateRecNums (SEventNumber)
                                
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                Call UpdateTimeCaps(ET, SAll)
                                
                                
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                If AbortFlag = 1 Then
                                    Exit For
                                End If
            
                            End If
                        Next Y
                        UseCompress = 0
                        'End If
                    End If
                End If
                If DoScans(0, 1) = 1 Then
                    GCIndelFlag = 0
            
                    ReDim FragMaxScore(GCDimSize, 5)
                    ReDim MaxScorePos(GCDimSize, 5)
                    ReDim PVals(GCDimSize, 5)
                    ReDim FragSt(GCDimSize, 6)
                    ReDim FragEn(GCDimSize, 6)
                    ReDim FragScore(GCDimSize, 6)
                    ReDim DeleteArray(Len(StrainSeq(0)) + 1)
                    BAL = TargetVal
                    ReDim AList(2, TargetVal)
                    ALC = -1
                    ReDim RestartPos(2)
                    '$'$'$
                    'ALC = MakeAListISP(1, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
                    For x = 1 To TargetVal
                        CurrentTripListNum = x
                        Seq1 = Analysislist(0, x)
                        Seq2 = Analysislist(1, x)
                        Seq3 = Analysislist(2, x)
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > 20 Then
                                        If PermValid(Seq1, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq2) > 20 Then
                                                 If ProgBinRead(1, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    'If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    ALC = ALC + 1
                                                    AList(0, ALC) = Seq1
                                                    AList(1, ALC) = Seq2
                                                    AList(2, ALC) = Seq3
                                                    
                                                 End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next x
                    If ALC > -1 Then
                        ReDim RedoL3(ALC)
                        StepsX = CLng(100000000 / Len(StrainSeq(0)))
                        UseCompress = 1
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                            ' NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), ALC, Y, EPX, NextNo, UCTHresh,                 RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            
                            'If NumRedos > 0 Then
                            '@'@
                            For x = Y To EPX
                                If RedoL3(x) = 1 Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    'ZZZ = ZZZ + 1
                                    CurrentTripListNum = x
                                    ''22,245,285
                                     NewOneFound = 0
                                    Call GCXoverD(0)
        '                            If RedoL3(x) = 2 And NewOneFound = 1 Then
        '                                x = x
        '                            End If
        '                            If NewOneFound = 0 Then
        '                                x = x
        '                            End If
                                ElseIf RedoL3(x) = 2 Then
                                    Call AddToRedoList(1, AList(0, x), AList(1, x), AList(2, x))
                                End If
                            Next x
                            'End If
                            
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                GlobalTimer = ET
                                LT = ET
                                'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined with GENECONV"
                                Form1.SSPanel1.Refresh
                                Form1.Refresh
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                If Abs(ET - ELT) > 2000 Then
                                    ELT = ET
                                    If oTotRecs > 0 Then
                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                        If PBV > Form1.ProgressBar1 Then
                                            Form1.ProgressBar1 = PBV
                                            Call UpdateF2Prog
                                        End If
                                    End If
                                            
                                End If
                                xNextno = NextNo
                                
                                DoEvents 'covered by currentlyrunningflag
                                NextNo = xNextno
                                If AbortFlag = 1 Then
                                    WinPPY = NextNo
                                    g = NextNo
                                    H = NextNo
                                End If
                                UpdateRecNums (SEventNumber)
                                
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                Call UpdateTimeCaps(ET, SAll)
                                
                                
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                If AbortFlag = 1 Then
                                    Exit For
                                End If
            
                            End If
                        Next Y
                    End If
                    UseCompress = 0
                End If
                
                If DoScans(0, 3) = 1 Then
                    Call SetupMCArrays
                    ReDim DeleteArray(Len(StrainSeq(0)) + 1)
                    BAL = TargetVal
                    ReDim AList(2, TargetVal)
                    ALC = -1
                    ReDim RestartPos(2)
                    'ALC = MakeAListISP(3, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
                    For x = 1 To TargetVal
                        CurrentTripListNum = x
                        Seq1 = Analysislist(0, x)
                        Seq2 = Analysislist(1, x)
                        Seq3 = Analysislist(2, x)
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > 20 Then
                                        If PermValid(Seq1, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq2) > 20 Then
                                                 If ProgBinRead(3, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    'If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    ALC = ALC + 1
                                                    AList(0, ALC) = Seq1
                                                    AList(1, ALC) = Seq2
                                                    AList(2, ALC) = Seq3
                                                    
                                                 End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next x
                    If ALC > -1 Then
                        ReDim RedoL3(ALC)
                        StepsX = CLng(100000000 / Len(StrainSeq(0)))
                        UseCompress = 1
                        oepx = -1
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                            'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh,                        RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0),        ALC,         Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            HWindowWidth = CLng(MCWinSize / 2)
                            lHWindowWidth = HWindowWidth
                            NumRedos = AlistMC3(SEventNumber, Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                            'XX = FindallFlag
                            
                            
                            
                            'If NumRedos > 0 Then
                            '@'@
                            For x = Y To EPX
        '                        If x <= oepx Then
        '                            x = x
        '                        End If
                                
                                If RedoL3(x) = 1 Then 'Or x = x Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    'ZZZ = ZZZ + 1
                                    CurrentTripListNum = x
                                    BQPV = 1
                                    ''22,245,285
                                    NewOneFound = 0
        '                            orl = RedoListSize
                                    Call MCXoverF(FindAllFlagX, 0, 0)
        '                            If (NewOneFound = 0 And RedoL3(x) > 0) Or (NewOneFound = 1 And RedoL3(x) = 0) Then
        '                                x = x
        '                            End If
        '
                                ElseIf RedoL3(x) = 2 Then
                                    Call AddToRedoList(3, AList(0, x), AList(1, x), AList(2, x))
                                    
                                End If
                            Next x
                            
                            
                            
                            'End If
                            OY = Y
                            oepx = EPX
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                GlobalTimer = ET
                                LT = ET
                                'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined with MAXCHI"
                                Form1.SSPanel1.Refresh
                                Form1.Refresh
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                If Abs(ET - ELT) > 2000 Then
                                    ELT = ET
                                    If oTotRecs > 0 Then
                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                        If PBV > Form1.ProgressBar1 Then
                                            Form1.ProgressBar1 = PBV
                                            Call UpdateF2Prog
                                        End If
                                    End If
                                            
                                End If
                                xNextno = NextNo
                                
                                DoEvents 'covered by currentlyrunningflag
                                NextNo = xNextno
                                If AbortFlag = 1 Then
                                    WinPPY = NextNo
                                    g = NextNo
                                    H = NextNo
                                End If
                                UpdateRecNums (SEventNumber)
                                
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                Call UpdateTimeCaps(ET, SAll)
                                
                                
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                If AbortFlag = 1 Then
                                    Exit For
                                End If
            
                            End If
                        Next Y
                    End If
                    UseCompress = 0
                    Call SetupMCArrays
                End If
                
                If DoScans(0, 4) = 1 Then
                    Dim LXOS() As Long
                    Dim XDP() As Long, XPD() As Long
                    
                    HWindowWidth = CLng(CWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    
                    ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
                    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
                    ReDim ChiValsX(Len(StrainSeq(0)))
                    ReDim SmoothChiX(Len(StrainSeq(0)))
                    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
                    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
                    ReDim LXOS(3)
                    ReDim XDP(Len(StrainSeq(0)) + 200, 2), XPD(Len(StrainSeq(0)) + 200, 2)
                    
                    Call GetCriticalDiff(1)
                    If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
                        CWinSize = HWindowWidth * 2
                    End If
                    
                    ReDim DeleteArray(Len(StrainSeq(0)) + 1)
                    BAL = TargetVal
                    ReDim AList(2, TargetVal)
                    ALC = -1
                    ReDim RestartPos(2)
                    '$'$'$
                    
                    
                   ' ALC = MakeAListISP(4, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
                    For x = 1 To TargetVal
                        CurrentTripListNum = x
                        Seq1 = Analysislist(0, x)
                        Seq2 = Analysislist(1, x)
                        Seq3 = Analysislist(2, x)
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > 20 Then
                                        If PermValid(Seq1, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq2) > 20 Then
                                                 If ProgBinRead(4, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    'If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    ALC = ALC + 1
                                                    AList(0, ALC) = Seq1
                                                    AList(1, ALC) = Seq2
                                                    AList(2, ALC) = Seq3
                                                    
                                                 End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next x
                    If ALC > -1 Then
                        ReDim RedoL3(ALC)
                        StepsX = CLng(100000000 / Len(StrainSeq(0)))
                        UseCompress = 1
                        oepx = -1
                        XX = RedoListSize
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                            'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh,                        RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0),        ALC,         Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            HWindowWidth = CLng(CWinSize / 2)
                            lHWindowWidth = HWindowWidth
                            'NumRedos = AlistMC3(SEventNumber,                  Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, 0,             NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, CDbl(LowestProb / MCCorrection), LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                            
                            NumRedos = AlistChi(SEventNumber, MissingData(0, 0), Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSRDP, 2), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                            
                            '@'@
                            For x = Y To EPX
                                '1578,4229, 4348
                                
                                CurrentTripListNum = x
                                If RedoL3(x) > 0 Then
                                    If ProgBinRead(0, RedoL3(x)) = 1 Then
                                        
                                        Seq1 = AList(0, x) '0
                                        Seq2 = AList(1, x) '31
                                        Seq3 = AList(2, x) '83
                                        ZZZ = ZZZ + 1
                                        BQPV = 1
        '                                If Y = 4229 Then
        '                                    x = x
        '                                End If
                                        
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(0, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(0, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                        
                                    End If
                                    If ProgBinRead(2, RedoL3(x)) = 1 Then
                                        
                                        Seq3 = AList(0, x) '5
                                        Seq1 = AList(1, x) '83
                                        Seq2 = AList(2, x) '104
                                        ZZZ = ZZZ + 1
                                        BQPV = 1
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(2, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(2, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                    End If
                                    If ProgBinRead(4, RedoL3(x)) = 1 Then
                                        
                                        Seq2 = AList(0, x) '5
                                        Seq3 = AList(1, x) '83
                                        Seq1 = AList(2, x) '107
                                        ZZZ = ZZZ + 1
                                        BQPV = 1
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(4, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(4, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                    End If
                                    If ProgBinRead(1, RedoL3(x)) = 1 Or ProgBinRead(3, RedoL3(x)) = 1 Or ProgBinRead(5, RedoL3(x)) = 1 Then
                                        ZZZ = ZZZ + 1
        '                                If ProgBinRead(4, Worthwhilescan(x)) = 0 Then
        '                                    Worthwhilescan(x) = Worthwhilescan(x) + 5
        '                                End If
                                        Call AddToRedoList(4, AList(0, x), AList(1, x), AList(2, x))
                                    End If
                                End If
                                
                                
                            Next x
                            
                            
                            
                            'End If
                            OY = Y
                            oepx = EPX
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                GlobalTimer = ET
                                LT = ET
                                'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                                Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined with CHIMAERA"
                                Form1.SSPanel1.Refresh
                                Form1.Refresh
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                If Abs(ET - ELT) > 2000 Then
                                    ELT = ET
                                    If oTotRecs > 0 Then
                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                        If PBV > Form1.ProgressBar1 Then
                                            Form1.ProgressBar1 = PBV
                                            Call UpdateF2Prog
                                        End If
                                    End If
                                            
                                End If
                                xNextno = NextNo
                                
                                DoEvents 'covered by currentlyrunningflag
                                NextNo = xNextno
                                If AbortFlag = 1 Then
                                    WinPPY = NextNo
                                    g = NextNo
                                    H = NextNo
                                End If
                                UpdateRecNums (SEventNumber)
                                
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                Call UpdateTimeCaps(ET, SAll)
                                
                                
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                If AbortFlag = 1 Then
                                    Exit For
                                End If
            
                            End If
                        Next Y
                    End If
                    UseCompress = 0
                End If
            End If
            If DoScans(0, 2) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then 'Or DoScans(0, 3) = 1 Then
                For x = 1 To TargetVal
                    CurrentTripListNum = x
                    Seq1 = Analysislist(0, x)
                    Seq2 = Analysislist(1, x)
                    Seq3 = Analysislist(2, x)
                    
                
                            If ActualSeqSize(Seq1) > MinSeqSize Then
                                If ActualSeqSize(Seq2) > MinSeqSize Then
                                    If ActualSeqSize(Seq3) > MinSeqSize Then
                                        If PermValid(Seq2, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq3) > 20 Then
                                                If PermValid(Seq1, Seq2) > 20 Then
'                                                     If ProgBinRead(0, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
'                                                        If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                     End If
'                                                     If ProgBinRead(1, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
'                                                        If DoScans(0, 1) = 1 Then Call GCXoverD(0)
'                                                     End If
                                                     If ProgBinRead(2, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                        If DoScans(0, 2) = 1 Then
                                                            Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                        End If
                                                     End If
'                                                     If ProgBinRead(3, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
'                                                        If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
'                                                    End If
'                                                     If ProgBinRead(4, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
'                                                        If DoScans(0, 4) = 1 Then
'                                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
'
'                                                            Call CXoverA(0, 0, 0)
'
'                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
'
'                                                            Call CXoverA(0, 0, 0)
'
'                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
'
'                                                            Call CXoverA(0, 0, 0)
'
'                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
'                                                        End If
'                                                    End If
                                                     
                                                     If ProgBinRead(6, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                        If DoScans(0, 8) = 1 Then
                                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                        End If
                                                    End If
                                                     If ProgBinRead(5, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                        If DoScans(0, 5) = 1 Then
                                                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                            Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                        End If
                                                    End If
                                                    
                                                    
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        'End If
                    'Next WinPPY
                    'End If
                    ET = Abs(GetTickCount)
                    If Abs(ET - GlobalTimer) > 500 Then
                        
                        'Form1.Refresh
                        GlobalTimer = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        UpdateRecNums (SEventNumber)
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        Form1.Label50(0).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(0) + MethodTime(0))
                        Form1.Label50(2).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(1) + MethodTime(1))
                        Form1.Label50(4).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(2) + MethodTime(2))
                        Form1.Label50(6).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(3) + MethodTime(3))
                        Form1.Label50(8).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(4) + MethodTime(4))
                        Form1.Label50(10).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(5) + MethodTime(5))
                        Form1.Label50(14).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(8) + MethodTime(8))
                        Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        DoEvents 'covered by currentlyrunningflag
                        If AbortFlag = 1 Then
                            Eventnumber = EN
                            If SPY = 1 Then
                                AbortFlag = 0
                            End If
                            For Z = 0 To AddNum - 1
                                MethodTime(Z) = MethodTime(Z) + Abs(ET - SAll) * TimeFract(Z)
                            Next Z
                            Exit Sub
                        End If
                        
                    End If
                Next x
            End If
        Else
        
            For x = 1 To TargetVal
                CurrentTripListNum = x
                Seq1 = Analysislist(0, x)
                Seq2 = Analysislist(1, x)
                Seq3 = Analysislist(2, x)
                
            
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > 20 Then
                                        If PermValid(Seq1, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq2) > 20 Then
                                                 If ProgBinRead(0, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                 End If
                                                 If ProgBinRead(1, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 1) = 1 Then Call GCXoverD(0)
                                                 End If
                                                 If ProgBinRead(2, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 2) = 1 Then
                                                        Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                    End If
                                                 End If
                                                 If ProgBinRead(3, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
                                                End If
                                                 If ProgBinRead(4, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 4) = 1 Then
                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                    
                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                    
                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                    
                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                    End If
                                                End If
                                                 
                                                 If ProgBinRead(6, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 8) = 1 Then
                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                    End If
                                                End If
                                                 If ProgBinRead(5, Worthwhilescan(x)) = 1 Or WWSReprieve = 1 Or CurWothwhilePos < x Then
                                                    If DoScans(0, 5) = 1 Then
                                                        oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                        Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                    End If
                                                End If
                                                
                                                
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    'End If
                'Next WinPPY
                'End If
                ET = Abs(GetTickCount)
                If Abs(ET - GlobalTimer) > 500 Then
                    
                    'Form1.Refresh
                    GlobalTimer = ET
                    'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                    UpdateRecNums (SEventNumber)
                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                    Form1.Label50(0).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(0) + MethodTime(0))
                    Form1.Label50(2).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(1) + MethodTime(1))
                    Form1.Label50(4).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(2) + MethodTime(2))
                    Form1.Label50(6).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(3) + MethodTime(3))
                    Form1.Label50(8).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(4) + MethodTime(4))
                    Form1.Label50(10).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(5) + MethodTime(5))
                    Form1.Label50(14).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(8) + MethodTime(8))
                    Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    DoEvents 'covered by currentlyrunningflag
                    If AbortFlag = 1 Then
                        Eventnumber = EN
                        If SPY = 1 Then
                            AbortFlag = 0
                        End If
                        For Z = 0 To AddNum - 1
                            MethodTime(Z) = MethodTime(Z) + Abs(ET - SAll) * TimeFract(Z)
                        Next Z
                        Exit Sub
                    End If
                    
                End If
            Next x
        End If
        
'        x = x
'
'        For x = 0 To NextNo
'            For Y = 1 To CurrentXOver(x)
'                XX = XoverList(x, Y).Probability
'            Next Y
'        Next x
        'this screens all the "extra" sequences
        
        
        
        
        
        If AbortFlag <> 1 Then
            
            For x = 0 To TripListLen
                CurrentTripListNum = x
                Seq1 = Analysislist(0, x)
                Seq2 = Analysislist(1, x)
                Seq3 = Analysislist(2, x)
                'If DoPairs(Seq1, Seq2) = 1 And DoPairs(Seq2, Seq3) = 1 And DoPairs(Seq1, Seq3) = 1 Then
                    For WinPPY = PermNextno + 1 To NextNo
                        
                        b = TraceSub(WinPPY)
                        
                        If Seq1 = b Or Seq2 = b Or Seq3 = b Then
                            If b = Seq1 Then
                                Seq1 = WinPPY
                            ElseIf b = Seq2 Then
                                Seq2 = WinPPY
                            ElseIf b = Seq3 Then
                                Seq3 = WinPPY
                            End If
                            If ActualSeqSize(Seq1) > MinSeqSize Then
                                If ActualSeqSize(Seq2) > MinSeqSize Then
                                    If ActualSeqSize(Seq3) > MinSeqSize Then
                                        If PermValid(Seq2, Seq3) > 20 Then
                                            If PermValid(Seq1, Seq3) > 20 Then
                                                If PermValid(Seq1, Seq2) > 20 Then
                                                     If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                     If DoScans(0, 1) = 1 Then Call GCXoverD(0)
                                                     
                                                     If DoScans(0, 2) = 1 Then
                                                         Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                     End If
                                                     
                                                     If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
                                                    
                                                     If DoScans(0, 4) = 1 Then
                                                         tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                     
                                                         Call CXoverA(0, 0, 0)
                                                                     
                                                         Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                     
                                                         Call CXoverA(0, 0, 0)
                                                                     
                                                         Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                     
                                                         Call CXoverA(0, 0, 0)
                                                                     
                                                         Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                     End If
                                                     If DoScans(0, 8) = 1 Then
                                                         tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                 
                                                         Call TSXOver(0)
                                                                 
                                                         Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                 
                                                         Call TSXOver(0)
                                                                 
                                                         Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                 
                                                         Call TSXOver(0)
                                                                 
                                                         Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                     End If
                                                     If DoScans(0, 5) = 1 Then
                                                         oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                         Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                         Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                     End If
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next WinPPY
                'End If
                ET = Abs(GetTickCount)
                If Abs(ET - GlobalTimer) > 500 Then
                    
                    'Form1.Refresh
                    GlobalTimer = ET
                    'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                    UpdateRecNums (SEventNumber)
                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                    Form1.Label50(0).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(0) + MethodTime(0))
                    Form1.Label50(2).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(1) + MethodTime(1))
                    Form1.Label50(4).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(2) + MethodTime(2))
                    Form1.Label50(6).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(3) + MethodTime(3))
                    Form1.Label50(8).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(4) + MethodTime(4))
                    Form1.Label50(10).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(5) + MethodTime(5))
                    Form1.Label50(14).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(8) + MethodTime(8))
                    Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    DoEvents 'covered by currentlyrunningflag
                    If AbortFlag = 1 Then
                        Eventnumber = EN
                        If SPY = 1 Then
                            AbortFlag = 0
                        End If
                        For Z = 0 To AddNum - 1
                            MethodTime(Z) = MethodTime(Z) + Abs(ET - SAll) * TimeFract(Z)
                        Next Z
                        If CurWothwhilePos > x Then CurWothwhilePos = x
                        Exit Sub
                    End If
                    
                End If
                
            Next x
        End If
        
        'Need to consolidate analysislist and remove all the pointless scans
        If CurWothwhilePos = TripListLen Or x = x Then
            x = 1
            Do
                If Worthwhilescan(x) = 0 Then
                    If x < TripListLen Then
                        Analysislist(0, x) = Analysislist(0, TripListLen)
                        Analysislist(1, x) = Analysislist(1, TripListLen)
                        Analysislist(2, x) = Analysislist(2, TripListLen)
                        Worthwhilescan(x) = Worthwhilescan(TripListLen)
                        'X = X - 1
                        
                    End If
                    TripListLen = TripListLen - 1
                Else
                    x = x + 1
                End If
                
                If x > TripListLen Then Exit Do
            Loop
            
            ReDim Preserve Analysislist(2, TripListLen)
            ReDim Preserve Worthwhilescan(TripListLen)
        End If
        CurWothwhilePos = TripListLen + 1
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5AnalysisList" + UFTag For Binary As #FF
        Put #FF, , Analysislist
        Close #FF
                
        ChDrive oDirX
        ChDir oDirX
            
        
        If TripListLen > 1000000 Then
            Erase Analysislist
        End If
    Else
    
        For Seq1 = 0 To NextNo
            
            'scan seqx against all the rest
            ' ie similar to individualA scan
            If IndividualA > -1 Or IndividualB > -1 Then
                If IndividualA = TraceSub(Seq1) Or IndividualB = TraceSub(Seq1) Then
                        GoOn = 1
                End If
            Else
                GoOn = 1
            End If
            If GoOn = 1 And MaskSeq(Seq1) = 0 Then
                
                If ActualSeqSize(Seq1) > MinSeqSize Then
                
                    For Seq2 = Seq1 + 1 To NextNo
                        'If DoPairs(TraceSub(Seq1), TraceSub(Seq2)) = 1 Then
                            If TraceSub(Seq1) <> TraceSub(Seq2) Then
                            If ActualSeqSize(Seq2) > MinSeqSize And (IndividualA > -1 Or MaskSeq(Seq2) = 0) Then
                                For Seq3 = Seq2 + 1 To NextNo
                                    If FastestFlag = 1 Then
                                        
                                            NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                        
                                    End If
                                    'If DoPairs(TraceSub(Seq2), TraceSub(Seq3)) + DoPairs(TraceSub(Seq1), TraceSub(Seq3)) + DoPairs(TraceSub(Seq1), TraceSub(Seq2)) > 0 Then
                                        If ActualSeqSize(Seq3) > MinSeqSize And (IndividualA > -1 Or MaskSeq(Seq3) = 0) Then
                                            
                                            If TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
                                                
                                                'If ((PermDiffs(Seq1, Seq2) > MinOverlap And PermDiffs(Seq1, Seq3)) > MinOverlap And PermDiffs(Seq2, Seq3) > MinOverlap) Then
                                                     'zzzz = zzzz + 1
                                                     
                                                     
                                                     
                                                    If DoScans(0, 0) = 1 Then
                                                        If FastestFlag = 0 Then
                                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                            x = x
                                                        Else
                                                            
                                                            If ProgBinRead(0, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                x = x
                                                            End If
                                                        End If
                                                    End If
                                                    
                                                   
                                                    
                                                    If DoScans(0, 1) = 1 Then
                                                    
                                                        'Call GCXoverD(0)
                                                        If FastestFlag = 0 Then
                                                            Call GCXoverD(0)
                                                        Else
                                                           
                                                            If ProgBinRead(1, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                               Call GCXoverD(0)
                                                            
                                                            End If
                                                        End If
                                                    End If
                                                    If DoScans(0, 2) = 1 Then
                                                       
                                                        If FastestFlag = 0 Then
                                                             Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                        Else
                                                            
                                                            If ProgBinRead(2, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                                Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                            End If
                                                        End If
                                                    End If
                                                    
                                                    If DoScans(0, 3) = 1 Then
                                                        
                                                        If FastestFlag = 0 Then
                                                            Call MCXoverF(0, 0, 0)
                                                        Else
                                                            
                                                            If ProgBinRead(3, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                               Call MCXoverF(0, 0, 0)
                                                            End If
                                                        End If
                                                    End If
                                                   
                                                    If DoScans(0, 4) = 1 Then
                                                    
                                                        If FastestFlag = 0 Then
                                                             tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                    
                                                            Call CXoverA(0, 0, 0)
                                                                        
                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                        
                                                            Call CXoverA(0, 0, 0)
                                                                        
                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                        
                                                            Call CXoverA(0, 0, 0)
                                                                        
                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                        Else
                                                            
                                                            If ProgBinRead(4, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                        
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                            
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                            
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                            End If
                                                        End If
                                                    
                                                    
                                                       
                                                    End If
                                                    
                                                    
                                                    
                                                    
                                                    If DoScans(0, 8) = 1 Then
                                                        
                                                        If FastestFlag = 0 Then
                                                             tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                        Else
                                                            
                                                            If ProgBinRead(6, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                        
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                        
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                            End If
                                                        End If
                                                        
                                                       
                                                    End If
                                                    If DoScans(0, 5) = 1 Then
                                                        
                                                        If FastestFlag = 0 Then
                                                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                            Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                        Else
                                                           
                                                            If ProgBinRead(5, Worthwhilescan(NumInList)) = 1 Or WWSReprieve = 1 Then
                                                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                'Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                If AbortFlag = 0 Then
                                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                End If
                                                            End If
                                                        End If
                                                        
                                                    End If
                                                End If
                                                                
                                            b = b + 1
                                        
                                        End If
                                    'End If
                                    ET = Abs(GetTickCount)
                                    ET = Abs(ET)
                                    If Abs(ET - GlobalTimer) > 500 Then
                                        GlobalTimer = ET
                                        Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                                        Form1.ProgressBar1 = PBS + (b / MCCorrectX) * (PBE - PBS)
                                        Call UpdateF2Prog
                                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                        DoEvents 'covered by currentlyrunning
                                        Form1.WindowState = Form1.WindowState
                                        
                                        If AbortFlag = 1 Then
                                            Eventnumber = EN
                                            If SPY = 1 Then
                                                AbortFlag = 0
                                            End If
                                            For x = 0 To AddNum - 1
                                                MethodTime(x) = MethodTime(x) + Abs(ET - SAll) * TimeFract(x)
                                            Next x
                                            Exit Sub
                                        End If
                                        UpdateRecNums (SEventNumber)
                                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                        Form1.Label50(0).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(0) + MethodTime(0))
                                        Form1.Label50(2).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(1) + MethodTime(1))
                                        Form1.Label50(4).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(2) + MethodTime(2))
                                        Form1.Label50(6).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(3) + MethodTime(3))
                                        Form1.Label50(8).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(4) + MethodTime(4))
                                        Form1.Label50(10).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(5) + MethodTime(5))
                                        Form1.Label50(14).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(8) + MethodTime(8))
                                        Form1.Refresh
                                    End If
                                Next Seq3
                            Else
                                b = b + (NextNo - Seq2)
                            End If
                            End If
                        'Else
                        '    B = B + (Nextno - Seq2)
                        'End If
                    Next Seq2
                Else
                    b = b + ((NextNo - Seq1 - 1) * (NextNo - Seq1 - 2)) / 2
                End If
            End If
            x = x
        Next Seq1
    End If
    ET = Abs(GetTickCount)
    ET = Abs(ET)
    UpdateRecNums (SEventNumber)
    Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
    Form1.Label50(0).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(0) + MethodTime(0))
    Form1.Label50(2).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(1) + MethodTime(1))
    Form1.Label50(4).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(2) + MethodTime(2))
    Form1.Label50(6).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(3) + MethodTime(3))
    Form1.Label50(8).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(4) + MethodTime(4))
    Form1.Label50(10).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(5) + MethodTime(5))
    Form1.Label50(14).Caption = DoTimeII(Abs(ET - SAll) * TimeFract(8) + MethodTime(8))
    For x = 0 To AddNum - 1
        MethodTime(x) = MethodTime(x) + Abs(ET - SAll) * TimeFract(x)
    Next x
End If

'EEE = Abs(GetTickCount)
'ttt = EEE - SSS
'X = X
'8.863 - no progs
'60.427 - rdp only -245 hits
'129.106 without using permdiffs info-244 hits
'198.235 using permdiffs -806 hits
'559.925 without using permdiffs -806 hits
Eventnumber = EN


End Sub
Public Sub AddPVal(MCFlag As Integer, MChi As Double, MCCorrection As Long, LenXoverSeq As Long, HWindowWidth As Long, mtP() As Double, Prog As Long)
If MCFlag = 0 Then
    If ChiPVal(MChi) * MCCorrection * (LenXoverSeq / (HWindowWidth)) <= mtP(Prog) Then
        mtP(Prog) = ChiPVal(MChi) * MCCorrection * (LenXoverSeq / (HWindowWidth))
    End If
Else
    If ChiPVal(MChi) * (LenXoverSeq / (HWindowWidth)) <= mtP(Prog) Then
        mtP(Prog) = ChiPVal(MChi) * (LenXoverSeq / (HWindowWidth))
    End If
End If
End Sub

Public Sub MakeWindowSize(BEP, ENP, CriticalDiff As Long, LenXoverSeq As Long, CWinFract As Double, CWinSize As Long, HWindowWidth As Long, lHWindowWidth As Long, GoOn As Byte, FindallFlag As Byte, CProportionFlag As Integer, XPosDiff() As Long)
Dim WindowWidth As Long, EN As Long, BE As Long
'@
GoOn = 1
If FindallFlag = 0 Or (BEP = 0 And ENP = 0) Then
    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2 + 0.000001)
        x = x
    Else
        If Int(CWinFract * LenXoverSeq) > 20 And Int(CWinFract * LenXoverSeq) < (LenXoverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXoverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXoverSeq) <= 20 Then
    
            If LenXoverSeq > 15 Then
                WindowWidth = 20
            Else
                GoOn = 0
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXoverSeq) >= (LenXoverSeq / 1.5) Then
    
            If LenXoverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXoverSeq / 1.5) / 2) * 2 - 2)
            Else
                GoOn = 0
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        
        Call GetCriticalDiff(0)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
            CWinSize = HWindowWidth * 2
        End If
    End If
Else
    BE = BEP
    EN = ENP
    If BE < EN Then
        HWindowWidth = XPosDiff(EN) - XPosDiff(BE) + 1
    Else
        HWindowWidth = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE)) + 1
    End If
End If
'@
If HWindowWidth * 2 > LenXoverSeq Then HWindowWidth = CLng((LenXoverSeq * 0.75) / 2 + 0.00001) - 1
If HWindowWidth <= CriticalDiff Then HWindowWidth = CLng(LenXoverSeq / 2 + 0.00001) - 1
If HWindowWidth < 6 Then
    HWindowWidth = lHWindowWidth
    GoOn = 0
End If

End Sub
Public Sub MakeWindowSize2(Element, BEP, ENP, CriticalDiff As Long, LenXoverSeq As Long, CWinFract As Double, CWinSize As Long, HWindowWidth As Long, lHWindowWidth As Long, GoOn As Byte, FindallFlag As Byte, CProportionFlag As Integer, XPosDiff() As Long)
Dim WindowWidth As Long, EN As Long, BE As Long

GoOn = 1
If FindallFlag = 0 Then
    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2)
        x = x
    Else
        If Int(CWinFract * LenXoverSeq) > 20 And Int(CWinFract * LenXoverSeq) < (LenXoverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXoverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXoverSeq) <= 20 Then
    
            If LenXoverSeq > 15 Then
                WindowWidth = 20
            Else
                GoOn = 0
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXoverSeq) >= (LenXoverSeq / 1.5) Then
    
            If LenXoverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXoverSeq / 1.5) / 2) * 2 - 2)
            Else
                GoOn = 0
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        
        Call GetCriticalDiff(0)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
            CWinSize = HWindowWidth * 2
        End If
    End If
Else
    BE = BEP
    EN = ENP
    If BE < EN Then
        HWindowWidth = XPosDiff(EN, Element) - XPosDiff(BE, Element) + 1
    Else
        HWindowWidth = XPosDiff(EN, Element) + (LenXoverSeq - XPosDiff(BE, Element)) + 1
    End If
End If

If HWindowWidth * 2 > LenXoverSeq Then HWindowWidth = CLng((LenXoverSeq * 0.75) / 2) - 1
If HWindowWidth <= CriticalDiff Then HWindowWidth = CLng(LenXoverSeq / 2) - 1
If HWindowWidth < 6 Then
    HWindowWidth = lHWindowWidth
    GoOn = 0
End If

End Sub
Public Sub MakeTWin(FindallFlag, HWindowWidth As Long, TWin As Long, LenXoverSeq As Long)
If FindallFlag = 0 Then
    TWin = CLng(HWindowWidth / 4)
    If TWin < 6 Then
        TWin = 6
    End If
    If TWin > HWindowWidth Then
        TWin = HWindowWidth
    End If
    If TWin > Int(LenXoverSeq / 2) Then
        TWin = Int(LenXoverSeq / 2)
    End If
Else
    TWin = HWindowWidth
End If
End Sub
Public Sub FlashName(Picture2 As PictureBox, p2bc As Long, InString As String, InY, InX, Chanel, T1, T2, T3, X1, X2, PauseTime)

'there is some screwup with the timer on some systems
Exit Sub
    Dim DS As Long, DH As Long, x As Long, SS As Integer, SSX As Long, EE As Long
    Picture2.AutoRedraw = True
    Picture2.DrawMode = 13
    If Len(InString) > 100 Then InString = Left(InString, 100)
    DS = Picture2.TextWidth(InString)
    PauseTime = 1
    DH = Picture2.TextHeight(InString)
    Picture2.Line (InX, InY)-(InX + DS, InY + DH - 1), p2bc, BF
    If T1 < T2 Then SS = 4 Else SS = -4
    If T1 <> 255 Then
        For x = T1 To T2 Step SS
            Picture2.Line (InX, InY)-(InX + DS, InY + DH - 1), p2bc, BF
            Picture2.CurrentX = InX
            Picture2.CurrentY = InY
            If Chanel = 1 Then
                Picture2.ForeColor = RGB(x, X1, X2)
            ElseIf Chanel = 2 Then
                Picture2.ForeColor = RGB(X1, x, X2)
            ElseIf Chanel = 3 Then
                Picture2.ForeColor = RGB(X1, X2, x)
            End If
            Picture2.Print InString
            Picture2.Refresh
            'Sleep PauseTime
            SSX = Abs(GetTickCount)
            DoEvents
            For Z = 0 To PauseTime * 10000
                EE = Abs(GetTickCount)
                If Abs(Abs(EE) - Abs(SSX)) > PauseTime Then Exit For
               DoEvents
            Next Z
        Next x
    End If
    SSX = Abs(GetTickCount)
    If T2 < T3 Then SS = 4 Else SS = -4
    For x = T2 To T3 Step SS
        Picture2.Line (InX, InY)-(InX + DS, InY + DH - 1), p2bc, BF
        Picture2.CurrentX = InX
        Picture2.CurrentY = InY
        If T1 = 255 Then
            If Chanel = 1 Then
                Picture2.ForeColor = RGB(T1, x, x)
            ElseIf Chanel = 2 Then
                Picture2.ForeColor = RGB(x, T1, x)
            ElseIf Chanel = 3 Then
                Picture2.ForeColor = RGB(x, x, T1)
            End If
        Else
            If Chanel = 1 Then
                Picture2.ForeColor = RGB(x, X1, X2)
            ElseIf Chanel = 2 Then
                Picture2.ForeColor = RGB(X1, x, X2)
            ElseIf Chanel = 3 Then
                Picture2.ForeColor = RGB(X1, X2, x)
            End If
        End If
        Picture2.Print InString
        Picture2.Refresh
        'Sleep PauseTime
        DoEvents
        SSX = Abs(GetTickCount)
             For Z = 0 To PauseTime * 10000
                EE = Abs(GetTickCount)
                If Abs(Abs(EE) - Abs(SSX)) > PauseTime Then Exit For
                 DoEvents
            Next Z
     Next x
     
     
     If T1 <> 255 Then
        If T3 < T1 Then SS = 4 Else SS = -4
        For x = T3 To T1 Step SS
           Picture2.Line (InX, InY)-(InX + DS, InY + DH - 2), p2bc, BF
           Picture2.CurrentX = InX
           Picture2.CurrentY = InY
           
           
               If Chanel = 1 Then
                   Picture2.ForeColor = RGB(x, X1, X2)
               ElseIf Chanel = 2 Then
                   Picture2.ForeColor = RGB(X1, x, X2)
               ElseIf Chanel = 3 Then
                   Picture2.ForeColor = RGB(X1, X2, x)
               End If
           
           Picture2.Print InString
           Picture2.Refresh
           'Sleep PauseTime
           DoEvents
           SSX = Abs(GetTickCount)
             For Z = 0 To PauseTime * 10000
                EE = Abs(GetTickCount)
                If Abs(Abs(EE) - Abs(SSX)) > PauseTime Then Exit For
                DoEvents
            Next Z
        Next x
    Else
        If T3 < T2 Then SS = 4 Else SS = -4
        For x = T3 To T2 Step SS
               Picture2.Line (InX, InY)-(InX + DS, InY + DH - 1), p2bc, BF
               Picture2.CurrentX = InX
               Picture2.CurrentY = InY
                If Chanel = 1 Then
                    Picture2.ForeColor = RGB(T1, x, x)
                ElseIf Chanel = 2 Then
                    Picture2.ForeColor = RGB(x, T1, x)
                ElseIf Chanel = 3 Then
                    Picture2.ForeColor = RGB(x, x, T1)
                End If
              
               Picture2.Print InString
               Picture2.Refresh
               'Sleep PauseTime
               DoEvents
               SSX = Abs(GetTickCount)
             For Z = 0 To PauseTime * 10000
                EE = Abs(Abs(GetTickCount))
                If Abs(Abs(EE) - Abs(SSX)) > PauseTime Then Exit For
                DoEvents
            Next Z
        Next x
     End If
     
     Picture2.Line (InX, InY)-(InX + DS, InY + DH - 1), p2bc, BF
     
     Picture2.CurrentX = InX
     Picture2.CurrentY = InY
     If T3 = 168 Then T1 = 192
     x = T1
     If Chanel = 1 Then
            Picture2.ForeColor = RGB(x, X1, X2)
     ElseIf Chanel = 2 Then
            Picture2.ForeColor = RGB(X1, x, X2)
     ElseIf Chanel = 3 Then
            Picture2.ForeColor = RGB(X1, X2, x)
     End If
     
     Picture2.Print InString
     Picture2.Refresh
     Picture2.AutoRedraw = False
     EE = Abs(GetTickCount)
     TT = EE - SSX
     x = x
End Sub
Public Sub FindSets(TraceSub() As Long, OKSeq() As Double, SetTot() As Long, NextNo As Long, BE As Long, EN As Long, ISeqs() As Long, RList() As Long, RNum() As Long, XoverList() As XOverDefine, CurrentXOver() As Integer)
Dim GoOn As Long, Dummy As Long, USet() As Byte, TS As Long, Sets() As Byte, SZ1 As Long, SZ2 As Long, OL As Long, A As Long, x As Long, Y As Long, Z As Long, RI(5) As Long, OLSeq() As Byte, LSeq As Long
Dim tRList() As Long, DoIt() As Byte, UB As Long
LSeq = Len(StrainSeq(0))
ReDim OLSeq(Len(StrainSeq(0)))




If NextNo >= PermNextno Then
    ReDim Sets(2, NextNo)
Else
    ReDim Sets(2, PermNextno)
End If


ReDim SetTot(1, 2)

Dummy = MakeOLSeqB(BE, EN, LSeq, OLSeq(0))

If EN > BE Then
    SZ1 = EN - BE + 1
Else
    SZ1 = EN + LSeq - BE + 1
End If

OLSeq(EN) = 1
ReDim DoIt(2)


UB = UBound(CurrentXOver, 1)
'If X = X Then
'@'$'@
    Dummy = DoSetsAP(NextNo, UB, UBound(XoverList, 1), SZ1, Len(StrainSeq(0)), RI(0), OLSeq(0), Sets(0, 0), DoIt(0), CurrentXOver(0), XoverList(0, 0), DoIt(0), ISeqs(0))



ReDim USet(6, NextNo)
'0 = union of all three
'1 = union of 0 and 1 excluding set 0
'2 = union of 0 and 2 excluding set 0
'3 = union of 1 and 2 excluding set 0
'4 = unique to 0
'5 = unique to 1
'6 = unique to 2
GoOn = 0

ReDim tRList(2, NextNo)




tRList(0, ISeqs(0)) = 1
tRList(1, ISeqs(1)) = 1
tRList(2, ISeqs(2)) = 1

For x = 0 To NextNo
    If Sets(0, x) = 1 And Sets(1, x) = 1 And Sets(2, x) = 1 Then
        
    ElseIf Sets(0, x) = 1 And Sets(1, x) = 1 Then
        If tRList(2, x) = 0 Then
            tRList(2, x) = 1
            GoOn = 1
        End If
    ElseIf Sets(0, x) = 1 And Sets(2, x) = 1 Then
        If tRList(1, x) = 0 Then
            tRList(1, x) = 1 '22
            GoOn = 1
        End If
    ElseIf Sets(2, x) = 1 And Sets(1, x) = 1 Then
        If tRList(0, x) = 0 Then
            tRList(0, x) = 1
            GoOn = 1
        End If
   
    End If
    
Next x

ReDim RList(2, NextNo), RNum(2)
For Z = 0 To 2
    For Y = 0 To NextNo
        If tRList(Z, Y) = 1 Then
            RList(Z, RNum(Z)) = Y
            RNum(Z) = RNum(Z) + 1
        End If
    Next Y
Next Z
For Z = 0 To 2
    RNum(Z) = RNum(Z) - 1
Next Z


'For X = 0 To 2
'    XX = ISeqs(X)
'    For Y = 0 To RNum(X)
'        XX = RList(X, Y)
'    Next Y
'Next X

'Now repeat until no more sequences have been a added to rlist
'SS = Abs(GetTickCount)

Do While GoOn = 1
    
    If NextNo >= PermNextno Then
        ReDim Sets(2, NextNo)
    Else
        ReDim Sets(2, PermNextno)
    End If
    
    
'    If X = X Then
        
        'this could be parallelized
        '$'$'$
        'Dummy = FillSetsP(SZ1, Len(StrainSeq(0)), NextNo, UB, UBound(XoverList, 1), UBound(RList, 1), UBound(Sets, 1), RNum(0), RList(0, 0), CurrentXOver(0), XoverList(0, 0), RI(0), OLSeq(0), Sets(0, 0))
        'Dummy = FillSetsP2(UBound(XoverList, 2), SZ1, Len(StrainSeq(0)), NextNo, UB, UBound(XoverList, 1), UBound(RList, 1), UBound(Sets, 1), RNum(0), RList(0, 0), CurrentXOver(0), XoverList(0, 0), RI(0), OLSeq(0), Sets(0, 0))
        Dummy = FillSetsP3(BE, EN, UBound(XoverList, 2), SZ1, Len(StrainSeq(0)), NextNo, UB, UBound(XoverList, 1), UBound(RList, 1), UBound(Sets, 1), RNum(0), RList(0, 0), CurrentXOver(0), XoverList(0, 0), RI(0), OLSeq(0), Sets(0, 0))
    
x = x
'    Else
'
'        For X = 0 To Nextno
'
'            If X <= UB Then
'
'                For Y = 1 To CurrentXOver(X)
'
'                    RI(4) = XOverlist(X, Y).Beginning
'                    RI(5) = XOverlist(X, Y).Ending
'
'                    GoOn = DoSetsB(SZ1, lseq, RI(0), OLSeq(0))
'
'                    If GoOn > 0 Then
    '                    If XOverlist(X, Y).Daughter > PermNextno Then
    '                        XOverlist(X, Y).Daughter = TraceSub(XOverlist(X, Y).Daughter)
    '                    End If
    '                     If XOverlist(X, Y).MajorP > PermNextno Then
    '                        XOverlist(X, Y).MajorP = TraceSub(XOverlist(X, Y).MajorP)
    '                    End If
    '                     If XOverlist(X, Y).MinorP > PermNextno Then
    '                        XOverlist(X, Y).MinorP = TraceSub(XOverlist(X, Y).MinorP)
    '                    End If
'                        RI(0) = XOverlist(X, Y).Daughter
'                        RI(1) = XOverlist(X, Y).MajorP
'                        RI(2) = XOverlist(X, Y).MinorP
'                        GoOn = 0
'
'                        'for some reason this c++ routine(which looks identical to the VB one below it) yields different answers with different sequence input orders
''                        If X = 12345 Then
''                            Dummy = FillSets(UBound(Sets, 1), UBound(RList, 1), RNum(0), RI(0), RList(0, 0), Sets(0, 0))
''                       Else
'                            For Z = 0 To 2
'
'                                For A = 0 To RNum(Z)
'                                    TS = RList(Z, A)
'                                    If RI(0) = TS Or RI(1) = TS Or RI(2) = TS Then
'                                        Sets(Z, RI(0)) = 1
'                                        Sets(Z, RI(1)) = 1 '
'                                        Sets(Z, RI(2)) = 1
'                                    End If
'                                Next A
'                            Next Z
''                        End If
'                    End If
'                Next Y
'            End If
'        Next X
'    End If
    
    
    GoOn = 0
    
    ReDim tRList(2, NextNo)
    For x = 0 To 2
        For Y = 0 To RNum(x)
            tRList(x, RList(x, Y)) = 1 '16,13,22,9
        Next Y
    Next x
    
    ReDim USet(6, NextNo)
    For x = 0 To NextNo
        If Sets(0, x) = 1 And Sets(1, x) = 1 And Sets(2, x) = 1 Then
            
        ElseIf Sets(0, x) = 1 And Sets(1, x) = 1 Then
            If tRList(2, x) = 0 Then
                tRList(2, x) = 1
                GoOn = 1
            End If
        ElseIf Sets(0, x) = 1 And Sets(2, x) = 1 Then
            If tRList(1, x) = 0 Then
                tRList(1, x) = 1
                GoOn = 1
            End If
        ElseIf Sets(2, x) = 1 And Sets(1, x) = 1 Then
           If tRList(0, x) = 0 Then
                tRList(0, x) = 1
                GoOn = 1
            End If
            
        ElseIf Sets(0, x) = 1 Then
            USet(4, x) = 1
            
        
        ElseIf Sets(1, x) = 1 Then
            
            USet(5, x) = 1
        ElseIf Sets(2, x) = 1 Then
            
            USet(6, x) = 1
        End If
        
        ReDim RList(2, NextNo), RNum(2)
        
        If x = x Then
            '&
            Dummy = ReAddToRList(NextNo, UBound(tRList, 1), UBound(RList, 1), tRList(0, 0), RList(0, 0), RNum(0))
            
        Else
        
            For Z = 0 To 2
                For Y = 0 To NextNo
                    If tRList(Z, Y) = 1 Then
                        RList(Z, RNum(Z)) = Y '16,13,22,9,16
                        RNum(Z) = RNum(Z) + 1
                    End If
                Next Y
            Next Z
        End If
        For Z = 0 To 2
            RNum(Z) = RNum(Z) - 1
        Next Z
    Next x
    x = x
Loop

'If SEventNumber = 18 Then
'    XX = RNum(0)
'    XX = RNum(1)
'    XX = RNum(2)
'End If


'EE = Abs(GetTickCount)
'TT = EE - SS '20.062'1.935 with readdtolist

For Y = 4 To 6
    For x = 0 To NextNo
        SetTot(0, Y - 4) = SetTot(0, Y - 4) + USet(Y, x)
    Next x
Next Y

For x = 0 To 2
    For Y = 0 To RNum(x)
        OKSeq(x, 2, RList(x, Y)) = 1
    Next Y
Next x

End Sub
Public Sub MakeDontRedo(NextNo As Long, ISeqs() As Long, RList() As Long, RNum() As Long, FAMat() As Single, SAMat() As Single, INList() As Byte, RCorr() As Single, DontRedo() As Byte)
Dim x As Long
'This is now using SAMatSmall and FAMatSmall (just too lazy to rename them)

    ReDim DontRedo(2, NextNo)
    Exit Sub
    For x = 0 To NextNo
        If FAMat(INList(1), x) < FAMat(INList(1), ISeqs(INList(0))) Then
           If SAMat(INList(1), x) < SAMat(INList(1), ISeqs(INList(2))) Then
                If RCorr(INList(1), 0, x) > 0.83 Or RCorr(INList(1), 1, x) > 0.83 Then
                    RList(INList(1), RNum(INList(1))) = x
                    RNum(INList(1)) = RNum(INList(1)) + 1
                    DontRedo(INList(1), x) = 1
                End If
           End If
        
        ElseIf FAMat(INList(0), x) < FAMat(INList(1), ISeqs(INList(0))) Then
           If SAMat(INList(0), x) < SAMat(INList(0), ISeqs(INList(1))) Then
                If RCorr(INList(0), 0, x) > 0.83 Or RCorr(INList(0), 1, x) > 0.83 Then
                    RList(INList(0), RNum(INList(0))) = x
                    RNum(INList(0)) = RNum(INList(0)) + 1
                    DontRedo(INList(0), x) = 1
                End If
           End If
        ElseIf FAMat(INList(2), x) < FAMat(INList(1), ISeqs(INList(2))) Then
           If SAMat(INList(2), x) < SAMat(INList(1), ISeqs(INList(2))) Then
                If RCorr(INList(2), 0, x) > 0.83 Or RCorr(INList(2), 1, x) > 0.83 Then
                    RList(INList(2), RNum(INList(2))) = x
                    RNum(INList(2)) = RNum(INList(2)) + 1
                    DontRedo(INList(2), x) = 1
                End If
           End If
        End If
    Next x
    x = x
End Sub
Public Sub TestPhprScore(NPh As Long, NextNo As Long, DoneThis() As Long, PhPRSignif() As Byte, PhPrScore() As Double)
    Dim TPVX As Double, x As Long
    NPh = 0
    For x = 0 To NextNo
        If DoneThis(0, x) = 0 Or DoneThis(1, x) = 0 Then
            NPh = NPh + 1
        End If
       
    Next x
    NPh = NPh + 3
    
    ReDim PhPRSignif(2)
    For x = 0 To 2
        If PhPrScore(x) >= 1 Then
            PhPrScore(x) = 0.99999999
        End If
        If PhPrScore(x) <= 0 Then
            PhPRSignif(x) = 0
        Else
           ' NPh = 6
           ' PhPrScore(X) = 0.83
            TPVX = PhPrScore(x) * Sqr((NPh - 2) / (1 - PhPrScore(x) * PhPrScore(x)))
            Dummy = ttestprob(TPVX, NPh - 2)
            TPVX = ((1 - Dummy) * 2)
            'TPVX = (1 - TPVX)
            If TPVX < 0.1 Then PhPRSignif(x) = 1 Else PhPRSignif(x) = 0
       End If
                                    
    Next x
End Sub

Public Sub DropSeqs(x As Long, StepNo As Long, NextNo As Long, Steps() As Long, RedoListSize As Long, RedoList() As Long, OriginalName() As String, MissingData() As Byte, SeqNum() As Integer, PermValid() As Single, PermDIffs() As Single, TempDone() As Byte, PXOList() As XOverDefine, PCurrentXover() As Integer, TraceSub() As Long, ActualSeqSize() As Long, MinSeqSize As Long, NumRecsI() As Long)
Dim UB As Long, Dummy As Long, oNR As Long, A As Long, Y As Long, Z As Long


Dim oNextno As Long
oNextno = NextNo


If PermNextno > MemPoc Then
    If UBound(PermValid, 1) = 0 Or UBound(PermValid, 2) = 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        ReDim PermValid(UBPermValid, UBPermValid)
        Open "RDP5PermValid" + UFTag For Binary As #FF
        Get #FF, , PermValid()
        Close #FF
        
        
        ReDim PermDIffs(UBPermDiffs, UBPermDiffs)
        Open "RDP5PermDiffs" + UFTag For Binary As #FF
        Get #FF, , PermDIffs()
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
    End If
End If
  ' x = PermNextno
'x = PermNextno + 1
x = x
Do While x <= NextNo
                
                If ActualSeqSize(x) < MinSeqSize Or NumRecsI(x) = 0 Then
                    If x < NextNo Then
                        ActualSeqSize(x) = ActualSeqSize(NextNo)
                        TraceSub(x) = TraceSub(NextNo)
                        PCurrentXover(x) = PCurrentXover(NextNo)
                        oNR = NumRecsI(x)
                        NumRecsI(x) = NumRecsI(NextNo)
                        
                        For Y = 1 To PCurrentXover(NextNo)
                            PXOList(x, Y) = PXOList(NextNo, Y)
                            PXOList(x, Y).Daughter = x
                        Next Y
                        'remove all references to x in every xoverlist other than x
                        
                        If oNR > 0 Then
                            For Y = 0 To NextNo
                                If Y <> x Then
                                    Z = 0
                                    Do While Z <= PCurrentXover(Y)
                                    
                                        If PXOList(Y, Z).MajorP = x Or PXOList(Y, Z).Daughter = x Or PXOList(Y, Z).MinorP = x Then
                                            If Z < PCurrentXover(Y) Then
                                                PXOList(Y, Z) = PXOList(Y, PCurrentXover(Y))
                                                PCurrentXover(Y) = PCurrentXover(Y) - 1
                                                Z = Z - 1
                                            Else
                                                PCurrentXover(Y) = PCurrentXover(Y) - 1
                                            End If
                                        End If
                                        Z = Z + 1
                                    Loop
                                End If
                            Next Y
                        End If
                        
                        
                       
                        'from here
                        '@
                        For Y = 0 To NextNo
                            
                            If Y <> x Then
                                For Z = 1 To PCurrentXover(Y)
                                    If PXOList(Y, Z).MajorP = NextNo Then
                                        PXOList(Y, Z).MajorP = x
                                    ElseIf PXOList(Y, Z).MinorP = NextNo Then
                                        PXOList(Y, Z).MinorP = x
                                    End If
                                    If Z <= UBound(TempDone, 2) Then
                                        TempDone(Y, Z) = 0
                                    End If
                                Next Z
                            End If
                        Next Y
                        'to here takes 27 seconds with pxolist 500 X1200
                       
                       
                        For Z = 0 To NextNo
                            If Z <> x Then
                                PermValid(x, Z) = PermValid(Z, NextNo)
                                PermDIffs(x, Z) = PermDIffs(Z, NextNo)
                            Else
                                PermValid(x, Z) = ActualSeqSize(x)
                                PermDIffs(x, Z) = 0
                            End If
                            PermValid(Z, x) = PermValid(x, Z)
                            PermDIffs(Z, x) = PermDIffs(x, Z)
                        Next Z
                        

                       
                         
                        Dummy = CopySeq(Len(StrainSeq(0)), NextNo, x, NextNo, SeqNum(0, 0))
                        
                        For Y = 1 To Len(StrainSeq(0))
                            MissingData(Y, x) = MissingData(Y, NextNo)
                        Next Y
                        
                        OriginalName(x) = OriginalName(NextNo)
                        If NextNo <= UBound(StraiName, 1) And x <= UBound(StraiName, 1) Then
                            StraiName(x) = StraiName(NextNo)
                            StraiName(NextNo) = ""
                        End If
                        OriginalName(NextNo) = ""
                       
                        'now remove all reference to X in redolist if necessary
                        '@'@
                        If RedoListSize > 0 Then
                            'If x = x Then
'                                Dim RL2 As Long, RL3() As Long
'                                ReDim RL3(UBound(RedoList, 1), UBound(RedoList, 2))
'                                For Z = 0 To UBound(RedoList, 2)
'                                    For A = 0 To UBound(RedoList, 1)
'                                        RL3(A, Z) = RedoList(A, Z)
'                                    Next A
'                                Next Z
'                                RL2 = RedoListSize
                                Dummy = CleanRedo(1, x, NextNo, RedoListSize, UBound(RedoList, 1), RedoList(0, 0))
'                            Else
'                                Z = 0
'                                Do While Z <= RedoListSize
'                                    For A = 1 To 3
'                                        If RedoList(A, Z) = x Then
'                                            Exit For
'                                        End If
'                                    Next A
'                                    If A < 4 Then
'                                        For A = 0 To 3
'                                            RedoList(A, Z) = RedoList(A, RedoListSize)
'                                        Next A
'                                        RedoListSize = RedoListSize - 1
'                                    Else
'                                        Z = Z + 1
'                                    End If
'                                Loop
'
'                                'now reidentify all the nextnos as x
'                                For Z = 0 To RedoListSize
'                                    For A = 1 To 3
'                                        If RedoList(A, Z) = NextNo Then
'                                            RedoList(A, Z) = x
'                                            Exit For
'                                        End If
'                                    Next A
'                                Next Z
''                                If RL2 <> RedoListSize Then
''                                    x = x
''                                End If
''                                For Z = 0 To UBound(RedoList, 2)
''                                    For A = 0 To UBound(RedoList, 1)
''                                        If RL3(A, Z) <> RedoList(A, Z) Then
''                                            x = x
''                                        End If
''                                    Next A
''                                Next Z
'                            End If
                            
                        End If
'                        If x = NextNo Then
'                            Steps(0, StepNo) = 3 'ie delete a sequence ....
'                            Steps(1, StepNo) = NextNo 'this is the seqence.....
'                            Steps(4, StepNo) = SEventNumber + 1
'                            StepNo = StepNo + 1
'
'                            UB = UBound(Steps, 2)
'                            If StepNo > UB Then
'                                ReDim Preserve Steps(4, UB + 100)
'                            End If
'                            NextNo = NextNo - 1
'                        Else
'                            XX = NextNo
'                            XX = SEventNumber
                            Steps(0, StepNo) = 4 'ie replace a sequence with nextno....
                            Steps(1, StepNo) = x 'this is the seqence.....
                            Steps(4, StepNo) = SEventNumber + 1
                            StepNo = StepNo + 1
                            UB = UBound(Steps, 2)
                            If StepNo > UB Then
                                ReDim Preserve Steps(4, UB + 100)
                            End If
                            Steps(0, StepNo) = 3 'ie delete a sequence
                            Steps(1, StepNo) = x 'this is the seqence.....
                            Steps(4, StepNo) = SEventNumber + 1
                            StepNo = StepNo + 1
                           
                            UB = UBound(Steps, 2)
                            If StepNo > UB Then
                                ReDim Preserve Steps(4, UB + 100)
                            End If
                        'End If
                        
                    Else
                        For Y = 0 To PermNextno
                                Z = 0
                                Do While Z <= PCurrentXover(Y)
                                    If PXOList(Y, Z).MajorP = NextNo Or PXOList(Y, Z).Daughter = NextNo Or PXOList(Y, Z).MinorP = NextNo Then
                                        PXOList(Y, Z) = PXOList(Y, PCurrentXover(Y))
                                        PCurrentXover(Y) = PCurrentXover(Y) - 1
                                    Else
                                        Z = Z + 1
                                    End If
                                Loop
                        Next Y
                        '$'$
                        If RedoListSize > 0 Then
                            'If x = x Then
                                Dummy = CleanRedo(0, x, NextNo, RedoListSize, UBound(RedoList, 1), RedoList(0, 0))
'
'                            Else
'                                Z = 0
'                                Do While Z <= RedoListSize
'                                    For A = 1 To 3
'                                        If RedoList(A, Z) = x Then
'                                            Exit For
'                                        End If
'                                    Next A
'                                    If A < 4 Then
'                                        For A = 0 To 3
'                                            RedoList(A, Z) = RedoList(A, RedoListSize)
'                                        Next A
'                                        RedoListSize = RedoListSize - 1
'                                    Else
'                                        Z = Z + 1
'                                    End If
'                                Loop
'                            End If
                        End If
'                        XX = SEventNumber
'                        XX = NextNo
'                        XX = PermNextno
                        StraiName(NextNo) = ""
                        
                        OriginalName(NextNo) = ""
                        'If x = NextNo Then
                            Steps(0, StepNo) = 3 'ie delete a sequence ....
                            Steps(1, StepNo) = NextNo 'this is the seqence.....
                            Steps(4, StepNo) = SEventNumber + 1
                            StepNo = StepNo + 1
                           
                            UB = UBound(Steps, 2)
                            If StepNo > UB Then
                                ReDim Preserve Steps(4, UB + 100)
                            End If
                            'NextNo = NextNo - 1
'                        Else
'                            Steps(0, StepNo) = 4 'ie replace a sequence with nextno....
'                            Steps(1, StepNo) = x 'this is the seqence.....
'                            Steps(4, StepNo) = SEventNumber + 1
'                            StepNo = StepNo + 1
'                            UB = UBound(Steps, 2)
'                            If StepNo > UB Then
'                                ReDim Preserve Steps(4, UB + 100)
'                            End If
'                            Steps(0, StepNo) = 3 'ie delete a sequence
'                            Steps(1, StepNo) = x 'this is the seqence.....
'                            Steps(4, StepNo) = SEventNumber + 1
'                            StepNo = StepNo + 1
'
'                            UB = UBound(Steps, 2)
'                            If StepNo > UB Then
'                                ReDim Preserve Steps(4, UB + 100)
'                            End If
'                        End If
                        
                    End If
'                    'add to steps - this should now be added in checkdrops
'                    Steps(0, StepNo) = 3 'ie delete a sequence ....
'                    Steps(1, StepNo) = x 'delete this seqence.....
'                    Steps(4, StepNo) = SEventNumber + 1
'                    StepNo = StepNo + 1
'                    UB = UBound(Steps, 2)
'                    If StepNo > UB Then
'                        ReDim Preserve Steps(4, UB + 100)
'                    End If
                    
                    NextNo = NextNo - 1
                Else
                    x = x + 1
                End If
                
            Loop
            
'If PermNextno > MemPoc Then
'    If (UBound(PermValid, 1) > 0 Or UBound(PermDiffs, 1) > 0) And oNextno <> Nextno Then
'
'        oDirX = CurDir
'        ChDrive App.Path
'        ChDir App.Path
'        FF = FreeFile
'
'        Dim TValid() As Single, TDiffs() As Single
'
'
'        ReDim TValid(Nextno, Nextno)
'
'        Dummy = CopyFloatArray(Nextno, UBound(TValid, 1), UBound(PermValid, 1), PermValid(0, 0), TValid(0, 0))
'
'        UBPermValid = Nextno
'        Open "RDP5PermValid" + UFTag For Binary As #FF
'        Put #FF, , TValid()
'        Close #FF
'        ReDim PermValid(0, 0)
'        Erase TValid
'
'        ReDim TDiffs(Nextno, Nextno)
'
'        Dummy = CopyFloatArray(Nextno, UBound(TDiffs, 1), UBound(PermDiffs, 1), PermDiffs(0, 0), TDiffs(0, 0))
'
'        UBPermDiffs = Nextno
'        Open "RDP5PermDiffs" + UFTag For Binary As #FF
'        Put #FF, , TDiffs()
'        Close #FF
'        ReDim PermDiffs(0, 0)
'        ChDrive oDirX
'        ChDir oDirX
'
'    End If
''ElseIf oNextno <> Nextno Then
''    ReDim TValid(Nextno, Nextno)
''    Dummy = CopyFloatArray(Nextno, UBound(TValid, 1), UBound(PermValid, 1), PermValid(0, 0), TValid(0, 0))
''    ReDim PermValid(Nextno, Nextno)
''    Dummy = CopyFloatArray(Nextno, UBound(PermValid, 1), UBound(TValid, 1), TValid(0, 0), PermValid(0, 0))
''    ReDim TDiffs(Nextno, Nextno)
''    Dummy = CopyFloatArray(Nextno, UBound(TDiffs, 1), UBound(PermDiffs, 1), PermDiffs(0, 0), TDiffs(0, 0))
''    ReDim PermDiffs(Nextno, Nextno)
''    Dummy = CopyFloatArray(Nextno, UBound(PermDiffs, 1), UBound(TDiffs, 1), TDiffs(0, 0), PermDiffs(0, 0))
'ElseIf Nextno < oNextno Then
'
'
'                ReDim TValid(Nextno, Nextno), TDiffs(Nextno, Nextno)
'
'                'If X = X Then
'                    Dummy = CopyFloatArray(Nextno, UBound(TValid, 1), UBound(PermValid, 1), PermValid(0, 0), TValid(0, 0))
'                    Dummy = CopyFloatArray(Nextno, UBound(TDiffs, 1), UBound(PermDiffs, 1), PermDiffs(0, 0), TDiffs(0, 0))
''                Else
''                    For X = 0 To Nextno
''                        For Y = 0 To Nextno
''                            TValid(X, Y) = PermValid(X, Y)
''                            TDiffs(X, Y) = PermDiffs(X, Y)
''
''                        Next Y
''                    Next X
''                End If
'                ReDim PermValid(Nextno, Nextno), PermDiffs(Nextno, Nextno)
'
'                'If X = X Then
'                    Dummy = CopyFloatArray(Nextno, UBound(PermValid, 1), UBound(TValid, 1), TValid(0, 0), PermValid(0, 0))
'                    Dummy = CopyFloatArray(Nextno, UBound(PermDiffs, 1), UBound(TDiffs, 1), TDiffs(0, 0), PermDiffs(0, 0))
''                Else
''
''                    For X = 0 To Nextno
''                        For Y = 0 To Nextno
''                            PermValid(X, Y) = TValid(X, Y)
''                            PermDiffs(X, Y) = TDiffs(X, Y)
''                        Next Y
''                    Next X
''                End If
'End If

End Sub

Public Sub MakeSSDist(ISeqs() As Long, SSDist() As Double, FMat() As Single, SMat() As Single, NextNo As Long, DoneThis() As Long)
Dim Y As Long, x As Long, sa As Double, TDist As Double, DI(1) As Single

DI(0) = 0: DI(1) = 0

If x = x Then
    Dummy = MakeDI(NextNo, UBound(DoneThis, 1), UBound(FMat, 1), DI(0), FMat(0, 0), SMat(0, 0), DoneThis(0, 0))
Else
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            If (DoneThis(0, x) = 0 Or DoneThis(1, x) = 0) And (DoneThis(0, Y) = 0 Or DoneThis(1, Y) = 0) Then
                DI(0) = DI(0) + FMat(x, Y)
                DI(1) = DI(1) + SMat(x, Y)
                
            End If
        Next Y
    Next x
End If
If DI(1) > 0 Then
    sa = DI(0) / DI(1)
Else
    SSDist(0) = 0
    SSDist(1) = 0
    SSDist(2) = 0
    Exit Sub
End If
For x = 0 To 2
    SSDist(x) = 0
    For Y = 0 To NextNo
        If DoneThis(0, Y) = 0 Or DoneThis(1, Y) = 0 Then
            TDist = FMat(ISeqs(x), Y) - SMat(ISeqs(x), Y) * sa
            TDist = (TDist) ^ 2
            SSDist(x) = SSDist(x) + TDist
        End If
    Next Y
    x = x
Next x
End Sub
Public Sub MakeSSDistB(ISeqs() As Long, SSDist() As Double, FAMatSmall() As Single, FMat() As Single, SMat() As Single, NextNo As Long, DoneThis() As Long)
Dim Dummy As Long, Z As Long, Y As Long, x As Long, sa As Single, TDist As Single, DI(1) As Single
Dim NG() As Long, ScoreArray() As Single, UB As Long



DI(0) = 0: DI(1) = 0
'**************************************do a C version*********************************************
'If X = X Then
    Dummy = MakeDI(NextNo, UBound(DoneThis, 1), UBound(FMat, 1), DI(0), FMat(0, 0), SMat(0, 0), DoneThis(0, 0))
'Else
'
'    For X = 0 To Nextno
'        For Y = X + 1 To Nextno
'            If (DoneThis(0, X) = 0 Or DoneThis(1, X) = 0) And (DoneThis(0, Y) = 0 Or DoneThis(1, Y) = 0) Then
'
'                DI(0) = DI(0) + FMat(X, Y)
'                DI(1) = DI(1) + SMat(X, Y)
'
'            End If
'        Next Y
'    Next X


If DI(1) > 0 Then
    sa = DI(0) / DI(1) 'a ratio of distances sa<0 means there is a higher density of polymorphic sites between the
                        'breakpoints
Else
    SSDist(0) = 0
    SSDist(1) = 0
    SSDist(2) = 0
    Exit Sub
End If
Dim MVal As Single
'find the maximum treedistance(*1000) - it will be used to store node distances



For x = 0 To 2
    MVal = 0
    For Y = 0 To NextNo
        If FAMatSmall(x, Y) * 1000 > MVal Then MVal = FAMatSmall(x, Y) * 1000
    Next Y
    MVal = CLng(MVal + 1)
    
    SSDist(x) = 0
    ReDim ScoreArray(MVal), NG(MVal)
    For Y = 0 To NextNo
    
        If DoneThis(0, Y) = 0 Or DoneThis(1, Y) = 0 Then
            Z = CLng(FAMatSmall(x, Y) * 1000)
            TDist = Abs(FMat(ISeqs(x), Y) - SMat(ISeqs(x), Y)) * sa
            TDist = (TDist) ^ 2
            If Z <= MVal Then
                ScoreArray(Z) = ScoreArray(Z) + TDist
                NG(Z) = NG(Z) + 1
            End If
        
        End If
    Next Y
    For Y = 0 To MVal
        If NG(Y) > 0 Then
            SSDist(x) = SSDist(x) + ScoreArray(Y) / NG(Y)
        End If
    Next Y
Next x

End Sub

Public Sub MakeTreeMat(NextNo As Long, TreeMat() As Byte, FAMat() As Single)
Dim Y As Long, x As Long, Holder As Double


For x = 0 To NextNo - 1
    For Y = x + 1 To NextNo
        Holder = FAMat(x, Y) * 1000
        Holder = CLng(Holder)
        If Holder <= NextNo Then
            TreeMat(Holder, x) = 1
            TreeMat(Holder, Y) = 1
        End If
        
    Next Y
Next x

End Sub

Public Sub SimpleDist(RankF() As Long, NextNo As Long, SimScore() As Byte, SimScoreB() As Double, RList() As Long, RNum() As Long, INList() As Byte, ISeqs() As Long, FMat() As Single, SMat() As Single)
Dim Dummy As Long, Z As Long, x As Long, Y As Long, DontUse() As Byte, Tot() As Single, Counter As Double, Addj As Double
 
ReDim DontUse(NextNo), SimScore(2), SimScoreB(2)

For Z = 0 To 2
    For x = 0 To RNum(Z) '6,0,0
        DontUse(RList(Z, x)) = 1
        
    Next x
Next Z
ReDim Tot(1)

If x = x Then
    Dummy = MakeTots(NextNo, UBound(FMat, 1), Tot(0), FMat(0, 0), SMat(0, 0), DontUse(0))
Else
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            If DontUse(x) = 0 And DontUse(Y) = 0 Then
                If FMat(x, Y) < 3 Then
                    Tot(0) = Tot(0) + FMat(x, Y)
                    Tot(1) = Tot(1) + SMat(x, Y)
                End If
            End If
        Next Y
    Next x
End If


'test rank changes
'test to see if some of the iseqs are overly outlyerish - could indicate that they have recombined with something outside the dataset
'need to do this because it creates fake signals of corecombination
Dim MoveDistF() As Single, MoveDistS() As Single
ReDim MoveDistF(NextNo), MoveDistS(NextNo)
'@'@'$
'If x = x Then
    Dummy = MakeMoveDist(NextNo, MoveDistF(0), MoveDistS(0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0))
'Else
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            MoveDistF(x) = MoveDistF(x) + FMat(x, Y)
'            MoveDistS(x) = MoveDistS(x) + SMat(x, Y)
'        Next Y
'    Next x
'End If




'work out the ranking of the iseqs in the two lists
Dim MDF As Single, MDS As Single
For x = 0 To 2
    MDF = MoveDistF(ISeqs(x))
    MDS = MoveDistS(ISeqs(x))
    RankF(x, 0) = 0
    RankF(x, 1) = 0
    For Y = 0 To NextNo
        If MDF > MoveDistF(Y) Then RankF(x, 0) = RankF(x, 0) + 1
        If MDS > MoveDistS(Y) Then RankF(x, 1) = RankF(x, 1) + 1
    Next Y
    
    x = x
Next x

'EE = Abs(GetTickCount)
'TT = EE - SS '1.092


If Tot(0) > 0 And Tot(1) > 0 Then '42.6091706,18.498428
    Addj = Tot(0) / Tot(1)
Else
    Addj = 1
End If

Dim Diff() As Double
ReDim Diff(2)
If UBound(FMat, 1) < NextNo Then
    ReDim FMat(NextNo, NextNo)
    
End If
If UBound(SMat, 1) < NextNo Then
    ReDim SMat(NextNo, NextNo)
    
End If

Diff(0) = Abs(FMat(ISeqs(INList(0)), ISeqs(INList(2))) - SMat(ISeqs(INList(0)), ISeqs(INList(2))) * Addj)
Diff(1) = SMat(ISeqs(INList(0)), ISeqs(INList(1))) * Addj - FMat(ISeqs(INList(0)), ISeqs(INList(1)))
Diff(2) = (FMat(ISeqs(INList(1)), ISeqs(INList(2))) - SMat(ISeqs(INList(1)), ISeqs(INList(2))) * Addj)
If Diff(0) < Diff(1) And Diff(0) < Diff(2) Then
    SimScore(INList(1)) = SimScore(INList(1)) + 1
End If
SimScoreB(INList(1)) = Diff(1) + Diff(2) - Diff(0)

Diff(0) = Abs(FMat(ISeqs(INList(1)), ISeqs(INList(2))) - SMat(ISeqs(INList(1)), ISeqs(INList(2))) * Addj)
Diff(1) = SMat(ISeqs(INList(0)), ISeqs(INList(1))) * Addj - FMat(ISeqs(INList(0)), ISeqs(INList(1)))
Diff(2) = SMat(ISeqs(INList(0)), ISeqs(INList(2))) * Addj - FMat(ISeqs(INList(0)), ISeqs(INList(2)))
If Diff(0) < Diff(1) And Diff(0) < Diff(2) Then
    SimScore(INList(0)) = SimScore(INList(0)) + 1
End If
SimScoreB(INList(0)) = Diff(1) + Diff(2) - Diff(0)

Diff(0) = Abs(FMat(ISeqs(INList(0)), ISeqs(INList(1))) - SMat(ISeqs(INList(0)), ISeqs(INList(1))) * Addj)
Diff(1) = FMat(ISeqs(INList(1)), ISeqs(INList(2))) - SMat(ISeqs(INList(1)), ISeqs(INList(2))) * Addj
Diff(2) = FMat(ISeqs(INList(0)), ISeqs(INList(2))) - SMat(ISeqs(INList(0)), ISeqs(INList(2))) * Addj

If Diff(0) < Diff(1) And Diff(0) < Diff(2) Then
    SimScore(INList(2)) = SimScore(INList(2)) + 1
End If

SimScoreB(INList(2)) = Diff(1) + Diff(2) - Diff(0)



End Sub

Public Sub ConsensusOK(NextNo As Long, ISeqs() As Long, OKSeq() As Double, RNum() As Long, RList() As Long, RCorrX() As Single)


Dim A As Long, GoOn As Long, NS As Long, x As Long, Y As Long, Z As Long, CScore() As Double, IsIn() As Byte
ReDim CScore(2, NextNo)
ReDim IsIn(2, NextNo)

'0=correlation pval
'1 = maximum overlap of identified fragments
'2 = findsets result
'3 = Checkpattern score
'4 = rlist before finaltrim
'5 = Strip duplicates result
'6 = finaltrim mainsequence result
'7 = positions in full sequence Bootstraped trees
'8 = positions in NJ trees (no collapsed branches)
'9 = relative distances
'10 = left breakpoint tree
'11 = right breakpoint tree
'12 = left breakpoint distances
'13 = right breakpoint distances
'14 = distances between identified recombinant regions
'15 = finaltrim end result
'17 = calcmatch of regions
'18 = calcmatch of best breakpoints

For x = 0 To 2
    For Y = 0 To NextNo
        
        If Y <> ISeqs(0) And Y <> ISeqs(1) And Y <> ISeqs(2) Then
'If ISeqs(X) = 41 And Y = 63 And SEventNumber = 63 Then
'
'                        X = X
'                    End If
            CScore(x, Y) = 0
            If OKSeq(x, 0, Y) > 0 And OKSeq(x, 0, Y) < 1 Then
                CScore(x, Y) = CScore(x, Y) + -Log10(OKSeq(x, 0, Y)) * 20 'correlation
            End If
            CScore(x, Y) = CScore(x, Y) + OKSeq(x, 1, Y) * 5 'max overlap of detected frag
            CScore(x, Y) = CScore(x, Y) + OKSeq(x, 3, Y) * 4 'proportion phylogenetically informative sites
                                                             'supporting grouping with query over parentals
            'XX = -Log10(0.05) * 20
            If OKSeq(x, 2, Y) = 1 And OKSeq(x, 4, Y) = 1 Then 'is it part of rlist and/or rlist2
                CScore(x, Y) = CScore(x, Y) * 1.2
            ElseIf OKSeq(x, 2, Y) = 1 Or OKSeq(x, 4, Y) = 1 Then
                CScore(x, Y) = CScore(x, Y) * 1.1
            End If
            
            
            If OKSeq(x, 5, Y) = 1 Then
                CScore(x, Y) = CScore(x, Y) * 1.1
            End If
            If OKSeq(x, 6, Y) = 1 Then
                CScore(x, Y) = CScore(x, Y) * 1.1
            End If
            If OKSeq(x, 15, Y) = 1 Then
                CScore(x, Y) = CScore(x, Y) * 2
            End If
            NS = 0
            CScore(x, Y) = (CScore(x, Y) + RCorrX(x, Y)) * RCorrX(x, Y)
            
            NS = NS + (OKSeq(x, 7, Y) + OKSeq(x, 8, Y)) / 2 '- okseq 7 is for bootstrapped tree with branches < 50 support collapsed - 8 is for the tree with uncollapsed branches
            For Z = 9 To 14
                If OKSeq(x, Z, Y) <> 0 Then
                    'CScore(X, Y) = CScore(X, Y) * 1.05
                    NS = NS + OKSeq(x, Z, Y) '7=6, 8=6, '14 = -0.5
                End If
            Next Z
            
            If NS < 1 Then
            NS = -0.5
                NS = 1 - NS
                NS = 2 ^ -NS '1 / NS
                
            End If
            CScore(x, Y) = CScore(x, Y) * NS
            x = x
        ElseIf Y = ISeqs(x) Then
            CScore(x, Y) = 1000
        
        End If
    Next Y
    
Next x
Dim oRList() As Long, oRNum(2) As Long
ReDim oRList(2, NextNo)
oRNum(0) = RNum(0): oRNum(1) = RNum(1): oRNum(2) = RNum(2)
For Y = 0 To 2
    For x = 0 To RNum(Y)
        oRList(Y, x) = RList(Y, x)
    Next x
Next Y

RNum(0) = -1: RNum(1) = -1: RNum(2) = -1

'If SEventNumber = 19 Then
'    X = X
'    XX = originalname(ISeqs(0))
'    XX = originalname(ISeqs(1))
'    XX = originalname(ISeqs(2))
'    XX = originalname(Y)
'End If
'38 - aj890346 - should be in
'18 - aj890350 - shouldn't be in
'If SEventNumber = 3 Or SEventNumber = 4 Then
'    X = X
'End If
'If SEventNumber = 4 Then
'    X = X
'End If


For x = 0 To 2
    For Y = 0 To NextNo
        
        If OKSeq(x, 18, Y) > -1 Then
            If x = 0 Then
                
                If FAMatSmall(0, ISeqs(1)) < FAMatSmall(0, ISeqs(2)) Then
                    If FAMatSmall(1, Y) > FAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf FAMatSmall(0, ISeqs(1)) > FAMatSmall(0, ISeqs(2)) Then
                    If FAMatSmall(1, Y) < FAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
                If SAMatSmall(0, ISeqs(1)) < SAMatSmall(0, ISeqs(2)) Then
                    If SAMatSmall(1, Y) > SAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf SAMatSmall(0, ISeqs(1)) > SAMatSmall(0, ISeqs(2)) Then
                    If SAMatSmall(1, Y) < SAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
            ElseIf x = 1 Then
                If FAMatSmall(1, ISeqs(0)) < FAMatSmall(1, ISeqs(2)) Then
                    If FAMatSmall(0, Y) > FAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf FAMatSmall(1, ISeqs(0)) > FAMatSmall(1, ISeqs(2)) Then
                    If FAMatSmall(0, Y) < FAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
                If SAMatSmall(1, ISeqs(0)) < SAMatSmall(1, ISeqs(2)) Then
                    If SAMatSmall(0, Y) > SAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf SAMatSmall(1, ISeqs(0)) > SAMatSmall(1, ISeqs(2)) Then
                    If SAMatSmall(0, Y) < SAMatSmall(2, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
            Else
                XX = ISeqs(0)
                XX = ISeqs(1)
'                XX = FAMat(8, 16)
'                XX = FAMat(9, 19)
                If FAMatSmall(2, ISeqs(0)) < FAMatSmall(2, ISeqs(1)) Then ' i clusters more closely with 16 than it does with 19
                    If FAMatSmall(0, Y) > FAMatSmall(1, Y) Then 'but j clusters more closely with 19 than 16
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf FAMatSmall(2, ISeqs(0)) > FAMatSmall(2, ISeqs(1)) Then
                    If FAMatSmall(0, Y) < FAMatSmall(1, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
                If SAMatSmall(2, ISeqs(0)) < SAMatSmall(2, ISeqs(1)) Then
                    If SAMatSmall(0, Y) > SAMatSmall(1, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                ElseIf SAMatSmall(2, ISeqs(0)) > SAMatSmall(2, ISeqs(1)) Then
                    If SAMatSmall(0, Y) < SAMatSmall(1, Y) Then
                        OKSeq(x, 18, Y) = -1
                    End If
                End If
                x = x
            End If
        End If
        
        
        
    Next Y
Next x


'If SEventNumber = 63 Then
'    X = X
'End If
If PermNextno > MemPoc Then
    GetSAMat
    GetFAMat
    GetSMat
    GetFMat
End If
For x = 0 To 2
    For Y = 0 To NextNo
'    If ISeqs(X) = 45 And Y = 16 And SEventNumber = 25 Then '34,35,16, 17
'        X = X
'
'    End If
'    If ISeqs(X) = 41 And Y = 63 And SEventNumber = 63 Then
'
'                        X = X
'                    End If

    
    '19,31,32,33,34,37,38,40,46(10),47(11),48(12),50(14),52(16),*54(18)*,55(22),56(23),*57(24)*,58(25),59(27),60(28),61(29),*62(36)*,63(41),65(45)
    'If X = 1 And Y = 30 Then
    ''18 - 0:? 0:aj585197mip 0:aj439545map
    ''38 - 1:? 1:aj585197mip 0:aj439545map
   '
   '     X = X
   ' End If
   
   
   
        GoOn = 0
        If OKSeq(x, 18, Y) > -1 Then
            If (((CScore(x, Y) > 30 And OKSeq(x, 17, Y) > 0.05) Or ((CScore(x, Y) * OKSeq(x, 17, Y)) > 2))) And OKSeq(x, 18, Y) = 1 Then
                'XX = RList(X, 0)
                RNum(x) = RNum(x) + 1
                RList(x, RNum(x)) = Y
                
                'XX = originalname(Y)
                
            ElseIf OKSeq(x, 17, Y) > 0.1 And OKSeq(x, 18, Y) = 1 Then
                RNum(x) = RNum(x) + 1
                RList(x, RNum(x)) = Y
                'XX = SEventNumber
                
                'XX = originalname(Y) '24,22,24,25,27
                'XX = ISeqs(X) '10,37,37,37,37
            
            Else
                'check if it groups with other sequences that are OK in both the smatc and fmatc matrices
                GoOn = 0
                If (((CScore(x, Y) > 30 And OKSeq(x, 17, Y) > 0.05) Or ((CScore(x, Y) * OKSeq(x, 17, Y)) > 2))) And OKSeq(x, 18, Y) > 0 Then
                    For A = 0 To NextNo
                        'If InRNum(A) = 1 Then
                            If OKSeq(x, 18, A) = 1 And A <> Y Then
                                If SAMatSmall(x, A) >= SAMatSmall(x, Y) And FAMatSmall(x, A) >= FAMatSmall(x, Y) Then
                                    RNum(x) = RNum(x) + 1
                                    RList(x, RNum(x)) = Y
                                     GoOn = 1
                                     Exit For
                                End If
                            End If
                        'End If
                    Next A
                    x = x
                ElseIf OKSeq(x, 18, Y) > 1 Then
                    For A = 0 To NextNo
                        If OKSeq(x, 18, A) = 1 And A <> Y Then
                            If SAMatSmall(x, A) >= SAMatSmall(x, Y) And FAMatSmall(x, A) >= FAMatSmall(x, Y) Then
                                RNum(x) = RNum(x) + 1
                                RList(x, RNum(x)) = Y
                                 GoOn = 1
                                 Exit For
                            End If
                        End If
                    Next A
                End If
                If DebuggingFlag < 2 Then On Error Resume Next
                UBFC = 0
                UBFC = UBound(FCMatSmall, 2)
                On Error GoTo 0
                If GoOn = 0 And UBFC > 0 Then
                    If OKSeq(x, 18, Y) > 0 Then
                        GoOn = 0
                        If x = 0 Then
                    
                            If FCMatSmall(0, ISeqs(1)) >= FCMatSmall(1, Y) And FCMatSmall(0, ISeqs(2)) >= FCMatSmall(2, Y) And SCMatSmall(0, ISeqs(1)) >= SCMatSmall(1, Y) And SCMatSmall(0, ISeqs(2)) >= SCMatSmall(2, Y) Then
                                GoOn = 1
                            ElseIf FMat(ISeqs(0), Y) = 0 And SMat(ISeqs(0), Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        ElseIf x = 1 Then
                            If FCMatSmall(1, ISeqs(0)) >= FCMatSmall(0, Y) And FCMatSmall(1, ISeqs(2)) >= FCMatSmall(2, Y) And SCMatSmall(1, ISeqs(0)) >= SCMatSmall(0, Y) And SCMatSmall(1, ISeqs(2)) >= SCMatSmall(2, Y) Then
                                GoOn = 1
                            ElseIf FMat(ISeqs(1), Y) = 0 And SMat(ISeqs(1), Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        Else
                            If FCMatSmall(2, ISeqs(1)) >= FCMatSmall(1, Y) And FCMatSmall(2, ISeqs(0)) >= FCMatSmall(0, Y) And SCMatSmall(2, ISeqs(1)) >= SCMatSmall(1, Y) And SCMatSmall(2, ISeqs(0)) >= SCMatSmall(0, Y) Then
                                GoOn = 1
                            ElseIf FMat(ISeqs(2), Y) = 0 And SMat(ISeqs(2), Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        End If
                    End If
                    If GoOn = 0 Then
                    'Else
                        GoOn = 0
                        If x = 0 Then
                    
                            If FAMatSmall(0, ISeqs(1)) = FAMatSmall(1, Y) And FAMatSmall(0, ISeqs(2)) = FAMatSmall(2, Y) And SAMatSmall(0, ISeqs(1)) = SAMatSmall(1, Y) And SAMatSmall(0, ISeqs(2)) = SAMatSmall(2, Y) Then
                                GoOn = 1
                            ElseIf FMat(0, Y) = 0 And SMat(0, Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        ElseIf x = 1 Then
                            If FAMatSmall(1, ISeqs(0)) = FAMatSmall(0, Y) And FAMatSmall(1, ISeqs(2)) = FAMatSmall(2, Y) And SAMatSmall(1, ISeqs(0)) = SAMatSmall(0, Y) And SAMatSmall(1, ISeqs(2)) = SAMatSmall(2, Y) Then
                                GoOn = 1
                            ElseIf FMat(ISeqs(1), Y) = 0 And SMat(ISeqs(1), Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        Else
                            If FAMatSmall(2, ISeqs(1)) = FAMatSmall(1, Y) And FAMatSmall(2, ISeqs(0)) = FAMatSmall(0, Y) And SAMatSmall(2, ISeqs(1)) = SAMatSmall(1, Y) And SAMatSmall(2, ISeqs(0)) = SAMatSmall(0, Y) Then
                                GoOn = 1
                            ElseIf FMat(ISeqs(2), Y) = 0 And SMat(ISeqs(2), Y) = 0 Then
                                GoOn = 1
                            
                            End If
                        End If
                    End If
                    If GoOn = 1 Then
                        RNum(x) = RNum(x) + 1
                        RList(x, RNum(x)) = Y
                        
                    End If
                End If
            End If
        End If
    Next Y
    Dim InRNum() As Byte
    ReDim InRNum(NextNo)
    For Y = 0 To RNum(x)
        InRNum(RList(x, Y)) = 1
    Next Y
    XX = RNum(2)
    For Y = 0 To NextNo
        If OKSeq(x, 18, Y) > -1 Then

            If InRNum(Y) = 0 And (OKSeq(x, 18, Y) > 0 Or ConservativeGroup = 1) Then
                If (((CScore(x, Y) > 30 And OKSeq(x, 17, Y) > 0.05) Or ((CScore(x, Y) * OKSeq(x, 17, Y)) > 2))) Then
                    For A = 0 To NextNo
                        If InRNum(A) = 1 And OKSeq(x, 18, A) > 0 And A <> Y Then
                            'If OKSeq(X, 18, A) > 0 Then
                            If SAMatSmall(2, A) = SAMatSmall(2, Y) And FAMatSmall(2, A) = FAMatSmall(2, Y) And SAMatSmall(1, A) = SAMatSmall(1, Y) And FAMatSmall(1, A) = FAMatSmall(1, Y) And SAMatSmall(0, A) = SAMatSmall(0, Y) And FAMatSmall(0, A) = FAMatSmall(0, Y) Then
                                RNum(x) = RNum(x) + 1
                                RList(x, RNum(x)) = Y
                                 
                                 Exit For
                            End If
                            'End If
                        End If
                    Next A
                ElseIf OKSeq(x, 18, Y) > 0 Then
                    For A = 0 To NextNo
                        If InRNum(A) = 1 And A <> Y Then
                            'If OKSeq(X, 18, A) > 0 Then
                            If SMat(ISeqs(x), A) > SMat(A, Y) And FMat(ISeqs(x), A) > FMat(A, Y) Then
                                RNum(x) = RNum(x) + 1
                                RList(x, RNum(x)) = Y
                                 
                                 Exit For
                            End If
                            'End If
                        End If
                    Next A
                    'X = X
                End If
            End If
        End If
    Next Y
    
    
    'RNum(X) = RNum(X) - 1
    
    
    'collect all of the stragglers
    ReDim InRNum(NextNo)
    For Y = 0 To RNum(x)
        InRNum(RList(x, Y)) = 1
    Next Y
    
    
    
    If PermNextno > MemPoc And x = 1234567 Then
'        Dim OKtoAdd() As Byte
'        ReDim OKtoAdd(NextNo, NextNo) 'element 0 = fmatOK, element 1 smat, element 2 famat, element 3 samat
'
'        'GetFMat
'        For Y = 0 To NextNo
'            If OKSeq(x, 18, Y) > -1 Then
'                If InRNum(Y) = 0 Then
'                    For A = 0 To NextNo
'                        If InRNum(A) = 1 And A <> Y Then
'                            If FMatSmall(x, A) >= FMat(A, Y) Then
'                                OKtoAdd(A, Y) = OKtoAdd(A, Y) + 1
'                                Exit For
'                            End If
'                        End If
'                    Next A
'                End If
'            End If
'        Next Y
'        'GetSMat
'        For Y = 0 To NextNo
'            If OKSeq(x, 18, Y) > -1 Then
'                If InRNum(Y) = 0 Then
'                    For A = 0 To NextNo
'                        If InRNum(A) = 1 And A <> Y Then
'                            If SMatSmall(x, A) >= SMat(A, Y) Then
'                                OKtoAdd(A, Y) = OKtoAdd(A, Y) + 1
'                            End If
'                        End If
'                    Next A
'                End If
'            End If
'        Next Y
'        'GetFAMat
'
'        For Y = 0 To NextNo
'            If OKSeq(x, 18, Y) > -1 Then
'                If InRNum(Y) = 0 Then
'                    For A = 0 To NextNo
'                        If InRNum(A) = 1 And A <> Y Then
'                            If FAMatSmall(x, A) >= FAMat(A, Y) Then
'                                OKtoAdd(A, Y) = OKtoAdd(A, Y) + 1
'                            End If
'                        End If
'                    Next A
'
'
'                End If
'            End If
'
'        Next Y
'
'        Call GetSAMat
'
'        For Y = 0 To NextNo
'            If OKSeq(x, 18, Y) > -1 Then
'                If InRNum(Y) = 0 Then
'                    For A = 0 To NextNo
'                        If InRNum(A) = 1 And A <> Y Then
'                            If SAMatSmall(x, A) >= SAMat(A, Y) Then
'                                OKtoAdd(A, Y) = OKtoAdd(A, Y) + 1
'                            End If
'                        End If
'                    Next A
'                End If
'            End If
'        Next Y
'
'        ReDim SAMat(0, 0)
'
'
'
'        For Y = 0 To NextNo
'            For A = 0 To NextNo
'                If OKtoAdd(A, Y) = 4 Then 'SAMatSmall(x, A) >= SAMat(A, Y) And FAMatSmall(x, A) >= FAMat(A, Y) And SMatSmall(x, A) >= SMat(A, Y) And FMatSmall(x, A) >= FMat(A, Y) Then
'                    RNum(x) = RNum(x) + 1
'                    RList(x, RNum(x)) = Y
'                    Exit For
'                End If
'            Next A
'        Next Y
    Else
       
        For Y = 0 To NextNo
            If OKSeq(x, 18, Y) > -1 Then
                If InRNum(Y) = 0 Then
                    For A = 0 To NextNo
                        If InRNum(A) = 1 And A <> Y Then
                            If SAMatSmall(x, A) >= SAMat(A, Y) And FAMatSmall(x, A) >= FAMat(A, Y) And SMatSmall(x, A) >= SMat(A, Y) And FMatSmall(x, A) >= FMat(A, Y) Then
                                RNum(x) = RNum(x) + 1
                                RList(x, RNum(x)) = Y
                                 
                                 Exit For
                            End If
                        End If
                    Next A
                
                
                End If
            End If
            
        Next Y
    End If

    'XX = RList(2, 7)
'    If X = 12345 Then
'        Y = 1
'        Do While Y <= RNum(X)
'
'
'            If IsIn(X, RList(X, Y)) = 0 Then
'                IsIn(X, RList(X, Y)) = 1
'            Else
'                RList(X, Y) = RList(X, RNum(X))
'                RNum(X) = RNum(X) - 1
'                Y = Y - 1
'            End If
'            Y = Y + 1
'        Loop
'        'For Y = 1 To RNum(X)
'        Y = 1
'        Do While Y <= RNum(X)
'            For Z = 0 To NextNo
'                If IsIn(X, Z) = 0 And OKSeq(X, 18, Z) = 1 Then
'                    If SCMat(RList(X, Y), Z) = SCMatSmall(X, RList(X, Y)) And FCMat(RList(X, Y), Z) = FCMatSmall(X, RList(X, Y)) Then
'                        If SCMat(RList(X, Y), Z) = SCMatSmall(1, RList(X, Y)) And FCMat(RList(X, Y), Z) = FCMatSmall(1, RList(X, Y)) Then
'                            If SCMat(RList(X, Y), Z) = SCMatSmall(2, RList(X, Y)) And FCMat(RList(X, Y), Z) = FCMatSmall(2, RList(X, Y)) Then
'                                    IsIn(X, Z) = 1
'
'                                    RList(X, RNum(X)) = Z
'                                    RNum(X) = RNum(X) + 1
'                            End If
'                        End If
'                    End If
'                End If
'            Next Z
'            Y = Y + 1
'        Loop
'        'Next Y
'        X = X
'    End If
    
Next x

If PermNextno > MemPoc Then
    ReDim SAMat(0, 0)
    ReDim FAMat(0, 0)
    ReDim FMat(0, 0)
    ReDim SMat(0, 0)
End If

'XX = RNum(2)
For x = 0 To 2
    'XX = SEventNumber
    If RNum(x) = -1 Then
        RNum(0) = oRNum(0): RNum(1) = oRNum(1): RNum(2) = oRNum(2)
        For Y = 0 To 2
            For Z = 0 To RNum(Y)
                RList(Y, Z) = oRList(Y, Z)
            Next Z
        Next Y
        Exit For
    End If
Next x
End Sub
Public Sub CheckBSTree(WinPP As Byte, INList() As Byte, FCMat() As Single, SCMat() As Single, OKSeq() As Double, ISeqs() As Long, CompMat() As Long)

Dim x As Long
For x = 0 To NextNo
                If FCMat(ISeqs(WinPP), x) < FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    If SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 20
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 10
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.075
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 10
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.075
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            End If
                        
                        
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 10
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.075
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            End If
                        
                        
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 1.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.5
                                End If
                        End If
                    End If
                ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    If SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 10
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.075
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.075
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            End If
                        
                        
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.125
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 1.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.5
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.125
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                End If
                        End If
                    End If
                ElseIf FCMat(ISeqs(WinPP), x) > FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    If SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5 'starting value for this set
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.125
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -2.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.125
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -20
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -10
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.125
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -10
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.125
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -10
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.125
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                End If
                        End If
                    End If
                ElseIf FCMat(ISeqs(WinPP), x) > FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    If SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 5 'starting value for this set
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.25
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 1.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -0.75
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.5
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.125
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -10
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                End If
                        End If
                    ElseIf SCMat(ISeqs(WinPP), x) > SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) < FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 2.5
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.5
                            
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) <= FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                            If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 1.25
                            ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = 0.75
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -1.25
                            ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                OKSeq(WinPP, 7, x) = -0.75
                            End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.25
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                End If
                        ElseIf FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 1))) Or FCMat(ISeqs(WinPP), x) > FCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                If SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) < SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.75
                                ElseIf SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) <= SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = 0.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -2.5
                                ElseIf SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 1))) Or SCMat(ISeqs(WinPP), x) > SCMat(x, ISeqs(CompMat(WinPP, 0))) Then
                                    OKSeq(WinPP, 7, x) = -1.25
                                End If
                        End If
                    End If
                End If
                If WinPP = INList(0) And OKSeq(WinPP, 7, x) > 0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) / 2
                End If
                       
            Next x
End Sub
Public Sub FinalTrim(WinNum, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, LowP As Double, RFF, WeightMod() As Long, OKSeq() As Double, BMatch() As Single, BPMatch() As Long _
, MinPair() As Byte, INList() As Byte, RInv() As Single, BPos As Long, Epos As Long, RWinPP As Byte, MissIDFlag As Byte, PhylCheck As Byte, BackUpNextno As Long, NextNo As Long, CorrectP As Double, oSeq As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, XoverList() As XOverDefine, CurrentXOver() As Integer, PCurrentXover() As Integer, PXOList() As XOverDefine, MissingData() As Byte, TraceSub() As Long, Trace() As Long, DMatS() As Single, CompMat() As Long, BPMat() As Single, RCorrWarn() As Byte, UNF() As Byte, RCorr() As Single, ISeqs() As Long, FCMatSmall() As Single, SCMatSmall() As Single, FAMatSmall() As Single, SAMatSmall() As Single, NRNum() As Long, NRList() As Long, RNum() As Long, RList() As Long)
Dim DecompressSeq As String
Dim UB As Long, FCV As Single, FCV0 As Single, FCV1 As Single, SCV As Single, SCV0 As Single, SCV1 As Single


Dim TT As Long, Z As Long, Y As Long, oSSFastFlag As Byte, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
Dim ET As Long, ST As Long, GoOn As Long, x As Long, WinPP As Byte, SNRD(1) As Double
Dim AlreadyIn() As Byte, optWinsize As Long, Duplicate() As Byte
Dim MatchMat() As Single
Dim oLowestProb As Double, tr() As Double
Dim MarkRemove() As Byte
Dim RListA() As Long, RNumA() As Long
Dim TN() As Byte, oRNum(3) As Long
Dim OKMod(1) As Double
'strip duplicates
ReDim Duplicate(NextNo, 2)




'If BusyWithExcludes = 1 Then
'        x = x
'        XX = PermNextno
'        XX = RList(1, 1)
'        XX = RNum(1)
'        XX = UNF(WinPP, RList(1, 0))
'    End If
'XX = RWinPP
'Base final removal/maintenance of sequences in Rlist on 6 lines of evidence
'(1) Correlation with the iseqs
'(2) duplication of correlation scores
'(3) Site patterns
'(4) distances between iseqs
'(5) tree postions relative to iseqs
'(6) was a signal detected?

'fOR CORRELATIONES ETC make sure the following criteria are met:
'(1) rcorrwarn = 0
'(2) rinv = 0


'Pattern check and "was a signal detected?" checks have already been made - what is left in rlist are the sequences
'that are potentially co-recombinants - there is a good chance though that the sequences have been over-grouped if one or both of the parents are
'also recombinants
XX = RNum(0)
XX = RNum(1)
XX = RNum(2)
  

If RFF = 0 Then
    
    ReDim MatchMat(2, 2, NextNo)
    'UBound(SMat, 1)
    'this should maybe be removed at some point - it is superceded by calcmatch later on (the results of which are stored in okseq element 18 and 17)
    Call MakeMatchMat(SMatSmall(), SeqNum(), BMatch(), BPMatch(), MatchMat(), ISeqs())
    'Make copy of rcorr
    
    ReDim tr(2, 2, NextNo)
    
    For x = 0 To 2
        For Y = 0 To 2
            For Z = 0 To NextNo
                tr(x, Y, Z) = RCorr(x, Y, Z)
            Next Z
        Next Y
    Next x
    
    'Now erase all meaningless rcorr evidence
    For x = 0 To 2
        If RCorrWarn(x) = 1 Then
            For Y = 0 To NextNo
                tr(0, x, Y) = 0
                tr(1, x, Y) = 0
                tr(2, x, Y) = 0
            Next Y
        End If
    Next x
    x = x
    'Exit Sub
    For x = 0 To 2
        For Y = 0 To 2
            For Z = 0 To NextNo
                If RInv(x, Y, Z) <> 0 Then
                    tr(x, Y, Z) = 0
                End If
            Next Z
        Next Y
    Next x
    
    '(1) check for duplication and clean up correlation scores
    For x = 0 To 2
        For Y = 0 To RNum(x)
            If RList(x, Y) <= NextNo Then
                For Z = 0 To 2
                    If tr(x, Z, RList(x, Y)) > 0.83 Then
                        Duplicate(RList(x, Y), Z) = Duplicate(RList(x, Y), Z) + 1
                    End If
                
                Next Z
            End If
        Next Y
    Next x
    
    For x = 0 To 2
        For Y = 0 To RNum(x)
            
            GoOn = 0
            If RList(x, Y) <= NextNo Then
                For Z = 0 To 2
                    If Duplicate(RList(x, Y), Z) > 1 Then ' And (RCorr(X, 0, RList(X, Y)) < 0.9 or rinv(X, 0, RList(X, Y)) <>0) And (RCorr(X, 1, RList(X, Y)) < 0.9 or rinv(X, 1, RList(X, Y)) <>0) And (RCorr(X, 2, RList(X, Y)) < 0.9 or rinv(X, 2, RList(X, Y)) <>0) Then
                        tr(x, Z, RList(x, Y)) = 0
                    End If
                Next Z
            End If
        Next Y
        
    Next x
    
    
    For x = 0 To 2
        Y = 0
        
        Do While Y <= RNum(x)
            If RList(x, Y) <= NextNo Then
                GoOn = 0
                If tr(x, 0, RList(x, Y)) < 0.83 And tr(x, 1, RList(x, Y)) < 0.83 And tr(x, 2, RList(x, Y)) < 0.83 Then
                    GoOn = 1
                End If
            
                If GoOn = 0 Then
                    OKSeq(x, 5, RList(x, Y)) = 1
                End If
            
            End If
            Y = Y + 1
        Loop
    Next x
    
    ReDim RListA(2, NextNo), RNumA(2)
    For x = 0 To 2
        RNumA(x) = RNum(x)
        For Y = 0 To RNum(x)
            RListA(x, Y) = RList(x, Y)
            OKSeq(x, 6, RList(x, Y)) = 1
        Next Y
    Next x
    
    'Remake NRlist - basicall y  make, NRlist, boot out sequences, remakeNRlist, and repeat until no more changes are made
    
    oRNum(0) = 0: oRNum(1) = 0: oRNum(2) = 0
        
    ReDim NRNum(2), NRList(2, NextNo)
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UBFC = 0
    UBFC = UBound(FCMatSmall, 2)
    On Error GoTo 0
    
    For WinPP = 0 To 2
        
        Do
            
            If oRNum(WinPP) = RNum(WinPP) Then Exit Do
            
                    
            oRNum(WinPP) = RNum(WinPP)
            NRNum(WinPP) = 0
                   
            x = WinPP
            ReDim TN(NextNo)
            SNRD(0) = 0: SNRD(1) = 0
            'Find the clusters in the f and s trees where the sequences in rlist occur
            For Y = 0 To RNum(x)
                If RList(x, Y) <= NextNo Then
                    TN(RList(x, Y)) = 1
                    If FAMatSmall(x, RList(x, Y)) > SNRD(0) Then
                        SNRD(0) = FAMatSmall(x, RList(x, Y))
                    End If
                    If SAMatSmall(x, RList(x, Y)) > SNRD(1) Then
                        SNRD(1) = SAMatSmall(x, RList(x, Y))
                    End If
                End If
            Next Y
            NRNum(x) = -1
            For Z = 0 To NextNo
                    
                If FAMatSmall(x, Z) <= SNRD(0) And TN(Z) = 0 Then
                    NRNum(x) = NRNum(x) + 1
                    NRList(x, NRNum(x)) = Z
                    TN(Z) = 1
                End If
                If SAMatSmall(x, Z) <= SNRD(1) And TN(Z) = 0 Then
                    NRNum(x) = NRNum(x) + 1
                    NRList(x, NRNum(x)) = Z
                    TN(Z) = 1
                End If
                        
            Next Z
            'XX = UBound(XOverlist, 2)
            ReDim MarkRemove(NextNo, 1)
            If NRNum(WinPP) > -1 Then
                'find the shortest tree distance to a nonrecombinant
                SNRD(0) = 1000000
                
                For x = 0 To NRNum(WinPP)
                    If NextNo > 2 Then
                        If UBFC > 0 Then
                            FCV = FCMatSmall(WinPP, NRList(WinPP, x))
                        Else
                            FCV = FAMatSmall(WinPP, NRList(WinPP, x))
                        End If
                        If FCV < SNRD(0) And FAMatSmall(WinPP, NRList(WinPP, x)) < (NextNo * 2 / 1000) Then
                            SNRD(0) = FCV
                        End If
                    End If
                Next x
                'delete entries from Rlist that are further from iseqs(winpp) then
                'the nearest non-recombinant
                x = 0
'                XX = RNum(1)
                Do While x <= RNum(WinPP)
                    If RList(WinPP, x) <= NextNo Then
                        If (tr(WinPP, 0, RList(WinPP, x)) >= 0.99) Or (tr(WinPP, 1, RList(WinPP, x)) >= 0.99) Then 'free ticket
                            'keep it regardless if the correlation is very high
                            x = x + 1
                        ElseIf (tr(WinPP, 0, RList(WinPP, x)) < 0.99 And tr(WinPP, 0, RList(WinPP, x)) > 0.83) Or (tr(WinPP, 1, RList(WinPP, x)) < 0.99 And tr(WinPP, 1, RList(WinPP, x)) > 0.83) Then
                            If UBFC > 0 Then
                                FCV = FCMatSmall(WinPP, RList(WinPP, x))
                                FCV0 = FCMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
                                FCV1 = FCMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
                            Else
                                FCV = FAMatSmall(WinPP, RList(WinPP, x))
                                FCV0 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
                                FCV1 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
                            End If
                            If FCV > SNRD(0) Or FCV > FCV0 Or FCV > FCV1 Then  'And RCorr(WinPP, 0, Rlist(WinPP, X)) < 0.95 And RCorr(WinPP, 1, Rlist(WinPP, X)) < 0.95 And RCorr(WinPP, 2, Rlist(WinPP, X)) < 0.95 Then
                                GoOn = 1
                                If tr(WinPP, 0, RList(WinPP, x)) > 0.95 Then
                                    GoOn = 0
                                ElseIf tr(WinPP, 1, RList(WinPP, x)) > 0.95 Then
                                    GoOn = 0
                                End If
                                If UNF(WinPP, RList(WinPP, x)) = 1 Or GoOn = 1 Then
                                    OKSeq(WinPP, 6, RList(WinPP, x)) = 0
                                    If x < RNum(WinPP) Then
                                        RList(WinPP, x) = RList(WinPP, RNum(WinPP))
                                    End If
                                    RNum(WinPP) = RNum(WinPP) - 1
                                Else
                                    GoOn = 0
                                    If RCorrWarn(0) = 0 Then
                                        If tr(WinPP, 0, RList(WinPP, x)) > 0.95 Then
                                            If x = x Then
                                                If DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                    If DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                        GoOn = GoOn + 2
                                                    Else
                                                        GoOn = GoOn + 1
                                                    End If
                                                Else
                                                    GoOn = GoOn - 1
                                                End If
                                                If DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                    If DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                        GoOn = GoOn + 2
                                                    Else
                                                        GoOn = GoOn + 1
                                                    End If
                                                Else
                                                    GoOn = GoOn - 1
                                                End If
                                            End If
                                        Else
                                            GoOn = 1
                                        End If
                                           
                                    Else
                                        GoOn = 1
                                    End If
                                    If GoOn > 0 Then
                                        If RCorrWarn(1) = 0 Then
                                            GoOn = 0
                                            If tr(WinPP, 1, RList(WinPP, x)) > 0.95 Then
                                                If x = x Then
                                                    If DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                        If DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                            GoOn = GoOn + 2
                                                        Else
                                                            GoOn = GoOn + 1
                                                        End If
                                                    Else
                                                        GoOn = GoOn - 1
                                                    End If
                                                    If DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                        If DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                            GoOn = GoOn + 2
                                                        Else
                                                            GoOn = GoOn + 1
                                                        End If
                                                    Else
                                                        GoOn = GoOn - 1
                                                    End If
                                                End If
                                            Else
                                                GoOn = 1
                                            End If
                                        Else
                                            GoOn = 1
                                        End If
                                    End If
                                    If GoOn > 0 Then
                                        MarkRemove(RList(WinPP, x), 0) = 1
                                    End If
                                    x = x + 1
                                        'Else
                                        '    If X < RNum(WinPP) Then
                                        '        Rlist(WinPP, X) = Rlist(WinPP, RNum(WinPP))
                                        '    End If
                                        '    RNum(WinPP) = RNum(WinPP) - 1
                                        'End If
                                End If
                            Else
                                x = x + 1
                            End If
                        Else
                            x = x + 1
                        End If
                    Else
                        x = x + 1
                    End If
                Loop
                    
                    'If X = X Then
                SNRD(1) = 1000000
                For x = 0 To NRNum(WinPP)
                    If UBFC > 0 Then
                        SCV = SCMatSmall(WinPP, NRList(WinPP, x))
                    Else
                        SCV = SAMatSmall(WinPP, NRList(WinPP, x))
                    End If
                    If SCV < SNRD(1) And SCV < (NextNo * 2 / 1000) Then
                        SNRD(1) = SCV
                    End If
                Next x
                'delete entries from Rlist that are further from iseqs(winpp) then
                'the nearest non-recombinant
                x = 0
                Do While x <= RNum(WinPP)
                    If RList(WinPP, x) <= NextNo Then
                        If (tr(WinPP, 0, RList(WinPP, x)) >= 0.99) Or (tr(WinPP, 1, RList(WinPP, x)) >= 0.99) Then 'free ticket
                            'keep it regardless if the correlation is very high
                            x = x + 1
                        ElseIf (tr(WinPP, 0, RList(WinPP, x)) < 0.99 And tr(WinPP, 0, RList(WinPP, x)) > 0.83) Or (tr(WinPP, 1, RList(WinPP, x)) < 0.99 And tr(WinPP, 1, RList(WinPP, x)) > 0.83) Then
                            If UBFC > 0 Then
                                SCV = SCMatSmall(WinPP, RList(WinPP, x))
                                SCV0 = SCMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
                                SCV1 = SCMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
                            Else
                                SCV = SAMatSmall(WinPP, RList(WinPP, x))
                                SCV0 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
                                SCV1 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
                            End If
                            If SCV > SNRD(1) Or SCV > SCV0 Or SCV > SCV1 Then 'And RCorr(WinPP, 0, Rlist(WinPP, X)) < 0.95 And RCorr(WinPP, 1, Rlist(WinPP, X)) < 0.95 And RCorr(WinPP, 2, Rlist(WinPP, X)) < 0.95 Then
                                GoOn = 1
                                If tr(WinPP, 0, RList(WinPP, x)) > 0.95 Then
                                    GoOn = 0
                                ElseIf tr(WinPP, 1, RList(WinPP, x)) > 0.95 Then
                                    GoOn = 0
                                End If
                                If UNF(WinPP, RList(WinPP, x)) = 1 Or GoOn = 1 Then
                                    OKSeq(WinPP, 6, RList(WinPP, x)) = 0
                                    If x < RNum(WinPP) Then
                                        RList(WinPP, x) = RList(WinPP, RNum(WinPP))
                                    End If
                                    RNum(WinPP) = RNum(WinPP) - 1
                                Else
                                    GoOn = 0
                                    
                                    If RCorrWarn(0) = 0 Then
                                        If tr(WinPP, 0, RList(WinPP, x)) > 0.95 Then
                                            If x = x Then
                                                If DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                    If DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(0, WinPP, RList(WinPP, x)) > DMatS(0, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                        GoOn = GoOn + 2
                                                    Else
                                                        GoOn = GoOn + 1
                                                    End If
                                                Else
                                                    GoOn = GoOn - 1
                                                End If
                                                If DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                    If DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(1, WinPP, RList(WinPP, x)) > DMatS(1, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                        GoOn = GoOn + 2
                                                    Else
                                                        GoOn = GoOn + 1
                                                    End If
                                                Else
                                                    GoOn = GoOn - 1
                                                End If
                                            End If
                                        Else
                                            GoOn = 1
                                        End If
                                                
                                    Else
                                        GoOn = 1
                                    End If
                                    If GoOn > 0 Then
                                        If RCorrWarn(1) = 0 Then
                                            GoOn = 0
                                            If tr(WinPP, 1, RList(WinPP, x)) > 0.95 Then
                                                If x = x Then
                                                    If DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                        If DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(2, WinPP, RList(WinPP, x)) > DMatS(2, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                            GoOn = GoOn + 2
                                                        Else
                                                            GoOn = GoOn + 1
                                                        End If
                                                    Else
                                                        GoOn = GoOn - 1
                                                    End If
                                                    If DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 0))) Or DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                                                        If DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, CompMat(WinPP, 0), RList(WinPP, x)) Or DMatS(3, WinPP, RList(WinPP, x)) > DMatS(3, CompMat(WinPP, 1), RList(WinPP, x)) Then
                                                            GoOn = GoOn + 2
                                                        Else
                                                            GoOn = GoOn + 1
                                                        End If
                                                    Else
                                                        GoOn = GoOn - 1
                                                    End If
                                                End If
                                            Else
                                                GoOn = 1
                                            End If
                                        Else
                                            GoOn = 1
                                        End If
                                    End If
                                    If GoOn > 0 Then
                                                
                                        MarkRemove(RList(WinPP, x), 1) = 1
                                    End If
                                    x = x + 1
                                            'Else
                                            '    If X < RNum(WinPP) Then
                                            '        Rlist(WinPP, X) = Rlist(WinPP, RNum(WinPP))
                                            '    End If
                                            '    RNum(WinPP) = RNum(WinPP) - 1
                                            'End If
                                End If
                            Else
                                x = x + 1
                            End If
                        Else
                            x = x + 1
                        End If
                    Else
                        x = x + 1
                    End If
                Loop
                   
            Else
                SNRD(0) = 0
                SNRD(1) = 0
            End If
                
            x = 0
            Do While x <= RNum(WinPP)
                If RList(WinPP, x) <= NextNo Then
                    If MarkRemove(RList(WinPP, x), 0) = 1 And MarkRemove(RList(WinPP, x), 1) = 1 Then
                        OKSeq(WinPP, 6, RList(WinPP, x)) = 0
                        If x < RNum(WinPP) Then
                            RList(WinPP, x) = RList(WinPP, RNum(WinPP))
                        End If
                        RNum(WinPP) = RNum(WinPP) - 1
                            
                    Else
                        x = x + 1
                    End If
                Else
                    x = x + 1
                End If
            Loop
        Loop
            
            
        ReDim AlreadyIn(NextNo)
        For x = 0 To RNum(WinPP)
            If RList(WinPP, x) <= NextNo Then
                AlreadyIn(RList(WinPP, x)) = 1
            End If
        Next x
           
        AlreadyIn(ISeqs(0)) = 1
        AlreadyIn(ISeqs(1)) = 1
        AlreadyIn(ISeqs(2)) = 1
          
        For x = 0 To NextNo
                
            If AlreadyIn(x) = 0 Then
                If UBFC > 0 Then
                    FCV = FCMatSmall(WinPP, x)
                    SCV = SCMatSmall(WinPP, x)
                Else
                    FCV = FAMatSmall(WinPP, x)
                    SCV = SAMatSmall(WinPP, x)
                End If
                If FCV <= SNRD(0) Then 'FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), X) <= FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    If SCV <= SNRD(1) Then 'SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), X) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        If tr(WinPP, 0, x) > 0.83 Or tr(WinPP, 1, x) > 0.83 Or tr(WinPP, 2, x) > 0.83 Then
                            RNum(WinPP) = RNum(WinPP) + 1
                            RList(WinPP, RNum(WinPP)) = x
                            AlreadyIn(x) = 1
                        End If
                    End If
                End If
            End If
        Next x
        If MinPair(0) <> MinPair(1) Then
            If WinPP = INList(0) Then
                OKMod(0) = 1: OKMod(1) = 1 '0.5
            ElseIf WinPP = INList(2) Then
                OKMod(0) = 1 '0.5
                OKMod(1) = 1
            ElseIf WinPP = INList(1) Then
                OKMod(0) = 1: OKMod(1) = 1
            End If
        Else
            If MinPair(0) = 0 Then
                If WinPP = 0 Or WinPP = 1 Then
                    OKMod(0) = 1: OKMod(1) = 1
                Else
                    OKMod(0) = 0.5: OKMod(1) = 0.5
                End If
             ElseIf MinPair(0) = 1 Then
                If WinPP = 0 Or WinPP = 2 Then
                    OKMod(0) = 1: OKMod(1) = 1
                Else
                    OKMod(0) = 0.5: OKMod(1) = 0.5
                End If
            ElseIf MinPair(0) = 2 Then
                If WinPP = 1 Or WinPP = 2 Then
                    OKMod(0) = 1: OKMod(1) = 1
                Else
                    OKMod(0) = 0.5: OKMod(1) = 0.5
                End If
            End If
        End If
        Dim SCIX As Single, FCIX As Single, FCIC1 As Single, FCIC0 As Single, SCIC1 As Single, SCIC0 As Single
        Dim FCXC1 As Single, FCXC0 As Single, SCXC1 As Single, SCXC0 As Single
        If UBFC > 0 Then
            FCIC1 = FCMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
            FCIC0 = FCMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
            SCIC1 = SCMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
            SCIC0 = SCMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
            For x = 0 To NextNo
                SCIX = SCMatSmall(WinPP, x)
                FCIX = FCMatSmall(WinPP, x)
                FCXC1 = FCMatSmall(CompMat(WinPP, 1), x)
                FCXC0 = FCMatSmall(CompMat(WinPP, 0), x)
                SCXC0 = SCMatSmall(CompMat(WinPP, 0), x)
                SCXC1 = SCMatSmall(CompMat(WinPP, 1), x)
                If FCIX < FCIC1 And FCIX < FCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 4 * OKMod(0)
                ElseIf FCIX <= FCIC1 And FCIX <= FCIC0 Then
                    If FCIX < FCIC1 Or FCIX < FCIC0 Then
                        OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 2 * OKMod(0)
                    End If
                ElseIf FCIX > FCIC1 And FCIX > FCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 10 / OKMod(0)
                ElseIf FCIX > FCIC1 Or FCIX > FCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 2 / OKMod(0)
                End If
                If SCIX < SCIC1 And SCIX < SCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 4 * OKMod(1)
                ElseIf SCIX <= SCIC1 And SCIX <= SCIC0 Then
                    If SCIX < SCIC1 Or SCIX < SCIC0 Then
                        OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 2 * OKMod(1)
                    End If
                ElseIf SCIX > SCIC1 And SCIX > SCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 10 / OKMod(1)
                ElseIf SCIX > SCIC1 Or SCIX > SCIC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 2 / OKMod(1)
                End If
                
                If FCIX < FCXC1 And FCIX < FCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 4 * OKMod(0)
                ElseIf FCIX <= FCXC1 And FCIX <= FCXC0 Then
                    If FCIX < FCXC1 Or FCIX < FCXC0 Then
                        OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 2 * OKMod(0)
                    End If
                        
                ElseIf FCIX > FCXC1 And FCIX > FCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 10 / OKMod(0)
                ElseIf FCIX > FCXC1 Or FCIX > FCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 2 / OKMod(0)
                End If
                If SCIX < SCXC1 And SCIX < SCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 4 * OKMod(1)
                ElseIf SCIX <= SCXC1 And SCIX <= SCXC0 Then
                    If SCIX < SCXC1 Or SCIX < SCXC0 Then
                        OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) + 2 * OKMod(1)
                    End If
                ElseIf SCIX > SCXC1 And SCIX > SCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 10 / OKMod(1)
                ElseIf SCIX > SCXC1 Or SCIX > SCXC0 Then
                    OKSeq(WinPP, 7, x) = OKSeq(WinPP, 7, x) - 2 / OKMod(1)
                End If
                'If (WinPP = INList(2) Or WinPP = INList(0)) And OKSeq(WinPP, 7, X) > 0 Then
                '    OKSeq(WinPP, 7, X) = OKSeq(WinPP, 7, X) / 2
                'End If
            Next x
        End If
        Dim SAIWX As Single, SAIC1 As Single, SAIC0 As Single, FAIWX As Single, FAIC1 As Single, FAIC0 As Single
        Dim SAX1 As Single, SAX0 As Single, FAX1 As Single, FAX0 As Single
        SAIC1 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
        SAIC0 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
        FAIC1 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
        FAIC0 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
        '@
        For x = 0 To NextNo
            
            SAIWX = SAMatSmall(WinPP, x)
            FAIWX = FAMatSmall(WinPP, x)
            
            FAX1 = FAMatSmall(CompMat(WinPP, 1), x)
            FAX0 = FAMatSmall(CompMat(WinPP, 0), x)
            SAX1 = SAMatSmall(CompMat(WinPP, 1), x)
            SAX0 = SAMatSmall(CompMat(WinPP, 0), x)
            
            If FAIWX < FAIC1 And FAIWX < FAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 4 * OKMod(0)
            ElseIf FAIWX <= FAIC1 And FAIWX <= FAIC0 Then
                If FAIWX < FAIC1 Or FAIWX < FAIC0 Then
                    OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 2 * OKMod(0)
                End If
            ElseIf FAIWX > FAIC1 And FAIWX > FAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 10 / OKMod(0)
            ElseIf FAIWX > FAIC1 Or FAIWX > FAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 2 / OKMod(0)
            End If
            If SAIWX < SAIC1 And SAIWX < SAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 4 * OKMod(0)
            ElseIf SAIWX <= SAIC1 And SAIWX <= SAIC0 Then
                If SAIWX < SAIC1 Or SAIWX < SAIC0 Then
                    OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 2 * OKMod(0)
                End If
            ElseIf SAIWX > SAIC1 And SAIWX > SAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 10 / OKMod(0)
            ElseIf SAIWX > SAIC1 Or SAIWX > SAIC0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 2 / OKMod(0)
            End If
            If FAIWX < FAX1 And FAIWX < FAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 4 * OKMod(0)
            ElseIf FAIWX <= FAX1 And FAIWX <= FAX0 Then
                If FAIWX < FAX1 Or FAIWX < FAX0 Then
                    OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 1 * OKMod(0)
                End If
            ElseIf FAIWX > FAX1 And FAIWX > FAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 10 / OKMod(0)
            ElseIf FAIWX > FAX1 Or FAIWX > FAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 2 / OKMod(0)
            End If
            If SAIWX < SAX1 And SAIWX < SAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 4 * OKMod(1)
            ElseIf SAIWX <= SAX1 And SAIWX <= SAX0 Then
                If SAIWX < SAX1 Or SAIWX < SAX0 Then
                    OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) + 1 * OKMod(1)
                End If
            ElseIf SAIWX > SAX1 And SAIWX > SAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 10 / OKMod(1)
            ElseIf SAIWX > SAX1 Or SAIWX > SAX0 Then
                OKSeq(WinPP, 8, x) = OKSeq(WinPP, 8, x) - 2 / OKMod(1)
            End If
            'If (WinPP = INList(2) Or WinPP = INList(0)) And OKSeq(WinPP, 8, X) > 0 Then
            '    OKSeq(WinPP, 8, X) = OKSeq(WinPP, 8, X) / 2
            'End If
            
        Next x
            
            
        For x = 0 To NextNo
            If FMatSmall(WinPP, x) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) And FMatSmall(WinPP, x) < FMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) Then
                If SMatSmall(WinPP, x) < SMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) And SMatSmall(WinPP, x) < SMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) Then
                    If FMatSmall(WinPP, x) < FMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                        If SMatSmall(WinPP, x) < SMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                            OKSeq(WinPP, 9, x) = 8
                        Else
                            If WinPP <> INList(0) Then
                                OKSeq(WinPP, 9, x) = 2
                            End If
                        End If
                    Else
                        If SMatSmall(WinPP, x) < SMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                            If WinPP <> INList(0) Then
                                OKSeq(WinPP, 9, x) = 2
                            End If
                        Else
                            If WinPP <> INList(0) Then
                                OKSeq(WinPP, 9, x) = 0.5
                            End If
                        End If
                    End If
                End If
            ElseIf FMatSmall(WinPP, x) > FMatSmall(CompMat(WinPP, 1), x) And FMatSmall(WinPP, x) > FMatSmall(CompMat(WinPP, 0), x) Then
                If SMatSmall(WinPP, x) > SMatSmall(CompMat(WinPP, 1), x) And SMatSmall(WinPP, x) > SMatSmall(CompMat(WinPP, 0), x) Then
                    If FMatSmall(WinPP, x) > FMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                        If SMatSmall(WinPP, x) > SMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                            OKSeq(WinPP, 9, x) = -1
                        Else
                            OKSeq(WinPP, 9, x) = -0.5
                        End If
                    Else
                        If SMatSmall(WinPP, x) > SMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                            OKSeq(WinPP, 9, x) = -0.5
                        Else
                            OKSeq(WinPP, 9, x) = -0.25
                        End If
                    End If
                End If
            End If
            If MinPair(0) <> MinPair(1) Then
                If (WinPP = INList(2) Or WinPP = INList(0)) And OKSeq(WinPP, 9, x) > 0 Then
                    OKSeq(WinPP, 9, x) = OKSeq(WinPP, 9, x) / 2
                End If
            Else
                If OKSeq(WinPP, 9, x) > 0 Then
                    OKSeq(WinPP, 9, x) = OKSeq(WinPP, 9, x) * OKMod(0)
                End If
            End If
        Next x
        '@
        If RCorrWarn(0) = 0 Then
            If x = x Then
                For x = 0 To NextNo
                    OKSeq(0, 10, x) = 0
                    OKSeq(1, 10, x) = 0
                    OKSeq(2, 10, x) = 0
                Next x
            End If
            For x = 0 To NextNo
                If DMatS(0, WinPP, x) < 3 And DMatS(1, WinPP, x) < 3 Then
                    '@
                    If DMatS(0, WinPP, x) < DMatS(0, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(0, WinPP, x) < DMatS(0, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                        If DMatS(1, WinPP, x) < DMatS(1, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(1, WinPP, x) < DMatS(1, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                            If DMatS(0, WinPP, x) < DMatS(0, CompMat(WinPP, 1), x) And DMatS(0, WinPP, x) < DMatS(0, CompMat(WinPP, 0), x) Then
                                If DMatS(1, WinPP, x) < DMatS(1, CompMat(WinPP, 1), x) And DMatS(1, WinPP, x) < DMatS(1, CompMat(WinPP, 0), x) Then
                                    If DMatS(0, WinPP, x) < DMatS(0, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                        If DMatS(1, WinPP, x) < DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                            OKSeq(WinPP, 12, x) = 6
                                        Else
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 12, x) = 2
                                            End If
                                        End If
                                    Else
                                        If DMatS(1, WinPP, x) < DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 12, x) = 2
                                            End If
                                        Else
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 12, x) = 1
                                            End If
                                        End If
                                    End If
                                End If
                                
                            End If
                        End If
                    ElseIf DMatS(0, WinPP, x) > DMatS(0, CompMat(WinPP, 1), x) And DMatS(0, WinPP, x) > DMatS(0, CompMat(WinPP, 0), x) Then
                        If DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 1), x) And DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 0), x) Then
                            If DMatS(0, WinPP, x) > DMatS(0, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                If DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 12, x) = -1
                                Else
                                    OKSeq(WinPP, 12, x) = -0.5
                                End If
                            Else
                                If DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 12, x) = -0.5
                                Else
                                    OKSeq(WinPP, 12, x) = -0.25
                                End If
                            End If
                        End If
                    ElseIf DMatS(0, WinPP, x) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(0, WinPP, x) > DMatS(0, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                        If DMatS(1, WinPP, x) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(1, WinPP, x) > DMatS(1, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                            If DMatS(0, WinPP, x) > DMatS(0, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                If DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 12, x) = -1
                                Else
                                    OKSeq(WinPP, 12, x) = -0.5
                                End If
                            Else
                                If DMatS(1, WinPP, x) > DMatS(1, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 12, x) = -0.5
                                Else
                                    OKSeq(WinPP, 12, x) = -0.25
                                End If
                            End If
                        End If
                    End If
                        
                End If
                If MinPair(0) <> MinPair(1) Then
                    If (WinPP = INList(2) Or WinPP = INList(0)) And OKSeq(WinPP, 12, x) > 0 Then
                        OKSeq(WinPP, 12, x) = OKSeq(WinPP, 12, x) / 2
                    End If
                Else
                    If OKSeq(WinPP, 12, x) > 0 Then
                        OKSeq(WinPP, 12, x) = OKSeq(WinPP, 12, x) * OKMod(0)
                    End If
                End If
            Next x
        End If
            
            
        If RCorrWarn(1) = 0 And DoQuick = 0 Then
            
            For x = 0 To NextNo
                If DMatS(2, WinPP, x) < 3 And DMatS(3, WinPP, x) < 3 Then
                    If DMatS(2, WinPP, x) < DMatS(2, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(2, WinPP, x) < DMatS(2, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                        If DMatS(3, WinPP, x) < DMatS(3, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(3, WinPP, x) < DMatS(3, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                            If DMatS(2, WinPP, x) < DMatS(2, CompMat(WinPP, 1), x) And DMatS(2, WinPP, x) < DMatS(2, CompMat(WinPP, 0), x) Then
                                If DMatS(3, WinPP, x) < DMatS(3, CompMat(WinPP, 1), x) And DMatS(3, WinPP, x) < DMatS(3, CompMat(WinPP, 0), x) Then
                                    If DMatS(2, WinPP, x) < DMatS(2, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                        If DMatS(3, WinPP, x) < DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                            OKSeq(WinPP, 13, x) = 6
                                        Else
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 13, x) = 2
                                            End If
                                        End If
                                    Else
                                        If DMatS(3, WinPP, x) < DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 13, x) = 2
                                            End If
                                        Else
                                            If WinPP <> INList(0) Then
                                                OKSeq(WinPP, 13, x) = 1
                                            End If
                                        End If
                                    End If
                                End If
                                
                            End If
                        End If
                    ElseIf DMatS(2, WinPP, x) > DMatS(2, CompMat(WinPP, 1), x) And DMatS(2, WinPP, x) > DMatS(2, CompMat(WinPP, 0), x) Then
                        If DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 1), x) And DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 0), x) Then
                            If DMatS(2, WinPP, x) > DMatS(2, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                If DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 13, x) = -1
                                Else
                                    OKSeq(WinPP, 13, x) = -0.5
                                End If
                            Else
                                If DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 13, x) = -0.5
                                Else
                                    OKSeq(WinPP, 13, x) = -0.25
                                End If
                            End If
                        End If
                    ElseIf DMatS(2, WinPP, x) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(2, WinPP, x) > DMatS(2, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                        If DMatS(3, WinPP, x) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 1))) And DMatS(3, WinPP, x) > DMatS(3, WinPP, ISeqs(CompMat(WinPP, 0))) Then
                            If DMatS(2, WinPP, x) > DMatS(2, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                If DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 13, x) = -1
                                Else
                                    OKSeq(WinPP, 13, x) = -0.5
                                End If
                            Else
                                If DMatS(3, WinPP, x) > DMatS(3, CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then
                                    OKSeq(WinPP, 13, x) = -0.5
                                Else
                                    OKSeq(WinPP, 13, x) = -0.25
                                End If
                            End If
                        End If
                    End If
                        
                End If
                If MinPair(0) <> MinPair(1) Then
                    If (WinPP = INList(2) Or WinPP = INList(0)) And OKSeq(WinPP, 13, x) > 0 Then
                        OKSeq(WinPP, 13, x) = OKSeq(WinPP, 13, x) / 2
                    End If
                Else
                    If OKSeq(WinPP, 13, x) > 0 Then
                        OKSeq(WinPP, 13, x) = OKSeq(WinPP, 13, x) * OKMod(0)
                    End If
                End If
            Next x
        End If

            
           
        For x = 0 To NextNo
            'If FMat(ISeqs(WinPP), X) < FMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FMat(ISeqs(WinPP), X) < FMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
            If MatchMat(WinPP, WinPP, x) <> 3 Then
                If MatchMat(WinPP, WinPP, x) < MatchMat(WinPP, WinPP, ISeqs(CompMat(WinPP, 0))) And MatchMat(WinPP, WinPP, x) < MatchMat(WinPP, WinPP, CompMat(WinPP, 1)) Then
                    If MatchMat(WinPP, WinPP, x) < MatchMat(WinPP, CompMat(WinPP, 0), x) And MatchMat(WinPP, WinPP, x) < MatchMat(WinPP, CompMat(WinPP, 1), x) Then
                        If MatchMat(WinPP, WinPP, x) < MatchMat(WinPP, CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) Then
                            OKSeq(WinPP, 14, x) = 10
                                     
                        Else
                            If WinPP <> INList(0) Then
                                OKSeq(WinPP, 14, x) = 5
                                    
                            End If
                        End If
                    Else
                        If MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 0), x) And MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 1), x) Then
                            OKSeq(WinPP, 14, x) = -1
                        Else
                            OKSeq(WinPP, 14, x) = -0.5
                        End If
                    End If
                ElseIf MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, WinPP, ISeqs(CompMat(WinPP, 0))) And MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, WinPP, ISeqs(CompMat(WinPP, 1))) Then
                    If MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 0), x) And MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 1), x) Then
                        OKSeq(WinPP, 14, x) = -50
                    Else
                        OKSeq(WinPP, 14, x) = -10
                    End If
                Else
                    If MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 0), x) And MatchMat(WinPP, WinPP, x) > MatchMat(WinPP, CompMat(WinPP, 1), x) Then
                        OKSeq(WinPP, 14, x) = -1
                    
                    Else
                        OKSeq(WinPP, 14, x) = -0.5
                    End If
                End If
            Else
                OKSeq(WinPP, 14, x) = -5
            End If
            If MinPair(0) <> MinPair(1) Then
                    If (WinPP = INList(0)) And OKSeq(WinPP, 14, x) > 0 Then
                        OKSeq(WinPP, 14, x) = OKSeq(WinPP, 14, x) / 2
                    End If
            Else
                    If OKSeq(WinPP, 14, x) > 0 Then
                        OKSeq(WinPP, 14, x) = OKSeq(WinPP, 14, x) * OKMod(0)
                    End If
            End If
        Next x
            
            
        SNRD(0) = 0: SNRD(1) = 0
            
        SAIC1 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
        SAIC0 = SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
        FAIC1 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))
        FAIC0 = FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0)))
            
        For x = 0 To NextNo
            If AlreadyIn(x) = 0 Then
                
                FAIWX = FAMatSmall(WinPP, x)
                If FAIWX < FAIC0 And FAIWX < FAIC1 Then 'FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And FCMat(ISeqs(WinPP), X) <= FCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                    SAIWX = SAMatSmall(WinPP, x)
                    If SAIWX < SAIC0 And SAIWX < SAIC1 Then 'SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 1))) And SCMat(ISeqs(WinPP), X) <= SCMat(ISeqs(WinPP), ISeqs(CompMat(WinPP, 0))) Then
                        RNum(WinPP) = RNum(WinPP) + 1
                        RList(WinPP, RNum(WinPP)) = x
                        AlreadyIn(x) = 1
                    End If
                End If
            End If
        Next x
         
        
    Next WinPP
    
       
    
   
    
    'find minimum rcorrs for sequences obviously moving as groups?
   ' If SEventNumber = 4 And RWinPP < 3 Then
    If MinPair(0) <> MinPair(1) And RWinPP < 3 Then 'INList(0) <> INList(1) And INList(0) <> INList(2) And INList(2) <> INList(1) Then
        'Do NO
        Y = 0
        Do While Y <= RNum(INList(0))
            GoOn = 0
            If UBFC > 0 Then
                FCV = FCMatSmall(INList(0), RList(INList(0), Y))
                FCV0 = FCMatSmall(INList(0), ISeqs(INList(1)))
                SCV = SCMatSmall(INList(0), RList(INList(0), Y))
                SCV0 = SCMatSmall(INList(1), ISeqs(INList(0)))
            Else
                FCV = FAMatSmall(INList(0), RList(INList(0), Y))
                FCV0 = FAMatSmall(INList(0), ISeqs(INList(1)))
                SCV = SAMatSmall(INList(0), RList(INList(0), Y))
                SCV0 = SAMatSmall(INList(0), ISeqs(INList(1)))
            End If
            If FCV <= FCV0 Then
                If SCV <= SCV0 Then
                    GoOn = 1
                End If
            End If
            If GoOn = 0 And RCorr(INList(0), 0, RList(INList(0), Y)) < 0.99 And RCorr(INList(0), 1, RList(INList(0), Y)) < 0.99 And RCorr(INList(0), 2, RList(INList(0), Y)) < 0.99 Then
                If Y < RNum(INList(0)) Then
                    RList(INList(0), Y) = RList(INList(0), RNum(INList(0)))
                   
                End If
                RNum(INList(0)) = RNum(INList(0)) - 1
            Else
                Y = Y + 1
            End If
        Loop
        
        
        
        Y = 0
        Do While Y <= RNum(INList(1))
            GoOn = 0
            If UBFC > 0 Then
                FCV = FCMatSmall(INList(1), RList(INList(1), Y))
                FCV0 = FCMatSmall(INList(1), ISeqs(INList(0)))
                SCV = SCMatSmall(INList(1), RList(INList(1), Y))
                SCV0 = SCMatSmall(INList(1), ISeqs(INList(2)))
            Else
                FCV = FAMatSmall(INList(1), RList(INList(1), Y))
                FCV0 = FAMatSmall(INList(1), ISeqs(INList(0)))
                SCV = SAMatSmall(INList(1), RList(INList(1), Y))
                SCV0 = SAMatSmall(INList(1), ISeqs(INList(2)))
            End If
            If FCV <= FCV0 Then
                GoOn = 1
            ElseIf SCV <= SCV0 Then
                GoOn = 1
            End If
            If GoOn = 0 And RCorr(INList(1), 0, RList(INList(1), Y)) < 0.99 And RCorr(INList(1), 1, RList(INList(1), Y)) < 0.99 And RCorr(INList(1), 2, RList(INList(1), Y)) < 0.99 Then
                If Y < RNum(INList(1)) Then
                    RList(INList(1), Y) = RList(INList(1), RNum(INList(1)))
                End If
                RNum(INList(1)) = RNum(INList(1)) - 1
            Else
                Y = Y + 1
            End If
        Loop
        Do While Y <= RNum(INList(2))
            GoOn = 0
            If UBFC > 0 Then
                FCV = FCMatSmall(INList(2), RList(INList(2), Y))
                FCV0 = FCMatSmall(INList(2), ISeqs(INList(1)))
                SCV = SCMatSmall(INList(2), RList(INList(2), Y))
                SCV0 = SCMatSmall(INList(2), ISeqs(INList(1)))
            Else
                FCV = FAMatSmall(INList(2), RList(INList(2), Y))
                FCV0 = FAMatSmall(INList(2), ISeqs(INList(1)))
                SCV = SAMatSmall(INList(2), RList(INList(2), Y))
                SCV0 = SAMatSmall(INList(2), ISeqs(INList(1)))
            End If
            
            If FCV <= FCV0 Then
                GoOn = 1
            ElseIf SCV <= SCV0 Then
                GoOn = 1
            End If
            If GoOn = 0 And RCorr(INList(2), 0, RList(INList(2), Y)) < 0.99 And RCorr(INList(2), 1, RList(INList(2), Y)) < 0.99 And RCorr(INList(2), 2, RList(INList(2), Y)) < 0.99 Then
                If Y < RNum(INList(2)) Then
                    RList(INList(2), Y) = RList(INList(2), RNum(INList(2)))
                End If
                RNum(INList(2)) = RNum(INList(2)) - 1
            Else
                Y = Y + 1
            End If
        Loop
    End If
    
    For x = 0 To 2
        For Y = 0 To RNum(x)
            OKSeq(x, 15, RList(x, Y)) = 1
        Next Y
    Next x
    Dim RCorrX() As Single
    ReDim RCorrX(2, NextNo)
    For Y = 0 To 2
        For x = 0 To NextNo
            For Z = 0 To 2
                If RCorrWarn(Z) = 0 Then
                    If RInv(Y, Z, x) = 0 Then
                        If RCorrX(Y, x) < RCorr(Y, Z, x) Then RCorrX(Y, x) = RCorr(Y, Z, x)
                    End If
                End If
            Next Z
        Next x
    Next Y
'    XX = RNum(0)
'         XX = RNum(1)
'         XX = RNum(2)
    Call CalcMatchY(ISeqs(), CompMat(), OKSeq(), BPos, Epos)
    
    'Call CalcMatchX(ISeqs(), CompMat(), OKSeq(), BPos, EPos)
    Call ConsensusOK(NextNo, ISeqs(), OKSeq(), RNum(), RList(), RCorrX())
    
    
    
    
    
    
End If





If DontDoScansFlag = 1 Then
    LowestProb = pLowestProb
    Exit Sub
End If
'If SEventNumber = 4 Then
'    X = X
'    XX = ISeqs(0)
'    XX = ISeqs(1)
'    XX = ISeqs(2)
'End If


'ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'ReDim ValidSpacer(Nextno)
'ReDim SpacerSeqs(Nextno)
'ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
'ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
'ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
'If SEventNumber = 7 Then
'    X = X
'End If


'



If RWinPP < 3 Then

    '48.39
    'Exit Sub
    'XX = SEventNumber
'    If SEventNumber = 10 Then
'        x = x '73,76
'        XX = RWinPP
'    End If
'If SEventNumber = 24 Then
'    x = x
'End If

    ReDim XoverList(NextNo, 10)
    ReDim CurrentXOver(NextNo)
    ReDim MaxXOP(AddNum - 1, NextNo)
    Call ResetMaxPVCO(NextNo)
'    If BusyWithExcludes = 1 Then
'        x = x
'        XX = PermNextno
'        XX = RList(1, 0)
'        XX = RNum(1)
'    End If

    If ConservativeGroup = 0 Then
        'This forces extra constraints on the sequences in the rlist so that they have to move around the tree exactly the same way as the sequences in iseqs
        
        Dim ILP(2)
        'test to see if some of the iseqs are overly outlyerish - could indicate that they have recombined with something outside the dataset
        'need to do this because it creates fake signals of corecombination
        Dim MoveDistF() As Single, MoveDistS() As Single
        ReDim MoveDistF(NextNo), MoveDistS(NextNo)
        If PermNextno > MemPoc Then
            GetFMat
            GetSMat
        End If
        '@'@'@'&
        For x = 0 To NextNo
            For Y = 0 To NextNo
                MoveDistF(x) = MoveDistF(x) + FMat(x, Y)
                MoveDistS(x) = MoveDistS(x) + SMat(x, Y)
            Next Y
        Next x
        If PermNextno > MemPoc Then
            '&
            ReDim FMat(0, 0)
            ReDim SMat(0, 0)
        End If
        'work out the ranking of the iseqs in the two lists
        Dim RankF(2) As Long, RankS(2) As Long, MDF As Single, MDS As Single, RankProp
        For x = 0 To 2
            MDF = MoveDistF(ISeqs(x))
            MDS = MoveDistS(ISeqs(x))
            RankF(x) = 0
            RankS(x) = 0
            For Y = 0 To NextNo
                If MDF > MoveDistF(Y) Then RankF(x) = RankF(x) + 1
                If MDS > MoveDistS(Y) Then RankS(x) = RankS(x) + 1
            Next Y
            
            x = x
        Next x
        XX = RWinPP
        
        Dim RSL() As Byte, DBI As Single
            
        For x = 0 To 2
            ReDim RSL(2, NextNo) '
            ILP(0) = 0
            ILP(1) = 0
            Seq1 = ISeqs(x)
            Seq2 = ISeqs(CompMat(x, 0))
            Seq3 = ISeqs(CompMat(x, 1))
'            For Y = 0 To RNum(x)
'                Seq4 = RList(x, Y)
'                If SCMatSmall(x, Seq4) > SCMatSmall(x, Seq2) Or SCMatSmall(x, Seq4) > SCMatSmall(x, Seq3) Then
'                    RSL(x, Seq4) = 1
'                End If
'                If FCMatSmall(x, Seq4) > FCMatSmall(x, Seq2) Or FCMatSmall(x, Seq4) > FCMatSmall(x, Seq3) Then
'                    RSL(x, Seq4) = 1
'                End If
'            Next Y


'XX = RWinPP
            GoOn = 1
            If SAMatSmall(x, Seq2) > SAMatSmall(CompMat(x, 0), Seq3) Or (SMatSmall(x, Seq2) > SMatSmall(CompMat(x, 0), Seq3) And SMatSmall(x, Seq3) > SMatSmall(CompMat(x, 0), Seq3)) Then
                ILP(0) = 1
                'seq1 is an outlyer in the recombinant region
                'This is importnant because it incurs additional constraints
                DBI = SAMatSmall(CompMat(x, 0), Seq3)
                For Y = 0 To RNum(x)
                    Seq4 = RList(x, Y)
                    'XX = ISeqs(x)
                    If SAMatSmall(x, Seq2) <> SAMatSmall(CompMat(x, 0), Seq4) Or SAMatSmall(x, Seq3) <> SAMatSmall(CompMat(x, 1), Seq4) Then
                        RSL(x, Seq4) = 1
                    End If
                    If SAMatSmall(x, Seq4) > DBI Then 'i.e. tree distance between seq1 and seq4 muct be shorter than that between seq2 and seq3
                        RSL(x, Seq4) = 1
                    End If
                    
                    If SAMatSmall(x, Seq4) > DBI Then 'i.e. tree distance between seq1 and seq4 muct be shorter than that between seq2 and seq3
                        RSL(x, Seq4) = 1
                    End If
                    If SMatSmall(x, Seq4) > SMatSmall(CompMat(x, 0), Seq4) Or SMatSmall(x, Seq4) > SMatSmall(CompMat(x, 1), Seq4) Then
                        RSL(x, Seq4) = 1
                    End If
                Next Y
                If FAMatSmall(x, Seq2) < FAMatSmall(x, Seq3) Then
                'seq2 is the major parent
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If FAMatSmall(x, Seq2) <> FAMatSmall(CompMat(x, 0), Seq4) Then 'seq4 must be in the same clade  as seq1
                            RSL(x, Seq4) = 1
                        End If

                    Next Y

                Else
                'seq3 is the major parent
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If FAMatSmall(x, Seq3) <> FAMatSmall(CompMat(x, 1), Seq4) Then  'seq4 must be in the same clade as seq1
                            RSL(x, Seq4) = 1
                        End If
                    Next Y
                End If
                GoOn = 0
            End If
            If FAMatSmall(x, Seq2) > FAMatSmall(CompMat(x, 0), Seq3) Or (FMatSmall(x, Seq2) > FMatSmall(CompMat(x, 0), Seq3) And FMatSmall(x, Seq3) > FMatSmall(CompMat(x, 0), Seq3)) Then
                'seq1 is the outlyer for the remainder of the sequences
                ILP(1) = 1
                DBI = FAMatSmall(CompMat(x, 0), Seq3)
                For Y = 0 To RNum(x)
                    Seq4 = RList(x, Y)
                    If FAMatSmall(x, Seq2) <> FAMatSmall(CompMat(x, 0), Seq4) Or FAMatSmall(x, Seq3) <> FAMatSmall(CompMat(x, 1), Seq4) Then
                        RSL(x, Seq4) = 1
                    End If
                    If FAMatSmall(x, Seq4) > DBI Then 'i.e. tree distance between seq1 and seq4 muct be shorter than that between seq2 and seq3
                        RSL(x, Seq4) = 1
                    End If
                    If FMatSmall(x, Seq4) > FMatSmall(CompMat(x, 0), Seq4) Or FMatSmall(x, Seq4) > FMatSmall(CompMat(x, 1), Seq4) Then
                        RSL(x, Seq4) = 1
                    End If
                Next Y
                If SAMatSmall(x, Seq2) < SAMatSmall(x, Seq3) Then
                'seq2 is the minor parent
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If SAMatSmall(x, Seq2) <> SAMatSmall(CompMat(x, 0), Seq4) Then 'seq4 must be in the same clade  as seq1
                            RSL(x, Seq4) = 1
                        End If

                    Next Y

                Else
                'seq3 is the minor parent
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If SAMatSmall(x, Seq3) <> SAMatSmall(CompMat(x, 1), Seq4) Then  'seq4 must be in the same clade as seq1
                            RSL(x, Seq4) = 1
                        End If
                    Next Y
                End If
                GoOn = 0
            End If
            If GoOn = 1 Then 'seq1 is an inyer in both the recombinant region and the rest of the sequence
                
                
                If SAMatSmall(x, Seq2) < SAMatSmall(x, Seq3) Then
                    'seq3 is the outlyer in the recombinant region
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        'XX = FMatSmall(x, Seq3)
                        If SAMatSmall(x, Seq4) >= SAMatSmall(CompMat(x, 1), Seq4) Or SMatSmall(x, Seq4) > (SMatSmall(x, Seq2) * 6) Then 'if tree dustance between seq1 and seq4 is greater than the tree distance ebtween seq4 and the outlyer Then
                            RSL(x, Seq4) = 1
                        End If
                        If SAMatSmall(x, Seq4) > SAMatSmall(x, Seq2) And SMatSmall(x, Seq2) < FMatSmall(x, Seq2) Then  'if x is closer to seq2 then seq4 must also be
                            If SMatSmall(CompMat(x, 0), Seq4) > FMatSmall(CompMat(x, 0), Seq4) Then
                                RSL(x, Seq4) = 1
                            End If
                        End If
                        
                    Next Y
                    'if seq3 is overly outlyerish (i.e. might have recombined with something outside the dataset
                    'then force a constraint that the corecombinants must have the same or a shorted tree distance to seq2 thna seq1
                    If RankS(CompMat(x, 1)) / NextNo > 0.95 And RankF(CompMat(x, 1)) / NextNo < 0.75 Or (((RankS(CompMat(x, 1)) - RankF(CompMat(x, 1))) / NextNo) > 0.5) Then
                        For Y = 0 To RNum(x)
                            Seq4 = RList(x, Y)
                            If SAMatSmall(CompMat(x, 0), Seq4) > SAMatSmall(x, Seq2) Then
                                RSL(x, Seq4) = 1
                            End If
                        Next Y
                    
                    End If
                    XX = SEventNumber
                    XX = RWinPP
                Else
                    'seq2 is the outlyer in the recombinant region
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If SAMatSmall(x, Seq4) >= SAMatSmall(CompMat(x, 0), Seq4) Or SMatSmall(x, Seq4) > (SMatSmall(x, Seq3) * 6) Then
                            RSL(x, Seq4) = 1
                        End If
                        If SAMatSmall(x, Seq4) > SAMatSmall(x, Seq3) And SMatSmall(x, Seq3) < FMatSmall(x, Seq3) Then 'if x is closer to seq3 then seq4 must also be
                            If SMatSmall(CompMat(x, 1), Seq4) > FMatSmall(CompMat(x, 1), Seq4) Then
                                RSL(x, Seq4) = 1
                            End If
                        End If
                        
                    Next Y
                    'if seq2 is overly outlyerish (i.e. might have recombined with something outside the dataset
                    'then force a constraint that the corecombinants must have the same or a shorted tree distance to seq2 thna seq1
                    If (RankS(CompMat(x, 0)) / NextNo > 0.95 And (RankF(CompMat(x, 0)) / NextNo) < 0.75) Or (((RankS(CompMat(x, 0)) - RankF(CompMat(x, 0))) / NextNo) > 0.5) Then
                        For Y = 0 To RNum(x)
                            Seq4 = RList(x, Y)
                            If SAMatSmall(CompMat(x, 1), Seq4) > SAMatSmall(x, Seq3) Then
                                RSL(x, Seq4) = 1
                            End If
                        Next Y
                    
                    End If
                    XX = SEventNumber
                    XX = RWinPP
                End If
                If FAMatSmall(x, Seq2) < FAMatSmall(x, Seq3) Then
                    'seq3 is the outlyer in the remaining regions
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If FAMatSmall(x, Seq4) >= FAMatSmall(CompMat(x, 1), Seq4) Or FMatSmall(x, Seq4) > (FMatSmall(x, Seq2) * 6) Then 'Or FAMatSmall(x, Seq4) > FAMatSmall(CompMat(x, 0), Seq4) Then
                            RSL(x, Seq4) = 1
                        End If
                        If FAMatSmall(x, Seq4) > FAMatSmall(x, Seq2) And FMatSmall(x, Seq2) < SMatSmall(x, Seq2) Then 'if x is closer to seq2 then seq4 must also be
                            If FMatSmall(CompMat(x, 0), Seq4) > SMatSmall(CompMat(x, 0), Seq4) Then
                                RSL(x, Seq4) = 1
                            End If
                        End If
                        
                    Next Y
                    'if seq3 is overly outlyerish (i.e. might have recombined with something outside the dataset
                    'then force a constraint that the corecombinants must have the same or a shorted tree distance to seq2 thna seq1
                    If RankF(CompMat(x, 1)) / NextNo > 0.95 And RankS(CompMat(x, 1)) / NextNo < 0.75 Or (((RankF(CompMat(x, 1)) - RankS(CompMat(x, 1))) / NextNo) > 0.5) Then
                        For Y = 0 To RNum(x)
                            Seq4 = RList(x, Y)
                            If FAMatSmall(CompMat(x, 0), Seq4) > FAMatSmall(x, Seq2) Then
                                RSL(x, Seq4) = 1
                            End If
                        Next Y
                    
                    End If
                    
                Else
                    'seq2 is the outlyer in the remaining regions
                    For Y = 0 To RNum(x)
                        Seq4 = RList(x, Y)
                        If FAMatSmall(x, Seq4) >= FAMatSmall(CompMat(x, 0), Seq4) Or FMatSmall(x, Seq4) > (FMatSmall(x, Seq3) * 6) Then ' Or FAMatSmall(x, Seq4) > FAMatSmall(CompMat(x, 1), Seq4) Then
                            RSL(x, Seq4) = 1
                        End If
                        If FAMatSmall(x, Seq4) > FAMatSmall(x, Seq3) And FMatSmall(x, Seq3) < SMatSmall(x, Seq3) Then 'if x is closer to seq3 then seq4 must also be
                            If FMatSmall(CompMat(x, 1), Seq4) > SMatSmall(CompMat(x, 1), Seq4) Then
                                RSL(x, Seq4) = 1
                            End If
                        End If
                    Next Y
                    
                    'if seq2 is overly outlyerish (i.e. might have recombined with something outside the dataset
                    'then force a constraint that the corecombinants must have the same or a shorter tree distance to seq2 than seq1
                    If RankF(CompMat(x, 0)) / NextNo > 0.95 And RankS(CompMat(x, 0)) / NextNo < 0.75 Or (((RankF(CompMat(x, 0)) - RankS(CompMat(x, 0))) / NextNo) > 0.5) Then
                        For Y = 0 To RNum(x)
                            Seq4 = RList(x, Y)
                            If FAMatSmall(CompMat(x, 1), Seq4) > FAMatSmall(x, Seq3) Then
                                RSL(x, Seq4) = 1
                            End If
                        Next Y
                    
                    End If
    
                End If
            End If
            Y = 0
            Do While Y <= RNum(x)
                If RSL(x, RList(x, Y)) = 1 Then
                    If Y < RNum(x) Then
                        RList(x, Y) = RList(x, RNum(x))
                    End If
                    RNum(x) = RNum(x) - 1
                Else
                    Y = Y + 1
                End If
                'XX = RList(x, 0)
'                SS = ISeqs(x)
            Loop
            'If you want to add sequences back in then this bit needs to be uncommented
            'now add in sequences if it makes sense (i.e. they are within the bounds of the sequences remaining in rnum
'            If SEventNumber = 15 Then
'                x = x
'                'For x = 0 To Nextno
'                    x = 13
'                    For Y = 1 To CurrentXOver(x)
'                        XX = XoverList(x, Y).Daughter
'                        XX = XoverList(x, Y).MajorP
'                        XX = XoverList(x, Y).MinorP
'                    Next Y
'                'Next x
'            End If
            If BusyWithExcludes = 0 Or (BusyWithExcludes = 1 And PXOList(Trace(0), Trace(1)).EndP = 0 And PXOList(Trace(0), Trace(1)).Daughter <> CurSeedExtras And PXOList(Trace(0), Trace(1)).MajorP <> CurSeedExtras And PXOList(Trace(0), Trace(1)).MinorP <> CurSeedExtras) Then
                Dim HDS As Single, HDF As Single, HDSA As Single, HDFA As Single
                HDS = 0
                HDF = 0
                HDFA = 0
                HDSA = 0
                For Y = 0 To RNum(x)
                    If HDSA < SAMatSmall(x, RList(x, Y)) Then
                        HDSA = SAMatSmall(x, RList(x, Y))
                    End If
                    If HDFA < FAMatSmall(x, RList(x, Y)) Then
                        HDFA = FAMatSmall(x, RList(x, Y))
                    End If
                    If HDS < SMatSmall(x, RList(x, Y)) Then
                        HDS = SMatSmall(x, RList(x, Y))
                    End If
                    If HDF < FMatSmall(x, RList(x, Y)) Then
                        HDF = FMatSmall(x, RList(x, Y))
                    End If
                Next Y
                
                For Y = 0 To NextNo
'                    If SEventNumber = 1 And TraceSub(Y) = 10 Then
'                        x = x
'                        XX = RList(x, 1)
'                        XX = CurrentXOver(Y)
'                    End If
                    'XX = SEventNumber
                    GoOn = 0
                    If SAMatSmall(x, Y) <= HDSA And FAMatSmall(x, Y) <= HDFA And SMatSmall(x, Y) <= HDS And FAMatSmall(x, Y) <= HDF Then
                        If SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 0), Y) And SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 1), Y) Then
                            If FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 0), Y) And FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 1), Y) Then
                                For Z = 0 To RNum(x)
                                    If (RList(x, Z)) = (Y) Then Exit For
                                Next Z
                                If Z = RNum(x) + 1 Then
                                    RNum(x) = RNum(x) + 1
                                    RList(x, RNum(x)) = Y
                                End If
                                    CurrentXOver((Y)) = CurrentXOver((Y)) + 1
                                    'XX = UBound(XoverList, 2)
                                    XoverList(Y, CurrentXOver((Y))) = PXOList(Trace(0), Trace(1))
                                    XoverList(Y, CurrentXOver((Y))).Daughter = (Y)
                                    XoverList(Y, CurrentXOver((Y))).MajorP = (ISeqs(CompMat(x, 0)))
                                    XoverList(Y, CurrentXOver((Y))).MinorP = (ISeqs(CompMat(x, 1)))
                                    XoverList(Y, CurrentXOver((Y))).Probability = 0.9
                                    XoverList(Y, CurrentXOver((Y))).DHolder = Abs(XoverList((Y), CurrentXOver((Y))).DHolder)
                                    'XX = OriginalName(Y)
                                    GoOn = 1
                               ' End If
                            End If
                        End If
                    End If
                    If GoOn = 0 Then
                        If ILP(0) = 0 And ILP(1) = 0 Or x = x Then ' sequence is inlyer in s and f regions
                            If SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 0), Y) And SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 1), Y) And SMatSmall(x, Y) < SMatSmall(CompMat(x, 0), Y) And SMatSmall(x, Y) < SMatSmall(CompMat(x, 1), Y) Then
                                If FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 0), Y) And FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 1), Y) And FMatSmall(x, Y) < FMatSmall(CompMat(x, 0), Y) And FMatSmall(x, Y) < FMatSmall(CompMat(x, 1), Y) Then
                                    For Z = 0 To RNum(x)
                                        If (RList(x, Z)) = (Y) Then Exit For
                                    Next Z
                                    If Z = RNum(x) + 1 Then
                                        RNum(x) = RNum(x) + 1
                                        RList(x, RNum(x)) = Y
                                        
                                    End If
                                        'XX = UBound(XoverList, 2)
                                        CurrentXOver((Y)) = CurrentXOver((Y)) + 1
                                        'XX = UBound(XoverList, 2)
                                        XoverList(Y, CurrentXOver((Y))) = PXOList(Trace(0), Trace(1))
                                        XoverList(Y, CurrentXOver((Y))).Daughter = (Y)
                                        XoverList(Y, CurrentXOver((Y))).MajorP = (ISeqs(CompMat(x, 0)))
                                        XoverList(Y, CurrentXOver((Y))).MinorP = (ISeqs(CompMat(x, 1)))
                                        XoverList(Y, CurrentXOver((Y))).Probability = 0.9
                                        XoverList(Y, CurrentXOver((Y))).DHolder = Abs(XoverList(Y, CurrentXOver(Y)).DHolder)
                                        'XX = OriginalName(Y)
                                        GoOn = 1
                                   ' End If
                                End If
                            End If
'                        ElseIf ILP(0) = 0 Then  ' sequence is inlyer in the s region
'                            If SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 0), Y) And SAMatSmall(x, Y) < SAMatSmall(CompMat(x, 1), Y) Then
'                                For Z = 0 To RNum(x)
'                                    If RList(x, Z) = Y Then Exit For
'                                Next Z
'                                If Z = RNum(x) + 1 Then
'                                    RNum(x) = RNum(x) + 1
'                                    RList(x, RNum(x)) = TraceSub(Y)
'                                End If
'                                CurrentXOver(Y) = CurrentXOver(Y) + 1
'                                'XX = UBound(XoverList, 2)
'                                XoverList(Y, CurrentXOver(Y)) = PXOList(Trace(0), Trace(1))
'                                XoverList(Y, CurrentXOver(Y)).Daughter = TraceSub(Y)
'                                XoverList(Y, CurrentXOver(Y)).MajorP = TraceSub(ISeqs(CompMat(x, 0)))
'                                XoverList(Y, CurrentXOver(Y)).MinorP = TraceSub(ISeqs(CompMat(x, 1)))
'                                XoverList(Y, CurrentXOver(Y)).Probability = 0.99
'                                XoverList(Y, CurrentXOver(Y)).DHolder = Abs(XoverList(Y, CurrentXOver(Y)).DHolder)
'                                'XX = OriginalName(Y)
'                                GoOn = 1
'
'                            End If
'                        ElseIf ILP(1) = 0 Then  ' sequence is an inlyer in the f-region
'                            If FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 0), Y) And FAMatSmall(x, Y) < FAMatSmall(CompMat(x, 1), Y) Then
'                                For Z = 0 To RNum(x)
'                                    If RList(x, Z) = Y Then Exit For
'                                Next Z
'                                If Z = RNum(x) + 1 Then
'                                    RNum(x) = RNum(x) + 1
'                                    RList(x, RNum(x)) = TraceSub(Y)
'                                End If
'                                CurrentXOver(Y) = CurrentXOver(Y) + 1
'                                'XX = UBound(XoverList, 2)
'                                XoverList(Y, CurrentXOver(Y)) = PXOList(Trace(0), Trace(1))
'                                XoverList(Y, CurrentXOver(Y)).Daughter = TraceSub(Y)
'                                XoverList(Y, CurrentXOver(Y)).MajorP = TraceSub(ISeqs(CompMat(x, 0)))
'                                XoverList(Y, CurrentXOver(Y)).MinorP = TraceSub(ISeqs(CompMat(x, 1)))
'                                XoverList(Y, CurrentXOver(Y)).Probability = 0.99
'                                XoverList(Y, CurrentXOver(Y)).DHolder = Abs(XoverList(Y, CurrentXOver(Y)).DHolder)
'                                'XX = OriginalName(Y)
'                                GoOn = 1
                                
'                            End If
                            
                        End If
                    End If
                    
                Next Y
                XX = RWinPP
            End If
        Next x
        
        
    End If

    'XX = RNum(0)
    If DoQuick = 0 And ExRecFlag <> 203 Then    'n
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
            Form1.SSPanel1.Caption = "Rechecking recombination signal"
        End If
        
        
        oLowestProb = LowestProb
        If (LowP * 100000) > LowestProb Then
            LowestProb = LowP * 100000
            'XX = MCCorrection
        End If
        If oLowestProb * MCCorrection > LowestProb Then
            LowestProb = (oLowestProb * MCCorrection)
        End If
        Dim TotRedos As Long, NumDone As Long
        ST = Abs(GetTickCount)
        TotRedos = RNum(0) + RNum(1) + RNum(2) + RNum(RWinPP)
        NumDone = 0
        'XX = UBound(Distance)
        
        If PermNextno > MemPoc And UBound(TreeDistance, 1) = 0 Then
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
    
            ReDim TreeDistance(UBTD1, UBTD1)
            FF = FreeFile
    
'            Open "RDP5Distance" + UFTag For Binary As #FF
'            Get #FF, , Distance()
'            Close #FF
            Open "RDP5TreeDistance" + UFTag For Binary As #FF
            Get #FF, , TreeDistance()
            Close #FF
            ChDir oDir
            ChDrive oDir

        
        End If
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            ReDim PermValid(UBPermValid, UBPermValid)
            Open "RDP5PermValid" + UFTag For Binary As #FF
            Get #FF, , PermValid()
            Close #FF
            
            
            ReDim PermDIffs(UBPermDiffs, UBPermDiffs)
            Open "RDP5PermDiffs" + UFTag For Binary As #FF
            Get #FF, , PermDIffs()
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
        End If
        
'        If DistanceInFileFlag = 1 Or UBound(Distance, 1) <> Nextno Then
'            oDir = CurDir
'            ChDir App.Path
'            ChDrive App.Path
'
'            FF = FreeFile
'            'UBDistance = UBound(Distance, 1)
'            ReDim Distance(UBDistance, UBDistance)
'            Open "RDP5Distance" + UFTag For Binary As #FF
'            Get #FF, , Distance()
'            Close #FF
'            DistanceInFileFlag = 0
'            'Erase Distance
'            ChDir oDir
'            ChDrive oDir
'        End If
        
        'XX = RWinPP
        UB = UBound(Distance, 1)
'        XX = ISeqs(0)
'        XX = ISeqs(1)
'        XX = ISeqs(2)
        
        ReDim SubSeq(Len(StrainSeq(0)), 6)
        
        For WinPP = 0 To 2
            
            For Y = 0 To RNum(WinPP)
                
                If RList(WinPP, Y) <= UB Then
                    Seq1 = RList(WinPP, Y)
                Else
                    Seq1 = TraceSub(RList(WinPP, Y))
                End If
                Seq2 = ISeqs(CompMat(WinPP, 0))
                Seq3 = ISeqs(CompMat(WinPP, 1))
                If Seq1 <= UB And Seq2 <= UB And Seq3 <= UB Then
                    If Seq1 <> ISeqs(WinPP) Then
                        
                        
                        
                        Seq2 = ISeqs(CompMat(WinPP, 0))
                        Seq3 = ISeqs(CompMat(WinPP, 1))
                        
                        'XX = UBound(PXOList, 2)
                        If UBound(PXOList, 2) < Trace(1) Then
                            LowestProb = pLowestProb
                            Exit Sub
                            
                        End If
                        GoOn = 1

                        If GoOn = 1 Then
                            If PermNextno > MemPoc And x = 1234567 And UBound(Distance, 1) <> NextNo And UBDistance = NextNo Then
                                oDir = CurDir
                                ChDir App.Path
                                ChDrive App.Path
                                
                                FF = FreeFile
                                'UBDistance = UBound(Distance, 1)
                                ReDim Distance(UBDistance, UBDistance)
                                Open "RDP5Distance" + UFTag For Binary As #FF
                                Get #FF, , Distance()
                                Close #FF
                                DistanceInFileFlag = 0
                                'Erase Distance
                                ChDir oDir
                                ChDrive oDir
                            End If
                        
                        
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 0 Then
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 1)
                            End If
                            'XX = UseCompress
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 1 Then
                                Call GCXoverD(1)
                            End If
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 2 Then
                               If DoScans(0, 2) = 1 Then
                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                Else
                                    Call BSXoverM(0, 1, WeightMod())
                                End If
                                
                            End If
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 3 Then
                                Call MCXoverF(1, BPos, Epos)
                                'x = x
                            End If
                            
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 4 Then
                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                Call CXoverA(1, BPos, Epos)
                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                Call CXoverA(1, BPos, Epos)
                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                Call CXoverA(1, BPos, Epos)
                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                            End If
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 8 Then
                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                        
                                Call TSXOver(1)
                                        
                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                        
                                Call TSXOver(1)
                                        
                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                        
                                Call TSXOver(1)
                                        
                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                            End If
                            If PXOList(Trace(0), Trace(1)).ProgramFlag = 5 Then
                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                oSSFastFlag = SSFastFlag
                                SSFastFlag = 0
                                Call SSXoverC(CLng(1), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                SSFastFlag = oSSFastFlag
                        
                            End If
                        End If
                    End If
'                    If SEventNumber = 17 And RList(WinPP, Y) = 7 Then
'                        x = x
'                        XX = CurrentXOver(7) '0
'                        XX = CurrentXOver(2) '1
'                        XX = CurrentXOver(25) '1
'                    End If
                End If
                NumDone = NumDone + 1
            Next Y
            ET = Abs(GetTickCount)
            If Abs(ST - GlobalTimer) > 500 Then
                GlobalTimer = ET
                If ReassortmentFlag = 0 Then
                    Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination signals rechecked"
                Else
                    Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination/reassortment signals rechecked"
                End If
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        
        
        Next WinPP
        
'        If SEventNumber = 7 Then
'            X = X
'        End If
        
        WinPP = RWinPP
        LowestProb = pLowestProb
        DontWorryAboutSplitsFlag = 1
        
        UB = UBound(Distance, 1)
        For Y = 0 To RNum(WinPP)
            
            If RList(WinPP, Y) <= UB Then
                Seq1 = RList(WinPP, Y)
            Else
                Seq1 = TraceSub(RList(WinPP, Y))
            End If
            Seq2 = ISeqs(CompMat(WinPP, 0))
            Seq3 = ISeqs(CompMat(WinPP, 1))
            If Seq1 <= UB And Seq2 <= UB And Seq3 <= UB And Seq1 <> Seq2 And Seq1 <> Seq3 And Seq2 <> Seq3 Then
                GoOn = 1
'                If BusyWithExcludes = 1 Then
'                    If Seq1 > PermNextno Then
'                        If Seq2 > PermNextno Or Seq3 > PermNextno Then
'                            GoOn = 0
'                        End If
'                    ElseIf Seq2 > PermNextno Then
'                        If Seq3 > PermNextno Then
'                            GoOn = 0
'                        End If
'                    End If
'                End If
                If GoOn = 1 Then
                    If PermNextno > MemPoc And x = 1234567 And UBound(Distance, 1) <> NextNo And UBDistance = NextNo Then
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        
                        FF = FreeFile
                        'UBDistance = UBound(Distance, 1)
                        ReDim Distance(UBDistance, UBDistance)
                        Open "RDP5Distance" + UFTag For Binary As #FF
                        Get #FF, , Distance()
                        Close #FF
                        DistanceInFileFlag = 0
                        'Erase Distance
                        ChDir oDir
                        ChDrive oDir
                    End If
                    
                    
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 0 Then
                        Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 1)
                    End If
    '                XX = UBound(Distance, 1)
    '                 XX = UBound(TreeDistance, 1)
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 1 Then
                        Call GCXoverD(1)
                    End If
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 2 And (DoScans(0, 2) = 1 Or DoScans(1, 2) = 1) Then
                       If DoScans(0, 2) = 1 Then
                            Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                        Else
                            Call BSXoverM(0, 1, WeightMod())
                           XX = UBound(Distance, 1)
                        End If
                    End If
                    
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 3 Then
                        Call MCXoverF(1, BPos, Epos)
                        x = x
                    End If
         
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 4 Then
                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                        Call CXoverA(2, BPos, Epos)
                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                        Call CXoverA(2, BPos, Epos)
                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                        Call CXoverA(2, BPos, Epos)
                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                        If SEventNumber = 8 Then
                    
                    End If
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 8 Then
                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                
                        Call TSXOver(1)
                                
                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                
                        Call TSXOver(1)
                                
                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                
                        Call TSXOver(1)
                                
                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                    End If
                        
                    End If
                    
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 5 And (DoScans(0, 5) = 1 Or DoScans(1, 5) = 1) Then
                        oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                        
                        oSSFastFlag = SSFastFlag
                        SSFastFlag = 0
                        Call SSXoverC(CLng(1), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                        SSFastFlag = oSSFastFlag
                        
                        
                    End If
                     XX = UBound(Distance, 1)
                    If PXOList(Trace(0), Trace(1)).ProgramFlag <> 7 And ISeqs(WinPP) = Seq1 And (DoScans(0, 7) = 1 Or DoScans(1, 7) = 1) Then
                    
                        Call LXoverA
                    End If
                End If
            End If
            NumDone = NumDone + 1
            
            ET = Abs(GetTickCount)
            If Abs(ST - GlobalTimer) > 500 Then
                GlobalTimer = ET
                If ReassortmentFlag = 0 Then
                    Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination signals rechecked"
                Else
                    Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination/reassortment signals rechecked"
                End If
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        
        Next Y
        
        
        If BusyWithExcludes = 1 Then
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                    ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MajorP > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MinorP > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                    ElseIf XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                    'XX = XoverList(x, Y).EndP '0
                    End If
'                    If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).MajorP), XoverList(x, Y).MajorP + 1))
'                        XoverList(x, Y).EndP = 0
'                    ElseIf XoverList(x, Y).MinorP > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).MinorP), XoverList(x, Y).MinorP + 1))
'                        XoverList(x, Y).EndP = 0
'                    ElseIf XoverList(x, Y).Daughter > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).Daughter), XoverList(x, Y).Daughter + 1))
'                        XoverList(x, Y).EndP = 0
'                    ElseIf XoverList(x, Y).MajorP > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).MajorP), XoverList(x, Y).MajorP + 1))
'                        XoverList(x, Y).EndP = 0
'                    ElseIf XoverList(x, Y).MinorP > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).MinorP), XoverList(x, Y).MinorP + 1))
'                        XoverList(x, Y).EndP = 0
'                    ElseIf XoverList(x, Y).Daughter > PermNextno Then
'                        XoverList(x, Y).BeginP = -(CombineP(OSNPos(XoverList(x, Y).Daughter), XoverList(x, Y).Daughter + 1))
'                        XoverList(x, Y).EndP = 0
'                    End If
                Next Y
            Next x
        End If
        
        'Check any sequences that are nearest relatives of those in Rlist(winpp,y) for evidence of the event
        'do this by loading the sequence off the disk, uppercasing it and copying it into the seqnum of the sequence it is most similar to
        '(after you make a backup of that sequence).  Then extract the xoverlist info and copy that into an xoverlist file that get dumped to the disk
        'then copy the original sequence back to seqnum
        'ExcludeCoords
        Dim EPosX As Long, C As Long, EL As Long, b As Long, S1o As Long, S2o As Long, S3o As Long, TEL As Long, TEB As Long, TB As Long, TE As Long, SeqT As Long
        Dim EListNum As Long, TEString As String, TELong As Long, SeqnumBak() As Long, SSBak() As Long, RSeq As Long, OldNum As Long
        ReDim SeqnumBak(Len(StrainSeq(0))), SSBak(Len(StrainSeq(0)))
        Dim OLcheck() As Integer
        ReDim OLcheck(Len(StrainSeq(0)))
        '@
        If BPos < Epos Then
            For x = 1 To BPos - 1
                OLcheck(x) = -1
            Next x
            For x = BPos To Epos
                OLcheck(x) = 1
            Next x
            For x = Epos + 1 To Len(StrainSeq(0))
                OLcheck(x) = -1
            Next x
        Else
            For x = 1 To Epos
                OLcheck(x) = 1
            Next x
            For x = Epos + 1 To BPos - 1
                OLcheck(x) = -1
            Next x
            For x = BPos To Len(StrainSeq(0))
                OLcheck(x) = 1
            Next x
        End If
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        Dim OriginalPosX As Long
        
'        If SEventNumber = 14 Then
'            x = x
'            XX = RNum(WinPP)
'            XX = RList(WinPP, 0)
'            XX = PXOList(Trace(0), Trace(1)).BeginP
'        End If
        'XX = EventsInExcludeds(0, 919)
        If Dir("RDP5ExcludeList" + UFTag) <> "" And BusyWithExcludes = 0 And ISeqs(RWinPP) <= PermNextno Then 'if true this means that there are extra sequences on the disk that also need to be checked
            Dim oDWS As Byte
            oDWS = DontWorryAboutSplitsFlag
            DontWorryAboutSplitsFlag = 1
            FF = FreeFile
            
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
            'fake treetrace for calcmatch
            Dim TtX() As Long
            ReDim TtX(3)
            TtX(0) = 0
            TtX(1) = 1
            TtX(2) = 2
            TtX(3) = 3
            Dim tSN() As Integer
            ReDim tSN(Len(StrainSeq(0)), 3)
            
            
            Dim TPP As Byte
            UB = UBound(Distance, 1)
            XX = OriginalName(ISeqs(2))
            
            Dim UB1 As Long, UB2 As Long, BakXOVerlist() As XOverDefine, BakCurrentXOver() As Integer, BakMaxXOP() As Double, BakDonePVCO() As Double, BakStorelpv() As Double
            UB1 = UBound(XoverList, 1)
            UB2 = UBound(XoverList, 2)
            ReDim BakXOVerlist(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    BakXOVerlist(Y, Z) = XoverList(Y, Z)
                Next Z
            Next Y
            UB1 = UBound(CurrentXOver, 1)
            ReDim BakCurrentXOver(UB1)
            For Y = 0 To UB1
                BakCurrentXOver(Y) = CurrentXOver(Y)
            Next Y
            UB1 = UBound(MaxXOP, 1)
            UB2 = UBound(MaxXOP, 2)
            ReDim BakMaxXOP(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    BakMaxXOP(Y, Z) = MaxXOP(Y, Z)
                Next Z
            Next Y
            
            UB1 = UBound(DonePVCO, 1)
            UB2 = UBound(DonePVCO, 2)
            ReDim BakDonePVCO(UB1, UB2)
            ReDim BakStorelpv(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    BakDonePVCO(Y, Z) = DonePVCO(Y, Z)
                    BakStorelpv(Y, Z) = StoreLPV(Y, Z)
                Next Z
            Next Y
            
            For TPP = 0 To 2
            
                Seq2 = ISeqs(CompMat(TPP, 0))
                Seq3 = ISeqs(CompMat(TPP, 1))
                '@
                For Z = 0 To Len(StrainSeq(0))
                    tSN(Z, 0) = SeqNum(Z, Seq2)
                    
                Next Z
                For Z = 0 To Len(StrainSeq(0))
                    tSN(Z, 1) = SeqNum(Z, Seq3)
                Next Z
                'XX = RWinPP
                
                'make a backup of currentxover, xoverlist, maxpvco, donepv and storelpv
                
                
                
                ReDim XoverList(NextNo, 10)
                ReDim CurrentXOver(NextNo)
                ReDim MaxXOP(AddNum - 1, NextNo)
                Call ResetMaxPVCO(NextNo)
                
                
                For Y = 0 To RNum(TPP)
                
                    If RList(TPP, Y) <= UB Then
                        Seq1 = RList(TPP, Y)
                    Else
                        Seq1 = TraceSub(RList(TPP, Y))
                    End If
                    If Seq1 <= UB Then
                        Seq2 = ISeqs(CompMat(TPP, 0))
                        Seq3 = ISeqs(CompMat(TPP, 1))
                        If Seq2 <= UB And Seq3 <= UB And Seq1 <> Seq2 And Seq1 <> Seq3 And Seq2 <> Seq3 Then
                            If Seq1 <= UBound(ExcludeCoords) Then
                                Pos = ExcludeCoords(Seq1)
                                If Pos > 0 Then 'this means there are one or more sequences that need to be considered
                                    '@
                                    For Z = 0 To Len(StrainSeq(0))
                                        SeqnumBak(Z) = SeqNum(Z, Seq1)
                                        tSN(Z, 2) = SeqNum(Z, Seq1)
                                    Next Z
                                    
                                    Get #FF, Pos, EListNum
                                    S1o = CurrentXOver(Seq1)
                                    S2o = CurrentXOver(Seq2)
                                    S3o = CurrentXOver(Seq3)
                                    
                                    
                                    
                                    For Z = 1 To EListNum
                                        
                                        
                                        EPosX = Seek(FF) 'remember the position of this specific sequence
                                        '&
                                        Get #FF, , TELong 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                                        Get #FF, , OriginalPosX 'original seq number
                                        
                                        Get #FF, , RSeq 'discard number
                                        '@'@'@
                                        Get #FF, , TELong 'name length
                                        TEString = String(TELong, " ")
                                        '&
                                        Get #FF, , TEString 'originalname
                                        Get #FF, , TELong 'name length
                                        TEString = String(TELong, " ")
                                        '@'@'@'&
                                        Get #FF, , TEString 'strainame
                                        Get #FF, , TELong 'seqeunec length
                                        '@
                                        TEString = String(TELong, " ")
                                        '@
                                        Get #FF, , TEString 'sequence
                                        
                                        If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                                        'there is sequence compression and the loaded sequence needs to be modified accordingly
                                           TEString = CompressTEString(Decompress(), TEString)
                                           'XX = Len(TEString)
                                           'XX = StrainSeq(0)
                                        End If
                                        '@
                                        Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, Seq1), TEString, SSBak(0))
                                        '@
                                        If x = x Then
                                           Dummy = FakeMissing(Seq1, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(tSN, 1), SeqnumBak(0), SeqNum(0, 0), tSN(0, 0))
                                        Else
                                            For A = 0 To Len(StrainSeq(0))
                                                If SeqnumBak(A) < 50 Then SeqNum(A, Seq1) = SeqnumBak(A) 'make sure all the masking is consistent
                                                tSN(A, 3) = SeqNum(A, Seq1)
                                            Next A
                                       End If
                                       
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 0 Then
                                           Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 1)
                                       End If
                                       'XX = UseCompress
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 1 Then
                                           Call GCXoverD(1)
                                       End If
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 2 And (DoScans(0, 2) = 1 Or DoScans(1, 2) = 1) Then
                                          If DoScans(0, 2) = 1 Then
                                               Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                           Else
                                               Call BSXoverM(0, 1, WeightMod())
                                           End If
                                       End If
                                       
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 3 Then
                                           Call MCXoverF(1, BPos, Epos)
                                          ' x = x
                                       End If
                            
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 4 Then
                                           tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                           Call CXoverA(2, BPos, Epos)
                                           Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                           Call CXoverA(2, BPos, Epos)
                                           Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                           Call CXoverA(2, BPos, Epos)
                                           Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                           If SEventNumber = 8 Then
                                       
                                       End If
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 8 Then
                                           tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                   
                                           Call TSXOver(1)
                                                   
                                           Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                   
                                           Call TSXOver(1)
                                                   
                                           Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                   
                                           Call TSXOver(1)
                                                   
                                           Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                       End If
                                           
                                       End If
                                       
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag = 5 And (DoScans(0, 5) = 1 Or DoScans(1, 5) = 1) Then
                                           oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                           
                                           oSSFastFlag = SSFastFlag
                                           SSFastFlag = 0
                                           Call SSXoverC(CLng(1), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                           Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                           SSFastFlag = oSSFastFlag
                                           
                                           
                                       End If
                                       If PXOList(Trace(0), Trace(1)).ProgramFlag <> 7 And ISeqs(TPP) = Seq1 And (DoScans(0, 7) = 1 Or DoScans(1, 7) = 1) Then
                                       
                                           Call LXoverA
                                       End If
                                       
                                       'work out the match accross the breakpoint
                                       'create a tempseqnum
                                       
                                       Call CalcMatch(TtX(), 0, tSN(), 2, 3, 0, 1, BPos, Epos)
                                       'bevss(0)=match over the bpos
                                       'bevss(1)=match over the epos
                                       XX = BEVSS(0)
                                       XX = BEVSS(1)
                                       GoOn = 0
                                       For b = 0 To 2
                                           If b = 0 Then
                                                SeqT = Seq1
                                                OldNum = S1o
                                           ElseIf b = 1 Then
                                                SeqT = Seq2
                                                OldNum = S2o
                                           ElseIf b = 2 Then
                                                SeqT = Seq3
                                                OldNum = S3o
                                           End If
                                           If CurrentXOver(SeqT) > OldNum Then 'some event(s) have been detected
                                                If BPos < Epos Then
                                                    EL = Epos - BPos
                                                Else
                                                    EL = Epos + Len(StrainSeq(0)) - BPos
                                                End If
                                                '@'@
                                                For x = OldNum + 1 To CurrentXOver(SeqT)
                                                    TB = XoverList(SeqT, x).Beginning
                                                    TE = XoverList(SeqT, x).Ending
                                                    Dim SizeFrag As Long
                                                    OL = 0
                                                    If TB < TE Then
                                                        For C = TB To TE
                                                            OL = OL + OLcheck(C)
                                                        Next C
                                                        SizeFrag = TE - TB + 1
                                                    Else
                                                        For C = 1 To TE
                                                            OL = OL + OLcheck(C)
                                                        Next C
                                                        For C = TB To Len(StrainSeq(0))
                                                            OL = OL + OLcheck(C)
                                                        Next C
                                                        SizeFrag = TE + Len(StrainSeq(0)) - TB + 1
                                                    End If
                                                    
                                                    If OL > EL * 0.5 Or BEVSS(0) > 0.7 Or BEVSS(1) > 0.7 Then
                                                        GoOn = 1
                                                        ExcludedEventNum = ExcludedEventNum + 1
                                                        ExcludedEventBPNum = ExcludedEventBPNum + 1
                                                        If ExcludedEventNum < ExcludedEventNumThresh Then
                                                            If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
                                                                ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
                                                            End If
                                                        Else
                                                            
                                                            Dim NF3 As Long
                                                            NF3 = FreeFile
                                                            oDirX = CurDir
                                                            ChDrive App.Path
                                                            ChDir App.Path
                                                            Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                                            NumExcludedEventNum = NumExcludedEventNum + 1
                                                            Put #NF3, 1, ExcludedEventNum
                                                            Put #NF3, , EventsInExcludeds
                                                            Close #NF3
                                                            ReDim EventsInExcludeds(5, 1000)
                                                            ExcludedEventNum = 1
                                                            ChDrive oDirX
                                                            ChDir oDirX
                                                        End If
                                                        'XX = UBound(EventsInExcludedsBP, 1)
                                                        If ExcludedEventNum > UBound(EventsInExcludedsBP, 2) Then
                                                            ReDim Preserve EventsInExcludedsBP(1, ExcludedEventNum + 100)
                                                        End If
                                                        EventsInExcludeds(0, ExcludedEventNum) = RSeq 'discard number
                                                        EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
                                                        EventsInExcludeds(2, ExcludedEventNum) = EPosX 'the position of the sequence in the excludes file
                                                        EventsInExcludeds(3, ExcludedEventNum) = Seq1 'sequence this exclude is most similar to
                                                        EventsInExcludeds(4, ExcludedEventNum) = OriginalPosX
                                                        If BEVSS(0) > 0.7 And BEVSS(1) > 0.7 Then
                                                            EventsInExcludeds(5, ExcludedEventNum) = 1
                                                        ElseIf BEVSS(0) > 0.7 Then
                                                            EventsInExcludeds(5, ExcludedEventNum) = 2
                                                        ElseIf BEVSS(1) > 0.7 Then
                                                            EventsInExcludeds(5, ExcludedEventNum) = 3
                                                        Else
                                                            EventsInExcludeds(5, ExcludedEventNum) = 5
                                                        End If
                                                        If SizeFrag > EL * 1.05 Then 'if the recombination frag in the excluded is more than 5% bigger
                                                                                    'than that in the included then record its breakpoints
                                                            EventsInExcludedsBP(0, ExcludedEventNum) = TB
                                                            EventsInExcludedsBP(1, ExcludedEventNum) = TE
                                                            
                                                        End If
                                                        
                                                        'only want to include one version of this event so need to exit for here
                                                        b = 2
                                                        Exit For
'                                                    ElseIf ConservativeGroup = 0 Then
'                                                        ExcludedEventNum = ExcludedEventNum + 1
'                                                        If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
'                                                            ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
'                                                        End If
'                                                        EventsInExcludeds(0, ExcludedEventNum) = RSeq
'                                                        EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
'                                                        EventsInExcludeds(2, ExcludedEventNum) = EPosX 'the position of the sequence in the excludes file
'                                                        EventsInExcludeds(3, ExcludedEventNum) = Seq1 'sequenec this exclude is most similar to
'                                                        EventsInExcludeds(4, ExcludedEventNum) = OriginalPosX
'                                                        EventsInExcludeds(5, ExcludedEventNum) = 6
                                                    End If
                                                    
                                                Next x
                                                
                                           
                                           End If
                                       Next b
                                       If GoOn = 0 And ConservativeGroup = 0 Then
                                            ExcludedEventNum = ExcludedEventNum + 1
                                            ExcludedEventBPNum = ExcludedEventBPNum + 1
                                            'need a mechanism here to stop EventsInExcludeds getting too big - need to dynamically drop it to disk
                                            If ExcludedEventNum < ExcludedEventNumThresh Then
                                                If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
                                                    ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
                                                End If
                                            Else
                                                
                                                'Dim NF3 As Long
                                                NF3 = FreeFile
                                                oDirX = CurDir
                                                ChDrive App.Path
                                                ChDir App.Path
                                                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                                NumExcludedEventNum = NumExcludedEventNum + 1
                                                Put #NF3, 1, ExcludedEventNum
                                                Put #NF3, , EventsInExcludeds
                                                Close #NF3
                                                ReDim EventsInExcludeds(5, 1000)
                                                ExcludedEventNum = 1
                                                ChDrive oDirX
                                                ChDir oDirX
                                            End If
                                            EventsInExcludeds(0, ExcludedEventNum) = RSeq
                                            EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
                                            EventsInExcludeds(2, ExcludedEventNum) = EPosX 'the position of the sequence in the excludes file
                                            EventsInExcludeds(3, ExcludedEventNum) = Seq1 'sequenec this exclude is most similar to
                                            EventsInExcludeds(4, ExcludedEventNum) = OriginalPosX
                                            EventsInExcludeds(5, ExcludedEventNum) = 6
                                            'Exit For
                                        End If
                                        CurrentXOver(Seq1) = S1o 'reset currentxover
                                        CurrentXOver(Seq2) = S2o
                                        CurrentXOver(Seq3) = S3o
                                    Next Z
                                    'replace the original seqnum
                                    '@'@'&
                                    For Z = 0 To Len(StrainSeq(0))
                                        SeqNum(Z, Seq1) = SeqnumBak(Z)
                                    Next Z
                                End If
                            End If
                        End If
                    End If
                    NumDone = NumDone + 1
                    
                    ET = Abs(GetTickCount)
                    If Abs(ST - GlobalTimer) > 500 Then
                        GlobalTimer = ET
                        If ReassortmentFlag = 0 Then
                            Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination signals rechecked"
                        Else
                            Form1.SSPanel1.Caption = Trim(Str(NumDone + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination/reassortment signals rechecked"
                        End If
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                
                Next Y
                
                
                
                
                
            Next TPP
            Close #FF
            
            UB1 = UBound(BakXOVerlist, 1)
            UB2 = UBound(BakXOVerlist, 2)
            ReDim XoverList(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    XoverList(Y, Z) = BakXOVerlist(Y, Z)
                Next Z
            Next Y
            UB1 = UBound(BakCurrentXOver, 1)
            ReDim CurrentXOver(UB1)
            For Y = 0 To UB1
                CurrentXOver(Y) = BakCurrentXOver(Y)
            Next Y
            UB1 = UBound(BakMaxXOP, 1)
            UB2 = UBound(BakMaxXOP, 2)
            ReDim MaxXOP(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    MaxXOP(Y, Z) = BakMaxXOP(Y, Z)
                Next Z
            Next Y
            
            UB1 = UBound(BakDonePVCO, 1)
            UB2 = UBound(BakDonePVCO, 2)
            ReDim DonePVCO(UB1, UB2)
            ReDim StoreLPV(UB1, UB2)
            For Y = 0 To UB1
                For Z = 0 To UB2
                    DonePVCO(Y, Z) = BakDonePVCO(Y, Z)
                    StoreLPV(Y, Z) = BakStorelpv(Y, Z)
                Next Z
            Next Y
            
            
           
            DontWorryAboutSplitsFlag = oDWS
        
        End If
        
        
        
        
        
        ChDrive oDirX
        ChDir oDirX
        
        
      
        
        
        
        If PermNextno > MemPoc Then
            ReDim TreeDistance(0, 0)
        End If
        DontWorryAboutSplitsFlag = 0
        'XX = XOverList(19, 9).Probability
        LowestProb = pLowestProb
        Dim BPXOS As Long
        BPXOS = (200000 / NextNo)
        For x = 0 To NextNo '19,3
            
            For Y = 1 To CurrentXOver(x)
                If PCurrentXover(x) < BPXOS Then
                    PCurrentXover(x) = PCurrentXover(x) + 1
                    If PCurrentXover(x) > UBound(PXOList, 2) Then
                        '@'@
                        If DebuggingFlag < 2 Then On Error Resume Next
                        '@'@
                        ReDim Preserve PXOList(UBound(PXOList, 1), PCurrentXover(x) + 10)
                        On Error GoTo 0
                        
                        
                    End If
                    If UBound(PXOList, 2) < PCurrentXover(x) Then
                        PCurrentXover(x) = PCurrentXover(x) - 1
                        Call AddToRedoList(XoverList(x, Y).ProgramFlag, XoverList(x, Y).Daughter, XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                        x = x
                    Else
                        PXOList(x, PCurrentXover(x)) = XoverList(x, Y) '19,169
                    End If
                
                Else
                    Call AddToRedoList(XoverList(x, Y).ProgramFlag, XoverList(x, Y).Daughter, XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                    x = x
                End If
            Next Y
            x = x
        Next x
        If PermNextno > MemPoc Then
            ReDim PermValid(0, 0)
            ReDim PermDIffs(0, 0)
        End If

    End If
'    If BusyWithExcludes = 1 And x = 12345 Then
'        Dim DoneZ() As Byte
'        ReDim DoneZ(Nextno, 2)
'        If Nextno - PermNextno > 1 Then
'            If BPos < EPos Then
'                EL = EPos - BPos
'            Else
'                EL = EPos + Len(StrainSeq(0)) - BPos
'            End If
'            For x = 0 To Nextno
'                For Y = 1 To PCurrentXOver(x)
'                    TB = PXOList(x, Y).Beginning
'                    TE = PXOList(x, Y).Ending
'                    D = PXOList(x, Y).Daughter
'
'                    Mi = PXOList(x, Y).MinorP
'                    Ma = PXOList(x, Y).MajorP
'                    If D > PermNextno Or Mi > PermNextno Or Ma > PermNextno Then
'                        OL = 0
'                        If TB < TE Then
'                            For C = TB To TE
'                                OL = OL + OLcheck(C)
'
'                            Next C
'                        Else
'                            For C = 1 To TE
'                                OL = OL + OLcheck(C)
'                            Next C
'                            For C = TB To Len(StrainSeq(0))
'                                OL = OL + OLcheck(C)
'                            Next C
'                        End If
'                        If OL > EL * 0.5 Then
'
'                            If D > PermNextno Then
'                                Z = D
'                            ElseIf Mi > PermNextno Then
'
'                                Z = Mi
'                            ElseIf Ma > PermNextno Then
'
'                                Z = Ma
'                            End If
'
'                            If PXOList(x, Y).Probability > LowestProb Then
'                                DoneZ(Z, 2) = 1
'                            ElseIf OL > EL * 0.9 Then
'                                DoneZ(Z, 0) = 1
'                            Else
'                                DoneZ(Z, 1) = 1
'                            End If
'                        End If
'                    End If
'                Next Y
'            Next x
'            For Z = PermNextno + 1 To Nextno
'                If DoneZ(Z, 0) = 1 Or DoneZ(Z, 1) Or DoneZ(Z, 2) Then
'                    ExcludedEventNum = ExcludedEventNum + 1
'                    If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
'                        ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
'                    End If
'                    If CurSeedExtras > PermNextno Then
'                        x = x
'                    End If
''                    If ExcludedEventNum = 919 Then
''                        x = x
''                    End If
'                    EventsInExcludeds(0, ExcludedEventNum) = CurSeedExtras 'sequence this exclude is most similar to in the includedlist
'                    EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
'                    EventsInExcludeds(2, ExcludedEventNum) = 0 'RList(x, Y) 'the number of the sequence at this time
'                    EventsInExcludeds(3, ExcludedEventNum) = Z
'                    EventsInExcludeds(4, ExcludedEventNum) = OSNPos(Z) 'OriginalPos(RList(WinPP, WinPPY)) 'original number of this sequence
'                    If DoneZ(Z, 0) = 1 Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 1
'                    ElseIf DoneZ(Z, 1) = 1 Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 2
'                    ElseIf DoneZ(Z, 2) = 1 Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 5
'                    End If
'                End If
'            Next Z
'        End If
'    End If
End If

'XX = EventsInExcludeds(0, 919)



TT = Abs(GetTickCount)
If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
  '@
    If ReassortmentFlag = 0 Then
        Form1.SSPanel1.Caption = Trim(Str(TotRedos + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination signals rechecked"
    Else
        Form1.SSPanel1.Caption = Trim(Str(TotRedos + 1)) + " of " + Trim(Str(TotRedos + 1)) + " recombination/reassortment signals rechecked"
    End If
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If
End Sub

Public Sub doAlignmentSh(UFTag As String, AcanaFlag As Byte, SeqsIn() As Integer, SeqsOut() As Integer, NumSeqs As Long, MaxLen As Long, GapO As Long, GapE As Long, GapReset As Long)

Dim UB As Long, FString As String, FLen As Long, Y As Long, x As Long, YPos As Long, CurSeq As Long, CurSeqS As String, WholeFile() As Byte, OSX As String, OS() As String, oDir As String, FF As Integer
'make strings from seqsin
ReDim OS(NumSeqs)
For x = 0 To NumSeqs
    OS(x) = String(MaxLen, " ")
Next x

Dim CPos As Long
If GapReset = 0 Then
    For x = 0 To NumSeqs
        CPos = 0
        For Y = 1 To MaxLen
            If SeqsIn(Y, x) <> 46 And SeqsIn(Y, x) <> 0 Then
                CPos = CPos + 1
                Mid$(OS(x), CPos, 1) = Chr(SeqsIn(Y, x) - 1)
                x = x
            End If
        Next Y
       
    Next x
   
Else
    For x = 0 To NumSeqs
        For Y = 1 To MaxLen
            If SeqsIn(Y, x) <> 0 Then
                CPos = CPos + 1
                Mid$(OS(x), CPos, 1) = Chr(SeqsIn(Y, x) - 1)
            End If
        Next Y
    Next x
End If

If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
'@
ChDir App.Path 'safepath
ChDrive App.Path
On Error GoTo 0
'Make batch file
FF = FreeFile

For x = 0 To 50
    Close #x
Next x

XX = CurDir

'Make infile
If DebuggingFlag < 2 Then On Error Resume Next
FString = Dir("clustal.bat")
If FString <> "" Then
    KillFile "clustal.bat"
End If

FString = Dir("clustal.bat")
FLen = 0


If FString <> "" Then 'this means that for some reason the file did not get deleted - we need to use another name for it
    
    FString = "clustal" & Trim(Str(Rnd)) & ".bat"
Else
    FString = "clustal.bat"
End If
On Error GoTo 0


Dim ExtraV As String
ExtraV = ""
For x = 0 To NumSeqs
    If Len(OS(x)) > 32000 Then
        AcanaFlag = 0 'only clusta can handle longer alignments
        'ExtraV = " -sv -loga -*verbose"
        'Exit For
        
        
    End If
Next x

If DebuggingFlag < 2 Then On Error Resume Next
'Close #FF
Open FString For Output As #FF
If AcanaFlag = 0 Then
    If GapReset = 0 Then
        OSX = "clustalw.exe /infile=IF" + UFTag + ".seq /output=fasta /type=d /gapopen=" + Trim(Str(GapO)) + " /gapext=" + Trim(Str(GapE)) + Chr(34)
    Else
        OSX = "clustalw.exe /PROFILE1=IF1" + UFTag + ".seq /PROFILE2=IF2" + UFTag + ".seq /output=fasta /type=d /gapopen=5 /gapext=0" + Chr(34)
    End If
ElseIf AcanaFlag = 1 Then
    OSX = "muscle3.8.31_i86win32.exe -in IF" + UFTag + ".seq -out IF" + UFTag + ".fasta -maxiters 1 -diags1 -quiet" ' + ExtraV
End If
Print #FF, OSX

'Print #FF, "del " + FString

Close #FF

FLen = 0
FLen = FileLen("clustal.bat")
On Error GoTo 0
If FLen = 0 Then 'the user is not an administrator
    
    Exit Sub
    'copy clustalw to the safepath directory
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FileCopy "coordinates.txt", SafePath + "\test.txt"
    FileCopy "clustalw.exe", SafePath + "\clustalw.exe"
    
    
    ChDir (SafePath)
    ChDrive (SafePath)
    Open FString For Output As #FF
    If AcanaFlag = 0 Then
        If GapReset = 0 Then
            OSX = "clustalw.exe /infile=IF" + UFTag + ".seq /output=fasta /type=d /gapopen=" + Trim(Str(GapO)) + " /gapext=" + Trim(Str(GapE))
        Else
            OSX = "clustalw.exe /PROFILE1=IF1" + UFTag + ".seq /PROFILE2=IF2" + UFTag + ".seq /output=fasta /type=d /gapopen=5 /gapext=0"
        End If
    Else
        OSX = "muscle3.8.31_i86win32.exe -in IF" + UFTag + ".seq -out IF" + UFTag + ".fasta -maxiters 1 -diags1 -quiet" ' + ExtraV
    End If
    
    Print #FF, OSX
    
    'Print #FF, "del " + FString
    
    Close #FF

    
    
End If



FF = FreeFile
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "infile"
On Error GoTo 0
For x = 0 To NumSeqs
    OS(x) = Trim(OS(x))
Next x

'make sure that the sequences arn't too long

For x = 0 To NumSeqs
    If Len(OS(x)) > 200000 Then
        OS(x) = Left(OS(x), 200000)
    End If
Next x

If GapReset = 0 Then
    Open "IF" + UFTag + ".seq" For Output As #FF
    For x = 0 To NumSeqs
        Print #FF, ">S" + Trim(Str(x))
        Print #FF, Trim(OS(x))
    Next x
    Close #FF
Else
    Open "IF1" + UFTag + ".seq" For Output As #FF
    Print #FF, ">S" + Trim(Str(0))
    Print #FF, Trim(OS(0))
    Close #FF
    Open "IF2" + UFTag + ".seq" For Output As #FF
    Print #FF, ">S" + Trim(Str(1))
    Print #FF, Trim(OS(1))
    Close #FF
End If
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "IF" + UFTag + ".fasta"
On Error GoTo 0
'Do
XX = CurDir
of1e = Form1.Picture1.Enabled
Form1.Picture1.Enabled = False
ShellAndClose FString & " >NUL", 0
Form1.Picture1.Enabled = of1e
If DebuggingFlag < 2 Then On Error Resume Next
KillFile FString
ChDrive App.Path
ChDir App.Path
On Error GoTo 0

'XX = curdrive

'Loop
x = x
FF = FreeFile
XX = CurDir
If GapReset = 0 Then
    Open "IF" + UFTag + ".fasta" For Binary As #FF
Else
    Open "IF1" + UFTag + ".fasta" For Binary As #FF
End If
ReDim WholeFile(LOF(FF))
Get #FF, , WholeFile()
Close #FF
UB = UBound(WholeFile, 1)
If UB = 0 Then 'this checks whether shellandclose has messed up and uses an alternative approach if it has - I've no idea why shellandclose soemtimes messes up with clustalw
    Call GetCommandOutput(OSX, 0, True, True)
    FF = FreeFile
    If GapReset = 0 Then
        Open "IF" + UFTag + ".fasta" For Binary As #FF
    Else
        Open "IF1" + UFTag + ".fasta" For Binary As #FF
    End If
    ReDim WholeFile(LOF(FF))
    Get #FF, , WholeFile()
    Close #FF
    UB = UBound(WholeFile, 1)
    If UB = 0 Then
     
     Exit Sub
    End If
End If
If AbortFlag = 1 Then Exit Sub
YPos = 0
For x = 0 To UBound(WholeFile)
    If WholeFile(x) = 62 Then
        CurSeqS = ""
        x = x + 2
        Do While WholeFile(x) > 47 And WholeFile(x) < 58
            CurSeqS = CurSeqS + Chr(WholeFile(x))
            YPos = 0
            x = x + 1
        Loop
        CurSeq = CLng(CurSeqS)
        x = x
    ElseIf WholeFile(x) = 45 Or (WholeFile(x) > 64 And WholeFile(x) < 85) Then
        YPos = YPos + 1
        'XX = UBound(SeqsOut, 1)
        SeqsOut(YPos, CurSeq) = WholeFile(x) + 1
        'XX = UBound(SeqsOut, 1)
    End If
Next x
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
On Error GoTo 0
End Sub

Public Function CalcChiP(A, b, C, D)
Dim e As Double, F As Double, ChiH As Double
If A + C > 0 And b + D > 0 Then
    e = A * D - b * C
    F = (A + b + C + D) / 2
    ChiH = e * e * 2 / (F * (A + C) * (b + D))
    CalcChiP = ChiPVal(ChiH)
                 
Else
    CalcChiP = 1
End If

End Function

Public Function CalcChiV(A, b, C, D)
Dim e As Double, F As Double, ChiH As Double
If A + C > 0 And b + D > 0 Then
    e = A * D - b * C
    F = (A + b + C + D) / 2
    CalcChiV = e * e * 2 / (F * (A + C) * (b + D))
    
                 
Else
    CalcChiV = 0
End If




End Function
Public Function CalcChiV2(A As Long, b As Long, C As Long, D As Long)
Dim e As Double, F As Double, ChiH As Double
If A + C > 0 And b + D > 0 Then
    e = A * D - b * C
    F = (A + b + C + D) / 2
    CalcChiV2 = e * e * 2 / (F * (A + C) * (b + D))
    
                 
Else
    CalcChiV2 = 0
End If




End Function
Public Sub RAlignAndRecheck(Prg As Byte, SeqNum() As Integer, ISeqs() As Long, BPos As Long, Epos As Long, AAF As Byte)

Dim Tots1 As Long, Tots2 As Long, A As Long, MAProb As Double, M(1) As Long, S1 As Long, s2 As Long, AScore(2) As Double, WinScore As Byte, x As Long, Y As Long, Z As Long, Matches() As Long, OLSeq() As Byte, SCount As Long, UEBPos() As Long, AEBPos() As Long, TXON() As Integer, tXOL() As XOverDefine, SeqsIn() As Integer, SeqsOut() As Integer, MaxLen As Long

'XXX = Eventnumber
Form1.SSPanel1.Caption = "Checking alignment consistency"
MaxLen = 0
'dim to the enb of the longest sequence





'For X = 0 To 2
'    If MaxLen < Len(StrainSeq(0)) - SeqSpaces(Len(StrainSeq(0)), ISeqs(X)) Then
'        MaxLen = Len(StrainSeq(0)) - SeqSpaces(Len(StrainSeq(0)), ISeqs(X))
'    End If
'Next X

'MaxLen = MaxLen + 200
'XX = (Len(StrainSeq(0)) - MaxLen)


If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
    If BPos < Epos Then
        MaxLen = (Epos - BPos + 1)
    Else
        MaxLen = Len(StrainSeq(0)) - BPos + Epos + 1
    End If
    ReDim SeqsOut(MaxLen * 3, 2), SeqsIn(MaxLen, 2)
    If MaxLen > 20000 Then
        AAF = 0
        Exit Sub
    End If
    MaxLen = 0

    For Y = 0 To 2
        Z = 0
        If BPos < Epos Then
            For x = BPos To Epos
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
            Next x
        Else
            For x = BPos To Len(StrainSeq(0))
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
            Next x
            For x = 1 To Epos
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
            Next x
        End If
        'For X = Z To MaxLen
        '    SeqsIn(X, Y) = 46
        'Next X
         If Z - 1 > MaxLen Then MaxLen = Z - 1
    Next Y
Else
    If Decompress(BPos) < Decompress(Epos) Then
        MaxLen = (Decompress(Epos) - Decompress(BPos) + 1)
    Else
        MaxLen = Decompress(Len(StrainSeq(0))) - Decompress(BPos) + Decompress(Epos) + 1
    End If
    If MaxLen > 20000 Then
        AAF = 0
        Exit Sub
    End If
    ReDim SeqsOut(MaxLen * 3, 2), SeqsIn(MaxLen, 2)
    MaxLen = 0
    For Y = 0 To 2
        Z = 0
        If Decompress(BPos) < Decompress(Epos) Then
            For x = BPos To Epos
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
                If x < Epos Then
                    For A = Decompress(x) To Decompress(x + 1)
                        If ABCons(A) > 0 Then
                            Z = Z + 1
                            SeqsIn(Z, Y) = ABCons(A) + 1
                        End If
                    Next A
                End If
            Next x
        Else
            For x = BPos To Len(StrainSeq(0))
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
                If x < Len(StrainSeq(0)) Then
                    For A = Decompress(x) To Decompress(x + 1)
                        If ABCons(A) > 0 Then
                            Z = Z + 1
                            SeqsIn(Z, Y) = ABCons(A) + 1
                        End If
                    Next A
                End If
            Next x
            For x = 1 To Epos
                If SeqNum(x, ISeqs(Y)) <> 46 Then
                    Z = Z + 1
                    SeqsIn(Z, Y) = SeqNum(x, ISeqs(Y))
                End If
                If x < Epos Then
                    For A = Decompress(x) To Decompress(x + 1)
                        If ABCons(A) > 0 Then
                            Z = Z + 1
                            SeqsIn(Z, Y) = ABCons(A) + 1
                        End If
                    Next A
                End If
            Next x
        End If
        'For X = Z To MaxLen
        '    SeqsIn(X, Y) = 46
        'Next X
         If Z - 1 > MaxLen Then MaxLen = Z - 1
    Next Y
End If


Dim SSN As String
Dim CPos As Long


'Call doAlignment(SeqsIn(0, 0), SeqsOut(0, 0), 2, MaxLen, 10, 5, 0)
Call doAlignmentSh(UFTag, 1, SeqsIn(), SeqsOut(), 2, MaxLen, 10, 5, 0)

' Call doPOA(SeqNum(0, 0), SeqsOut(0, 0), Nextno, Len(StrainSeq(0)), RateMat(), 10, 5, 0)
'SeqSpaces(XOverList(RecSeq, PAVal).Beginning, RecSeq))
If DebuggingFlag < 2 Then On Error Resume Next
KillFile SSN
On Error GoTo 0


'Find BPos and EPos in unaligned seqs
'ReDim UEBPos(1, 2), AEBPos(1, 2)
'For X = 0 To 2
'    UEBPos(0, X) = BPos - SeqSpaces(BPos, ISeqs(X))
'    UEBPos(1, X) = EPos - SeqSpaces(EPos, ISeqs(X))
'Next X




'find bpos and epos in new alignment
'SCount = 0
'For X = 0 To 2
'    SCount = 0
'    For Y = 1 To Len(StrainSeq(0)) * 2
'        If SeqsOut(Y, X) = 46 Then
'            SCount = SCount + 1
'
'        End If
'        If Y - SCount = UEBPos(0, X) Then
'            AEBPos(0, X) = Y
 '       End If
'        If Y - SCount = UEBPos(1, X) Then
'            AEBPos(1, X) = Y
'        End If
'        If AEBPos(0, X) > 0 And AEBPos(1, X) > 0 Then
'
'            Exit For
'        End If
'        X = X
'    Next Y
'Next X

'ReDim OLSeq(Len(StrainSeq(0)) * 2)
'For X = 0 To 2
'    If AEBPos(0, X) < AEBPos(1, X) Then
'        For Y = AEBPos(0, X) To AEBPos(1, X)
'            OLSeq(Y) = OLSeq(Y) + 1
'        Next Y
'    Else
'        For Y = AEBPos(0, X) To Len(StrainSeq(0)) * 2
'            OLSeq(Y) = OLSeq(Y) + 1
'
'        Next Y
'         For Y = 1 To AEBPos(1, X)
'            OLSeq(Y) = OLSeq(Y) + 1
'        Next Y
'    End If
'Next X

ReDim Matches(1, 1, 2)
If SeqsOut(1, 0) = 0 Then
    AAF = 0
    Exit Sub
End If
For x = 1 To MaxLen * 2
    'If OLSeq(X) = 3 Then
        'If SeqsOut(X, 0) <> SeqsOut(X, 1) Or SeqsOut(X, 0) <> SeqsOut(X, 2) Then
            If SeqsOut(x, 0) <> 46 And SeqsOut(x, 1) <> 46 And SeqsOut(x, 2) <> 46 Then
            
                If SeqsOut(x, 0) = 0 Then
                   Exit For
                End If
                If SeqsOut(x, 0) = SeqsOut(x, 1) Then
                    Matches(1, 1, 0) = Matches(1, 1, 0) + 1
                Else
                    Matches(1, 0, 0) = Matches(1, 0, 0) + 1
                End If
                    
                If SeqsOut(x, 0) = SeqsOut(x, 2) Then
                    Matches(1, 1, 1) = Matches(1, 1, 1) + 1
                Else
                    Matches(1, 0, 1) = Matches(1, 0, 1) + 1
                End If
                    
                If SeqsOut(x, 1) = SeqsOut(x, 2) Then
                    Matches(1, 1, 2) = Matches(1, 1, 2) + 1
                Else
                    Matches(1, 0, 2) = Matches(1, 0, 2) + 1
                End If
            End If
        'End If
    'End If
Next x

If BPos < Epos Then
    For x = BPos To Epos
        'If SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(1)) Or SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(2)) Then
            If SeqNum(x, ISeqs(0)) <> 46 And SeqNum(x, ISeqs(1)) <> 46 And SeqNum(x, ISeqs(2)) <> 46 Then
                'If SeqNum(X, ISeqs(0)) <> 46 And SeqNum(X, ISeqs(1)) <> 46 And SeqNum(X, ISeqs(2)) <> 46 Then
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(1)) Then
                        Matches(0, 1, 0) = Matches(0, 1, 0) + 1
                    Else
                        Matches(0, 0, 0) = Matches(0, 0, 0) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 1) = Matches(0, 1, 1) + 1
                    Else
                        Matches(0, 0, 1) = Matches(0, 0, 1) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(1)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 2) = Matches(0, 1, 2) + 1
                    Else
                        Matches(0, 0, 2) = Matches(0, 0, 2) + 1
                    End If
                'End If
            End If
        'End If
    Next x
Else
    For x = 1 To Epos
        'If SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(1)) Or SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(2)) Then
            If SeqNum(x, ISeqs(0)) <> 46 And SeqNum(x, ISeqs(1)) <> 46 And SeqNum(x, ISeqs(2)) <> 46 Then
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(1)) Then
                        Matches(0, 1, 0) = Matches(0, 1, 0) + 1
                    Else
                        Matches(0, 0, 0) = Matches(0, 0, 0) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 1) = Matches(0, 1, 1) + 1
                    Else
                        Matches(0, 0, 1) = Matches(0, 0, 1) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(1)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 2) = Matches(0, 1, 2) + 1
                    Else
                        Matches(0, 0, 2) = Matches(0, 0, 2) + 1
                    End If
            End If
        'End If
    Next x
    For x = BPos To Len(StrainSeq(0))
        'If SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(1)) Or SeqNum(X, ISeqs(0)) <> SeqNum(X, ISeqs(2)) Then
            If SeqNum(x, ISeqs(0)) <> 46 And SeqNum(x, ISeqs(1)) <> 46 And SeqNum(x, ISeqs(2)) <> 46 Then
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(1)) Then
                        Matches(0, 1, 0) = Matches(0, 1, 0) + 1
                    Else
                        Matches(0, 0, 0) = Matches(0, 0, 0) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(0)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 1) = Matches(0, 1, 1) + 1
                    Else
                        Matches(0, 0, 1) = Matches(0, 0, 1) + 1
                    End If
                        
                    If SeqNum(x, ISeqs(1)) = SeqNum(x, ISeqs(2)) Then
                        Matches(0, 1, 2) = Matches(0, 1, 2) + 1
                    Else
                        Matches(0, 0, 2) = Matches(0, 0, 2) + 1
                    End If
            End If
        'End If
    Next x
End If

Tots1 = (Matches(1, 0, 0) + Matches(1, 1, 0))
Tots2 = (Matches(0, 0, 0) + Matches(0, 1, 0))



If Tots1 > Tots2 Then
    Tots1 = (Tots1 - Tots2)
    For x = 0 To 2
        Matches(0, 1, x) = Matches(0, 1, x) + Tots1
    Next x
ElseIf Tots2 > Tots1 Then
    Tots1 = (Tots2 - Tots1)
    For x = 0 To 2
        Matches(1, 1, x) = Matches(1, 1, x) + Tots1
    Next x
Else
    Tots1 = 0
End If

'work out greatest number of matches in seqnum
AScore(0) = 0: AScore(1) = 0: AScore(2) = 0

'AScore(0) = Matches(1, 1, 0) / (Matches(1, 1, 0) + Matches(1, 1, 1) + Matches(1, 1, 2)) - Matches(0, 1, 0) / (Matches(0, 1, 0) + Matches(0, 1, 1) + Matches(0, 1, 2))
For x = 0 To 2
    'AScore(X) = (Matches(1, 1, X) / (Matches(1, 1, 0) + Matches(1, 1, 1) + Matches(1, 1, 2))) - (Matches(0, 1, X) / (Matches(0, 1, 0) + Matches(0, 1, 1) + Matches(0, 1, 2)))
'        XX = ISeqs(0)
'        XX = ISeqs(1)
'        XX = ISeqs(2)
'        XX = Matches(1, 0, X)
'        XX = Matches(1, 1, X)
'        XX = Matches(0, 0, X)
'        XX = Matches(0, 1, X)
        AScore(x) = CalcChiP(Matches(1, 1, x), Matches(1, 0, x), Matches(0, 1, x), Matches(0, 0, x))
'        XX = XX
Next x
MAProb = (-Log10(AScore(0)) + -Log10(AScore(1)) + -Log10(AScore(2))) / 3
MAProb = 10 ^ -MAProb

'If SEventNumber = 39 Or SEventNumber = 40 Or SEventNumber = 48 Or SEventNumber = 41 Then
'    X = X
'End If
If DebuggingFlag < 2 Then On Error Resume Next
If (Matches(1, 1, 0) / (Matches(1, 1, 0) + Matches(1, 0, 0))) < 0.4 Or (Matches(1, 1, 1) / (Matches(1, 1, 1) + Matches(1, 0, 1))) < 0.4 Or (Matches(1, 1, 2) / (Matches(1, 1, 2) + Matches(1, 0, 2))) < 0.4 Then
    AAF = 2
Else


    If MAProb < 0.01 Or AScore(0) < 0.001 Or AScore(1) < 0.001 Or AScore(2) < 0.001 Then
        
        AAF = 1
    ElseIf MAProb < 0.1 Then
        AAF = 2
    Else
        AAF = 0
    End If
End If
On Error GoTo 0
'If SEventNumber = 1 And X = 12345 Then
'    Open "talign" + Trim(Str(SEventNumber)) + ".fas" For Output As #1
'
'    For X = 0 To 2
'        Print #1, ">" + OriginalName(ISeqs(X))
'        OS = ""
'        For Y = 1 To MaxLen * 2
'            If SeqsOut(Y, X) > 0 Then
'                OS = OS + Chr(SeqsOut(Y, X) - 1)
'            End If
'        Next Y
'        Print #1, OS
'    Next X
'    Close #1
'End If

'X = X

End Sub
Public Sub UpdatePlotsF(BPlots() As Single, BPos As Long, Epos As Long, MaxBP() As Double, SBFlag)

Dim SP As Long, EP As Long, x As Long, GoOn As Long, Z As Long
For x = 0 To 1
    GoOn = 0
    If x = 0 Then
        SP = BPos - 49
        EP = BPos + 50
        If SBFlag <> 1 And SBFlag <> 3 Then
            GoOn = 1
        End If
    Else
        SP = Epos - 49
        EP = Epos + 50
        If SBFlag <> 2 And SBFlag <> 3 Then
            GoOn = 1
        End If
    End If
    Dim BPosX As Long, EPosX As Long
    If UPArrayDimXFact <> 0 Then
        BPosX = CLng(SP * UPArrayDimXFact)
        EPosX = CLng(EP * UPArrayDimXFact)
        
    Else
        BPosX = SP
        EPosX = EP
    End If
    If GoOn = 1 Then
    'XX = MaxBP(0)
        If BPosX < 0 Then BPosX = BPosX + UPArrayDim1
        If EPosX > UPArrayDim1 Then EPosX = EPosX - UPArrayDim1
        Z = BPosX
        Do While Z <> EPosX
            BPlots(0, Z) = BPlots(0, Z) + 1
            If MaxBP(0) < BPlots(0, Z) Then
                MaxBP(0) = BPlots(0, Z) + 4
                RedoPltL(1) = 1
            End If
            Z = Z + 1
            If Z = UPArrayDim1 Then
                If EPosX = UPArrayDim1 Or EPosX = 0 Then Exit Do
                Z = 1
            End If
        Loop
    End If
Next x

If UPArrayDimXFact <> 0 Then
    BPosX = CLng(BPos * UPArrayDimXFact)
    EPosX = CLng(Epos * UPArrayDimXFact)
    If EPosX > UBound(BPlots, 2) Then
        EPosX = UBound(BPlots, 2)
    End If
    If BPosX > UBound(BPlots, 2) Then
        BPosX = UBound(BPlots, 2)
    End If
Else
    BPosX = BPos
    EPosX = Epos
End If
If BPosX <= EPosX Then
    For x = BPosX To EPosX
        BPlots(1, x) = BPlots(1, x) + 1
        If MaxBP(1) < BPlots(1, x) Then
            MaxBP(1) = BPlots(1, x) + 4
            RedoPltL(2) = 1
        End If
    Next x
ElseIf BPos > Epos Then
    For x = 1 To EPosX
        BPlots(1, x) = BPlots(1, x) + 1
        If MaxBP(1) < BPlots(1, x) Then
            MaxBP(1) = BPlots(1, x) + 4
            RedoPltL(2) = 1
        End If
    Next x
    For x = BPosX To UPArrayDim1
        BPlots(1, x) = BPlots(1, x) + 1
        If MaxBP(1) < BPlots(1, x) Then
            MaxBP(1) = BPlots(1, x) + 4
            RedoPltL(2) = 1
        End If
    Next x
End If

End Sub
Public Sub SetUpAxes(NextNo As Long, XoverList() As XOverDefine, CurrentXOver() As Integer, BPlots() As Single, MaxBP() As Double, oPMax As Single, oPMin As Single)

Dim x As Long, Y As Long, UValA As Single, LValA As Single, UValB As Single, LValB As Single, UValC As Long, LValC As Long, DDFlag As Byte, XLegendA As String, XLegendB As String, XLegendC As String

ReDim BPlots(1, UPArrayDim1 + 100)
        MaxBP(0) = 5
        MaxBP(1) = 5
        UValA = 3
        UValB = 5
        UValC = 5
        ReDim StartPlt(AddNum)
        If UBound(PDistPlt, 1) < UPArrayDim1 + 10 Then
            ReDim PDistPlt(UPArrayDim1 + 10, AddNum)
            ReDim ProbPlt(UPArrayDim1 + 10, AddNum)
            ReDim HitPlt(UPArrayDim1 + 10, AddNum)
            ReDim Hitnumber(Len(StrainSeq(0)) + 10)
        End If
        
        Dim PMi As Double, PMa As Double
        
        PMi = -Log10(LowestProb)
        oPMin = CSng(PMi)
        PMa = 10
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If PMa > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    PMa = XoverList(x, Y).Probability
                End If
            Next Y
        Next x
        PMa = CLng(-Log10(PMa) + 1)
        oPMax = CSng(PMa)
        Call DoAxes2(oPMax, 0, UValB, 0, UValC, 0, 0, "P-Val", "BP Num", "# Hits")
End Sub


Public Sub MakeProperRCorr(INList() As Byte, MissingData() As Byte, RCorrWarn() As Byte, RInv() As Single, tRCorr() As Single, RCorr() As Single, CompMat() As Long, SLen As Long, ISeqs() As Long, SP() As Long, EP() As Long, SeqNum() As Integer)
Dim WinX As Single, Z As Long, Dummy As Long, n As Byte, V(2) As Double, SDM() As Double, DistMat() As Double, IntVal(1) As Double, RMat() As Double, TmF As Double, T As Double, D(5) As Double, S(1) As Long, DZ As Long, x As Long, Y As Long, A As Long, b As Long
ReDim DistMat(2, 4, NextNo, 2)
TmF = 10 ^ -14
ReDim tRCorr(2, 2, 4, NextNo), SDM(2, 2, NextNo)
'@'@'@'@'$
'Dummy = MakeSDMP(NextNo, SLen, SP(0), EP(0), ISeqs(0), CompMat(0, 0), MissingData(0, 0), SeqNum(0, 0), SDM(0, 0, 0), DistMat(0, 0, 0, 0))
'&
Dummy = MakeSDMP2(NextNo, SLen, SP(0), EP(0), ISeqs(0), CompMat(0, 0), MissingData(0, 0), SeqNum(0, 0), SDM(0, 0, 0), DistMat(0, 0, 0, 0))
    



Dim ZP(1) As Byte



For Y = 0 To 2
    ReDim RMat(2, 5, NextNo)
    'S(0) = ISeqs(CompMat(Y, 0))
    'S(1) = ISeqs(CompMat(Y, 1))
'    If X = X Then
        Dummy = FillRmat(Y, NextNo, 2, 5, 2, 4, NextNo, RMat(0, 0, 0), DistMat(0, 0, 0, 0), ZP(0))
'    Else
'        For X = 0 To 1
'            If X = 0 Then
'
'                ZP(0) = 0: ZP(1) = 1
'            Else
'
'                ZP(0) = 3: ZP(1) = 2
'            End If
'
'            For Z = 0 To Nextno
'
'                RMat(X, 0, Z) = DistMat(Y, ZP(0), Z, 0)
'                RMat(X, 1, Z) = DistMat(Y, ZP(0), Z, 1)
'                RMat(X, 2, Z) = DistMat(Y, ZP(0), Z, 2)
'                RMat(X, 3, Z) = DistMat(Y, ZP(1), Z, 0)
'                RMat(X, 4, Z) = DistMat(Y, ZP(1), Z, 1)
'                RMat(X, 5, Z) = DistMat(Y, ZP(1), Z, 2)
'
'
'                RMat(2, 0, Z) = RMat(2, 0, Z) + DistMat(Y, ZP(0), Z, 0) / 2
'                RMat(2, 1, Z) = RMat(2, 1, Z) + DistMat(Y, ZP(0), Z, 1) / 2
'                RMat(2, 2, Z) = RMat(2, 2, Z) + DistMat(Y, ZP(0), Z, 2) / 2
'
'                RMat(2, 3, Z) = RMat(2, 3, Z) + DistMat(Y, 4, Z, 0) / 2
'                RMat(2, 4, Z) = RMat(2, 4, Z) + DistMat(Y, 4, Z, 1) / 2
'                RMat(2, 5, Z) = RMat(2, 5, Z) + DistMat(Y, 4, Z, 2) / 2
'
'
'            Next Z
'        Next X
'    End If
    
     
     'do calcr specifically for this y (rmat gets reused for all 3 seqs)
     'with data going into rcorr
     IntVal(0) = 0: IntVal(1) = 0
     '@'@'@
     Dummy = CalCR(TmF, NextNo, Y, ISeqs(0), CompMat(0, 0), RCorr(0, 0, 0), RInv(0, 0, 0), IntVal(0), RMat(0, 0, 0), tRCorr(0, 0, 0, 0))
     
     
Next Y







If x = x Then
    For x = 0 To 2
        For Y = 0 To NextNo
            n = 0
            For Z = 0 To 1
                If RCorr(x, Z, Y) > 0.83 And RInv(x, Z, Y) = 0 Then
                    n = n + 1
                End If
            Next Z
            
            If n = 1 Or (n = 0 And RCorr(x, 2, Y) > 0.83 And RInv(x, 2, Y) = 0) Then
                For Z = 0 To 2
                    If RCorr(x, Z, Y) > 0.83 And RCorr(x, Z, Y) < 0.99 And RInv(x, Z, Y) = 0 Then
                        'If INList(0) = X Or (INList(0) = INList(1) And INList(0) = INList(2)) Then
                            If SDM(x, Z, Y) > SDM(CompMat(x, 0), Z, Y) Or SDM(x, Z, Y) > SDM(CompMat(x, 1), Z, Y) Then
                                RCorr(x, Z, Y) = 0: RInv(x, Z, Y) = 0 ': RCorr(X, 2, Y) = 0: RInv(X, 2, Y) = 0
                            End If
                        x = x
                        'End If
                    End If
                Next Z
            
            End If
        Next Y
    Next x
End If

RCorrWarn(0) = 0: RCorrWarn(1) = 0
For Z = 0 To 2
'Check if a warning is necessary
    
    If RCorrWarn(0) = 0 Then
        D(0) = CLng(DistMat(Z, 0, ISeqs(Z), 0) * 100000) / 100000 '0.0344
        D(1) = CLng(DistMat(Z, 0, ISeqs(Z), 1) * 100000) / 100000 '0.1724
        D(2) = CLng(DistMat(Z, 0, ISeqs(Z), 2) * 100000) / 100000 '0.7931
        
        D(3) = CLng(DistMat(Z, 1, ISeqs(Z), 0) * 100000) / 100000 '0.3448
        D(4) = CLng(DistMat(Z, 1, ISeqs(Z), 1) * 100000) / 100000 '0.4138
        D(5) = CLng(DistMat(Z, 1, ISeqs(Z), 2) * 100000) / 100000 '0.2413
        
        If D(0) > D(1) And D(0) > D(2) Then
            If D(3) > D(4) And D(3) > D(5) Then
                RCorrWarn(0) = 1
            End If
        ElseIf D(1) > D(0) And D(1) > D(2) Then
            If D(4) > D(3) And D(4) > D(5) Then
                RCorrWarn(0) = 1
            End If
        ElseIf D(2) > D(0) And D(2) > D(1) Then
            If D(5) > D(3) And D(5) > D(4) Then
                RCorrWarn(0) = 1
            End If
        End If
    End If
    If RCorrWarn(1) = 0 Then
        D(0) = CLng(DistMat(Z, 2, ISeqs(Z), 0) * 100000) / 100000 '0.0344
        D(1) = CLng(DistMat(Z, 2, ISeqs(Z), 1) * 100000) / 100000 '0.1724
        D(2) = CLng(DistMat(Z, 2, ISeqs(Z), 2) * 100000) / 100000 '0.7931
        
        D(3) = CLng(DistMat(Z, 3, ISeqs(Z), 0) * 100000) / 100000 '0.3448
        D(4) = CLng(DistMat(Z, 3, ISeqs(Z), 1) * 100000) / 100000 '0.4138
        D(5) = CLng(DistMat(Z, 3, ISeqs(Z), 2) * 100000) / 100000 '0.2413
        
        If D(0) > D(1) And D(0) > D(2) Then
            If D(3) > D(4) And D(3) > D(5) Then
                RCorrWarn(1) = 1
            End If
        ElseIf D(1) > D(0) And D(1) > D(2) Then
            If D(4) > D(3) And D(4) > D(5) Then
                RCorrWarn(1) = 1
            End If
        ElseIf D(2) > D(0) And D(2) > D(1) Then
            If D(5) > D(3) And D(5) > D(4) Then
                RCorrWarn(1) = 1
            End If
        End If
    End If
Next Z
If RCorrWarn(1) = 1 Or RCorrWarn(0) = 1 Then RCorrWarn(2) = 1
    
If x = x Then
    '&
    For x = 0 To 2
        For Y = 0 To 2
            For Z = 0 To 4
                    For A = 0 To NextNo
                        tRCorr(x, Y, Z, A) = CLng(tRCorr(x, Y, Z, A) * 1000000) / 1000000
                    Next A
            Next Z
            
        Next Y
        
    Next x
End If

If x = x Then
    For x = 0 To 2
        For Y = 0 To 2
            
            For A = 0 To NextNo
                If RInv(x, Y, A) > 0 Then
                    WinX = -1
'                    If X = 0 And Y = 1 And A = 17 Then
'                        XX = RInv(0, 1, 17)
'                    End If
                    For Z = 0 To 4
                            
                            If tRCorr(x, Y, Z, A) > WinX Then
                                RInv(x, Y, A) = Z
                                WinX = tRCorr(x, Y, Z, A)
                                x = x
                            End If
                    Next Z
                    x = x
                End If
            Next A
            
        Next Y
    Next x
End If

For x = 0 To 2
    For Y = 0 To 2
        
        For A = 0 To NextNo
            If RInv(x, Y, A) = 3 Then
                RInv(x, Y, A) = 2
            End If
        Next A
        
    Next Y
Next x

'If SEventNumber = 18 Then
'    XX = CurDir
'    Open "rcorr.csv" For Output As #1
'    Dim OS As String
'    'For K = PermNextno To 0 Step -1
'    For K = 0 To PermNextno
'        OS = Str(RCorr(0, 0, K)) + "," + Str(RCorr(0, 1, K)) + "," + Str(RCorr(0, 2, K)) + ",," + Str(RCorr(1, 0, K)) + "," + Str(RCorr(1, 1, K)) + "," + Str(RCorr(1, 2, K)) + ",," + Str(RCorr(2, 0, K)) + "," + Str(RCorr(2, 1, K)) + "," + Str(RCorr(2, 2, K)) + ","
'        Print #1, OS
'
'    Next K
'    'For K = PermNextno To 0 Step -1
'    For K = 0 To PermNextno
'    OS = Str(RInv(0, 0, K)) + "," + Str(RInv(0, 1, K)) + "," + Str(RInv(0, 2, K)) + ",," + Str(RInv(1, 0, K)) + "," + Str(RInv(1, 1, K)) + "," + Str(RInv(1, 2, K)) + ",," + Str(RInv(2, 0, K)) + "," + Str(RInv(2, 1, K)) + "," + Str(RInv(2, 2, K)) + ","
'    Print #1, OS
'    Next K
'    Close #1
'    XX = ISeqs(0)
'    XX = ISeqs(1)
'    XX = ISeqs(2)
'
'    X = X
'
'End If
x = x


End Sub




Public Sub MakeINList(INList() As Byte, OUList() As Byte, MinPair() As Byte)
'    If SEventNumber = 81 Then
'        X = X
'    End If
    ReDim INList(2), OUList(2)
    
    If MinPair(0) = 0 And MinPair(1) = 1 Then
        INList(0) = 1: INList(1) = 0: INList(2) = 2
        OUList(1) = 0: OUList(0) = 1: OUList(2) = 2
    ElseIf MinPair(0) = 0 And MinPair(1) = 2 Then
        INList(0) = 0: INList(1) = 1: INList(2) = 2
        OUList(0) = 0: OUList(1) = 1: OUList(2) = 2
    ElseIf MinPair(0) = 1 And MinPair(1) = 0 Then
        INList(0) = 2: INList(1) = 0: INList(2) = 1
        OUList(2) = 0: OUList(0) = 1: OUList(1) = 2
    ElseIf MinPair(0) = 1 And MinPair(1) = 2 Then
        INList(0) = 0: INList(1) = 2: INList(2) = 1
        OUList(0) = 0: OUList(2) = 1: OUList(1) = 2
    ElseIf MinPair(0) = 2 And MinPair(1) = 0 Then
        INList(0) = 2: INList(1) = 1: INList(2) = 0
        OUList(2) = 0: OUList(1) = 1: OUList(0) = 2
    ElseIf MinPair(0) = 2 And MinPair(1) = 1 Then
        INList(0) = 1: INList(1) = 2: INList(2) = 0
        OUList(1) = 0: OUList(2) = 1: OUList(0) = 2
    End If
End Sub
Public Sub GetBadDists(NextNo As Long, RCorr() As Single, FAMatSmall() As Single, CompMat() As Long, DMatS() As Single, ISeqs() As Long, BadDists() As Single, UNF() As Byte, RList() As Long, RNum() As Long)
    Dim b As Long, A As Byte, BD() As Byte, BFlag As Byte
    
    ReDim BadDists(2)
    
    If IndividualA = -1 Then
        
        For A = 0 To 2
            ReDim BD(NextNo)
            
            For b = 0 To RNum(A)
                BFlag = 0
                
                If UNF(A, RList(A, b)) = 0 Then
                    If RCorr(A, 0, RList(A, b)) > 0.83 Then '0.91
                        If DMatS(0, A, RList(A, b)) > DMatS(0, A, ISeqs(CompMat(A, 1))) Or DMatS(1, A, RList(A, b)) >= DMatS(1, A, ISeqs(CompMat(A, 1))) Or DMatS(0, A, RList(A, b)) > DMatS(0, A, ISeqs(CompMat(A, 0))) Or DMatS(1, A, RList(A, b)) >= DMatS(1, A, ISeqs(CompMat(A, 0))) Then
                            BFlag = 1 '0.0316 vs 0.00998, 0.0262 vs 0.1556,0.0316 vs 0.2212, 0.0262 vs 0.1556
                        End If
                    End If
                    If RCorr(A, 1, RList(A, b)) > 0.83 Then
                        If DMatS(2, A, RList(A, b)) >= DMatS(2, A, ISeqs(CompMat(A, 1))) Or DMatS(3, A, RList(A, b)) > DMatS(3, A, ISeqs(CompMat(A, 1))) Or DMatS(2, A, RList(A, b)) >= DMatS(2, A, ISeqs(CompMat(A, 0))) Or DMatS(3, A, RList(A, b)) > DMatS(3, A, ISeqs(CompMat(A, 0))) Then
                            BFlag = 1 '0.034 vs 0.2317,0.0311 vs 0.0102,0.034 vs 0.2317,0.0311 vs 0.2326
                            
                        End If
                    End If
                    If BFlag = 1 Then
'                        If RList(A, b) > PermNextno Then
'                            x = x
'                        End If
                    'XX = FMat(ISeqs(A), Rlist(A, B))
                        If CLng(FAMatSmall(A, RList(A, b)) * 1000) < NextNo Then
                            BD(CLng(FAMatSmall(A, RList(A, b)) * 1000)) = 1
                        Else
                            BD(NextNo) = 1
                        End If
                    End If
                Else
                    x = x
                End If
            Next b
            For b = 0 To NextNo
                BadDists(A) = BadDists(A) + BD(b)
            Next b
        Next A
    End If
    x = x
End Sub





Public Sub QTestAlign(WinPP As Long, LDst() As Double, ISeqs() As Long, PermDiffsSmall() As Single, PermValidSmall() As Single, SubDiffs() As Single, SubValid() As Single)
        Dim x As Long, IDist(1, 2) As Double, UBSV As Long
        
        LDst(0) = 0
        LDst(1) = 0
        If UBound(SubValid, 1) < NextNo Or UBound(SubValid, 2) < NextNo Then
            ReDim SubValid(NextNo, NextNo)
        End If
        If UBound(SubDiffs, 1) < NextNo Or UBound(SubDiffs, 2) < NextNo Then
            ReDim SubDiffs(NextNo, NextNo)
        End If
        If UBound(PermValidSmall, 1) < NextNo Or UBound(PermValidSmall, 2) < NextNo Then
            ReDim PermValidSmall(NextNo, NextNo)
        End If
        If UBound(PermDiffsSmall, 1) < NextNo Or UBound(PermDiffsSmall, 2) < NextNo Then
            ReDim PermDiffsSmall(NextNo, NextNo)
        End If
        
        If SubValid(0, ISeqs(1)) > 0 And SubValid(0, ISeqs(2)) > 0 Then
            IDist(1, 0) = (SubDiffs(0, ISeqs(1)) / SubValid(0, ISeqs(1)) + SubDiffs(0, ISeqs(2)) / SubValid(0, ISeqs(2))) / 2
        Else
            IDist(1, 0) = 1#
        End If
        If PermValidSmall(0, ISeqs(1)) > 0 And PermValidSmall(0, ISeqs(2)) > 0 Then
            IDist(0, 0) = (PermDiffsSmall(0, ISeqs(1)) / PermValidSmall(0, ISeqs(1)) + PermDiffsSmall(0, ISeqs(2)) / PermValidSmall(0, ISeqs(2))) / 2
        Else
            IDist(0, 0) = 1#
        End If
        If SubValid(0, ISeqs(1)) > 0 And SubValid(1, ISeqs(2)) > 0 Then
            IDist(1, 1) = (SubDiffs(1, ISeqs(0)) / SubValid(1, ISeqs(0)) + SubDiffs(1, ISeqs(2)) / SubValid(1, ISeqs(2))) / 2
        Else
            IDist(1, 1) = 1#
        End If
        If PermValidSmall(0, ISeqs(1)) > 0 And PermValidSmall(1, ISeqs(2)) > 0 Then
            IDist(0, 1) = (PermDiffsSmall(1, ISeqs(0)) / PermValidSmall(1, ISeqs(0)) + PermDiffsSmall(1, ISeqs(2)) / PermValidSmall(1, ISeqs(2))) / 2
        Else
            IDist(0, 1) = 1#
        End If
        If SubValid(0, ISeqs(2)) > 0 And SubValid(1, ISeqs(2)) > 0 Then
            IDist(1, 2) = (SubDiffs(2, ISeqs(0)) / SubValid(2, ISeqs(0)) + SubDiffs(2, ISeqs(1)) / SubValid(2, ISeqs(1))) / 2
        Else
            IDist(1, 2) = 1#
        End If
        If PermValidSmall(0, ISeqs(2)) > 0 And PermValidSmall(1, ISeqs(2)) > 0 Then
            'XX = PermValid(ISeqs(0), ISeqs(2))
            IDist(0, 2) = (PermDiffsSmall(2, ISeqs(0)) / PermValidSmall(2, ISeqs(0)) + PermDiffsSmall(2, ISeqs(1)) / PermValidSmall(2, ISeqs(1))) / 2
        Else
            IDist(0, 2) = 1#
        End If
        
        
        
        For x = 0 To 2
            
            If IDist(1, x) >= LDst(1) Then
                LDst(1) = IDist(1, x)
                'WinPP = X
            End If
            If IDist(0, x) >= LDst(0) Then
                LDst(0) = IDist(0, x)
                
            End If
        Next x
    x = x

End Sub

Public Sub CheckPattern(OKSeq() As Double, ISeqs() As Long, RList() As Long, SP() As Long, EP() As Long, CompMat() As Long, RNum() As Long, SeqNum() As Integer, RInv() As Single, InvList() As Long, RCorrWarn() As Byte)
'Exit Sub
Dim TNu2 As Long, Dummy As Long, x As Long, Y As Long, Z As Long, ST() As Long, EN() As Long, Pattern() As Double, DonePattern() As Byte
ReDim ST(3)
ReDim EN(3)
ReDim Pattern(2, 2, NextNo)
ReDim DonePattern(2, NextNo)
ST(0) = SP(0): EN(0) = EP(1)
ST(1) = SP(2): EN(1) = EP(3)
ST(2) = SP(4): EN(2) = EP(4)
'$
'If X = X Then
    Dummy = CheckPatternX(NextNo, Len(StrainSeq(0)), ISeqs(0), ST(0), EN(0), SeqNum(0, 0), Pattern(0, 0, 0), DonePattern(0, 0))
    x = x
'Else
'    For G = 0 To 2
'        For H = 0 To Nextno 'RNum(G)
'            X = H 'RList(G, H)
'            If X <> ISeqs(G) Then
'                For Z = 0 To 2
'                    'If RCorr(0, Z, X) > 0.83 Or RCorr(1, Z, X) > 0.83 Or RCorr(2, Z, X) > 0.83 Then
'                        If DonePattern(Z, X) = 0 Then
'                            DonePattern(Z, X) = 1
'                            'If RInv(X, Z, x) = 0 Then
'                                If ST(Z) < EN(Z) Then
'                                    For A = ST(Z) To EN(Z)
'                                        If SeqNum(A, X) <> 46 Then
'                                            If SeqNum(A, ISeqs(1)) <> 46 Then
'                                                If SeqNum(A, ISeqs(2)) <> 46 Then
'                                                    If SeqNum(A, ISeqs(0)) <> 46 Then
'                                                        If SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(1)) Or SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(2)) Then
'                                                            If SeqNum(A, X) = SeqNum(A, ISeqs(0)) Then
'                                                                If SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                    If SeqNum(A, ISeqs(2)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            Else
'                                                                If SeqNum(A, X) = SeqNum(A, ISeqs(1)) Then
'
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 0.5
'                                                                    End If
'                                                                ElseIf SeqNum(A, X) = SeqNum(A, ISeqs(2)) Then
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            End If
'                                                        End If
'                                                    End If
'                                                End If
'                                            End If
'                                        End If
'                                    Next A
'                                Else
'                                    For A = 1 To EN(Z)
'                                        If SeqNum(A, X) <> 46 Then
'                                            If SeqNum(A, ISeqs(1)) <> 46 Then
'                                                If SeqNum(A, ISeqs(2)) <> 46 Then
'                                                    If SeqNum(A, ISeqs(0)) <> 46 Then
'                                                        If SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(1)) Or SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(2)) Then
'                                                            If SeqNum(A, X) = SeqNum(A, ISeqs(0)) Then
'                                                                If SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                    If SeqNum(A, ISeqs(2)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            Else
'                                                                If SeqNum(A, X) = SeqNum(A, ISeqs(1)) Then
'
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 0.5
'                                                                    End If
'                                                                ElseIf SeqNum(A, X) = SeqNum(A, ISeqs(2)) Then
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            End If
'                                                        End If
'                                                    End If
'                                                End If
'                                            End If
'                                        End If
'                                    Next A
'                                    For A = ST(Z) To Len(StrainSeq(0))
'                                        If SeqNum(A, X) <> 46 Then
'                                            If SeqNum(A, ISeqs(1)) <> 46 Then
'                                                If SeqNum(A, ISeqs(2)) <> 46 Then
'                                                    If SeqNum(A, ISeqs(0)) <> 46 Then
'                                                        If SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(1)) Or SeqNum(A, ISeqs(0)) <> SeqNum(A, ISeqs(2)) Then
'                                                            If SeqNum(A, X) = SeqNum(A, ISeqs(0)) Then
'                                                                If SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                    If SeqNum(A, ISeqs(2)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(0, Z, X) = Pattern(0, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            Else
'                                                                If SeqNum(A, X) = SeqNum(A, ISeqs(1)) Then
'
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(2)) Then
'                                                                        Pattern(1, Z, X) = Pattern(1, Z, X) + 0.5
'                                                                    End If
'                                                                ElseIf SeqNum(A, X) = SeqNum(A, ISeqs(2)) Then
'                                                                    If SeqNum(A, ISeqs(0)) = SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 1
'                                                                    ElseIf SeqNum(A, X) <> SeqNum(A, ISeqs(1)) Then
'                                                                        Pattern(2, Z, X) = Pattern(2, Z, X) + 0.5
'                                                                    End If
'                                                                End If
'                                                            End If
'                                                        End If
'                                                    End If
'                                                End If
'                                            End If
'                                        End If
'                                    Next A
'                                End If
'                            'End If
'
'
'                        End If
'                    'End If
'                Next Z
'            End If
'        Next H
'    Next G
'End If



'XX = Pattern(2, 1, 19)

'Analyse patterns
Dim GoOn As Long, TNu As Integer, TPr As Double, ND As Long, XL As Long, EnterF As Byte, PatScore As Double
'@
For x = 0 To 2
     
    Y = 0
    Do While Y <= RNum(x)
        
        If RList(x, Y) <> ISeqs(x) Then
            
            GoOn = 0
            EnterF = 0
            PatScore = 0
            For Z = 0 To 2
                If RInv(x, Z, RList(x, Y)) = 0 And RCorrWarn(Z) = 0 Then
                    EnterF = 1
                    
                    If Pattern(x, Z, RList(x, Y)) >= Pattern(CompMat(x, 0), Z, RList(x, Y)) And Pattern(x, Z, RList(x, Y)) >= Pattern(CompMat(x, 1), Z, RList(x, Y)) Then
                        GoOn = 1
                        
                        Exit For
                    Else
                        If (Pattern(x, Z, RList(x, Y)) >= Pattern(CompMat(x, 0), Z, RList(x, Y)) Or Pattern(x, Z, RList(x, Y)) >= Pattern(CompMat(x, 1), Z, RList(x, Y))) Then
                            ND = Pattern(x, Z, RList(x, Y)) * 2
                            
                            If Pattern(x, Z, RList(x, Y)) < Pattern(CompMat(x, 0), Z, RList(x, Y)) Then
                                
                                TNu = ND + (Pattern(CompMat(x, 0), Z, RList(x, Y))) * 2
                            Else
                                TNu = ND + (Pattern(CompMat(x, 1), Z, RList(x, Y))) * 2
                            End If
                            If TNu > 170 Then
                                ND = CLng(ND * 170 / TNu)
                                TNu = 170
                            End If
                            XL = TNu
                            TNu2 = TNu
                            'ProbCalc(XOverLength, XOverLength - NumDifferent, IndProb, LenXOverSeq)
                            'TPr = ProbCalc(TNu, TNu - ND, 0.5, TNu)
                            TPr = ProbCalc(Fact(0), TNu2, ND, 0.5, XL) '(TNu, TNu - ND, 0.5, TNu)
                            
                            If (TPr > 0.01 And TPr < 0.99) Or TNu < 6 Then
                                GoOn = 1
                                
                           
                            End If
                        End If
                    End If
                End If
            Next Z
            If GoOn = 0 And EnterF = 1 Then
                ' OKSeq(X, 3, RList(X, Y)) = 0
              '  If Y < RNum(X) Then
              '      RList(X, Y) = RList(X, RNum(X))
              '      InvList(X, Y) = InvList(X, RNum(X))
              '  End If
              '  RNum(X) = RNum(X) - 1
               Y = Y + 1
            Else
                ' OKSeq(X, 3, RList(X, Y)) = PatScore
                Y = Y + 1
            End If
        Else
            'OKSeq(X, 3, RList(X, Y)) = Len(StrainSeq(0))
            Y = Y + 1
        End If
    Loop
Next x

For x = 0 To 2
    For Y = 0 To NextNo
        If Y <> ISeqs(x) Then
            For Z = 0 To 2
                If (Pattern(x, Z, Y) + Pattern(CompMat(x, 0), Z, Y) + Pattern(CompMat(x, 1), Z, Y)) > 0 Then
                    OKSeq(x, 3, Y) = OKSeq(x, 3, Y) + Pattern(x, Z, Y) / (Pattern(x, Z, Y) + Pattern(CompMat(x, 0), Z, Y) + Pattern(CompMat(x, 1), Z, Y))
                End If
            Next Z
        Else
            OKSeq(x, 3, Y) = 3
        End If
    Next Y
Next x



x = x
End Sub


Public Sub MakeMatchMat(SMatSmall() As Single, SeqNum() As Integer, BMatch() As Single, BPMatch() As Long, MatchMat() As Single, ISeqs() As Long)

Dim Y As Long, Z As Long, AA As Long, Dummy As Long, UB As Long, x As Long, Valid As Single, Diff As Single, th1 As Double, th2 As Double, th3 As Double
Dim ContainSite() As Byte

'Dim MatchMat2() As Single
'ReDim MatchMat2(UBound(MatchMat, 1), UBound(MatchMat, 2), UBound(MatchMat, 3))

For x = 0 To 2
    If DebuggingFlag < 3 Then On Error Resume Next
    UB = -1
    '@'@'$
    ReDim ContainSite(Len(StrainSeq(0)), NextNo)
    UB = UBound(ContainSite, 2)
    On Error GoTo 0
    '@
    If UB = NextNo Then
'        If X = X Then
'        ReDim MatchMat2(UBound(MatchMat, 1), UBound(MatchMat, 2), UBound(MatchMat, 3))
'
'        For A = 0 To UBound(MatchMat, 1)
'            For Y = 0 To UBound(MatchMat, 2)
'                For Z = 0 To UBound(MatchMat, 3)
'                    MatchMat2(A, Y, Z) = MatchMat(A, Y, Z)
'                Next Z
'            Next Y
'
'        Next A
            'Dummy = MakeMatchMatX(Len(StrainSeq(0)), NextNo, x, ContainSite(0, 0), SMat(0, 0), MatchMat(0, 0, 0), BMatch(0, 0), BPMatch(0, 0, 0), SeqNum(0, 0), ISeqs(0))
           ' Dummy = MakeMatchMatX2(Len(StrainSeq(0)), NextNo, x, ContainSite(0, 0), SMatSmall(0, 0), MatchMat(0, 0, 0), BMatch(0, 0), BPMatch(0, 0, 0), SeqNum(0, 0), ISeqs(0))
            'SS = GetTickCount
            'For A = 1 To 10000
            '&
            Dummy = MakeMatchMatX2P(Len(StrainSeq(0)), NextNo, x, ContainSite(0, 0), SMatSmall(0, 0), MatchMat(0, 0, 0), BMatch(0, 0), BPMatch(0, 0, 0), SeqNum(0, 0), ISeqs(0))
            x = x
            'Dummy = MakeMatchMatX2P2(Len(StrainSeq(0)), NextNo, x, ContainSite(0, 0), SMatSmall(0, 0), MatchMat(0, 0, 0), BMatch(0, 0), BPMatch(0, 0, 0), SeqNum(0, 0), ISeqs(0))
            'Next A
            'EE = GetTickCount
            'TT = EE - SS
            'x = x
'            For A = 0 To UBound(MatchMat, 1)
'                For Y = 0 To UBound(MatchMat, 2)
'                    For Z = 0 To UBound(MatchMat, 3)
'                        If CLng(MatchMat2(A, Y, Z) * 100000) <> CLng(MatchMat(A, Y, Z) * 100000) Then
'                            x = x
''                        ElseIf CLng(MatchMat2(A, Y, Z) * 100000) = CLng(MatchMat(A, Y, Z) * 100000) Then
''                            x = x
'                        End If
''
'                    Next Z
'                Next Y
'
'            Next A
'            x = x
'            ReDim ContainSite(Len(StrainSeq(0)), NextNo)
'
'x = x
''        Else
'            For Y = 0 To NextNo
'                If BMatch(x, Y) > 0 Then
'                    If BPMatch(x, 0, Y) < BPMatch(x, 1, Y) Then
'                        For Z = BPMatch(x, 0, Y) To BPMatch(x, 1, Y)
'                            ContainSite(Z, Y) = 1
'                        Next Z
'                    Else
'                        For Z = BPMatch(x, 0, Y) To Len(StrainSeq(0))
'                            ContainSite(Z, Y) = 1
'                        Next Z
'                        For Z = 1 To BPMatch(x, 1, Y)
'                            ContainSite(Z, Y) = 1
'                        Next Z
'                    End If
'                End If
'            Next Y
'            For AA = 0 To 2
'                Y = ISeqs(AA)
'                If BMatch(x, Y) > 0 Then
'                    For Z = 0 To NextNo
'                        Diffs = 0: Valid = 0
'                        If BMatch(x, Z) > 0 Then
'
'                            If BPMatch(x, 0, Y) < BPMatch(x, 1, Y) Then
'                                For A = BPMatch(x, 0, Y) To BPMatch(x, 1, Y)
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If ContainSite(A, Z) = 1 Then
'                                                If ContainSite(A, Y) = 1 Then
'                                                    If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                        Diffs = Diffs + 1
'                                                    End If
'                                                    Valid = Valid + 1
'                                                End If
'                                            End If
'                                        End If
'                                    End If
'                                Next A
'
'                            Else
'                                For A = BPMatch(x, 0, Y) To Len(StrainSeq(0))
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If ContainSite(A, Z) = 1 Then
'                                                If ContainSite(A, Y) = 1 Then
'                                                    If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                        Diffs = Diffs + 1
'                                                    End If
'                                                    Valid = Valid + 1
'                                                End If
'                                            End If
'                                        End If
'                                    End If
'                                Next A
'                                For A = 1 To BPMatch(x, 1, Y)
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If ContainSite(A, Z) = 1 Then
'                                                If ContainSite(A, Y) = 1 Then
'                                                    If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                        Diffs = Diffs + 1
'                                                    End If
'                                                    Valid = Valid + 1
'                                                End If
'                                            End If
'                                        End If
'                                    End If
'                                Next A
'                                x = x
'                            End If
'
'                        Else
'                            If BPMatch(x, 0, Y) < BPMatch(x, 1, Y) Then
'                                For A = BPMatch(x, 0, Y) To BPMatch(x, 1, Y)
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                Diffs = Diffs + 1
'                                            End If
'                                            Valid = Valid + 1
'                                        End If
'                                    End If
'                                Next A
'
'                            Else
'                                For A = BPMatch(x, 0, Y) To Len(StrainSeq(0))
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                Diffs = Diffs + 1
'                                            End If
'                                            Valid = Valid + 1
'                                        End If
'                                    End If
'                                Next A
'                                For A = 1 To BPMatch(x, 1, Y)
'                                    If SeqNum(A, Z) <> 46 Then
'                                        If SeqNum(A, Y) <> 46 Then
'                                            If SeqNum(A, Y) <> SeqNum(A, Z) Then
'                                                Diffs = Diffs + 1
'                                            End If
'                                            Valid = Valid + 1
'                                        End If
'                                    End If
'                                Next A
'                            End If
'                        End If
'                        If Valid <= 30 Then
'                            MatchMat(x, AA, Z) = 3
'                        ElseIf Diffs / Valid >= 0.75 Then
'                            MatchMat(x, AA, Z) = 3
'                        Else
'                            th1 = 1 - (Diffs / Valid)
'                            th2 = (4# * th1 - 1#) / 3#
'                            th3 = Log(th2)
'                            MatchMat(x, AA, Z) = -0.75 * th3
'                            x = x
'                        End If
'                        'MatchMat(X, Z, Y) = MatchMat(X, Y, Z)
'                    Next Z
'                Else
'                    For Z = 0 To NextNo
'                        If BMatch(x, Z) = 0 Then
'                            MatchMat(x, AA, Z) = SMat(Y, Z)
'                            'MatchMat(X, Z, Y) = MatchMat(X, Y, Z)
'                        End If
'                    Next Z
'                End If
'            Next AA
        'End If
        

x = x
    Else
        For AA = 0 To 2
            Y = ISeqs(AA)
            For Z = 0 To NextNo
                If BMatch(x, Z) = 0 Then
                    MatchMat(x, AA, Z) = SMatSmall(AA, Z)
                    
                End If
            Next Z
        Next AA
    
    End If
Next x

x = x
End Sub

Public Sub AddOK1(PermNextno As Long, DontRedo() As Byte, RCorr() As Single, RList() As Long, RNum() As Long, OKSeq() As Double, TPVal() As Double, RInv() As Single)

Dim x As Long, Y As Long, Z As Long
For x = 0 To 2
    For Y = 0 To NextNo
    
        If DontRedo(x, Y) = 0 Then
            For Z = 0 To 2
                If TPVal(x, Y, Z) > 0 Then
                    
                    If TPVal(x, Y, Z) * PermNextno < OKSeq(x, 0, Y) Or OKSeq(x, 0, Y) = 0 Then
                       OKSeq(x, 0, Y) = TPVal(x, Y, Z) * PermNextno '0,7 0,8 0,8 0,9 0,11 0,13 0,14
                       
                    End If
                   
                End If
            Next Z
        Else
            OKSeq(x, 0, Y) = 0.049
        End If
    Next Y
Next x
End Sub



Public Sub GetSupers()
'This routine groups events according to their similarities with other detected events.
' It scores 4 measures of similarity
'(i) similarity between daughters in recombinant region = score(0)
'(ii) genetic distance of daughters = score(1)
'(iii) genetic distance of parents = score(2)
'(iv) degree of overlap = score(3)

Dim C As Long, D As Long, MaxDist As Double, ENX(1) As Long, FLHit(3), Replace As Long, CEN As Long, TRE(1) As Long, SE As Long, WinScore(2) As Byte, LowDist(1) As Double, Hit() As Double, Valid() As Double, OtherDist(2, 2, 2) As Byte, LowPDist(1) As Double, Score(3) As Double, SizeE(2) As Long, TempFrag() As Byte, ISeqs(1, 2) As Long, Span(1, 1) As Long
Dim PValE(1) As Double, BiggestE As Long, BiggestC As Long, BackTrace() As Long, EventDist() As Double
'Find total eventnumber yes I know it "should" = eventnumber
BiggestE = 0
BiggestC = 0
For x = 0 To NextNo
    BiggestE = BiggestE + CurrentXOver(x)
    If BiggestC < CurrentXOver(x) Then BiggestC = CurrentXOver(x)
Next x

'I may have to adjust how I do this for very big matrices

ReDim EventTrace(1, BiggestE)
ReDim EventDist(BiggestE, BiggestE)
ReDim BackTrace(NextNo, BiggestC)

BiggestE = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        BiggestE = BiggestE + 1
        BackTrace(x, Y) = BiggestE
        EventTrace(0, BiggestE) = x
        EventTrace(1, BiggestE) = Y
    Next Y
Next x

'score(0) = P-val similarity
'score(1) = genetic distance of daughters
'score(2) = genetic distance of parents
'score(3) = degree of region overlap

OtherDist(1, 1, 0) = 2
OtherDist(1, 1, 1) = 2
OtherDist(1, 2, 0) = 2
OtherDist(1, 2, 1) = 1
OtherDist(2, 1, 0) = 1
OtherDist(2, 1, 1) = 2
OtherDist(2, 2, 0) = 1
OtherDist(2, 2, 1) = 1




For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        ISeqs(0, 0) = XoverList(x, Y).Daughter
        ISeqs(0, 1) = XoverList(x, Y).MinorP
        ISeqs(0, 2) = XoverList(x, Y).MajorP
        Span(0, 0) = XoverList(x, Y).Beginning
        Span(0, 1) = XoverList(x, Y).Ending
        ENX(0) = XoverList(x, Y).Eventnumber
        PValE(0) = -Log10(XoverList(x, Y).Probability)
        
        'Make a "template" of the region
        ReDim TempFrag(Len(StrainSeq(0)))
        If Span(0, 0) < Span(0, 1) Then
            SizeE(0) = Span(0, 1) - Span(0, 0)
            For Z = Span(0, 0) To Span(0, 1)
                TempFrag(Z) = 1
            Next Z
        Else
            SizeE(0) = Len(StrainSeq(0)) - Span(0, 1) + Span(0, 0)
            For Z = Span(0, 0) To Len(StrainSeq(0))
                TempFrag(Z) = 1
            Next Z
            For Z = 1 To Span(0, 1)
                TempFrag(Z) = 1
            Next Z
        End If
        For Z = 0 To NextNo
            For A = 1 To CurrentXOver(Z)
                If A <> Y Or x <> Z Then
                    ISeqs(1, 0) = XoverList(Z, A).Daughter
                    If ISeqs(1, 0) <> ISeqs(0, 0) Then
                        ISeqs(1, 1) = XoverList(Z, A).MinorP
                        ISeqs(1, 2) = XoverList(Z, A).MajorP
                        Span(1, 0) = XoverList(Z, A).Beginning
                        Span(1, 1) = XoverList(Z, A).Ending
                        ENX(1) = XoverList(Z, A).Eventnumber
                        PValE(1) = -Log10(XoverList(Z, A).Probability)
                        SizeE(2) = 0
                        
                        FLHit(0) = -1
                        FLHit(1) = -1
                        If Span(1, 0) < Span(1, 1) Then
                            SizeE(1) = Span(1, 1) - Span(1, 0)
                            For b = Span(1, 0) To Span(1, 1)
                                SizeE(2) = SizeE(2) + TempFrag(b)
                                If TempFrag(b) > 0 Then
                                    FLHit(1) = b
                                    If FLHit(0) = -1 Then
                                        FLHit(0) = b
                                    End If
                                End If
                            Next b
                        Else
                            SizeE(1) = Len(StrainSeq(0)) - Span(1, 1) + Span(1, 0)
                            For b = Span(1, 0) To Len(StrainSeq(0))
                                SizeE(2) = SizeE(2) + TempFrag(b)
                                If TempFrag(b) > 0 Then
                                    FLHit(1) = b
                                    If FLHit(0) = -1 Then
                                        FLHit(0) = b
                                    End If
                                End If
                            Next b
                            For b = 1 To Span(1, 1)
                                SizeE(2) = SizeE(2) + TempFrag(b)
                                If TempFrag(b) > 0 Then
                                    FLHit(1) = b
                                    If FLHit(0) = -1 Then
                                        FLHit(0) = b
                                    End If
                                End If
                            Next b
                        End If
                        
                        
                        
                        
                        comp1 = XoverList(x, Y).Eventnumber
                        comp2 = XoverList(Z, A).Eventnumber
                        x = x
                        
                        
                        If SizeE(2) > 0 Then 'ie there is some overlap
                            FLHit(1) = FLHit(1) + 100
                            
                            FLHit(0) = FLHit(0) - 100
                            
                            If FLHit(0) < 1 Then FLHit(0) = FLHit(0) + Len(StrainSeq(0))
                            If FLHit(1) > Len(StrainSeq(0)) Then FLHit(1) = FLHit(1) - Len(StrainSeq(0))
                            
                            FLHit(2) = FLHit(0) + 200
                            FLHit(3) = FLHit(1) - 200
                            
                            If FLHit(2) > Len(StrainSeq(0)) Then FLHit(2) = FLHit(1) - Len(StrainSeq(0))
                            If FLHit(3) < 1 Then FLHit(3) = FLHit(3) + Len(StrainSeq(0))
                            
                            
                            ReDim Hit(1), Valid(1)
                            If FLHit(0) < FLHit(2) Then
                                
                                For b = FLHit(0) To FLHit(2)
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                            Else
                                For b = FLHit(0) To Len(StrainSeq(0))
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                                For b = 1 To FLHit(2)
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                            End If
                            
                            If FLHit(1) > FLHit(3) Then
                                
                                For b = FLHit(3) To FLHit(1)
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                            Else
                                For b = FLHit(3) To Len(StrainSeq(0))
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                                For b = 1 To FLHit(1)
                                        If SeqNum(b, ISeqs(0, 0)) > 46 And SeqNum(b, ISeqs(1, 0)) > 46 Then
                                            Valid(0) = Valid(0) + 1
                                            If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                                Hit(0) = Hit(0) + 1
                                            End If
                                               
                                        End If
                                        
                                Next b
                            End If
                            If (ENX(0) = 11 And ENX(1) = 8) Or (ENX(0) = 8 And ENX(1) = 11) Then
                                x = x
                            End If
                            Score(0) = Hit(0) / Valid(0)
                            MaxDist = 1
                            For C = 0 To NextNo - 1
                                For D = C + 1 To NextNo
                                    If MaxDist > Distance(C, D) Then
                                        MaxDist = Distance(C, D)
                                    End If
                                    
                                Next D
                            Next C
                            x = x
                            MaxDist = 1 - MaxDist
                            Score(0) = Score(0) / MaxDist
                            
                            'Calculate the overlap score
                            Score(3) = 1 - SizeE(2) / ((SizeE(1) + SizeE(0)) / 2) 'ie 100% overlap = 0
                            
                            
                            
                            ReDim Valid(1)
                            ReDim Hit(1)
                            For b = 1 To Len(StrainSeq(0))
                                If TempFrag(b) > 0 Then
                                    If SeqNum(b, ISeqs(0, 0)) <> 46 And SeqNum(b, ISeqs(1, 0)) <> 46 Then
                                        Valid(0) = Valid(0) + 1
                                        If SeqNum(b, ISeqs(0, 0)) <> SeqNum(b, ISeqs(1, 0)) Then
                                            Hit(0) = Hit(0) + 1
                                        End If
                                    End If
                                    If SeqNum(b, ISeqs(0, 1)) <> 46 And SeqNum(b, ISeqs(1, 1)) <> 46 Then
                                        Valid(1) = Valid(1) + 1
                                        If SeqNum(b, ISeqs(0, 1)) <> SeqNum(b, ISeqs(1, 1)) Then
                                            Hit(1) = Hit(1) + 1
                                        End If
                                    End If
                                End If
                            Next b
                            
                            For b = 0 To 1
                                Hit(b) = Hit(b) / Valid(b)
                            Next b
                            
                            Score(1) = Hit(0)
                            Score(2) = Hit(1)
                            
                           
                            
                            
                 '           ReDim Valid(1, 1, 2)
                 '           ReDim Hit(1, 1, 2)
                 '
                 '           For B = 1 To Len(StrainSeq(0))
                 '               If TempFrag(B) > 0 Then
                 '                   For F = 0 To 1
                  '                      For E = 0 To 1
                 '                           For C = 0 To 2
                 '
                 '                               If SeqNum(B, Iseqs(F, 0)) <> 46 And SeqNum(B, Iseqs(E, C)) <> 46 Then
                 '                                   Valid(F, E, C) = Valid(F, E, C) + 1
                 '                                   If SeqNum(B, Iseqs(F, 0)) <> SeqNum(B, Iseqs(E, C)) Then
                 '                                       Hit(F, E, C) = Hit(F, E, C) + 1
                 '                                   End If
                 '                               End If
                 '
                 '                           Next C
                 '                       Next E
                 '                   Next F
                 '               End If
                 '           Next B
                            
                  
                  
                  '          For F = 0 To 1
                  '              For E = 0 To 1
                  '                  For C = 0 To 2
                  '                      If Valid(F, E, C) > 0 Then
                  '                          Hit(F, E, C) = Hit(F, E, C) / Valid(F, E, C)
                  '                      Else
                  '                          Hit(F, E, C) = 100
                  '                      End If
                  '                  Next
                  '              Next
                  '          Next
                  '
                  '          'get lowest score
                  '          LowDist(0) = 100
                  '          For F = 0 To 1
                  '              For E = 0 To 1
                   '                 For C = 0 To 2
                  '                      If LowDist(0) > Hit(F, E, C) And (E <> F Or C > 0) Then
                  '                          LowDist(0) = Hit(F, E, C)
                  '                          WinScore(0) = F
                  '                          WinScore(1) = E
                  '                          WinScore(2) = C
                  '
                  '                      End If
                  '                  Next C
                  '              Next E
                  '          Next F
                  '
                             
                            
                            
                         '   'Calculate parental sequence in recombinant region similarity score
                         '   If PValE(0) > PValE(1) Then
                         '       Score(0) = (PValE(0) - PValE(1)) / PValE(0)
                         '   Else
                         '       Score(0) = (PValE(1) - PValE(0)) / PValE(1)
                         '   End If
                            
                            'get parent and daughter identities
                           ' Score(1) = 1 - Distance(Iseqs(0, 0), Iseqs(1, 0))
                            
                            'Find the lowest two distances amongst the parents
                            
                        '    LowPDist(0) = 100
                        '    For B = 1 To 2
                        '        For C = 1 To 2
                        '            If LowPDist(0) > 1 - Distance(Iseqs(0, B), Iseqs(1, C)) Then
                        '                LowPDist(0) = 1 - Distance(Iseqs(0, B), Iseqs(1, C))
                        '                LowPDist(1) = 1 - Distance(Iseqs(0, OtherDist(B, C, 0)), Iseqs(1, OtherDist(B, C, 1)))
                        '            End If
                        '        Next C
                        '    Next B
                        '    Score(2) = (LowPDist(0) + LowPDist(1)) / 2
                            
                            'EventDist(BackTrace(X, Y), BackTrace(Z, A)) = (Score(0) +  Score(3)) / 2
                            EventDist(BackTrace(x, Y), BackTrace(Z, A)) = (Score(0) + Score(3)) / 2
                            
                            
                            
                            
                           
                            If EventDist(BackTrace(x, Y), BackTrace(Z, A)) < 0.1 Then
                                x = x
                            End If
                            
                             If comp1 = 5 And comp2 = 11 Then
                              x = x
                            End If
                            
                        Else
                            EventDist(BackTrace(x, Y), BackTrace(Z, A)) = 100
                        End If
                    Else
                        EventDist(BackTrace(x, Y), BackTrace(Z, A)) = 100
                    End If
                End If
            Next A
        Next Z
    Next Y
Next x
If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If

ReDim SuperEventList(BiggestE)
CEN = 0
Do
    LowDist(0) = 1000
    For x = 1 To BiggestE
        For Y = x + 1 To BiggestE
            If LowDist(0) > EventDist(x, Y) Then
                LowDist(0) = EventDist(x, Y)
                TRE(0) = x
                TRE(1) = Y
            End If
        Next Y
    Next x
    If LowDist(0) < 0.1 Then
        If SuperEventList(TRE(0)) = 0 And SuperEventList(TRE(1)) = 0 Then
            CEN = CEN + 1
            SuperEventList(TRE(0)) = CEN
            SuperEventList(TRE(1)) = CEN
        ElseIf SuperEventList(TRE(0)) > 0 And SuperEventList(TRE(1)) = 0 Then
            SuperEventList(TRE(1)) = SuperEventList(TRE(0))
        ElseIf SuperEventList(TRE(1)) > 0 And SuperEventList(TRE(0)) = 0 Then
            SuperEventList(TRE(0)) = SuperEventList(TRE(1))
        ElseIf SuperEventList(TRE(0)) > 0 And SuperEventList(TRE(1)) > 0 Then
            Replace = SuperEventList(TRE(1))
            For x = 0 To BiggestE
                If SuperEventList(x) = Replace Then SuperEventList(x) = SuperEventList(TRE(0))
            Next x
        End If
        
        
        For x = 1 To BiggestE
            If x <> TRE(0) And x <> TRE(1) Then
                EventDist(TRE(0), x) = (EventDist(TRE(0), x) + EventDist(TRE(1), x)) / 2
                EventDist(TRE(1), x) = 100
                EventDist(x, TRE(0)) = EventDist(TRE(0), x)
                EventDist(x, TRE(1)) = 100
            ElseIf x = TRE(0) Then
                EventDist(x, x) = 0
            ElseIf x = TRE(1) Then
                EventDist(TRE(0), x) = 100
                EventDist(x, TRE(0)) = 100
            End If
        Next x
    Else
        Exit Do
    End If
Loop
For x = 0 To BiggestE
    If SuperEventList(x) = 0 Then
        CEN = CEN + 1
        SuperEventList(x) = CEN
    End If
Next x

'For X = 0 To BiggestE
'    XOverlist(EventTrace(0, X), EventTrace(1, X)).Eventnumber = SuperEventList(X)'
'
'Next X


'make SuperEventList(X) understandable in terms of eventnumbers
Dim tSup() As Long
ReDim tSup(BiggestE)

For x = 1 To BiggestE
    tSup(XoverList(EventTrace(0, x), EventTrace(1, x)).Eventnumber) = SuperEventList(x) '
Next x

For x = 0 To BiggestE
    SuperEventList(x) = tSup(x)
Next x


End Sub

Public Sub CheckMatrixX(UB As Long, SCO As Long, MinSeqSize As Long, NextNo As Long, Valtot() As Long, ISeqs() As Long, PermValid() As Single, SubValid() As Single, FMat() As Single, SMat() As Single)
'int FAR pascal CheckMatrix(int UB, int SCO, int MinSeqSize, int Nextno, int *Valtot, int *ISeqs, double *PermValid, double *SubValid, double *FMat, double *SMat, double *FAMat, double *SAMat){
    Dim LoopNo As Long, GoOn As Long, x As Long, Y As Long, Z As Long, A As Long, EraseF As Long
    'int X, Y, Z, A, EraseF, off1, off2, off3, off4;
    Dim ReplaceVal As Double, NN As Double
    Dim ValtotF() As Long, ValtotS() As Long, MissPair() As Byte, MinNum As Long, MinSize As Long, MinS() As Long
    'double ReplaceVal,nn;
    NN = NextNo
    'nn=(double)(Nextno);
    
    ReplaceVal = (NN * 3 - 1) / 1000
    
'    SS = Abs(GetTickCount)
    
'    If SEventNumber = 46 Then
'        X = X
'    End If
    
    '$
    For x = 0 To NextNo '103'68
        
        EraseF = 0
        'off1 = X*(UB+1);
        'off2 = X*(Nextno+1);
        
        'XX = UBound(Fubvalid, 1)
       If UBound(PermValid, 1) < NextNo Then
            For Y = 0 To 2
                If ISeqs(Y) <= NextNo Then
                    If x <> ISeqs(Y) Then
                        If FubValid(ISeqs(Y), x) - SubValid(ISeqs(Y), x) < MinSeqSize Or SubValid(ISeqs(Y), x) < SCO Then
                            EraseF = 1
                            Exit For
                        End If
                    End If
                End If
            Next Y
       
        Else
            For Y = 0 To 2
                If ISeqs(Y) <= NextNo Then
                    '@
                    If x <> ISeqs(Y) Then
                        If PermValid(ISeqs(Y), x) - SubValid(ISeqs(Y), x) < MinSeqSize Or SubValid(ISeqs(Y), x) < SCO Then
                            EraseF = 1
                            Exit For
                        End If
                    End If
                End If
            Next Y
        End If
        'XX = UBound(FAMat, 1)
        If EraseF = 1 Then
            '$
            For Y = 0 To NextNo '19,36,51,55,69,79,81,82,84,85,87-94,97-103, 105-117,120,121
                'off3 = Y*(Nextno+1);
                
                FMat(x, Y) = 3#
                FMat(Y, x) = 3#
                SMat(x, Y) = 3#
                SMat(Y, x) = 3#

                                
            Next Y
        End If
    Next x
    
    GoOn = 0
    ReDim ValtotF(NextNo), ValtotS(NextNo), MissPair(NextNo, NextNo)
    ReDim MinS(NextNo)
'    SS = Abs(GetTickCount)
    '@'@'@'@
    If x = x Then
        GoOn = CheckMatrixP(MinS(0), ISeqs(0), NextNo, SCO, MinSeqSize, UBound(MissPair, 1), MissPair(0, 0), UBound(PermValid, 1), PermValid(0, 0), UBound(SubValid, 1), SubValid(0, 0), UBound(FMat, 1), FMat(0, 0), SMat(0, 0), ValtotF(0), ValtotS(0))
    Else
        For x = 0 To NextNo
            
            
            For Y = x + 1 To NextNo
                
                If FMat(Y, x) <> 3# Then
                    If PermValid(Y, x) - SubValid(Y, x) < MinSeqSize Then
                        MissPair(x, Y) = 1
                        MissPair(Y, x) = 1
                        For Z = 0 To 2
                            ValtotF(x) = ValtotF(x) + PermValid(ISeqs(Z), x) - SubValid(ISeqs(Z), x)
                            ValtotF(Y) = ValtotF(Y) + PermValid(ISeqs(Z), Y) - SubValid(ISeqs(Z), Y)
                        Next Z
                        GoOn = 1
                    End If
                    
                    If SubValid(Y, x) < SCO And SMat(Y, x) <> 3# Then
                        MissPair(x, Y) = 1
                        MissPair(Y, x) = 1
                        For Z = 0 To 2
                            ValtotS(x) = ValtotS(x) + SubValid(ISeqs(Z), x)
                            ValtotS(Y) = ValtotS(Y) + SubValid(ISeqs(Z), Y)
                        Next Z
                        GoOn = 1
                    End If
                    'XX = Nextno
                End If
            Next Y
        Next x
        'XX = UBound(SeqNum, 2)
    '    EE = Abs(GetTickCount)
    '    TT = EE - SS '1.482
        '0.172
        
        '21,17:29,17
        
    
        MinNum = 0
        
        LoopNo = 0
        
        Do While GoOn = 1
            
            MinSize = 1000000000#
            
            For x = 0 To NextNo
                If ValtotS(x) > 0 Then
                    If ValtotS(x) < MinSize Then
                        MinNum = 0
                        MinSize = ValtotS(x)
                        MinS(0) = x
                    ElseIf ValtotS(x) = MinSize Then
                        MinNum = MinNum + 1
                        MinS(MinNum) = x
                    End If
                End If
                If ValtotF(x) > 0 Then
                    If ValtotF(x) < MinSize Then
                        MinNum = 0
                        MinSize = ValtotF(x)
                        MinS(0) = x
                    ElseIf ValtotF(x) = MinSize Then
                        MinNum = MinNum + 1
                        MinS(MinNum) = x
                    End If
                End If
            Next x
            '8,11,10,2,17
            '@'@'@
            For x = 0 To MinNum
                ValtotS(MinS(x)) = 0
                ValtotF(MinS(x)) = 0
                For Y = 0 To NextNo
                    FMat(MinS(x), Y) = 3# '1,4,6,9,11,12,13,14,15,16,21,23,24,25,28,29,30,31,34,35,37,39,42,48,51,52,60,61,62,63,67,90,94
                    FMat(Y, MinS(x)) = 3# '1,6,8,12,23,24,29,30,34,37,42,48,62,65
                    SMat(MinS(x), Y) = 3# '30,24,8,65,23,29,42,6,48,37,34,1,12,62
                    SMat(Y, MinS(x)) = 3# '34,90,1,12,31,25,39,21,9,13,14,16,51,28,11,60,61,15,67,10
                    MissPair(Y, MinS(x)) = 0
                    MissPair(MinS(x), Y) = 0
                    If MinS(x) <> Y Then
                    End If
                Next Y
            Next x
            
            GoOn = 0
            '@'@'@'@'@'@'@
            For x = 0 To NextNo
                For Y = 0 To NextNo
                
                    If MissPair(x, Y) = 1 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                
                If GoOn = 1 Then
                    Exit For
                
                End If
            Next x
            
            LoopNo = LoopNo + 1
            If LoopNo > NextNo * 10 Then Exit Do
        Loop
        
    '    XX = SEventNumber
        'clean up any leftovers
        For x = 0 To NextNo
            If FMat(x, x) <> 3# Then
                For Y = 0 To NextNo
                    If FMat(x, Y) < 3# And x <> Y Then
                       Exit For
                    End If
                Next Y
               
                If Y = NextNo + 1 Then
                    FMat(x, x) = 3#
                End If
            End If
        Next x
    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS '4.009 for 3203 seqs
'X = X
End Sub
Public Sub CheckMatrixX2(UB As Long, SCO As Long, MinSeqSize As Long, NextNo As Long, Valtot() As Long, ISeqs() As Long, PermValid() As Single, SubValid() As Single, FMat() As Single)
'int FAR pascal CheckMatrix(int UB, int SCO, int MinSeqSize, int Nextno, int *Valtot, int *ISeqs, double *PermValid, double *SubValid, double *FMat, double *SMat, double *FAMat, double *SAMat){
    Dim LoopNo As Long, GoOn As Long, x As Long, Y As Long, Z As Long, A As Long, EraseF As Long
    'int X, Y, Z, A, EraseF, off1, off2, off3, off4;
    Dim ReplaceVal As Double, NN As Double
    Dim ValtotF() As Long, ValtotS() As Long, MissPair() As Byte, MinNum As Long, MinSize As Long, MinS() As Long
    'double ReplaceVal,nn;
    NN = NextNo
    'nn=(double)(Nextno);
    
    ReplaceVal = (NN * 3 - 1) / 1000
    
'    SS = Abs(GetTickCount)
    
'    If SEventNumber = 46 Then
'        X = X
'    End If
    '&
    For x = 0 To NextNo '103'68
        
        EraseF = 0
        'off1 = X*(UB+1);
        'off2 = X*(Nextno+1);
        
        'XX = UBound(Fubvalid, 1)
       If UBound(PermValid, 1) < NextNo Then
            For Y = 0 To 2
                If ISeqs(Y) <= NextNo Then
                    If x <> ISeqs(Y) Then
                        If FubValid(ISeqs(Y), x) - SubValid(ISeqs(Y), x) < MinSeqSize Or SubValid(ISeqs(Y), x) < SCO Then
                            EraseF = 1
                            Exit For
                        End If
                    End If
                End If
            Next Y
       
        Else
            For Y = 0 To 2
                If ISeqs(Y) <= NextNo Then
                    If x <> ISeqs(Y) Then
                        If PermValid(ISeqs(Y), x) - SubValid(ISeqs(Y), x) < MinSeqSize Or SubValid(ISeqs(Y), x) < SCO Then
                            EraseF = 1
                            Exit For
                        End If
                    End If
                End If
            Next Y
        End If
        'XX = UBound(FAMat, 1)
        If EraseF = 1 Then
            
            For Y = 0 To NextNo '19,36,51,55,69,79,81,82,84,85,87-94,97-103, 105-117,120,121
                'off3 = Y*(Nextno+1);
                
                FMat(x, Y) = 3#
                FMat(Y, x) = 3#
                

                                
            Next Y
        End If
    Next x
    
    GoOn = 0
    ReDim ValtotF(NextNo), ValtotS(NextNo), MissPair(NextNo, NextNo)
    
'    SS = Abs(GetTickCount)
    '@'&'&'&
    For x = 0 To NextNo
        
        
        For Y = x + 1 To NextNo
            
            If FMat(Y, x) <> 3# Then
                If PermValid(Y, x) - SubValid(Y, x) < MinSeqSize Then
                    MissPair(x, Y) = 1
                    MissPair(Y, x) = 1
                    For Z = 0 To 2
                        ValtotF(x) = ValtotF(x) + PermValid(ISeqs(Z), x) - SubValid(ISeqs(Z), x)
                        ValtotF(Y) = ValtotF(Y) + PermValid(ISeqs(Z), Y) - SubValid(ISeqs(Z), Y)
                    Next Z
                    GoOn = 1
                End If
                
                If SubValid(Y, x) < SCO And FMat(Y, x) <> 3# Then
                    MissPair(x, Y) = 1
                    MissPair(Y, x) = 1
                    For Z = 0 To 2
                        ValtotS(x) = ValtotS(x) + SubValid(ISeqs(Z), x)
                        ValtotS(Y) = ValtotS(Y) + SubValid(ISeqs(Z), Y)
                    Next Z
                    GoOn = 1
                End If
                'XX = Nextno
            End If
        Next Y
    Next x
    'XX = UBound(SeqNum, 2)
'    EE = Abs(GetTickCount)
'    TT = EE - SS '1.482
    '0.172
    
    '21,17:29,17
    MinNum = 0
    ReDim MinS(NextNo)
    LoopNo = 0
    '&'&'&'&'&'&
    Do While GoOn = 1
        
        MinSize = 1000000000#
        
        For x = 0 To NextNo
            If ValtotS(x) > 0 Then
                If ValtotS(x) < MinSize Then
                    MinNum = 0
                    MinSize = ValtotS(x)
                    MinS(0) = x
                ElseIf ValtotS(x) = MinSize Then
                    MinNum = MinNum + 1
                    MinS(MinNum) = x
                End If
            End If
            If ValtotF(x) > 0 Then
                If ValtotF(x) < MinSize Then
                    MinNum = 0
                    MinSize = ValtotF(x)
                    MinS(0) = x
                ElseIf ValtotF(x) = MinSize Then
                    MinNum = MinNum + 1
                    MinS(MinNum) = x
                End If
            End If
        Next x
        '8,11,10,2,17
        For x = 0 To MinNum
            ValtotS(MinS(x)) = 0
            ValtotF(MinS(x)) = 0
            For Y = 0 To NextNo
                FMat(MinS(x), Y) = 3# '1,4,6,9,11,12,13,14,15,16,21,23,24,25,28,29,30,31,34,35,37,39,42,48,51,52,60,61,62,63,67,90,94
                FMat(Y, MinS(x)) = 3# '1,6,8,12,23,24,29,30,34,37,42,48,62,65
                MissPair(Y, MinS(x)) = 0
                MissPair(MinS(x), Y) = 0
                If MinS(x) <> Y Then
                End If
            Next Y
        Next x
        
        GoOn = 0
        
        For x = 0 To NextNo
            For Y = 0 To NextNo
            
                If MissPair(x, Y) = 1 Then
                    GoOn = 1
                    Exit For
                End If
            Next Y
            
            If GoOn = 1 Then
                Exit For
            
            End If
        Next x
        
        LoopNo = LoopNo + 1
        If LoopNo > NextNo * 10 Then Exit Do
    Loop
                    
'    XX = SEventNumber
    'clean up any leftovers
    For x = 0 To NextNo
        If FMat(x, x) <> 3# Then
            For Y = 0 To NextNo
                If FMat(x, Y) < 3# And x <> Y Then
                   Exit For
                End If
            Next Y
           
            If Y = NextNo + 1 Then
                FMat(x, x) = 3#
            End If
        End If
    Next x
'    EE = Abs(GetTickCount)
'    TT = EE - SS '4.009 for 3203 seqs
'X = X
End Sub
Public Sub CheckMatrixY(UB As Long, SCO As Long, MinSeqSize As Long, NextNo As Long, Valtot() As Long, ISeqs() As Long, FubValid() As Single, SubValid() As Single, FMat() As Single, SMat() As Single)
'int FAR pascal CheckMatrix(int UB, int SCO, int MinSeqSize, int Nextno, int *Valtot, int *ISeqs, double *PermValid, double *SubValid, double *FMat, double *SMat, double *FAMat, double *SAMat){
    
    'starttime = Abs(GetTickCount)
    Dim LastX As Long, NumPos As Long, LoopNo As Long, GoOn As Long, Dummy As Long, FF As Long, oDir As String, x As Long, Y As Long, Z As Long, A As Long, EraseF As Long, UBX As Long, SCOS As Long, SCOF As Long
    'int X, Y, Z, A, EraseF, off1, off2, off3, off4;
    Dim ReplaceVal As Double, NN As Double, UB2 As Long
    Dim ValtotF() As Long, ValtotS() As Long, MissPair() As Byte, MinNum As Long, MinSize As Long, MinS() As Long
    'double ReplaceVal,nn;
    NN = NextNo
    'nn=(double)(Nextno);
    
    If UBound(SMat, 1) = 0 Then
        GetSMat
    End If
    If UBound(SubValid, 1) = 0 Then
        GetSubValid
    End If
    XX = Seq1
    XX = Seq2
    XX = Seq3
    'GetFMat
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            If FMat(x, Y) > 0 Then
'                x = x
'            End If
'        Next Y
'    Next x
    
    XX = NextNo
    XX = UBound(FMat, 1)
    ReplaceVal = (NN * 3 - 1) / 1000
    'XX = UBound(PermValid, 1)
    UB2 = UBound(FMat, 1)
    For x = 0 To NextNo
        If x <= UB2 Then
            If FMat(x, x) = 3 Or SMat(x, x) = 3 Then
                FMat(x, x) = 3
                SMat(x, x) = 3
            End If
        End If
    Next x
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SubValid, 1)
    If UB = 0 Then
    
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        ReDim SubValid(PermNextno, PermNextno)
        ReDim SMat(PermNextno, PermNextno)
        Open "RDP5SubValid" + UFTag For Binary As #FF
        If LOF(FF) > 0 Then
            Get #FF, , SubValid()
            Close #FF
        Else
            Close #FF
            For x = 0 To UBound(PermValid, 1)
                For Y = 0 To UBound(PermValid, 1)
                    SubValid(x, Y) = PermValid(x, Y)
                    SMat(x, Y) = FMat(x, Y)
                Next Y
            Next x
        End If
        ChDir oDir
        ChDrive oDir
    
    
    End If
    On Error GoTo 0
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(SMat, 1)
    On Error GoTo 0
  
    'If X = X Then
        '@
        'Dummy = EraseEmpties(Nextno, UB, UBound(FMat, 1), SCO, ISeqs(0), FMat(0, 0), FubValid(0, 0), SMat(0, 0), SubValid(0, 0))
        Dummy = EraseEmptiesP(NextNo, UB, UBound(FMat, 1), SCO, ISeqs(0), FMat(0, 0), FubValid(0, 0), SMat(0, 0), SubValid(0, 0))
    
'    Else
'        For X = 0 To Nextno '103'68
'
'            If FMat(X, X) <> 3 Then
'
'                EraseF = 0
'                'off1 = X*(UB+1);
'                'off2 = X*(Nextno+1);
'
'                For Y = 0 To 2
'                    If ISeqs(Y) <= Nextno Then
'                        If X <> ISeqs(0) And X <> ISeqs(1) And X <> ISeqs(2) Then
'
'                            If FubValid(ISeqs(Y), X) < SCO Or SubValid(ISeqs(Y), X) < SCO Then '9412,0
'                                EraseF = 1
'                                Exit For '9,13,22,25,26,27,28,29
'                                        '9,13,22,25,26,27,28,29
'                            End If
'                        Else
'                            X = X
'                        End If
'                    End If
'                Next Y
'
'                If EraseF = 1 Then
'
'                    For Y = 0 To Nextno '0,2,3,7,17,19,20,36,38,41,44,45,46,47,53,54,55,56,57,58,64
'                        FMat(X, Y) = 3#
'                        FMat(Y, X) = 3#
'                        If UB > 0 Then
'                            SMat(X, Y) = 3#
'                            SMat(Y, X) = 3#
'                        End If
'
'
'                    Next Y
'
'                End If
'
'            End If
'        Next X
'    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X '1.4
    'fred event 2 219,203
    'p-version 219
    'parallelised version 78,94

'    For X = 0 To Nextno
'        If FMat(X, X) = 3 Then
'            XX = XX + 1
'        End If
'    Next X
    '2371
    GoOn = 0
    If NextNo = -1 Then Exit Sub
    ReDim ValtotF(NextNo), ValtotS(NextNo), MissPair(NextNo, NextNo)
    

    UBX = UBound(SubValid, 1)
    

    
    
    'If X = X Then
        GoOn = MakeValTots(NextNo, SCO, UBX, UBound(FMat, 1), UBound(FubValid, 1), UBound(MissPair, 1), ValtotS(0), ValtotF(0), ISeqs(0), MissPair(0, 0), FubValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0))
'    Else
'        For X = 0 To Nextno
'
'            If FMat(X, X) <> 3 Then
'
'                For Y = X + 1 To Nextno
'                    If FMat(Y, Y) <> 3 Then
'                        If FMat(Y, X) <> 3# Then
'                            If FubValid(Y, X) < SCO Then
'                                MissPair(X, Y) = 1
'                                MissPair(Y, X) = 1
'                                For Z = 0 To 2
'                                    If ISeqs(Z) <= UBX Then
'                                        ValtotF(X) = ValtotF(X) + FubValid(ISeqs(Z), X)
'                                        ValtotF(Y) = ValtotF(Y) + FubValid(ISeqs(Z), Y)
'                                    End If
'                                Next Z
'                                GoOn = 1
'                            End If
'                            If SubValid(Y, X) < SCO And SMat(Y, X) <> 3# Then
'                                MissPair(X, Y) = 1
'                                MissPair(Y, X) = 1
'                                For Z = 0 To 2
'                                    If ISeqs(Z) <= UBX Then
'            '                            If X = 8 Or Y = 8 Then
'            '                                X = X
'            '                            End If
'                                        ValtotS(X) = ValtotS(X) + SubValid(ISeqs(Z), X)
'                                        ValtotS(Y) = ValtotS(Y) + SubValid(ISeqs(Z), Y)
'                                    End If
'                                Next Z
'                                GoOn = 1
'                            End If
'                        End If
'                    End If
'                Next Y
'            Else
'                X = X '9,13,22,25,26,27,28
'            End If
'        Next X
'    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS
    '0.172
    
    '21,17:29,17
    MinNum = 0
    ReDim MinS(NextNo)
    LoopNo = 0
    'XX = FMat(8, 8)
    Do While GoOn = 1
        'XX = FMat(8, 8)
        MinSize = 10000000
        For x = 0 To NextNo
            
            If FMat(x, x) <> 3 Then
                If x <> ISeqs(0) And x <> ISeqs(1) And x <> ISeqs(2) Then
                    If ValtotS(x) > 0 Then
                        If ValtotS(x) < MinSize Then
                            MinNum = 0
                            MinSize = ValtotS(x)
                            MinS(0) = x
                             
                        ElseIf ValtotS(x) = MinSize Then
                            MinNum = MinNum + 1
                            MinS(MinNum) = x
                             
                        End If
                    End If
                    If ValtotF(x) > 0 Then
                        If ValtotF(x) < MinSize Then
                            MinNum = 0
                            MinSize = ValtotF(x)
                            MinS(0) = x
                             
                        ElseIf ValtotF(x) = MinSize Then
                            MinNum = MinNum + 1
                            MinS(MinNum) = x
                            
                        End If
                    End If
                End If
            End If
        Next x
        
        '8,11,10,2,17
        '
        For x = 0 To MinNum
            ValtotS(MinS(x)) = 0
            ValtotF(MinS(x)) = 0
            A = MinS(x)
            For Y = 0 To NextNo
                
                FMat(A, Y) = 3# '1,4,6,9,11,12,13,14,15,16,21,23,24,25,28,29,30,31,34,35,37,39,42,48,51,52,60,61,62,63,67,90,94
                FMat(Y, A) = 3# '1,6,8,12,23,24,29,30,34,37,42,48,62,65
                SMat(A, Y) = 3# '30,24,8,65,23,29,42,6,48,37,34,1,12,62
                SMat(Y, A) = 3# '34,90,1,12,31,25,39,21,9,13,14,16,51,28,11,60,61,15,67,10
                MissPair(Y, A) = 0
                MissPair(A, Y) = 0
                
            Next Y
            
        Next x
        GoOn = 0
        
        For x = 0 To NextNo
            If FMat(x, x) < 3 Then
                For Y = 0 To NextNo
                
                    If MissPair(x, Y) = 1 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                If GoOn = 1 Then
                    Exit For
                
                End If
            End If
        Next x
        
        LoopNo = LoopNo + 1
        If LoopNo > NextNo * 10 Then Exit Do
        If LoopNo > NextNo Then
            NumPos = 0
            For x = 0 To NextNo
                If FMat(x, x) < 3 Then
                    
                    NumPos = NumPos + 1
                End If
            Next x
            
            If LastX = NumPos Then Exit Do
            LastX = NumPos
            
        End If
    
    Loop
     
    
    'clean up any leftovers
    For x = 0 To NextNo
        If x <> ISeqs(0) And x <> ISeqs(1) And x <> ISeqs(2) Then
            If FMat(x, x) <> 3# Then
                For Y = 0 To NextNo
                    If FMat(x, Y) < 3# And x <> Y Then
                       Exit For
                    End If
                Next Y
               
                If Y = NextNo + 1 Then
                    FMat(x, x) = 3#
                End If
            End If
        End If
    Next x


End Sub
Public Sub CheckEndsVB(OBE, oEN, RL, Warn, LSS, ChF, CirF, Seq1, Seq2, Seq3, BPos As Long, Epos As Long, SeqNum() As Integer, XPD() As Long, XDP() As Long)
Dim Cycle As Long, x As Long, Target As Long, tBPos As Long, tEPos As Long

'BPos = Recompress(BPos)
'EPos = Recompress(EPos)
tBPos = BPos
tEPos = Epos
'This is needed because of geneconv xposdiffs not containing invarient site positions
If OBE = 0 And oEN = 0 Then
    Cycle = 0
    If XPD(Epos) = 0 Then
        Do While XPD(Epos) = 0
            Epos = Epos - 1
            If Epos < 1 Then
                Epos = Len(StrainSeq(0))
                If Cycle = 1 Then
                    Warn = 1
                    Exit Sub
                End If
                Cycle = 1
            End If
            
        Loop
    End If
    
    If XPD(BPos) = 0 Then
        Do While XPD(BPos) = 0
            BPos = BPos + 1
            If BPos > Len(StrainSeq(0)) Then BPos = 1
        Loop
    End If
End If
If OBE = 0 And oEN = 0 Then
    '$
    Warn = CheckEnds(Len(StrainSeq(0)), RL, LSS, ChF, CirF, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(0, 0), XPD(0), XDP(0), MissingData(0, 0))
    x = x
Else

    
    If ChF = 0 Then
        
        If OBE - RL > 0 Then
            Target = XDP(OBE - RL)
        Else
            If CirF = 1 Then
                If (OBE - RL + LSS >= 0) Then
                    Target = XDP(OBE - RL + LSS)
                Else
                    Target = 1
                End If
            Else
                Target = 1
            End If
        End If
        If OBE + RL < LSS Then
            BPos = XDP(OBE + RL)
        
        Else
            If CirF = 1 Then
                BPos = XDP(OBE + RL - LSS)
                
            Else
                BPos = Len(StrainSeq(0))
            End If
        End If
        If UBound(MissingData, 2) < PermNextno Then
            ReDim Preserve MissingData(Len(StrainSeq(0)), PermNextno)
        End If
        If Target < BPos Then
            For x = Target To BPos
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
        Else
             For x = Target To Len(StrainSeq(0)) - 1
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
            If CirF = 0 Then
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                End If
                If MissingData(1, Seq1) = 1 Or MissingData(1, Seq2) = 1 Or MissingData(1, Seq3) = 1 Then
                    Warn = 1
                End If
            End If
            If Warn = 0 Then
                For x = 2 To BPos
                    If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                        Warn = 1
                        Exit For
                    End If
                Next x
            End If
        End If
    ElseIf ChF = 1 Then
        
        If oEN + RL < LSS Then
            Target = XDP(oEN + RL)
        Else
            If CirF = 1 Then
                Target = XDP(oEN + RL - LSS)
                
            Else
                Target = Len(StrainSeq(0))
            End If
        End If
        If oEN - RL > 0 Then
            Epos = XDP(oEN - RL)
        Else
            If CirF = 1 Then
                If (oEN - RL + LSS >= 0) Then
                    Epos = XDP(oEN - RL + LSS)
                Else
                    Epos = 1
                End If
            Else
                Epos = 1
            End If
        End If
        If Epos < 1 Then
            If CirF = 1 Then
                Epos = Epos + Len(StrainSeq(0))
            Else
            
                Epos = Len(StrainSeq(0))
            End If
        End If
        If Target > Epos Then
            For x = Epos To Target
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
        Else
             For x = Epos To Len(StrainSeq(0)) - 1
                
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
            
            'warn = 0
            If CirF = 0 Then
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    
                End If
                If MissingData(1, Seq1) = 1 Or MissingData(1, Seq2) = 1 Or MissingData(1, Seq3) = 1 Then
                    Warn = 1
                End If
            End If
            
            If Warn = 0 Then
                
                For x = 2 To Target
                    If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                        Warn = 1
                        Exit For
                    End If
                Next x
            End If
        End If
    End If
End If
If OBE = 0 And oEN = 0 Then
    If CircularFlag = 0 Then
        If ChF = 0 Then
            If XPD(tBPos) < RL Then
                Warn = 1
            End If
        Else
            If XPD(tEPos) + RL > LSS Then
                Warn = 1
            End If
        
        End If
    End If
Else
    If CircularFlag = 0 Then
        If ChF = 0 Then
            If OBE < RL Then
                Warn = 1
            End If
        Else
            If oEN + RL > LSS Then
                Warn = 1
            End If
        
        End If
    End If
End If
Epos = tEPos
BPos = tBPos
End Sub

Public Sub CheckEndsVB2(ElementX As Long, OBE, oEN, RL, Warn, LSS, ChF, CirF, Seq1, Seq2, Seq3, BPos As Long, Epos As Long, SeqNum() As Integer, XPD() As Long, XDP() As Long)
Dim Cycle As Long, x As Long, Target As Long, tBPos As Long, tEPos As Long

'BPos = Recompress(BPos)
'EPos = Recompress(EPos)
tBPos = BPos
tEPos = Epos
'This is needed because of geneconv xposdiffs not containing invarient site positions
If OBE = 0 And oEN = 0 Then
    Cycle = 0
    If XPD(Epos, ElementX) = 0 Then
        Do While XPD(Epos, ElementX) = 0
            Epos = Epos - 1
            If Epos < 1 Then
                Epos = Len(StrainSeq(0))
                If Cycle = 1 Then
                    Warn = 1
                    Exit Sub
                End If
                Cycle = 1
            End If
            
        Loop
    End If
    
    If XPD(BPos, ElementX) = 0 Then
        Do While XPD(BPos, ElementX) = 0
            BPos = BPos + 1
            If BPos > Len(StrainSeq(0)) Then BPos = 1
        Loop
    End If
End If
If OBE = 0 And oEN = 0 Then
    
    Warn = CheckEnds(Len(StrainSeq(0)), RL, LSS, ChF, CirF, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(0, 0), XPD(0, ElementX), XDP(0, ElementX), MissingData(0, 0))
Else

    
    If ChF = 0 Then
        
        If OBE - RL > 0 Then
            Target = XDP(OBE - RL, ElementX)
        Else
            If CirF = 1 Then
                If (OBE - RL + LSS >= 0) Then
                    Target = XDP(OBE - RL + LSS, ElementX)
                Else
                    Target = 1
                End If
            Else
                Target = 1
            End If
        End If
        If OBE + RL < LSS Then
            BPos = XDP(OBE + RL, ElementX)
        
        Else
            If CirF = 1 Then
                BPos = XDP(OBE + RL - LSS)
                
            Else
                BPos = Len(StrainSeq(0))
            End If
        End If
        If UBound(MissingData, 2) < PermNextno Then
            ReDim Preserve MissingData(Len(StrainSeq(0)), PermNextno)
        End If
        If Target < BPos Then
            For x = Target To BPos
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
        Else
             For x = Target To Len(StrainSeq(0)) - 1
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
            If CirF = 0 Then
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                End If
                If MissingData(1, Seq1) = 1 Or MissingData(1, Seq2) = 1 Or MissingData(1, Seq3) = 1 Then
                    Warn = 1
                End If
            End If
            If Warn = 0 Then
                For x = 2 To BPos
                    If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                        Warn = 1
                        Exit For
                    End If
                Next x
            End If
        End If
    ElseIf ChF = 1 Then
        
        If oEN + RL < LSS Then
            Target = XDP(oEN + RL, ElementX)
        Else
            If CirF = 1 Then
                Target = XDP(oEN + RL - LSS, ElementX)
                
            Else
                Target = Len(StrainSeq(0))
            End If
        End If
        If oEN - RL > 0 Then
            Epos = XDP(oEN - RL, ElementX)
        Else
            If CirF = 1 Then
                If (oEN - RL + LSS >= 0) Then
                    Epos = XDP(oEN - RL + LSS, ElementX)
                Else
                    Epos = 1
                End If
            Else
                Epos = 1
            End If
        End If
        If Epos < 1 Then
            If CirF = 1 Then
                Epos = Epos + Len(StrainSeq(0))
            Else
            
                Epos = Len(StrainSeq(0))
            End If
        End If
        If Target > Epos Then
            For x = Epos To Target
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
        Else
             For x = Epos To Len(StrainSeq(0)) - 1
                
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    Exit For
                End If
            Next x
            
            'warn = 0
            If CirF = 0 Then
                If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                    Warn = 1
                    
                End If
                If MissingData(1, Seq1) = 1 Or MissingData(1, Seq2) = 1 Or MissingData(1, Seq3) = 1 Then
                    Warn = 1
                End If
            End If
            
            If Warn = 0 Then
                
                For x = 2 To Target
                    If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
                        Warn = 1
                        Exit For
                    End If
                Next x
            End If
        End If
    End If
End If
If OBE = 0 And oEN = 0 Then
    If CircularFlag = 0 Then
        If ChF = 0 Then
            If XPD(tBPos, ElementX) < RL Then
                Warn = 1
            End If
        Else
            If XPD(tEPos, ElementX) + RL > LSS Then
                Warn = 1
            End If
        
        End If
    End If
Else
    If CircularFlag = 0 Then
        If ChF = 0 Then
            If OBE < RL Then
                Warn = 1
            End If
        Else
            If oEN + RL > LSS Then
                Warn = 1
            End If
        
        End If
    End If
End If
Epos = tEPos
BPos = tBPos
End Sub

Public Sub WriteIni()

Dim iniName As String

    If DebuggingFlag < 2 Then On Error Resume Next
    iniName$ = App.Path + "\RDP.ini"

    If CLine = "" Or CLine = " " Then
        'Close #1
        Open iniName$ For Output As #1
        Write #1, CurDir
        Write #1, DefExt
        Write #1, SpacerFlag, CircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, XOverWindowX, LowestProb, MCFlag
        Write #1, SHWinLen, GCIndelFlag, SHStep, GCtripletflag
        Write #1, GCOutfileName
        Write #1, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
        Write #1, GCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, GCMinFragLen, GCMinPolyInFrag
        Write #1, GCMinPairScore, GCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
        Write #1, BSStepWin, BSStepSize, BSCutOff, BSBootReps, BSRndNumSeed, BSSubModelFlag
        Write #1, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
        Write #1, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
        Write #1, AllowConflict, MCPermMaxP, MCSteplen, MCWinSize
        Write #1, DoScans(0, 0), DoScans(0, 1), DoScans(0, 2), DoScans(0, 3), DoScans(0, 4), DoScans(0, 5)
        Write #1, FileList(1), FileList(2), FileList(3), FileList(4)
        Write #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
        Write #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
        Write #1, MCWinFract, MCProportionFlag, MCTripletFlag, MCStripGapsFlag
        Write #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
        Write #1, VisRDWin, ModelTestFlag
        Write #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
        Write #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
        Write #1, TOTreeType, TOFreqFlag, TOModel
        Write #1, BSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
        Write #1, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
        Write #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
        Write #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
        Write #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, BSPValFlag, SSFastFlag, SSGapFlag, SSVarPFlag, SSOutlyerFlag, SSRndSeed, SSWinLen, SSStep, SSNumPerms, SSNumPerms2
        Write #1, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, CWinFract, CProportionFlag, CWinSize, 0, 0
        Write #1, PPWinLen, PPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
        Write #1, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
        Write #1, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
        Close #1
        

    
        
        
        
    End If
End Sub
Public Sub ReSort()

Dim TotTarget As Long, TotSorted As Long, Winner As Byte, GoOn As Byte, BPos2 As Long, EPos2 As Long, BPos4 As Long, EPos4 As Long, TempLen2() As Byte, DaughterSeq As Long, Relatives(2) As Long, AcceptTarget As Long, BestHit(1) As Long, BestPval As Double, DoneOne() As Byte
'find best P-val for an "accepted" event when accepttarget = 1, but
'find best P-val for an accepted event if all accepted events handled
ReDim DoneOne(NextNo, XOverListSize)
ReDim ShowAllHits(NextNo)
TotSorted = 0
TotTarget = 0
For x = 0 To NextNo
    TotTarget = TotTarget + CurrentXOver(x)
Next x

SS = Abs(GetTickCount)

Do
   
    For AcceptTarget = 1 To 0 Step -1
        BestPval = 1
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If DoneOne(x, Y) = 0 Then
                    If XoverList(x, Y).Accept = AcceptTarget Then
                        If BestPval > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                            
                            BestPval = XoverList(x, Y).Probability
                            If BestPval = 0 Then
                                x = x
                            End If
                            BestHit(0) = x
                            BestHit(1) = Y
                        End If
                    End If
                End If
            Next Y
        Next x
        If BestPval < 1 Then Exit For
    Next
    
    If BestPval = 1 Then Exit Do
    
    DoneOne(BestHit(0), BestHit(1)) = 1
    'TotSorted = TotSorted + 1
    
    DaughterSeq = BestHit(0)
    BPos4 = XoverList(BestHit(0), BestHit(1)).Beginning
    EPos4 = XoverList(BestHit(0), BestHit(1)).Ending
    
    ReDim TempLen2(Len(StrainSeq(0)))
    If BPos4 > EPos4 Then
        EPos4 = Len(StrainSeq(0)) + EPos4
    End If
    
    If BPos4 > Len(StrainSeq(0)) Then BPos4 = BPos4 - Len(StrainSeq(0))
    If EPos4 > Len(StrainSeq(0)) Then EPos4 = EPos4 - Len(StrainSeq(0))
                        
    If BPos4 < EPos4 Then
        For Z = BPos4 To EPos4
            TempLen2(Z) = 1
        Next Z
    Else
        For Z = BPos4 To Len(StrainSeq(0))
            TempLen2(Z) = 1
        Next Z
        For Z = 1 To EPos4
            TempLen2(Z) = 1
        Next Z
    End If
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If DoneOne(x, Y) = 0 And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Accept <> 1 Then
                'Check to see whether any of these share
                Relatives(0) = XoverList(x, Y).Daughter
                Relatives(1) = XoverList(x, Y).MinorP
                Relatives(2) = XoverList(x, Y).MajorP
                GoOn = 0
                For Winner = 0 To 2
                    If DaughterSeq = Relatives(Winner) Then Exit For
                Next Winner
                
                If Winner < 3 Then
                    GoOn = 0
                    BPos2 = XoverList(x, Y).Beginning
                    EPos2 = XoverList(x, Y).Ending
                        
                    If BPos2 > EPos2 Then
                        EPos2 = Len(StrainSeq(0)) + EPos2
                    End If
                        
                    SubM = Int((EPos2 - BPos2) / 10)
                        
                    If SubM > 50 Then
                        BPos2 = BPos2 + 50
                        EPos2 = EPos2 - 50
                    Else
                        BPos2 = BPos2 + SubM
                        EPos2 = EPos2 - SubM
                    End If
                        
                    If BPos2 > Len(StrainSeq(0)) Then BPos2 = BPos2 - Len(StrainSeq(0))
                    If EPos2 > Len(StrainSeq(0)) Then EPos2 = EPos2 - Len(StrainSeq(0))
                        
                    If BPos2 < EPos2 Then
                        For Z = BPos2 To EPos2
                            If TempLen2(Z) = 1 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Z
                    Else
                        For Z = BPos2 To Len(StrainSeq(0))
                            If TempLen2(Z) = 1 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Z
                        If GoOn = 0 Then
                            For Z = 1 To EPos2
                                If TempLen2(Z) = 1 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next Z
                        End If
                    End If
                End If
                    
                If GoOn = 1 Then
                    'Group these events
                    DoneOne(x, Y) = 1
                    TotSorted = TotSorted + 1
                    If Winner > 0 Then
                    'ie things need to be shuffled around a bit
                        Call SwapDaughter(Winner, 0, x, Y, Relatives())
                        Call CompressList(x, Y, XoverList(), CurrentXOver())
                        If XOverListSize > UBound(DoneOne, 2) Then
                            ReDim Preserve DoneOne(NextNo, XOverListSize)
                        End If
                        DoneOne(x, Y) = 0
                        DoneOne(DaughterSeq, CurrentXOver(DaughterSeq)) = 1
                        
                        If CurrentXOver(x) > 1 And Y < CurrentXOver(x) Then
                            Y = Y - 1
                        Else
                            x = x
                        End If
                    End If
                        
                End If
                    
            End If
        Next Y
        
    Next x
  '  zzz = 0
  '  For X = 0 To Nextno
  '      zzz = zzz + CurrentXover(X)
  '  Next X
  '  If zzz <> TotTarget Then
  '      X = X
  '  End If
    SS = Abs(GetTickCount)
    If SS - LS > 500 Then
        LS = SS
        Form1.ProgressBar1.Value = (TotSorted / TotTarget) * 30
        Form1.SSPanel1.Caption = Trim(Str(TotSorted)) & " of " & Trim(Str(TotTarget)) & " Hits Sorted"
        Call UpdateF2Prog
    End If
    
Loop
End Sub
Public Sub CompressList(x, Y, XoverList() As XOverDefine, CurrentXOver() As Integer)

If Y > CurrentXOver(x) Then
    XoverList(x, CurrentXOver(x)).Probability = 0
    CurrentXOver(x) = CurrentXOver(x) - 1
ElseIf CurrentXOver(x) > 0 Then
    XoverList(x, Y) = XoverList(x, CurrentXOver(x))
    XoverList(x, CurrentXOver(x)).Probability = 0
    CurrentXOver(x) = CurrentXOver(x) - 1
                        
End If
End Sub
Public Sub SwapDaughter(Y, SortFlag, ChangeX, ChangeY, SeqNumb() As Long)

If Y = 1 Then
    Z = 2
Else
    Z = 1
End If
                    
'the actual daughter is

Call UpdateXOList(SeqNumb(Y), CurrentXOver(), XoverList())

XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))) = XoverList(ChangeX, ChangeY)

XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).Daughter = SeqNumb(Y) 'XOverList(changex, changey).MinorP


If Y = 1 Then
    XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP = SeqNumb(Z) 'XOverList(changex, changey).Daughter
    XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP = SeqNumb(0)
'XXXZZZ      XOverlist(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).TreePos(1) = XOverlist(ChangeX, ChangeY).TreePos(0)
'XXXZZZ      XOverlist(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).TreePos(2) = XOverlist(ChangeX, ChangeY).TreePos(Z)
Else
    XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP = SeqNumb(0) 'XOverList(changex, changey).Daughter
    XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP = SeqNumb(Z)
'XXXZZZ      XOverlist(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).TreePos(1) = XOverlist(ChangeX, ChangeY).TreePos(Z)
'XXXZZZ      XOverlist(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).TreePos(2) = XOverlist(ChangeX, ChangeY).TreePos(0)
End If

D = x
Outer1 = 0


If XoverList(ChangeX, ChangeY).MissIdentifyFlag = 1 Then
    If Distance(SeqNumb(Y), SeqNumb(Z)) > (Distance(SeqNumb(Y), SeqNumb(0)) + Distance(SeqNumb(Z), SeqNumb(0))) / 2 Then
        Outer1 = 1
    End If
End If
                    
If XoverList(ChangeX, ChangeY).OutsideFlag = 0 Then
    If XoverList(ChangeX, ChangeY).MissIdentifyFlag = 0 Then
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
    ElseIf XoverList(ChangeX, ChangeY).MissIdentifyFlag = 1 Then
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = XoverList(ChangeX, ChangeY).OutsideFlag
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = 1
    ElseIf XoverList(ChangeX, ChangeY).MissIdentifyFlag = 2 Then
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = 2
    End If
ElseIf XoverList(ChangeX, ChangeY).OutsideFlag = 1 Then
    If XoverList(ChangeX, ChangeY).MissIdentifyFlag = 0 Or XoverList(ChangeX, ChangeY).MissIdentifyFlag = 2 Then
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
        Temp = XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP = XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP = Temp
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = XoverList(ChangeX, ChangeY).MissIdentifyFlag
    ElseIf XoverList(ChangeX, ChangeY).MissIdentifyFlag = 1 Then
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = 1
    End If
ElseIf XoverList(ChangeX, ChangeY).OutsideFlag = 2 Then
    If XoverList(ChangeX, ChangeY).MissIdentifyFlag = 0 Or XoverList(ChangeX, ChangeY).MissIdentifyFlag = 2 Then
        Outer1 = 0
        If Distance(SeqNumb(Y), SeqNumb(Z)) < (Distance(SeqNumb(Y), SeqNumb(0)) + Distance(SeqNumb(Z), SeqNumb(0))) / 2 Then
            Outer1 = 1
        End If
                                    
        If Outer1 = 1 And x = 1233456 Then
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
        Else
            Temp = XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MinorP = XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MajorP = Temp
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 1
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = 1
        End If
    ElseIf XoverList(ChangeX, ChangeY).MissIdentifyFlag = 1 Then
        If Outer1 = 1 Or x = x Then
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 1
        Else
            XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).OutsideFlag = 2
        End If
        XoverList(SeqNumb(Y), CurrentXOver(SeqNumb(Y))).MissIdentifyFlag = 1
    End If
End If
                           
If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If
                
End Sub


Public Sub SetUpEvents()
Dim x As Long, Y As Long, Eventholder As Long
If ExRecFlag = 1 Then
   
    For x = 2 To NextNo
        For Y = 1 To CurrentXOver(x)
            SEventNumber = SEventNumber + 1
           
        Next Y
    Next x
    ReDim SuperEventList(SEventNumber)
     SEventNumber = 0
    For x = 2 To NextNo
        For Y = 1 To CurrentXOver(x)
            SEventNumber = SEventNumber + 1
            SuperEventList(XoverList(x, Y).Eventnumber) = SEventNumber
        Next Y
    Next x
    x = x
'    For x = 0 To SEventNumber
'        SuperEventList(x) = x
'    Next x
    'extrahits
    'daught
    'minorpar
    'majorpar
End If

If LongWindedFlag = 1 And ((ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210)) Then
    If UBound(ExtraHits, 2) > SEventNumber Then
        ReDim Daught(UBound(ExtraHits, 2), NextNo)
    Else
        ReDim Daught(SEventNumber, NextNo)
    End If
    
    If UBound(ExtraHitsMi, 2) > SEventNumber Then
        ReDim MinorPar(UBound(ExtraHitsMi, 2), NextNo)
    Else
        ReDim MinorPar(SEventNumber, NextNo)
    End If
    
    If UBound(ExtraHitsMa, 2) > SEventNumber Then
        ReDim MajorPar(UBound(ExtraHitsMa, 2), NextNo)
    Else
        ReDim MajorPar(SEventNumber, NextNo)
    End If
    'ReDim TrPos(Eventnumber, Nextno * 2, 2), Daught(Eventnumber, Nextno), MinorPar(Eventnumber, Nextno + 1), MajorPar(Eventnumber, Nextno + 1)

    'For X = 0 To Nextno
    '    For Y = 1 To CurrentXover(X)
    '        Eventholder = SuperEventlist(XOverList(X, Y).Eventnumber)
    '        MinorPar(Eventholder, XOverList(X, Y).MinorP) = 1
    '        MajorPar(Eventholder, XOverList(X, Y).MajorP) = 1
    '
    '    Next Y
    'Next X
    'Exit Sub
    'Add extrahits
    For x = 1 To UBound(ExtraHits, 2)
        For Y = 0 To NextNo
            If ExtraHits(Y, x) > 0 Then
                Daught(x, Y) = ExtraHits(Y, x)
            End If
        Next Y
    Next x
    For x = 1 To UBound(ExtraHitsMi, 2)
        For Y = 0 To NextNo
            If ExtraHitsMi(Y, x) > 0 Then
                MinorPar(x, Y) = ExtraHitsMi(Y, x)
            End If
        Next Y
    Next x
    For x = 1 To UBound(ExtraHitsMa, 2)
        For Y = 0 To NextNo
            If ExtraHitsMa(Y, x) > 0 Then
                MajorPar(x, Y) = ExtraHitsMa(Y, x)
            End If
        Next Y
    Next x
    
    Call MakeBestEvent
    
    
Else
    ReDim Daught(Eventnumber, NextNo), MinorPar(Eventnumber, NextNo + 1), MajorPar(Eventnumber, NextNo + 1)
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Eventholder = XoverList(x, Y).Eventnumber
            Daught(Eventholder, x) = 1
            MinorPar(Eventholder, XoverList(x, Y).MinorP) = 1
            MajorPar(Eventholder, XoverList(x, Y).MajorP) = 1
'XXXZZZ              TrPos(Eventholder, XOverlist(X, Y).TreePos(0), 0) = 1
'XXXZZZ              TrPos(Eventholder, XOverlist(X, Y).TreePos(1), 1) = 1
'XXXZZZ              TrPos(Eventholder, XOverlist(X, Y).TreePos(2), 2) = 1
        Next Y
    Next x
    ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1)
    If ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210 Then
        ReDim BestEvent(Eventnumber, 1)
    Else
        ReDim DScores(25, 2, Eventnumber)
        ReDim Steps(4, Eventnumber * 2)
    End If
End If

End Sub

Public Sub FindBestEvent(SEN, Prg)
Dim BestP As Double
BestP = 1
GoOn = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If XoverList(x, Y).Eventnumber > UBound(SuperEventList, 1) Then
            ReDim Preserve SuperEventList(UBound(SuperEventList, 1) + 100)
        End If
        If SuperEventList(XoverList(x, Y).Eventnumber) = SEN And XoverList(x, Y).ProgramFlag = Prg Then
            If BestP > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                BestP = XoverList(x, Y).Probability
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 0) = x
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 1) = Y
                GoOn = 1
            End If
        End If
        
    Next Y
Next x
If GoOn = 0 Then
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).Eventnumber > UBound(SuperEventList, 1) Then
            ReDim Preserve SuperEventList(UBound(SuperEventList, 1) + 100)
            End If
            If SuperEventList(XoverList(x, Y).Eventnumber) = SEN Then
                If BestP > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    BestP = XoverList(x, Y).Probability
                    BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 0) = x
                    BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 1) = Y
                    GoOn = 1
                End If
            End If
            
        Next Y
    Next x
End If
x = x

End Sub

Public Sub Tree2Array(EarlyExitFlag As Byte, NameLen, NumberOfSeqs, LTree, T2Holder() As Byte, TMat2() As Single)
Dim CS As Long, XYP(1) As Long, LowD As Double, TMat2Bak() As Single
Dim MaxCurPos As Long, tMat() As Single, TB(1) As Long, MidNode(2) As Double
Dim DoneNode() As Long, NodeOrder() As Long, RootNode() As Byte, AbBe() As Long, DoneThis() As Long, TempNodeOrder() As Long, NodeLen() As Double, NumDone() As Double
Dim Z As Long, C As Long, Inside As Byte, MD As Double, TallyDist As Double, Done0 As Byte
Dim Y As Long, x As Long, Dummy As Long, NoS As Long
MaxCurPos = NumberOfSeqs * 3 'This was 4
'For X = 0 To LTree
'    T2Holder(X) = T2Holder(X)
'Next X

'SS = Abs(GetTickCount)
'For X = 0 To 5000
ReDim NodeLen(MaxCurPos)
ReDim TempNodeOrder(MaxCurPos)
ReDim NodeOrder(MaxCurPos)
ReDim DoneNode(MaxCurPos)
ReDim RootNode(MaxCurPos, MaxCurPos)
'@
ReDim tMat(NumberOfSeqs, NumberOfSeqs)
ReDim NumDone(MaxCurPos)

NoS = NumberOfSeqs

'Make a matrix of distances within the tree

'       TreeToArray (short int nlen2, int nextno, int treelen, char *sholder, float *tmat,int  *nodeorder, int *donenode, int *tempnodeorder, int *rootnode, double *nodelen, double *numdone){

Dummy = TreeToArrayP(NameLen, NumberOfSeqs, LTree, T2Holder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0))

For x = 0 To NumberOfSeqs
    If TMat2(x, x) <> 0 Then
        TMat2(x, x) = 0
   End If
Next x
    

    
'0.901/4.086
ReDim NumDone(MaxCurPos), DoneThis(MaxCurPos)


'@
For x = 0 To NumberOfSeqs
    For Y = x + 1 To NumberOfSeqs
        TMat2(x, Y) = CLng(TMat2(x, Y) * 100000) / 100000
        TMat2(Y, x) = TMat2(x, Y)
    Next Y
Next x

For x = 0 To UBound(NodeLen, 1)
    NodeLen(x) = CLng(NodeLen(x) * 100000) / 100000
Next x


MD = TreeMidP(MaxCurPos, NumberOfSeqs, NumDone(0), TMat2(0, 0), TB(0), NodeOrder(0), MidNode(0), NodeLen(0))

'@'@
For x = 0 To UBound(NodeLen, 1)
    NodeLen(x) = CLng(NodeLen(x) * 100000) / 100000
Next x

For x = 1 To 2
    MidNode(x) = CLng(MidNode(x) * 100000) / 100000
Next x

'MD = 0.54705

ReDim AbBe(MaxCurPos)

'@
Dummy = UltraTreeDistP(MD, MaxCurPos, NoS, TMat2(0, 0), NumDone(0), DoneThis(0), AbBe(0), NodeOrder(0), MidNode(0), NodeLen(0))


For x = 0 To NumberOfSeqs
    For Y = Y + 1 To NumberOfSeqs
        TMat2(x, Y) = CLng(TMat2(x, Y) * 100000) / 100000
        TMat2(Y, x) = TMat2(x, Y)
    Next Y
Next x

'0.41084


'3.856/4.086
'1.171

'If Eventnumber = 7 Then

ReDim TMat2Bak(NumberOfSeqs, NumberOfSeqs)

'Dummy = MakeTreeArray(NumberOfSeqs, TMat2(0, 0), TMat2Bak(0, 0)) 'this version does not allow ties
'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@

Dummy = MakeTreeArrayXP(NumberOfSeqs, TMat2(0, 0), TMat2Bak(0, 0)) 'this version does allow ties

'If SEventNumber = 9 Then
'XX = TMat2(23, 24)
'X = X
'End If
'4.086/4.086
'1.232/1.232
End Sub

Public Sub MakeTreeSeqs(BPos As Long, Epos As Long)

    Dim UB6 As Long, UB5 As Long, b As Long, A As Long, Z As Long, oDir As String, UB4 As Long, UB3 As Long, UB2 As Long, UB1 As Long, WinX As Long, Dummy As Long, UB As Long, FF As Long, oDirX As String, Y As Long, FragSize As Long, x As Long, ZZ As Long, EN As Long, CTot As Long, MSV(2) As Long
    Dim BPos3 As Long, EPos3 As Long, AvDst As Double, Udst As Double, TraceSeqs() As Long
    Dim Valtot(1) As Long, SCO As Long, ISeqs(2) As Long
    'ScDME = XOverlist(RelX, RelY).Ending: ScDMB = XOverlist(RelX, RelY).Beginning
    
   'XX = FMat(20, 20)
   ' Call ModNextno
    If NextNo = -1 Then Exit Sub
    ISeqs(0) = Seq1
    ISeqs(1) = Seq2
    ISeqs(2) = Seq3
    'Call ModNextno
    If BPos < Epos Then
        SCO = CLng((Epos - BPos) / 2)
    Else
        SCO = CLng((Epos + Len(StrainSeq(0)) - BPos) / 2)
    End If
    If SCO > 20 Then SCO = 20
    If BigFileFlag = 1 Then
        SCO = 5
    End If
    
    If PermNextno > MemPoc Then
        If UBFMat <> NextNo Then
            If UBound(FMat, 1) > 0 Then
                PutFMat
                
            End If
        Else
            If UBound(FMat, 1) = 0 Then
                GetFMat
            End If
        End If
        If UBSMat <> NextNo Then
            If UBound(SMat, 1) > 0 Then
                PutSMat
            End If
        Else
            If UBound(FMat, 1) = 0 Then
                GetSMat
            End If
        End If
        If UBSubValid <> NextNo Then
            If UBound(SubValid, 1) > 0 Then
                PutSubValid
            
            End If
        Else
            If UBound(SubValid, 1) = 0 Then
                GetSubValid
            End If
        End If
        
    End If
    
    'find bestevent
    EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    BPos3 = BPos
    EPos3 = Epos
    ZZ = 0
    
    For x = 0 To 2
        MSV(x) = 0
    Next x
    
   
    'Calculate distance matrix using all sequences
    
    
     
    'now modify iseqs
    Dim BestOL() As Long
    ReDim BestOL(2, 1)
    Dim CTot2 As Long

    'Call ModNextno
    'Call UnModNextno
    
    For x = 0 To NextNo
'    If TreeTrace(X) = 7 Then
'    X = X
'    End If
'        If X = 30 Then
'            X = X
'        End If
'
        If x = Seq1 Or x = Seq2 Or x = Seq3 Or x > PermNextno Then
'            If X = Seq2 Then
'                X = X
'            End If
            If TreeTrace(x) <= UBound(TreeTrace, 1) Then
                If TreeTrace(TreeTrace(x)) = Seq1 Or TreeTrace(TreeTrace(x)) = Seq2 Or TreeTrace(TreeTrace(x)) = Seq3 Then
    '                If TreeTrace(TreeTrace(X)) = 38 Then
    '                    X = X
    '                End If
                    
                    CTot = 0
                    CTot2 = 0
                    FragSize = 0
                    If BPos3 < EPos3 Then
                        FragSize = EPos3 - BPos3 + 1
                        For Y = BPos3 To EPos3
                            If MissingData(Y, x) = 0 Then
                                If SeqNum(Y, x) <> 46 Then
                                    CTot = CTot + 1 ': Exit For
                                End If
                            End If
                        Next Y
                        
    '                    For Y = 0 To Len(StrainSeq(0))
    '                        If MissingData(Y, x) = 0 Then '1-314 = 1, 315-2249=0
    '                            x = x
    '                        End If
    '                    Next Y
                        
                        For Y = EPos3 + 1 To Len(StrainSeq(0))
                            If MissingData(Y, x) = 0 And SeqNum(Y, x) <> 46 Then CTot2 = CTot2 + 1  ': Exit For
                        Next Y
                        
                        For Y = 1 To BPos3 - 1
                            If MissingData(Y, x) = 0 And SeqNum(Y, x) <> 46 Then CTot2 = CTot2 + 1  ': Exit For
                        Next Y
                        x = x
                    Else
                        FragSize = EPos3 + Len(StrainSeq(0)) - BPos3 + 1
                        For Y = EPos3 + 1 To BPos3 - 1
                            If MissingData(Y, x) = 0 And SeqNum(Y, x) <> 46 Then CTot2 = CTot2 + 1  ': Exit For
                        Next Y
                        For Y = BPos3 To Len(StrainSeq(0))
                            If MissingData(Y, x) = 0 And SeqNum(Y, x) <> 46 Then CTot = CTot + 1  ': Exit For
                        Next Y
                        If CTot = 0 Then
                            For Y = 1 To EPos3
                                If MissingData(Y, x) = 0 And SeqNum(Y, x) <> 46 Then CTot = CTot + 1  ': Exit For
                            Next Y
                        End If
                    End If
                    'XX = PermNextno
                    If FragSize = Len(StrainSeq(0)) Then FragSize = Len(StrainSeq(0)) - 1
                    If TreeTrace(TreeTrace(x)) = Seq1 Then '16,
                            If ((BestOL(0, 0) = 0 Or BestOL(0, 1) = 0) And ((CTot / FragSize) * 2 + CTot2 / (Len(StrainSeq(0)) - FragSize)) > ((BestOL(0, 0) / FragSize) * 2 + BestOL(0, 1) / (Len(StrainSeq(0)) - FragSize))) Or (CTot > 0 And CTot2 > 0 And (BestOL(0, 0) < 3 Or BestOL(0, 1) < 3)) Then  'BestOL(2, 0) Then ' And CTot2 > BestOL(2, 1) Then
                                BestOL(0, 0) = CTot '0
                                BestOL(0, 1) = CTot2 '1682
                                ISeqs(0) = x
                            ElseIf BestOL(0, 0) > 0 And BestOL(0, 1) > 0 Then
                                If ((CTot / BestOL(0, 0) * CTot2 / BestOL(0, 1)) > 1) Then
                                    BestOL(0, 0) = CTot
                                    BestOL(0, 1) = CTot2
                                    ISeqs(0) = x
                                End If
                            End If
                    ElseIf TreeTrace(TreeTrace(x)) = Seq2 Then
                            If ((BestOL(1, 0) = 0 Or BestOL(1, 1) = 0) And (((CTot / FragSize) * 2 + CTot2 / (Len(StrainSeq(0)) - FragSize)) > ((BestOL(1, 0) / FragSize) * 2 + BestOL(1, 1) / (Len(StrainSeq(0)) - FragSize)))) Or (CTot > 0 And CTot2 > 0 And (BestOL(1, 0) < 3 Or BestOL(1, 1) < 3)) Then
                                BestOL(1, 0) = CTot '246
                                BestOL(1, 1) = CTot2 '2439
                                ISeqs(1) = x
                            ElseIf BestOL(1, 0) > 0 And BestOL(1, 1) > 0 Then
                                If ((CTot / BestOL(1, 0) * CTot2 / BestOL(1, 1)) > 1) Then
                                    BestOL(1, 0) = CTot
                                    BestOL(1, 1) = CTot2
                                    ISeqs(1) = x
                                End If
                            End If
                    ElseIf TreeTrace(TreeTrace(x)) = Seq3 Then
                            If ((BestOL(2, 0) = 0 Or BestOL(2, 1) = 0) And ((CTot / FragSize) * 2 + CTot2 / (Len(StrainSeq(0)) - FragSize)) > ((BestOL(2, 0) / FragSize) * 2 + BestOL(2, 1) / (Len(StrainSeq(0)) - FragSize))) Or (CTot > 0 And CTot2 > 0 And (BestOL(2, 0) < 3 Or BestOL(2, 1) < 3)) Then   'BestOL(2, 0) Then ' And CTot2 > BestOL(2, 1) Then
                                BestOL(2, 0) = CTot ' 0     246
                                BestOL(2, 1) = CTot2 '1512  926
                                ISeqs(2) = x
                            ElseIf BestOL(2, 0) > 0 And BestOL(2, 1) > 0 Then
                                If ((CTot / BestOL(2, 0) * CTot2 / BestOL(2, 1)) > 1) Then
                                    BestOL(2, 0) = CTot
                                    BestOL(2, 1) = CTot2
                                    ISeqs(2) = x
                                End If
                            End If
                    End If
                End If
            Else
                TreeTrace(x) = x
            End If
        End If
    Next x
    
    Seq1 = ISeqs(0)
    Seq2 = ISeqs(1)
    Seq3 = ISeqs(2)
    '6110
'    If X = 1234567 Then
'        XX = MissingData(6110, 30)
'    End If


    

    If DontLoseSeqsFlag = 1 Then Exit Sub
    '*'*'*Exit Sub
    ISPerm(0) = ISeqs(0)
    ISPerm(1) = ISeqs(1)
    ISPerm(2) = ISeqs(2)
    'XX = SeqNum(1869, ISeqs(0))
    'XX = SeqNum(1866, ISeqs(1))
    'XX = SeqNum(1866, ISeqs(2))
    'XX = UBound(FMat, 1)
    
    'XX = FMat(20, 20)
    
    'XX = Len(StrainSeq(0))
   
    'It may be necessary no temporarily modify the minseqsize if the region is very small
    Dim oMinSeqSize As Long
    oMinSeqSize = MinSeqSize
    For x = 0 To 2
        For Y = 0 To 1
            If MinSeqSize > BestOL(x, Y) Then
                MinSeqSize = BestOL(x, Y)
            End If
        Next Y
    Next x
    
    
    If FubValidInFile = 1 Then
            
        '@
        ReDim FubValid(FVL, FVL)
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5FVFile" + UFTag For Binary As #FF
        '@
        Get #FF, , FubValid
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
    
    End If
    'MinSize = MinSize * 0.5
    'XX = FMat(20, 20)
    Call CheckMatrixY(NextNo, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), FubValid(), SubValid(), FMat(), SMat())
    'XX = FMat(20, 20)
    
    MinSeqSize = oMinSeqSize
    
    
    
    
    If FubValidInFile = 1 Then
        ReDim FubValid(0, 0)
    End If
    
    
    Dim ExtraRemove() As Long, MaxRemove As Long
    
    'For X = 0 To Nextno
    '    If SAMat(54, X) < 1 Then
    '        X = X
    '    End If
    'Next X
'    For x = 0 To Len(StrainSeq(0))
'        If SeqNum(x, 378) > 50 Then
'            x = x
'        End If
'    Next x
   ' XX = FMat(378, 378)

    If NextNo = -1 Then NextNo = PermNextno
    ReDim ExtraRemove(NextNo)
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SMat, 1)
    
    On Error GoTo 0
    Dim UBTT As Long
    UBTT = UBound(TreeTrace, 1)
    If NextNo > 1000 Then
        For x = 0 To NextNo
            If x <= UBTT Then
                If Daught(EN, TreeTrace(x)) = 0 And MaskSeq(TreeTrace(x)) > 0 And Seq1 <> TreeTrace(x) And Seq2 <> TreeTrace(x) And Seq3 <> TreeTrace(x) Then
                    FMat(x, x) = 3
                    SMat(x, x) = 3
                End If
            End If
        Next x
    End If
    
    '*'*'*Exit Sub
    
    
    
    
    'If X = X And UB > 0 Then
        '@
        SS = Abs(GetTickCount)
'        Tot = 0
'        For X = 0 To Nextno
'            If FMat(X, X) >= 3 Or SMat(X, X) >= 3 Then
'                Tot = Tot + 1 '694
'            End If
'        Next X
        'for some reason this can take a VERY long time - there must be a quicker way of doing it.
        
'        If UBound(FMat, 1) <> UBound(SMat, 1) Or UBound(FMat, 2) <> UBound(SMat, 2) Or UBound(FMat, 1) <> Nextno Or UBound(SMat, 1) <> Nextno Or UBound(ExtraRemove, 1) <> Nextno Or UBound(ISeqs) < 2 Then
'            X = X
'        End If

'If UBound(FMat, 1) <> NextNo Or UBound(FMat, 2) <> NextNo Or UBound(SMat, 2) <> NextNo Or UBound(SMat, 1) <> NextNo Then
'    x = x
'End If
 '       Exit Sub
        Dummy = ExtraRemovals2(NextNo, UBound(FMat, 1), UBound(SMat, 1), ISeqs(0), ExtraRemove(0), FMat(0, 0), SMat(0, 0))
         Tot = 0
         
         
        ' Exit Sub
         
'        For X = 0 To Nextno
'            If FMat(X, X) >= 3 Or SMat(X, X) >= 3 Then
'                Tot = Tot + 1 '1720
'            End If
'        Next X
        
        EE = Abs(GetTickCount)
        TT = EE - SS '85.531'89.328 with p version'37.234 reorientating the array, 0.125 not fully recalculating extraremove
        x = x
        'Dummy = ExtraRemovalsp(Nextno, UBound(FMat, 1), UBound(SMat, 1), ISeqs(0), ExtraRemove(0), FMat(0, 0), SMat(0, 0))
x = x
'    Else
'        Do
'            For X = 0 To Nextno
'                ExtraRemove(X) = 0
'            Next X
'            For X = 0 To Nextno
'
'                    If FMat(X, X) < 3 Then
'                        For Y = X + 1 To Nextno
'                            If FMat(Y, Y) < 3 Then
'                                If FMat(X, Y) >= 3 Then
'                                    'Redo = 1
'                                    ExtraRemove(X) = ExtraRemove(X) + 1
'                                    ExtraRemove(Y) = ExtraRemove(Y) + 1
'                                End If
'                                If UB > 0 Then
'                                    If SMat(X, Y) >= 3 Then
'                                        'Redo = 1
'                                        ExtraRemove(X) = ExtraRemove(X) + 1
'                                        ExtraRemove(Y) = ExtraRemove(Y) + 1
'                                    End If
'                                End If
'                            End If
'                        Next Y
'                    End If
'
'            Next X
'
'            MaxRemove = 0
'
'            WinX = -1
'            For X = 0 To Nextno
'                If ExtraRemove(X) > MaxRemove Then
'                    If (X <> ISeqs(0) And X <> ISeqs(1) And X <> ISeqs(2)) Then
'
'                           MaxRemove = ExtraRemove(X)
'                           WinX = X
'
'                    End If
'
'                End If
'            Next X
'            If WinX = -1 Then Exit Do
'
'            If MaxRemove > 0 Then
'                FMat(WinX, WinX) = 3
'                If UB > 0 Then
'                    SMat(WinX, WinX) = 3
'                End If
'            End If
'
'        Loop
'    End If

    '6.984,4.047, 3.563,3.532, 3.407,2.438

    
    Dim BFMat() As Single
    '@
    ReDim BFMat(NextNo, NextNo)
    
    UB1 = UBound(FMat, 1): UB2 = UBound(FMat, 2): UB3 = UBound(BFMat, 1): UB4 = UBound(BFMat, 2)
   
    Dummy = CopySingleArray(NextNo, NextNo, UB1, UB2, UB3, UB4, FMat(0, 0), BFMat(0, 0))
 
   
    'Exit Sub
    If PermNextno < NextNo Then
        ReDim TreeTraceSeqs(1, NextNo)
    Else
        ReDim TreeTraceSeqs(1, PermNextno)
    End If
    TreeNextno = -1
    For x = 0 To PermNextno
        TreeTraceSeqs(1, x) = x
    Next x
    
    For x = 0 To NextNo
        
        If FMat(x, x) <> 3 Then
            TreeNextno = TreeNextno + 1
            
            TreeTraceSeqs(0, x) = TreeNextno
            TreeTraceSeqs(1, TreeNextno) = x
            
        Else
            TreeTraceSeqs(0, x) = NextNo
            TreeTraceSeqs(1, NextNo) = x
            'XX = OriginalName(72)
        End If
    Next x
    x = x
'    If TreeNextno > 1000 Then
'        If PermNextno < Nextno Then
'            ReDim TreeTraceSeqs(1, Nextno)
'        Else
'            ReDim TreeTraceSeqs(1, PermNextno)
'        End If
'        TreeNextno = -1
'        For X = 0 To PermNextno
'            TreeTraceSeqs(1, X) = X
'        Next X
'        For X = 0 To Nextno
'
'            If FMat(X, X) <> 3 And (Maskseq(X) = 0 Or X = Seq1 Or X = Seq3 Or X = Seq2) Then
'                TreeNextno = TreeNextno + 1
'                TreeTraceSeqs(0, X) = TreeNextno
'                TreeTraceSeqs(1, TreeNextno) = X
'            Else
'                FMat(X, X) = 3
'                TreeTraceSeqs(0, X) = Nextno
'                TreeTraceSeqs(1, Nextno) = X
'                'XX = OriginalName(72)
'            End If
'        Next X
'    End If
    
    
    'XX = TreeTrace(33)
    If TreeNextno = -1 Then
        'replace vals in fmat with those in bfmat
        For x = 0 To NextNo
            
            For Y = 0 To NextNo
                FMat(x, Y) = BFMat(x, Y)
            Next Y
        Next x
        If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(SubValid, 1)
        
        
        
        On Error GoTo 0
        If UB = 0 Then
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            FF = FreeFile
            ReDim SubValid(PermNextno, PermNextno)
            
            Open "RDP5SubValid" + UFTag For Binary As #FF
            Get #FF, , SubValid()
            Close #FF
                
            ChDir oDir
            ChDrive oDir
        End If
        
        If FubValidInFile = 1 Then
            
            FubValidInFile = 1
            ReDim FubValid(FVL, FVL)
            
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5FVFile" + UFTag For Binary As #FF
            Get #FF, , FubValid
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
        
        End If
        
        For x = 0 To NextNo
            For Y = 0 To 2
                If x <> ISeqs(Y) Then
                    If ISeqs(Y) <= UBound(SubValid, 2) Then
                        If SubValid(x, ISeqs(Y)) = 0 Or FubValid(x, ISeqs(Y)) = 0 Then
                            For Z = 0 To NextNo
                                FMat(x, Z) = 3#
                                SMat(x, Z) = 3#
                            Next Z
                            
                        Else
                            x = x
                        End If
                    Else
                        For Z = 0 To NextNo
                            FMat(x, Z) = 3#
                            SMat(x, Z) = 3#
                        Next Z
                    End If
                End If
            Next Y
        Next x
        
        TreeNextno = -1
        For x = 0 To NextNo
            If FMat(x, x) <> 3 Then
                TreeNextno = TreeNextno + 1
                
                TreeTraceSeqs(0, x) = TreeNextno
                TreeTraceSeqs(1, TreeNextno) = x
            Else
                TreeTraceSeqs(0, x) = NextNo
                TreeTraceSeqs(1, NextNo) = x
            End If
        Next x
    End If
    
    Erase BFMat
    
    
    
    
    
    'redim SubValid(0,0)
    
    If TreeNextno = -1 Then Exit Sub
    
    If TreeNextno > 1000 Then
        If TreeNextno > 1000 Then
            TreeMatrixInFileFLag = 1
        End If
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        UBTreeMatrix = TreeNextno
        
        
        
         If DebuggingFlag < 2 Then On Error Resume Next
         UB4 = -1
         UB4 = UBound(SMat, 1)
         On Error GoTo 0
         
        
        FF = FreeFile
        'do treeseqnum first
        '
        ReDim TreeSeqNum(Len(StrainSeq(0)), TreeNextno)
        A = 0: b = 0
        
        For x = 0 To NextNo
             If FMat(x, x) <> 3 Then
                 Dummy = CopySeqs(Len(StrainSeq(0)), 0, SeqNum(0, x), TreeSeqNum(0, A))
                 A = A + 1
             End If
         Next x
        
        
        'then treematrix
        ReDim TreeMatrix(TreeNextno, TreeNextno)

'        If X = X Then
            
            Dummy = MakeTreeMatrix(NextNo, UBound(FMat, 1), UBound(Distance, 1), UBound(TreeMatrix), FMat(0, 0), TreeMatrix(0, 0), Distance(0, 0))
        
'        Else
'            A = 0: B = 0
'            For X = 0 To Nextno
'                 If FMat(X, X) <> 3 Then
'                    B = A + 1
'                    For Y = X + 1 To Nextno
'                        If FMat(Y, Y) <> 3 Then
'                            TreeMatrix(A, B) = 1 - Distance(X, Y)
'                            TreeMatrix(B, A) = TreeMatrix(A, B)
'                            B = B + 1
'                        End If
'                    Next Y
'                    A = A + 1
'                 End If
'             Next X
'        End If

        If TreeNextno > 1000 Then
            Open "RDP5TreeMatrix" + UFTag For Binary As #FF
            Put #FF, , TreeMatrix()
            Close #FF
            Erase TreeMatrix
        End If
        
        'then treefmat
        ReDim TreeFMat(TreeNextno, TreeNextno)

        
        'If X = X Then
            Dummy = MakeTreeFMat(NextNo, UBound(FMat, 1), UBound(TreeFMat), FMat(0, 0), TreeFMat(0, 0))
'        Else
'            A = 0: B = 0
'
'
'            For X = 0 To Nextno
'
'                 If FMat(X, X) <> 3 Then
'                    'A = A + 1
'                     TreeFMat(A, A) = 0
'                     If UB4 > 0 Then
'                         B = A + 1
'                         For Y = X + 1 To Nextno
'                             If FMat(Y, Y) <> 3 Then
'                                 TreeFMat(A, B) = FMat(X, Y)
'                                 TreeFMat(B, A) = TreeFMat(A, B)
'                                 B = B + 1
'                             End If
'                         Next Y
'                     End If
'                     A = A + 1
'                 End If
'             Next X
'         End If
'         EE = Abs(GetTickCount)
'         TT = EE - SS
'         X = X '0.624
        '@
        If TreeNextno > 1000 Then
            Open "RDP5TreeFMat" + UFTag For Binary As #FF
            Put #FF, , TreeFMat()
            Close #FF
            Erase TreeFMat
        End If
        'then treesmat
        ReDim TreeSMat(TreeNextno, TreeNextno)
        
'        If X = X Then
            ''
            Dummy = MakeTreeSMat(NextNo, UB4, UBound(FMat, 1), UBound(TreeSMat, 1), FMat(0, 0), TreeSMat(0, 0), SMat(0, 0))
           ' XX = TreeSMat(1017, 1019)
'        Else
'            A = 0: B = 0
'            For X = 0 To Nextno
'
'                 If FMat(X, X) <> 3 Then
'                     TreeSMat(A, A) = 0
'
'
'                     If UB4 > 0 Then
'                         'If LowMemThreshold >= PermNextno Then
'                         B = A + 1
'                         For Y = X + 1 To Nextno
'                             If FMat(Y, Y) <> 3 Then
'
'                                 If UB4 > 0 Then
'                                     TreeSMat(A, B) = SMat(X, Y)
'                                     TreeSMat(B, A) = TreeSMat(A, B)
'                                 Else
'                                     TreeSMat(A, B) = FMat(X, Y)
'                                     TreeSMat(B, A) = TreeSMat(A, B)
'                                 End If
'                                 B = B + 1
'                             End If
'
'                         Next Y
'                     End If
'                     A = A + 1
'                 Else
'                     FMat(X, X) = 0
'                     If UB4 > 0 Then
'                         SMat(X, X) = 0
'                     End If
'                 End If
'             Next X
'         End If
'          EE = Abs(GetTickCount)
'         TT = EE - SS '0.671
'         X = X '0.484
         
         If TreeNextno > 1000 Then
            Open "RDP5TreeSMat" + UFTag For Binary As #FF
            Put #FF, , TreeSMat()
            Close #FF
            Erase TreeSMat
        End If
        ChDrive oDirX
        ChDir oDirX
    
    
    Else
         TreeMatrixInFileFLag = 0
         ReDim TreeSeqNum(Len(StrainSeq(0)), TreeNextno), TreeMatrix(TreeNextno, TreeNextno), TreeFMat(TreeNextno, TreeNextno), TreeSMat(TreeNextno, TreeNextno)
         
         A = 0
         b = 0
         
         
         
         
         'Dummy = CopySeqs(Len(StrainSeq(0)), NextNo, TreeSeqNum(0, 0), SeqNum(0, 0))
         
         
         'TreeFMat, double *TreeSMat, double *FMat, double *SMat,double *TreeMatrix, double *Distance
         
         
         If x = x Then
             UB1 = UBound(TreeFMat, 1)
             UB2 = UBound(TreeSMat, 1)
             UB3 = UBound(FMat, 1)
             If DebuggingFlag < 2 Then On Error Resume Next
             UB4 = 0
             UB4 = UBound(SMat, 1)
             On Error GoTo 0
             UB5 = UBound(TreeMatrix, 1)
             UB6 = UBound(Distance, 1)
             Dim UB7 As Long
             UB7 = UBound(SeqNum, 2)
             If UB7 < NextNo Then
                UnModNextno
             End If
            
            ' XX = UBound(TreeSeqNum, 2)
            ' XX = UBound(SeqNum, 2)
             For x = 0 To NextNo
                 
                 If FMat(x, x) <> 3 Then
                     TreeFMat(A, A) = 0
                     TreeSMat(A, A) = 0
                     
                     Dummy = CopySeqs(Len(StrainSeq(0)), 0, SeqNum(0, x), TreeSeqNum(0, A))
                     
                     
                     
                     
                     If UB4 > 0 And UB5 <= NextNo And UB6 <= NextNo And x = x Then
                         'If LowMemThreshold >= PermNextno Then
                         
                             Dummy = UpdateDistArrays(NextNo, x, A, UB1, UB2, UB3, UB4, UB5, UB6, TreeFMat(0, 0), TreeSMat(0, 0), FMat(0, 0), SMat(0, 0), TreeMatrix(0, 0), Distance(0, 0))
                         'End If
             
                     Else
                         b = A + 1
                         For Y = x + 1 To NextNo
                             If FMat(Y, Y) <> 3 And FMat(x, x) <> 3 Then
                                 
                                 TreeMatrix(A, b) = 1 - Distance(x, Y)
                                 TreeMatrix(b, A) = 1 - Distance(x, Y)
                                 TreeFMat(A, b) = FMat(x, Y)
                                 
                                 TreeFMat(b, A) = FMat(x, Y)
                                 If UB4 > 0 Then
                                     TreeSMat(A, b) = SMat(x, Y)
                                     TreeSMat(b, A) = SMat(x, Y)
                                 Else
                                     TreeSMat(A, b) = FMat(x, Y)
                                     TreeSMat(b, A) = FMat(x, Y)
                                 End If
                                 b = b + 1
                             End If
                             
                         Next Y
                     End If
                     A = A + 1
                 Else
                     FMat(x, x) = 0
                     If UB4 > 0 Then
                         SMat(x, x) = 0
                     End If
                 End If
             Next x
         End If
    End If
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    If PermNextno > MemPoc Then
        ReDim FMat(0, 0)
        ReDim SMat(0, 0)
        ReDim SubValid(0, 0)
    End If
    
End Sub
Public Sub MakeSFMats(NextNo As Long, BPos3 As Long, EPos3 As Long, FMat() As Single, SMat() As Single, SubValid() As Single, SubDiffs() As Single, PermValid() As Single, PermDIffs() As Single, SeqNum() As Integer, RedoDist() As Integer)
        
        Dim FF As Long, oDirX As String, x As Long, D2() As Double, UB As Long, Dummy As Long, StartVal As Long, TargetVal As Long
        Dim Fubdiffs() As Single, PermValidx() As Single, PermDiffsx() As Single
        Dim ISeqs(2) As Long
        
        UB = UBound(PermValid, 1)
        ISeqs(0) = TreeTrace(Seq1)
        ISeqs(1) = TreeTrace(Seq2)
        ISeqs(2) = TreeTrace(Seq3)
        If UB <> NextNo Then
            ReDim PermValidx(NextNo, NextNo), PermDiffsx(NextNo, NextNo)
'            If X = X Then
               Dummy = CopySingleDist(UB, UBound(PermValidx, 2), UBound(PermValid, 1), PermValidx(0, 0), PermValid(0, 0), PermDiffsx(0, 0), PermDIffs(0, 0))
'            Else
'                For X = 0 To UB
'                    For Y = 0 To UB
'                        PermValidx(X, Y) = PermValid(X, Y)
'                        PermDiffsx(X, Y) = PermDiffs(X, Y)
'                    Next Y
'                Next X
'            End If
            ReDim PermValid(NextNo, NextNo), PermDIffs(NextNo, NextNo)
            Dummy = CopySingleDist(NextNo, UBound(PermValid, 2), UBound(PermValidx, 1), PermValid(0, 0), PermValidx(0, 0), PermDIffs(0, 0), PermDiffsx(0, 0))
            
            
            Call MakeSmallArrays(ISeqs(), PermValid(), PermValidSmall())
            Call MakeSmallArrays(ISeqs(), PermDIffs(), PermDiffsSmall())
            
            Erase PermDiffsx
            Erase PermValidx

        End If
        
        
        

        StartVal = Form1.ProgressBar1
        
        If StartVal < 75 Then
            TargetVal = StartVal + 25
        Else
            TargetVal = StartVal + (100 - StartVal) / 2
        End If
        If UpdateProgressBar = 0 Then
            Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.4
        End If
       If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = "Calculating first distance matrix"
       Call UpdateF2Prog
       Dim tRedoDist() As Integer
       ReDim tRedoDist(NextNo)
       
       ReDim SMat(NextNo, NextNo), SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo)

       
       
       For x = 0 To NextNo
             If RedoDist(x) <> -1 Then
                 tRedoDist(x) = 1
             Else
                 tRedoDist(x) = -1 'only leave out the redodosts that are really low
             End If
        Next x
       
       Call FastDistanceCalcZ(1, 0, BPos3, EPos3, NextNo, SubDiffs(), SubValid(), SeqNum(), SMat(), AvDst, Udst, tRedoDist())
        
        
        
        Call MakeSmallArrays(ISeqs(), SubDiffs(), SubDiffsSmall())
        Call MakeSmallArrays(ISeqs(), SubValid(), SubValidSmall())


'
'       EE = Abs(GetTickCount)
'       TT = EE - SS
       '7.16'4.165 with distancecalcx, 3.557 distancecalcz
       

       If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = "Calculating second distance matrix"
       If UpdateProgressBar = 0 Then
            Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.8
       End If
       Call UpdateF2Prog
       If x = x Then
            Dim BPos4 As Long, EPos4 As Long
            
            If BPos3 > 1 Then
                 EPos4 = BPos3 - 1
            Else
                 EPos4 = Len(StrainSeq(0))
            End If
       
       
            If EPos3 < Len(StrainSeq(0)) Then
                 BPos4 = EPos3 + 1
            Else
                 BPos4 = 1
            End If
            ReDim tRedoDist(NextNo)
            
            For x = 0 To NextNo
                
                tRedoDist(x) = RedoDist(x)
                 
            Next x
            '
            ReDim FubValid(NextNo, NextNo), Fubdiffs(NextNo, NextNo), FMat(NextNo, NextNo)
            '
            Call FastDistanceCalcZ(1, 0, BPos4, EPos4, NextNo, Fubdiffs(), FubValid(), SeqNum(), FMat(), AvDst, Udst, tRedoDist())
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            
       End If
       

       '959
         
            'I make have to split this up into two parts to conserve memory - it takes 9 nextno x nextno arrays!!!
        'Dummy = ConvSimToDist(Len(StrainSeq(0)), Nextno, UBound(Distance, 1), UBound(PermValid, 1), UBound(FubValid, 1), UBound(SubValid, 1), tRedoDist(0), Distance(0, 0), FMat(0, 0), SMat(0, 0), PermValid(0, 0), PermDiffs(0, 0), FubValid(0, 0), Fubdiffs(0, 0), SubValid(0, 0), SubDiffs(0, 0))
        '@
        Dummy = ConvSimToDistP(Len(StrainSeq(0)), NextNo, UBound(Distance, 1), UBound(PermValid, 1), UBound(FubValid, 1), UBound(SubValid, 1), tRedoDist(0), Distance(0, 0), FMat(0, 0), SMat(0, 0), PermValid(0, 0), PermDIffs(0, 0), FubValid(0, 0), Fubdiffs(0, 0), SubValid(0, 0), SubDiffs(0, 0))
        Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())
        Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
        
'        For x = 0 To Nextno
'            For Y = 0 To Nextno
'                If FMat(x, Y) <> 0 Then
'                    x = x
'                End If
'            Next Y
'
'        Next x
        If PermNextno > MemPoc Then
            PutSMat
            PutFMat
        End If
        'Fred event 2 dnadll version 484,515
        'p version 500,500
        'parallelised version 187
        x = x
'
'XX = SubValid(19, 9) '0
'      XX = FubValid(19, 9) '4451
'      XX = PermValid(19, 9) '9412
            
       
        
        
        'dont need to do this here - its done in maketreeseqs
        
'       If Nextno > 1000 Then
'            For X = 0 To Nextno
'                Y = TreeTrace(X)
'                If Maskseq(Y) > 0 And Y <> TreeTrace(Seq1) And Y <> TreeTrace(Seq2) And Y <> TreeTrace(Seq3) Then
'                    'RedoDist(X) = 0
'                    'FMat(X, X) = 3
'                End If
'            Next X
'       End If
        
        If (NextNo * NextNo * 4) > 1000000 Then
            If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = "Writing data to disk"
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            
            '****************************
            'Better to read just single value from the file
            '*******************************
            FubValidInFile = 1
            FVL = UBound(FubValid, 1)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5FVFile" + UFTag For Binary As #FF
            '@
            Put #FF, , FubValid
            
            Close #FF
            ReDim FubValid(0, 0)
'            Open "SVFile" For Binary As #FF
'            Put #FF, , SubValid
'            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            FubValidInFile = 0
        End If
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
       
        'XX = SubValid(22, 7)
        
        'XX = Fubvalid(17, 0)
        


End Sub

Public Sub ModNextno()
Dim UB As Long, x As Long
If SEventNumber = 0 Then Exit Sub
NextNo = TreeNextno
If UBound(OriginalName, 1) < NextNo Then
    ReDim Preserve OriginalName(NextNo)
End If
UB = UBound(TreeStrainName, 1)

If UB < NextNo Then
    For x = 0 To UB
        If TreeStrainName(x) <> "" Then
        
        
            OriginalName(x) = TreeStrainName(x)
        End If
       
    Next x
Else
    For x = 0 To NextNo
        If TreeStrainName(x) <> "" Then
            OriginalName(x) = TreeStrainName(x)
        End If
    Next x
End If

'ModNextnoFlag = 1

End Sub
Public Sub UnModNextno()
'If SEventNumber = 0 Then Exit Sub
'If ModNextnoFlag = 0 Then Exit Sub
Dim x As Long, oDir As String, FF As Long
NextNo = PermNextno
'If UBound(PermOriginalName, 1) <> Nextno Then
'    Exit Sub
'End If

If DebuggingFlag < 2 Then On Error Resume Next
If UBound(OriginalName, 1) < NextNo Then
    ReDim Preserve OriginalName(NextNo)
    ReDim Preserve PermOriginalName(NextNo)
End If

If UBound(PermOriginalName, 1) >= NextNo Then
    For x = 0 To NextNo
       OriginalName(x) = PermOriginalName(x)
    Next x
Else
    Exit Sub
End If
'XX = OriginalName(0)
''''''
ReDim Distance(PermNextno, PermNextno)
oDir = CurDir
ChDir App.Path
ChDrive App.Path
FF = FreeFile
'@
Open "RDP5PermDistance" + UFTag For Binary As #FF
''''
Get #FF, , Distance()

Close #FF
ChDir oDir
ChDrive oDir

ModNextnoFlag = 0

On Error GoTo 0
End Sub


Public Sub FilterSteps()
'this gets rid of unnecessary sequence creation and deletion steps
Dim tStepno As Long, tSteps() As Long, EN As Long, MarkForRemoval() As Byte, x As Long, Y As Long, NNo As Long
Exit Sub 'this subrutine fucks things up whenever steps gets a bit complicated.
ReDim tSteps(4, StepNo), MarkForRemoval(StepNo)


On Error GoTo 0
NNo = PermNextno
XXX = Steps(1, 4457)
'4457 = 159????
For x = 0 To StepNo
    If Steps(0, x) = 1 Then
        'check if the created sequence with the same EN is removed
        NNo = NNo + 1
        EN = Steps(4, x)
        For Y = x + 1 To StepNo
            If Steps(4, Y) = EN Then
                If Steps(0, Y) = 3 Then
                    If Steps(1, Y) = NNo Then
                        MarkForRemoval(x) = 1
                        MarkForRemoval(Y) = 1
                        Exit For
                    End If
                End If
            Else
                Exit For
            End If
            
        Next Y
    ElseIf Steps(0, x) = 3 Then
        NNo = NNo - 1
    ElseIf Steps(0, x) = 4 Then
    x = x
    End If


Next x

tStepno = -1
For x = 0 To StepNo
    If MarkForRemoval(x) = 0 Then
        tStepno = tStepno + 1
        For Y = 0 To 4
            tSteps(Y, tStepno) = Steps(Y, x)
        Next Y
    End If
    
Next x

ReDim Steps(4, tStepno + 50)
StepNo = tStepno
For x = 0 To StepNo
    For Y = 0 To 4
        Steps(Y, x) = tSteps(Y, x)
    Next Y
Next x


End Sub

Public Sub ModSeqNum(BPos, Epos, SPF)
Dim ReplaceDistsFlag As Long, x As Long, Y As Long, EN As Long, UB As Long, Dummy As Long, ZZ As Long, GoOn As Long, UBU As Long, oDir As String, FF As Long, SE As Long, oDirX As String, UBX As Long

Dim IntTD() As Integer, MaxDist As Single, MaxTDist As Single

If SPF = 0 Then
    Form1.SSPanel1.Caption = "Setting up scan"
End If


ModSeqNumFlag = 1
If NextNo <> PermNextno Then
    Call UnModNextno
    Call UnModSeqNum(0)
End If

ModSNE = Epos: ModSNB = BPos
If NextNo = -1 Then
    Exit Sub
End If
'if editseqflag = 0 then bits get deleted from sequences with events lower than the cirrent event  - these edits get stored in backups
'if editseqflag = 1 then the arrays are replaced with the backed up edits
If EditSeqFlag = 0 Then 'Or AllCheckFlag = 1 Then '**************************************************
    '710
    'ModSeqNumFlag = 1 'i.e. the sequences were reedited
    ReDim MissingData(Len(StrainSeq(0)), NextNo), TreeTrace(NextNo)
    '710
    If ReassortmentFlag = 1 Then 'adds missing data to bounds of segments
        Dim tBP As Long
        If UBound(RBPPos, 1) < RBPNum Then
            ReDim Preserve RBPPos(RBPNum)
        End If
        For x = 0 To RBPNum
            If RBPPos(x) > Len(StrainSeq(0)) Then
                RBPPos(x) = Len(StrainSeq(0))
            End If
            tBP = RBPPos(x)
            For Y = 0 To NextNo
                MissingData(tBP, Y) = 1
            Next Y
        Next x
    End If
    
    For x = 0 To NextNo
        TreeTrace(x) = x
    Next x
    Dim tNextno As Long
    
    If DebuggingFlag < 2 Then On Error Resume Next
        EN = -1
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
   
    If SPF = 0 Then Form1.SSPanel1.Caption = "Rebuilding sequences"
    ReDim RedoDist(NextNo + 100)
    
    If (RelX > 0 Or RelY > 0) And EN > 0 Then
        
        
        ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + 1)
        
        '710
        oNextno = NextNo
        
        
        
        
        ReDim S2TraceBack(NextNo)
        
        Dim ExcludeExempt As Byte
        ExcludeExempt = 0
        For x = 0 To NextNo
            S2TraceBack(x) = x
        Next x
        For x = 0 To 255
            Close #x
        Next x
        Dim TELong As Long, TEString As String, SSBak() As Long, PSeq As Long, IntoSomeExtras As Byte
        
        ReDim SSBak(Len(StrainSeq(0)))
        Dim UBS2 As Long
        UBS2 = UBound(Steps, 2)
        'XX = UBound(MissingData, 2)
        IntoSomeExtras = 0
        
        XX = PermNextno
        XX = NextNo
        ReDim MissingData(Len(StrainSeq(0)), NextNo)
        For x = 0 To StepNo
            XX = Steps(0, x) '1,1,1,1,1,2,2,2,2,2,4,3,4,3,4,3,4,3,3
            If x = 18 Then
                x = x
            End If
            If x <= UBS2 Then
                If Abs(Steps(4, x)) <= EN And Abs(Steps(4, x)) > 0 Then
                
'                    If Steps(4, x) = 34 Then
'                        'XX = Daught(33, 0)
'                        If Steps(1, x) = 0 Then
'                            x = x
'                        End If
'                    Else
'                        x = x
'                    End If
                    If Steps(0, x) = 6 Then
                        
                        NextNo = PermNextno
                        If UBound(RedoDist) <> NextNo Then
                            ReDim Preserve RedoDist(NextNo)
                        End If
                        If UBound(TreeTrace) <> NextNo Then
                            ReDim Preserve TreeTrace(NextNo)
                        End If
                        If UBound(CurrentXOver) <> NextNo Then
                            ReDim Preserve CurrentXOver(NextNo)
                        End If
                        If UBound(Daught, 2) <> NextNo Then
                            ReDim Preserve Daught(SEventNumber, NextNo)
                        End If
                        If UBound(MinorPar, 2) <> NextNo Then
                            ReDim Preserve MinorPar(SEventNumber, NextNo)
                        End If
                        If UBound(MajorPar, 2) <> NextNo Then
                            ReDim Preserve MajorPar(SEventNumber, NextNo)
                        End If
                        If UBound(OriginalName) <> NextNo Then
                            ReDim Preserve OriginalName(NextNo)
                        End If
                        If UBound(SeqNum, 2) <> NextNo Then
                            ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
                        End If
                        If UBound(MissingData, 2) <> NextNo Then
                            ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
                        End If
                        If UBound(PermOriginalName) <> NextNo Then
                            ReDim Preserve PermOriginalName(NextNo)
                        End If
                        If UBound(ONameLen) <> NextNo Then
                            ReDim Preserve ONameLen(NextNo)
                        End If
                        
                        If x = 1234567890 Then
                            If x = 1234567890 Then
                                For Y = x + 1 To StepNo
                                    If Steps(4, Y) >= EN Then Exit For
                                    If Steps(0, Y) = 2 And Steps(1, Y) <= PermNextno Then
                                        
                                        Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, Y), Steps(2, Y), Steps(3, Y), SeqNum(0, 0), MissingData(0, 0))
                                        RedoDist(Steps(1, Y)) = 1
                                    End If
                                Next Y
                            Else
                                'reset seqnum
                                ReDim MissingData(Len(StrainSeq(0)), NextNo)
                                If PermSeqNumInFile = 1 Then
                                    oDirX = CurDir
                                    ChDrive App.Path
                                    ChDir App.Path
                                    FF = FreeFile
                                    ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
                                    Open "RDP5PSNFile" + UFTag For Binary As #FF
                                    Get #FF, , SeqNum
                                    Close #FF
                                    ChDrive oDirX
                                    ChDir oDirX
                                    If DebuggingFlag < 2 Then On Error Resume Next
                                    ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
                                    On Error GoTo 0
                                Else
                                    If DebuggingFlag < 2 Then On Error Resume Next
                                    ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
                                    On Error GoTo 0
                                    Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
                                End If
                                If x = 12345678 Then 'maybe erase bits from the anchor sequence
                                    'find the anchor sequence
                                    Dim DCV1 As Long, DCV2 As Long, mP As Long
                                    Call SplitP(-XoverList(RelX, RelY).BeginP, DCV1, DCV2)
                                    mP = WhereIsExclude(DCV1)
                                    
                                    For Y = x + 1 To StepNo
                                        If Steps(4, Y) >= EN Then Exit For
                                        If Steps(0, Y) = 2 And Steps(1, Y) = mP Then
                                            'XX = OriginalName(Steps(1, Y)) '3193-1800(99),2451-3028(184), 1858-2248(202)
                                            Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, Y), Steps(2, Y), Steps(3, Y), SeqNum(0, 0), MissingData(0, 0))
                                            RedoDist(Steps(1, Y)) = 1
                                        End If
                                    Next Y
                                End If
                            End If
                        End If
                        
                        If x = x Then
                        'quickly get to the steps(4,x) that equals EN
                            For Y = x + 1 To StepNo
                                If Steps(4, Y) = EN + 1 Then
                                    'XX = Steps(0, Y)
                                    
                                    Exit For
                                End If
                            Next Y
                            'now scan backwards to the last steps(0,y) that equals 6
                            For Z = Y To 0 Step -1
                                If Steps(0, Z) = 6 Then
                                    x = Z
                                    Exit For
                                End If
                            Next Z
                            x = x
                        End If
                    ElseIf Steps(0, x) = 1 Then 'ie make a sequence
                        NextNo = NextNo + 1
                        If NextNo > UBound(RedoDist, 1) Then
                            ReDim Preserve RedoDist(NextNo + 100)
                        End If
                        
                        UB = UBound(MissingData, 2)
                        
                        If NextNo < 50 Then
                            ExtraBit = NextNo
                        Else
                            ExtraBit = 50
                        End If
                         
                        If NextNo > UB Then '3204,3255,3306,3357
                        '
                            ReDim Preserve TreeTrace(NextNo + ExtraBit)
                            ReDim Preserve CurrentXOver(NextNo + ExtraBit)
                            ReDim Preserve OriginalName(NextNo + ExtraBit)
                            If (Len(StrainSeq(0)) * (NextNo + ExtraBit)) > (MemPoc * 10000) Then
                                FF = FreeFile
                                Open "tmp1" + UFTag For Binary As #FF
                                Put #FF, , SeqNum
                                Close #FF
                                Open "tmp2" + UFTag For Binary As #FF
                                Put #FF, , MissingData
                                Close #FF
                                Open "tmp3" + UFTag For Binary As #FF
                                Put #FF, , Daught
                                Close #FF
                                Erase SeqNum
                                Erase MissingData
                                Erase Daught
                                ReDim SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                Open "tmp1" + UFTag For Binary As #FF
                                Get #FF, , SeqNum
                                Close #FF
                                ReDim MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                Open "tmp2" + UFTag For Binary As #FF
                                Get #FF, , MissingData
                                Close #FF
                                ReDim Daught(SEventNumber, NextNo + ExtraBit)
                                Open "tmp3" + UFTag For Binary As #FF
                                Get #FF, , Daught
                                Close #FF
                                Kill "tmp1" + UFTag
                                Kill "tmp2" + UFTag
                                Kill "tmp3" + UFTag
                                
                            Else
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve Daught(SEventNumber, NextNo + ExtraBit)
                            End If
                            If NextNo > PermNextno Then
                                ReDim Preserve PermOriginalName(NextNo + ExtraBit)
                                ReDim Preserve ONameLen(NextNo + ExtraBit)
                            End If
                        End If
                        If NextNo > UBound(S2TraceBack, 1) Then
                            ReDim Preserve S2TraceBack(NextNo + 10)
                        End If
                        If Steps(2, x) < 0 Then
                            IntoSomeExtras = 1
                            oDirX = CurDir
                            ChDrive App.Path
                            ChDir App.Path
                            FF = FreeFile
                            Open "RDP5ExcludeList" + UFTag For Binary As #FF
                            Get #FF, Abs(Steps(2, x)), TELong 'Original number of the sequence that this unexcluded sequence  is most similar to
                            Get #FF, , TELong 'the original sequence number'18,30,33,42,45,46//16,17,29,31,44
                           
                            Get #FF, , TELong 'discard number
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            OriginalName(NextNo) = Trim(TEString)
                            ONameLen(NextNo) = Len(OriginalName(NextNo))
                            PermOriginalName(NextNo) = Trim(TEString)
                            If UBound(StraiName) < NextNo Then ReDim Preserve StraiName(NextNo)
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            StraiName(NextNo) = Trim(TEString)
                            Get #FF, , TELong 'seqeunec length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'sequence
                            'XX = Seq1
                            Close #FF
                            ChDrive oDirX
                            ChDir oDirX
                            ExcludeExempt = 1
                            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                            'there is sequence compression and the loaded sequence needs to be modified accordingly
                               TEString = CompressTEString(Decompress(), TEString)
                            End If
                            Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), UCase(TEString), SSBak(0))
                            If UBound(StrainSeq, 1) < NextNo Then ReDim Preserve StrainSeq(NextNo)
                            StrainSeq(NextNo) = UCase(TEString)
'                            For A = 0 To Len(StrainSeq(0))
'                                MissingData(A, Nextno) = 0
'                            Next A
'                            If Nextno = Seq3 Then
'                                x = x
'                            End If
'                            If Nextno = 246 Then
'                                x = x
'                            End If
                            For A = 0 To Len(StrainSeq(0))
                                'If SeqNum(A, PSeq) < 50 Then SeqNum(A, Nextno) = SeqNum(A, PSeq) 'make sure all the masking is consistent
                                MissingData(A, NextNo) = MissingData(A, RelX)
                                
                                'If SeqNum(A, Nextno) < 50 Then MissingData(A, Nextno) = 1
                            Next A
'                            If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            'If Daught(EN, RelX) > 0 Then
                            Daught(EN, NextNo) = 7 'ELLite(5, x)
                            'End If
'                            If Nextno = 290 Then
'                                x = x
'                            End If
                            TreeTrace(NextNo) = NextNo
                            
                            RedoDist(NextNo) = 1
                            If NextNo > UBound(S2TraceBack, 1) Then
                                ReDim Preserve S2TraceBack(NextNo + 10)
                            End If
                            S2TraceBack(NextNo) = NextNo
                            
                        Else
                           
                            If Steps(1, x) < UBound(TreeTrace, 1) Then
                                OriginalName(NextNo) = OriginalName(TreeTrace(Steps(1, x))) 'x97704(6)
                                If NextNo > PermNextno Then ONameLen(NextNo) = Len(OriginalName(TreeTrace(Steps(1, x))))
                                Daught(EN, NextNo) = Daught(EN, Steps(1, x))
                                TreeTrace(NextNo) = TreeTrace(TreeTrace(Steps(1, x)))
                            End If
                            Dummy = ModSeqNumD(NextNo, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
'                             If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            S2TraceBack(NextNo) = S2TraceBack(TreeTrace(Steps(1, x)))
                        End If
                        RedoDist(NextNo) = 1
                       
                        
                        
                        RedoDist(Steps(1, x)) = 1
                    ElseIf Steps(0, x) = 2 Then  'delete some positions in sequence
'                        If IntoSomeExtras = 1 Then
'                            XX = EN
'                            Daught(Steps(4, x), Steps(1, x)) = 1
'                        End If
                        'XX = OriginalName(Steps(1, x))'2630-4018 in seq 6/???,1412-2100 in seq24,25,26,27,28
                        Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
'                        If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                        RedoDist(NextNo) = 1
                    ElseIf Steps(0, x) = 3 Then 'delete a sequence
'                        If Nextno = 828 Then
'                            X = X
'                        End If
'                            If Steps(1, x) = 232 Then
'                                x = x
'                            End If
'                            If TreeTrace(TreeTrace(Steps(1, x))) = 85 Then
'                                x = x
'                            End If
                            'If (TreeTrace(TreeTrace(Steps(1, x))) <> Seq1 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq2 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq3) Or IntoSomeExtras = 1 Then
                                If Steps(1, x) <= NextNo Then
                                    If Steps(1, x) < NextNo Then
                                        
                                        Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
    '                                    If SeqNum(1780, Seq3) = 46 Then
    '                                    XX = Steps(4, x)
    '                                x = x
    '                            End If
                                        Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
                                        TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
                                        'XX = TreeTrace(TreeTrace(Steps(1, X)))
                                        OriginalName(Steps(1, x)) = OriginalName(NextNo)
                                        S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
                                        RedoDist(Steps(1, x)) = RedoDist(NextNo)
                                        RedoDist(NextNo) = 0
                                        
                                        
                                    Else
                                        Daught(EN, NextNo) = 0
                                    End If
    '                                If Nextno > 226 Then
    '                                    XX = PermNextno
    '                                    x = x
    '                                End If
                                    NextNo = NextNo - 1
                                End If
                                'XX = TreeTrace(Nextno)
'                            ElseIf Seq1 > PermNextno Or Seq2 > PermNextno Or Seq3 > PermNextno Then
'                                If Steps(1, x) < NextNo Then
'
'                                    Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
''                                    If SeqNum(1780, Seq3) = 46 Then
''                                x = x
''                            End If
'                                    Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
'                                    TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                                    'XX = TreeTrace(TreeTrace(Steps(1, X)))
'                                    OriginalName(Steps(1, x)) = OriginalName(NextNo)
'                                    RedoDist(Steps(1, x)) = RedoDist(NextNo)
'                                    RedoDist(NextNo) = 0
'                                    S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
'                                Else
'                                    Daught(EN, NextNo) = 0
'                                End If
''                                If Nextno = 226 Then
''                                    x = x
''                                End If
'                                NextNo = NextNo - 1
'                            End If
                    ElseIf Steps(0, x) = 4 Then 'replace a sequence
'                        If Steps(1, x) = 232 Then
'                                x = x
'                            End If
'                            If TreeTrace(TreeTrace(Steps(1, x))) = 85 Then
'                                x = x
'                            End If
                        XX = TreeTrace(TreeTrace(Steps(1, x)))
                        'If (TreeTrace(TreeTrace(Steps(1, x))) <> Seq1 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq2 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq3) Or IntoSomeExtras = 1 Then
                            Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
'                            If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
                            OriginalName(Steps(1, x)) = OriginalName(NextNo)
                            RedoDist(Steps(1, x)) = RedoDist(NextNo)
                            RedoDist(NextNo) = 0
                            S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
                            TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                            If Nextno = 226 Then
'                                    x = x
'                                End If
'                            NextNo = NextNo - 1
'                        ElseIf Seq1 > PermNextno Or Seq2 > PermNextno Or Seq3 > PermNextno Then
'                            Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
'                            Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
'                            OriginalName(Steps(1, x)) = OriginalName(NextNo)
'                            RedoDist(Steps(1, x)) = RedoDist(NextNo)
'                            RedoDist(NextNo) = 0
'                            S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
'                            TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                            NextNo = NextNo - 1
                        'End If
                    End If
                Else
                    Exit For
                    
                End If
            End If
            
            
            'If NextNo = 27 Then
'            For Z = 1 To Len(StrainSeq(0))
'                If MissingData(Z, Nextno) = 0 Then '30=n,31=w
'                    XX = TreeTrace(Nextno)
'                End If
'            Next Z
'                x = x
                'xx==tracsub(
            'End If
            
        Next x
        
        
'        XX = SeqNum(1780, Seq3)
'                            XX = MissingData(1780, Seq3)
'                            XX = Mid$(TEString, 1780, 20)
        
        'XX = PermNextno
        XX = NextNo - PermNextno
        
        tNextno = NextNo
        If IntoSomeExtras = 1 Then
            ReDim Preserve MinorPar(UBound(MinorPar, 1), NextNo)
            ReDim Preserve MajorPar(UBound(MajorPar, 1), NextNo)
            ReDim Preserve Daught(UBound(Daught, 1), NextNo)
            If NumExcludedEventNum > 0 Then
                'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                NF3 = FreeFile
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                Put #NF3, 1, ExcludedEventNum
                Put #NF3, , EventsInExcludeds
                Close #NF3
                ReDim EventsInExcludeds(5, 1000)
                'ExcludedEventNum = 1
                ChDrive oDirX
                ChDir oDirX
            End If
            For j = 0 To NumExcludedEventNum
                If NumExcludedEventNum > 0 Then
                    NF3 = FreeFile
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                    Get #NF3, , ExcludedEventNum
                    ReDim EventsInExcludeds(5, ExcludedEventNum)
                    Get #NF3, , EventsInExcludeds
                    Close #NF3
                    'ExcludedEventNum = 1
                    ChDrive oDirX
                    ChDir oDirX
                End If
                For x = 0 To UBound(EventsInExcludeds, 2)
                    'XX = UBound(Daught, 2)
                    If EventsInExcludeds(1, x) = -EN And EventsInExcludeds(2, x) <= NextNo Then
                        If EventsInExcludeds(0, x) = 3 Then
                            Daught(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                            MajorPar(EN, EventsInExcludeds(2, x)) = 0
                            MinorPar(EN, EventsInExcludeds(2, x)) = 0
                        End If
                        If EventsInExcludeds(0, x) = 1 Then
                            MajorPar(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                            'Daught(EN, EventsInExcludeds(2, x)) = 0
                            MinorPar(EN, EventsInExcludeds(2, x)) = 0
                            
                        End If
                        If EventsInExcludeds(0, x) = 2 Then
                            MinorPar(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                            'Daught(EN, EventsInExcludeds(2, x)) = 0
                            MajorPar(EN, EventsInExcludeds(2, x)) = 0
                            
                        End If
                    End If
                Next x
            Next j
'            If BusyWithExcludes = 1 Then
'                If RList(WinPP, WinPPY) > RList(WinPP, WinPPY) > PermNextno Then
'                'For Y = 0 To RNum(x)
'                    ExcludedEventNum = ExcludedEventNum + 1
'                    If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
'                        ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
'                    End If
'                    EventsInExcludeds(0, ExcludedEventNum) = WinPP
'                    EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
'                    EventsInExcludeds(2, ExcludedEventNum) = RList(WinPP, WinPPY) 'the number of the sequence at this time
'                    EventsInExcludeds(3, ExcludedEventNum) = CurSeedExtras 'sequence this exclude is most similar to in the includedlist
'                    EventsInExcludeds(4, ExcludedEventNum) = OriginalPos(RList(WinPP, WinPPY)) 'original number of this sequence
'                    If MinP > LowestProb Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 5
'                    ElseIf (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 4
'                    ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 2
'                    ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 3
'                    Else
'                        EventsInExcludeds(5, ExcludedEventNum) = 1
'                    End If
'                End If
'            'Next Y
'
'            End If
        
        End If
'        For Z = 1 To Len(StrainSeq(0))
'            If MissingData(Z, NextNo - 2) = 1 Then
'                x = x
'            End If
'        Next Z
        'XX = MissingData(3000, 15)
'        XX = Nextno
'        XX = OriginalName(11)
'        XX = OriginalName(12)
'        XX = OriginalName(13)
        'XX = XoverList(RelX, RelY).Daughter
        If ExcludedEventNum > 0 And DontLoadExcludes = 0 And ExcludeExempt = 0 Then
            
            If UBound(ELLite, 2) = 0 Then
                Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
            End If
            
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            '3428 (793,213 - se=64,154),5883 (2601,727 - se = 99),1947 (359,93 se = 25,48,49), *3279 (3279,869 se = 192), 6659(2460,689 se = 99,163)

            If Dir("RDP5ExcludeList" + UFTag) <> "" Then
                ReDim SSBak(Len(StrainSeq(0)))
                ReDim Excludetrace(NextnoBak)
                For x = 0 To UBound(ELLite, 2)
                    If ELLite(3, x) <= UBound(Daught, 2) Then
                        If EN = ELLite(1, x) And Daught(EN, ELLite(3, x)) > 0 Then
                            
                            NextNo = NextNo + 1
                            Excludetrace(NextNo) = x
                            If NextNo > UBound(RedoDist, 1) Then
                                ReDim Preserve RedoDist(NextNo + 100)
                            End If
                            
                            
                            
                            UB = UBound(MissingData, 2)
                            If NextNo < 50 Then
                                ExtraBit = NextNo
                            Else
                                ExtraBit = 50
                            End If
                            
                            If NextNo > UB Then '3204,3255,3306,3357
                            '
                                ReDim Preserve TreeTrace(NextNo + ExtraBit)
                                ReDim Preserve CurrentXOver(NextNo + ExtraBit)
                                ReDim Preserve Daught(SEventNumber, NextNo + ExtraBit)
                                ReDim Preserve OriginalName(NextNo + ExtraBit)
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve StraiName(NextNo + ExtraBit)
                                If NextNo > PermNextno Then
                                    ReDim Preserve PermOriginalName(NextNo + ExtraBit)
                                    'ReDim Preserve OriginalName(NextNo + ExtraBit)
                                    ReDim Preserve ONameLen(NextNo + ExtraBit)
                                End If
                            End If
                            
                            FF = FreeFile
                            Open "RDP5ExcludeList" + UFTag For Binary As #FF
                            PSeq = ELLite(3, x)
                            Get #FF, ELLite(2, x), TELong 'the original number of the sequence this sequence is most similar to
                            Get #FF, , TELong 'the original sequence number'3176,3279
                           
                            Get #FF, , TELong 'discard number
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            OriginalName(NextNo) = Trim(TEString)
                            ONameLen(NextNo) = Len(OriginalName(NextNo))
                            PermOriginalName(NextNo) = Trim(TEString)
                            If UBound(StraiName) < NextNo Then ReDim Preserve StraiName(NextNo)
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            StraiName(NextNo) = Trim(TEString)
                            Get #FF, , TELong 'seqeunec length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'sequence
                            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                            'there is sequence compression and the loaded sequence needs to be modified accordingly
                               TEString = CompressTEString(Decompress(), TEString)
                            End If
                            Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), UCase(TEString), SSBak(0))
'                            XX = SeqNum(1455, Nextno)
'                            For Z = 1300 To Len(StrainSeq(0))
'                                If SeqNum(Z, Nextno) > 46 Then
'                                    x = x
'                                End If
'                            Next Z
                            For A = 0 To Len(StrainSeq(0))
                                If SeqNum(A, PSeq) < 50 Then SeqNum(A, NextNo) = SeqNum(A, PSeq) 'make sure all the masking is consistent
                                MissingData(A, NextNo) = MissingData(A, PSeq)
'                                If SeqNum(A, NextNo) < 50 Then MissingData(A, NextNo) = 1
                            Next A
                            Daught(EN, NextNo) = ELLite(5, x)
                            TreeTrace(NextNo) = NextNo
                            
                            RedoDist(NextNo) = 1
                            If NextNo > UBound(S2TraceBack, 1) Then
                                ReDim Preserve S2TraceBack(NextNo + 10)
                            End If
                            S2TraceBack(NextNo) = NextNo
                            Close #FF
                        End If
                    End If
                    If NextNo > MemPoc * 1.25 Then Exit For
                Next x
            Else
                ReDim Excludetrace(NextNo)
                
            End If
            
            ChDrive oDirX
            ChDir oDirX
        Else
            ReDim Excludetrace(NextNo)
        End If
        
        Dim MissNt As Long
        
        
        '@
        For x = 0 To NextNo
            MissNt = 0
            For Y = 1 To Len(StrainSeq(0))
                If SeqNum(Y, x) < 50 Then
                    MissNt = MissNt + 1
                    If MissNt > 10 Then
                        MissingData(Y, x) = 1
                    ElseIf MissNt = 10 Then
                        For Z = Y - 10 To Y
                            MissingData(Z, x) = 1
                        Next Z
                    End If
                Else
                    MissNt = 0
                End If
            Next Y
        
        Next x
        If tNextno < NextNo Then
            If UBound(TreeTrace, 1) < NextNo Then
                ReDim Preserve TreeTrace(NextNo)
            End If
            For x = tNextno + 1 To NextNo
                TreeTrace(x) = x
            Next x
        End If
        
    End If
     
   ' XX = Nextno
    ZZ = 0
    Dim ReplaceFlag As Byte
    
    
    
    
    '710
    
    If BPos <> Epos Then
        x = 0
        'get rid of some empty sequences here - it should massively speed up the distance matrix calculations
        For x = 0 To NextNo
            ReplaceFlag = 0
            If BPos < Epos Then
                GoOn = 0
                For Y = BPos To Epos
                    If SeqNum(Y, x) <> 46 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                If GoOn = 1 Then
                    GoOn = 0
                    For Y = 1 To BPos
                        If SeqNum(Y, x) <> 46 Then
                            GoOn = 1
                            Exit For
                        End If
                    Next Y
                    If GoOn = 0 Then
                        For Y = Epos To Len(StrainSeq(0))
                            If SeqNum(Y, x) <> 46 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Y
                        If GoOn = 0 Then
                            ReplaceFlag = 1
                        End If
                    End If
                Else
                    ReplaceFlag = 1
                End If
            Else
                GoOn = 0
                For Y = Epos To BPos
                    If SeqNum(Y, x) <> 46 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                If GoOn = 1 Then
                    GoOn = 0
                    For Y = 1 To Epos
                        If SeqNum(Y, x) <> 46 Then
                            GoOn = 1
                            Exit For
                        End If
                    Next Y
                    If GoOn = 0 Then
                        For Y = BPos To Len(StrainSeq(0))
                            If SeqNum(Y, x) <> 46 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Y
                        If GoOn = 0 Then
                            ReplaceFlag = 1
                        End If
                    End If
                Else
                    ReplaceFlag = 1
                End If
            End If
            If ReplaceFlag = 1 Then '323,660
                RedoDist(x) = -1
                ZZ = ZZ + 1
            End If
            
        Next x
    End If
    
    
    
    

    '710
     If NextNo > PermNextno Then
         ReDim Preserve TreeTrace(NextNo), CurrentXOver(NextNo), Daught(SEventNumber, NextNo), OriginalName(NextNo), SeqNum(Len(StrainSeq(0)), NextNo), MissingData(Len(StrainSeq(0)), NextNo)
       
     End If
    
    
    'make sure all the maskseq info is preserved
     '710
     ReDim Preserve MaskSeq(NextNo)
     For x = 0 To NextNo
        If TreeTrace(x) <= UBound(MaskSeq, 1) Then
            MaskSeq(x) = MaskSeq(TreeTrace(x))
        End If
     Next x
     
     If DebuggingFlag < 2 Then On Error Resume Next
    If UBound(SeqCol, 1) < NextNo Or UBound(FFillCol, 1) < NextNo Then
        ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
    End If
    
    If UBound(XCord, 3) < NextNo + 2 Or UBound(YCord, 3) < NextNo + 2 Or UBound(RYCord, 3) < NextNo + 2 Then
        ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
    
    End If
    
    On Error GoTo 0
    
     If UBound(OriginalName, 1) < NextNo Then
        ReDim Preserve OriginalName(NextNo)
     End If
         
         
     
     'the number of sequences has changed and distances need to be recalculated for the sequences that have been modified
     'ReDim PermDiffs(Nextno, Nextno), PermValid(Nextno, Nextno)
    '710
    If NextNo <> UBound(Distance, 1) Then
        ReDim Distance(NextNo, NextNo) 'WARNING - removing this will make the program super unstable
        ReplaceDistsFlag = 1
    End If
    '710
     If BPos <> Epos Then
     
        If NextNo > 1000 Then 'get rid of masked sequences (except those in daught)
            For x = 0 To NextNo
                If MaskSeq(x) = 1 And Daught(EN, x) = 0 Then
                    RedoDist(x) = -1 'make sure it is not calculated in either the smat or the fmat
                End If
                
            Next x
            
        End If

        Dim BPX As Long, EPX As Long
        BPX = BPos: EPX = Epos
        '710
        'XX = UBound(RedoDist)
        Call MakeSFMats(NextNo, BPX, EPX, FMat(), SMat(), SubValid(), SubDiffs(), PermValid(), PermDIffs(), SeqNum(), RedoDist())
        
        '884 but spikes at ~1200
        
        BPos = BPX: Epos = EPX
        
     Else
        Dim tRedoDist() As Integer
        
        ReDim tRedoDist(NextNo)
        
        For x = 0 To NextNo
            tRedoDist(x) = 1
        Next x
        'Dim AvDst As Double, UDst As Double
        ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo), Distance(NextNo, NextNo)
        Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, PermDIffs(), PermValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
        
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            UBPermValid = UBound(PermValid, 1)
            Open "RDP5PermValid" + UFTag For Binary As #FF
            Put #FF, , PermValid()
            Close #FF
            
            UBPermDiffs = UBound(PermDIffs, 1)
            Open "RDP5PermDiffs" + UFTag For Binary As #FF
            Put #FF, , PermDIffs()
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        
     End If
     
     DistanceFlag = 1
     EditSeqFlag = 1

     If uSeqNuminFile = 1 Then
        If UBuMD2 = NextNo Then
            ReDim uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
        End If
     End If
'     For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
     If UBound(uMissingData, 2) <> NextNo Then
        ReDim uTreeTrace(NextNo)
        '987
        
        ReDim uDaught(SEventNumber, NextNo)
        
        For Y = 0 To NextNo
            If Y <= UBound(Daught, 2) Then
                For x = 0 To SEventNumber
            
                    uDaught(x, Y) = Daught(x, Y)
               
                Next x
            End If
        Next Y
'        For x = 0 To NextNo
'            If Daught(SEventNumber, x) <> 0 Then
'                x = x
'            End If
'        Next x
        '995
        '
        
        
        
        ReDim uOriginalName(NextNo), uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
        '1097
        ReDim Preserve uSeqCol(NextNo), uFFillCol(NextNo)
        
        ReDim Preserve uOriginalName(NextNo)
     End If
     Dim UB1 As Long, UB2 As Long
     If DebuggingFlag < 2 Then On Error Resume Next
     UB1 = -1
     UB1 = UBound(uDaught, 1)
     UB2 = -1
     UB2 = UBound(Daught, 1)
     On Error GoTo 0
     If UB1 > -1 And UB2 > -1 Then
         If UB1 <> UB2 Then
            If UB = 0 Then
         
                ReDim uDaught(UBound(Daught, 1), UBound(Daught, 2))
                For x = 0 To UBound(Daught, 1)
                    'If X <= UBound(uDaught, 1) Then
                        For Y = 0 To UBound(Daught, 2)
                            uDaught(x, Y) = Daught(x, Y)
                        Next Y
                    'End If
                Next x
            Else
                Dim tDaught() As Byte
                
                UBU = UBound(uDaught, 1)
                UB = UBound(Daught, 1)
                If UBU >= UB Then
                    ReDim tDaught(UBound(uDaught, 1), NextNo)
                    x = x
                Else
                    ReDim tDaught(UBound(Daught, 1), NextNo)
                    x = x
                End If
                For x = 0 To UBound(uDaught, 1)
                    'If X <= UBound(uDaught, 1) Then
                    For Y = 0 To NextNo
                        tDaught(x, Y) = uDaught(x, Y)
                    Next Y
                    'End If
                Next x
                 ReDim uDaught(UBound(Daught, 1), NextNo)
                For x = 0 To UBound(Daught, 1)
                    
                    For Y = 0 To NextNo
                        uDaught(x, Y) = tDaught(x, Y)
                    Next Y
                Next x
            End If
        End If
    End If
    If SPF = 0 Then
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
   
    
    'Make sure that the bounds of Treedistance are correct
    If UBound(TreeDistance, 1) <> NextNo Then
        UB = UBound(TreeDistance, 1)
        ReDim uTreeDistance(UB, UB)
        For x = 0 To UB
            For Y = 0 To UB
                uTreeDistance(x, Y) = TreeDistance(x, Y)
            Next Y
        Next x
        ReDim TreeDistance(NextNo, NextNo)
        If UB > NextNo Then UB = NextNo
        
        For x = 0 To UB
            For Y = 0 To UB
                TreeDistance(x, Y) = uTreeDistance(x, Y)
            Next Y
        Next x
    
    End If
   
    'Dump uDistance and uTreeDistance to Disk
    
    
    
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    UBuDist = UBound(Distance, 1)
    UBuTDist = UBound(TreeDistance, 1)
'    ReDim TestTreeDist(UBuTDist, UBuTDist)
'    ReDim TestDist(UBuTDist, UBuTDist)
'    For X = 0 To UBuTDist
'        For Y = 0 To UBuTDist
'            TestDist(X, Y) = Distance(X, Y)
'            TestTreeDist(X, Y) = TreeDistance(X, Y)
'        Next Y
'
'    Next X
    'replace top half of utreedistance with distance
'    SS = abs(gettickcount)
'    If X = X Then
'        If X = X Then
            Erase uTreeDistance
            
            ReDim IntTD(UBuTDist, UBuTDist)
            
'            If X = X Then
'                SS = abs(gettickcount)
                Dummy = FillIntTD(UBuTDist, MinDist, MinTDist, AdjustD, AdjustTD, IntTD(0, 0), Distance(0, 0), TreeDistance(0, 0))
'                EE = abs(gettickcount)
'                TT = EE - SS
'                X = X
                '0.6048775
                '0.8124499
'            Else
'
'                MaxDist = -10000
'                MinDist = 10000
'                MaxTDist = -10000
'                MinTDist = 10000
'                For X = 0 To UBuTDist
'                    For Y = X + 1 To UBuTDist
'                        If Distance(X, Y) > MaxDist Then MaxDist = Distance(X, Y)
'                        If Distance(X, Y) < MinDist Then MinDist = Distance(X, Y)
'                        If TreeDistance(X, Y) > MaxTDist Then MaxTDist = TreeDistance(X, Y)
'                        If TreeDistance(X, Y) < MinTDist Then MinTDist = TreeDistance(X, Y)
'                    Next Y
'                Next X
'
'                IntervalD = MaxDist - MinDist
'                'Compressed distance
'                AdjustD = 64000 / IntervalD
'
'                IntervalTD = MaxTDist - MinTDist
'                'Compressed distance
'                AdjustTD = 64000 / IntervalTD
'                For X = 0 To UBuTDist
'                    For Y = X + 1 To UBuTDist
'                        IntTD(X, Y) = CLng((Distance(X, Y) - MinDist) * AdjustD) - 32000
'                        X = X
'                    Next Y
'                Next X
'                For X = 1 To UBuTDist
'                    For Y = 0 To X - 1
'                        IntTD(X, Y) = CLng((TreeDistance(X, Y) - MinTDist) * AdjustTD) - 32000
'                    Next Y
'                Next X
'            End If
            FF = FreeFile
'            SS = abs(gettickcount)
            '@
            Open "RDP5uDuTD" + UFTag For Binary As #FF
            '@
            Put #FF, , IntTD()
            
            
            Close #FF
            Erase IntTD
'            EE = abs(gettickcount)
'            TT = EE - SS
'            X = X
            'this is about 5 times quicker than the old version
'        Else
'           ' SS = abs(gettickcount)
'            ReDim uTreeDistance(UBuTDist, UBuTDist)
'            For X = 0 To UBuTDist
'                For Y = X + 1 To UBuTDist
'                    uTreeDistance(X, Y) = Distance(X, Y)
'
'                Next Y
'            Next X
'
'            For X = 1 To UBuTDist
'                For Y = 0 To X - 1
'                    uTreeDistance(X, Y) = TreeDistance(X, Y)
'                Next Y
'            Next X
'    '        EE = abs(gettickcount)
'    '        TT = EE - SS
'
'
'
'            FF = FreeFile
'    '        SS = abs(gettickcount)
'            Open "RDP5uDuTD" + UFTag For Binary As #FF
'            ''''
'            Put #FF, , uTreeDistance()
'            Close #FF
'            Erase uTreeDistance
'    '        EE = abs(gettickcount)
'    '        TT = EE - SS
'    '        X = X
'        End If
'    SS = abs(gettickcount)
'    Else
'        FF = FreeFile
'        Open "RDP5uDistance" + UFTag For Binary As #FF
'        ''''
'        Put #FF, , Distance()
'        Close #FF
'        If SPF = 0 Then
'            Form1.Refresh
'            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'        End If
'        Open "RDP5uTreeDistance" + UFTag For Binary As #FF
'        '''
'        Put #FF, , TreeDistance()
'
'        Close #FF
'    End If
'    EE = abs(gettickcount)
'    TT = EE - SS
'    X = X

    
    If SPF = 0 And DontRefreshFlag = 0 Then
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    ChDir oDir
    ChDrive oDir
    uDistanceInFIleFlag = 1 ' it will always be 1
    
    If DebuggingFlag < 2 Then On Error Resume Next
    SE = -1
    SE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(SeqNum, 2)
    On Error GoTo 0
    If SE > -1 And UB2 > -1 Then
        If uSeqNuminFile = 1 And UB < 1 Then
            For x = 0 To NextNo
                uTreeTrace(x) = TreeTrace(x)
                uDaught(SE, x) = Daught(SE, x)
                uSeqCol(x) = SeqCol(x)
                uFFillCol(x) = FFillCol(x)
                
            Next x
            
            ReDim uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5uSeqnum" + UFTag For Binary As #FF
            Get #FF, , uSeqNum
            Close #FF
            Open "RDP5uMissingData" + UFTag For Binary As #FF
            Get #FF, , uMissingData
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
           '@
            If SE > -1 Then
                    Dummy = MakeuBackups(Len(StrainSeq(0)), SE, UBound(Daught, 1), NextNo, uMissingData(0, 0), MissingData(0, 0), uSeqNum(0, 0), SeqNum(0, 0), uFFillCol(0), FFillCol(0), uSeqCol(0), SeqCol(0), uDaught(0, 0), Daught(0, 0), uTreeTrace(0), TreeTrace(0))
            End If
        End If
    End If
     
     For x = 0 To NextNo
        uOriginalName(x) = OriginalName(x)
     Next x
     uNextno = NextNo
    
Else
    


    NextNo = uNextno
    'ModSeqNumFlag = 2 'i.e. the sequences were no reedited
    If NextNo > PermNextno Then
        ReDim Preserve TreeTrace(NextNo)
        ReDim Preserve CurrentXOver(NextNo)
        ReDim Preserve Daught(SEventNumber, NextNo)
        ReDim Preserve OriginalName(NextNo)
        ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
        ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
    End If
   
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB1 = -1
    UB1 = UBound(uDaught, 1)
    UB2 = -1
    UB2 = UBound(Daught, 1)
    On Error GoTo 0
    If UB1 > -1 And UB2 > -1 Then
        If UB1 <> UB2 Then
    
    
            ReDim tDaught(UBound(Daught, 1), NextNo)
            For x = 0 To UBound(Daught, 1)
                If x <= UBound(uDaught, 1) Then
                    For Y = 0 To NextNo
                        tDaught(x, Y) = uDaught(x, Y)
                    Next Y
                End If
            Next x
            ReDim uDaught(UBound(Daught, 1), NextNo)
            For x = 0 To UBound(Daught, 1)
                For Y = 0 To NextNo
                    uDaught(x, Y) = tDaught(x, Y)
                Next Y
            Next x
        End If
    End If
    'Dim X As Long
    
    If UBound(SeqCol, 1) < NextNo Then
        ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
    End If
    
    If UBound(OriginalName, 1) < NextNo Then
        ReDim Preserve OriginalName(NextNo)
    End If
    'ssx = Abs(GetTickCount)
    
    If uSeqNuminFile = 1 Then
       
        ReDim uSeqNum(Len(StrainSeq(0)), UBuSN2), uMissingData(Len(StrainSeq(0)), UBuMD2)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5uSeqnum" + UFTag For Binary As #FF
        Get #FF, , uSeqNum
        Close #FF
        Open "RDP5uMissingData" + UFTag For Binary As #FF
        Get #FF, , uMissingData
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        'ReDim uSeqNum(0, 0), uMissingData(0, 0)
       
    End If

    If DebuggingFlag < 2 Then On Error Resume Next
    UBX = 0
    UBX = UBound(TreeTrace, 1)
    If UBX = 0 Then
        ReDim Preserve TreeTrace(NextNo + 100)
    End If
    On Error GoTo 0
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    
'    If X = X Then
'        SS = abs(gettickcount)
        ReDim IntTD(UBuTDist, UBuTDist)
        
        FF = FreeFile
        
        Open "RDP5uDuTD" + UFTag For Binary As #FF
        ''''
        Get #FF, , IntTD()
        Close #FF
        
        
        ReDim Distance(UBuTDist, UBuTDist)
        ReDim TreeDistance(UBuTDist, UBuTDist)
'        If X = X Then
           
            Dummy = ReadIntTD(UBuTDist, MinDist, MinTDist, AdjustD, AdjustTD, IntTD(0, 0), Distance(0, 0), TreeDistance(0, 0))
'            EE = abs(gettickcount)
'            TT = EE - SS
'            X = X
            
'            For X = 0 To UBuTDist
'                For Y = 0 To UBuTDist
'                    If X <> Y Then
'                        If Abs(TestDist(X, Y) - Distance(X, Y)) > 0.0001 Then
'                            X = X
'                        End If
'                        If Abs(TestTreeDist(X, Y) - TreeDistance(X, Y)) > 0.0001 Then
'                            X = X
'                        End If
'                    End If
'                Next Y
'
'            Next X
'            X = X
            
'        Else
'
'            For X = 0 To UBuTDist
'                For Y = X + 1 To UBuTDist
'                    Distance(X, Y) = ((CLng(IntTD(X, Y)) + 32000) / AdjustD) + MinDist
'                    Distance(Y, X) = Distance(X, Y)
'                Next Y
'            Next X
'
'            For X = 1 To UBuTDist
'                For Y = 0 To X - 1
'                    TreeDistance(X, Y) = ((CLng(IntTD(X, Y)) + 32000) / AdjustTD) + MinTDist
'                    TreeDistance(Y, X) = TreeDistance(X, Y)
'                Next Y
'            Next X
'        End If
        Erase IntTD
        
'    Else
'
'        'refill distance and treedistance
'        ReDim uTreeDistance(UBuTDist, UBuTDist)
'
'        FF = FreeFile
'        SS = abs(gettickcount)
'        Open "RDP5uDuTD" + UFTag For Binary As #FF
'        Get #FF, , uTreeDistance()
'        Close #FF
'        ReDim Distance(UBuTDist, UBuTDist)
'        For X = 0 To UBuTDist
'            For Y = X + 1 To UBuTDist
'                Distance(X, Y) = uTreeDistance(X, Y)
'                Distance(Y, X) = uTreeDistance(X, Y)
'            Next Y
'        Next X
'        ReDim TreeDistance(UBuTDist, UBuTDist)
'        For X = 1 To UBuTDist
'            For Y = 0 To X - 1
'                TreeDistance(X, Y) = uTreeDistance(X, Y)
'                TreeDistance(Y, X) = uTreeDistance(X, Y)
'            Next Y
'        Next X
'        EE = abs(gettickcount)
'        TT = EE - SS
'        Erase uTreeDistance
'    End If
'    ReDim Distance(UBuDist, UBuDist)
'    FF = FreeFile
'
'    Open "RDP5uDistance" + UFTag For Binary As #FF
'    Get #FF, , Distance()
'    Close #FF
'
'    ReDim TreeDistance(UBuTDist, UBuTDist)
'    Open "RDP5uTreeDistance" + UFTag For Binary As #FF
'    Get #FF, , TreeDistance()
'    Close #FF
    ChDir oDir
    ChDrive oDir
    If DebuggingFlag < 2 Then On Error Resume Next
    SE = -1
    SE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
    If SE > -1 And UB2 > -1 Then
        GoOn = 0
        For x = 0 To UBound(uDaught, 1)
              For Y = 0 To UBound(uDaught, 2)
                If uDaught(x, Y) <> 0 Then
                    GoOn = 1: Exit For
                End If
            Next Y
            If GoOn = 1 Then Exit For
        Next x
        If GoOn = 0 Then 'somewhere along the line udaught was erased
'              For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
  '  x = x
            ReDim uDaught(UBound(Daught, 1), UBound(Daught, 2))
            For Y = 0 To UBound(Daught, 1)
                  For x = 0 To UBound(Daught, 2)
                    uDaught(Y, x) = Daught(Y, x)
                Next x
                
            Next Y
        Else
            GoOn = 0
            For Y = 0 To UBound(uDaught, 2)
                If uDaught(SE, Y) <> 0 Then
                    GoOn = 1: Exit For
                End If
            Next Y
            If GoOn = 0 Then
                If UBound(uDaught, 2) < UBound(Daught, 2) Then
                    ReDim Preserve uDaught(UBound(uDaught, 1), UBound(Daught, 2))
                End If
                'For Y = 0 To UBound(Daught, 1)
                For x = 0 To UBound(Daught, 2)
                    uDaught(SE, x) = Daught(SE, x)
'                    If Daught(SE, x) > 0 Then
'                        x = x
'                    End If
                Next x
            End If
            'Next Y
        End If
    'x = x
        Dummy = ReplaceuBackups(Len(StrainSeq(0)), SE, UBound(Daught, 1), NextNo, uMissingData(0, 0), MissingData(0, 0), uSeqNum(0, 0), SeqNum(0, 0), uFFillCol(0), FFillCol(0), uSeqCol(0), SeqCol(0), uDaught(0, 0), Daught(0, 0), uTreeTrace(0), TreeTrace(0))
    

    
    End If
    For x = 0 To NextNo
        OriginalName(x) = uOriginalName(x)
    Next x
    ReDim Preserve MaskSeq(NextNo)
    For x = 0 To NextNo
        MaskSeq(x) = MaskSeq(TreeTrace(x))
    Next x

End If

'got to free up ram
If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(SeqNum, 2)
On Error GoTo 0

If UB > -1 Then
    If (((Len(StrainSeq(0)) + 3) * (NextNo + 1) * 4)) > 30000000 Then
        'if necessary write useqnum and umissingdata to disk
        Form1.SSPanel1.Caption = "Copying data to disk"
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        UBuSN2 = UBound(uSeqNum, 2)
        UBuMD2 = UBound(uMissingData, 2)
        uSeqNuminFile = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5uSeqnum" + UFTag For Binary As #FF
        '@
        Put #FF, , uSeqNum
        Close #FF
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        
        Open "RDP5uMissingData" + UFTag For Binary As #FF
        '@
        Put #FF, , uMissingData
        
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        ReDim uSeqNum(0, 0), uMissingData(0, 0)
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    Else
        uSeqNuminFile = 0
    End If
End If

'1111
'If Nextno > UBound(MissingData, 2) Then
'    X = X
'End If
If uDistanceInFIleFlag = 1 Then
    '1107
    Erase uDistance
    '1053,1107
    Erase uTreeDistance
    x = x
    '995,1049
End If
If uSeqNuminFile = 1 Then
    ReDim uSeqNum(0, 0), uMissingData(0, 0)
End If
If UpdateProgressBar = 0 Then
    If SPF = 0 Then
        Form1.SSPanel1.Caption = ""
    End If
End If
 

End Sub
Public Sub ModSeqNumMod(BPos, Epos, SPF)
Dim ReplaceDistsFlag As Long, x As Long, Y As Long, EN As Long, UB As Long, Dummy As Long, ZZ As Long, GoOn As Long, UBU As Long, oDir As String, FF As Long, SE As Long, oDirX As String, UBX As Long

Dim IntTD() As Integer, MaxDist As Single, MaxTDist As Single

If SPF = 0 Then
    Form1.SSPanel1.Caption = "Setting up scan"
End If


ModSeqNumFlag = 1
If NextNo <> PermNextno Then
    Call UnModNextno
    Call UnModSeqNum(0)
End If

ModSNE = Epos: ModSNB = BPos
If NextNo = -1 Then
    Exit Sub
End If
'if editseqflag = 0 then bits get deleted from sequences with events lower than the cirrent event  - these edits get stored in backups
'if editseqflag = 1 then the arrays are replaced with the backed up edits
If EditSeqFlag = 0 Then 'Or AllCheckFlag = 1 Then '**************************************************
    '710
    'ModSeqNumFlag = 1 'i.e. the sequences were reedited
    ReDim MissingData(Len(StrainSeq(0)), NextNo), TreeTrace(NextNo)
    '710
    If ReassortmentFlag = 1 Then 'adds missing data to bounds of segments
        Dim tBP As Long
        If UBound(RBPPos, 1) < RBPNum Then
            ReDim Preserve RBPPos(RBPNum)
        End If
        For x = 0 To RBPNum
            If RBPPos(x) > Len(StrainSeq(0)) Then
                RBPPos(x) = Len(StrainSeq(0))
            End If
            tBP = RBPPos(x)
            For Y = 0 To NextNo
                MissingData(tBP, Y) = 1
            Next Y
        Next x
    End If
    
    For x = 0 To NextNo
        TreeTrace(x) = x
    Next x
    Dim tNextno As Long
    
    If DebuggingFlag < 2 Then On Error Resume Next
        EN = -1
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
   
    If SPF = 0 And SEventNumber > 0 Then Form1.SSPanel1.Caption = "Rebuilding sequences"
    ReDim RedoDist(NextNo + 100)
    
    If (RelX > 0 Or RelY > 0) And EN > 0 Then
        
        
        ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + 1)
        
        '710
        oNextno = NextNo
        
        
        
        
        ReDim S2TraceBack(NextNo)
        
        Dim ExcludeExempt As Byte
        ExcludeExempt = 0
        For x = 0 To NextNo
            S2TraceBack(x) = x
        Next x
        For x = 0 To 255
            Close #x
        Next x
        Dim TELong As Long, TEString As String, SSBak() As Long, PSeq As Long, IntoSomeExtras As Byte
        
        ReDim SSBak(Len(StrainSeq(0)))
        Dim UBS2 As Long
        UBS2 = UBound(Steps, 2)
        'XX = UBound(MissingData, 2)
        IntoSomeExtras = 0
        
        XX = PermNextno
        XX = NextNo
        ReDim MissingData(Len(StrainSeq(0)), NextNo)
        For x = 0 To StepNo
            
            If x <= UBS2 Then
                If Abs(Steps(4, x)) <= EN And Abs(Steps(4, x)) > 0 Then
                
'                    If Steps(4, x) = 34 Then
'                        'XX = Daught(33, 0)
'                        If Steps(1, x) = 0 Then
'                            x = x
'                        End If
'                    Else
'                        x = x
'                    End If
                    If Steps(0, x) = 6 Then
                        
                        NextNo = PermNextno
                        If UBound(RedoDist) <> NextNo Then
                            ReDim Preserve RedoDist(NextNo)
                        End If
                        If UBound(TreeTrace) <> NextNo Then
                            ReDim Preserve TreeTrace(NextNo)
                        End If
                        If UBound(CurrentXOver) <> NextNo Then
                            ReDim Preserve CurrentXOver(NextNo)
                        End If
                        If UBound(Daught, 2) <> NextNo Then
                            ReDim Preserve Daught(SEventNumber, NextNo)
                        End If
                        If UBound(MinorPar, 2) <> NextNo Then
                            ReDim Preserve MinorPar(SEventNumber, NextNo)
                        End If
                        If UBound(MajorPar, 2) <> NextNo Then
                            ReDim Preserve MajorPar(SEventNumber, NextNo)
                        End If
                        If UBound(OriginalName) <> NextNo Then
                            ReDim Preserve OriginalName(NextNo)
                        End If
                        If UBound(SeqNum, 2) <> NextNo Then
                            ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
                        End If
                        If UBound(MissingData, 2) <> NextNo Then
                            ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
                        End If
                        If UBound(PermOriginalName) <> NextNo Then
                            ReDim Preserve PermOriginalName(NextNo)
                        End If
                        If UBound(ONameLen) <> NextNo Then
                            ReDim Preserve ONameLen(NextNo)
                        End If
                        
                        If x = 1234567890 Then
                            If x = 1234567890 Then
                                For Y = x + 1 To StepNo
                                    If Steps(4, Y) >= EN Then Exit For
                                    If Steps(0, Y) = 2 And Steps(1, Y) <= PermNextno Then
                                        
                                        Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, Y), Steps(2, Y), Steps(3, Y), SeqNum(0, 0), MissingData(0, 0))
                                        RedoDist(Steps(1, Y)) = 1
                                    End If
                                Next Y
                            Else
                                'reset seqnum
                                ReDim MissingData(Len(StrainSeq(0)), NextNo)
                                If PermSeqNumInFile = 1 Then
                                    oDirX = CurDir
                                    ChDrive App.Path
                                    ChDir App.Path
                                    FF = FreeFile
                                    ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
                                    Open "RDP5PSNFile" + UFTag For Binary As #FF
                                    Get #FF, , SeqNum
                                    Close #FF
                                    ChDrive oDirX
                                    ChDir oDirX
                                    If DebuggingFlag < 2 Then On Error Resume Next
                                    ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
                                    On Error GoTo 0
                                Else
                                    If DebuggingFlag < 2 Then On Error Resume Next
                                    ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
                                    On Error GoTo 0
                                    Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
                                End If
                                If x = 12345678 Then 'maybe erase bits from the anchor sequence
                                    'find the anchor sequence
                                    Dim DCV1 As Long, DCV2 As Long, mP As Long
                                    Call SplitP(-XoverList(RelX, RelY).BeginP, DCV1, DCV2)
                                    mP = WhereIsExclude(DCV1)
                                    
                                    For Y = x + 1 To StepNo
                                        If Steps(4, Y) >= EN Then Exit For
                                        If Steps(0, Y) = 2 And Steps(1, Y) = mP Then
                                            'XX = OriginalName(Steps(1, Y)) '3193-1800(99),2451-3028(184), 1858-2248(202)
                                            Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, Y), Steps(2, Y), Steps(3, Y), SeqNum(0, 0), MissingData(0, 0))
                                            RedoDist(Steps(1, Y)) = 1
                                        End If
                                    Next Y
                                End If
                            End If
                        End If
                        
                        If x = x Then
                        'quickly get to the steps(4,x) that equals EN
                            For Y = x + 1 To StepNo
                                If Steps(4, Y) = EN + 1 Then
                                    'XX = Steps(0, Y)
                                    
                                    Exit For
                                End If
                            Next Y
                            'now scan backwards to the last steps(0,y) that equals 6
                            For Z = Y To 0 Step -1
                                If Steps(0, Z) = 6 Then
                                    x = Z
                                    Exit For
                                End If
                            Next Z
                            x = x
                        End If
                    ElseIf Steps(0, x) = 1 Then 'ie make a sequence
                        NextNo = NextNo + 1
                        If NextNo > UBound(RedoDist, 1) Then
                            ReDim Preserve RedoDist(NextNo + 100)
                        End If
                        
                        UB = UBound(MissingData, 2)
                        
                        If NextNo < 50 Then
                            ExtraBit = NextNo
                        Else
                            ExtraBit = 50
                        End If
                         
                        If NextNo > UB Then '3204,3255,3306,3357
                        '
                            ReDim Preserve TreeTrace(NextNo + ExtraBit)
                            ReDim Preserve CurrentXOver(NextNo + ExtraBit)
                            ReDim Preserve OriginalName(NextNo + ExtraBit)
                            If (Len(StrainSeq(0)) * (NextNo + ExtraBit)) > (MemPoc * 10000) Then
                                FF = FreeFile
                                Open "tmp1" + UFTag For Binary As #FF
                                Put #FF, , SeqNum
                                Close #FF
                                Open "tmp2" + UFTag For Binary As #FF
                                Put #FF, , MissingData
                                Close #FF
                                Open "tmp3" + UFTag For Binary As #FF
                                Put #FF, , Daught
                                Close #FF
                                Erase SeqNum
                                Erase MissingData
                                Erase Daught
                                ReDim SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                Open "tmp1" + UFTag For Binary As #FF
                                Get #FF, , SeqNum
                                Close #FF
                                ReDim MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                Open "tmp2" + UFTag For Binary As #FF
                                Get #FF, , MissingData
                                Close #FF
                                ReDim Daught(SEventNumber, NextNo + ExtraBit)
                                Open "tmp3" + UFTag For Binary As #FF
                                Get #FF, , Daught
                                Close #FF
                                Kill "tmp1" + UFTag
                                Kill "tmp2" + UFTag
                                Kill "tmp3" + UFTag
                                
                            Else
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve Daught(SEventNumber, NextNo + ExtraBit)
                            End If
                            If NextNo > PermNextno Then
                                ReDim Preserve PermOriginalName(NextNo + ExtraBit)
                                ReDim Preserve ONameLen(NextNo + ExtraBit)
                            End If
                        End If
                        If NextNo > UBound(S2TraceBack, 1) Then
                            ReDim Preserve S2TraceBack(NextNo + 10)
                        End If
                        If Steps(2, x) < 0 Then
                            IntoSomeExtras = 1
                            oDirX = CurDir
                            ChDrive App.Path
                            ChDir App.Path
                            FF = FreeFile
                            Open "RDP5ExcludeList" + UFTag For Binary As #FF
                            Get #FF, Abs(Steps(2, x)), TELong 'Original number of the sequence that this unexcluded sequence  is most similar to
                            Get #FF, , TELong 'the original sequence number'18,30,33,42,45,46//16,17,29,31,44
                           
                            Get #FF, , TELong 'discard number
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            OriginalName(NextNo) = Trim(TEString)
                            ONameLen(NextNo) = Len(OriginalName(NextNo))
                            PermOriginalName(NextNo) = Trim(TEString)
                            If UBound(StraiName) < NextNo Then ReDim Preserve StraiName(NextNo)
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            StraiName(NextNo) = Trim(TEString)
                            Get #FF, , TELong 'seqeunec length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'sequence
                            'XX = Seq1
                            Close #FF
                            ChDrive oDirX
                            ChDir oDirX
                            ExcludeExempt = 1
                            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                            'there is sequence compression and the loaded sequence needs to be modified accordingly
                               TEString = CompressTEString(Decompress(), TEString)
                            End If
                            Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), UCase(TEString), SSBak(0))
                            If UBound(StrainSeq, 1) < NextNo Then ReDim Preserve StrainSeq(NextNo)
                            StrainSeq(NextNo) = UCase(TEString)
'                            For A = 0 To Len(StrainSeq(0))
'                                MissingData(A, Nextno) = 0
'                            Next A
'                            If Nextno = Seq3 Then
'                                x = x
'                            End If
'                            If Nextno = 246 Then
'                                x = x
'                            End If
                            For A = 0 To Len(StrainSeq(0))
                                'If SeqNum(A, PSeq) < 50 Then SeqNum(A, Nextno) = SeqNum(A, PSeq) 'make sure all the masking is consistent
                                MissingData(A, NextNo) = MissingData(A, RelX)
                                
                                'If SeqNum(A, Nextno) < 50 Then MissingData(A, Nextno) = 1
                            Next A
'                            If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            'If Daught(EN, RelX) > 0 Then
                            Daught(EN, NextNo) = 7 'ELLite(5, x)
                            'End If
'                            If Nextno = 290 Then
'                                x = x
'                            End If
                            TreeTrace(NextNo) = NextNo
                            
                            RedoDist(NextNo) = 1
                            If NextNo > UBound(S2TraceBack, 1) Then
                                ReDim Preserve S2TraceBack(NextNo + 10)
                            End If
                            S2TraceBack(NextNo) = NextNo
                            
                        Else
                           
                            If Steps(1, x) < UBound(TreeTrace, 1) Then
                                OriginalName(NextNo) = OriginalName(TreeTrace(Steps(1, x))) 'x97704(6)
                                If NextNo > PermNextno Then ONameLen(NextNo) = Len(OriginalName(TreeTrace(Steps(1, x))))
                                Daught(EN, NextNo) = Daught(EN, Steps(1, x))
                                TreeTrace(NextNo) = TreeTrace(TreeTrace(Steps(1, x)))
                            End If
                            Dummy = ModSeqNumD(NextNo, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
'                             If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            S2TraceBack(NextNo) = S2TraceBack(TreeTrace(Steps(1, x)))
                        End If
                        RedoDist(NextNo) = 1
                       
                        
                        
                        RedoDist(Steps(1, x)) = 1
                    ElseIf Steps(0, x) = 2 Then  'delete some positions in sequence
'                        If IntoSomeExtras = 1 Then
'                            XX = EN
'                            Daught(Steps(4, x), Steps(1, x)) = 1
'                        End If
                        'XX = OriginalName(Steps(1, x))'2630-4018 in seq 6/???,1412-2100 in seq24,25,26,27,28
                        Dummy = ModSeqNumE(NextNo, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
'                        If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                        RedoDist(NextNo) = 1
                    ElseIf Steps(0, x) = 3 Then 'delete a sequence
'                        If Nextno = 828 Then
'                            X = X
'                        End If
'                            If Steps(1, x) = 232 Then
'                                x = x
'                            End If
'                            If TreeTrace(TreeTrace(Steps(1, x))) = 85 Then
'                                x = x
'                            End If
                            'If (TreeTrace(TreeTrace(Steps(1, x))) <> Seq1 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq2 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq3) Or IntoSomeExtras = 1 Then
                                If Steps(1, x) <= NextNo Then
                                    If Steps(1, x) < NextNo Then
                                        
                                        Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
    '                                    If SeqNum(1780, Seq3) = 46 Then
    '                                    XX = Steps(4, x)
    '                                x = x
    '                            End If
                                        Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
                                        TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
                                        'XX = TreeTrace(TreeTrace(Steps(1, X)))
                                        OriginalName(Steps(1, x)) = OriginalName(NextNo)
                                        S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
                                        RedoDist(Steps(1, x)) = RedoDist(NextNo)
                                        RedoDist(NextNo) = 0
                                        
                                        
                                    Else
                                        Daught(EN, NextNo) = 0
                                    End If
    '                                If Nextno > 226 Then
    '                                    XX = PermNextno
    '                                    x = x
    '                                End If
                                    NextNo = NextNo - 1
                                End If
                                'XX = TreeTrace(Nextno)
'                            ElseIf Seq1 > PermNextno Or Seq2 > PermNextno Or Seq3 > PermNextno Then
'                                If Steps(1, x) < NextNo Then
'
'                                    Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
''                                    If SeqNum(1780, Seq3) = 46 Then
''                                x = x
''                            End If
'                                    Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
'                                    TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                                    'XX = TreeTrace(TreeTrace(Steps(1, X)))
'                                    OriginalName(Steps(1, x)) = OriginalName(NextNo)
'                                    RedoDist(Steps(1, x)) = RedoDist(NextNo)
'                                    RedoDist(NextNo) = 0
'                                    S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
'                                Else
'                                    Daught(EN, NextNo) = 0
'                                End If
''                                If Nextno = 226 Then
''                                    x = x
''                                End If
'                                NextNo = NextNo - 1
'                            End If
                    ElseIf Steps(0, x) = 4 Then 'replace a sequence
'                        If Steps(1, x) = 232 Then
'                                x = x
'                            End If
'                            If TreeTrace(TreeTrace(Steps(1, x))) = 85 Then
'                                x = x
'                            End If
                        XX = TreeTrace(TreeTrace(Steps(1, x)))
                        'If (TreeTrace(TreeTrace(Steps(1, x))) <> Seq1 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq2 And TreeTrace(TreeTrace(Steps(1, x))) <> Seq3) Or IntoSomeExtras = 1 Then
                            Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
'                            If SeqNum(1780, Seq3) = 46 Then
'                                x = x
'                            End If
                            Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
                            OriginalName(Steps(1, x)) = OriginalName(NextNo)
                            RedoDist(Steps(1, x)) = RedoDist(NextNo)
                            RedoDist(NextNo) = 0
                            S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
                            TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                            If Nextno = 226 Then
'                                    x = x
'                                End If
'                            NextNo = NextNo - 1
'                        ElseIf Seq1 > PermNextno Or Seq2 > PermNextno Or Seq3 > PermNextno Then
'                            Dummy = ReplaceSeq(NextNo, Len(StrainSeq(0)), Steps(1, x), NextNo, SeqNum(0, 0), MissingData(0, 0))
'                            Daught(EN, Steps(1, x)) = Daught(EN, NextNo)
'                            OriginalName(Steps(1, x)) = OriginalName(NextNo)
'                            RedoDist(Steps(1, x)) = RedoDist(NextNo)
'                            RedoDist(NextNo) = 0
'                            S2TraceBack(Steps(1, x)) = S2TraceBack(NextNo)
'                            TreeTrace(Steps(1, x)) = TreeTrace(TreeTrace(NextNo))
'                            NextNo = NextNo - 1
                        'End If
                    End If
                Else
                    Exit For
                    
                End If
            End If
            
            
            'If NextNo = 27 Then
'            For Z = 1 To Len(StrainSeq(0))
'                If MissingData(Z, Nextno) = 0 Then '30=n,31=w
'                    XX = TreeTrace(Nextno)
'                End If
'            Next Z
'                x = x
                'xx==tracsub(
            'End If
            
        Next x
        
        
'        XX = SeqNum(1780, Seq3)
'                            XX = MissingData(1780, Seq3)
'                            XX = Mid$(TEString, 1780, 20)
        
        'XX = PermNextno
        XX = NextNo - PermNextno
        
        tNextno = NextNo
        If IntoSomeExtras = 1 Then
            ReDim Preserve MinorPar(UBound(MinorPar, 1), NextNo)
            ReDim Preserve MajorPar(UBound(MajorPar, 1), NextNo)
            ReDim Preserve Daught(UBound(Daught, 1), NextNo)
            For x = 0 To UBound(EventsInExcludeds, 2)
                XX = UBound(Daught, 2)
                If EventsInExcludeds(1, x) = -EN And EventsInExcludeds(2, x) <= NextNo Then
                    If EventsInExcludeds(0, x) = 3 Then
                        Daught(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                        MajorPar(EN, EventsInExcludeds(2, x)) = 0
                        MinorPar(EN, EventsInExcludeds(2, x)) = 0
                    End If
                    If EventsInExcludeds(0, x) = 1 Then
                        MajorPar(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                        'Daught(EN, EventsInExcludeds(2, x)) = 0
                        MinorPar(EN, EventsInExcludeds(2, x)) = 0
                        
                    End If
                    If EventsInExcludeds(0, x) = 2 Then
                        MinorPar(EN, EventsInExcludeds(2, x)) = EventsInExcludeds(5, x)
                        'Daught(EN, EventsInExcludeds(2, x)) = 0
                        MajorPar(EN, EventsInExcludeds(2, x)) = 0
                        
                    End If
                End If
            Next x
'            If BusyWithExcludes = 1 Then
'                If RList(WinPP, WinPPY) > RList(WinPP, WinPPY) > PermNextno Then
'                'For Y = 0 To RNum(x)
'                    ExcludedEventNum = ExcludedEventNum + 1
'                    If ExcludedEventNum > UBound(EventsInExcludeds, 2) Then
'                        ReDim Preserve EventsInExcludeds(5, ExcludedEventNum + 100)
'                    End If
'                    EventsInExcludeds(0, ExcludedEventNum) = WinPP
'                    EventsInExcludeds(1, ExcludedEventNum) = SEventNumber
'                    EventsInExcludeds(2, ExcludedEventNum) = RList(WinPP, WinPPY) 'the number of the sequence at this time
'                    EventsInExcludeds(3, ExcludedEventNum) = CurSeedExtras 'sequence this exclude is most similar to in the includedlist
'                    EventsInExcludeds(4, ExcludedEventNum) = OriginalPos(RList(WinPP, WinPPY)) 'original number of this sequence
'                    If MinP > LowestProb Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 5
'                    ElseIf (RCorr(WinPP, 0, TWinner) < 0.83 And RCorr(WinPP, 1, TWinner) < 0.83) Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0 And BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 4
'                    ElseIf RCorr(WinPP, 0, TWinner) < 0.83 Or (BreaksExist(WinPP, 0, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 2
'                    ElseIf RCorr(WinPP, 1, TWinner) < 0.83 Or (BreaksExist(WinPP, 1, TraceSub(RList(WinPP, WinPPY))) = 0) Then
'                        EventsInExcludeds(5, ExcludedEventNum) = 3
'                    Else
'                        EventsInExcludeds(5, ExcludedEventNum) = 1
'                    End If
'                End If
'            'Next Y
'
'            End If
        
        End If
'        For Z = 1 To Len(StrainSeq(0))
'            If MissingData(Z, NextNo - 2) = 1 Then
'                x = x
'            End If
'        Next Z
        'XX = MissingData(3000, 15)
'        XX = Nextno
'        XX = OriginalName(11)
'        XX = OriginalName(12)
'        XX = OriginalName(13)
        'XX = XoverList(RelX, RelY).Daughter
        If ExcludedEventNum > 0 And DontLoadExcludes = 0 And ExcludeExempt = 0 Then
            
            If UBound(ELLite, 2) = 0 Then
                Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
            End If
            
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            '3428 (793,213 - se=64,154),5883 (2601,727 - se = 99),1947 (359,93 se = 25,48,49), *3279 (3279,869 se = 192), 6659(2460,689 se = 99,163)

            If Dir("RDP5ExcludeList" + UFTag) <> "" Then
                ReDim SSBak(Len(StrainSeq(0)))
                ReDim Excludetrace(NextnoBak)
                For x = 0 To UBound(ELLite, 2)
                    If ELLite(3, x) <= UBound(Daught, 2) Then
                        If EN = ELLite(1, x) And Daught(EN, ELLite(3, x)) > 0 Then
                            
                            NextNo = NextNo + 1
                            Excludetrace(NextNo) = x
                            If NextNo > UBound(RedoDist, 1) Then
                                ReDim Preserve RedoDist(NextNo + 100)
                            End If
                            
                            
                            
                            UB = UBound(MissingData, 2)
                            If NextNo < 50 Then
                                ExtraBit = NextNo
                            Else
                                ExtraBit = 50
                            End If
                            
                            If NextNo > UB Then '3204,3255,3306,3357
                            '
                                ReDim Preserve TreeTrace(NextNo + ExtraBit)
                                ReDim Preserve CurrentXOver(NextNo + ExtraBit)
                                ReDim Preserve Daught(SEventNumber, NextNo + ExtraBit)
                                ReDim Preserve OriginalName(NextNo + ExtraBit)
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo + ExtraBit)
                                ReDim Preserve StraiName(NextNo + ExtraBit)
                                If NextNo > PermNextno Then
                                    ReDim Preserve PermOriginalName(NextNo + ExtraBit)
                                    'ReDim Preserve OriginalName(NextNo + ExtraBit)
                                    ReDim Preserve ONameLen(NextNo + ExtraBit)
                                End If
                            End If
                            
                            FF = FreeFile
                            Open "RDP5ExcludeList" + UFTag For Binary As #FF
                            PSeq = ELLite(3, x)
                            Get #FF, ELLite(2, x), TELong 'the original number of the sequence this sequence is most similar to
                            Get #FF, , TELong 'the original sequence number'3176,3279
                           
                            Get #FF, , TELong 'discard number
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            OriginalName(NextNo) = Trim(TEString)
                            ONameLen(NextNo) = Len(OriginalName(NextNo))
                            PermOriginalName(NextNo) = Trim(TEString)
                            If UBound(StraiName) < NextNo Then ReDim Preserve StraiName(NextNo)
                            Get #FF, , TELong 'name length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'name
                            StraiName(NextNo) = Trim(TEString)
                            Get #FF, , TELong 'seqeunec length
                            TEString = String(TELong, " ")
                            Get #FF, , TEString 'sequence
                            If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                            'there is sequence compression and the loaded sequence needs to be modified accordingly
                               TEString = CompressTEString(Decompress(), TEString)
                            End If
                            Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), UCase(TEString), SSBak(0))
'                            XX = SeqNum(1455, Nextno)
'                            For Z = 1300 To Len(StrainSeq(0))
'                                If SeqNum(Z, Nextno) > 46 Then
'                                    x = x
'                                End If
'                            Next Z
                            For A = 0 To Len(StrainSeq(0))
                                If SeqNum(A, PSeq) < 50 Then SeqNum(A, NextNo) = SeqNum(A, PSeq) 'make sure all the masking is consistent
                                MissingData(A, NextNo) = MissingData(A, PSeq)
'                                If SeqNum(A, NextNo) < 50 Then MissingData(A, NextNo) = 1
                            Next A
                            Daught(EN, NextNo) = ELLite(5, x)
                            TreeTrace(NextNo) = NextNo
                            
                            RedoDist(NextNo) = 1
                            If NextNo > UBound(S2TraceBack, 1) Then
                                ReDim Preserve S2TraceBack(NextNo + 10)
                            End If
                            S2TraceBack(NextNo) = NextNo
                            Close #FF
                        End If
                    End If
                    If NextNo > MemPoc * 1.25 Then Exit For
                Next x
            Else
                ReDim Excludetrace(NextNo)
                
            End If
            
            ChDrive oDirX
            ChDir oDirX
        Else
            ReDim Excludetrace(NextNo)
        End If
        
        Dim MissNt As Long
        
        
        '@
        For x = 0 To NextNo
            MissNt = 0
            For Y = 1 To Len(StrainSeq(0))
                If SeqNum(Y, x) < 50 Then
                    MissNt = MissNt + 1
                    If MissNt > 10 Then
                        MissingData(Y, x) = 1
                    ElseIf MissNt = 10 Then
                        For Z = Y - 10 To Y
                            MissingData(Z, x) = 1
                        Next Z
                    End If
                Else
                    MissNt = 0
                End If
            Next Y
        
        Next x
        If tNextno < NextNo Then
            If UBound(TreeTrace, 1) < NextNo Then
                ReDim Preserve TreeTrace(NextNo)
            End If
            For x = tNextno + 1 To NextNo
                TreeTrace(x) = x
            Next x
        End If
        
    End If
     
   ' XX = Nextno
    ZZ = 0
    Dim ReplaceFlag As Byte
    
    
    
    
    '710
    
    If BPos <> Epos Then
        x = 0
        'get rid of some empty sequences here - it should massively speed up the distance matrix calculations
        For x = 0 To NextNo
            ReplaceFlag = 0
            If BPos < Epos Then
                GoOn = 0
                For Y = BPos To Epos
                    If SeqNum(Y, x) <> 46 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                If GoOn = 1 Then
                    GoOn = 0
                    For Y = 1 To BPos
                        If SeqNum(Y, x) <> 46 Then
                            GoOn = 1
                            Exit For
                        End If
                    Next Y
                    If GoOn = 0 Then
                        For Y = Epos To Len(StrainSeq(0))
                            If SeqNum(Y, x) <> 46 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Y
                        If GoOn = 0 Then
                            ReplaceFlag = 1
                        End If
                    End If
                Else
                    ReplaceFlag = 1
                End If
            Else
                GoOn = 0
                For Y = Epos To BPos
                    If SeqNum(Y, x) <> 46 Then
                        GoOn = 1
                        Exit For
                    End If
                Next Y
                If GoOn = 1 Then
                    GoOn = 0
                    For Y = 1 To Epos
                        If SeqNum(Y, x) <> 46 Then
                            GoOn = 1
                            Exit For
                        End If
                    Next Y
                    If GoOn = 0 Then
                        For Y = BPos To Len(StrainSeq(0))
                            If SeqNum(Y, x) <> 46 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next Y
                        If GoOn = 0 Then
                            ReplaceFlag = 1
                        End If
                    End If
                Else
                    ReplaceFlag = 1
                End If
            End If
            If ReplaceFlag = 1 Then '323,660
                RedoDist(x) = -1
                ZZ = ZZ + 1
            End If
            
        Next x
    End If
    
    
    
    

    '710
     If NextNo > PermNextno Then
         ReDim Preserve TreeTrace(NextNo), CurrentXOver(NextNo), Daught(SEventNumber, NextNo), OriginalName(NextNo), SeqNum(Len(StrainSeq(0)), NextNo), MissingData(Len(StrainSeq(0)), NextNo)
       
     End If
    
    
    'make sure all the maskseq info is preserved
     '710
     ReDim Preserve MaskSeq(NextNo)
     For x = 0 To NextNo
        If TreeTrace(x) <= UBound(MaskSeq, 1) Then
            MaskSeq(x) = MaskSeq(TreeTrace(x))
        End If
     Next x
     
     If DebuggingFlag < 2 Then On Error Resume Next
    If UBound(SeqCol, 1) < NextNo Or UBound(FFillCol, 1) < NextNo Then
        ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
    End If
    
    If UBound(XCord, 3) < NextNo + 2 Or UBound(YCord, 3) < NextNo + 2 Or UBound(RYCord, 3) < NextNo + 2 Then
        ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
    
    End If
    
    On Error GoTo 0
    
     If UBound(OriginalName, 1) < NextNo Then
        ReDim Preserve OriginalName(NextNo)
     End If
         
         
     
     'the number of sequences has changed and distances need to be recalculated for the sequences that have been modified
     'ReDim PermDiffs(Nextno, Nextno), PermValid(Nextno, Nextno)
    '710
    If NextNo <> UBound(Distance, 1) Then
        ReDim Distance(NextNo, NextNo) 'WARNING - removing this will make the program super unstable
        ReplaceDistsFlag = 1
    End If
    '710
     If BPos <> Epos Then
     
        If NextNo > 1000 Then 'get rid of masked sequences (except those in daught)
            For x = 0 To NextNo
                If MaskSeq(x) = 1 And Daught(EN, x) = 0 Then
                    RedoDist(x) = -1 'make sure it is not calculated in either the smat or the fmat
                End If
                
            Next x
            
        End If

        Dim BPX As Long, EPX As Long
        BPX = BPos: EPX = Epos
        '710
        'XX = UBound(RedoDist)
        Call MakeSFMats(NextNo, BPX, EPX, FMat(), SMat(), SubValid(), SubDiffs(), PermValid(), PermDIffs(), SeqNum(), RedoDist())
        
        '884 but spikes at ~1200
        
        BPos = BPX: Epos = EPX
        
     Else
        Dim tRedoDist() As Integer
        
        ReDim tRedoDist(NextNo)
        
        For x = 0 To NextNo
            tRedoDist(x) = 1
        Next x
        
        'Dim AvDst As Double, UDst As Double
        ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo), Distance(NextNo, NextNo)
        Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, PermDIffs(), PermValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
        
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            UBPermValid = UBound(PermValid, 1)
            Open "RDP5PermValid" + UFTag For Binary As #FF
            Put #FF, , PermValid()
            Close #FF
            
            UBPermDiffs = UBound(PermDIffs, 1)
            Open "RDP5PermDiffs" + UFTag For Binary As #FF
            Put #FF, , PermDIffs()
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        
     End If
     
     DistanceFlag = 1
     EditSeqFlag = 1

     If uSeqNuminFile = 1 Then
        If UBuMD2 = NextNo Then
            ReDim uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
        End If
     End If
     
     If UBound(uMissingData, 2) <> NextNo Then
        ReDim uTreeTrace(NextNo)
        '987
        ReDim uDaught(SEventNumber, NextNo)
        '995
        '
        ReDim uOriginalName(NextNo), uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
        '1097
        ReDim Preserve uSeqCol(NextNo), uFFillCol(NextNo)
        
        ReDim Preserve uOriginalName(NextNo)
     End If
     Dim UB1 As Long, UB2 As Long
     If DebuggingFlag < 2 Then On Error Resume Next
     UB1 = -1
     UB1 = UBound(uDaught, 1)
     UB2 = -1
     UB2 = UBound(Daught, 1)
     On Error GoTo 0
     If UB1 > -1 And UB2 > -1 Then
         If UB1 <> UB2 Then
            If UB = 0 Then
         
                ReDim uDaught(UBound(Daught, 1), UBound(Daught, 2))
                For x = 0 To UBound(Daught, 1)
                    'If X <= UBound(uDaught, 1) Then
                        For Y = 0 To UBound(Daught, 2)
                            uDaught(x, Y) = Daught(x, Y)
                        Next Y
                    'End If
                Next x
            Else
                Dim tDaught() As Byte
                
                UBU = UBound(uDaught, 1)
                UB = UBound(Daught, 1)
                If UBU >= UB Then
                    ReDim tDaught(UBound(uDaught, 1), NextNo)
                    x = x
                Else
                    ReDim tDaught(UBound(Daught, 1), NextNo)
                    x = x
                End If
                For x = 0 To UBound(uDaught, 1)
                    'If X <= UBound(uDaught, 1) Then
                    For Y = 0 To NextNo
                        tDaught(x, Y) = uDaught(x, Y)
                    Next Y
                    'End If
                Next x
                 ReDim uDaught(UBound(Daught, 1), NextNo)
                For x = 0 To UBound(Daught, 1)
                    
                    For Y = 0 To NextNo
                        uDaught(x, Y) = tDaught(x, Y)
                    Next Y
                Next x
            End If
        End If
    End If
    If SPF = 0 Then
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
   
    
    'Make sure that the bounds of Treedistance are correct
    If UBound(TreeDistance, 1) <> NextNo Then
        UB = UBound(TreeDistance, 1)
        ReDim uTreeDistance(UB, UB)
        For x = 0 To UB
            For Y = 0 To UB
                uTreeDistance(x, Y) = TreeDistance(x, Y)
            Next Y
        Next x
        ReDim TreeDistance(NextNo, NextNo)
        If UB > NextNo Then UB = NextNo
        
        For x = 0 To UB
            For Y = 0 To UB
                TreeDistance(x, Y) = uTreeDistance(x, Y)
            Next Y
        Next x
    
    End If
   
    'Dump uDistance and uTreeDistance to Disk
    
    
    
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    UBuDist = UBound(Distance, 1)
    UBuTDist = UBound(TreeDistance, 1)
'    ReDim TestTreeDist(UBuTDist, UBuTDist)
'    ReDim TestDist(UBuTDist, UBuTDist)
'    For X = 0 To UBuTDist
'        For Y = 0 To UBuTDist
'            TestDist(X, Y) = Distance(X, Y)
'            TestTreeDist(X, Y) = TreeDistance(X, Y)
'        Next Y
'
'    Next X
    'replace top half of utreedistance with distance
'    SS = abs(gettickcount)
'    If X = X Then
'        If X = X Then
            Erase uTreeDistance
            
            ReDim IntTD(UBuTDist, UBuTDist)
            
'            If X = X Then
'                SS = abs(gettickcount)
                Dummy = FillIntTD(UBuTDist, MinDist, MinTDist, AdjustD, AdjustTD, IntTD(0, 0), Distance(0, 0), TreeDistance(0, 0))
'                EE = abs(gettickcount)
'                TT = EE - SS
'                X = X
                '0.6048775
                '0.8124499
'            Else
'
'                MaxDist = -10000
'                MinDist = 10000
'                MaxTDist = -10000
'                MinTDist = 10000
'                For X = 0 To UBuTDist
'                    For Y = X + 1 To UBuTDist
'                        If Distance(X, Y) > MaxDist Then MaxDist = Distance(X, Y)
'                        If Distance(X, Y) < MinDist Then MinDist = Distance(X, Y)
'                        If TreeDistance(X, Y) > MaxTDist Then MaxTDist = TreeDistance(X, Y)
'                        If TreeDistance(X, Y) < MinTDist Then MinTDist = TreeDistance(X, Y)
'                    Next Y
'                Next X
'
'                IntervalD = MaxDist - MinDist
'                'Compressed distance
'                AdjustD = 64000 / IntervalD
'
'                IntervalTD = MaxTDist - MinTDist
'                'Compressed distance
'                AdjustTD = 64000 / IntervalTD
'                For X = 0 To UBuTDist
'                    For Y = X + 1 To UBuTDist
'                        IntTD(X, Y) = CLng((Distance(X, Y) - MinDist) * AdjustD) - 32000
'                        X = X
'                    Next Y
'                Next X
'                For X = 1 To UBuTDist
'                    For Y = 0 To X - 1
'                        IntTD(X, Y) = CLng((TreeDistance(X, Y) - MinTDist) * AdjustTD) - 32000
'                    Next Y
'                Next X
'            End If
            FF = FreeFile
'            SS = abs(gettickcount)
            '@
            Open "RDP5uDuTD" + UFTag For Binary As #FF
            '@
            Put #FF, , IntTD()
            
            
            Close #FF
            Erase IntTD
'            EE = abs(gettickcount)
'            TT = EE - SS
'            X = X
            'this is about 5 times quicker than the old version
'        Else
'           ' SS = abs(gettickcount)
'            ReDim uTreeDistance(UBuTDist, UBuTDist)
'            For X = 0 To UBuTDist
'                For Y = X + 1 To UBuTDist
'                    uTreeDistance(X, Y) = Distance(X, Y)
'
'                Next Y
'            Next X
'
'            For X = 1 To UBuTDist
'                For Y = 0 To X - 1
'                    uTreeDistance(X, Y) = TreeDistance(X, Y)
'                Next Y
'            Next X
'    '        EE = abs(gettickcount)
'    '        TT = EE - SS
'
'
'
'            FF = FreeFile
'    '        SS = abs(gettickcount)
'            Open "RDP5uDuTD" + UFTag For Binary As #FF
'            ''''
'            Put #FF, , uTreeDistance()
'            Close #FF
'            Erase uTreeDistance
'    '        EE = abs(gettickcount)
'    '        TT = EE - SS
'    '        X = X
'        End If
'    SS = abs(gettickcount)
'    Else
'        FF = FreeFile
'        Open "RDP5uDistance" + UFTag For Binary As #FF
'        ''''
'        Put #FF, , Distance()
'        Close #FF
'        If SPF = 0 Then
'            Form1.Refresh
'            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'        End If
'        Open "RDP5uTreeDistance" + UFTag For Binary As #FF
'        '''
'        Put #FF, , TreeDistance()
'
'        Close #FF
'    End If
'    EE = abs(gettickcount)
'    TT = EE - SS
'    X = X

    
    If SPF = 0 And DontRefreshFlag = 0 Then
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    ChDir oDir
    ChDrive oDir
    uDistanceInFIleFlag = 1 ' it will always be 1
    
    If DebuggingFlag < 2 Then On Error Resume Next
    SE = -1
    SE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(SeqNum, 2)
    On Error GoTo 0
    If SE > -1 And UB2 > -1 Then
        If uSeqNuminFile = 1 And UB < 1 Then
            For x = 0 To NextNo
                uTreeTrace(x) = TreeTrace(x)
                uDaught(SE, x) = Daught(SE, x)
                uSeqCol(x) = SeqCol(x)
                uFFillCol(x) = FFillCol(x)
                
            Next x
            
            ReDim uSeqNum(Len(StrainSeq(0)), NextNo), uMissingData(Len(StrainSeq(0)), NextNo)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5uSeqnum" + UFTag For Binary As #FF
            Get #FF, , uSeqNum
            Close #FF
            Open "RDP5uMissingData" + UFTag For Binary As #FF
            Get #FF, , uMissingData
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
           '@
            If SE > -1 Then
                    Dummy = MakeuBackups(Len(StrainSeq(0)), SE, UBound(Daught, 1), NextNo, uMissingData(0, 0), MissingData(0, 0), uSeqNum(0, 0), SeqNum(0, 0), uFFillCol(0), FFillCol(0), uSeqCol(0), SeqCol(0), uDaught(0, 0), Daught(0, 0), uTreeTrace(0), TreeTrace(0))
            End If
        End If
    End If
     
     For x = 0 To NextNo
        uOriginalName(x) = OriginalName(x)
     Next x
     uNextno = NextNo
    
Else
    


    NextNo = uNextno
    'ModSeqNumFlag = 2 'i.e. the sequences were no reedited
    If NextNo > PermNextno Then
        ReDim Preserve TreeTrace(NextNo)
        ReDim Preserve CurrentXOver(NextNo)
        ReDim Preserve Daught(SEventNumber, NextNo)
        ReDim Preserve OriginalName(NextNo)
        If uSeqNuminFile = 0 Then
            ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
            ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
        End If
    End If
    
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB1 = -1
    UB1 = UBound(uDaught, 1)
    UB2 = -1
    UB2 = UBound(Daught, 1)
    On Error GoTo 0
    If UB1 > -1 And UB2 > -1 Then
        If UB1 <> UB2 Then
    
    
            ReDim tDaught(UBound(Daught, 1), NextNo)
            For x = 0 To UBound(Daught, 1)
                If x <= UBound(uDaught, 1) Then
                    For Y = 0 To NextNo
                        tDaught(x, Y) = uDaught(x, Y)
                    Next Y
                End If
            Next x
            ReDim uDaught(UBound(Daught, 1), NextNo)
            For x = 0 To UBound(Daught, 1)
                For Y = 0 To NextNo
                    uDaught(x, Y) = tDaught(x, Y)
                Next Y
            Next x
        End If
    End If
    'Dim X As Long
    
    If UBound(SeqCol, 1) < NextNo Then
        ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)
    End If
    
    If UBound(OriginalName, 1) < NextNo Then
        ReDim Preserve OriginalName(NextNo)
    End If
    'ssx = Abs(GetTickCount)
    If PermSeqNumInFile = 1 Then
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        '@
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    If uSeqNuminFile = 1 Then
        If PermSeqNumInFile = 0 Then
            ReDim uSeqNum(Len(StrainSeq(0)), UBuSN2)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5uSeqnum" + UFTag For Binary As #FF
            Get #FF, , SeqNum
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
        
        ReDim MissingData(Len(StrainSeq(0)), UBuMD2)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile

        Open "RDP5uMissingData" + UFTag For Binary As #FF
        Get #FF, , MissingData
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        'ReDim uSeqNum(0, 0), uMissingData(0, 0)
       
    End If

    If DebuggingFlag < 2 Then On Error Resume Next
    UBX = 0
    UBX = UBound(TreeTrace, 1)
    If UBX = 0 Then
        ReDim Preserve TreeTrace(NextNo + 100)
    End If
    On Error GoTo 0
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    
'    If X = X Then
'        SS = abs(gettickcount)
        ReDim IntTD(UBuTDist, UBuTDist)
        
        FF = FreeFile
        
        Open "RDP5uDuTD" + UFTag For Binary As #FF
        ''''
        Get #FF, , IntTD()
        Close #FF
        
        
        ReDim Distance(UBuTDist, UBuTDist)
        ReDim TreeDistance(UBuTDist, UBuTDist)
'        If X = X Then
           
            Dummy = ReadIntTD(UBuTDist, MinDist, MinTDist, AdjustD, AdjustTD, IntTD(0, 0), Distance(0, 0), TreeDistance(0, 0))
'            EE = abs(gettickcount)
'            TT = EE - SS
'            X = X
            
'            For X = 0 To UBuTDist
'                For Y = 0 To UBuTDist
'                    If X <> Y Then
'                        If Abs(TestDist(X, Y) - Distance(X, Y)) > 0.0001 Then
'                            X = X
'                        End If
'                        If Abs(TestTreeDist(X, Y) - TreeDistance(X, Y)) > 0.0001 Then
'                            X = X
'                        End If
'                    End If
'                Next Y
'
'            Next X
'            X = X
            
'        Else
'
'            For X = 0 To UBuTDist
'                For Y = X + 1 To UBuTDist
'                    Distance(X, Y) = ((CLng(IntTD(X, Y)) + 32000) / AdjustD) + MinDist
'                    Distance(Y, X) = Distance(X, Y)
'                Next Y
'            Next X
'
'            For X = 1 To UBuTDist
'                For Y = 0 To X - 1
'                    TreeDistance(X, Y) = ((CLng(IntTD(X, Y)) + 32000) / AdjustTD) + MinTDist
'                    TreeDistance(Y, X) = TreeDistance(X, Y)
'                Next Y
'            Next X
'        End If
        Erase IntTD
        
'    Else
'
'        'refill distance and treedistance
'        ReDim uTreeDistance(UBuTDist, UBuTDist)
'
'        FF = FreeFile
'        SS = abs(gettickcount)
'        Open "RDP5uDuTD" + UFTag For Binary As #FF
'        Get #FF, , uTreeDistance()
'        Close #FF
'        ReDim Distance(UBuTDist, UBuTDist)
'        For X = 0 To UBuTDist
'            For Y = X + 1 To UBuTDist
'                Distance(X, Y) = uTreeDistance(X, Y)
'                Distance(Y, X) = uTreeDistance(X, Y)
'            Next Y
'        Next X
'        ReDim TreeDistance(UBuTDist, UBuTDist)
'        For X = 1 To UBuTDist
'            For Y = 0 To X - 1
'                TreeDistance(X, Y) = uTreeDistance(X, Y)
'                TreeDistance(Y, X) = uTreeDistance(X, Y)
'            Next Y
'        Next X
'        EE = abs(gettickcount)
'        TT = EE - SS
'        Erase uTreeDistance
'    End If
'    ReDim Distance(UBuDist, UBuDist)
'    FF = FreeFile
'
'    Open "RDP5uDistance" + UFTag For Binary As #FF
'    Get #FF, , Distance()
'    Close #FF
'
'    ReDim TreeDistance(UBuTDist, UBuTDist)
'    Open "RDP5uTreeDistance" + UFTag For Binary As #FF
'    Get #FF, , TreeDistance()
'    Close #FF
    ChDir oDir
    ChDrive oDir
    If DebuggingFlag < 2 Then On Error Resume Next
    SE = -1
    SE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
    If SE > -1 And UB2 > -1 Then
        If uSeqNuminFile = 0 And PermSeqNumInFile = 0 Then
            Dummy = ReplaceuBackups(Len(StrainSeq(0)), SE, UBound(Daught, 1), NextNo, uMissingData(0, 0), MissingData(0, 0), uSeqNum(0, 0), SeqNum(0, 0), uFFillCol(0), FFillCol(0), uSeqCol(0), SeqCol(0), uDaught(0, 0), Daught(0, 0), uTreeTrace(0), TreeTrace(0))
        Else
        
            If PermSeqNumInFile = 1 Then
                'this is awkward - if useqnuminfile=1 then seqnum and missingdata are already filled
                'Dummy = ReplaceuBackups(Len(StrainSeq(0)), SE, UBound(Daught, 1), NextNo, MissingData(0, 0), MissingData(0, 0), SeqNum(0, 0), SeqNum(0, 0), uFFillCol(0), FFillCol(0), uSeqCol(0), SeqCol(0), uDaught(0, 0), Daught(0, 0), uTreeTrace(0), TreeTrace(0))
                For x = 0 To UBound(Daught, 1)
                    For Y = 0 To UBound(Daught, 2)
                        Daught(x, Y) = uDaught(x, Y)
                    Next Y
                Next x
                For x = 0 To UBound(SeqCol)
                    SeqCol(x) = uSeqCol(x)
                Next x
                For x = 0 To UBound(FFillCol)
                    FFillCol(x) = uFFillCol(x)
                Next x
                For x = 0 To UBound(TreeTrace)
                    TreeTrace(x) = uTreeTrace(x)
                Next x
                If uSeqNuminFile = 0 Then
                    For x = 0 To UBound(MissingData, 1)
                        For Y = 0 To UBound(MissingData, 2)
                            MissingData(x, Y) = uMissingData(x, Y)
                        Next Y
                    Next x
                End If
                
            End If
        End If
    End If
    For x = 0 To NextNo
        OriginalName(x) = uOriginalName(x)
    Next x
    ReDim Preserve MaskSeq(NextNo)
    For x = 0 To NextNo
        MaskSeq(x) = MaskSeq(TreeTrace(x))
    Next x

End If

'got to free up ram
If DebuggingFlag < 2 Then On Error Resume Next
UB = -1
UB = UBound(SeqNum, 2)
On Error GoTo 0

If UB > -1 Then 'if it is already on disk I dont see why it needs to be rewritten to the disk?
    If (((Len(StrainSeq(0)) + 3) * (NextNo + 1) * 4)) > 30000000 And uSeqNuminFile = 0 Then
        'if necessary write useqnum and umissingdata to disk
        Form1.SSPanel1.Caption = "Copying data to disk"
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        UBuSN2 = UBound(uSeqNum, 2)
        UBuMD2 = UBound(uMissingData, 2)
        uSeqNuminFile = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5uSeqnum" + UFTag For Binary As #FF
        '@
        Put #FF, , uSeqNum
        Close #FF
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        
        Open "RDP5uMissingData" + UFTag For Binary As #FF
        '@
        Put #FF, , uMissingData
        
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        ReDim uSeqNum(0, 0), uMissingData(0, 0)
        If SPF = 0 And DontRefreshFlag = 0 Then
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    Else
        uSeqNuminFile = 0
    End If
End If

'1111
'If Nextno > UBound(MissingData, 2) Then
'    X = X
'End If
If uDistanceInFIleFlag = 1 Then
    '1107
    Erase uDistance
    '1053,1107
    Erase uTreeDistance
    x = x
    '995,1049
End If
If uSeqNuminFile = 1 Then
    ReDim uSeqNum(0, 0), uMissingData(0, 0)
End If
If UpdateProgressBar = 0 Then
    If SPF = 0 Then
        Form1.SSPanel1.Caption = ""
    End If
End If
 

End Sub
Public Sub UnModSeqNum(SPF)


'This undoes all previous edits to seqnum - it does not completely revere modseqnum

'If ModSeqNumFlag = 0 Then Exit Sub
Dim oDirX As String, oDir As String, FF As Long, Dummy As Long, x As Long

ModSeqNumFlag = 0
If (RelX > 0 Or RelY > 0) Then 'And F2TreeIndex > 0 Then

        
        If PermSeqNumInFile = 1 Then
            ReDim SeqNum(Len(StrainSeq(0)), PermNextno)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5PSNFile" + UFTag For Binary As #FF
            '@
            Get #FF, , SeqNum
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            If UBound(SeqNum, 2) <> PermNextno Or UBound(SeqNum, 1) <> Len(StrainSeq(0)) Then
                ReDim SeqNum(Len(StrainSeq(0)), PermNextno)
            End If
            Dummy = CopySeqs(Len(StrainSeq(0)), PermNextno, PermSeqNum(0, 0), SeqNum(0, 0))
        End If
End If

ReDim Preserve MaskSeq(PermNextno)
If UBound(pMaskSeq, 1) < PermNextno Then
    ReDim Preserve pMaskSeq(PermNextno)
End If
For x = 0 To PermNextno
    MaskSeq(x) = pMaskSeq(x)
Next x

'it'll be A LOT quicker to just read in the old values
If PermNextno > MemPoc Then

Else
    ReDim TreeDistance(PermNextno, PermNextno)
End If
If DebuggingFlag < 2 Then On Error Resume Next
If UBound(SeqCol, 1) < PermNextno Or UBound(FFillCol, 1) < PermNextno Then
    ReDim Preserve SeqCol(PermNextno), FFillCol(PermNextno)
End If

If UBound(XCord, 3) < PermNextno + 2 Or UBound(YCord, 3) < PermNextno + 2 Or UBound(RYCord, 3) < PermNextno + 2 Then
    ReDim Preserve XCord(4, 3, PermNextno + 2), YCord(4, 3, PermNextno + 2), RYCord(4, 3, PermNextno + 2)
End If

On Error GoTo 0

If UBound(OriginalName, 1) < PermNextno Then
ReDim Preserve OriginalName(PermNextno)
End If

'
ReDim Distance(PermNextno, PermNextno)
ReDim TreeDistance(PermNextno, PermNextno)
oDir = CurDir
ChDir App.Path
ChDrive App.Path
FF = FreeFile
SS = Abs(GetTickCount)
Open "RDP5PermDistance" + UFTag For Binary As #FF
Get #FF, , Distance()
Close #FF

Open "RDP5PermTreeDistance" + UFTag For Binary As #FF
Get #FF, , TreeDistance()
Close #FF
EE = Abs(GetTickCount)
TT = EE - SS
x = x
ReDim PermValid(PermNextno, PermNextno)
ReDim PermDIffs(PermNextno, PermNextno)

Open "RDP5PPermValid" + UFTag For Binary As #FF
Get #FF, , PermValid()
Close #FF

Open "RDP5PPermDiffs" + UFTag For Binary As #FF
Get #FF, , PermDIffs()
Close #FF


ChDir oDir
ChDrive oDir






'ReDim uMissingData(0, 0)
'ReDim uSeqNum(0, 0)
                
DistanceFlag = 1
TreeDistFlag = 1
ModSeqNumFlag = 0
End Sub
Public Sub LoadConfirms()



Eventnumber = 0

For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If XoverList(x, Y).Eventnumber > Eventnumber Then
            Eventnumber = XoverList(x, Y).Eventnumber
        End If
    Next Y
Next x


ReDim Daught(Eventnumber, NextNo), MinorPar(Eventnumber, NextNo + 1), MajorPar(Eventnumber, NextNo + 1)

For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        Eventholder = XoverList(x, Y).Eventnumber
        Daught(Eventholder, x) = 1
        MinorPar(Eventholder, XoverList(x, Y).MinorP) = 1
        MajorPar(Eventholder, XoverList(x, Y).MajorP) = 1
'XXXZZZ          TrPos(Eventholder, XOverlist(X, Y).TreePos(0), 0) = 1
'XXXZZZ          TrPos(Eventholder, XOverlist(X, Y).TreePos(1), 1) = 1
'XXXZZZ          TrPos(Eventholder, XOverlist(X, Y).TreePos(2), 2) = 1
    Next Y
Next x


ReDim ENumber(Eventnumber)
Dim MaxEnumber As Long
MaxEnumber = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        ENumber(XoverList(x, Y).Eventnumber) = ENumber(XoverList(x, Y).Eventnumber) + 1
        If MaxEnumber < ENumber(XoverList(x, Y).Eventnumber) Then
            MaxEnumber = ENumber(XoverList(x, Y).Eventnumber)
        End If
    Next Y
Next x

ReDim EventTrace(1, Eventnumber, MaxEnumber)

ReDim ENumber(Eventnumber)
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        ENumber(XoverList(x, Y).Eventnumber) = ENumber(XoverList(x, Y).Eventnumber) + 1
        EventTrace(0, XoverList(x, Y).Eventnumber, ENumber(XoverList(x, Y).Eventnumber)) = x
        EventTrace(1, XoverList(x, Y).Eventnumber, ENumber(XoverList(x, Y).Eventnumber)) = Y
        
    Next Y
Next x
Dim BEv As Double

ReDim BestEvent(Eventnumber, 1)
For x = 1 To Eventnumber
    BEv = 1
    For Y = 1 To ENumber(x)
        If BEv > XoverList(EventTrace(0, x, Y), EventTrace(1, x, Y)).Probability Then
            BEv = XoverList(EventTrace(0, x, Y), EventTrace(1, x, Y)).Probability
            BestEvent(x, 0) = EventTrace(0, x, Y)
            BestEvent(x, 1) = EventTrace(1, x, Y)
        End If
    Next Y
Next x

ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1)

Dim CNum() As Long, CPValX() As Double
For x = 1 To Eventnumber
    
    ReDim CNum(AddNum * 3)
    ReDim CPValX(AddNum * 3)

    For b = 1 To ENumber(x)
        RelX = EventTrace(0, x, b)
        RelY = EventTrace(1, x, b)
        If XoverList(RelX, RelY).ProgramFlag < AddNum Then
            CNum(XoverList(RelX, RelY).ProgramFlag) = CNum(XoverList(RelX, RelY).ProgramFlag) + 1
            CPValX(XoverList(RelX, RelY).ProgramFlag) = CPValX(XoverList(RelX, RelY).ProgramFlag) + -Log(XoverList(RelX, RelY).Probability)
        Else
            ProgF(XoverList(RelX, RelY).ProgramFlag) = 1
            CNum(XoverList(RelX, RelY).ProgramFlag - AddNum) = CNum(XoverList(RelX, RelY).ProgramFlag - AddNum) + 1
            CPValX(XoverList(RelX, RelY).ProgramFlag - AddNum) = CPValX(XoverList(RelX, RelY).ProgramFlag - AddNum) + -Log(XoverList(RelX, RelY).Probability)
        End If
    Next b
    
    For Z = 0 To AddNum - 1
        If CPValX(Z) > 0 Then
                
            Confirm(x, Z) = CNum(Z)
            ConfirmP(x, Z) = CPValX(Z)
        End If
    Next Z
    
Next x

End Sub
Public Sub UpdateRecNums(total)

Dim oTotal As Long, x As Long
'XX = LongWindedFlag
'oTotal = oRecombNo(100) + RedoListSize
oTotal = 0
'Total = 0
For x = 0 To AddNum
    oTotal = oTotal + oRecombNo(x)
Next x
oTotal = oTotal + RedoListSize
If oTotal < 0 Then
    oTotal = 0
End If
Form1.Label50(13) = Trim(Str(total)) & " (" & Trim(Str(oTotal)) & ")"
If DoScans(0, 0) = 1 Then
    Form1.Label50(1) = Trim(Str(RecombNo(0))) & " (" & Trim(Str(oRecombNo(0))) & ")"
End If
If DoScans(0, 1) = 1 Then
    Form1.Label50(3) = Trim(Str(RecombNo(1))) & " (" & Trim(Str(oRecombNo(1))) & ")"
End If
If DoScans(0, 2) = 1 Then
    Form1.Label50(5) = Trim(Str(RecombNo(2))) & " (" & Trim(Str(oRecombNo(2))) & ")"
End If
If DoScans(0, 3) = 1 Then
    Form1.Label50(7) = Trim(Str(RecombNo(3))) & " (" & Trim(Str(oRecombNo(3))) & ")"
End If
If DoScans(0, 4) = 1 Then
    Form1.Label50(9) = Trim(Str(RecombNo(4))) & " (" & Trim(Str(oRecombNo(4))) & ")"
End If
If DoScans(0, 5) = 1 Then
    Form1.Label50(11) = Trim(Str(RecombNo(5))) & " (" & Trim(Str(oRecombNo(5))) & ")"
End If
If DoScans(0, 8) = 1 Then
    Form1.Label50(15) = Trim(Str(RecombNo(8))) & " (" & Trim(Str(oRecombNo(8))) & ")"
End If

If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End Sub

Public Sub ResortCurrentXOverIII(S1x, NPV, Prgx, XoverList() As XOverDefine, CurrentXOver() As Integer, SIPX)
    '@'@
    Dim x As Long, NPVal As Double, S1 As Long, Prg As Long, SIP As Long
    Prg = Prgx
    NPVal = NPV
    S1 = S1x
    SIP = SIPX
    Dim GoOn As Byte
    Dim WinPrg As Integer
    Dim SD As Long, WinRep As Long, WinRepB As Long, MaxPValB As Double, MaxPVal As Double, MaxPu As Long, Begin As Long, Ending As Long
    Dim PVal As Double
    Dim PU() As Long, UL As Double, LL As Double, LPV As Double
    
    If DebuggingFlag < 3 Then On Error Resume Next
    XX = 0
    XX = UBound(DonePVCO, 1)
    If XX = 0 Then
        SIPX = SIP
        Exit Sub
    End If
    On Error GoTo 0
    '@
    ReDim PU(AddNum * 2)
    SD = UBound(DonePVCO, 2)
    If S1 > SD Then
        'SIP = -1
        ReDim Preserve DonePVCO(UBound(DonePVCO, 1), S1)
        For x = SD + 1 To S1
            DonePVCO(Prg, x) = -1
        Next x
    End If
    SD = UBound(StoreLPV, 2)
    If S1 > SD Then
        'SIP = -1
        ReDim Preserve StoreLPV(UBound(StoreLPV, 1), S1)
        For x = SD + 1 To S1
            StoreLPV(Prg, x) = 1
        Next x
    End If
    '@
    If DonePVCO(Prg, S1) = -1 Then
        LPV = 0
        XX = UBound(XoverList, 2)
        If CurrentXOver(S1) > UBound(XoverList, 2) Then CurrentXOver(S1) = UBound(XoverList, 2)
        For x = 1 To CurrentXOver(S1)
            If XoverList(S1, x).ProgramFlag = Prg Then
            
                If XoverList(S1, x).Probability > LPV Then
                    LPV = XoverList(S1, x).Probability
                    DonePVCO(Prg, S1) = x
                End If
            End If
        Next x
    End If
   ' If (XOverList(S1, DonePVCO(Prg, S1)).MinorP = 0 And XOverList(S1, DonePVCO(Prg, S1)).MajorP = 0) Then
   '     X = X
   ' End If
   
    If DonePVCO(Prg, S1) > -1 Then
        If DonePVCO(Prg, S1) <= UBound(XoverList, 2) Then
            If NPVal < XoverList(S1, DonePVCO(Prg, S1)).Probability Then 'Or (XOverList(S1, DonePVCO(Prg, S1)).MinorP = 0 And XOverList(S1, DonePVCO(Prg, S1)).MajorP = 0) Then  'only bother if it is better than a score that has already been recorded
                                                'for that program
                ''XX = XOverlist(S1, DonePVCO(Prg, S1)).MinorP
                GoOn = 1
                SIP = DonePVCO(Prg, S1)
                'add the old event to the redolist
                Call AddToRedoList(XoverList(S1, DonePVCO(Prg, S1)).ProgramFlag, XoverList(S1, DonePVCO(Prg, S1)).Daughter, XoverList(S1, DonePVCO(Prg, S1)).MinorP, XoverList(S1, DonePVCO(Prg, S1)).MajorP)
                XoverList(S1, DonePVCO(Prg, S1)).Probability = 10
                x = x
                'find the new worst p-value
                LPV = 0
                '@
                'I have no idea why this part was so slow.
                If x = x Then
                    LPV = UpdateDonePVCO(NPVal, LPV, Prg, S1, SIP, UBound(XoverList, 1), UBound(DonePVCO, 1), CurrentXOver(0), XoverList(0, 0), DonePVCO(0, 0))
                    x = x
                Else
                    For x = 1 To CurrentXOver(S1)
                    
                        If x <> SIP Then
                            If XoverList(S1, x).ProgramFlag = Prg Then
                            
                                If XoverList(S1, x).Probability > LPV Then
                                    LPV = XoverList(S1, x).Probability
                                    DonePVCO(Prg, S1) = x
                                End If
                            End If
                        Else
                            If NPVal > LPV Then
                                LPV = NPVal
                                DonePVCO(Prg, S1) = x
                            End If
                        End If
                    Next x
                    
                End If
                StoreLPV(Prg, S1) = LPV
                x = x
            Else
                
                
                
            End If
        Else
            SIP = -1
        End If
        
    Else
        SIP = -1
    End If
    SIPX = SIP
End Sub
Public Sub ResortCurrentXoverII(S1 As Integer)
    Dim GoOn As Byte
    Dim WinPrg As Integer, Prg As Integer
    Dim WinRep As Long, WinRepB As Long, MaxPValB As Double, MaxPVal As Double, MaxPu As Long, Begin As Long, Ending As Long
    Dim PVal As Double
    Dim PU() As Long
    ReDim PU(AddNum * 2)
    Prg = XoverList(S1, MaxXOListSize).ProgramFlag
    Begin = XoverList(S1, MaxXOListSize).Beginning
    Ending = XoverList(S1, MaxXOListSize).Ending
    PVal = XoverList(S1, MaxXOListSize).Probability
    MaxPVal = 0
    'First find most represented program
    For x = 0 To MaxXOListSize - 1
        PU(XoverList(S1, x).ProgramFlag) = PU(XoverList(S1, x).ProgramFlag) + 1
    Next ' X
    For x = 0 To AddNum * 2
        If PU(x) >= MaxPu Then
            MaxPu = PU(x)
            WinPrg = x
        End If
    Next 'X
    
    For x = 1 To MaxXOListSize - 1
        If XoverList(S1, x).ProgramFlag = WinPrg Then
            If (PVal <= XoverList(S1, x).Probability Or (Prg <> XoverList(S1, x).ProgramFlag And Prg <> XoverList(S1, x).ProgramFlag + AddNum)) And XoverList(S1, x).Probability > MaxPVal Then
                If XoverList(S1, x).Beginning >= Begin And XoverList(S1, x).Ending <= Ending Then
                    MaxPVal = XoverList(S1, x).Probability
                    WinRep = x
                End If
                WinRepB = x
                MaxPValB = XoverList(S1, x).Probability
            End If
        End If
    Next x
    
    If MaxPValB > 0 Then 'ie there is no space but there is a worse P-val, so replace it.
        
        WinRep = WinRepB
    End If
    
    If WinRep > 0 Then
        GetRidOf(0) = XoverList(S1, WinRep).Eventnumber
        If GetRidOf(0) > Eventnumber Then
            x = x
        End If
        GetRidOf(1) = WinRep
        GetRidOf(2) = XoverList(S1, MaxXOListSize).Eventnumber
        GetRidOf(3) = MaxXOListSize
    Else
        'RecombNo(XOverList(S1, MaxXOListSize).ProgramFlag) = RecombNo(XOverList(S1, MaxXOListSize).ProgramFlag) - 1
        GetRidOf(0) = XoverList(S1, MaxXOListSize).Eventnumber
        If GetRidOf(0) > Eventnumber Then
            x = x
        End If
        GetRidOf(1) = MaxXOListSize
        
    End If
    
    
End Sub

Public Function TTest(T, DF)
Dim V() As Double, pi As Double, pj4 As Double, pi2 As Double, e As Double, dgr As Double
pi = 4 * Atn(1)
'e = Exp(1)
ReDim V(2)
V(0) = pi / 2
'pj4 = pi / 4
'pi2 = 2 * pi
'dgr = 180 / pi
TTest = 1 - buzz(T, DF, V(0)) / 2

End Function
Public Function zip(Q, i, j, b, LINK)
'Local double zip(q, i, j, b, LINK)
Dim k As Double, ZZ As Double, Z As Double


  ZZ = 1#


  Z = ZZ
  k = i
  Do While (k <= j)
    ZZ = ZZ * Q * k / (k - b)
    Z = Z + ZZ
    k = k + 2
  Loop
zip = Z



End Function
Public Sub SetUpSiScan(Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte)
Dim InNum As Byte, x As Long, RndNum As Long, Y As Long

'Mark Sequence sets that are worth looking at

DoGroupS(0, 0) = 1: DoGroupS(0, 1) = 2: DoGroupS(0, 2) = 3: DoGroupP(0, 0) = 2: DoGroupP(0, 1) = 3: DoGroupP(0, 2) = 5

DG2(6) = 1: DG2(8) = 1: DG2(9) = 1: DG2(10) = 1: DG2(11) = 1: DG2(12) = 1

'If SSFastFlag = 0 Then

    If SSVarPFlag = 1 Or SSVarPFlag = 0 Then
        DG1(15) = 1
    ElseIf SSVarPFlag = 2 Then
        DoGroupS(1, 0) = 4: DoGroupS(1, 1) = 5: DoGroupS(1, 2) = 7: DoGroupP(1, 0) = 8: DoGroupP(1, 1) = 9: DoGroupP(1, 2) = 10
        DG1(11) = 1: DG1(15) = 1
    End If
'Else
'    If SSVarPFlag = 2 Then
'        DoGroupS(1, 0) = 4: DoGroupS(1, 1) = 5: DoGroupS(1, 2) = 7: DoGroupP(1, 0) = 8: DoGroupP(1, 1) = 9: DoGroupP(1, 2) = 10
'
'    End If
'    'DG1(1) = 1: DG1(4) = 1: DG1(6) = 1: DG1(7) = 1: DG1(11) = 1: DG1(12) = 1: DG1(13) = 1: DG1(14) = 1: DG1(15) = 1

'End If



'This doesn't seem to have any effect
Rnd (-BSRndNumSeed)

'Find the Z score that must be exceeded for significance
Call GetCriticalZ

'Construct horizontal randomisation array (used for every window)to generate the
'fourth randomised sequence
If SSOutlyerFlag = 0 Then
    For x = 1 To SSWinLen
        RndNum = Int((SSWinLen * Rnd) + 1)
        If TakenPos(RndNum) = 0 Then
            HRandTemplate(x) = RndNum
            TakenPos(RndNum) = 1
        Else 'find next available position to the right
            Y = RndNum
            Do While TakenPos(Y) = 1
                Y = Y + 1
                If Y > SSWinLen Then Y = 1
            Loop
            HRandTemplate(x) = Y
            TakenPos(Y) = 1
        End If
    Next 'X
End If

'Construct randomisation array for vertical randomisation
'@
If VRandOnFileFlag = 1 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    ReDim VRandTemplate(VRandUB1, VRandUB2)
    
    FF = FreeFile
    Open "RDP5VRandTemplate" + UFTag For Binary As #FF
    '@
    Get #FF, , VRandTemplate()
    Close #FF
    ChDir oDir
    ChDrive oDir
Else
    MakeVRand Len(StrainSeq(0)), BSRndNumSeed, SSNumPerms, Len(StrainSeq(0)), VRandTemplate(0, 0)
    VRandOnFileFlag = 1
    VRandUB1 = UBound(VRandTemplate, 1)
    VRandUB2 = UBound(VRandTemplate, 2)
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    Open "RDP5VRandTemplate" + UFTag For Binary As #FF
    Put #FF, , VRandTemplate()
    Close #FF
    ChDir oDir
    ChDrive oDir
End If
'Make a lookup table for randomisations (speeds things up enormously)
For x = 1 To 12
    VRandConv(1, x) = 1
    VRandConv(15, x) = 15
Next x

For x = 2 To 7
    InNum = 2
    For Y = 1 To 12
        VRandConv(x, Y) = InNum
        InNum = InNum + 1
        If InNum > 7 Then InNum = 2
    Next Y
Next x

For x = 8 To 10
    InNum = 8
    For Y = 1 To 12
        VRandConv(x, Y) = InNum
        InNum = InNum + 1
        If InNum > 10 Then InNum = 8
    Next Y
Next x

For x = 11 To 14
    InNum = 11
    For Y = 1 To 12
        VRandConv(x, Y) = InNum
        InNum = InNum + 1
        If InNum > 14 Then InNum = 11
    Next Y
Next x

'Make a pattern-conversion lookup table

Seq34Conv(1, 1) = 4
Seq34Conv(1, 2) = 6
Seq34Conv(1, 3) = 7
Seq34Conv(1, 4) = 1
Seq34Conv(1, 5) = 1
Seq34Conv(2, 1) = 12
Seq34Conv(2, 2) = 2
Seq34Conv(2, 3) = 8
Seq34Conv(2, 4) = 2
Seq34Conv(2, 5) = 2
Seq34Conv(3, 1) = 13
Seq34Conv(3, 2) = 9
Seq34Conv(3, 3) = 3
Seq34Conv(3, 4) = 3
Seq34Conv(3, 5) = 3
Seq34Conv(4, 1) = 10
Seq34Conv(4, 2) = 14
Seq34Conv(4, 3) = 5
Seq34Conv(4, 4) = 5
Seq34Conv(4, 5) = 5
Seq34Conv(5, 1) = 15
Seq34Conv(5, 2) = 11
Seq34Conv(5, 3) = 11
Seq34Conv(5, 4) = 11
Seq34Conv(5, 5) = 11


'Addjust the scores according to settings - ie
'Turn some scores into a 0 category based on what we're actually looking for.
For x = 1 To 5
    For Y = 1 To 5
        Seq34Conv(x, Y) = Abs(Seq34Conv(x, Y) * (DG1(Seq34Conv(x, Y)) - 1))
    Next Y
Next x

For x = 1 To 15
    For Y = 1 To 12
        VRandConv(x, Y) = Abs(VRandConv(x, Y) * (DG1(VRandConv(x, Y)) - 1))
    Next Y
Next x
End Sub

Public Sub GetSSOutlyer(oSeq As Long, LFlag, TraceSub() As Long)



If SSOutlyerFlag = 2 Then
    'Check to see if outlyer is one of the sequences
    If LFlag = 0 Then
        If Seq1 = oSeq Then
            Seq1 = Seq1 + 1
            Seq2 = Seq1 + 1
            Seq3 = Seq2 + 1
            'C = C + (Nextno - Seq3) * (Nextno - Seq3 - 1) / 2
        ElseIf Seq2 = oSeq Then
            'C = C + (Nextno - Seq3)
            Seq2 = Seq2 + 1
            Seq3 = Seq2 + 1
        ElseIf Seq3 = oSeq Then
            Seq3 = Seq3 + 1
            'C = C + 1
        End If
    Else
        If Seq1 = oSeq Or Seq2 = oSeq Or Seq3 = oSeq Then '
            Seq3 = -1
            Exit Sub
        End If
    End If
    If Seq3 > NextNo Then Exit Sub
ElseIf SSOutlyerFlag = 1 Then ' Find outlyer seq if necessary 0 = use rndseq, 2 = use most distant seq
    Dim OLS As Integer, InS As Integer, CTD As Double, UBTD As Long
    UBTD = UBound(TreeDistance, 2)
    Do
        If TreeDistance((Seq1), (Seq2)) > TreeDistance((Seq1), (Seq3)) Then
            InS = (Seq1)
            OLS = (Seq3)
        ElseIf TreeDistance((Seq1), (Seq3)) > TreeDistance((Seq1), (Seq2)) Then
            InS = (Seq1)
            OLS = (Seq2)
        ElseIf TreeDistance((Seq2), (Seq3)) > TreeDistance((Seq1), (Seq2)) Then
            InS = (Seq2)
            OLS = Seq1
        End If
                        
        CTD = 0
        
        For x = 0 To PermNextno
            If x <= UBTD Then
                If TreeDistance(OLS, x) < TreeDistance(OLS, InS) And TreeDistance(OLS, x) >= CTD And x <> OLS Then
                    If TreeDistance(OLS, x) = CTD Then
                        If Distance(OLS, x) > Distance(OLS, oSeq) Then
                            GoOn = 1
                            If SEventNumber > 0 Then
                                For Z = 0 To Len(StrainSeq(0))
                                    If MissingData(Z, x) = 1 Then
                                        If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
                                            GoOn = 0
                                            Exit For
                                        End If
                                    End If
                                Next Z
                                
                            End If
                            If GoOn = 1 Then
                                oSeq = x
                                CTD = TreeDistance(OLS, x)
                                
                            End If
                        End If
                    Else
                        GoOn = 1
                        If SEventNumber > 0 Then
                            For Z = 0 To Len(StrainSeq(0))
                                If MissingData(Z, x) = 1 Then
                                    If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
                                        GoOn = 0
                                        Exit For
                                    End If
                                End If
                            Next Z
                        End If
                        If GoOn = 1 Then
                            oSeq = x
                            CTD = TreeDistance(OLS, x)
                        End If
                    End If
                    
                End If
            End If
        Next x
        If CTD > 0 Then
            Exit Do
        End If
        'C = C + 1
        
        Dim MDist As Double, TDist As Double, WinX As Long
        MDist = 1
        WinX = -1
        For x = 0 To NextNo
            If TraceSub(x) <> TraceSub(Seq1) And TraceSub(x) <> TraceSub(Seq2) And TraceSub(x) <> TraceSub(Seq3) Then
                
                TDist = (Distance(x, Seq1) + Distance(x, Seq2) + Distance(x, Seq3)) / 3
                If TDist < MDist Then
                    GoOn = 1
                    If SEventNumber > 0 Then
                        For Z = 0 To Len(StrainSeq(0))
                            If MissingData(Z, x) = 1 Then
                                If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
                                    GoOn = 0
                                    Exit For
                                End If
                            End If
                        Next Z
                    End If
                    If GoOn = 1 Then
                        MDist = TDist
                        WinX = x
                        
                    End If
                End If
            End If
            
        Next x
        If WinX = -1 Then
            
            MDist = 1
            WinX = -1
            For x = 0 To NextNo
                If TraceSub(x) <> TraceSub(Seq1) And TraceSub(x) <> TraceSub(Seq2) And TraceSub(x) <> TraceSub(Seq3) Then
                    TDist = (Distance(x, Seq1) + Distance(x, Seq2) + Distance(x, Seq3)) / 3
                    If TDist < MDist Then
                        GoOn = 1
                        If SEventNumber > 0 Then
                            For Z = 0 To Len(StrainSeq(0))
                                If MissingData(Z, x) = 1 Then
                                    If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
                                        GoOn = 0
                                        Exit For
                                    End If
                                End If
                            Next Z
                        End If
                        If GoOn = 1 Then
                            MDist = TDist
                            WinX = x
                            
                        End If
                    End If
                End If
                
            Next x
        End If
        If WinX = -1 Then
            minmiss = Len(StrainSeq(0))
            
            MDist = 1
            WinX = -1
            For x = 0 To NextNo
                curmiss = 0
                If TraceSub(x) <> TraceSub(Seq1) And TraceSub(x) <> TraceSub(Seq2) And TraceSub(x) <> TraceSub(Seq3) Then
                    TDist = (Distance(x, Seq1) + Distance(x, Seq2) + Distance(x, Seq3)) / 3
                    If TDist < MDist Then
                        GoOn = 1
                        If SEventNumber > 0 Then
                            For Z = 0 To Len(StrainSeq(0))
                                If MissingData(Z, x) = 1 Then
                                    If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
                                        curmiss = curmiss + 1
                                        
                                    End If
                                End If
                            Next Z
                            If curmiss < minmiss Then
                                minmiss = curmiss
                                WinX = x
                            End If
                        End If
                        
                    End If
                End If
                
            Next x
        End If
        oSeq = WinX
        
        Exit Sub
        
        If Seq3 > NextNo Or Seq3 = -1 Then Exit Sub
    Loop
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
    If PermNextno > MemPoc Then
        ReDim TreeDistance(0, 0)
    End If
End If


End Sub

Public Sub OrderSeqs(tSeq1, tSeq2, tSeq3, Seq1, Seq2, Seq3, TraceSub() As Long)
tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
If UBound(TraceSub, 1) < Seq1 Then
    ReDim Preserve TraceSub(Seq1)
End If
If UBound(TraceSub, 1) < Seq2 Then
    ReDim Preserve TraceSub(Seq2)
End If
If UBound(TraceSub, 1) < Seq3 Then
    ReDim Preserve TraceSub(Seq3)
End If
If TraceSub(Seq1) < TraceSub(Seq2) And TraceSub(Seq1) < TraceSub(Seq3) Then
    If TraceSub(Seq2) < TraceSub(Seq3) Then
        Seq1 = tSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
    Else
        Seq1 = tSeq1
        Seq2 = tSeq3
        Seq3 = tSeq2
    End If
ElseIf TraceSub(Seq2) < TraceSub(Seq1) And TraceSub(Seq2) < TraceSub(Seq3) Then
    If TraceSub(Seq1) < TraceSub(Seq3) Then
        Seq1 = tSeq2
        Seq2 = tSeq1
        Seq3 = tSeq3
    Else
        Seq1 = tSeq2
        Seq2 = tSeq3
        Seq3 = tSeq1
    End If
Else
    If TraceSub(Seq1) < TraceSub(Seq2) Then
        Seq1 = tSeq3
        Seq2 = tSeq1
        Seq3 = tSeq2
    Else
        Seq1 = tSeq3
        Seq2 = tSeq2
        Seq3 = tSeq1
    End If
End If
End Sub

Public Sub ShrinkRegion(HVX As Byte, TBegin As Long, TEnd As Long, SP As Long, EP As Long, SSStep As Long, SSWinLen As Long, SSGapFlag As Byte, SeqNum() As Integer)
    
    Dim Hi1 As Long, Hi2 As Long, LO As Long, Z As Long
    If HVX = 0 Then
        Hi1 = Seq1: Hi2 = Seq2: LO = Seq3
    ElseIf HVX = 1 Then
        Hi1 = Seq1: Hi2 = Seq3: LO = Seq2
    ElseIf HVX = 2 Then
       Hi1 = Seq2: Hi2 = Seq3: LO = Seq1
    End If
    
    If EP >= SP Then
        For Z = (SP * SSStep) To (EP * SSStep + SSWinLen)
            If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                    TBegin = Z
                    Exit For
                End If
            End If
        Next Z
                                                                
        For Z = (EP * SSStep + SSWinLen) To SP * SSStep Step -1
            If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                
                If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                    TEnd = Z
                    Exit For
                End If
            End If
        Next Z
                                                    
    Else
        For Z = SP To Len(StrainSeq(0))
            If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                    TBegin = Z
                    Exit For
                End If
            End If
        Next Z
        
        If TBegin <> Z Then
            For Z = 1 To EP * SSStep + SSWinLen
                If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                    If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                        TBegin = Z
                        Exit For
                    End If
                End If
            Next Z
        End If
        
        For Z = EP * SSStep + SSWinLen To 1 Step -1
            If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                    TEnd = Z
                    Exit For
                End If
            End If
        Next Z
                                                    
        If TEnd <> Z Then
            For Z = Len(StrainSeq(0)) To SP * SSWinLen Step -1
                If SSGapFlag = 1 Or (SeqNum(Z, Hi1) > 60 And SeqNum(Z, Hi2) > 60 And SeqNum(Z, LO) > 60) Then
                    If SeqNum(Z, Hi1) = SeqNum(Z, Hi2) And SeqNum(Z, Hi1) <> SeqNum(Z, LO) Then
                        TEnd = Z
                        Exit For
                    End If
                End If
            Next Z
        End If
    End If
End Sub

Public Sub UpdateXOList(ActiveSeq, CurrentXOver() As Integer, XoverList() As XOverDefine)
Dim XOLS As Long, XX As Long
XOLS = UBound(XoverList, 2)
CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) + 1
If CurrentXOver(ActiveSeq) > XOLS And XOLS < MaxXOListSize Then
    XOverListSize = Int(XOLS * 1.1) + 1
    If XOverListSize > MaxXOListSize Then XOverListSize = MaxXOListSize
    XX = UBound(XoverList, 1)
    ReDim Preserve XoverList(XX, XOverListSize)
ElseIf CurrentXOver(ActiveSeq) > MaxXOListSize Then
    CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
    ResortCurrentxover (ActiveSeq)
End If

End Sub
Public Sub AddToRedoList(Prg, Seq1, Seq2, Seq3)

Dim UB As Long
If DebuggingFlag < 3 Then On Error Resume Next
XX = 0
'@
XX = UBound(RedoList, 2)
If XX = 0 Then Exit Sub
On Error GoTo 0
If RedoListSize < 1 Then RedoListSize = 1


If Seq1 = 0 And Seq2 = 0 And Seq3 = 0 Then
    Exit Sub
End If

'$
If Prg = RedoList(0, RedoListSize) Then
    If Seq1 = RedoList(1, RedoListSize) Then
        If Seq2 = RedoList(2, RedoListSize) And Seq3 = RedoList(3, RedoListSize) Then
            Exit Sub
        ElseIf Seq3 = RedoList(2, RedoListSize) And Seq2 = RedoList(3, RedoListSize) Then
            Exit Sub
        End If
    End If
    If Seq2 = RedoList(1, RedoListSize) Then
        If Seq3 = RedoList(2, RedoListSize) And Seq1 = RedoList(3, RedoListSize) Then
            Exit Sub
        ElseIf Seq1 = RedoList(2, RedoListSize) And Seq2 = RedoList(3, RedoListSize) Then
            Exit Sub
        End If
    End If
    If Seq3 = RedoList(1, RedoListSize) Then
        If Seq1 = RedoList(2, RedoListSize) And Seq2 = RedoList(3, RedoListSize) Then
            Exit Sub
        ElseIf Seq2 = RedoList(2, RedoListSize) And Seq1 = RedoList(3, RedoListSize) Then
            Exit Sub
        End If
    End If
    
End If



RedoListSize = RedoListSize + 1


If SEventNumber = 23 Then
    XX = RedoListSize
    XX = Seq1
    XX = Seq2
    XX = Seq3
    '23 a:(3,42,33,120), (3,31,33,42), (3,37,33,42), (3,70,33,42)
    '23 b:(3,120,33,42), (3,42,33,120), (3,120,42,33), (3,42,33,120)
    x = x
End If
'Tot = 0
'XX = UBound(RedoList, 2)
'For x = 0 To NextNo
'    Tot = Tot + CurrentXOver(x)
'Next x
'For x = 1 To UBound(RedoList, 2)
'    If RedoList(0, x) = RedoList(0, x - 1) Then
'        If RedoList(1, x) = RedoList(1, x - 1) Then
'            If RedoList(2, x) = RedoList(2, x - 1) Then
'                If RedoList(3, x) = RedoList(3, x - 1) Then
'                    x = x
'                End If
'            End If
'        End If
'    End If
'Next x

If RedoListSize > UBound(RedoList, 2) Then
    
'    APhys = Abs(MemSit.dwTotalPhys)
'    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    UB = UBound(RedoList, 2) + 1000
    If UB < 4000000 Then
        On Error Resume Next
        tub = UBound(RedoList, 2)
        ReDim Preserve RedoList(3, UB)
        If tub = UBound(RedoList, 2) Then
            Call DropRedolist
            RedoListSize = 1
        End If
        On Error GoTo 0
        
    Else
        Call DropRedolist
        RedoListSize = 1
    End If
    
End If
RedoList(0, RedoListSize) = Prg
RedoList(1, RedoListSize) = Seq1
RedoList(2, RedoListSize) = Seq2
RedoList(3, RedoListSize) = Seq3

End Sub
Public Sub FillISInvolved(NextNo As Long, UseALFlag, Worthwhilescan() As Byte, ISInvolved() As Long, Analysislist() As Integer)
Dim NumInList As Long, x As Long, Seq1 As Long, Seq2 As Long, Seq3 As Long
ReDim ISInvolved(NextNo)
'XX = UBound(Analysislist, 1)
oDirX = CurDir
ChDrive App.Path
ChDir App.Path
If Dir("RDP5AnalysisList" + UFTag) <> "" And TripListLen > 100000 Then
    ReDim Analysislist(2, TripListLen)
    FF = FreeFile
    Open "RDP5AnalysisList" + UFTag For Binary As #FF
    Get #FF, , Analysislist
    Close #FF
End If
ChDrive oDirX
ChDir oDirX

If UseALFlag = 1 Then
  For x = 0 To TripListLen
    If Worthwhilescan(x) > 0 Then
        ISInvolved(Analysislist(0, x)) = ISInvolved(Analysislist(0, x)) + 1
        ISInvolved(Analysislist(1, x)) = ISInvolved(Analysislist(1, x)) + 1
        ISInvolved(Analysislist(2, x)) = ISInvolved(Analysislist(2, x)) + 1
    End If
  Next x
Else
    For Seq1 = 0 To NextNo
        For Seq2 = Seq1 + 1 To NextNo
            For Seq3 = Seq2 + 1 To NextNo
                NumInList = GetNumInList(Seq1, Seq2, Seq3)
                If Worthwhilescan(NumInList) > 0 Then
                    ISInvolved(Seq1) = ISInvolved(Seq1) + 1
                    ISInvolved(Seq2) = ISInvolved(Seq2) + 1
                    ISInvolved(Seq3) = ISInvolved(Seq3) + 1
                End If
            Next Seq3
        Next Seq2
    Next Seq1
   

End If

End Sub
Public Sub UpdateXOList3(ActiveSeq, CurrentXOver() As Integer, XoverList() As XOverDefine, Prg, PVal, SIP)
'@'@
Dim XOLS As Long, XX As Long, UB1 As Long, UB2 As Long, UBXOL2 As Long
SIP = -1
XOLS = UBound(XoverList, 2)
'@
If PN = 0 Then
    PN = 6
End If

'If CurrentXOver(XoverList(x, Y).Daughter) < CurrentXOver(XoverList(x, Y).MinorP) And CurrentXOver(XoverList(x, Y).Daughter) < CurrentXOver(XoverList(x, Y).MajorP) Then
'    ActiveSeq = XoverList(x, Y).Daughter
'ElseIf CurrentXOver(XoverList(x, Y).MinorP) < CurrentXOver(XoverList(x, Y).Daughter) And CurrentXOver(XoverList(x, Y).MinorP) < CurrentXOver(XoverList(x, Y).MajorP) Then
'    ActiveSeq = XoverList(x, Y).MinorP
'ElseIf CurrentXOver(XoverList(x, Y).MajorP) < CurrentXOver(XoverList(x, Y).Daughter) And CurrentXOver(XoverList(x, Y).MajorP) < CurrentXOver(XoverList(x, Y).MinorP) Then
'    ActiveSeq = XoverList(x, Y).MajorP
'
'End If


Dim OUB As Long
OUB = UBound(MaxXOP, 2)
'$
If ActiveSeq > UBound(MaxXOP, 2) Then
    UB1 = UBound(MaxXOP, 1)
    UB2 = ActiveSeq + 10 'UBound(MaxXOP, 2) + 10
    ReDim Preserve MaxXOP(UB1, UB2)
    ReDim DonePVCO(UB1, UB2)
    ReDim StoreLPV(UB1, UB2)
    For x = 0 To UB1
        For Y = OUB + 1 To UB2
            StoreLPV(x, Y) = 1
            DonePVCO(x, Y) = -1
        Next Y
    Next x
End If



'@
If MaxXOP(Prg, ActiveSeq) < CLng((MaxXOListSize / PN) - 0.49) And CurrentXOver(ActiveSeq) < MaxXOListSize Then
    
    CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) + 1
    
    If CurrentXOver(ActiveSeq) > XOLS And XOLS <= MaxXOListSize Then
        
        XOverListSize = Int(XOLS * 1.1) + 1
'        If XOverListSize - XOLS < 10 Then
'            XOverListSize = XOLS + 10
'        End If
        If XOverListSize > MaxXOListSize Then XOverListSize = MaxXOListSize
        XX = UBound(XoverList, 1)
        '@'@'$
        ReDim Preserve XoverList(XX, XOverListSize)
        If UBound(XoverList, 2) < CurrentXOver(ActiveSeq) Then
            ReDim Preserve XoverList(XX, CurrentXOver(ActiveSeq) + 3)
            If UBound(XoverList, 2) <> CurrentXOver(ActiveSeq) + 3 Then
                Call ResortCurrentXOverIII(ActiveSeq, PVal, Prg, XoverList(), CurrentXOver(), SIP)
                If SIP > -1 Then
                    If XoverList(ActiveSeq, SIP).Probability <> 10 Then
                        Call AddToRedoList(XoverList(ActiveSeq, SIP).ProgramFlag, XoverList(ActiveSeq, SIP).Daughter, XoverList(ActiveSeq, SIP).MinorP, XoverList(ActiveSeq, SIP).MajorP)
                    End If
                    
                End If
                Exit Sub
            End If
        End If
        
    End If
    
    SIP = CurrentXOver(ActiveSeq)
    '@
    MaxXOP(Prg, ActiveSeq) = MaxXOP(Prg, ActiveSeq) + 1
ElseIf CurrentXOver(ActiveSeq) < MaxXOListSize Then
x = x

'
'    CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) + 1
'
'    If CurrentXOver(ActiveSeq) > XOLS And XOLS <= MaxXOListSize Then
'
'        XOverListSize = Int(XOLS * 1.1) + 1
''        If XOverListSize - XOLS < 10 Then
''            XOverListSize = XOLS + 10
''        End If
'        If XOverListSize > MaxXOListSize Then XOverListSize = MaxXOListSize
'        XX = UBound(XoverList, 1)
'        '@'@'$
'        ReDim Preserve XoverList(XX, XOverListSize)
'        If UBound(XoverList, 2) < CurrentXOver(ActiveSeq) Then
'            ReDim Preserve XoverList(XX, CurrentXOver(ActiveSeq) + 3)
'            If UBound(XoverList, 2) <> CurrentXOver(ActiveSeq) + 3 Then
'                Call ResortCurrentXOverIII(ActiveSeq, PVal, Prg, XoverList(), CurrentXOver(), SIP)
'                If SIP > -1 Then
'                    Call AddToRedoList(XoverList(ActiveSeq, SIP).ProgramFlag, XoverList(ActiveSeq, SIP).Daughter, XoverList(ActiveSeq, SIP).MinorP, XoverList(ActiveSeq, SIP).MajorP)
'                    x = x
'                End If
'                Exit Sub
'            End If
'        End If
'
'    End If
'
'    SIP = CurrentXOver(ActiveSeq)
    '@
    'MaxXOP(Prg, ActiveSeq) = MaxXOP(Prg, ActiveSeq) + 1
Else
    Call ResortCurrentXOverIII(ActiveSeq, PVal, Prg, XoverList(), CurrentXOver(), SIP)
    If SIP > -1 Then
        If XoverList(ActiveSeq, SIP).Probability <> 10 Then
            Call AddToRedoList(XoverList(ActiveSeq, SIP).ProgramFlag, XoverList(ActiveSeq, SIP).Daughter, XoverList(ActiveSeq, SIP).MinorP, XoverList(ActiveSeq, SIP).MajorP)
        End If
        'x = x
    End If
End If



End Sub
Public Sub UpdateXOList2(ActiveSeq, CurrentXOver() As Integer, XoverList() As XOverDefine, Prg)
Dim XOLS As Long, XX As Long
XOLS = UBound(XoverList, 2)


CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) + 1
If CurrentXOver(ActiveSeq) > XOLS And XOLS < MaxXOListSize Then
    XOverListSize = Int(XOLS * 1.1) + 1
    If XOverListSize > MaxXOListSize Then XOverListSize = MaxXOListSize
    XX = UBound(XoverList, 1)
    ReDim Preserve XoverList(XX, XOverListSize)
ElseIf CurrentXOver(ActiveSeq) > MaxXOListSize Then
    CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
    ResortCurrentxover (ActiveSeq)
End If

End Sub


Public Sub BSXoverS(NS, Seq1, Seq2, Seq3, TraceSub() As Long, SSMap() As Byte)
    
'Routine used to retrieve automated bootscan data from the file "RDP5BSScanData"

    Dim NumSets As Long, Y As Long, x As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
    Dim oDir As String, S1 As Long, s2 As Long, S3 As Long
    Dim SubMaskSeq() As Long, RevSeq() As Long, NumberOfSeqs As Long
    If SelGrpFlag = 1 Then
        If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
            Exit Sub
        End If
    End If
    'Set appropriate directory location
    oDir$ = CurDir
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    'Note:  The number of sequences must = the number of unmasked sequences
    S1 = TraceSub(Seq1)
    s2 = TraceSub(Seq2)
    S3 = TraceSub(Seq3)
    
    NumberOfSeqs = 0
    ReDim Preserve pMaskSeq(BackUpNextno), SubMaskSeq(BackUpNextno), RevSeq(BackUpNextno)
    
        For x = 0 To BackUpNextno

            If pMaskSeq(x) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = x
                RevSeq(x) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
                
            End If

        Next 'X
    XX = UBound(RevSeq, 1)
    If XX = 0 Then
    ReDim Preserve RevSeq(NextNo)
    For x = 0 To NextNo
        RevSeq(x) = x
    Next x
    End If
    S1 = RevSeq(S1)
    s2 = RevSeq(s2)
    S3 = RevSeq(S3)
    NumberOfSeqs = NumberOfSeqs - 1
    NumSets = Int(Len(StrainSeq(0)) / BSStepSize) + 2
        
    ReDim PltPos(NumSets + 1)
    Dim NSets As Long
    
    NSets = NumSets - 1

    For Z = 0 To NSets
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    Dim FF As Integer

    FF = FreeFile
    'Open BSFileName For Binary Access Read As #FF
    Dim hbfFile2 As HugeBinaryFile
    Set hbfFile2 = New HugeBinaryFile
    hbfFile2.OpenFile BSFileName
    ReDim PltVal(2, NumSets)

    Dim t0() As Integer
    Dim T1() As Integer
    Dim T2() As Integer
    ReDim t0(BSBootReps * (NumSets + 1) - 1)
    ReDim T1(BSBootReps * (NumSets + 1) - 1)
    ReDim T2(BSBootReps * (NumSets + 1) - 1)
     If S1 > UBound(BSFilePos, 1) Or s2 > UBound(BSFilePos, 1) Or S3 > UBound(BSFilePos, 1) Then
        'Close #FF
        hbfFile2.CloseFile
        Set hbfFile2 = Nothing
        Exit Sub
     End If
     Dim Pos As Currency, TempByte() As Byte
     ReDim TempByte((BSBootReps * (NumSets + 1) - 1) * 2 + 1)
     Pos = BSFilePos(S1, s2)
    Pos = Pos * BSBootReps
    Pos = Pos * NumWins
    Pos = Pos * 2 + 1
    hbfFile2.SeekAbsolute Pos
    hbfFile2.ReadBytes TempByte()
    t0() = AnyArrayToInteger(TempByte)
    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
    'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1)
    Pos = BSFilePos(S1, S3)
    Pos = Pos * BSBootReps
    Pos = Pos * NumSets
    Pos = Pos * 2 + 1
    hbfFile2.SeekAbsolute Pos
    hbfFile2.ReadBytes TempByte()
    T1() = AnyArrayToInteger(TempByte)
    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
    Pos = BSFilePos(s2, S3)
    Pos = Pos * BSBootReps
    Pos = Pos * NumSets
    Pos = Pos * 2 + 1
    hbfFile2.SeekAbsolute Pos
    hbfFile2.ReadBytes TempByte()
    T2() = AnyArrayToInteger(TempByte)
'    Get #FF, (BSFilePos(s1, s2) * BSBootReps * (NumSets) * 2 + 1), t0()
'    Get #FF, (BSFilePos(s1, S3) * BSBootReps * (NumSets) * 2 + 1), T1()
'    Get #FF, (BSFilePos(s2, S3) * BSBootReps * (NumSets) * 2 + 1), T2()
                                       
    For Y = 0 To NumSets
        'this coluld be speeded up with better nesting of if then's

        GetPltVal BSBootReps, Y, t0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
        
    Next 'Y
    
    'Cancel out the deleted bits
    For x = 1 To Len(StrainSeq(0))
        If SSMap(x, Seq1) > 0 Or SSMap(x, Seq2) > 0 Or SSMap(x, Seq3) > 0 Then
        
            For Z = 0 To 2
                PltVal(Z, Int(x / BSStepSize)) = 0
            Next Z
            x = Int((x / BSStepSize) + 1) * BSStepSize
        End If
    Next x
    hbfFile2.CloseFile
    Set hbfFile2 = Nothing
    'Close #FF
    
    LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
    ReDim GoOnA(0)
    ReDim GoOnB(0)
    GoOnA(0) = 1
    GoOnB(0) = NumSets
    
    Call ScanBSPlots(0, 0)
    If DebuggingFlag < 2 Then On Error Resume Next

    
    ChDir oDir$
    ChDrive oDir$
    On Error GoTo 0
End Sub
Public Sub MakeBSEvent(YVal As Long, GoOnA() As Long, GoOnB() As Long, BSStepSize As Long, BSStepWin As Long, BSBootReps As Long, BSCutOff As Double, CycleCount, PltVal() As Double, OverlapNum As Integer, BE As Long, EN As Long, PosCount As Long, MedHomol As Double, HighHomol As Double, LowHomol As Double, PPVal As Double, PVal As Double, BSPValFlag, EWarn, BWarn)
Dim Ac As Long, b As Long, D As Long, AFact As Double, C As Long, A As Long, oActive As Long, oMajP As Long, oMinP As Long, Y As Long, bCurPos As Long, Dummy As Long, NumWins As Long, EraseAll As Byte, ProbCounter As Long, CurPos As Long, TotalProb As Double, FirstFull As Long, LastFull As Long
Dim SeqLen As Long, Z As Long, GoOnFlag As Byte
Dim ScoreP As Byte, HMChi As Double, XOverLen As Long

EWarn = 0: BWarn = 0

SeqLen = Len(StrainSeq(0))
If MedHomol = 0 Then
    BSHi1 = Seq1: BSHi2 = Seq2: BSLo = Seq3
ElseIf MedHomol = 1 Then
    BSHi1 = Seq1: BSHi2 = Seq3: BSLo = Seq2
Else
    BSHi1 = Seq2: BSHi2 = Seq3: BSLo = Seq1
End If
                
'Likely recombinant region.  Do some book keeping
ProbCounter = 1

TotalProb = PltVal(MedHomol, PosCount) / BSBootReps

CurPos = PosCount
                
'Hopefully the beginning of the recombinant region is detected
FirstFull = PosCount
LastFull = PosCount
EraseAll = 0
'XX = PltPos(CurPos)
NumWins = UBound(PltVal, 2)
'If X = X Then

    'need to make totalprob=0
    Dummy = FindBeginBS(CircularFlag, BSStepSize, BSStepWin, MedHomol, HighHomol, LowHomol, NumWins, BSCutOff, BSBootReps, PosCount, OverlapNum, TotalProb, LastFull, ProbCounter, YVal, PVal, PPVal, EraseAll, CurPos, PltVal(0, 0))
    If Dummy = 0 Then Exit Sub
    
    
'Else
'
'    Do While CurPos >= 0 And CurPos >= (PosCount - OverlapNum)
'
'        If PltVal(MedHomol, CurPos) < BSCutOff * BSBootReps Then
'                GoOnFlag = 0
'                For Z = 0 To OverlapNum
'                    Y = CurPos - Z
'                    If Y = PosCount Then
'                        EraseAll = 1
'                        PVal = 100000000
'                        PPVal = 1
'                        YVal = YVal + (BSStepWin + BSStepSize) + 1
'                        Exit Sub
'                    End If
'                    If Y < 1 Then Y = Y + (UBound(PltVal, 2) - 1)
'
'                    If PltVal(MedHomol, Y) <= PltVal(HighHomol, Y) Or PltVal(MedHomol, Y) <= PltVal(LowHomol, Y) Or PltVal(MedHomol, Y) <= (0.4 * BSBootReps) Then
'                        GoOnFlag = 0
'                        Exit For
'
'                    ElseIf PltVal(MedHomol, Y) >= BSCutOff * BSBootReps Then
'                        GoOnFlag = 1
'                        CurPos = Y
'                        Exit For
'                    End If
'                    ProbCounter = ProbCounter + 1
'                    TotalProb = TotalProb + PltVal(MedHomol, CurPos - 1) / BSBootReps
'                Next ' Z
'
'                If GoOnFlag = 0 Then
'                    If Y = CurPos And PltVal(MedHomol, Y) <= (0.4 * BSBootReps) Then CurPos = CurPos + 1
'                    Exit Do
'                End If
'        Else
'
'                LastFull = CurPos
'        End If
'
'        If PltVal(MedHomol, CurPos) <= PltVal(HighHomol, CurPos) Or PltVal(MedHomol, CurPos) <= PltVal(LowHomol, CurPos) Or PltVal(MedHomol, CurPos) <= (0.5 * BSBootReps) Then
'            If PltVal(MedHomol, Y) <= (0.4 * BSBootReps) Then CurPos = CurPos + 1
'            Exit Do
'        End If
'        ProbCounter = ProbCounter + 1
'
'        TotalProb = TotalProb + PltVal(MedHomol, CurPos - 1) / BSBootReps
'        CurPos = CurPos - 1
'        'CurPos = 4
'        If CurPos = PosCount Then
'            EraseAll = 1
'            PVal = 100000000
'            PPVal = 1
'            YVal = (BSStepWin + BSStepSize * GoOnB(CycleCount)) + 1
'            Exit Sub
'        End If
'        If CurPos < 1 Then
'            If CircularFlag = 1 Then
'                CurPos = UBound(PltVal, 2) - 1
'            Else
'                CurPos = 1
'                Exit Do
'            End If
'        End If
'    Loop
'End If
'XX = PPVal '0,0.35846,0.351428,0.37625:0,0.9999,0.9999
'XX = TotalProb '3.11,4.01,2.93:3.08,3.99,2.92
If CurPos < 0 Then CurPos = 0
Dim Backtrack As Long

Backtrack = CLng((BSStepWin / 2) / BSStepSize)
If FirstFull < Backtrack Then
    If CircularFlag = 1 Then
        bCurPos = FirstFull - Backtrack
        bCurPos = bCurPos + UBound(PltVal, 2)
    Else
        bCurPos = 1
    End If
Else
    bCurPos = FirstFull - Backtrack
End If

If (CircularFlag = 0 And (PltPos(bCurPos) < PltPos(CurPos) And (PltVal(MedHomol, bCurPos) >= PltVal(HighHomol, bCurPos) And PltVal(MedHomol, bCurPos) >= PltVal(LowHomol, bCurPos) And PltVal(MedHomol, bCurPos) >= (0.5 * BSBootReps)))) Or (CircularFlag = 1 And EraseAll = 1) Then
'If (CircularFlag = 0 And PltPos(FirstFull) - BSStepWin / 2 + 1 < PltPos(CurPos)) Or (CircularFlag = 1 And EraseAll = 1) Then
    
    BE = PltPos(bCurPos)
    If FirstFull = 0 Then
        If CircularFlag = 0 Then BWarn = 1
    Else
        If PltVal(0, FirstFull - 1) = 0 And PltVal(1, FirstFull - 1) = 0 And PltVal(2, FirstFull - 1) = 0 Then
            BWarn = 1
        End If
    End If
Else
    BE = PltPos(CurPos)
    If CurPos = 0 Then
        If CircularFlag = 0 Then BWarn = 1
    Else
        If PltVal(0, CurPos - 1) = 0 And PltVal(1, CurPos - 1) = 0 And PltVal(2, CurPos - 1) = 0 Then
            BWarn = 1
        End If
    End If
End If
 
If BE < 1 Then
    If CircularFlag = 0 Then
        BE = 1
    Else
        BE = SeqLen + BE
    End If
End If
                              
    'Now find the end of the region
CurPos = PosCount
'If X = X Then
    Dummy = FindEndBS(Y, BSCutOff, BSBootReps, NumWins, OverlapNum, MedHomol, HighHomol, LowHomol, GoOnB(CycleCount), LastFull, ProbCounter, CurPos, TotalProb, PltVal(0, 0))
'Else
'    Do While CurPos <= GoOnB(CycleCount) - 1
'            If PltVal(MedHomol, CurPos) < BSCutOff * BSBootReps Then
'                GoOnFlag = 0
'                For Z = 1 To OverlapNum
'                    If CurPos + Z <= UBound(PltVal, 2) Then
'                        If PltVal(MedHomol, CurPos + Z) <= PltVal(HighHomol, CurPos + Z) Or PltVal(MedHomol, CurPos + Z) <= PltVal(LowHomol, CurPos + Z) Or PltVal(MedHomol, CurPos + Z) <= (0.4 * BSBootReps) Then
'                            GoOnFlag = 0
'                            Exit For
'                        ElseIf PltVal(MedHomol, CurPos + Z) >= BSCutOff * BSBootReps Then
'                            GoOnFlag = 1
'                            CurPos = CurPos + Z
'                            Exit For
'                        End If
'                    Else
'                        Exit For
'                    End If
'                    ProbCounter = ProbCounter + 1
'                    TotalProb = TotalProb + PltVal(MedHomol, CurPos - 1) / BSBootReps
'                Next ' Z
'
'                If GoOnFlag = 0 Then
'                    If Y = CurPos And PltVal(MedHomol, Y) <= (0.4 * BSBootReps) Then CurPos = CurPos - 1
'                    Exit Do
'                End If
'            Else
'                LastFull = CurPos
'            End If
'
'        ProbCounter = ProbCounter + 1
'        TotalProb = TotalProb + PltVal(MedHomol, CurPos - 1) / BSBootReps
'        CurPos = CurPos + 1
'    Loop
'End If

If CurPos > UBound(PltVal, 2) Then CurPos = UBound(PltVal, 2)
                
Backtrack = CInt((BSStepWin / 2) / BSStepSize)
If LastFull + Backtrack > UBound(PltVal, 2) Then
    If CircularFlag = 1 Then
        bCurPos = LastFull + Backtrack
        bCurPos = bCurPos - UBound(PltVal, 2)
    Else
        bCurPos = UBound(PltVal, 2)
    End If
Else
    bCurPos = LastFull + Backtrack
End If
 
If (CircularFlag = 0 And (PltPos(bCurPos) > PltPos(CurPos) And (PltVal(MedHomol, bCurPos) >= PltVal(HighHomol, bCurPos) And PltVal(MedHomol, bCurPos) >= PltVal(LowHomol, bCurPos) And PltVal(MedHomol, bCurPos) >= (0.5 * BSBootReps)))) Or (CircularFlag = 1 And EraseAll = 1) Then
    EN = PltPos(bCurPos)
    If LastFull = UBound(PltVal, 2) Then
        If CircularFlag = 0 Then EWarn = 1
    Else
        If PltVal(0, LastFull + 1) = 0 And PltVal(1, LastFull + 1) = 0 And PltVal(2, LastFull + 1) = 0 Then
            EWarn = 1
        End If
    End If
Else
    EN = PltPos(CurPos)
    If CurPos = UBound(PltVal, 2) Then
        If CircularFlag = 0 Then EWarn = 1
    Else
        
        If PltVal(0, CurPos + 1) = 0 And PltVal(1, CurPos + 1) = 0 And PltVal(2, CurPos + 1) = 0 Then
            EWarn = 1
        End If
    End If
End If
    
If EN > SeqLen Then
    If CircularFlag = 0 Then
        EN = SeqLen
    Else
        EN = EN - SeqLen
    End If
End If
    
'Work out the bootstrap "P-value"
PPVal = 1 - (TotalProb / ProbCounter)
    
If PPVal = 0 Then PPVal = (1 / (BSBootReps * 10))
                
oActive = ActiveSeq
oMajP = ActiveMajorP
oMinP = ActiveMinorP
    
'Call CheckDistance

Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, BE, EN, 2, 0)
               
If BE = EN Or PVal = 1000 Then Exit Sub
       
If BSPValFlag > 0 Then
            
        'If FindallFlag = 0 Then
        If (BSHi1 = Seq1 And BSHi2 = Seq2) Or (BSHi2 = Seq1 And BSHi1 = Seq2) Then
            ScoreP = 0
        ElseIf (BSHi1 = Seq1 And BSHi2 = Seq3) Or (BSHi2 = Seq1 And BSHi1 = Seq3) Then
            ScoreP = 1
        ElseIf (BSHi1 = Seq3 And BSHi2 = Seq2) Or (BSHi2 = Seq3 And BSHi1 = Seq2) Then
            ScoreP = 2
        End If
       ' End If
'    OBE = BE
'    oen = EN
'    'For ScoreP = 0 To 2
'        BE = OBE
'        EN = oen
'        If BE > 10000 Then
'            X = X
'        End If
'        XX = SEventNumber
        '@'@'@'@
        XOverLen = MakeScoresBS(LenXoverSeq, ScoreP, Len(StrainSeq(0)), BE, EN, A, C, XPosDiff(0), Scores(0, 0))
    '    XX = XPosDiff(BE)
    '    XX = XPosDiff(EN)
'        For X = XPosDiff(BE) To XPosDiff(EN)
'            XX = Scores(X, ScoreP)
'        Next X
        If BSPValFlag = 1 Then
            'Using binomial dist
            If (LenXoverSeq - XOverLen) > 0 Then
                IndProb = (C + A) / (LenXoverSeq)
            Else
                IndProb = 1
            End If
                    'LenXoverSeq = CLng(d1 + d2 + d3 - Abs(d2 - d3) - Abs(d1 - d2) - Abs(d1 - d3))
            If XOverLen > 2 Then
                If XOverLen >= 170 Then
                    A = CLng(A * 169 / XOverLen)
                    AFact = XOverLen / 169
                    XOverLen = 169
                Else
                    AFact = 1
                End If
                'C routine that calculates the probability of the "recomination" having occured by chance.
                
                ProbabilityXOver = ProbCalc(Fact(0), XOverLen, A, IndProb, LenXoverSeq)
                If ProbabilityXOver > 1 Then
                    ProbabilityXOver = 1
                End If
                                    
                ProbabilityXOver = ProbabilityXOver ^ AFact
'            X = X '10,10,0.177,304
            Else
                ProbabilityXOver = 1
            End If
            PVal = ProbabilityXOver
        ElseIf BSPValFlag = 2 Then
            If LenXoverSeq > 0 Then
                C = CLng(C * (XOverLen / LenXoverSeq))
                b = XOverLen - A
                D = XOverLen - C
                If (A + C > 0) And (b + D > 0) Then
                    HMChi = (A * D - b * C) ^ 2 * XOverLen * 2
                    HMChi = HMChi / (A + b)
                    HMChi = HMChi / (C + D)
                    HMChi = HMChi / (A + C)
                    HMChi = HMChi / (b + D)
                    If HMChi > 0 Then
                        ProbabilityXOver = ChiPVal(HMChi)
                    Else
                        ProbabilityXOver = 1
                    End If
                Else
                    ProbabilityXOver = 1
                End If
            Else
                ProbabilityXOver = 1
            End If
                    
        End If
        If MCFlag = 0 Then
            ProbabilityXOver = ProbabilityXOver * MCCorrection
        End If
        If ShortOutFlag = 3 Then
            If ProbabilityXOver > 0 And ProbabilityXOver <= mtP(2) And XoverList(Ac, CurrentXOver(Ac)).Beginning <> XoverList(Ac, CurrentXOver(Ac)).Ending Then
                mtP(2) = ProbabilityXOver
            End If
        End If
        If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
            'XOverList(Ac, CurrentXOver(Ac)).Probability = ProbabilityXOver
            If MCFlag = 2 Then
                                            
                If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                    PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                    PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                End If
            End If
        Else
            BE = EN
        End If
        'If ProbabilityXOver < PVal Then
            PVal = ProbabilityXOver
        'End If
    'Next ScoreP
Else
    PVal = PPVal
End If
ProbabilityXOver = PVal
ActiveSeq = oActive
ActiveMajorP = oMajP
ActiveMinorP = oMinP
                
YVal = PltPos(CurPos) + BSStepWin / 2
    
If CurPos > PosCount Then PosCount = CurPos

End Sub
Public Sub FixEnds(BWarn, EWarn, MissingData() As Byte, XoverList() As XOverDefine, AD, SIP)
    Dim BE As Long, EN As Long, S1 As Long, s2 As Long, S3 As Long, x As Long
    S1 = AD
    '$
    s2 = XoverList(AD, SIP).MinorP
    S3 = XoverList(AD, SIP).MajorP
    If XoverList(AD, SIP).Beginning > Len(StrainSeq(0)) Then
        If CircularFlag = 0 Then
            XoverList(AD, SIP).Beginning = 1
        Else
            XoverList(AD, SIP).Beginning = XoverList(AD, SIP).Beginning - Len(StrainSeq(0))
        End If
    End If
    If XoverList(AD, SIP).Ending > Len(StrainSeq(0)) Then
        If CircularFlag = 0 Then
            XoverList(AD, SIP).Ending = Len(StrainSeq(0))
        Else
            XoverList(AD, SIP).Ending = XoverList(AD, SIP).Ending - Len(StrainSeq(0))
        End If
    End If
    If XoverList(AD, SIP).Beginning < 1 Then
        If CircularFlag = 0 Then
            XoverList(AD, SIP).Beginning = 1
        Else
            XoverList(AD, SIP).Beginning = XoverList(AD, SIP).Beginning + Len(StrainSeq(0))
        End If
    End If
    If XoverList(AD, SIP).Ending < 1 Then
        If CircularFlag = 0 Then
            XoverList(AD, SIP).Ending = Len(StrainSeq(0))
        Else
            XoverList(AD, SIP).Ending = XoverList(AD, SIP).Ending + Len(StrainSeq(0))
        End If
    End If
    BE = XoverList(AD, SIP).Beginning
    EN = XoverList(AD, SIP).Ending
    
    If SEventNumber > 0 Then
        If MissingData(BE, S1) = 1 Or MissingData(BE, s2) = 1 Or MissingData(BE, S3) = 1 Then
            BWarn = 1
        End If
        If MissingData(EN, S1) = 1 Or MissingData(EN, s2) = 1 Or MissingData(EN, S3) = 1 Then
            EWarn = 1
        End If
    End If
    
    
    If BWarn = 1 And EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 3
        
        'If X = X Then
            XoverList(AD, SIP).Beginning = FindRightEnd(S1, s2, S3, Len(StrainSeq(0)), BE, UBound(MissingData, 1), MissingData(0, 0))
'        Else
'            X = BE
'            Do While MissingData(X, S1) + MissingData(X, S2) + MissingData(X, S3) > 0
'                X = X + 1
'                If X > Len(StrainSeq(0)) Then
'                    X = 1
'                End If
'                If X = BE Then Exit Do
'            Loop
'            XOverList(AD, SIP).Beginning = X
'        End If
        
        'If X = X Then
            XoverList(AD, SIP).Ending = FindLeftEnd(S1, s2, S3, Len(StrainSeq(0)), EN, UBound(MissingData, 1), MissingData(0, 0))
'        Else
'
'            X = EN
'            Do While MissingData(X, S1) + MissingData(X, S2) + MissingData(X, S3) > 0
'                X = X - 1
'                If X < 1 Then
'                    X = Len(StrainSeq(0))
'                End If
'                If X = EN Then Exit Do
'            Loop
'            XOverList(AD, SIP).Ending = X
'        End If
    ElseIf BWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 1
        XoverList(AD, SIP).Beginning = FindRightEnd(S1, s2, S3, Len(StrainSeq(0)), BE, UBound(MissingData, 1), MissingData(0, 0))

'        X = BE
'        If SEventNumber > 0 Then
'
'
'            Do While MissingData(X, S1) + MissingData(X, S2) + MissingData(X, S3) > 0
'                X = X + 1
'                If X > Len(StrainSeq(0)) Then
'                    X = 1
'                End If
'                If X = BE Then Exit Do
'            Loop
'
'        End If
'        XOverList(AD, SIP).Beginning = X
    ElseIf EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 2
        XoverList(AD, SIP).Ending = FindLeftEnd(S1, s2, S3, Len(StrainSeq(0)), EN, UBound(MissingData, 1), MissingData(0, 0))
'        X = EN
'        If SEventNumber > 0 Then
'            Do While MissingData(X, S1) + MissingData(X, S2) + MissingData(X, S3) > 0
'                X = X - 1
'                If X < 1 Then
'                    X = Len(StrainSeq(0))
'                End If
'                If X = EN Then Exit Do
'            Loop
'            XOverList(AD, SIP).Ending = X
'        End If
        
    End If
    If EWarn = 1 And BWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 3
    ElseIf EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 2
    ElseIf BWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 1
    End If
End Sub
Public Function buzz(T, n, LINK)

Dim RT As Double, fk As Double, ek As Double, dk As Double

T = Abs(T)
RT = T / Sqr(n)
fk = Atn(RT)
If n = 1 Then
    buzz = (1 - fk / LINK)
Else
    ek = Sin(fk)
    dk = Cos(fk)
    buzz = (1 - ek * zip(dk * dk, 1, n - 3, -1, LINK))
End If


End Function


Public Sub FindDaughter(Ac, AMi, AMa, BEX As Long, ENX As Long, PrgF As Long, HitNo)
    

    Dim S1 As Long, s2 As Long, Dists(2) As Single, Valids(2) As Single, Diffs(2) As Single, oAc As Long, oAmi As Long, oAma As Long, DupFlag As Integer, OutF As Integer
    Dim NPosMod As Long, RefNT, QueryNT As Long, EqFlag As Byte, RS As Long, RE As Long, MRCASeq1 As Long, MRCASeq2 As Long, InA(2) As Long, InB As Long, Out As Long
    Dim MRCA As Long, MRCA2 As Long, V1(2) As Double, V2(1) As Double, V3 As Double, DM1(2) As Double, DM2(1) As Double, DM3 As Double, DA1(1) As Double, DA2 As Double
    Dim AncDstMatT() As Double, Valid() As Long, Done() As Byte
    Dim DA As Long, Ma As Long, Mi As Long, BE As Long, EN As Long, NCyc As Long, Cycle As Long
    Dim ReCalc As Byte, Hi1 As Long, Hi2 As Long, LO As Long, LSeq As Long, Dummy As Long, x As Long, PVal As Double
    
    If PrgF <> 2 Then
        RS = XoverList(Ac, HitNo).Beginning
        RE = XoverList(Ac, HitNo).Ending
    Else
        RS = BEX
        RE = ENX
    End If
    
    If RS > Len(StrainSeq(0)) Then
        If CircularFlag = 0 Then
            RS = Len(StrainSeq(0))
        Else
            RS = RS - Len(StrainSeq(0))
        End If
    End If
    If RE > Len(StrainSeq(0)) Then
        If CircularFlag = 0 Then
            RE = Len(StrainSeq(0))
        Else
            RE = RE - Len(StrainSeq(0))
        End If
    End If
    If RS < 1 Then
        If CircularFlag = 0 Then
            RS = 1
        Else
            RS = Len(StrainSeq(0)) + RS
        End If
        
    End If
    If RE < 1 Then
        If CircularFlag = 0 Then
            RE = 1
        Else
            RE = Len(StrainSeq(0)) + RE
        End If
        
    End If
    oAc = Ac
    oAmi = AMi
    oAma = AMa
    
    LSeq = Len(StrainSeq(0))
    
    
        
    If PrgF <> 2 And PrgF <> 3 And PrgF <> 4 Then
    
        Dummy = FindHiSeqs(Len(StrainSeq(0)), RS, RE, Ac, AMi, AMa, SeqNum(0, 0), Dists(0), Valids(0), Diffs(0))
        
        If Dists(0) <= Dists(1) And Dists(0) <= Dists(2) Then
            Hi1 = Ac: Hi2 = AMi: LO = AMa
        ElseIf Dists(1) <= Dists(0) And Dists(1) <= Dists(2) Then
            Hi1 = Ac: Hi2 = AMa: LO = AMi
        Else
            Hi1 = AMa: Hi2 = AMi: LO = Ac
        End If
    ElseIf PrgF = 2 Then
        If BSLo > UBound(SubMaskSeq, 1) Or BSHi1 > UBound(SubMaskSeq, 1) Or BSHi2 > UBound(SubMaskSeq, 1) Then
            ReDim Preserve SubMaskSeq(NextNo)
        End If
        If BSLo > UBound(SubMaskSeq, 1) Or BSHi1 > UBound(SubMaskSeq, 1) Or BSHi2 > UBound(SubMaskSeq, 1) Then
'            If Nextno > UBound(TreeTrace, 1) Then
'                ReDim TreeTrace(Nextno)
'            End If
            Hi1 = SubMaskSeq(TreeTrace(BSHi1))
            Hi2 = SubMaskSeq(TreeTrace(BSHi2))
            LO = SubMaskSeq(TreeTrace(BSLo))
        Else
            Hi1 = SubMaskSeq(BSHi1)
            Hi2 = SubMaskSeq(BSHi2)
            LO = SubMaskSeq(BSLo)
        End If
    ElseIf PrgF = 3 Or PrgF = 4 Then
        If MCMaxY = 0 Then
            Hi1 = Seq1: Hi2 = Seq2: LO = Seq3
        ElseIf MCMaxY = 1 Then
            Hi1 = Seq1: Hi2 = Seq3: LO = Seq2
        ElseIf MCMaxY = 2 Then
            Hi1 = Seq3: Hi2 = Seq2: LO = Seq1
        End If
    End If
        
    
        
   
    
    
    If (PrgF = 4 Or PrgF = 3) Then
        'ReCalc = 0
        BE = RS: EN = RE
        x = XPosDiff(RS)
        If x = 0 Then x = 1
        
        Do
            If LoHiFlag = 1 Then
                If SeqNum(XDiffPos(x), Hi1) <> SeqNum(XDiffPos(x), Hi2) Then
                    Exit Do
                End If
            Else
                If SeqNum(XDiffPos(x), Hi1) = SeqNum(XDiffPos(x), Hi2) Then
                    Exit Do
                End If
            End If
            x = x - 1
            If x >= 0 And x <= UBound(MDMap, 1) Then
                If MDMap(x) = 1 Then Exit Do
            End If
            If x < 1 Then
                If CircularFlag = 1 Then
                    If x = XPosDiff(RE) Then x = x + 1: Exit Do
                    x = LenXoverSeq
                Else
                    Exit Do
                End If
            End If
            
            If x = XPosDiff(RE) Then x = x + 1: Exit Do
        Loop
        RS = XDiffPos(x)
        x = XPosDiff(RS)
        
        Do
            
            If LoHiFlag = 1 Then
                If SeqNum(XDiffPos(x), Hi1) = SeqNum(XDiffPos(x), Hi2) Then
                    BE = XDiffPos(x)
'                    If LongWindedFlag = 0 Then
'                        'No ReCalc Is necessary
'                        'If BE <> XDiffpos(X) Then
'                        '    ReCalc = 1
'                        'End If
'                    End If
                    Exit Do
                End If
            Else
                If SeqNum(XDiffPos(x), Hi1) <> SeqNum(XDiffPos(x), Hi2) Then
                    BE = XDiffPos(x)
                    
'                    If LongWindedFlag = 0 Then
'                        'No ReCalc Is necessary
'                        'If BE <> XDiffpos(X) Then
'                        '    ReCalc = 1
'                        'End If
'                    End If
                    Exit Do
                End If
            End If
            x = x + 1
            If x >= 0 And x <= UBound(MDMap, 1) Then
                If MDMap(x) = 1 Then Exit Do
            End If
            
            If x > LenXoverSeq Then
                If CircularFlag = 1 Then
                    x = 1
                Else
                    Exit Do
                End If
            End If
            
            If x = XPosDiff(RE) Then x = x - 1: Exit Do
        Loop
        x = XPosDiff(RE)
        If x > UBound(MDMap, 1) Then x = UBound(MDMap, 1)
        If MDMap(x) = 0 Then
            Do
                If LoHiFlag = 1 Then
                    If SeqNum(XDiffPos(x), Hi1) <> SeqNum(XDiffPos(x), Hi2) Then
                        Exit Do
                    End If
                Else
                    If SeqNum(XDiffPos(x), Hi1) = SeqNum(XDiffPos(x), Hi2) Then
                        Exit Do
                    End If
                End If
                x = x + 1
                
                If x >= 0 And x <= UBound(MDMap, 1) Then
                    If MDMap(x) = 1 Then Exit Do
                End If
                If x > LenXoverSeq Then
                    If CircularFlag = 1 Then
                        x = 1
                        If x <= UBound(MDMap, 1) Then
                            If MDMap(x) = 1 Then Exit Do
                        End If
                    Else
                        Exit Do
                    End If
                End If
                
                If x = XPosDiff(RS) Then x = x - 1: Exit Do
            Loop
        End If
        RE = XDiffPos(x)
        x = XPosDiff(RE)
        If x = 0 Then x = 1
        Do
            If LoHiFlag = 1 Then
                If SeqNum(XDiffPos(x), Hi1) = SeqNum(XDiffPos(x), Hi2) Then
                    EN = XDiffPos(x)
                    Exit Do
                End If
            Else
                If SeqNum(XDiffPos(x), Hi1) <> SeqNum(XDiffPos(x), Hi2) Then
                    EN = XDiffPos(x)
                            
                    Exit Do
                End If
            End If
            If x > 0 And x <= UBound(MDMap, 1) Then
                If MDMap(x) = 1 Then Exit Do
            End If
            x = x - 1
            If x >= 0 And x <= UBound(MDMap, 1) Then
                If MDMap(x) = 1 Then Exit Do
            End If
            If x < 1 Then
                If CircularFlag = 1 Then
                    x = LenXoverSeq
                Else
                    Exit Do
                End If
            End If
            
            If x = XPosDiff(RS) Then x = x + 1: Exit Do
        Loop
        
        If Abs(XPosDiff(EN) - XPosDiff(XoverList(Ac, HitNo).Ending)) < 5 Then
            XoverList(Ac, HitNo).Ending = EN
        ElseIf Abs(XPosDiff(EN) - (XPosDiff(XoverList(Ac, HitNo).Ending) - Len(StrainSeq(0)))) < 5 Then
            XoverList(Ac, HitNo).Ending = EN
        ElseIf Abs((XPosDiff(EN) - Len(StrainSeq(0)))) - XPosDiff(XoverList(Ac, HitNo).Ending) < 5 Then
            XoverList(Ac, HitNo).Ending = EN
        End If
        
        
        If Abs(XPosDiff(BE) - XPosDiff(XoverList(Ac, HitNo).Beginning)) < 5 Then
            XoverList(Ac, HitNo).Beginning = BE
        ElseIf Abs(XPosDiff(BE) - (XPosDiff(XoverList(Ac, HitNo).Beginning) - Len(StrainSeq(0)))) < 5 Then
            XoverList(Ac, HitNo).Beginning = BE
        ElseIf Abs((XPosDiff(BE) - Len(StrainSeq(0)))) - XPosDiff(XoverList(Ac, HitNo).Beginning) < 5 Then
            XoverList(Ac, HitNo).Beginning = BE
        End If
        
    ElseIf PrgF = 2 Then
        
        If PolishBPFlag = 1 Or x = x Then ' bs must always have polish on or its a big screwup
                BEX = RS
                ENX = RE
                If x = x Then
                    '@
                    PVal = ShrinkRegionBS(CircularFlag, SEventNumber, Hi1, Hi2, LO, Len(StrainSeq(0)), XPosDiff(0), RS, RE, SeqNum(0, 0), MissingData(0, 0))
                    BEX = RS
                    ENX = RE
                Else
                    If x = x Then
                        x = RS - 1
                        If x > Len(StrainSeq(0)) Then x = Len(StrainSeq(0))
                        Do
                            
                            If SeqNum(x, Hi1) <> 46 Then
                                If SeqNum(x, Hi2) <> 46 Then
                                    If SeqNum(x, LO) <> 46 Then
                                        If SeqNum(x, Hi1) <> SeqNum(x, Hi2) And SeqNum(x, Hi1) = SeqNum(x, LO) Then
                                            BEX = x
                                            Exit Do
                                        End If
                                    End If
                                End If
                            End If
                            x = x - 1
                            If x < 1 Then
                                If CircularFlag = 1 Then
                                    x = Len(StrainSeq(0))
                                Else
                                    BEX = 1
                                    Exit Do
                                End If
                            Else
                                
                                
                                If SEventNumber > 0 Then
                                    If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                        BEX = BEX + 1
                                        Exit Do
                                    End If
                                End If
                            End If
                            If x = RS Or x = RE Then PVal = 1000: Exit Sub
                        Loop
                    Else
                        PVal = ShrinkRegionBS(CircularFlag, SEventNumber, Hi1, Hi2, LO, Len(StrainSeq(0)), XPosDiff(0), RS, RE, SeqNum(0, 0), MissingData(0, 0))
                        BEX = RS
                        ENX = RE
                    End If
                    x = BEX '2643,418,418,418,418,1402,1713
                    'XX = Len(StrainSeq(0))
                    If x > UBound(SeqNum, 1) Then x = UBound(SeqNum, 1)
                    Do
                    
                        If SeqNum(x, Hi1) <> 46 Then
                            If SeqNum(x, Hi2) <> 46 Then
                                
                                If SeqNum(x, LO) <> 46 Then
                                    If SeqNum(x, Hi1) = SeqNum(x, Hi2) And SeqNum(x, Hi1) <> SeqNum(x, LO) Then
                                        BEX = x
                   
                                        Exit Do
                                    End If
                                End If
                            End If
                        End If
                        x = x + 1
                        If x > Len(StrainSeq(0)) Then
                            If CircularFlag = 1 Then
                                x = 1
                                If SEventNumber > 0 Then
                                    If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                        BEX = 1
                                        Exit Do
                                    End If
                                End If
                                NCyc = NCyc + 1
                                If NCyc = 2 Then PVal = 1000: Exit Sub
                            Else
                                BEX = 1
                                Exit Do
                            End If
                        Else
                            If SEventNumber > 0 Then
                                If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                    Cycle = 0
                                    Do Until MissingData(x, Hi1) = 0 And MissingData(x, Hi2) = 0 And MissingData(x, LO) = 0
                                        x = x + 1
                                        If x > Len(StrainSeq(0)) Then
                                            x = 1
                                            Cycle = Cycle + 1
                                            If Cycle = 2 Then x = RE: Exit Do
                                        End If
                                    Loop
                                    BEX = x
                                    Exit Do
                                End If
                            End If
                        End If
                        If x = RE Then PVal = 1000: Exit Sub
                    Loop
                    If x = RE Then PVal = 1000: Exit Sub
                    x = RE
                    Do
                        
                        If SeqNum(x, Hi1) > 60 And SeqNum(x, Hi2) > 60 And SeqNum(x, LO) > 60 Then
                            If SeqNum(x, Hi1) <> SeqNum(x, Hi2) And SeqNum(x, Hi1) = SeqNum(x, LO) Then
                                ENX = x
                                
                                Exit Do
                            End If
                        End If
                        
                        x = x + 1
                        If x > Len(StrainSeq(0)) Then
                            If CircularFlag = 1 Then
                                x = 1
                                If SEventNumber > 0 Then
                                    If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                        ENX = Len(StrainSeq(0))
                                        Exit Do
                                    End If
                                End If
                            Else
                                ENX = Len(StrainSeq(0))
                                Exit Do
                            End If
                        Else
                            
                            If SEventNumber > 0 Then
                                If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                    
                                    Do Until MissingData(x, Hi1) = 0 And MissingData(x, Hi2) = 0 And MissingData(x, LO) = 0
                                        x = x - 1
                                        
                                        If x = RE Then PVal = 1000: Exit Sub
                                        If x < 1 Then x = Len(StrainSeq(0))
                                        If x = RE Then PVal = 1000: Exit Sub
                                    Loop
                                    ENX = x
                                    Exit Do
                                End If
                            End If
                        End If
                        
                        If x = RS Or x = RE Then PVal = 1000: Exit Sub
                    Loop
                    x = ENX
                    Do
                    
                        If SeqNum(x, Hi1) > 60 And SeqNum(x, Hi2) > 60 And SeqNum(x, LO) > 60 Then
                            If SeqNum(x, Hi1) = SeqNum(x, Hi2) And SeqNum(x, Hi1) <> SeqNum(x, LO) Then
                                ENX = x
            
                                
                                Exit Do
                            End If
                        End If
                        x = x - 1
                        If x < 1 Then
                            If CircularFlag = 1 Then
                                x = Len(StrainSeq(0))
                                If SEventNumber > 0 Then
                                    If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                        ENX = Len(StrainSeq(0))
                                        Exit Do
                                    End If
                                End If
                            Else
                                ENX = Len(StrainSeq(0))
                                Exit Do
                            End If
                        Else
                            
                            If SEventNumber > 0 Then
                                If MissingData(x, Hi1) = 1 Or MissingData(x, Hi2) = 1 Or MissingData(x, LO) = 1 Then
                                    Cycle = 0
                                    Do Until MissingData(x, Hi1) = 0 And MissingData(x, Hi2) = 0 And MissingData(x, LO) = 0
                                        x = x - 1
                                        If x < 1 Then
                                            x = Len(StrainSeq(0))
                                            Cycle = Cycle + 1
                                            If Cycle = 2 Then
                                                PVal = 1000: Exit Sub
                                            End If
                                        End If
                                    Loop
                                    ENX = x
                                    Exit Do
                                End If
                            End If
                        End If
                        If x = RS Or x = BEX Then PVal = 1000: Exit Sub
                    Loop
                End If
                
        End If
        
        
        If ShortOutFlag = 1 Then Exit Sub
    End If
'
'    XX = RS '95 388 : 95, 1341:95, 1341:95, 1341:, 95, 1341
'    XX = RE
'   X = X
    

End Sub
Public Sub CalcDistances(SeqNum() As Integer, AvDst As Double, Decompress() As Long, PermDIffs() As Single, PermValid() As Single, NextNo As Long, Distance() As Single, SPF, DF)
    Dim oB As Long, oCap As String, LowDist As Single, b As Long, A As Long, Z As Long, k As Long, Y As Long, x As Long, Valid As Long, Diffs As Long
    'SS = Abs(GetTickCount)
    'This calculates a distance matrix for the alignment
    ReDim Distance(NextNo, NextNo)
    'AvDst, Decompress() , PermDiffs() , PermValid() , Nextno , Distance() ,
    AvDst = 0
    Dim tRedoDist() As Integer
    If DF = 1 Or DF = 2 Then
        
        Valid = 0
        Diffs = 0
        'SS = Abs(GetTickCount)
        'XX = UBound(SeqNum, 2)
        
        'Change this to only look at the altered sequences.
        'UDst = DistanceCalcY(Nextno, Len(StrainSeq(0)) + 1, PermDiffs(0, 0), PermValid(0, 0), SeqNum(0, 0), Distance(0, 0), AvDst, DistMod(0))
        'UDst = DistanceCalcX(Nextno, Len(StrainSeq(0)) + 1, PermDiffs(0, 0), PermValid(0, 0), SeqNum(0, 0), Distance(0, 0), AvDst)
        
            'SS = Abs(GetTickCount)
            ReDim tRedoDist(NextNo)
            For x = 0 To NextNo
                 tRedoDist(x) = 1
            Next x
            'this is the 4 nt version
            
            
            ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo), Distance(NextNo, NextNo)
            'Call FastDistanceCalcX(0, 1, Len(StrainSeq(0)), Nextno, PermDiffs(), PermValid(), SeqNum(), Distance(), AvDst, UDst, tRedoDist())
            Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, PermDIffs(), PermValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
            
            If PermNextno > MemPoc Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                
                UBPermValid = UBound(PermValid, 1)
                Open "RDP5PermValid" + UFTag For Binary As #FF
                Put #FF, , PermValid()
                Close #FF
                
                UBPermDiffs = UBound(PermDIffs, 1)
                Open "RDP5PermDiffs" + UFTag For Binary As #FF
                Put #FF, , PermDIffs()
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            End If
            

'            EE = Abs(GetTickCount)
'            TT = EE - SS '13797
'
'        EE = Abs(GetTickCount)
'        TT = EE - SS '62.390 - 22.797 with fastdistcalcx for upgma with recombinant regions separated
'        X = X
'
            
        
      '  XX = Distance(7, 60) '0.97
      '  XX = Distance(7, 36) '1.00
      '  XX = PermValid(7, 60) '185
      '  XX = PermValid(7, 36) '17
      '  XX = PermDiffs(7, 60) '4
      '  XX = PermDiffs(7, 36) '0
        
            'Impute dmissing distances using a nearest neghbours method
        
        If x = 12345 Then
            Dim tFMat() As Single, DistDist() As Single, NDstx As Long, WinDist As Long, TmpDist As Double, BakDist() As Long
            
            ReDim tFMat(NextNo, NextNo)
            
            For x = 0 To NextNo
                Distance(x, x) = 1
                PermValid(x, x) = Len(StrainSeq(0))
                PermDIffs(x, x) = 0
                For Y = 0 To NextNo
                    tFMat(x, Y) = Distance(x, Y)
                Next Y
            Next x
            
            
        
            
            k = CLng(NextNo / 10) + 1
            'first do full matrix
            For x = 0 To NextNo
                For Y = x + 1 To NextNo
                    If PermValid(x, Y) < MinSeqSize Then 'ie if there is missing data
                        ReDim DistDist(NextNo, 1)
                       
                        For Z = 0 To NextNo
                            If PermValid(x, Z) >= MinSeqSize And PermValid(Y, Z) >= MinSeqSize Then
                                 NDstx = 0
                                For A = 0 To NextNo
                                    If PermValid(Z, A) >= MinSeqSize Then
                                        DistDist(Z, 0) = DistDist(Z, 0) + Abs(tFMat(Z, A) - tFMat(x, A))
                                        DistDist(Z, 1) = DistDist(Z, 1) + Abs(tFMat(Z, A) - tFMat(Y, A))
                                        NDstx = NDstx + 1
                                    End If
                                Next A
                                DistDist(Z, 0) = DistDist(Z, 0) / NDstx
                                DistDist(Z, 1) = DistDist(Z, 1) / NDstx
                                x = x
                            Else
                                DistDist(Z, 0) = 10
                                DistDist(Z, 1) = 10
                            End If
                        Next Z
                        'Order the distances
                        ReDim BakDist(NextNo, 1)
                        For Z = 0 To NextNo
                            BakDist(Z, 0) = Z
                            BakDist(Z, 1) = Z
                        Next Z
                        
                        For b = 0 To 1
                            Z = 0
                            Do While Z <= NextNo And Z <= k
                                LowDist = 100
                                For A = Z To NextNo
                                    If LowDist > DistDist(A, b) Then
                                        LowDist = DistDist(A, b)
                                        WinDist = A
                                    End If
                                Next A
                                If LowDist >= 1 And Z > 0 Then k = Z: Exit Do
                                TmpDist = DistDist(Z, b)
                                DistDist(Z, b) = DistDist(WinDist, b)
                                DistDist(WinDist, b) = TmpDist
                                TmpDist = BakDist(WinDist, b)
                                BakDist(WinDist, b) = BakDist(Z, b)
                                BakDist(Z, b) = TmpDist
                                Z = Z + 1
                            Loop
                        Next b
                        'Missing entry now becomes the average of the top k
                        TmpDist = 0
                        NDstx = 0
                        For Z = 0 To k - 1
                            For A = 0 To k - 1
                                TmpDist = TmpDist + tFMat(BakDist(Z, 0), BakDist(A, 1))
                                NDstx = NDstx + 1
                            Next A
                        Next Z
                        TmpDist = TmpDist / NDstx
                        Distance(x, Y) = TmpDist
                        Distance(Y, x) = TmpDist
                        x = x
                    End If
                    
                Next Y
            Next x
        Else
            
            For x = 0 To NextNo
                
                For Y = x + 1 To NextNo
                    If PermValid(x, Y) < MinSeqSize Then
                        Distance(x, Y) = 0
                        Distance(Y, x) = 0
                    End If
                Next Y
            Next x
        End If
        'If SEventNumber = 1 And X = 12345 Then
        '    Open "distmat" For Output As #1
        '    Dim OS As String
         '   For X = 0 To Nextno
        '        OS = ""
        '
        '        For Y = 0 To Nextno
        '            If PermValid(X, Y) > 0 Then
        '                OS = OS + " 0" + Trim(Str(CLng((PermDiffs(X, Y) / PermValid(X, Y)) * 10000) / 10000))
        ' '           Else
        '                OS = OS + " 0.0000"
        '            End If
        '        Next Y
        '        Print #1, OS
        '    Next X
        '    Close #1
        'End If
        'XX = Distance(11, 36) '0.97
        'XX = Distance(10, 19) '1.00
        'XX = PermValid(11, 36) '185
        'XX = PermValid(10, 19) '17
        'XX = PermDiffs(11, 36) '4
        'XX = PermDiffs(10, 19) '0
    Else
        If SPF = 0 Then Form1.SSPanel1.Caption = "Calculating distance matrix"
        
         'SS = Abs(GetTickCount)
        
        
        'Dim TSNum() As Long
        'ReDim LongSeqNum(Len(StrainSeq(0)), Nextno)
        'For X = 0 To Nextno
        '    For Y = 1 To Len(StrainSeq(0))
        '        LongSeqNum(Y, X) = SeqNum(Y, X)
        '    Next Y
        'Next X
       
       
        'UDst = DistanceCalcX(Nextno, Len(StrainSeq(0)) + 1, PermDiffs(0, 0), PermValid(0, 0), SeqNum(0, 0), Distance(0, 0), AvDst)
        'ReDim PermDiffs(Nextno, Nextno), PermValid(Nextno, Nextno)
        
        'UDst = DistanceCalcZ(Nextno, Len(StrainSeq(0)) + 1, PermDiffs(0, 0), PermValid(0, 0), SeqNum(0, 0), Distance(0, 0), AvDst, ValidList(0), CountList(0))
        oCap = Form1.SSPanel1.Caption
        Form1.SSPanel1.Caption = "Calculating distances"
        'SS = Abs(GetTickCount)
        
        If x = 1234567899 Then
        
            'Dim udst2 As Double, avdst2 As Double, permvalid2() As Double, permdiffs2() As Double, distance2() As Double
            'ReDim distance2(Nextno, Nextno), permvalid2(Nextno, Nextno), permdiffs2(Nextno, Nextno)
            Udst = DistanceCalcX(NextNo, Len(StrainSeq(0)) + 1, PermDIffs(0, 0), PermValid(0, 0), SeqNum(0, 0), Distance(0, 0), AvDst)
            'XX = Distance(1, 3)
            x = x
        Else
       
            
            'SS = Abs(GetTickCount)
            ReDim tRedoDist(NextNo)
            For x = 0 To NextNo
                 tRedoDist(x) = 1
            Next x
            'this is the 4 nt version
            
            
            
            XX = UBound(Distance, 1)
            
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'Do a version of this where permdiffs and permvalid are both in the same array and distance is written to disk
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo), Distance(NextNo, NextNo)
            'Call FastDistanceCalcX(1, 1, Len(StrainSeq(0)), Nextno, PermDiffs(), PermValid(), SeqNum(), Distance(), AvDst, UDst, tRedoDist())
            'SS = abs(gettickcount)
            'For Z = 0 To 10000
            Call FastDistanceCalcZ(0, 1, 1, Len(StrainSeq(0)), NextNo, PermDIffs(), PermValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
            'Next Z

            'EE = Abs(GetTickCount)
            'TT = EE - SS '13797'63.461'62.806 with fastdistancecalc x, 48.813 with fastdistancecalcz
            
            If PermNextno > MemPoc Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                
                UBPermValid = UBound(PermValid, 1)
                Open "RDP5PermValid" + UFTag For Binary As #FF
                Put #FF, , PermValid()
                Close #FF
                
                UBPermDiffs = UBound(PermDIffs, 1)
                Open "RDP5PermDiffs" + UFTag For Binary As #FF
                Put #FF, , PermDIffs()
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            End If
            
            If x = 12345 Then
                 Dim D2() As Double
                    ReDim D2(NextNo, NextNo)
                 
                 For x = 0 To NextNo
                     For Y = 0 To NextNo
                         D2(x, Y) = Distance(x, Y)
                     Next Y
                 Next x
              ' SS = Abs(GetTickCount)
            
            
            
            
            ' This is for the 3 nt version
                 Call FastDistanceCalc3(NextNo, PermDIffs(), PermValid(), SeqNum(), Distance(), AvDst, Udst)
'
'                  EE = Abs(GetTickCount)
'                      TT = EE - SS '15844
                  
                  
                  For x = 0 To NextNo
                      For Y = 0 To NextNo
                          If D2(x, Y) <> Distance(x, Y) Then '
                              x = x
                          End If
                      Next Y
                  Next x
                 
                x = x
            End If
            x = x
        
        
        
        
       ' For x = 0 To Nextno
       '
       '
       ' For Y = 0 To Nextno
       '     If distance2(x, Y) <> Distance(x, Y) Then
       '         x = x
       '     End If
       '     If permvalid2(x, Y) <> PermValid(x, Y) Then
       '         x = x
       '     End If
       '     If permdiffs2(x, Y) <> PermDiffs(x, Y) Then
       '         x = x
       '     End If
       ' Next Y
        
       ' Next x
        
        End If
'         EE = Abs(GetTickCount)
'        TT = EE - SS
        Form1.SSPanel1.Caption = oCap
       ' XX = Distance(7, 60) '0.97
       ' XX = Distance(7, 36) '1.00
       ' XX = PermValid(7, 60) '185
       ' XX = PermValid(7, 36) '17
       ' XX = PermDiffs(7, 60) '4
       ' XX = PermDiffs(7, 36) '0
        oB = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        oB = UBound(Decompress, 1)
        On Error GoTo 0
        If oB < Len(StrainSeq(0)) Then
            ReDim Preserve Decompress(Len(StrainSeq(0)))
            If Decompress(oB) = oB Then
                For x = oB To Len(StrainSeq(0))
                    Decompress(x) = x
                Next x
            End If
        End If
        
'        If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) And X = 12345 Then
'            TotAdd = 0
'            For X = 1 To Decompress(Len(StrainSeq(0)))
'
'                If ABCons(X) > 0 Then
'                    TotAdd = TotAdd + 1
'                End If
'            Next X
'            For X = 0 To Nextno
'                For Y = X + 1 To Nextno
'                    PermValid(X, Y) = PermValid(X, Y) + TotAdd
'                    PermValid(Y, X) = PermValid(X, Y)
'                    If PermValid(X, Y) > 0 Then
'
'                        Distance(X, Y) = 1 - (PermDiffs(X, Y) / PermValid(X, Y))
'                    Else
'                         Distance(X, Y) = -10
'                    End If
'                    X = X
'                Next Y
'            Next X
'        End If
        
        
        '1.150s
        '1.093s - separation of >46's
        '1.079 = instead of !=
        '0.969
        '0.907 - using s1
        '0.843 using int for s1 instead of short int
        '0.813 - using brackets in *Seqnum
        '0.797 - reading nextno as int rather than short int
        '0.562 - compiler maximised for speed!!
        '0.546 - using valid=valid+ rather than ++
       'XX = Form1.Timer1.Enabled
        
        
        
        
    End If
    
    Dim CutOf As Long
    CutOf = Len(StrainSeq(0)) / 100
    If CutOf < 30 Then CutOf = 30
    If CutOf > 50 Then
        CutOf = 50
    End If
    
    
     
    'this is meant to fix the trees that are made from sequences with large amounts of missing data.
    For x = 0 To NextNo
        Distance(x, x) = 1
        For Y = x + 1 To NextNo
            If PermValid(x, Y) < CutOf Then
                
                PermValid(x, Y) = 0
                PermDIffs(x, Y) = 0
                Distance(x, Y) = 0
                PermValid(Y, x) = 0
                PermDIffs(Y, x) = 0
                Distance(Y, x) = 0
            End If
        Next Y
    
    Next x
    
    
    
    
    
    
    
    
    
    AvDst = (AvDst / (NextNo * (NextNo + 1) / 2))
    'Make a note that this doesn't need to be calculated again
    DistanceFlag = 1
    If SPF = 0 Then Form1.SSPanel1 = ""
   
    x = x
End Sub
