Attribute VB_Name = "Module1"

Public FirstPass As Byte, BPCoord(1) As Long, exRelX As Long, exRely As Long, NewBP(1) As Long, ExpectFL As Long, StartProgress As Integer, EndProgress As Integer, DontClick As Byte, Timercheck(1) As Long, ABFl(100) As Byte, TotSignals(255) As Long, TotUSignals(255) As Long, MName As String, VRFlag As Byte, Mat567Len As Long, HorstFlag As Byte, DontDoKey As Byte, VarsitesMC() As Long, VarsitesCM() As Long, VarsitesLD() As Long, DoVS5 As Byte, MatZoom(20) As Double, MatCoord(20, 1) As Long, DoneMatX(10) As Byte, CurScale As Byte, MatBound(20) As Double
Public TypeSeqNumber As Long, xMatPermNo As Long, MatPermNo As Long, MatWinSize As Long, xMatWinSize As Long, CompatMatIJ() As Byte

Public MatrixL() As Double, MatrixMC() As Double, MatrixC() As Byte, MatrixBP() As Double, MatrixLD() As Double, MatrixRMin() As Double, MatrixRMinD() As Double, MatrixRR() As Double, MatrixR() As Double, MatrixM() As Double

Public KPFlag As Byte, MethodTime(20) As Double, TimeFract(20) As Double, CurMatrixFlag As Byte, DoneColFlag As Byte, BestEStore() As Long, aaConv() As Byte, AASeq() As Byte, CurGenes As Long
Public HeatMap(8, 1024) As Long
Public TopBoot As Long, OldBoot As Long
Public TargetFileSize As Long, FullSize As Long
Public uDaught() As Long, uSeqNum() As Integer, uMissingdata() As Byte, uTreetrace() As Long, uNextno As Long, uTreeDistance() As Double, uSeqCol() As Long, uFFillCol() As Long, uDistance() As Double, uStraiName() As String
Public SelGrpFlag As Byte, GrpMaskSeq() As Byte

Public SPSPos As Long, PermSPos As Long
Public CIndex As Byte, F2P2SNum As Long, PValMap() As Single, AvHomol(3) As Double
Public Fact() As Double, BinTable() As Double
Public DoQuick As Byte
Public UDst As Double, SPSN() As Integer, SPD() As Double, SPV() As Double, SPTD() As Double, SPDist() As Double, AddTimes As Long, SchemBlocks() As Long, SBlocksLen As Long, SchemString() As Long, SStringLen As Long
Public DoneTree(3, 3) As Byte, DelSeqNum() As Integer, TBS(10) As String, TreeBlocksL() As Long, TBLLen As Long, TreeBlocks() As Long, TBLen() As Long, TreeDraw() As Long, TDLen() As Long, O31FS As Double, SSOLoSeq As Long, TYF As Double, TYF2 As Double, PPermValid() As Double, PPermDiffs() As Double
Public BPCVal() As Double, BPCvalFlag As Byte, tRecSeqX As Long, PermUDst As Double, PermAvDst As Double, PermDistance() As Double, PermTreeDistance() As Double, PermsCurrentXOver() As Integer, ForcePhylE As Byte, BPListHolder() As Double
Public MCMaxY As Long, DScores() As Double, FCMat() As Double, SCMat() As Double, TarSeq As Long, OSEPAVal As Long, testpa() As Double, NOPINI() As Long
Public TestName(20) As String
Public BestXOListMa() As XOverDefine, BestXOListMi() As XOverDefine, BCurrentXoverMa() As Integer, BCurrentXoverMi() As Integer

Public StepSEn() As Long, StepNextNo As Long, StepSeqnum() As Integer, sPermSeqnum() As Integer
Public ExtraD() As Long, ExtraHits() As Byte, ExtraHitsMa() As Byte, ExtraHitsMi() As Byte, PermSeq1 As Long, PermSeq2 As Long, PermSeq3 As Long, TreeTraceSeqs() As Long, PermNextNo As Long, PermStraiName() As String, TreeFMat() As Double, TreeSMat() As Double, TreeTrace() As Long, TreeSeqNum() As Integer, TreeNextno As Long, TreeStrainName() As String, TreeMatrix() As Double
Public oNextno As Long, PermSeqNum() As Integer, Steps() As Long, StepNo As Long
Public PN As Byte, PNPos() As Byte, MaxXOP() As Double, RedoList() As Long, RedoListSize As Long, DonePVCO() As Double
Public BanWin() As Long, MDMap() As Byte
Public oTotRec As Long, MissingData() As Long
Public TargetX As Long, XOverWindow As Long, LenStrainSeq As Long, NumRecsI() As Long, ColTotals() As Double, ttt, LongSeqNum() As Long, ValidList() As Long, CountList() As Long
Public DistMod() As Double, MinSeqSize As Long, FMatBak() As Double, SMatBak() As Double, CHEvFlag As Long
Public FMat() As Double, SMat() As Double, FAMat() As Double, SAMat() As Double
Public CritPVals() As Double, CPermNo As Long, GPerms As Long, GRndSeed As Long, BestPermP() As Double, APermFlag As Byte

Public SuperEvent(), SEventNumber As Long, NumInE As Long
Public SubValid() As Double, SubDiffs() As Double, PermDiffs() As Double, PermValid() As Double, tPermDiffs() As Long, tPermValid() As Long
Public EventTrace() As Long
Public SimSeqNum() As Integer, SuperEventlist() As Long
Public txSeqNum() As Integer, BackUpNextno As Long, LongFlag As Byte, EventSeq() As Integer, LongWindedFlag As Byte, SERecSeq As Long, SEPAVal As Long

'Option Explicit
Public ShowAllHits() As Byte, GetRidOf(3) As Long, ENumbs As Long, oRecombNo() As Long, RecombNo() As Long, PermDist() As Double, ThirdFlag As Byte, EvN As Long, mtP() As Double, mtEv() As Double
Public RecMap() As Double, BestEvent() As Long, Eventnumber As Long
Public MaxEn() As Long, MinS() As Long, Daught() As Long, MinorPar() As Long, MajorPar() As Long
Public Confirm() As Integer, ConfirmP() As Double, ConfirmMi() As Integer, ConfirmPMi() As Double, ConfirmMa() As Integer, ConfirmPMa() As Double
Public AncSeqS() As String, UnionC(85, 85) As Byte
Public BranchMapX() As Long

'Manual Distanceplot
Public ManGroups() As Long, SelectGroups() As Long, DSeqs() As Byte, CSelect As Long

'Phylpro variable
Public pPPNumSeqs As Long, MRV As Double, MaRV As Double, PPXOSeq() As String, PPWinScore() As Double, PPWinScoreT() As Double, pPhylProFlag As Byte, PhylProFlag As Byte, TotalPPRecombinants As Long, PPWinLen As Long, pPPWinLen As Long, xPPWinLen As Long, PPStripGaps As Long, pPPStripGaps As Long, pIncSelf As Byte, IncSelf As Byte, xPPStripGaps As Long, xIncSelf As Byte, PPPerms As Long, PPSeed As Long

Public togglex As Byte, XL As String, TW As Long

'Make International
Public TmpD As Double

Public ShortOutput() As Byte, DatasetNo As Long

'Ancestral Sequences
Public AncDstMat() As Double, AncSeq() As Integer, BranchMap() As Long, MRCAMat() As Long, ConDeg() As Double

'Plot display during scan
Public StartPlt() As Byte, PDistPlt() As Double, ProbPlt() As Double, HitPlt() As Long, RedoPltL(2) As Byte

'Recombination matrix
Public RecombMatrix() As Double

'Phylip Test Variables
Public DstMat() As Double

'Benchmark Setting
Public BMark As Long

'GUI settings
Public P12X As Long, P12Y As Long, OldAbort As Integer, oScreenHeight As Long, oScreenWidth As Long, TwipPerPix As Integer, oTwipPerPixX As Integer, oTwipPerPixY As Integer, OptionsFlag As Integer
Public BkR As Byte, BkG As Byte, BkB As Byte
Public HAddjust As Double, VAddjust As Double
Public HalfColour As Long, QuaterColour As Long, ThreeQuaterColour As Long, RedBorder As Long, Rejected As Long, FillColour As Long, Form1OHeight As Long, Form1OWidth As Long, Form4OHeight As Long, Form4OWidth As Long, Form2OHeight As Long, Form2OWidth As Long

'Permanant settings for save files
Public pChimaeraFlag As Integer, pSiScanFlag As Integer, pRDPFlag As Integer, pGENECONVFlag As Integer, pBOOTSCANFlag As Integer, pMaxChiFlag As Integer, pLDHatFlag As Integer

'Variables for managing compatibility matrices
Public MaxLim As Long

'Variables for managing display during scan
Public ScanFlagX As Integer, RowSpace As Integer
Public PHMax As Double, PPMax As Double, oDMax As Double, oPMax As Double, AvDst As Double, PerMaxPval As Double, Hitnumber() As Long, MaxHits As Long

'Manual Scan settings
Public RevSeq() As Integer, Selected() As Integer, UYPos() As Integer, SYPos() As Integer
Public OIndex As Long, OManFlag As Integer, TopDistFlag As Integer, ManPFlag As Integer, TManFlag As Integer, ManFlag As Integer, ManMinSeqNo As Integer, ManMaxSeqNo As Integer

'Variables for managing the schematic sequence display
Public GEvents() As Long, MenuUpFlag As Integer, HighlightFlag As Integer
Public ProgNames(10) As String, TimerVal As Integer, ProgF() As Integer, PermArray() As Integer
Public PermYVal2 As Single, PermXVal As Single, PermYVal As Single, OutsideFlagX As Integer, InlyerA As Integer, InlyerB As Integer, SchemFlag As Integer, yPicRef As Long, AddNum As Integer, PRecSeq As Long, RecSeq As Long
Public FFillCol() As Long, SeqCol() As Long
Public AXONoY As Long, AXONo As Long, P2DHeight As Long, PPAVal As Long, PAVal As Long, OPAVal As Long
Public SeqProb2() As Byte
Public NewDirName As String
Public SpaceAdjust As Double, AdjArrayPos As Double, XPicAddjust As Double, MaxLogPValSch As Double, MinLogPValSch As Double, MaxDistSch As Double, MinDistSch As Double

'Variables for managing the sequence display
Public GTCS As Long, ltPosX As Integer, ltPosY As Integer, HScroll1Mod As Integer, ShowSeqFlag As Integer, PrintSeqLen As Integer
Public SeqColRef() As Integer, Identical() As Integer, ColDist() As Integer, IDCount() As Integer
Public SiteHomol() As Long, MoveSeq As Double, P3MouseDown As Integer, WinLeft As Long, DontDoComboFlag As Integer, SubMaskSeq() As Integer, GCIDCount() As Integer, MCIDCount() As Integer, GCXDiffPos() As Long, GCXPosDiff() As Long
Public LastY3 As Long, YStrain As Long, WinCount As Long
Public Output() As String, GCXOverSeq() As String, MCXoverSeq() As String
Public GapChar As String
Public GCIdentical() As Byte, MCIdentical() As Byte

'Variables for managing the plot display
Public APlot As Long, P7PixCol As Long, PicHeight As Integer, Pic7PointerVal As Integer, CopyFlag As Integer, OptFlag As Integer, ExeCheckFlag As Integer, Over7Flag As Integer
Public RefCol() As Long, PltPos() As Long
Public PltVal() As Double, MCPrintData() As Double, MCPrintPos() As Double
Public XFactor As Double, MinPx As Double, MaDistance As Double, MiDistance As Double

'Variables for managing tree display(s)
Public ETSeqNum() As Integer, TSeqLen As Long, TreeSeqMap() As Long, TreeSeqs() As Integer, CurTree() As Integer, XCord() As Integer, YCord() As Integer, RYCord() As Integer, TTFlag() As Integer, NodeYPos() As Integer, TreeX() As Integer, TreeY() As Integer, TreeImage(3) As Integer, NewNo() As Integer, ColourSeq() As Integer, TreeRX() As Integer, TreeRY() As Integer
Public TreeTypeFlag As Integer, CTF As Integer, TRegion As Integer, Outie As Long, LChange As Integer, Pic2MD As Integer, PartFlag As Integer, NJDrawFlag As Integer, F2TreeIndex As Integer, TreeDistFlag As Integer
Public TempSeq() As String, NHString() As String
Public MultColour() As Long
Public TreeRLen() As Long, BTree As Long, ETree As Long, SelCol As Long, BeginMark As Long, EndMark As Long, NextnoB As Long
Public TreeDistance() As Double, NodeLength() As Double
Public LargestDist As Double
Public TBSReps As Integer, TRndSeed As Long, TTVRat As Double, TModel As Integer, TCoeffVar As Double, TBaseFreqFlag As Integer, TAfreq As Double, TCFreq As Double, TGFreq As Double, TTFreq As Double, TPower As Double, TNegBLFlag As Integer, TSubRepsFlag As Integer, TGRFlag As Integer, TRndIOrderFlag As Integer
Public xTModel As Integer, xTBaseFreqFlag As Integer, xTNegBLFlag As Integer, xTSubRepsFlag As Integer, xTGRFlag As Integer, xTRndIOrderFlag As Integer
Public OSS2 As Boolean, OSS8 As Boolean, OSS5 As Boolean, OP3 As Boolean, OP5 As Boolean, OP16 As Boolean
Public SDLen() As Integer, SSeqXPos() As Double, SSeqYPos() As Double, SNodeXPos() As Double, SNodeYPos() As Double, SNodePath() As Long

'Variables for managing the recombination info window
Public RecSeqX As Long, PAValX As Long, P2YVal As Long, HLFlag As Long

'Variables for managing shelled apps
Public PBStart As Integer, PBTarget As Integer, BatIndex As Integer
Public scWndJob As Long, gcProcess As Integer, hProcess As Long, scProcess As Long, cProcess As Long, OutSize As Long, reProcess As Long, mcProcess As Long, gcmcProcess As Long

'SiScan variables
Public SSSubSeq() As String, PltCol3() As Long, PScores() As Byte, SSOLSeq As String, SSOLSeqName As String, PltCol2() As Long, PltCol() As Long
Public oSeq As Integer, ManSSOLSeq As Integer, SSUp As Double, SSLo As Double, SSFastFlag, SSGapFlag As Byte, SSVarPFlag As Byte, SSOutlyerFlag As Byte, SSRndSeed As Long, SSWinLen As Long, SSStep As Long, SSNumPerms As Long, UCriticalZ As Double, CriticalZ As Double, TotalSSRecombinants As Long, SSS As Long, SSE As Long
Public pSSFastFlag, pSSGapFlag As Byte, pSSVarPFlag As Byte, pSSOutlyerFlag As Byte, pSSRndSeed As Long, pSSWinLen As Long, pSSStep As Long, pSSNumPerms As Long
Public pSSNumPerms2 As Long, xSSNumPerms2 As Long, SSNumPerms2 As Long, xSSFastFlag, xSSGapFlag As Byte, xSSVarPFlag As Byte, xSSOutlyerFlag As Byte, xSSRndSeed As Long, xSSWinLen As Long, xSSStep As Long, xSSNumPerms As Long

'TOPAL variables
Public DistMatrix() As Single
Public SSScore() As Double, HighestDSS() As Double, SmoothDSS() As Double
Public TOSeq() As String
Public ToSeqGenCLine As String
Public TotMat() As Double, LastMatrix() As Double, TOCoeffVar As Double, TOHigh As Double, MatAverage As Double, TOPower As Double, TOPValCOff As Double, TOTvTs As Double, TOFreqFlag As Double, TOFreqA As Double, TOFreqC As Double, TOFreqG As Double, TOFreqT As Double, xTOTsTv As Double
Public TOTSeqNum() As Integer
Public TOEndPlot As Long
Public xTOWinLen As Long, ToNumSeqs As Long, TOPFlag As Integer, TORndNum As Integer, TOModel As Integer, TOTreeType As Integer, TOPerms As Integer, TOWinLen As Integer, TOStepSize As Integer, TOSmooth As Integer, xTOModel As Integer, xToTreeType As Integer, xToFreqFlag As Integer

'Reticulate variables
Public FormatFlag As Integer, RETFlag As Integer, Square As Integer, MatrixFlag As Integer, RepaintFlag As Integer, ZoomFlag As Integer, RedoReticulateFlag As Integer, RetSiteFlag As Integer, RetNumMatrixFlag As Integer, xRetSiteFlag As Integer, xRetNumMatrixFlag As Integer
Public RetXPos() As Long, RetYPos() As Long
Public EndY As Long, Varsites As Long
Public MatLine As String
Public RetPlot() As Double
Public XYFactor As Double, MaxWhite As Double, MinWhite As Double, RetPVal As Double, RetOCompat As Double, RetNSS As Double

'Distance plot variables
Public xDPModelFlag As Integer, xDPBFreqFlag As Integer, DPBFreqFlag As Integer, DPModelFlag As Integer
Public DPWindow As Long, DPStep As Long
Public MinDistX As Double, MaxDistX As Double, DPTVRatio As Double, DPBFreqA As Double, DPBFreqC As Double, DPBFreqG As Double, DPBFreqT As Double, DPCoeffVar As Double, xDPTVRatio As Double

'Colour schemes
Public BackColours As Long, Purple As Long, LGreen As Long, Green As Long, LPurple As Long, Yellow As Long, LYellow As Long, mPurple As Long, mYellow As Long, mGreen As Long
Public ProgColour() As Long

'LARD variables
Public xLRDBaseFreqFlag As Integer, xLRDModel As Integer, LRDStep As Integer, LRDBaseFreqFlag As Integer, LRDModel As Integer, LRDCategs As Integer
Public LSurface() As Double
Public MinL As Double, MaxL As Double, LRDCodon1 As Double, LRDCodon2 As Double, LRDCodon3 As Double, LRDAFreq As Double, LRDCFreq As Double, LRDGFreq As Double, LRDTFreq As Double, LRDShape As Double, LRDTvRat As Double, LRDACCoeff As Double, LRDAGCoeff As Double, LRDATCoeff As Double, LRDCGCoeff As Double, LRDCTCoeff As Double, LRDGTCoeff As Double
Public lWndJob As Long, lProcess As Long, LXPos() As Long
Public LRDRegion As Long

'File management
Public WholeFileFlag As Integer, ErrorFlag As Integer, RLFlag As Integer, SaveFlag As Integer, SaveBMPFlag As Integer, SaveTxtFlag As Integer, OldFileFlag As Integer
Public FileList() As String, RecombSeq() As String
Public DefExt As String, SeqFile As String, FNameII As String, FName As String, SFName As String, EMFFName As String

'MaxChi/Chimaera variables
Public lHWindowWidth As Long, pHWindowWidth As Long, MaxY As Integer, LoHiFlag As Byte, MCCorrect As Long, HWindowWidth As Long, CriticalChi As Double, CriticalDiff As Long, SubSetF() As Integer, SubSetR() As Integer, MCWarningFlag() As Integer, PeakNumber() As Integer, MCXDiffPos() As Long, MCXPosDiff() As Long
Public NoMCFlag As Integer, IncludeSeq As Integer, MCStripGapsFlag As Integer, xMCStripGapsFlag As Integer, pMCStripGapsFlag As Integer, xMCProportionFlag As Integer, pMCFlag As Integer, pMCSteplen As Integer, xMCSteplen As Integer, pMCTripletFlag As Integer, pMCProportionFlag As Integer, xMCTripletFlag As Integer, MCSteplen As Integer, MCOverlapL As Integer, MCOverlapR As Integer, MCTripletFlag As Integer, MCProportionFlag As Integer
Public MCFullFile As String, MaxChiCline As String
Public MCRndSeed As Long, MCFile() As Long, mmcProcess As Long, MCFullOL As Long, MCFullOR As Long, XOverListSize As Long, MCMaxX As Long, MCMaxZ As Long, pMCWinSize As Long, pMCStart As Long, pMCEnd As Long, pMCPerms As Long, xMCPerms As Long, xMCWinSize As Long, xMCStart As Long, xMCEnd As Long, MCWinSize As Long, MCPerms As Long, MCStart As Long, MCEnd As Long
Public PeakPair() As Double
Public xMCPermMaxP As Double, xMCMaxP As Double, xMCWinFract As Double, pMCMaxP As Double, pMCPermMaxP As Double, pMCWinFract As Double, MCMinChiP As Double, MCPermMaxP As Double, MCMaxP As Double, MCWinFract As Double
Public SmoothChi() As Double, SmoothChiX() As Double, Scores() As Byte, ScoresX() As Byte, WinScoresX() As Long, WinScores() As Long, ChiVals() As Double, ChiValsX() As Double, ChiPVals() As Double, ChiPValsX() As Double

'Chimaera Variables
Public CXoverSeq() As String
Public xLenXoverSeq() As Long
Public xCProportionFlag As Integer, pCProportionFlag As Integer, CProportionFlag As Integer
Public CRndSeed As Long, pCWinSize As Long, pCPerms As Long, xCPerms As Long, xCWinSize As Long, CWinSize As Long, CPerms As Long
Public xCPermMaxP As Double, xCMaxP As Double, xCWinFract As Double, pCMaxP As Double, pCPermMaxP As Double, pCWinFract As Double, CMinChiP As Double, CPermMaxP As Double, CMaxP As Double, CWinFract As Double

'LDHat Variables
Public TotalLDRecombinants As Long

'RDP Variables
Public RDPUD As Double, RDPLD As Double
Public Outlyer As Integer, FirstDrawFlag As Integer, SpacerNo As Integer, ntInCommon As Integer, XOverWindowX As Integer, SpacerFlag As Integer
Public SpacerFlagT  As Byte
Public Spacer4No As Long
Public AvBkgHomology As Double
Public XOverSeqNumW() As Byte, XOverSeqNum() As Integer, SpacerSeqs() As Integer, XPosdiff() As Long, XDiffpos() As Long, ValidSpacer() As Integer
Public OLSeq As Long, LenXOverSeq As Long, InRangeFlag As Integer
Public XOverLength As Long, pXOverWindowX As Long, xXOverWindowX As Long
Public XOverSeq() As String
Public ProbTest As String
Public XOverHomologyNum() As Long
Public indprob As Double, ProbX As Double, ProbY As Double, AddjustFactor As Double, ProbabilityXOver As Double, NFactorial As Double, MFactorial As Double

'General Settings
Public PValCat() As Long, MaxPValCat() As Double, CurrentXover() As Integer, MaskSeq() As Integer, SeqSpaces() As Integer, SeqNum() As Integer, pMaskSeq() As Integer
Public CurrentCorrect As Byte, MaxXOListSize As Long, Beginning As Integer, Ending As Integer, RecombineFlag As Integer, CircularFlagT As Integer, WeightedFlagT As Integer, HomologyIndicatorT As Integer, ShowPlotFlagT As Integer, CircularFlag As Integer, ShowPlotFlag As Integer, RunFlag As Integer, NJFlag As Integer, DistanceFlag As Integer, AbortFlag As Integer, xCircularFlag As Integer, xSpacerFlag As Integer, xMCFlag As Integer, MCFlagT As Integer, MCFlag As Integer, pCircularFlag As Integer, pSpacerFlag As Integer
Public TBkgHomol() As Double, ValidSite() As Double, Distance() As Double, AnalT() As Double
Public pLowestProb As Double, xLowestProb As Double, LowestProb As Double
Public Pos As Long, NextNo As Long
Public PolishBPFlag As Byte, Realignflag As Byte, ConsensusProg As Byte, xConsensusProg As Byte
Public StraiName()  As String, StrainSeq() As String
Public VarString As String

'Checking variables
Public CurrentCheck As Integer

'Recombinant scanning
Public RFlag() As Integer
Public Seq1 As Long, Seq2 As Long, Seq3 As Long, ShortOutFlag As Integer, ChimaeraFlag As Integer, SiScanFlag As Integer, RDPFlag As Integer, GENECONVFlag As Integer, LDHatFlag As Integer, BOOTSCANFlag As Integer, MaxChiFlag As Integer, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, IndividualA As Integer, IndividualB As Integer
Public MCCorrection As Long
Public CLine As String
Public ST As Double, ET As Double, GCST As Double, MCS As Double, MCE As Double, ChiS As Double, ChiE As Double, lds As Double, LDE As Double

'ManualBootscan variables
Public NumberOfSeqs As Long

'Auto-Bootscan variables

Public BSHi1 As Long, BSHi2 As Long, BSLo As Long
Public pBSPValFlag, xBSPValFlag As Byte, BSPValFlag As Byte, GoOnA() As Integer, GoOnB() As Integer, BSRWBuffer As Long, BSRSize As Long, BSRWSize As Long, BSWinRWChunk As Long, BSFilePos() As Long
Public BSFileName As String, InFileX As String, OutFileX As String
Public xBSBootReps As Long, xBSSubModelFlag As Integer, BSBootReps As Long, BSRndNumSeed As Integer, BSSubModelFlag As Integer, BSTypeFlag As Integer, xBSTypeFlag As Integer, BSCTypeFlag As Integer, xBSCTypeFlag As Integer, BSFreqFlag As Integer, xBSFreqFlag As Integer, BSFreqA As Double, BSFreqC As Double, BSFreqG As Double, BSFreqT As Double
Public xBSStepWin As Long, xBSStepSize As Long, BSStepWin As Long, BSStepSize As Long, s1col As Long, s2col As Long, s3col As Long, s1colb As Long, s2colb As Long, s3colb As Long
Public xBSTTRatio As Double, BSTTRatio As Double, xBSCutoff As Double, pBSCutoff As Double, BSCutOff As Double, BSStart As Double, BSEnd As Long
Public pBSTypeFlag As Integer, pBSStepSize As Long, pBSStepWin As Long, pBSBootReps As Long

'Bootscan check variables
Public BSCCenterFlag As Integer, BSCDecreaseStepFlag As Integer
Public BSCDStepWin As Long, BSCDStepSize As Long, BSCDSpan As Long, BSCStepWin As Long, BSCStepSize As Long, BSCBootReps As Integer
Public BSCoeffVar As Double
Public SimSeq As String

'GENECONV variables
Public HighEnough(5) As Long, HiFragScore(5) As Long, PVals() As Double, FragMaxScore() As Long, MaxScorePos() As Long
Public SubSeq() As Byte
Public xGCTripletFlag As Byte, pGCTripletflag As Byte, GCtripletflag As Byte, GCFoundSitesFlag As Byte
Public GCSeq() As String
Public GCGroups() As String, GCOutfileName As String, GCFragSeq As String, GCCompCfg As String, GCPOutCfg As String, GCFragCfg As String, GCOFile As String, GCCFile As String
Public GCEnabledNo() As Integer, RevGCIndex1() As Integer, RevGCIndex2() As Integer, GCImageIndex() As Integer
Public GCMCCheckFlag As Integer, NumEnabledSeqs As Integer, NextGCImage As Integer, xGCPermPolyFlag As Integer, GCPermPolyFlag As Integer, xGCLogFlag As Integer, xGCOutFlag As Integer
Public xGCOutFlagII As Integer, xGCSortFlag As Integer, xGCSeqTypeFlag As Integer, xGCIndelFlag As Byte, xGCCodeFlag As Integer, xGCMonoSiteFlag As Integer, GCLogFlag As Integer, GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer, GCMaxOverlapFrags As Integer
Public pGCMissmatchPen As Integer, pGCIndelFlag As Byte, pGCMinFragLen As Integer, pGCMinPolyInFrag As Integer, pGCMinPairScore As Integer, pGCMaxOverlapFrags As Integer
Public GCMissmatchPen As Integer, GCSeq1 As Integer, GCSeq2 As Integer, GCSeq3 As Integer, GCOutFlag As Integer, GCOutFlagII As Integer, GCSortFlag As Integer, GCSeqTypeFlag As Integer, GCIndelFlag As Byte, GCCodeFlag As Integer, GCMonoSiteFlag As Integer
Public FragSt() As Long, FragEn() As Long, FragScore() As Long
Public GCSeqRange() As Long, xGCSeqRange() As Long
Public GCMaxPairFrags As Long, GCMaxGlobFrags As Long, MaskFlag As Long, GCMCCorrection As Long, GCNumPerms As Long, GCEndLen As Long, GCOffsetAddjust As Long
Public MinGCP As Double, GCMaxPermPVal As Double, MinP() As Double, MinPVal As Double
Public GCGroupFlag As Byte

'Managing recombination checks
Public RelX As Long, RelY As Long, RecStart As Long, RecEnd As Long
Public RecProb As Double

'Managing ORFMaps and GenBank files
Public ORFWin() As Integer
Public ORFFlag As Integer, HighlightFlagII As Integer
Public GBFile As String
Public Pic20PointerVal As Single

'Homology display
Public FullWindowSize As Integer, Pic4PointerVal As Integer, Pic11PointerVal As Integer, Pic4Flag As Integer, Pic11Flag As Integer, Chunk As Integer, HomologyIndicator As Integer
Public BkgHomology() As Double
Public MinHomology As Double, MaxHomology As Double

Private Type BITMAPINFOHEADER '40 bytes
    biSize As Long
    biWidth As Long
    biHeight As Long
    biPlanes As Integer
    biBitCount As Integer
    biCompression As Long
    biSizeImage As Long
    biXPelsPerMeter As Long
    biYPelsPerMeter As Long
    biClrUsed As Long
    biClrImportant As Long
End Type

Type POINTAPI
    XPos As Long
    Y As Long
End Type
Type XOverDefine
    OutsideFlag As Byte '1
    MissIdentifyFlag As Byte '1
    ProgramFlag As Byte '1
    SBPFlag As Byte '1
    Accept As Byte '1
    MajorP As Integer '2
    MinorP As Integer '2
    Daughter As Integer '2
    Beginning As Long '4
    Ending As Long '4
    LHolder As Long '4
    Eventnumber As Long '4
    PermPVal As Single '4
    BeginP As Single '4
    EndP As Single '4
    Probability As Double '8
    DHolder As Double '8
    
'    NumPoly As Long '4
'    NumDiffs As Long '4
'    TotDiffs As Long '4
'    MisPen As Variant '16
    
'    BeginPermP As Double '8
'    EndPermP As Double '8
'    TreePos(2) As Long '4
    
End Type
Type GenomeFeatureDefine
    Orientation As Integer
    Frame As Integer
    Start As Integer
    End As Integer
    IntronFlag As Integer
    ExonNumber As Integer
    StartInAlign As Integer
    EndInAlign As Integer
    Name As String
    Product As String
End Type
Type RECT
    left As Long
    Top As Long
    right As Long
    Bottom As Long
End Type
Type LOGPEN
    lopnStyle As Long
    lopnWidth As POINTAPI
    lopnColor As Long
End Type

Private Type RGBQUAD
    rgbBlue As Byte
    rgbGreen As Byte
    rgbRed As Byte
    rgbReserved As Byte
End Type
'Modified 8-bit BMI type
Private Type BITMAPINFO
    bmiHeader As BITMAPINFOHEADER
    bmiColors(255) As RGBQUAD
End Type

Type site_type
    PT(4) As Long
    nt As Long
    ld_stat(3) As Double
End Type

'LDHat variables
Public idum As Long

Type data_sum
    NSeq As Long
    LSeq As Long
    tlseq As Long
    lc As Byte
    avc As Double
    rho As Double
    lkmax As Double
    LD(4) As Double
    rme As Double
    rce As Long
End Type

Type MEMORYSTATUS
    dwLength    As Long ' sizeof(MEMORYSTATUS)
    dwMemoryLoad    As Long ' percent of memory in use
    dwTotalPhys As Long ' bytes of physical memory
    dwAvailPhys As Long ' free physical memory bytes
    dwTotalPageFile As Long ' bytes of paging file
    dwAvailPageFile As Long ' free bytes of paging file
    dwAvailVirtual  As Long ' user bytes of address space
    dwTotalVirtual  As Long ' free user bytes
End Type

Type RGBTRIPLE
        rgbtBlue As Byte
        rgbtGreen As Byte
        rgbtRed As Byte
End Type

Type BITMAP '14 bytes
        bmType As Long
        bmWidth As Long
        bmHeight As Long
        bmWidthBytes As Long
        bmPlanes As Integer
        bmBitsPixel As Integer
        bmBits As Long
End Type
Type BITMAPCOREHEADER '12 bytes
        bcSize As Long
        bcWidth As Integer
        bcHeight As Integer
        bcPlanes As Integer
        bcBitCount As Integer
End Type
Type BITMAPCOREINFO
        bmciHeader As BITMAPCOREHEADER
        bmciColors As RGBTRIPLE
End Type
Type BITMAPFILEHEADER
        bfType As Integer
        bfSize As Long
        bfReserved1 As Integer
        bfReserved2 As Integer
        bfOffBits As Long
End Type
Type BITMAPV4HEADER
        bV4Size As Long
        bV4Width As Long
        bV4Height As Long
        bV4Planes As Integer
        bV4BitCount As Integer
        bV4V4Compression As Long
        bV4SizeImage As Long
        bV4XPelsPerMeter As Long
        bV4YPelsPerMeter As Long
        bV4ClrUsed As Long
        bV4ClrImportant As Long
        bV4RedMask As Long
        bV4GreenMask As Long
        bV4BlueMask As Long
        bV4AlphaMask As Long
        bV4CSType As Long
        bV4Endpoints As Long
        bV4GammaRed As Long
        bV4GammaGreen As Long
        bV4GammaBlue As Long
End Type




Public XOverList() As XOverDefine
Public PermsXOverList() As XOverDefine

Public GeneList() As GenomeFeatureDefine
Public MemSit As MEMORYSTATUS
'Phylip declares
'DNADIST
Declare Function SEQBOOT Lib "dna.dll" (ByVal RandomNumberSeed As Long, ByVal NumberOfBootstrapReps As Integer, ByVal NumberOfSites As Long, ByRef ScratchPatchArray As Integer, ByRef WeightModArray As Long) As Double
Declare Function SEQBOOT2 Lib "dna.dll" (ByVal RandomNumberSeed As Long, ByVal NumberOfBootstrapReps As Integer, ByVal NumberOfSites As Long, ByRef ScratchPatchArray As Integer, ByRef WeightModArray As Long) As Double
Declare Function DNADIST Lib "dna.dll" (ByVal CoeffVariation As Double, ByVal TransitionTransversionRatio As Double, ByVal BaseFreqFlag As Integer, ByVal DistModelFlag As Integer, ByVal AFrequency As Double, ByVal CFrequency As Double, ByVal GFrequency As Double, ByVal TFrequency As Double, ByVal NumberOfSequences As Long, ByVal NumberOfSites As Long, ByRef IntSeqString As Integer, ByRef AliasArray As Long, ByRef AllyArray As Long, ByRef WeightArray As Long, ByRef LocationArray As Long, ByRef PXArray As Integer, ByRef xx1Array As Integer, ByRef xx2Array As Integer, ByRef Product1Array As Double, ByRef Product2Array As Double, ByRef Product3Array As Double, ByRef DistanceMatrixArray As Double) As Double
Declare Function BootDist Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal CoeffVariation As Double, ByVal TransitionTransversionRatio As Double, ByVal DistModelFlag As Integer, ByVal NumberOfSequences As Long, ByVal NumberOfSites As Long, ByRef IntSeqString As Integer, ByRef AliasArray As Long, ByRef AllyArray As Long, ByRef WeightArray As Long, ByRef LocationArray As Long, ByRef PXArray As Integer, ByRef xx1Array As Integer, ByRef xx2Array As Integer, ByRef Product1Array As Double, ByRef Product2Array As Double, ByRef Product3Array As Double, ByRef DistanceMatrixArray As Double, ByRef DistanceValue As Double, ByRef Numerator1 As Long, ByRef Numerator2 As Long, ByRef Denominator As Long, ByRef Numerator As Double, ByRef WeightModifier As Long) As Integer
'Declare Function MakeV Lib "dna.dll" (ByVal freqax As Double, ByVal freqcx As Double, ByVal freqgx As Double, ByVal freqtx As Double, ByVal freqarx As Double, ByVal freqgrx As Double, ByVal freqcyx As Double, ByVal freqtyx As Double, ByVal cvix As Double, ByVal fracchangex As Double, ByVal xvx As Double, ByVal tmodelx As Integer, ByVal numspx As Long, ByVal sitesx As Long, ByVal endsitex As Long, ByRef weightx As Long, ByRef xx1x As Double, ByRef xx2x As Double, ByRef pxx As Integer, ByRef prodx As Double, ByRef prod2x As Double, ByRef prod3x As Double, ByRef dstmatx As Double) As Integer
'Declare Function NEIGHBOUR Lib "C:\Program Files\DevStudio\MyProjects\DNA\Debug\dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Double, ByRef HolderForOutTree As Integer) As Long
Declare Function NEIGHBOUR Lib "dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Double, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Double, ByRef TreeDistanceArray As Double) As Long
Declare Function NEIGHBOUR2 Lib "dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Double, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Double, ByRef TreeDistanceArray As Double) As Long

'Declare Function JCDist Lib "dna.dll" (ByVal BootstrapReplicates As Integer, ByVal JCORSimFlag As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef WeightModifyer As Long, ByRef Numerator2 As Long, ByRef Denominator As Long) As Long
Declare Function GetPltVal Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal YPosition As Long, ByRef Total0 As Integer, ByRef Total1 As Integer, ByRef Total2 As Integer, ByRef PlotValueArray As Double) As Long
Declare Function GetPltVal2 Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal StartPosition As Long, ByVal EndPosition As Long, ByRef Total0 As Integer, ByRef Total1 As Integer, ByRef Total2 As Integer, ByRef PlotValueArray As Double) As Long
Declare Function MakeSubAlign Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Long, ByVal LengthOfFullSequence As Long, ByVal WindowNumber As Long, ByVal SizeOfStep As Long, ByVal SizeOfWindow As Long, ByRef SubAlignmentInIntegerArray As Integer, ByRef AlignmentInIntegerArray As Integer) As Long
Declare Function DubToInt Lib "dna.dll" (ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal NumberBootReps As Integer, ByVal NumberOfSequencesMinusOne As Long, ByRef InArray As Double, ByRef OutArray As Integer) As Long
'Declare Function TreeToArray Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Integer, ByRef TemporaryArray As Double, ByRef RootNodeArray As Long) As Double
Declare Function TreeToArray Lib "dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Byte, ByRef TemporaryArray As Double, ByRef NodeOrderArray As Long, ByRef DoneNodeArray As Long, ByRef TempNodeOrderArray As Long, ByRef RootNodeArray As Long, ByRef NodeLenArray As Double, ByRef NumDonex As Double) As Double
Declare Function TreeToArrayB Lib "dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Integer, ByRef TemporaryArray As Double, ByRef NodeOrderArray As Long, ByRef DoneNodeArray As Long, ByRef TempNodeOrderArray As Long, ByRef RootNodeArray As Long, ByRef NodeLenArray As Double) As Double

Declare Function ScanPositive Lib "dna.dll" (ByVal WindowNumber As Long, ByVal BootScanCutOff As Double, ByVal CutOffCount As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal NumberOfSequencesx As Long, ByVal BootStrapReplicates As Integer, ByRef GoOnHolderA As Integer, ByRef GoOnHolderB As Integer, ByRef SequenceOrder As Byte, ByRef DistanceMatrix As Double) As Long
'Metafile declares
Declare Function CloseEnhMetaFile Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function CreateFont Lib "gdi32" Alias "CreateFontA" (ByVal H As Long, ByVal w As Long, ByVal E As Long, ByVal O As Long, ByVal w As Long, ByVal i As Long, ByVal u As Long, ByVal S As Long, ByVal C As Long, ByVal OP As Long, ByVal CP As Long, ByVal q As Long, ByVal PAF As Long, ByVal F As String) As Long
Declare Function CreatePenIndirect Lib "gdi32" (lpLogPen As LOGPEN) As Long
Declare Function CreateEnhMetaFile Lib "gdi32" Alias "CreateEnhMetaFileA" (ByVal hdcref As Long, ByVal lpFileName As String, lpRect As RECT, ByVal lpDescription As String) As Long
Declare Function DeleteEnhMetaFile Lib "gdi32" (ByVal hemf As Long) As Long
Declare Function LineTo Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long) As Long
Declare Function MoveToEx Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long, lpPoint As POINTAPI) As Long
Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function TextOut Lib "gdi32" Alias "TextOutA" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal lpString As String, ByVal NCount As Long) As Long
Declare Function SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
'DIB Functions
Declare Function GetPixel Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long) As Long
Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Declare Function SetPixelV Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal crColor As Long) As Long
Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function StretchBlt Lib "gdi32" (ByVal hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Declare Function SetDIBits Lib "gdi32" (ByVal hdc As Long, ByVal hBitmap As Long, ByVal nStartScan As Long, ByVal nNumScans As Long, lpBits As Any, lpBI As BITMAPINFO, ByVal wUsage As Long) As Long
'Shell declares
Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
'Declare Sub ExitProcess Lib "kernel32" (ByVal uExitCode As Long)
Declare Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As Long, lpExitCode As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
'Declare Function ShellAbout Lib "shell32.dll" Alias "ShellAboutA" (ByVal hwnd As Long, ByVal szApp As String, ByVal szOtherStuff As String, ByVal hIcon As Long) As Long
Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
'Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
'Time functions
Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Declare Function GetTickCount Lib "kernel32" () As Long
'Memory managemnet declares
Declare Sub GlobalMemoryStatus Lib "kernel32.dll" (lpBuffer As MEMORYSTATUS)
'Misc Declares
Declare Function GetBkColor Lib "gdi32" (ByVal hdc As Long) As Long
'Custom C functions
Declare Function CopyString Lib "dna.dll" (ByVal lseqx As Long, ByRef SeqNumArray As Integer, ByVal SeqString As String, ByRef seqspacesx As Integer) As Integer
'Declare Function CopyStringB Lib "dna.dll" (ByVal LSeqX As Long, ByRef SeqNumArray As Integer, ByVal SeqString As String) As Integer
Declare Function CopyStringC Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByRef xoverseqnumx As Integer, ByVal xoverseqx As String) As Integer
Declare Function CopyStringD Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByRef SeqNumx As Integer, ByRef xdiffposx As Long, ByVal StringX As String) As Integer
Declare Function FindSubSeq Lib "dna.dll" (ByRef AH As Long, ByVal spacerflagx As Integer, ByVal outlyerx As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal Nextnox As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqNumx As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xdiffposx As Long, ByRef xposdiffx As Long, ByRef validspacerx As Integer) As Integer 'ByVal var3x As Integer

Declare Function FindSubSeq2 Lib "dna.dll" (ByVal spacerflagx As Integer, ByVal outlyerx As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal Nextnox As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqNumx As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Integer, ByRef spacerseqsx As Integer, ByRef xdiffposx As Long, ByRef xposdiffx As Long, ByRef validspacerx As Integer) As Integer  'ByVal var3x As Integer
Declare Function FindSubSeqB Lib "dna.dll" (ByVal LenSeqx As Long, ByVal Nextnox As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqNumx As Integer, ByRef xdiffposx As Long, ByRef xposdiffx As Long) As Integer   'ByVal var3x As Integer
Declare Function FindSubSeqC Lib "dna.dll" (ByVal LenSeqx As Long, ByVal Nextnox As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqNumx As Integer, ByRef xdiffposx As Long, ByRef xposdiffx As Long) As Integer   'ByVal var3x As Integer
Declare Function FindSubSeqD Lib "dna.dll" (ByVal LenSeqx As Long, ByVal Nextnox As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqNumx As Integer, ByRef xdiffposx As Long, ByRef xposdiffx As Long) As Integer    'ByVal var3x As Integer

Declare Function ShiftDown Lib "dna.dll" (ByVal diffspacex As Integer, ByVal lseqx As Long, ByVal LastDimx As Integer, ByVal LastEndx As Integer, ByRef arrayx As Integer) As Integer
Declare Function ShiftUp Lib "dna.dll" (ByVal diffspacex As Integer, ByVal lseqx As Long, ByVal LastDimx As Integer, ByVal LastEndx As Integer, ByRef arrayx As Integer) As Integer
Declare Function FillArray Lib "dna.dll" (ByVal fillvalx As Integer, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal LenSeq As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function FillArray2 Lib "dna.dll" (ByVal Addj As Double, ByVal fillvalx As Integer, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal LenSeq As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function ModPermArray Lib "dna.dll" (ByVal Frm1Pic5ScaleWidth As Long, ByVal UB As Long, ByVal LastDim As Long, ByVal SPos As Long, ByVal B As Long, ByRef PermArray As Integer, ByRef TempArray As Integer) As Long

Declare Function FindSlot Lib "dna.dll" (ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal sposx As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function ReFindSlot Lib "dna.dll" (ByVal AdjPos As Double, ByVal picwid As Long, ByVal lseqx As Long, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function XOHomology Lib "dna.dll" (ByVal Inlyerx As Integer, ByVal lenstrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef xoverseqnumwx As Byte, ByRef xoverhomologynumx As Long) As Integer
Declare Function WinScoreCalc Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long
Declare Function WinScoreCalc2 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long
Declare Function WinScoreCalc3 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long, ByRef PositionsOfDiffs2 As Long) As Long
Declare Function WinScoreCalc4 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long

Declare Function XOHomologyB Lib "dna.dll" (ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal Inlyerx As Integer, ByVal lenstrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef homologycountholder As Double, ByRef ArrayWithSequences As Integer, ByRef AvHomolx As Double, ByRef xdifposx As Long) As Integer
Declare Function ProbCalc Lib "dna.dll" (ByRef Fact As Double, ByVal xoverlengthx As Integer, ByVal numincommonx As Integer, ByVal indprobx As Double, ByVal LenXoverSeqx As Long) As Double
Declare Function DistanceCalc Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double) As Double
Declare Function DistanceCalcX Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Double, ByRef ValidSitesArray As Double, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double) As Double
Declare Function DistanceCalcY Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Double, ByRef ValidSitesArray As Double, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double, ByRef DistanceModifier As Double) As Double
Declare Function DistanceCalcZ Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Double, ByRef ValidSitesArray As Double, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double, ByRef valy As Long, ByRef CountY As Long) As Double
Declare Function DistanceCalcW Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Double, ByRef ValidSitesArray As Double, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double, ByRef InvovedArray As Long) As Double

Declare Function BSSubSeq Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef SequencesInIntegerArray As Integer, ByRef xposdiffx As Long, ByRef xdiffposx As Long, ByRef ScoresX As Byte) As Long
'Declare Function DistanceCalc2 Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double) As Double
Declare Function DistanceCalcB Lib "dna.dll" (ByVal Nextnox As Integer, ByVal LenSeqx As Long, ByVal nonspacernox As Integer, ByRef SeqNumx As Integer, ByRef DistanceX As Double, ByRef validsitex As Double) As Double
Declare Function DistanceCalcC Lib "dna.dll" (ByVal Nextnox As Integer, ByVal LenSeqx As Long, ByVal Startx As Long, ByVal Endx As Long, ByRef SeqNumx As Integer, ByRef DistanceX As Double, ByRef validsitex As Double) As Double
Declare Function DistanceCalcD Lib "dna.dll" (ByVal Nextnox As Integer, ByVal LenSeqx As Long, ByRef SeqNumx As Integer, ByRef DistanceX As Double, ByRef validsitex As Double, ByRef currentxoverx As Integer, ByRef distancebx As Double) As Double
Declare Function DistanceCalcE Lib "dna.dll" (ByVal TestSequenceNumber As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByVal StartPosition As Long, ByVal EndPosition As Long, ByRef AlignmentInIntegerArray As Integer, ByRef DistanceMatrix As Double) As Double
Declare Function DistanceCalcF Lib "dna.dll" (ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencesPlusOne As Long, ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal AverageIdentity As Double, ByRef AlignmentIntegerArray As Integer, ByRef DistHolderArray As Double, ByRef HomologyArray As Double) As Double
Declare Function DrawMatrix Lib "dna.dll" (ByVal hdc As Long, ByVal pwidx As Integer, ByVal yposx As Integer, ByVal wid As Integer, ByVal sqrx As Integer, ByVal parrayx As String) As Integer
Declare Function DrawMatrixB Lib "dna.dll" (ByVal hdc As Long, ByVal pwidx As Integer, ByVal yposx As Integer, ByVal wid As Integer, ByVal sqrx As Integer, ByVal parrayx As String) As Integer
Declare Function DrawDiffs Lib "dna.dll" (ByVal hdc As Long, ByVal LenXoverSeqx As Long, ByVal XFactorx As Double, ByRef xdiffposx As Long) As Integer
Declare Function DrawDiffsB Lib "dna.dll" (ByVal hdc As Long, ByVal LenXoverSeqx As Long, ByVal XFactorx As Double, ByRef xdiffposx As Long) As Integer
Declare Function SpacerFindB Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal ReferenceSequenceFlag As Integer, ByVal MinimumParentalIdentity As Double, ByVal MaximumParentalIdentity As Double, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef OutlyerHolder As Integer, ByRef ReferenceSequenceNumberHolder As Integer, ByRef ArrayOfTreeDistances As Double, ByRef IdentityMatrix As Double, ByRef SequenceMasks As Integer, ByRef ReferenceSequenceHolder As Integer, ByRef ValidReferenceSequenceHolder As Integer) As Long
'Declare Function PlotDraw Lib "dna.dll" (ByVal hdc As Long, ByVal lenxoverseqx As Long, ByVal picheightx As Integer, ByVal XFactorx As Double, ByRef XDiffPosx As Long, ByRef xoverhomologynumx As Double) As Integer
'Declare Function HomologyWin Lib "dna.dll" (ByVal WeightedFlagx As Integer, ByVal lenhsnum As Integer, ByVal Beginningx As Integer, ByVal Endingx As Integer, ByVal nextnox As Integer, ByRef validsitex As Double, ByRef runningtotalx As Double, ByRef homologyseqnumx As Integer, ByRef homologyx As Double, ByRef bkghomologyx As Double, ByRef adjustfactorx As Double) As Integer
'Declare Function MakeSubSeq Lib "dna.dll" (ByVal nextnox As Integer, ByVal lenseqx As Long, ByRef seqnumx As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Double) As Integer
Declare Function MakeSubSeqB Lib "dna.dll" (ByVal spacernox As Integer, ByVal LenSeqx As Long, ByVal nonspacernox As Integer, ByRef SeqNumx As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Integer) As Integer
Declare Function MakeSubSeqC Lib "dna.dll" (ByVal Nextnox As Integer, ByVal LenSeqx As Long, ByRef SeqNumx As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Byte, ByRef currentxoverx As Integer) As Integer
Declare Function TreeDist Lib "dna.dll" (ByVal Nextnox As Integer, ByRef treedistancex As Double, ByRef nodelengthx As Double, ByRef treexx As Integer) As Double
Declare Function ShortestDist Lib "dna.dll" (ByVal Nextnox As Integer, ByVal sortednox As Integer, ByRef distancebakx As Double, ByRef treexx As Integer, ByRef treeyx As Integer) As Double
Declare Function GetSiteHomol Lib "dna.dll" (ByVal lseqx As Long, ByVal Nextnox As Integer, ByRef SeqNumx As Integer, ByRef idcountx As Integer, ByRef seqhomolx As Long) As Integer
Declare Function FindNext Lib "dna.dll" (ByVal StartPosition As Long, ByVal HighHomolSeqPair As Integer, ByVal MedHomolSeqPair As Integer, ByVal LowHomolSeqPair As Integer, ByVal LenXoverSubSeq As Long, ByVal SizeOfXoverWindow As Integer, ByRef XOverHomologyNumArray As Long) As Long

Declare Function CalcChiVals Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals2 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals3 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals4 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long) As Double
Declare Function CalcChiVals5 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long) As Double

Declare Function DoPerms Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long
Declare Function DoPerms2 Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long
Declare Function DoPerms3 Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long

Declare Function GetPScores Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer) As Long
Declare Function GetPScores2 Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer) As Long
Declare Function GetPScores4 Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer, ByRef SimSequencesInIntegerArray As Integer) As Long

Declare Function GetPScoresRnd Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer, ByRef HorizontalRandomisationArray As Long) As Long

'Declare Function InStrX Lib "dna.dll" (ByVal strtx As Integer, ByRef sequencex As String, ByVal targetx As Integer, ByVal slenx As Integer) As Long
Declare Function FindMChi Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long
Declare Function FindMChi2 Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long
Declare Function FindMChi3 Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long

Declare Function SmoothChiVals Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Declare Function SmoothChiVals2 Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Declare Function SmoothChiVals3 Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long

Declare Function AddScores Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal NumToAdd As Long, ByVal SeqNumber As Long, ByRef HitsHolder As Long) As Long
Declare Function DoHits Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal Daughter As Long, ByVal MinorParent As Long, ByVal MajorParent As Long, ByRef HitsHolder As Long, ByRef NumHitsHolder As Long) As Long
Declare Function DoHits2 Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal Daughter As Long, ByVal MinorParent As Long, ByVal MajorParent As Long, ByRef HitsHolder As Long, ByRef NumHitsHolder As Long) As Long

Declare Function MakeZValue Lib "dna.dll" (ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal NumberOfGroups As Integer, ByVal NumberOfPermutations As Long, ByRef DoGroupArray As Byte, ByRef PermutationPScoresArray As Long, ByRef ZScoreHolderArray As Double) As Double
Declare Function QuickCheck Lib "dna.dll" (ByVal PositionInSequence As Long, ByVal WindowLength As Long, ByRef TallyX As Long, ByRef SeqScore3X As Integer) As Long
Declare Function MakeVRand Lib "dna.dll" (ByVal NumberOfSpacesToFill As Long, ByVal RandomNumberSeed As Long, ByVal NumberOfPerms As Long, ByVal LengthOfAlignmnet As Long, ByRef RandomNumberTemplate As Byte) As Double
Declare Function DoSums Lib "dna.dll" (ByVal NumberOfPermutations As Long, ByRef PermutationSScores As Long, ByRef PermutationPScores As Long) As Long
Declare Function Get3Score Lib "dna.dll" (ByVal GapFlag As Byte, ByVal LengthOfSequences As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef SequenceIntegerArray As Integer, ByRef Pattern3Holder As Integer) As Long
Declare Function ReSortArray Lib "dna.dll" (ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal InPosition As Long, ByVal ReadNumber As Long, ByVal NumberOfBSReps As Long, ByRef FileBuffer As Integer, ByRef SortingArray As Integer) As Long
Declare Function DoChiPerms Lib "dna.dll" (ByVal MaxChiVal As Double, ByVal WindowSize As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfRegion As Long, ByVal PermutationNumber As Long, ByVal LeftOffset As Long, ByRef PermutationScoreArray As Byte, ByRef ScoreArray As Byte) As Long
Declare Function FillMatrix Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal BeginningOfRegion As Long, ByVal EndingOfRegion As Long, ByVal DistanceR As Double, ByRef RecombMatrixx As Double) As Long
Declare Function FindSubSeqGCA Lib "dna.dll" (ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long) As Long
Declare Function GetFrags Lib "dna.dll" (ByVal CircularFlagX As Integer, ByVal LengthXoverSeq As Long, ByVal SequenceLength As Long, ByRef SubSeqArray As Byte, ByRef FragStartpos As Long, ByRef FragEndPos As Long, ByRef FragmentScore As Long, ByRef FragmentCount As Long) As Long
Declare Function GetAncDst Lib "dna.dll" (ByVal NumberOfSequences As Long, ByVal SequenceLength As Long, ByRef AncestralSequenceArray As Integer, ByRef SequenceArray As Integer, ByRef AncestralDistances As Double, ByRef ConversionArray As Double) As Long
Declare Function MakeAnc Lib "dna.dll" (ByVal NumberOfSequences As Long, ByVal SequenceLength As Long, ByVal CurrentPos As Long, ByRef BranchMapArray As Long, ByRef THoldX As Double, ByRef PathArray As Long, ByRef IdneticalArray As Integer, ByRef ConvX As Byte, ByRef AncSeqArray As Integer, ByRef SequenceArray As Integer) As Long
Declare Function GetMaxFragScore Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByVal LenSeqsx As Long, ByVal CircularFlagX As Integer, ByVal GCMissmatchPenX As Integer, ByRef MissMatchPenArray As Double, ByRef MaxScorePosX As Long, ByRef FragMaxScorex As Long, ByRef FragScoreX As Long, ByRef FragCountx As Long, ByRef HiFragScore As Long) As Long
Declare Function CalcKMax Lib "dna.dll" (ByVal GCMissmatchPenX As Integer, ByVal XOLen As Long, ByRef MissPen As Double, ByRef LLx As Double, ByRef KMaxX As Double, ByRef NDiffx As Long, ByRef highenoughx As Long) As Long
Declare Function GCCalcPVal Lib "dna.dll" (ByVal lseqx As Long, ByVal LenXoverX As Long, ByRef FragMaxScorex As Long, ByRef PValsx As Double, ByRef FragCountx As Long, ByRef KMaxX As Double, ByRef LLx As Double, ByRef highenoughx As Long, ByRef critval As Double) As Double
Declare Function GCGetHiPVal Lib "dna.dll" (ByVal lseqx As Long, ByVal LenXoverSeqx As Long, ByRef FragCountx As Long, ByRef PValsx As Double, ByRef MaxYx As Long, ByRef MaxXx As Long, ByRef highenoughx As Long) As Double
Declare Function QuickDist Lib "dna.dll" (ByVal lseqx As Long, ByVal Nextnox As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef FMatX As Double, ByRef SMatx As Double, ByRef SubValidx As Double, ByRef SubDiffsx As Double, ByRef PermValidx As Double, ByRef PermDiffsx As Double, ByRef SeqNumx As Integer) As Double
Declare Function MakeTreeArray Lib "dna.dll" (ByVal Nextnox As Long, ByRef arrayx As Double, ByRef arrayy As Double) As Long
Declare Function TreeMid Lib "dna.dll" (ByVal MaxCurPosX As Long, ByVal NumberOfSeqsX As Long, ByRef NumDonex As Double, ByRef TMat2x As Double, ByRef TBx As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef nonelenx As Double) As Double
Declare Function UltraTreeDist Lib "dna.dll" (ByVal MDx As Double, ByVal MaxCurPosX As Long, ByVal NumSeqs As Long, ByRef DistMatrix As Double, ByRef NumDonex As Double, ByRef DoneThisx As Long, ByRef AbBex As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef NodeLenx As Double) As Double
Declare Function QuickDist2 Lib "dna.dll" (ByVal lseqx As Long, ByVal Nextnox As Long, ByVal ubnd As Long, ByVal BPos3x As Long, ByVal EPos3x As Long, ByRef SubValidx As Double, ByRef SubDiffsx As Double, ByRef SeqNumx As Integer, ByRef ISeqsX As Long) As Double
Declare Function MakeRMat Lib "dna.dll" (ByVal NextNo As Long, ByVal WinPP As Long, ByRef RMatx As Double, ByRef LMatx As Double, ByRef PDist As Double, ByRef ISeqs As Long, ByRef FMat As Double, ByRef SMat As Double, ByRef CompMat As Long, ByRef TtX As Double) As Double
Declare Function CalCR Lib "dna.dll" (ByVal TmF As Double, ByVal NextNo As Long, ByVal WinPP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef RCorr As Double, ByRef RInv As Double, ByRef IntVal As Double, ByRef RMat As Double, ByRef tRCorr As Double) As Double
Declare Function MakeLMat Lib "dna.dll" (ByVal X As Long, ByVal NextNo As Long, ByRef LMat As Double, ByRef PDist As Double, ByRef SubValidx As Double, ByRef SubDiffsx As Double, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef AVSN As Double) As Double
Declare Function MakeEventSeqs Lib "dna.dll" (ByVal DA As Long, ByVal mip As Long, ByVal Map As Long, ByVal EN As Long, ByVal LSeq As Long, ByRef EventSeq As Integer, ByRef SeqNum As Integer) As Double
Declare Function DefineEvent Lib "dna.dll" (ByVal ShortOutFlag As Long, ByVal LongWindedFlag As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal TargetX As Long, ByVal CircularFlag As Long, ByVal XX As Long, ByVal XOverWindow As Long, ByVal LenSeq As Long, ByVal LenXOverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByRef EndFlag As Long, ByRef BE As Long, ByRef EN As Long, ByrefNCommon As Long, ByrefXOverLength As Long, ByRef XOverSeqNum As Byte, ByRef XDiffpos As Long, ByRef XOverHomologyNum As Long) As Double
Declare Function MakeGoodC Lib "dna.dll" (ByVal NextNo As Long, ByVal LenSeq As Long, ByRef GoodC As Long, ByRef BPosLR As Long, ByRef SeqNum As Integer) As Double
Declare Function FindOverlap Lib "dna.dll" (ByVal LenSeq As Long, ByVal BPos2 As Long, ByVal EPos2 As Long, ByRef RSize As Long, ByRef OLSeq As Long) As Long
Declare Function MakeTMatch Lib "dna.dll" (ByVal WinPP As Long, ByRef CompMat As Long, ByRef tMatchX As Long, ByRef RNum As Long, ByRef FoundOne As Long, ByRef SQ As Long, ByRef RList As Long, ByRef FOX As Long, ByRef CSeq As Long, ByRef TMatch As Double, ByRef InvList As Long) As Long
Declare Function ttestprob Lib "dna.dll" (ByVal T As Double, ByVal DF As Long) As Double
Declare Function StripUnfound Lib "dna.dll" (ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvList As Long, ByRef FoundOne As Long, ByRef RCorr As Double, ByRef RLScore As Double) As Double
Declare Function MakeRCompat Lib "dna.dll" (ByRef ISeqs As Long, ByRef CompMat As Long, ByVal WinPP As Long, ByVal NextNo As Long, ByRef RCompat As Long, ByRef RCompatB As Long, ByRef InPen As Long, ByRef RCats As Long, ByRef RNum As Long, ByRef NRNum As Long, ByRef GoodC As Long, ByRef DoneX As Long, ByRef RList As Long, ByRef NRList As Long, ByRef FAMat As Double, ByRef LDist As Double) As Double
Declare Function MakeActualSeqSize Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef ActualSeqSize As Long, ByRef SeqNum As Integer) As Long
Declare Function MakeTDiffs Lib "dna.dll" (ByVal NextNo As Long, ByVal xNextno As Long, ByRef TDiffs As Double, ByRef TValid As Double, ByRef PermDiffs As Double, ByRef PermValid As Double, ByRef UnInvolved As Long, ByRef ActualSeqSize As Long) As Long
'int FAR pascal MakePermDiffs(int Nextno, int MinSeqSize,double *TDiffs, double *TValid, double *PermDiffs, double *PermValid, double *Distance){
Declare Function MakePermDiffs Lib "dna.dll" (ByVal NextNo As Long, ByVal MinSeqSize As Long, ByRef TDiffs As Double, ByRef TValid As Double, ByRef PermDiffs As Double, ByRef PermValid As Double, ByRef Distance As Double) As Long

Declare Function ModSN Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal EPos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer, ByRef missdata As Long) As Long
Declare Function RebuildSeqNum Lib "dna.dll" (ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqNum As Integer) As Long
'int FAR pascal ModSeqNumY(int BPos, int EPos, int LS, int WinPP, int *RNum, int *BReaks, int *Rlist, short int *SeqNum, short int *tSeqNum){
Declare Function ModSeqNumY Lib "dna.dll" (ByVal BPos As Long, ByVal EPos As Long, ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqNum As Integer, ByRef missdata As Long) As Long
Declare Function MakeTrpScore Lib "dna.dll" (ByVal X As Long, ByVal NextNo As Long, ByRef FAMat As Double, ByRef SAMat As Double, ByRef TrpScore As Double, ByRef NumInGroup As Double, ByRef ISeqs As Long, ByRef GroupSeq As Long) As Long
Declare Function MakePairs Lib "dna.dll" (ByVal NextNo As Long, ByVal DA As Long, ByVal Ma As Long, ByVal Mi As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Long) As Long
Declare Function ModSeqNumA Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal EPos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer) As Long
Declare Function ModSeqNumB Lib "dna.dll" (ByVal BPos As Long, ByVal EPos As Long, ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqNum As Integer) As Long
Declare Function FindMissing Lib "dna.dll" (ByVal LS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal Z As Long, ByVal EN As Long, ByRef MissingData As Long) As Long
Declare Function CheckSplit Lib "dna.dll" (ByVal LS As Long, ByVal BE As Long, ByVal EN As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef Split As Long, ByRef MissingData As Long) As Long
Declare Function MakeDoneThis Lib "dna.dll" (ByVal NextNo As Long, ByRef FMat As Double, ByRef FAMat As Double, ByRef SAMat As Double, ByRef LD As Double, ByRef DoneThis As Long, ByRef ISeqs As Long) As Long
Declare Function MakePhPrScore Lib "dna.dll" (ByVal NextNo As Long, ByVal TmF As Double, ByRef TraceInvolvedBak As Long, ByRef DoneThis As Long, ByRef ISeqs As Long, ByRef PhPrScore As Double, ByRef FMat As Double, ByRef SMat As Double, ByRef tPhPrScore As Double, ByRef SubPhPrScore As Double, ByRef SubScore As Double) As Double
Declare Function MakeTrpGroups Lib "dna.dll" (ByVal X As Long, ByVal NextNo As Long, ByRef NumInGroup As Double, ByRef CompMat As Long, ByRef ISeqs As Long, ByRef DoneOne As Long, ByRef GroupSeq As Long, ByRef MinDistZ As Double, ByRef FAMat As Double) As Long
Declare Function MakeBPosLR Lib "dna.dll" (ByVal VSN As Long, ByVal TSN As Long, ByVal LS As Long, ByVal BPos As Long, ByVal EPos As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long, ByRef BPosLR As Long, ByRef AVSN As Double) As Long
Declare Function MakeOLSeq Lib "dna.dll" (ByVal LS As Long, ByVal BPos As Long, ByVal EPos As Long, ByRef RSize As Long, ByRef OLSeq As Long) As Long
Declare Function AddSeqToUPGMA Lib "dna.dll" (ByVal NextNo As Long, ByVal SortedNo As Long, ByRef XInstance As Integer, ByRef DistanceBak As Double, ByRef TreeX As Integer, ByRef TreeY As Integer, ByRef Check As Long, ByRef NodeYPos As Integer) As Long
Declare Function MakeRList Lib "dna.dll" (ByVal NextNo As Long, ByRef GoodC As Long, ByRef ISeqs As Long, ByRef RListX As Long, ByRef InvListX As Long, ByRef RNumX As Long, ByRef RList As Long, ByRef InvList As Long, ByRef RNum As Long, ByRef RInv As Double, ByRef RCorr As Double, ByRef PScores As Double, ByRef TPVal As Double, ByRef tVal As Double, ByRef TotP As Double, ByRef RLScore As Double, ByRef dontredox As Byte, ByRef accpetablecorx As Byte, ByRef rcorrwarnx As Byte) As Double
Declare Function TreeDist2 Lib "dna.dll" (ByVal NextNo As Long, ByRef TreeX As Integer, ByRef TreeY As Integer, ByRef TreeDistance As Double) As Long
Declare Function MakeTMatch2 Lib "dna.dll" (ByVal tWinPP As Long, ByVal WinPP As Long, ByRef tMatchX As Long, ByRef SQ As Long, ByRef TMatch As Double, ByRef RNum As Long, ByRef RList As Long, ByRef CompMat As Long) As Long
Declare Function TestRList Lib "dna.dll" (ByVal WinPP As Long, ByRef A As Long, ByRef Z As Long, ByRef FoundOne As Long, ByRef RNum As Long, ByRef SQ As Long, ByRef RList As Long) As Long
Declare Function StripDupInv Lib "dna.dll" (ByVal NextNo As Long, ByRef RCorr As Double, ByRef RLScore As Double, ByRef InPen As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvList As Long) As Long
Declare Function MakeLDist Lib "dna.dll" (ByVal NextNo As Long, ByRef LDist As Double, ByRef FAMat As Double, ByRef RNum As Long, ByRef RList As Long) As Long
Declare Function MakeRelevant Lib "dna.dll" (ByVal NextNo As Long, ByRef Relevant As Long, ByRef RNum As Long, ByRef RList As Long) As Long
Declare Function CopySeqs Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByRef SeqNum As Integer, ByRef PermSeqNum As Integer) As Long
Declare Function SplitEvent Lib "dna.dll" (ByVal XOWin As Long, ByVal LS As Long, ByVal LenXOverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByVal BTarget As Long, ByVal ETarget As Long, ByRef XOverLength As Long, ByRef NCommon As Long, ByRef XPosdiff As Long, ByRef XOverSeqNum As Byte) As Long
Declare Function MakeUninvolved Lib "dna.dll" (ByVal WinPP As Long, ByVal NextNo As Long, ByRef UnInvolved As Long, ByRef RNum As Long, ByRef RList As Long) As Long
Declare Function StripUnfound2 Lib "dna.dll" (ByVal WinPP As Long, ByVal AddNum As Long, ByRef RNum As Long, ByRef WinnerPos As Long, ByRef RList As Long, ByRef Breaks As Long) As Long
Declare Function CopySeq Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByVal X As Long, ByVal Y As Long, ByRef SeqNum As Integer) As Long
Declare Function DelPVals Lib "dna.dll" (ByVal GCMaxOverlapFrags As Integer, ByVal Y As Long, ByVal X As Long, ByVal LS As Long, ByRef PVals As Double, ByRef FragCount As Long, ByRef FragSt As Long, ByRef FragEn As Long, ByRef MaxScorePos As Long, ByRef DeleteArray As Long) As Long
Declare Function MakeSubProb Lib "dna.dll" (ByVal X As Long, ByVal LS As Long, ByVal LenXOverSeq As Long, ByVal BTarget As Long, ByVal ETarget As Long, ByRef SubSeq As Byte, ByRef LL As Double, ByRef KMax As Double, ByRef MissPen As Double, ByRef critval As Double) As Double
Declare Function GrowMChiWin Lib "dna.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXOverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte) As Long
Declare Function ChiPVal2 Lib "dna.dll" (ByVal X As Double) As Double
Declare Function DestroyPeaks Lib "dna.dll" (ByVal MaxY As Long, ByVal LenXOverSeq As Long, ByVal LS As Long, ByVal LO As Long, ByVal RO As Long, ByRef SmoothChi As Double, ByRef ChiVals As Double) As Long
Declare Function FindSide Lib "dna.dll" (ByVal TopL As Long, ByVal TopR As Long, ByVal LS As Long, ByVal LO As Long, ByVal RO As Long, ByVal WinWin As Long, ByVal LenXOverSeq As Long, ByVal MaxY As Long, ByRef Scores As Byte, ByRef HiLeft As Double, ByRef HiRight As Double) As Long
Declare Function GrowMChiWin2 Lib "dna.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXOverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long
Declare Function MakeBanWin Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal HWindowWidth As Long, ByVal LS As Long, ByVal LenXOverSeq As Long, ByRef BanWin As Long, ByRef MDMap As Byte, ByRef MissingData As Long, ByRef XPosdiff As Long, ByRef XDiffpos As Long) As Long
Declare Function DestroyPeak Lib "dna.dll" (ByVal MaxY As Long, ByVal LS As Long, ByVal RO As Long, ByVal LO As Long, ByVal LenXOverSeq As Long, ByRef LOT As Double, ByRef SmoothChi As Double, ByRef ChiVals As Double) As Long
Declare Function GetAC Lib "dna.dll" (ByVal LenXOverSeq As Long, ByVal LS As Long, ByVal MaxY As Long, ByVal MaxX As Long, ByVal TWin As Long, ByRef A As Long, ByRef C As Long, ByRef Scores As Byte) As Long
Declare Function vQuickDist Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal UB As Long, ByVal BPos3 As Long, ByVal EPos3 As Long, ByRef FMat As Double, ByRef SMat As Double, ByRef SubValid As Double, ByRef SubDiffs As Double, ByRef PermValid As Double, ByRef PermDiffs As Double, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Double
Declare Function FindHiSeqs Lib "dna.dll" (ByVal LS As Long, ByVal RS As Long, ByVal RE As Long, ByVal Ac As Long, ByVal Mi As Long, ByVal Ma As Long, ByRef SeqNum As Integer, ByRef Dists As Double, ByRef Valids As Double, ByRef Diffs As Double) As Long
Declare Function CheckMatrix Lib "dna.dll" (ByVal UB As Long, ByVal SCO As Long, ByVal MinSeqSize As Long, ByVal NextNo As Long, ByRef Valtot As Long, ByRef ISeqs As Long, ByRef PermValid As Double, ByRef SubValid As Double, ByRef FMat As Double, ByRef SMat As Double, ByRef FAMat As Double, ByRef SAMat As Double) As Long
Declare Function FindNextRedo Lib "dna.dll" (ByVal Start As Long, ByRef Relevant2 As Byte, ByRef RedoList As Long, ByRef ISeqs As Long, ByRef Relevant As Long) As Long
Declare Function CleanRedoList Lib "dna.dll" (ByRef RedoListSize As Long, ByRef RedoList As Long) As Long
Declare Function MarkRemovals Lib "dna.dll" (ByVal NextNo As Long, ByVal WinPP As Long, ByVal RedoListSize As Long, ByRef RedoList As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Long) As Long
Declare Function ModSeqNumZ Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal EPos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer, ByRef missdata As Long) As Long
Declare Function ModSeqNumD Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal FS As Long, ByVal BE As Long, ByVal EN As Long, ByRef SeqNum As Integer, ByRef MissingData As Long) As Long
Declare Function ModSeqNumE Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal FS As Long, ByVal BE As Long, ByVal EN As Long, ByRef SeqNum As Integer, ByRef MissingData As Long) As Long
Declare Function ReplaceSeq Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal S1 As Long, ByVal S2 As Long, ByRef SeqNum As Integer, ByRef MissingData As Long) As Long
Declare Function PBar Lib "dna.dll" (ByRef valu As Double) As Long
Declare Function MakeSDM Lib "dna.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByRef SP As Long, ByRef EP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef MissingData As Long, ByRef SeqNum As Integer, ByRef SDM As Double, ByRef DistMat As Double) As Long
Declare Function TransferDist Lib "dna.dll" (ByVal NSeqs As Long, ByVal cr As Long, ByVal Reps As Long, ByRef tFMat As Double, ByRef DstMat As Double) As Double
Declare Function MaketSeqNum Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByRef tSeqNum2 As Integer, ByRef SeqNum As Integer, ByRef FMat As Double) As Long
Declare Function MakeETSeqNumX Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal tlseq As Long, ByVal RS As Long, ByVal RE As Long, ByRef ETSeqNum As Integer, ByRef TreeSeqNum As Integer) As Long
Declare Function MakeOLSeqB Lib "dna.dll" (ByVal BE As Long, ByVal EN As Long, ByVal LSeq As Long, ByRef OLSeq As Byte) As Long
Declare Function DoSetsA Lib "dna.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte, ByRef DoIt As Byte) As Long
Declare Function DoSetsB Lib "dna.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte) As Long

Declare Function doAlignment Lib "clustalw.dll" (ByRef SeqsIn As Integer, ByRef SeqsOut As Integer, ByVal HeightA As Long, ByVal LengthA As Long, ByVal GapOpen As Single, ByVal GapExtend As Single, ByVal RemoveGapsF As Long) As Long
Declare Function doPOA Lib "poa.dll" Alias "main" (ByRef SeqsIn As Integer, ByRef SeqsOut As Integer, ByVal HeightA As Long, ByVal LengthA As Long, ByVal GapOpen As Single, ByVal GapExtend As Single, ByVal GapExtend2 As Long, ByRef ScoreMat As Double) As Long
Declare Function GetPltValX Lib "dna.dll" (ByVal B As Long, ByVal BSBootReps As Long, ByRef DstMat As Double, ByRef PltVal As Double) As Long

Declare Function MakeDst Lib "dna.dll" (ByVal LSeq As Long, ByVal DA As Long, ByVal Mi As Long, ByVal Ma As Long, ByVal BPos As Long, ByVal EPos As Long, ByRef VDiffs As Double, ByRef SeqNum As Integer) As Double
Declare Function UpdatePlotInfo Lib "dna.dll" (ByVal PVal As Double, ByVal Prg As Long, ByVal LSeq As Long, ByVal BPos As Long, ByVal EPos As Long, ByVal Dst As Double, ByRef MaxHits As Long, ByRef PDistPlt As Double, ByRef ProbPlt As Double, ByRef HitPlt As Long, ByRef RedoPltL As Byte) As Double
Declare Function FastBootDist Lib "dna.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Double, ByRef ValidX As Double, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Double) As Double

Declare Function CollapseNodesX Lib "dna.dll" (ByVal NextNo As Long, ByVal CutOff As Double, ByRef T As Long, ByRef DLen As Double, ByRef CMat As Double, ByRef AMat As Double, ByRef TraceBak As Double) As Long
Declare Function CheckPatternX Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByRef ISeqs As Long, ByRef ST As Long, ByRef EN As Long, ByRef SeqNum As Integer, ByRef Pattern As Double, ByRef DonePattern As Byte) As Long
Declare Function MakeMatchMatX Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal X As Long, ByRef ContainSite As Byte, ByRef SMat As Double, ByRef MatchMat As Double, ByRef BMatch As Double, ByRef BPMatch As Long, ByRef SeqNum As Integer) As Long
Declare Function TreeGroupsX Lib "dna.dll" (ByVal NextNo As Long, ByRef THolder As Byte, ByVal TLen As Long, ByVal NLen As Long, ByRef DoneNode As Byte, ByRef TArray As Byte, ByRef TMatch As Byte, ByRef DLen As Double) As Long
Declare Function MakeDeleteArray Lib "dna.dll" (ByVal FragSt As Long, ByVal FragEn As Long, ByVal FragCount As Long, ByRef DeleteArray As Long) As Long
Declare Function MakeSubSeqPerm Lib "dna.dll" (ByVal LS As Long, ByVal D As Long, ByVal P1 As Long, ByVal P2 As Long, ByRef PermSeqNum As Integer, ByRef XDiffpos As Long, ByRef XPosdiff As Long) As Long


Declare Function MakeRecCMatrix Lib "dna.dll" (ByVal LS As Long, ByVal RSize As Long, ByVal ST As Long, ByVal EN As Long, ByVal SConvert As Double, ByRef RegionMat As Double) As Long
Declare Function MakeHeatPlot Lib "dna.dll" (ByVal MaxN As Double, ByVal UBHM As Long, ByVal ColorScheme As Long, ByVal hdcref As Long, ByVal RSize As Long, ByVal XAddj As Double, ByRef HeatMap As Long, ByRef RegionMat As Double) As Long

Declare Function MakeVarMap Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByRef SeqNum As Integer, ByRef VarSiteMap As Byte, ByRef VRPos As Long, ByRef VXPos As Long, ByRef ISeqs As Long, ByRef CompMat As Long) As Long
Declare Function MakeCntHit Lib "dna.dll" (ByVal BPos As Long, ByVal EPos As Long, ByVal SWinx As Long, ByVal NextNo As Long, ByVal LenVarSeq As Long, ByVal LS As Long, ByRef CntHit As Double, ByRef VarSiteMap As Byte, ByRef VarSiteSmooth As Double, ByRef VRPos As Long) As Long
Declare Function FindBestRecSignal Lib "dna.dll" (ByVal DoneTarget As Byte, ByVal NextNo As Long, ByVal UB As Long, ByRef LowP As Double, ByRef DoneSeq As Byte, ByRef Trace As Long, ByRef PCurrentXOver As Integer, ByRef PXOList As XOverDefine) As Long
Declare Function CheckEnds Lib "dna.dll" (ByVal LS As Long, ByVal RL As Long, ByVal LSS As Long, ByVal ChF As Long, ByVal CirF As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal BPos As Long, ByVal EPos As Long, ByRef SeqNum As Integer, ByRef XPD As Long, ByRef XDP As Long, ByRef MissingData As Long) As Long
Declare Function CopyXOListsX Lib "dna.dll" (ByVal UB1 As Long, ByVal UB2 As Long, ByVal NextNo As Long, ByRef CurrentXover As Integer, ByRef PCurrentXOver As Integer, ByRef PXOList As XOverDefine, ByRef XOverList As XOverDefine, ByRef NumRecsI As Long) As Long
Declare Function FindActualEvents Lib "dna.dll" (ByVal LS As Long, ByVal WinPP As Long, ByVal NextNo As Long, ByVal UB As Long, ByRef RSize As Long, ByRef Don As Byte, ByRef BPMatch As Long, ByRef BMatch As Double, ByRef OKSeq As Double, ByRef FoundOne As Long, ByRef SP As Long, ByRef EP As Long, ByRef RCorr As Double, ByRef OLSeq As Long, ByRef OLSeqB As Long, ByRef OLSeqE As Long, ByRef CSeq As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvS As Byte, ByRef TrS As Long, ByRef TMatch As Double, ByRef PXOList As XOverDefine, ByRef PCurrentXOver As Integer, ByRef SQ As Long, ByRef tDon As Byte, ByRef ISeqs As Long, ByRef TList As Byte, ByRef CompMat As Long) As Long
Declare Function MakePValMap Lib "dna.dll" (ByVal DN As Long, ByVal LS As Long, ByVal PermNum As Long, ByRef Map As Integer, ByRef PValMap As Single) As Long
Declare Function AddToMap Lib "dna.dll" (ByVal A As Long, ByVal S As Long, ByVal Win As Double, ByVal LS As Long, ByRef APos As Long, ByRef Map As Integer) As Long

Declare Function CheckBPOL Lib "dna.dll" (ByVal LS As Long, ByVal D As Long, ByVal LSSeq As Long, ByVal NewStart As Long, ByVal RecSize As Long, ByRef tSeqNum As Integer, ByRef NS As Long, ByRef NE As Long, ByRef XDiffpos As Long) As Long
Declare Function FindMaxMapVal Lib "dna.dll" (ByVal DN As Long, ByVal LS As Long, ByVal PermNum As Long, ByRef MaxVals As Long, ByRef Map As Integer) As Long

Declare Function OptLeftBPMC Lib "dna.dll" (ByVal LO As Long, ByVal HiLeft As Long, ByVal TopL As Long, ByVal MaxX As Long, ByVal MaxY As Long, ByVal WinWin As Long, ByVal LenXOverSeq As Long, ByVal LSeq As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long

Declare Function DrawMats Lib "dna.dll" (ByVal Pict As Long, ByVal MaxN As Double, ByVal CurScale As Long, ByVal XAddj As Double, ByVal UBRM As Long, ByRef PosS As Long, ByRef PosE As Long, ByRef RegionMat As Double, ByRef HeatMap As Long) As Long
Declare Function FindMaxN Lib "dna.dll" (ByVal RSize As Long, ByRef RegionMat As Double) As Double
Declare Function ChiPVal3 Lib "dna.dll" (ByVal X As Double, ByVal DF As Long) As Double
Declare Function MakeMatrixMC Lib "dna.dll" (ByVal LS As Long, ByVal LenXOverSeq As Long, ByRef A As Double, ByRef C As Double, ByRef Scores As Byte, ByRef MatrixMC As Double) As Long
'Declare Function SeqWrite Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal hdc As Long, ByVal nextnox As Integer, ByVal fraglen As Integer, ByVal seqlen As Integer, ByVal winleftx As Integer, ByRef seqfrag As String) As Integer
'Constants
Public Const FW_BOLD = 700
Public Const FW_NORMAL = 400
Public Const DEFAULT_CHARSET = 1
Public Const OUT_DEFAULT_PRECIS = 0
Public Const CLIP_DEFAULT_PRECIS = 0
Public Const PROOF_QUALITY = 2
Public Const DEFAULT_PITCH = 0
Public Const FF_DONTCARE = 0
Public Const WM_CLOSE = &H10
Public Const GW_HWNDNEXT = 2
Public Const STILL_ACTIVE = &H103
Public Const PROCESS_QUERY_INFORMATION = &H400
Public Const LENTYPE = 50
Public NumT As Long, NumD As Long, q() As Double, Qb() As Double, typex() As Long, pi() As Double, new2() As Long





Public Sub SaveAlign(SIndex As Integer)
    'Subroutine used to save multiple sequence alignments
    'I must remember to incorporate the "save recombinant region" thing here
Dim SeqSave() As Integer
    Dim SeqMask() As Byte, DontInclude As Byte
    Dim Addj As Integer, Addon As Integer
    Dim NumSeqs As Long, LastPos As Long, X As Long, Y As Long, Z As Long
    Dim TString As String, AName As String
    Dim Namestring() As String, TempSeq() As String, TempName() As String

    ReDim TempSeq(NextNo)
    ReDim TempName(NextNo)

    With Form1.CommonDialog1
        .filename = ""
        .DefaultExt = "fas"
        .Filter = "All Files (*.*)|*.*|RDP Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
        .Action = 2 'Specify that the "open file" action is required.
        AName = .filename  'Stores selected file name in the
        ANameII = .FileTitle
    End With

    If AName = "" Then Exit Sub
    NumSeqs = 0

    If SIndex = 0 Then
        NumSeqs = NextNo
        'zz = 0
        For X = 0 To NextNo
            
            TempName(X) = StraiName(X)
            TempSeq(X) = StrainSeq(X)
           
        Next 'X
    ElseIf SIndex = 5 Then ' save only disabled
        For X = 0 To NextNo

            If MaskSeq(X) > 0 Then
                TempSeq(NumSeqs) = StrainSeq(X)
                TempName(NumSeqs) = StraiName(X)
                NumSeqs = NumSeqs + 1
            End If

        Next 'X

        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 6 Then ' save only enabled
        For X = 0 To NextNo

            If MaskSeq(X) = 0 Then
                TempSeq(NumSeqs) = StrainSeq(X)
                TempName(NumSeqs) = StraiName(X)
                NumSeqs = NumSeqs + 1
            End If

        Next 'X

        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 1 Then

        For X = 0 To NextNo

            If CurrentXover(X) = 0 Then
                TempSeq(NumSeqs) = StrainSeq(X)
                TempName(NumSeqs) = StraiName(X)
                NumSeqs = NumSeqs + 1
            Else
                DontInclude = 0

                For Y = 1 To CurrentXover(X)
                    If XOverList(X, Y).Accept = 1 Then
                    
                        DontInclude = 1
                        Exit For
                    End If

                Next 'Y

                If DontInclude = 0 Then
                    TempSeq(NumSeqs) = StrainSeq(X)
                    TempName(NumSeqs) = StraiName(X)
                    NumSeqs = NumSeqs + 1
                End If

            End If

        Next 'X

        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 2 Then
        NumSeqs = NextNo
        ReDim SeqSave(Len(StrainSeq(0)), NextNo)
        For X = 0 To NextNo
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, X) = PermSeqNum(Y, X)
            Next Y
        Next X
        For X = 0 To NextNo
            For Y = 1 To CurrentXover(X)
                If XOverList(X, Y).Accept = 1 Then
                    BE = XOverList(X, Y).Beginning
                    EN = XOverList(X, Y).Ending
                    
                    For A = 0 To NextNo
                        If BE < EN Then
                            For Z = BE To EN
                                SeqSave(Z, A) = 46
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                SeqSave(Z, A) = 46
                            Next Z
                            For Z = 1 To EN
                                SeqSave(Z, A) = 46
                            Next Z
                        End If
                    Next A
                End If
            Next Y
        
        Next X
        For X = 0 To NextNo
            TempSeq(X) = StrainSeq(X)
            TempName(X) = StraiName(X)
            For Y = 1 To Len(StrainSeq(0))
                If SeqSave(Y, X) <> PermSeqNum(Y, X) Then
                    Mid$(TempSeq(X), Y, 1) = "-"
                End If
            Next Y
        Next X

    ElseIf SIndex = 3 Then
        NumSeqs = NextNo
        
        
        ReDim SeqSave(Len(StrainSeq(0)), NextNo)
        For X = 0 To NextNo
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, X) = PermSeqNum(Y, X)
            Next Y
        Next X
        For X = 0 To NextNo
            For Y = 1 To CurrentXover(X)
                If XOverList(X, Y).Accept = 1 Then
                    BE = XOverList(X, Y).Beginning
                    EN = XOverList(X, Y).Ending
                    If BE < EN Then
                        For Z = BE To EN
                            SeqSave(Z, X) = 46
                        Next Z
                    Else
                        For Z = BE To Len(StrainSeq(0))
                            SeqSave(Z, X) = 46
                        Next Z
                        For Z = 1 To EN
                            SeqSave(Z, X) = 46
                        Next Z
                    End If
                End If
            Next Y
        
        Next X
        For X = 0 To NextNo
            TempSeq(X) = StrainSeq(X)
            TempName(X) = StraiName(X)
            For Y = 1 To Len(StrainSeq(0))
                If SeqSave(Y, X) <> PermSeqNum(Y, X) Then
                    Mid$(TempSeq(X), Y, 1) = "-"
                End If
            Next Y
        Next X
        

    End If

    
    Close #1
    
    Open AName For Output As #1
    If right$(AName, 4) = ".msd" Or right$(AName, 4) = ".MSD" Then
        'Save DNAMAN file
        Print #1, "FILE: Multiple_Sequence_Alignment"
        Print #1, "PROJECT:"
        Print #1, "NUMBER:" + CStr(NumSeqs + 1)
        Print #1, "MAXLENGTH:" + CStr(Len(TempSeq(0)))
        Addj = 65

        For X = 0 To NumSeqs

            If Len(TempName(X)) > 9 Then
                TempName(X) = Mid$(TempName(X), 1, 8) + Chr$(Addj)
                Addj = Addj + 1
            End If

        Next 'X

        ReDim Namestring(Int((NumSeqs + 1) / 6) + 1)
        Namestring(0) = "NAMES:"

        For X = 1 To Int((NumSeqs + 1) / 6)
            Namestring(X) = "      "
        Next 'X

        For X = 0 To Int((NumSeqs + 1) / 6)
            Y = 0

            Do Until Y = 6 Or (X * 6 + Y) > NextNo
                Namestring(X) = Namestring(X) + " " + TempName(X * 6 + Y)
                Y = Y + 1
            Loop

        Next 'X

        For X = 0 To Int((NextNo + 1) / 6)
            Print #1, Namestring(X)
        Next 'X

        Print #1, ""
        Print #1, "ORIGIN"

        For X = 0 To NextNo
            Addon = 10 - Len(TempName(X))
            TempName(X) = TempName(X) + String$(Addon, 32)
        Next 'X

        For X = 1 To Int(Len(TempSeq(0)) / 60)

            For Y = 0 To NumSeqs
                Print #1, TempName(Y) + Mid$(TempSeq(Y), X * 60 - 59, 60)
            Next 'Y

            Print #1, ""
        Next 'X

        For Y = 0 To NumSeqs
            Print #1, TempName(Y) + Mid$(TempSeq(Y), X * 60 - 59, Len(TempSeq(0)) - (X * 60 - 60))
        Next 'Y

    ElseIf right$(AName, 4) = ".aln" Or right$(AName, 4) = ".ALN" Then
        Addj = 0

        For X = 0 To NumSeqs

            If Len(TempName(X)) > 15 Then
                TempName(X) = Mid$(TempName(X), 1, 14) + Chr$(Addj)
                Addj = Addj + 1
            End If

            Addon = 16 - Len(TempName(X))
            TempName(X) = TempName(X) + String$(Addon, 32)
        Next 'X

        Print #1, "CLUSTAL multiple sequence alignment"
        Print #1, ""
        Print #1, ""

        For Y = 1 To Len(TempSeq(0)) Step 60

            For X = 0 To NumSeqs
                Print #1, TempName(X) + Mid$(TempSeq(X), Y, 60)
            Next 'X

            Print #1, ""
            Print #1, ""
        Next 'Y

    ElseIf right$(AName, 4) = ".phy" Or right$(AName, 4) = ".PHY" Then
        'Save alignment in phylip Format
        Addj = 65

        For X = 0 To NumSeqs

            If Len(TempName(X)) > 10 Then
                TempName(X) = Mid$(TempName(X), 1, 8) + Chr$(Addj)
                Addj = Addj + 1
            End If

            Addon = 10 - Len(TempName(X))
            TempName(X) = TempName(X) + String$(Addon, 32)
        Next 'X

        Print #1, "    " & Trim$(CStr(NumSeqs + 1)) & "   " & Trim$(CStr(Len(TempSeq(0))))

        For Y = 1 To Len(TempSeq(0)) Step 50

            For X = 0 To NumSeqs
                TString = ""

                For Z = 0 To 49 Step 10
                    TString = TString + " " + Mid$(TempSeq(X), Y + Z, 10)
                Next 'Z

                Print #1, TempName(X) + TString

                If Y = 1 Then
                    TempName(X) = String$(10, " ")
                End If

            Next 'X

            Print #1, ""
        Next 'Y

    ElseIf right$(AName, 4) = ".gde" Or right$(AName, 4) = ".GDE" Then
        'Save alignment in GDE Format

        For X = 0 To NumSeqs
            Print #1, "#" & TempName(X)

            For Y = 1 To Len(TempSeq(0)) + 60 Step 60
                Print #1, Mid$(TempSeq(X), Y, 60)
            Next 'Y

        Next 'X

    Else
        'Save alignment in FASTA format

        For X = 0 To NumSeqs
            Print #1, ">" & TempName(X)

            For Y = 1 To Len(TempSeq(0)) + 70 Step 70
                Print #1, Mid$(TempSeq(X), Y, 70)
            Next 'Y

        Next 'X

    End If

    Close #1
End Sub



Public Sub FindSimilar(DaughterSeq, RecNumber, AcceptFlag, StartAcceptX)

Dim LenXOver2 As Long, LenXOver As Long, HitsPerseq() As Long, RSP As Long, REP As Long, RSP2 As Long, REP2 As Long, RS As Long, RE As Long, TP As Long, RS2 As Long, RE2 As Long, TP2 As Long, LSeq As Long
Dim GroupEvents() As Long, Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long
Dim EventBegin() As Long, EventEnd() As Long, TreePoses() As Long, PosNumber() As Long
Dim CNum() As Long, CPVal() As Double

LSeq = Len(StrainSeq(0))
ReDim GEvents(CurrentXover(DaughterSeq))
ENumbs = 0
X = DaughterSeq
Y = RecNumber
StartAccept = StartAcceptX
            
            
            RSP = XOverList(X, Y).Beginning
            REP = XOverList(X, Y).Ending
'XXXZZZ              TP = XOverlist(X, Y).TreePos(0)
            
                If RSP > REP Then REP = LSeq + REP
                LenXOver = REP - RSP
                
                RE = REP - LenXOver / 4
                RS = RSP + LenXOver / 4
                
                For Z = 1 To CurrentXover(X)
                    
                    If XOverList(X, Z).Accept = StartAccept Then
                        'Exit Sub
                        If X = 123456 Then
                            RSP2 = XOverList(X, Z).Beginning
                            REP2 = XOverList(X, Z).Ending
                            
'XXXZZZ                                  TP2 = XOverlist(X, Z).TreePos(0)
                                
                                If RSP2 < REP2 Then
                                    If REP > LSeq Then
                                        If REP2 < RSP Then
                                            RSP2 = RSP2 + LSeq
                                            REP2 = REP2 + LSeq
                                        End If
                                    End If
                                Else
                                    If REP > LSeq Then
                                        REP2 = REP2 + LSeq
                                    Else
                                        RSP2 = RSP2 - LSeq
                                    End If
                                End If
                                
                                LenXOver2 = REP2 - RSP2
                                OL = 0
                                ol2 = 0
                                If REP > REP2 Then
                                    OL = REP - REP2
                                ElseIf REP < REP2 Then
                                    ol2 = REP2 - REP
                                End If
                                If RSP > RSP2 Then
                                    ol2 = ol2 + RSP - RSP2
                                ElseIf RSP < RSP2 Then
                                    OL = OL + RSP2 - RSP
                                End If
                                RE2 = REP2 - LenXOver2 / 4
                                RS2 = RSP2 + LenXOver2 / 4
                                'Exit Sub
                                
                                If LenXOver > 0 And LenXOver2 > 0 Then
                                    If RS2 < RE And RE2 > RS And TP = TP2 And OL / LenXOver < 0.5 And ol2 / LenXOver2 < 0.5 Then
                                        ENumbs = ENumbs + 1
                                        GEvents(ENumbs) = Z
                                        XOverList(X, Z).Accept = AcceptFlag
                                        
                                    End If
                                End If
                            Else
                                If XOverList(X, Z).Eventnumber = XOverList(X, Y).Eventnumber Then
                                    ENumbs = ENumbs + 1
                                    GEvents(ENumbs) = Z
                                    XOverList(X, Z).Accept = AcceptFlag
                                End If
                            End If
                    End If
                Next Z
End Sub
Public Sub ReCheck()

    Dim HitsPerseq() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, EPos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim X As Long, EY As Long, Y As Long, Z As Long
    Dim NumToAdd As Long
    NumToAdd = 1
    LSeq = Len(StrainSeq(0))
    ReDim HitsPerseq(NextNo, LSeq)

    For X = 0 To NextNo
        EY = CurrentXover(X)

        For Y = 1 To EY

            If XOverList(X, Y).Ending > LSeq Then
                XOverList(X, Y).Ending = LSeq
                XOverList(X, Y).Beginning = LSeq - 15
            End If

            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            BPos = XOverList(X, Y).Beginning
            EPos = XOverList(X, Y).Ending

            If BPos <= EPos Then
                SubM = Int((EPos - BPos) / 3)
                BPos = BPos + SubM
                EPos = EPos - SubM
                
                AddScores BPos, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
'                For Z = BPos To EPos
'                    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    'HitsPerSeq(Ma, Z) = HitsPerSeq(Ma, Z) + 1
'                    'HitsPerSeq(Mi, Z) = HitsPerSeq(Mi, Z) + 1
'                Next 'Z

            Else
                SubM = Int((EPos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                EPos = EPos - SubM

                If EPos < 0 Then EPos = LSeq + EPos

                If EPos < BPos Then
                    AddScores 1, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, X, HitsPerseq(0, 0)
           '         For Z = 1 To EPos
           '             HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
           '         Next 'Z'

'                    For Z = BPos To LSeq
'                        HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    Next 'Z

                Else
                    AddScores BPos, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    
              '      For Z = BPos To EPos
              '          HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
              '      Next 'Z

                End If

            End If

        Next 'Y

    Next 'X
    For X = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXover(X)
            ReDim NumHits(2)
            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            

            If Mi <= NextNo And Mi <> X Then
                
                BPos = XOverList(X, Y).Beginning
                EPos = XOverList(X, Y).Ending
                
               ' If BPos <= EPos Then
               '     SubM = Int((EPos - BPos) / 3)
               '     BPos = BPos + SubM
               '     EPos = EPos - SubM
               ' Else
               '     SubM = Int((EPos + (LSeq - BPos)) / 3)
               '     BPos = BPos + SubM
   '
     '               If BPos > LSeq Then BPos = BPos - LSeq
     '               EPos = EPos - SubM
   '
   '                 If EPos < 0 Then EPos = LSeq + EPos
   '             End If
                
                If BPos <= EPos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
       '             For Z = BPos To EPos
       '                 NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
       '                 NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
       '                 NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
       '             Next 'Z

                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If

                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXover(), XOverList())
                    
                    XOverList(Mi, CurrentXover(Mi)) = XOverList(X, Y)
                    XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    XOverList(Mi, CurrentXover(Mi)).Daughter = XOverList(X, Y).MinorP
                    XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(X, Y).Daughter
                    XOverList(Mi, CurrentXover(Mi)).MajorP = XOverList(X, Y).MajorP

                    If XOverList(X, Y).OutsideFlag = 0 Then
                        XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    ElseIf XOverList(X, Y).OutsideFlag = 1 Then
                        XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        temp = XOverList(Mi, CurrentXover(Mi)).MinorP
                        XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).MajorP
                        XOverList(Mi, CurrentXover(Mi)).MajorP = temp
                        XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 0
                        XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    Else
                        XOverList(Mi, CurrentXover(Mi)).OutsideFlag = XOverList(X, Y).OutsideFlag
                    End If
                    
                    If Y = CurrentXover(X) Then
                        CurrentXover(X) = CurrentXover(X) - 1
                    ElseIf CurrentXover(X) > 0 Then
                        XOverList(X, Y) = XOverList(X, CurrentXover(X))
                        CurrentXover(X) = CurrentXover(X) - 1
                        Y = Y - 1
                    End If

                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXover(), XOverList())
                    XOverList(Ma, CurrentXover(Ma)) = XOverList(X, Y)
                    XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    XOverList(Ma, CurrentXover(Ma)).Daughter = XOverList(X, Y).MajorP
                    XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(X, Y).MinorP
                    XOverList(Ma, CurrentXover(Ma)).MajorP = XOverList(X, Y).Daughter
                    XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2

                   
                    If XOverList(X, Y).OutsideFlag = 1 Then
                        XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        temp = XOverList(Ma, CurrentXover(Ma)).MinorP
                        XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(Ma, CurrentXover(Ma)).MajorP
                        XOverList(Ma, CurrentXover(Ma)).MajorP = temp
                        XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 0
                        XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    ElseIf XOverList(X, Y).OutsideFlag = 0 Then
                        XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                        XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    Else
                        XOverList(Ma, CurrentXover(Ma)).OutsideFlag = XOverList(X, Y).OutsideFlag
                    End If
                    
                    If Y = CurrentXover(X) Then
                        CurrentXover(X) = CurrentXover(X) - 1
                    ElseIf CurrentXover(X) > 1 Then
                        XOverList(X, Y) = XOverList(X, CurrentXover(X))
                        CurrentXover(X) = CurrentXover(X) - 1
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop

    Next 'X

End Sub
Public Sub ReCheck2()
    Dim HitsPerseq() As Long, HitsPerSeq2() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, EPos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim X As Long, EY As Long, Y As Long, Z As Long
    Dim NumToAdd As Long
    NumToAdd = 1
    LSeq = Len(StrainSeq(0))
    
    ReDim HitsPerseq(NextNo, LSeq)
    ReDim HitsPerSeq2(NextNo, LSeq)
    'Exit Sub
    For X = 0 To NextNo
        EY = CurrentXover(X)

        For Y = 1 To EY

            If XOverList(X, Y).Ending > LSeq Then
                XOverList(X, Y).Ending = LSeq
                XOverList(X, Y).Beginning = LSeq - 15
            End If

            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            BPos = XOverList(X, Y).Beginning
            EPos = XOverList(X, Y).Ending

            If BPos <= EPos Then
                SubM = Int((EPos - BPos) / 3)
                BPos = BPos + SubM
                EPos = EPos - SubM
                
                AddScores BPos, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
'                For Z = BPos To EPos
'                    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    'HitsPerSeq(Ma, Z) = HitsPerSeq(Ma, Z) + 1
'                    'HitsPerSeq(Mi, Z) = HitsPerSeq(Mi, Z) + 1
'                Next 'Z

            Else
                SubM = Int((EPos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                EPos = EPos - SubM

                If EPos < 0 Then EPos = LSeq + EPos

                If EPos < BPos Then
                    AddScores 1, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, X, HitsPerseq(0, 0)
           '         For Z = 1 To EPos
           '             HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
           '         Next 'Z'

'                    For Z = BPos To LSeq
'                        HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    Next 'Z

                Else
                    AddScores BPos, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    
              '      For Z = BPos To EPos
              '          HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
              '      Next 'Z

                End If

            End If

        Next 'Y
        Form1.ProgressBar1.Value = ((X / NextNo) * 0.2) * 100
    Next 'X
    
    For X = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXover(X)
            ReDim NumHits(2)
            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            

            If Mi <= NextNo And Mi <> X Then
                
                BPos = XOverList(X, Y).Beginning
                EPos = XOverList(X, Y).Ending
                
                If BPos <= EPos Then
                    SubM = Int((EPos - BPos) / 4)
                    BPos = BPos + SubM
                    EPos = EPos - SubM
                Else
                    SubM = Int((EPos + (LSeq - BPos)) / 4)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    EPos = EPos - SubM
   
                    If EPos < 0 Then EPos = LSeq + EPos
                End If
                
                If BPos <= EPos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
       '             For Z = BPos To EPos
       '                 NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
       '                 NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
       '                 NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
       '             Next 'Z
                    If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                        For Z = BPos To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                        For Z = BPos To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            
                        Next 'Z
                    ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                        For Z = BPos To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    Else
                      '  For Z = BPos To EPos
                      '      HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                       '     HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                      '      HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                      '  Next 'Z
                    End If

                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits 1, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    DoHits BPos, LSeq, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    
                    If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                        For Z = 1 To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                        For Z = 1 To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                        Next 'Z
                    ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                        For Z = 1 To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    End If
                    
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                
            End If
            Y = Y + 1
        Loop
        Form1.ProgressBar1.Value = 20 + ((X / NextNo) * 0.2) * 100
    Next 'X
                
    For X = 0 To NextNo
        
        Y = 1
        Do While Y <= CurrentXover(X)
            
          
            ReDim NumHits(2)
            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            

            If Mi <= NextNo And Mi <> X Then
                
                BPos = XOverList(X, Y).Beginning
                EPos = XOverList(X, Y).Ending
                
                If BPos <= EPos Then
                    SubM = Int((EPos - BPos) / 4)
                    BPos = BPos + SubM
                    EPos = EPos - SubM
                Else
                    SubM = Int((EPos + (LSeq - BPos)) / 4)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    EPos = EPos - SubM
   
                    If EPos < 0 Then EPos = LSeq + EPos
                End If
                
                If BPos <= EPos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, EPos, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)


                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, EPos, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXover(), XOverList())
                    
                    XOverList(Mi, CurrentXover(Mi)) = XOverList(X, Y)
                    'XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    XOverList(Mi, CurrentXover(Mi)).Daughter = XOverList(X, Y).MinorP
                    XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(X, Y).Daughter
                    XOverList(Mi, CurrentXover(Mi)).MajorP = XOverList(X, Y).MajorP
                    
                    D = X
                    Outer1 = 0
                    If XOverList(X, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XOverList(X, Y).OutsideFlag = 0 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = XOverList(X, Y).OutsideFlag
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 2
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 1 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            temp = XOverList(Mi, CurrentXover(Mi)).MinorP
                            XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(Mi, CurrentXover(Mi)).MajorP
                            XOverList(Mi, CurrentXover(Mi)).MajorP = temp
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            Outer1 = 0
                            If Distance(Mi, Ma) < (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                                Outer1 = 1
                            End If
                            
                            If Outer1 = 1 And X = 1233456 Then
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            Else
                                temp = XOverList(Mi, CurrentXover(Mi)).MinorP
                                XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(Mi, CurrentXover(Mi)).MajorP
                                XOverList(Mi, CurrentXover(Mi)).MajorP = temp
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 1
                                XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                            End If
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Or X = X Then
                                                                
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 1
                                
                            Else
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            End If
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    If Y = CurrentXover(X) Then
                        CurrentXover(X) = CurrentXover(X) - 1
                    ElseIf CurrentXover(X) > 0 Then
                        XOverList(X, Y) = XOverList(X, CurrentXover(X))
                        
                        CurrentXover(X) = CurrentXover(X) - 1
                        Y = Y - 1
                    End If

                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXover(), XOverList())
                    
                    XOverList(Ma, CurrentXover(Ma)).Beginning = XOverList(X, Y).Beginning
                    'XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    XOverList(Ma, CurrentXover(Ma)).Daughter = XOverList(X, Y).MajorP
                    XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(X, Y).MinorP
                    XOverList(Ma, CurrentXover(Ma)).MajorP = XOverList(X, Y).Daughter
                    D = X
                    Outer1 = 0
                    If XOverList(X, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XOverList(X, Y).OutsideFlag = 0 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = XOverList(X, Y).OutsideFlag
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 2
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 1 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            temp = XOverList(Ma, CurrentXover(Ma)).MinorP
                            XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(Ma, CurrentXover(Ma)).MajorP
                            XOverList(Ma, CurrentXover(Ma)).MajorP = temp
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 0
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Then
                                                                
                                XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 1
                                
                            Else
                                XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            End If
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    If Y = CurrentXover(X) Then
                        CurrentXover(X) = CurrentXover(X) - 1
                    ElseIf CurrentXover(X) > 1 Then
                        XOverList(X, Y) = XOverList(X, CurrentXover(X))
                        CurrentXover(X) = CurrentXover(X) - 1
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop
        Form1.ProgressBar1.Value = 40 + ((X / NextNo) * 0.6) * 100
    Next 'X
    
End Sub

Public Sub ReSortB()

    Dim HitsPerseq() As Long, HitsPerSeq2() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, EPos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim NumToAdd As Long, X As Long, EY As Long, Y As Long, Z As Long
    
    LSeq = Len(StrainSeq(0))
    ReDim HitsPerseq(NextNo, LSeq)
    ReDim HitsPerSeq2(NextNo, LSeq)
    Form1.SSPanel1.Caption = "Re-Sorting Regions"
    For X = 0 To NextNo
        EY = CurrentXover(X)

        For Y = 1 To EY
            If XOverList(X, Y).Ending > LSeq Then
                XOverList(X, Y).Ending = LSeq
                XOverList(X, Y).Beginning = LSeq - 15
            End If

            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            BPos = XOverList(X, Y).Beginning
            EPos = XOverList(X, Y).Ending
            If XOverList(X, Y).Accept = 0 Then
                NumToAdd = 1
            ElseIf XOverList(X, Y).Accept = 2 Then
                NumToAdd = 0
            ElseIf XOverList(X, Y).Accept = 1 Then
                NumToAdd = 10000
            End If
            
            If BPos <= EPos Then
                SubM = Int((EPos - BPos) / 3)
                BPos = BPos + SubM
                EPos = EPos - SubM
                
                'AddScores BPos, EPos, Nextno, NumToAdd, X, HitsPerseq(0, 0)
                
                For Z = BPos To EPos
                    HitsPerseq(X, Z) = HitsPerseq(X, Z) + NumToAdd
                    X = X
                Next 'Z

            Else
                SubM = Int((EPos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                EPos = EPos - SubM

                If EPos < 0 Then EPos = LSeq + EPos

                If EPos < BPos Then
                    
                    AddScores 1, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    'For Z = 1 To EPos
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                    'Next 'Z
                    
                    'For Z = BPos To LSeq
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                    'Next 'Z

                Else
                    AddScores BPos, EPos, NextNo, NumToAdd, X, HitsPerseq(0, 0)
                    'For Z = BPos To EPos
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                   ' Next 'Z

                End If

            End If

        Next 'Y
        Form1.ProgressBar1 = (X / NextNo) * 30
    Next 'X

    For X = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXover(X)
            
            ReDim NumHits(2)
            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            

            If Mi <= NextNo And Mi <> X Then
                
                BPos = XOverList(X, Y).Beginning
                EPos = XOverList(X, Y).Ending
                
                If BPos <= EPos Then
                    SubM = Int((EPos - BPos) / 3)
                    BPos = BPos + SubM
                    EPos = EPos - SubM
                Else
                    SubM = Int((EPos + (LSeq - BPos)) / 3)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    EPos = EPos - SubM
   
                    If EPos < 0 Then EPos = LSeq + EPos
                End If
                
                If BPos <= EPos Then
                    If XOverList(X, Y).Accept = 1 Then
                        For Z = BPos To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 10000
                        Next Z
                    Else
                        'First count the number of hits for this sequence
                        DoHits2 BPos, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        'For Z = BPos To EPos
                        '    NumHits(0) = NumHits(0) + HitsPerseq(X, Z)
                        '    NumHits(1) = NumHits(1) + HitsPerseq(Mi, Z)
                        '    NumHits(2) = NumHits(2) + HitsPerseq(Ma, Z)
                        'Next 'Z
                        If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                            For Z = BPos To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                            For Z = BPos To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                        ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                            For Z = BPos To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        Else
                          '  For Z = BPos To EPos
                          '      HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                           '     HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                          '      HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                          '  Next 'Z
                        End If
                    End If
                Else
                    
                    If XOverList(X, Y).Accept = 1 Then
                        For Z = 1 To EPos
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 10000
                        Next Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 10000
                        Next Z
                    Else
                        ' if region overlaps the ends
                        'First count the number of hits for this sequence
                        DoHits 1, EPos, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        DoHits BPos, LSeq, NextNo, X, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        
                        If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                            For Z = 1 To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                            For Z = 1 To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                        ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                            For Z = 1 To EPos
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        End If
                    End If
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                
            End If
            Y = Y + 1
        Loop
        Form1.ProgressBar1 = 30 + (X / NextNo) * 30
    Next 'X
                
    For X = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXover(X)
            ReDim NumHits(2)
            Mi = XOverList(X, Y).MinorP
            Ma = XOverList(X, Y).MajorP
            

            If Mi <= NextNo And Mi <> X Then
                
                BPos = XOverList(X, Y).Beginning
                EPos = XOverList(X, Y).Ending
                
                If BPos <= EPos Then
                    SubM = Int((EPos - BPos) / 3)
                    BPos = BPos + SubM
                    EPos = EPos - SubM
                Else
                    SubM = Int((EPos + (LSeq - BPos)) / 3)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    EPos = EPos - SubM
   
                    If EPos < 0 Then EPos = LSeq + EPos
                End If
                
                If BPos <= EPos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, EPos, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)


                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, EPos, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, X, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXover(), XOverList())
                    
                    XOverList(Mi, CurrentXover(Mi)) = XOverList(X, Y)
                    'XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    XOverList(Mi, CurrentXover(Mi)).Daughter = XOverList(X, Y).MinorP
                    XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(X, Y).Daughter
                    XOverList(Mi, CurrentXover(Mi)).MajorP = XOverList(X, Y).MajorP
                    Outer1 = 0
                    D = X
                    If XOverList(X, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XOverList(X, Y).OutsideFlag = 0 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 1
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = XOverList(X, Y).OutsideFlag
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 1
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 2
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 1 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 0
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = XOverList(X, Y).OutsideFlag
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            temp = XOverList(Mi, CurrentXover(Mi)).MinorP
                            XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(Mi, CurrentXover(Mi)).MajorP
                            XOverList(Mi, CurrentXover(Mi)).MajorP = temp
                            XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 0
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Or X = X Then
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 1
                                temp = XOverList(Mi, CurrentXover(Mi)).MinorP
                                XOverList(Mi, CurrentXover(Mi)).MinorP = XOverList(Mi, CurrentXover(Mi)).MajorP
                                XOverList(Mi, CurrentXover(Mi)).MajorP = temp
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 0
                                
                            Else
                                XOverList(Mi, CurrentXover(Mi)).OutsideFlag = 2
                            End If
                            XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    Call CompressList(X, Y, XOverList(), CurrentXover())
                    
                    If CurrentXover(X) > 1 And Y < CurrentXover(X) Then Y = Y - 1
                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXover(), XOverList())
                    XOverList(Ma, CurrentXover(Ma)) = XOverList(X, Y)

                    'XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    XOverList(Ma, CurrentXover(Ma)).Daughter = XOverList(X, Y).MajorP
                    XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(X, Y).MinorP
                    XOverList(Ma, CurrentXover(Ma)).MajorP = XOverList(X, Y).Daughter
                    D = X
                    Outer1 = 0
                    If XOverList(X, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XOverList(X, Y).OutsideFlag = 0 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = XOverList(X, Y).OutsideFlag
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 2
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 1 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            temp = XOverList(Ma, CurrentXover(Ma)).MinorP
                            XOverList(Ma, CurrentXover(Ma)).MinorP = XOverList(Ma, CurrentXover(Ma)).MajorP
                            XOverList(Ma, CurrentXover(Ma)).MajorP = temp
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XOverList(X, Y).OutsideFlag = 2 Then
                        If XOverList(X, Y).MissIdentifyFlag = 0 Or XOverList(X, Y).MissIdentifyFlag = 2 Then
                            
                            XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 0
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = XOverList(X, Y).MissIdentifyFlag
                        ElseIf XOverList(X, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Then
                                                                
                                XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 1
                                
                            Else
                                XOverList(Ma, CurrentXover(Ma)).OutsideFlag = 2
                            End If
                            XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    Call CompressList(X, Y, XOverList(), CurrentXover())
                    
                    If CurrentXover(X) > 1 And Y < CurrentXover(X) Then
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop
        Form1.ProgressBar1 = 60 + (X / NextNo) * 30
    Next 'X

End Sub
Public Sub SchemDown(Button As Integer)
    Dim tSeqNum() As Integer
    Dim X As Long, tmp As Long
    Dim ZYFactor As Double
    Dim LineStart As Integer, LineEnd As Integer, Z As Long
    
    ssx = GetTickCount
   
    
    'Store variable states at start of analysis


    If Button = 1 Then
        xMCTripletFlag = MCTripletFlag
        xMCProportionFlag = MCProportionFlag
        xMCPerms = MCPerms
        xMCPermMaxP = MCPermMaxP
        xMCStart = MCStart
        xMCEnd = MCEnd
        xMCMaxP = MCMaxP
        xMCSteplen = MCSteplen
        xMCWinSize = MCWinSize
        xMCWinFract = MCWinFract
        xMCStripGapsFlag = MCStripGapsFlag
        xMCFlag = MCFlag
        xXOverWindowX = XOverWindowX
        xCircularFlag = CircularFlag
        xSpacerFlag = SpacerFlag
        xLowestProb = LowestProb
        xBSTypeFlag = BSTypeFlag
        xBSStepSize = BSStepSize
        xBSStepWin = BSStepWin
        xBSBootReps = BSBootReps
        xBSCutoff = BSCutOff
        xBSPValFlag = BSPValFlag
        xSSGapFlag = SSGapFlag
        xSSVarPFlag = SSVarPFlag
        xSSOutlyerFlag = SSOutlyerFlag
        xSSRndSeed = SSRndSeed
        xSSWinLen = SSWinLen
        xSSStep = SSStep
        xSSNumPerms = SSNumPerms
        xGCMissmatchPen = GCMissmatchPen
        xGCIndelFlag = GCIndelFlag
        xGCMinFragLen = GCMinFragLen
        xGCMinPolyInFrag = GCMinPolyInFrag
        xGCMinPairScore = GCMinPairScore
        xGCMaxOverlapFrags = GCMaxOverlapFrags
        xGCTripletFlag = GCtripletflag
        xPPStripGaps = PPStripGaps
        Dim A As Integer

        For A = 0 To PermNextNo
            MaskSeq(A) = pMaskSeq(A)
        Next 'A

        MCTripletFlag = pMCTripletFlag
        MCProportionFlag = pMCProportionFlag
        MCPerms = pMCPerms
        MCPermMaxP = pMCPermMaxP
        MCStart = pMCStart
        MCEnd = pMCEnd
        MCMaxP = pMCMaxP
        MCSteplen = pMCSteplen
        MCWinSize = pMCWinSize
        MCWinFract = pMCWinFract
        MCStripGapsFlag = pMCStripGapsFlag
        MCFlag = pMCFlag
        XOverWindowX = pXOverWindowX
        CircularFlag = pCircularFlag
        SpacerFlag = pSpacerFlag
        LowestProb = pLowestProb
        BSTypeFlag = pBSTypeFlag
        BSStepSize = pBSStepSize
        BSStepWin = pBSStepWin
        BSBootReps = pBSBootReps
        BSCutOff = pBSCutoff
        BSPValFlag = pBSPValFlag
        
        SSGapFlag = pSSGapFlag
        SSVarPFlag = pSSVarPFlag
        SSOutlyerFlag = pSSOutlyerFlag
        SSRndSeed = pSSRndSeed
        SSWinLen = pSSWinLen
        SSStep = pSSStep
        SSNumPerms = pSSNumPerms
        PPStripGaps = pPPStripGaps

        If pGCTripletflag = 1 And (XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) Then
            GCtripletflag = pGCTripletflag
            GCMissmatchPen = GCMissmatchPen
            GCIndelFlag = pGCIndelFlag
            GCMinFragLen = pGCMinFragLen
            GCMinPolyInFrag = pGCMinPolyInFrag
            GCMinPairScore = pGCMinPairScore
            GCMaxOverlapFrags = pGCMaxOverlapFrags
        End If
        
        If Form2.Visible = True Then
            Form1.Refresh
            'Form2.WindowState = 1
        End If
        For X = 7 To 12
            NHString(X) = ""
        Next X
        Screen.MousePointer = 11
        Form1.SSPanel1.Caption = "Drawing Tree"
        Form1.Frame17.Visible = False
        Form1.ProgressBar1.Value = 5
        Form1.Command14.Enabled = True
        Form1.Command35.Enabled = True
        Form1.Command36.Enabled = True
        Form1.Command17.Enabled = True
        Form1.Command9.Enabled = True
        Form1.Command9.BackColor = RGB(128, 128, 255)
        Form1.Command6.Enabled = True
        Form1.Image3(0).Picture = LoadPicture() 'Bootscan plot picture
        Form1.Image3(1).Picture = LoadPicture() 'Lard plot Picture
        Form1.Image3(2).Picture = LoadPicture() 'TOPAL plot picture
        TreeImage(1) = 0
        TreeImage(2) = 0
        TreeImage(3) = 0
        'Set Flags
        RunFlag = 1
        RecombineFlag = 1
        ExeCheckFlag = 0
        OptFlag = -1
        CurrentCheck = -1
        'Retrive info on which recombinant region is neing studied
        'RelY = 0
        RecStart = XOverList(RelX, RelY).Beginning
        RecEnd = XOverList(RelX, RelY).Ending
        RecProb = XOverList(RelX, RelY).Probability

        If Seq1 = Seq2 Then Seq1 = Seq3
        Seq1 = XOverList(RelX, RelY).MajorP
        Seq2 = XOverList(RelX, RelY).MinorP
        Seq3 = XOverList(RelX, RelY).Daughter
        
        'Early start geneconv in the background

        Dim reshuffle As Integer
        XX = NextNo
        If LongWindedFlag = 1 Then
                
                ReDim tSeqNum(Len(StrainSeq(0)), 2)
                EN = XOverList(RelX, RelY).Eventnumber
                'For X = 1 To Len(StrainSeq(0))
                    
                    Form1.ProgressBar1.Value = 20
                   
                    NJFlag = 0
                    Call ModSeqNum(0)
                    XX = NextNo
                    'Seq1 = TreeTrace(Seq1)
                    'Seq2 = TreeTrace(Seq2)
                    'Seq3 = TreeTrace(Seq3)
                    '9.719
                    '5.656
                  
                    Form1.ProgressBar1.Value = 70
                    Form1.SSPanel1.Caption = "Removing recombinant regions"
                    Call MakeTreeSeqs(XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending)
                    '6.042
                    '1.891  -without recalculating distances yet again
                    GCSeq1 = Seq1
                    GCSeq2 = Seq2
                    GCSeq3 = Seq3
                    'XX = TreeTrace(33)
        End If
        'clear matrix lists that need to be cleared
        If exRelX <> RelX Or exRely <> RelY Then
            If CurMatrixFlag = 8 Then
                DoneMatX(8) = 0
                Call MCXoverK
            Else
                For X = 8 To 10
                    DoneMatX(X) = 0
                    If CurMatrixFlag = X Then
                        CurMatrixFlag = 255
                        Form1.Picture26.Picture = LoadPicture()
                        Form1.Picture18.Picture = LoadPicture()
                        Form1.Picture17.Picture = LoadPicture()
                        Form1.Label6(5) = ""
                        For Z = 0 To 4
                           Form1.Line1(Z).Visible = False
                           Form1.Label6(Z) = ""
                        Next Z
                        Form1.VScroll5.Enabled = False
                        Form1.HScroll4.Enabled = False
                    End If
                Next X
            End If
        Else
            Call MCXoverK
        End If
        If XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then

            
            If XOverList(RelX, RelY).ProgramFlag = 3 And MCTripletFlag = 1 Then
            
            Else
                Call GCCompare
            End If
        End If

        'No idea what this does.

        If XOverList(RelX, RelY).ProgramFlag <> 0 And XOverList(RelX, RelY).ProgramFlag <> AddNum Then

            If Seq1 > Seq2 Then
                reshuffle = 1
                tmp = Seq1
                Seq1 = Seq2
                Seq2 = tmp
            End If

            If reshuffle = 1 Then
                reshuffle = 0
                tmp = Seq1
                Seq1 = Seq2
                Seq2 = tmp
            End If

            Form2.SSPanel1(1).Visible = True
            Form2.SSPanel1(2).ZOrder
        ElseIf XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form2.SSPanel1(1).Visible = True
            Form2.SSPanel1(2).ZOrder
            OutsideFlagX = XOverList(RelX, RelY).OutsideFlag

            If XOverList(RelX, RelY).OutsideFlag = 1 Then
                Outlyer = Seq3
                InlyerB = Seq1
                InlyerA = Seq2
            ElseIf XOverList(RelX, RelY).OutsideFlag = 2 Then
                InlyerA = Seq3
                InlyerB = Seq1
                Outlyer = Seq2
            Else
                InlyerA = Seq3
                InlyerB = Seq1
                Outlyer = Seq2
            End If

        End If

        If Seq1 = NextNo + 1 Then Seq1 = Seq2

        If Seq2 = NextNo + 1 Then Seq2 = Seq1
        PPAVal = PAVal
        PRecSeq = RecSeq
    End If

    If Button = 2 Then
        MenuUpFlag = 1
        
        Form1.RCheckMnu.Caption = "Recheck This Event With All Methods"
        Form1.SwapMajorMinorMnu.Enabled = True
        Form1.ReassignMajorMnu.Caption = "Swap Daughter (" & StraiName(XOverList(RecSeq, PAVal).Daughter) & ") and Major Parent (" & StraiName(XOverList(RecSeq, PAVal).MajorP) & ")"
        Form1.ReassignMinorMnu.Caption = "Swap Daughter (" & StraiName(XOverList(RecSeq, PAVal).Daughter) & ") and Minor Parent (" & StraiName(XOverList(RecSeq, PAVal).MinorP) & ")"
        Form1.SwapMajorMinorMnu.Caption = "Swap Major (" & StraiName(XOverList(RecSeq, PAVal).MajorP) & ") and Minor Parent (" & StraiName(XOverList(RecSeq, PAVal).MinorP) & ")"
        SERecSeq = RecSeq
        SEPAVal = PAVal
        If XOverList(RecSeq, PAVal).Accept = 1 Then
            Form1.AcceptMnu.Enabled = False
            Form1.AcceptSMnu.Enabled = False
        Else
            Form1.AcceptMnu.Enabled = True
            Form1.AcceptSMnu.Enabled = True
        End If

        If XOverList(RecSeq, PAVal).Accept = 2 Then
            Form1.RejectMnu.Enabled = False
            Form1.RejectSMnu.Enabled = False
        Else
            Form1.RejectMnu.Enabled = True
            Form1.RejectSMnu.Enabled = True
        End If

        If XOverList(RecSeq, PAVal).MajorP = XOverList(RecSeq, PAVal).Daughter Or XOverList(RecSeq, PAVal).MajorP = NextNo + 1 Or ((XOverList(RecSeq, PAVal).ProgramFlag = 1 Or XOverList(RecSeq, PAVal).ProgramFlag = 1 + AddNum) And pGCTripletflag = 0) Then
            Form1.ReassignMajorMnu.Enabled = False
            Form1.SwapMajorMinorMnu.Enabled = False

            If (XOverList(RecSeq, PAVal).ProgramFlag = 1 Or XOverList(RecSeq, PAVal).ProgramFlag = 1 + AddNum) And pGCTripletflag = 0 Then
                
                If XOverList(RecSeq, PAVal).OutsideFlag = 1 Then
                    Form1.ReassignMinorMnu.Enabled = False
                    Form1.ReassignMajorMnu.Enabled = True
                    Form1.SwapMajorMinorMnu.Enabled = True
                ElseIf XOverList(RecSeq, PAVal).OutsideFlag = 2 Or XOverList(RecSeq, PAVal).OutsideFlag = 0 Then
                    Form1.ReassignMinorMnu.Enabled = True
                    Form1.ReassignMajorMnu.Enabled = False
                    Form1.SwapMajorMinorMnu.Enabled = True
                ElseIf XOverList(RecSeq, PAVal).OutsideFlag = 3 Then
                    Form1.ReassignMinorMnu.Enabled = True

                    If XOverList(RecSeq, PAVal).ProgramFlag <> 1 Then
                        Form1.ReassignMajorMnu.Enabled = False
                    Else
                        Form1.ReassignMajorMnu.Enabled = True
                    End If

                    Form1.SwapMajorMinorMnu.Enabled = False
                End If

            End If

        Else
            Form1.ReassignMajorMnu.Enabled = True
        End If

        If XOverList(RecSeq, PAVal).MinorP = XOverList(RecSeq, PAVal).Daughter Or XOverList(RecSeq, PAVal).MinorP = NextNo + 1 Then
            Form1.ReassignMinorMnu.Enabled = False
            Form1.SwapMajorMinorMnu.Enabled = False
        Else
            Form1.ReassignMinorMnu.Enabled = True
        End If

        Form1.PopupMenu Form1.SchemEditMnu
    ElseIf Button = 1 Then
        On Error Resume Next
        LowestProb = Val(Form1.Text1.Text)
        LowestProb = CDbl(Form1.Text1.Text)
        On Error GoTo 0
        ManFlag = -1
        TManFlag = -1
        TimerVal = 0
        Form1.Timer1.Enabled = True

        For Z = 1 To 3
            For A = 0 To 3
                DoneTree(A, Z) = 0
            Next A
        Next 'Z

        'This draws all of the plts display panel stuff
        OutsideFlagX = XOverList(RelX, RelY).OutsideFlag
        
        
       
        If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form1.SSPanel1.Caption = "Drawing Identity Plots"
            
            

            'XX = TreeTrace(25)
            'Call RTSpacerFind
            Call XOverIII(0)
            Call DoCombo(0)
            
            
        ElseIf XOverList(RelX, RelY).ProgramFlag = 6 Or XOverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
            Form1.SSPanel1.Caption = "Executing PhylPro"
            Call PXoverE
            
            Call DoCombo(0)
        ElseIf XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
            If pGCTripletflag = 1 Then
                Call GCCompare
                Call GCCheck(0)
                Call DoCombo(0)
            Else
                Call GCDraw
                Call DoCombo(1)
    
                SpacerNo = 0
                ReDim SpacerSeqs(NextNo)
    
                For X = 0 To NextNo
    
                    If X <> Seq1 And X <> Seq2 And MaskSeq(X) < 2 Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                    End If
    
                Next 'X
            End If
        ElseIf XOverList(RelX, RelY).ProgramFlag = 2 Or XOverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
            
            
            
            
            
            
            If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then
                
                Call BSXoverL(0)
                
            Else
                Call FindSubSeqBS
                Dim WeightMod() As Long, Scratch() As Integer
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())
                
                
                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            End If

            Call MakeXOverSeq
            'Call MakeXOverSeq
             
            Call DoCombo(0)

        ElseIf XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
            Form1.SSPanel1.Caption = "Executing MaxChi"

            If XOverList(RelX, RelY).Daughter <> XOverList(RelX, RelY).MajorP And XOverList(RelX, RelY).Daughter <> XOverList(RelX, RelY).MinorP And XOverList(RelX, RelY).MajorP <> XOverList(RelX, RelY).MinorP Then
                    Call MCXoverG(0)
                
                Call DoCombo(0)
                Call MakeXOverSeq
               
            Else

                Call MCXoverI
                Call DoCombo(1)

                SpacerNo = 0
                ReDim SpacerSeqs(NextNo)

                For X = 0 To NextNo

                    If X <> Seq1 And X <> Seq2 And MaskSeq(X) < 2 Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                        'Form1.Command6.Enabled = True
                    End If

                Next 'X

            End If
        ElseIf XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
            Form1.SSPanel1.Caption = "Executing Chimaera"

            
                'If BSFileName = "BSfile2" Then
                    Call CXoverB
                    'Call CXoverC(0)
                'Else
                '    Call CXoverC(0)
                'End If
                
                Call DoCombo(0)

            
        ElseIf XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            Call SSXoverB(0)
            Call DoCombo(0)
            If Form1.Picture12.Visible = True Then
                Form1.Picture12.AutoRedraw = True
                Form1.Picture12.Picture = LoadPicture()
                For X = 1 To 15
                    Form1.Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                Next X
                Form1.Picture12.ForeColor = RGB(150, 150, 150)
                For X = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 250 + 14
                    Form1.Picture12.CurrentY = 50 + (X - 1) * 200 + 14
                    Form1.Picture12.Print "P" & Trim$(CStr(X))
                Next X
                
                
                Form1.Picture12.ForeColor = 0
                
                For X = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 250
                    Form1.Picture12.CurrentY = 50 + (X - 1) * 200
                    Form1.Picture12.Print "P" & Trim$(CStr(X))
                Next X
                
                For X = 1 To 9
                    Form1.Picture12.Line (750, 50 + 200 * (X - 1))-(900, 50 + (200 * (X - 1) + 150)), PltCol2(X), BF
                Next X
                Form1.Picture12.ForeColor = RGB(150, 150, 150)
                For X = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 950 + 14
                    Form1.Picture12.CurrentY = 50 + (X - 1) * 200 + 14
                    Form1.Picture12.Print "S" & Trim$(CStr(X))
                Next X
                
                
                Form1.Picture12.ForeColor = 0
                
                For X = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 950
                    Form1.Picture12.CurrentY = 50 + (X - 1) * 200
                    Form1.Picture12.Print "S" & Trim$(CStr(X))
                Next X
                
                Form1.Picture12.Refresh
            End If
        End If
        
        'Seq1 = TreeTraceSeqs(1, Seq1)
        'Seq2 = TreeTraceSeqs(1, Seq2)
        'Seq3 = TreeTraceSeqs(1, Seq3)
        
       ' KPFlag = 0
       ' ST = GetTickCount
       ' Do While ET - ST < 2000
       '     DoEvents
       '     ET = GetTickCount
       '
       ' Loop
        
        If X = X Then
            Form1.SSPanel1.Caption = "Drawing Trees"
            Form1.ProgressBar1.Value = 5
            
            'Do the trees
            PartFlag = 2
            XX = NextNo
            'Call UnModNextno
            Call ModNextno
            
            'Dim SeqNumBak() As Integer
            'ReDim SeqNumBak(Len(StrainSeq(0)), Nextno)
            
            
            TreeTypeFlag = 2
    
            Form1.Label14 = "UPGMA of Region " + Trim$(CStr(XOverList(RelX, RelY).Beginning)) + " - " + Trim$(CStr(XOverList(RelX, RelY).Ending)) '  Recombinant Region"
    
            Call RecUPGMAII
    
            TreeImage(2) = 1
                
            DoneTree(0, 2) = 1
            
            
            
            
            Dim CurrentState As Integer
    
            CurrentState = TreeTypeFlag
            
            'Sort out the multiple tree display if it is visible
    
            If Form2.Visible = True Then
    
                For Z = 1 To 3
                    Form2.Picture2(Z).Visible = True
                Next 'Z
    
                Form1.ProgressBar1.Value = 60
    
                Call MultTreeWin
    
                TreeTypeFlag = CurrentState
                Form1.ProgressBar1.Value = 90
            Else
                Form1.ProgressBar1.Value = 90
            End If
        Else
            KPFlag = 0
        End If
        If LongWindedFlag = 1 Then
            Call UnModSeqNum(0)
            Call UnModNextno
        End If

        'Retrieve variable states saved before analysis began
        MCTripletFlag = xMCTripletFlag
        MCProportionFlag = xMCProportionFlag
        MCPerms = xMCPerms
        MCPermMaxP = xMCPermMaxP
        MCStart = xMCStart
        MCEnd = xMCEnd
        MCMaxP = xMCMaxP
        MCSteplen = xMCSteplen
        MCWinSize = xMCWinSize
        MCWinFract = xMCWinFract
        MCStripGapsFlag = xMCStripGapsFlag
        MCFlag = xMCFlag
        XOverWindowX = xXOverWindowX
        CircularFlag = xCircularFlag
        SpacerFlag = xSpacerFlag
        LowestProb = xLowestProb
        SpacerNo = SpacerNo
        BSTypeFlag = xBSTypeFlag
        BSStepSize = xBSStepSize
        BSStepWin = xBSStepWin
        BSBootReps = xBSBootReps
        BSCutOff = xBSCutoff
        BSPValFlag = xBSPValFlag
        SSGapFlag = xSSGapFlag
        SSVarPFlag = xSSVarPFlag
        SSOutlyerFlag = xSSOutlyerFlag
        SSRndSeed = xSSRndSeed
        SSWinLen = xSSWinLen
        SSStep = xSSStep
        SSNumPerms = xSSNumPerms
        GCMissmatchPen = xGCMissmatchPen
        GCIndelFlag = xGCIndelFlag
        GCMinFragLen = xGCMinFragLen
        GCMinPolyInFrag = xGCMinPolyInFrag
        GCMinPairScore = xGCMinPairScore
        GCMaxOverlapFrags = xGCMaxOverlapFrags
        GCtripletflag = xGCTripletFlag
        PPStripGaps = xPPStripGaps

        'Sort out compatibility matrices if they have been drawn

        If RETFlag = 3 Then

            If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
                ZYFactor = Form4.Picture3.ScaleWidth / Square
                'Form4.Picture3.Picture = Form1.Picture27.Image
                BitBlt Form4.Picture3.hdc, 0, 0, Square, Square, Form1.Picture27.hdc, 0, 1, &HCC0020
                Form4.Picture3.DrawMode = 12
                Form4.Picture3.ScaleMode = 3
                Form4.Picture3.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - (ZYFactor)), 0)-(RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor * 2, RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - (ZYFactor + 1)), RGB(0, 255, 255), BF
                Form4.Picture3.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - (ZYFactor)), RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor)-(RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor * 2, Form4.Picture3.Height), RGB(0, 255, 255), BF
                Form4.Picture3.Line (0, (RetYPos(XOverList(RelX, RelY).Beginning)) * ZYFactor - (ZYFactor))-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor - ZYFactor, RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor), RGB(0, 255, 255), BF
                Form4.Picture3.Line (RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor, RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - (ZYFactor))-(Form4.Picture3.Height, RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor * 2), RGB(0, 255, 255), BF
                Form4.Picture3.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor), Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor))-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor), Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor)), Yellow, BF
                Form4.Picture3.DrawMode = 13
                MatrixFlag = 0
                Call DoMatCap
                Form1.Picture26.Picture = Form1.Picture28(0).Image
                Form1.Picture26.DrawMode = 12
                Form1.Picture26.AutoRedraw = True
                Form1.Picture26.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - (XYFactor)), 0)-(RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor * 2, RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - (XYFactor + 1)), RGB(0, 255, 255), BF
                Form1.Picture26.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - (XYFactor)), RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor)-(RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor * 2, Form1.Picture26.Height), RGB(0, 255, 255), BF
                Form1.Picture26.Line (0, (RetYPos(XOverList(RelX, RelY).Beginning)) * XYFactor - (XYFactor))-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor - XYFactor, RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor), RGB(0, 255, 255), BF
                Form1.Picture26.Line (RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor, RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - (XYFactor))-(Form1.Picture26.Height, RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor * 2), RGB(0, 255, 255), BF
                Form1.Picture26.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor), Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor))-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor), Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor)), Yellow, BF
                Form1.Picture26.DrawMode = 13
                Form1.Picture26.Refresh
            Else
                ZYFactor = Form4.Picture3.ScaleWidth / Square
                'Form4.Picture3.Picture = Form1.Picture27.Image
                BitBlt Form4.Picture3.hdc, 0, 0, Square, Square, Form1.Picture27.hdc, 0, 1, &HCC0020
                Form4.Picture3.DrawMode = 12
                Form4.Picture3.ScaleMode = 3
                Form4.Picture3.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - (ZYFactor)), RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor)-(Form4.Picture3.Height, (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor - ZYFactor), RGB(0, 255, 255), BF
                Form4.Picture3.Line (RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor, (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor)-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor - ZYFactor, Form4.Picture3.Height), RGB(0, 255, 255), BF
                Form4.Picture3.Line (0, RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor)-(Int(RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor * 2), (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor - ZYFactor), RGB(0, 255, 255), BF
                Form4.Picture3.Line (RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor, 0)-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * ZYFactor - ZYFactor, RetYPos(XOverList(RelX, RelY).Ending) * ZYFactor - ZYFactor * 2), RGB(0, 255, 255), BF
                Form4.Picture3.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor), Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor))-(Form4.Picture3.Height, Form4.Picture3.Height), Yellow, BF
                Form4.Picture3.Line (0, Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor))-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor), Form4.Picture3.Height), Yellow, BF
                Form4.Picture3.Line (0, 0)-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor), Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor)), Yellow, BF
                Form4.Picture3.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * ZYFactor - ZYFactor), 0)-(Form4.Picture3.Height, Int(RetYPos(XOverList(RelX, RelY).Ending) * (ZYFactor) - 2 * ZYFactor)), Yellow, BF
                Form4.Picture3.DrawMode = 13
                MatrixFlag = 0
                Call DoMatCap
                Form1.Picture26.Picture = Form1.Picture28(0).Image
                Form1.Picture26.DrawMode = 12
                Form1.Picture26.AutoRedraw = True
                Form1.Picture26.Line ((RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - (XYFactor)), RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor)-(Form1.Picture26.Height, (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor - XYFactor), RGB(0, 255, 255), BF
                Form1.Picture26.Line (RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor, (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor)-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor - XYFactor, Form1.Picture26.Height), RGB(0, 255, 255), BF
                Form1.Picture26.Line (0, RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor)-(Int(RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor * 2), (RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor - XYFactor), RGB(0, 255, 255), BF
                Form1.Picture26.Line (RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor, 0)-((RetYPos(XOverList(RelX, RelY).Beginning) - 1) * XYFactor - XYFactor, RetYPos(XOverList(RelX, RelY).Ending) * XYFactor - XYFactor * 2), RGB(0, 255, 255), BF
                Form1.Picture26.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor), Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor))-(Form1.Picture26.Height, Form1.Picture26.Height), Yellow, BF
                Form1.Picture26.Line (0, Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor))-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor), Form1.Picture26.Height), Yellow, BF
                Form1.Picture26.Line (0, 0)-(Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor), Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor)), Yellow, BF
                Form1.Picture26.Line (Int(RetYPos(XOverList(RelX, RelY).Beginning) * XYFactor - XYFactor), 0)-(Form1.Picture26.Height, Int(RetYPos(XOverList(RelX, RelY).Ending) * (XYFactor) - 2 * XYFactor)), Yellow, BF
                Form1.Picture26.DrawMode = 13
                Form1.Picture26.Refresh
            End If

        End If

        'If ORF info has been loaded, shade the orfmap appropriately

        If ORFFlag = 1 Then
            Form1.Picture20.Picture = Form1.Picture19.Image
            Form1.Picture20.Visible = True
            Form1.Picture20.BorderStyle = 0

            Dim P20XFactor As Double

            P20XFactor = Form1.Picture20.ScaleWidth / Len(StrainSeq(0))
            LineStart = CInt(P20XFactor * RecStart) - 1
            LineEnd = CInt(P20XFactor * RecEnd) + 1

            If LineEnd > LineStart Then
                Form1.Picture20.DrawMode = 5
                Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF 'RGB(255 - BkR, 255 - BkG, 255 - BkB), BF
                Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
            Else
                Form1.Picture20.DrawMode = 5
                Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
                Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
                Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
            End If

        End If

        Form1.Picture20.Refresh

        If ((XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Or XOverList(RelX, RelY).ProgramFlag = 2 Or XOverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then SpacerNo = 0

        If (XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And Seq1 = Seq2 Then
            ShowSeqFlag = 0
            Form1.HScroll1.SmallChange = 1
            Form1.Picture3.Enabled = True
            Form1.Label21 = "Show All Sequences"
            Form1.Picture3.Picture = LoadPicture()
            Form1.Picture3.CurrentX = 0
            Form1.Picture3.CurrentY = 0
            Form1.Command6.Enabled = False
            Call PrintNames
        End If
        
        If ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
            Form1.Picture3.Picture = LoadPicture()
            Form1.Picture3.AutoRedraw = True
            Call PrintNames2(Form1.Picture3, XOverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
            LastY3 = -1
            'Form1.Picture3.Enabled = False
        End If

        'Disable the"STOP" button
        Form1.Command25.Enabled = False
        Form1.ProgressBar1.Value = 100
    End If
    If RelY <= UBound(XOverList, 2) Then
        If XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
        
        Else
            Form1.Picture12.Visible = False
        End If
    Else: RelY = 0
    End If
    
    If Form1.VScroll1.Value <> 0 Then
        Form1.VScroll1.Value = 0
    Else
         Form1.VScroll1.Value = 1
    End If
    'X = X
End Sub

Public Sub DoLegend()

    Dim StY As Integer
    Dim LenStr As Long, OldCY As Long, X As Long, Z As Long

    If Form5.Combo1.ListIndex < 1 And (ManFlag = 3 Or ManFlag = 1 Or ManFlag = 7 Or ManFlag = 4) Then Exit Sub
    Form1.Frame17.Visible = False
    With Form1.Picture2
        .AutoRedraw = True
        .Picture = LoadPicture()
        .CurrentX = 0
        .CurrentY = 5
        .ScaleMode = 3
        .BackColor = BackColours
    End With

    If ((NumberOfSeqs + 10) * 15 * Screen.TwipsPerPixelY) > Form1.Picture2.Height Then Form1.Picture2.Height = ((NumberOfSeqs + 10) * 15) * Screen.TwipsPerPixelY

    With Form1.SSPanel16
        .BackColor = QBColor(8)
        .FontSize = 12
        .FontBold = True
    End With

    With Form1.Combo1
        .Clear
        .BackColor = Form1.BackColor
        .Enabled = False
    End With

    'Form1.Command29.Enabled = False
    ReDim RefCol(NumberOfSeqs + 1)
    RefCol(0) = GetPixel(Form1.Picture2.hdc, 2, 2)
On Error Resume Next
    If ManFlag = 1 Then
        Form1.SSPanel16.Caption = "Manual GENECONV Scan"
        Form1.Picture2.Print StraiName(Form5.Combo1.ListIndex - 1) + " scanned against:"
        StY = Form1.Picture2.CurrentY + 5

        If APlot > 0 And APlot <= NumberOfSeqs Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        ElseIf APlot = NumberOfSeqs + 1 Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        End If

        For Z = 1 To NumberOfSeqs
            If UBound(SeqCol, 1) < RevSeq(Z) Then ReDim Preserve SeqCol(RevSeq(Z))
            Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(Z)), BF
            RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Next 'Z

        Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(0)), BF
        RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Form1.Picture2.Print
        Form1.Picture2.Print "G-Scale:" & CStr(GCMissmatchPen)
        Form1.Picture2.Print "Minimum aligned fragment length:" & CStr(GCMinFragLen)
        Form1.Picture2.Print "Minimum number of polymorphisms per fragment:" & CStr(GCMinPolyInFrag)
        Form1.Picture2.Print "Minimum pairwise fragment score:" & CStr(GCMinPairScore)

        If GCIndelFlag = 0 Then
            Form1.Picture2.Print "Indels ignored"
        ElseIf GCIndelFlag = 1 Then
            Form1.Picture2.Print "Indel blocs used as single polymorphisms"
        Else
            Form1.Picture2.Print "Every indel used as a single polymorphism"
        End If

        If GCMonoSiteFlag = 0 Then
            Form1.Picture2.Print "Monomorphic sites not used"
        ElseIf GCMonoSiteFlag Then
            Form1.Picture2.Print "Monomorphic sites used"
        End If

        If GCNumPerms > 1 Then
            Form1.Picture2.Print "Permutations used:"; CStr(GCNumPerms)
        Else
            Form1.Picture2.Print "No Permutations used"
        End If

        Form1.Picture2.ForeColor = 0

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
            Form1.Picture2.Print StraiName(RevSeq(Z))
        Next 'Z

        Form1.Picture2.CurrentX = 25
        Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
        Form1.Picture2.Print "Outer fragments (potentially unknown parents)"
    ElseIf ManFlag = 3 Then
        Form1.SSPanel16.Caption = "Manual Bootscan"
        Form1.Picture2.Print StraiName(Form5.Combo1.ListIndex - 1) + " scanned against:"
        StY = Form1.Picture2.CurrentY + 5

        If APlot > 0 Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(Z)), BF
            RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Next 'Z

        Form1.Picture2.Print
        Form1.Picture2.Print "Window size:" + CStr(BSStepWin)
        Form1.Picture2.Print "Step size:" + CStr(BSStepSize)
        Form1.Picture2.Print "Bootstrap replicates:" + CStr(BSBootReps)

        If BSTypeFlag = 0 Then
            Form1.Picture2.Print "Pairwise distances used"
        ElseIf BSTypeFlag = 1 Then
            Form1.Picture2.Print "Positions in an UPGMA used"
        Else
            Form1.Picture2.Print "Positions in a NJ tree used"
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
            Form1.Picture2.Print StraiName(RevSeq(Z))
        Next 'Z

    ElseIf ManFlag = 4 Then
        Form1.SSPanel16.Caption = "Manual MaxChi Scan"
        Form1.Picture2.Print StraiName(Form5.Combo1.ListIndex - 1) + " scanned against:"
        'Exit Sub
        StY = Form1.Picture2.CurrentY + 5

        If APlot > 0 Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(Z)), BF
            RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Next 'Z

        Form1.Picture2.Print

        If MCProportionFlag = 0 Then
            Form1.Picture2.Print "Window size:" + CStr(MCWinSize)
        Else
            Form1.Picture2.Print "Window size:" + CStr(Int(MCWinFract * LenXOverSeq))
        End If

        Form1.Picture2.Print "Step size:" + CStr(MCSteplen)

        If MCStripGapsFlag = 1 Then
            Form1.Picture2.Print "Gaps stripped"
        Else
            Form1.Picture2.Print "Gaps used"
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
            Form1.Picture2.Print StraiName(RevSeq(Z))
        Next 'Z

    ElseIf TManFlag = 5 Then
        Form1.SSPanel16.Caption = "Manual LARD Scan"
        Form1.Picture2.CurrentY = 5
        Form1.Picture2.Print
        OldCY = Form1.Picture2.CurrentY
        LenStr = Form1.Picture2.TextWidth("Sequences scanned: ")
        Form1.Picture2.Print "Selected sequences:"
        Form1.Picture2.CurrentY = OldCY

        For X = 0 To 2
            Form1.Picture2.CurrentX = LenStr
            Form1.Picture2.Print StraiName(RevSeq(X))
        Next 'X

        Form1.Picture2.Print
        Form1.Picture2.Print "Step size:" + CStr(LRDStep)
    ElseIf ManFlag = 7 Then
        Form1.SSPanel16.Caption = "Manual Distance Plot"
        Form1.Picture2.Print StraiName(Form5.Combo1.ListIndex - 1) + " scanned against:"
        StY = Form1.Picture2.CurrentY + 5

        If APlot > 0 Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(Z)), BF
            RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Next 'Z

        Form1.Picture2.Print
        Form1.Picture2.Print "Window size:" + CStr(DPWindow)
        Form1.Picture2.Print "Step size:" + CStr(DPStep)

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
            Form1.Picture2.Print StraiName(RevSeq(Z))
        Next 'Z

    ElseIf ManFlag = 8 Then
        Form1.SSPanel16.Caption = "Manual TOPAL Scan"
        Form1.Picture2.CurrentY = 5
        Form1.Picture2.Print
        OldCY = Form1.Picture2.CurrentY
        LenStr = Form1.Picture2.TextWidth("Sequences scanned: ")
        Form1.Picture2.Print "Selected sequences:"
        Form1.Picture2.CurrentY = OldCY

        For X = 0 To ToNumSeqs
            Form1.Picture2.CurrentX = LenStr
            Form1.Picture2.Print StraiName(RevSeq(X))
        Next 'X

        Form1.Picture2.Print

        If TOPerms > 0 Then
            StY = Form1.Picture2.CurrentY + 5
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (0) * 15
            Form1.Picture2.Print "Scan of selected sequences"
            Form1.Picture2.Line (5, StY + (0) * 15)-(17, StY + 12 + (0) * 15), 0, BF
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (1) * 15

            If TOPerms > 1 Then
                Form1.Picture2.Print "Scan of permuted datasets"
            Else
                Form1.Picture2.Print "Scan of permuted dataset"
            End If

            Form1.Picture2.Line (5, StY + (1) * 15)-(17, StY + 12 + (1) * 15), QBColor(8), BF
        End If

        Form1.Picture2.Print
        Form1.Picture2.Print "Window size:" + CStr(TOWinLen)
        Form1.Picture2.Print "Step size:" + CStr(TOStepSize)
        Form1.Picture2.Print "Smoothing window size:" + CStr(TOSmooth)

        If TOPerms > 0 Then
            Form1.Picture2.Print "Number of permutations:" + CStr(TOPerms)
        Else
            Form1.Picture2.Print "No permutations performed"
        End If
    ElseIf ManFlag = 10 Then
        NumberOfSeqs = NextNo + 1
        Form1.SSPanel16.Caption = "Manual PhylPro Scan"
        
        StY = Form1.Picture2.CurrentY + 5

        If APlot > 0 Then
            Form1.Picture2.Line (0, StY - 2 + (APlot - 1) * 15)-(Form1.Picture2.ScaleWidth, StY + 14 + (APlot - 1) * 15), FFillCol(RevSeq(APlot)), BF
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.Line (5, StY + (Z - 1) * 15)-(17, StY + 12 + (Z - 1) * 15), SeqCol(RevSeq(Z)), BF
            RefCol(Z) = GetPixel(Form1.Picture2.hdc, 6, StY + (Z - 1) * 15 + 1)
        Next 'Z

        Form1.Picture2.Print

        If MCProportionFlag = 0 Then
            Form1.Picture2.Print "Window size:" + CStr(MCWinSize)
        Else
            Form1.Picture2.Print "Window size:" + CStr(Int(MCWinFract * LenXOverSeq))
        End If

        Form1.Picture2.Print "Step size:" + CStr(MCSteplen)

        If MCStripGapsFlag = 1 Then
            Form1.Picture2.Print "Gaps stripped"
        Else
            Form1.Picture2.Print "Gaps used"
        End If

        For Z = 1 To NumberOfSeqs
            Form1.Picture2.ForeColor = 0
            Form1.Picture2.CurrentX = 25
            Form1.Picture2.CurrentY = StY + 1 + (Z - 1) * 15
            Form1.Picture2.Print StraiName(RevSeq(Z))
        Next 'Z
    End If
On Error GoTo 0
    P2DHeight = Form1.Picture2.CurrentY + (15) * 7

    If P2DHeight > (Form1.Picture32.ScaleHeight / Screen.TwipsPerPixelY) Then
        Form1.VScroll4.Max = P2DHeight - (Form1.Picture32.ScaleHeight / Screen.TwipsPerPixelY)
        Form1.VScroll4.Enabled = True
    Else

        If Form1.Picture2.Top = 0 Then Form1.VScroll4.Enabled = False
    End If

    Form1.Picture2.Refresh
End Sub
Public Sub StartReticulate()
    Exit Sub
    If RETFlag = 1 Then Exit Sub

    Dim ODir$
    Dim X As Long

    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path

    Dim Option1 As Integer

    Option1 = RetSiteFlag

    Dim Option2 As Integer

    Option2 = RetNumMatrixFlag

    Dim FirstSeq As Integer
    Dim NextFile As Integer


        NextFile = FreeFile
        Open "in" For Output As #NextFile
        FirstSeq = 0

        For X = 0 To NextNo

            If MaskSeq(X) < 2 Then

                If FirstSeq = 0 Then
                    FirstSeq = 1
                    Print #NextFile, Option1 & Option2 & ">>s" & Trim$(CStr(X + 1))
                    Print #NextFile, StrainSeq(X)
                End If

                Print #NextFile, ">s" & Trim$(CStr(X + 1))
                Print #NextFile, StrainSeq(X)
            End If

        Next 'X

        Close #NextFile
        reProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell("reticulate.exe", 0))
        ChDir ODir$
        ChDrive ODir$
        RETFlag = 1
        'Nextno = Nextno
End Sub

Public Sub ShutRunning()

    Dim ODir As String, TitleTmp As String
    Dim tExitCode As Long, nRet As Long

    Const STILL_ACTIVE = &H103
    On Error Resume Next
    'Shut down any shelled apps that may still be running

    If scProcess > 0 Then
        TitleTmp = Space$(256)
        nRet = GetWindowText(scWndJob, TitleTmp, Len(TitleTmp))

        If nRet Then
            TitleTmp = UCase$(left$(TitleTmp, nRet))

            If InStr(TitleTmp, "FINISHED") = 1 Then

                Call SendMessage(scWndJob, WM_CLOSE, 0, 0)

            End If

        End If

        GetExitCodeProcess scProcess, nRet

        If nRet = STILL_ACTIVE Then
            TerminateProcess scProcess, nRet
        End If

        CloseHandle scProcess
        scProcess = 0
    End If

    If reProcess > 0 Then
        GetExitCodeProcess reProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess reProcess, tExitCode
            Dummy = CloseHandle(reProcess)
        End If

        reProcess = 0
    End If

    tExitCode = 0

    If mcProcess > 0 Then
        GetExitCodeProcess mcProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess mcProcess, tExitCode
            Dummy = CloseHandle(mcProcess)
        End If

        mcProcess = 0
    End If

    tExitCode = 0

    If gcmcProcess > 0 Then
        GetExitCodeProcess gcmcProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess gcmcProcess, tExitCode
            Dummy = CloseHandle(gcmcProcess)
        End If

        gcmcProcess = 0
    End If

    tExitCode = 0

    If gcProcess > 0 Then
        GetExitCodeProcess gcProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess gcProcess, tExitCode
            Dummy = CloseHandle(gcProcess)
        End If

        gcProcess = 0
    End If

    tExitCode = 0

    If cProcess > 0 Then
        GetExitCodeProcess cProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess cProcess, tExitCode
            Dummy = CloseHandle(cProcess)
        End If

        cProcess = 0
    End If

    tExitCode = 0

    If hProcess > 0 Then
        GetExitCodeProcess hProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess hProcess, tExitCode
            Dummy = CloseHandle(hProcess)
        End If

        hProcess = 0
    End If

    If lProcess > 0 Then
        GetExitCodeProcess lProcess, nRet
        TitleTmp = Space$(256)
        nRet = GetWindowText(lWndJob, TitleTmp, Len(TitleTmp))

        If nRet Then
            TitleTmp = UCase$(left$(TitleTmp, nRet))

            If InStr(TitleTmp, "FINISHED") = 1 Then

                Call SendMessage(lWndJob, WM_CLOSE, 0, 0)

            End If

        End If

        GetExitCodeProcess lProcess, nRet

        If nRet = STILL_ACTIVE Then
            TerminateProcess lProcess, nRet
        End If

        CloseHandle lProcess
        lProcess = 0
    End If

    'clean up outfiles
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    Kill "tf"
    Kill "comp.cfg"
    Kill "comp.frags"
    Kill GCFragCfg
    Kill GCOFile
    Kill GCCompCfg
    Kill GCPOutCfg
    Kill GCCFile
    Kill GCFragSeq
    Kill "outfiley"
    Kill "infile"
    Kill "outfilex"
    Kill "rdpfile.txt"
    Kill "LARD.EXE.stackdump"
    Kill "lardin"
    Kill "config.cfg"
    Kill "dnadist.bat"
    Kill "dnaml.bat"
    Kill "fitch1.bat"
    Kill "fitch2.bat"
    Kill "fitch3.bat"
    Kill "fitch4.bat"
    Kill "in"
    Kill "maxchi.bat"
    Kill "maxchiout"
    Kill "neighbor.bat"
    Kill "neighbor1.bat"
    Kill "neighbor2.bat"
    Kill "optfile"
    Kill "optfiled"
    Kill "optfilef1"
    Kill "optfilef2"
    Kill "optfilef3"
    Kill "optfilef4"
    Kill "optfilen"
    Kill "optfilen1"
    Kill "optfilen2"
    Kill "optfiles"
    Kill "out.eps"
    Kill "out.sit"
    Kill "RETICULATE.EXE.stackdump"
    Kill "rnd.eps"
    Kill "stat"
    Kill "seqboot.bat"
    Kill "BSScanData"
    Kill "bsfile2"
    Kill "distmatrix"
    Kill "comptf"
    Kill "consense.bat"
    Kill "optfilec"
    Kill "seqgen.bat"
    ChDir ODir
    On Error GoTo 0
End Sub
Public Sub ResortCurrentxover(S1)
    Dim GoOn As Byte
    Dim WinPrg As Integer, Prg As Integer
    Dim WinRep As Long, WinRepB As Long, MaxPValB As Double, MaxPVal As Double, MaxPu As Long, Begin As Long, Ending As Long
    Dim PVal As Double
    Dim PU() As Long
    ReDim PU(AddNum * 2)
    Prg = XOverList(S1, MaxXOListSize).ProgramFlag
    Begin = XOverList(S1, MaxXOListSize).Beginning
    Ending = XOverList(S1, MaxXOListSize).Ending
    PVal = XOverList(S1, MaxXOListSize).Probability
    MaxPVal = 0
    'First find most represented program
    
    For X = 0 To MaxXOListSize - 1
        PU(XOverList(S1, X).ProgramFlag) = PU(XOverList(S1, X).ProgramFlag) + 1
    Next ' X
    For X = 0 To AddNum * 2
        If PU(X) >= MaxPu Then
            MaxPu = PU(X)
            WinPrg = X
        End If
    Next 'X
    
    For X = 1 To MaxXOListSize - 1
        If XOverList(S1, X).ProgramFlag = WinPrg Then
            If (PVal <= XOverList(S1, X).Probability Or (Prg <> XOverList(S1, X).ProgramFlag And Prg <> XOverList(S1, X).ProgramFlag + AddNum)) And XOverList(S1, X).Probability > MaxPVal Then
                If XOverList(S1, X).Beginning >= Begin And XOverList(S1, X).Ending <= Ending Then
                    MaxPVal = XOverList(S1, X).Probability
                    WinRep = X
                End If
                WinRepB = X
                MaxPValB = XOverList(S1, X).Probability
            End If
        End If
    Next X
    
    If MaxPValB > 0 Then 'ie there is no space but there is a worse P-val, so replace it.
        
        WinRep = WinRepB
    End If
    
    If WinRep > 0 Then
        
        
        
        If RelX = 0 And RelY = 0 And SEventNumber < 1 Then
            RecombNo(XOverList(S1, WinRep).ProgramFlag) = RecombNo(XOverList(S1, WinRep).ProgramFlag) - 1
        End If
        XOverList(S1, WinRep) = XOverList(S1, MaxXOListSize)
    Else
        
         If RelX = 0 And RelY = 0 And SEventNumber < 1 Then
            RecombNo(XOverList(S1, MaxXOListSize).ProgramFlag) = RecombNo(XOverList(S1, MaxXOListSize).ProgramFlag) - 1
         End If
    End If
    
    
End Sub
Public Sub WriteMatrix()
    Exit Sub
    If RETFlag <> 1 Then Exit Sub 'Exit if we've already done this before

    Dim ODir As String, VString As String, XString As String, tempstring As String, NewString As String
    Dim A As Integer, B As Integer, ErrorFlagX As Integer, Y As Integer, MatArray As Integer, PWid As Integer, DWidth As Integer
    Dim LSeq As Long, CPos As Long, RetVal As Long, LastPos As Long, EY As Long, X As Long, Pic As Long
    Dim Matrix() As Byte

    RETFlag = 2 'Keeps track of where we are
    LSeq = Len(StrainSeq(0))
    Form1.ProgressBar1.Value = 10
    Form1.SSPanel1.Caption = "Executing Reticulate"
    DoEvents
    'Wait for Reticulate to finish executing
    Const STILL_ACTIVE = &H103

    Do
        Sleep (10)
        DoEvents

        If RedoReticulateFlag = 1 Then

            Dim tExitCode As Long

            GetExitCodeProcess reProcess, tExitCode
            TerminateProcess reProcess, tExitCode
            Dummy = CloseHandle(reProcess)
            reProcess = 0
            ODir$ = CurDir
            ChDir App.Path
            ChDrive App.Path
            Exit Sub
        End If

        GetExitCodeProcess reProcess, RetVal
    Loop While RetVal = STILL_ACTIVE

    CloseHandle reProcess
    reProcess = 0
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 30
    Form1.SSPanel1.Caption = "Drawing Matrices"
    'Read the file containing ststistics.
    Open "stat" For Binary Access Read As 1
    'Load whole file into "XString"
    XString = String$(LOF(1), " ")
    Get #1, 1, XString
    Pos = InStr(1, XString, "overall compatibility", vbBinaryCompare)
    RetOCompat = Val(Trim$(Mid$(XString, Pos + 21, 9)))
    Pos = InStr(1, XString, "matrix was", vbBinaryCompare)
    RetNSS = Val(Trim$(Mid$(XString, Pos + 10, 9)))
    Pos = InStr(1, XString, "for random matrices", vbBinaryCompare)
    RetRndNSS = Val(Trim$(Mid$(XString, Pos + 19, 9)))
    Pos = InStr(1, XString, "P value is", vbBinaryCompare)
    RetPVal = Val(Trim$(Mid$(XString, Pos + 10, 9)))
    Close #1
    'Read file containing informative site data
    Open "out.sit" For Input As 1
    On Error Resume Next
    Line Input #1, tempstring

    If Len(tempstring) > 80 Then
        Close #1
        Open "out.sit" For Binary Access Read As #1
        tempstring = String$(LOF(1), " ")
        Get #1, , tempstring
        Close #1
        LastPos = 1

        Do
            Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 2
                Variab = Asc(Mid$(tempstring, 7, 1))
            Else
                Exit Do
            End If

        Loop

        Open "out.sit" For Output As #1
        SaveFlag = 1
        Print #1, tempstring
        Close #1
        Open "out.sit" For Input As #1
    End If

    Do
        Line Input #1, VString

        If left$(VString, 8) = "Sequence" Then Exit Do
    Loop While Not EOF(1)

    Line Input #1, VString
    Line Input #1, VString
    ReDim RetXPos(LSeq)
    ReDim RetYPos(LSeq)
    X = 0

    Do
        X = X + 1
        Input #1, RetXPos(X)
        Line Input #1, VString
    Loop While VString <> "" And Not EOF(1)

    Close #1
    On Error GoTo 0
    Y = 0

    For X = 0 To LSeq

        If X = RetXPos(Y + 1) Then
            LastIPos = RetXPos(Y)
            Y = Y + 1
            RetYPos(X) = Y
        Else
            RetYPos(X) = Y
        End If

    Next 'X
    
    Open "out.eps" For Binary Access Read As #1
    
    MatLine = ""
    X = LOF(1)
    DCheck = Sqr(X)
    Square = Sqr(X)

    Dim FL As Long

    FL = LOF(1)
    GlobalMemoryStatus MemSit

    If MemSit.dwAvailPhys > LOF(1) Or MemSit.dwTotalPhys > LOF(1) * 3 Then
        
        MatLine = String$(LOF(1), " ")
        Get #1, 1, MatLine
        

        If Len(MatLine) < LOF(1) Then
            Close #1
            Open "out.eps" For Input As 1
        
            FormatFlag = 1

            Dim TStr As String

            Do While Not EOF(1)
                Line Input #1, TStr
                MatLine = MatLine + TStr
            Loop

            Square = InStr(2, MatLine, "x", vbBinaryCompare)
            Square = Square - 2
            Close #1
            Open "out.eps" For Output As 1
            Write #1, MatLine
            Close #1
        End If

    Else
        ErrorFlagX = 1
        Close #1
    End If

    Close #1
    Open "out.eps" For Binary Access Read As 1
    NewString = String$(Square * 4, " ")
    'Exit Sub
    Get #1, 1, NewString
    Pos = InStr(2, MatLine, "x", vbBinaryCompare)
    Pos = InStr(5, MatLine, "x", vbBinaryCompare)
    Close #1
    Form1.Picture26.ScaleMode = 3
    Form1.Picture26.AutoRedraw = True
    Form1.Picture26.BackColor = Form1.BackColor
    Form1.Picture26.DrawMode = 13
    XYFactor = Form1.Picture26.ScaleWidth / Square
    DWidth = Int(Square / Form1.Picture26.ScaleWidth) + 1 'CInt(XYFactor)
    Form1.ScaleMode = 3
    Form1.Picture27.ScaleMode = 3
    Form1.Picture27.Width = Square
    Form1.Picture27.Height = Square
    Form1.Picture27.AutoRedraw = True
    Form1.Picture29.ScaleMode = 3

    If Square > Form1.Picture26.ScaleWidth And ErrorFlagX = 0 Then
        Form1.ScaleMode = 3
        PWid = Form1.Picture26.ScaleWidth

        If ErrorFlagX <> 1 Then
            Form1.Picture28(0).AutoRedraw = True
            Dummy = DrawMatrix(Form1.Picture28(0).hdc, PWid, Y, DWidth - 1, Square, MatLine)
            Form1.Picture26.Picture = Form1.Picture28(0).Image
            Form1.Picture26.Refresh
            Form1.ProgressBar1.Value = 50

            Call DrawBigMatrix

            Form1.ProgressBar1.Value = 80
            MatLine = ""

            If FormatFlag = 0 Then
                Open "rnd.eps" For Binary Access Read As 1
                On Error Resume Next
                XString = String$(LOF(1), " ")
                Get #1, 1, XString
                On Error GoTo 0
                Close #1
            Else
                On Error Resume Next
                Open "rnd.eps" For Input As 1
                FL = 0
                FL = LOF(1)

                If FL > 10 Then
                    XString = ""

                    Do While Not EOF(1)
                        Line Input #1, TStr
                        XString = XString + TStr
                    Loop

                    Close #1
                Else
                    Close #1
                    Form1.SSPanel1.Caption = ""
                    Form1.ProgressBar1.Value = 0
                    Screen.MousePointer = 0
                    'Form1.Command5.Enabled = True
                    Form1.Command10.Enabled = False
                    Exit Sub
                End If

            End If

            If XString = "" Then
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Screen.MousePointer = 0
                'Form1.Command5.Enabled = True
                Form1.Command10.Enabled = False
                ErrorFlagX = 1
                Exit Sub
            End If

            PWid = Form1.Picture28(1).ScaleWidth
            Dummy = DrawMatrix(Form1.Picture28(1).hdc, PWid, Y, DWidth - 1, Square, XString) '
            Form1.ScaleMode = 1
            XString = ""
        End If

    ElseIf ErrorFlagX = 0 Then
        Form1.ScaleMode = 3
        Form1.Picture28(1).AutoRedraw = True
        Open "rnd.eps" For Binary Access Read As 1
        XString = String$(LOF(1), " ")
        Get #1, 1, XString
        Close #1
        Dummy = DrawMatrixB(Form1.Picture27.hdc, PWid, Y, DWidth - 1, Square, XString)
        Form1.Picture28(1).PaintPicture Form1.Picture27.Image, 0, 0, Form1.Picture26.ScaleWidth, Form1.Picture26.ScaleHeight, 0, 0, Form1.Picture27.ScaleHeight, Form1.Picture27.ScaleWidth
        XString = ""
        XYFactor = Form1.Picture26.ScaleWidth / Square
        Dummy = DrawMatrixB(Form1.Picture27.hdc, PWid, Y, DWidth - 1, Square, MatLine)
        Form1.Picture26.PaintPicture Form1.Picture27.Image, 0, 0, Form1.Picture26.Width, Form1.Picture26.Height, 0, 0, Form1.Picture27.Height, Form1.Picture27.Width
        'StretchBlt Form1.Picture26.hdc, 0, 0, Form1.Picture26.ScaleWidth, Form1.Picture26.ScaleHeight, Form1.Picture28(0).hdc, 0, 0, Form1.Picture28(0).ScaleWidth, Form1.Picture28(0).ScaleHeight, &HCC0020
        Form1.Picture28(0).Picture = Form1.Picture26.Image
        'Form1.Picture28(0).Picture = Form1.Picture26.Image
        Form1.ScaleMode = 1
        Form1.Command5.Enabled = True
    End If

    Form1.ProgressBar1.Value = 75
    MatLine = ""
    Form1.ProgressBar1.Value = 90

    If ErrorFlagX = 1 Then
        'Set m_dc = New CMemoryDC
        'Set m_dc.Picture = Form1.Picture26.Picture
        Open "out.eps" For Binary As 1 Len = 10 + ((Square) * 2)
        'On Error Resume Next
        ReDim Matrix(Square, DWidth)
        'End If
        CPos = 1
        Pic = Form1.Picture26.hdc

        For Y = 0 To Square - (DWidth - 1) Step DWidth - 1
            Get #1, CPos, Matrix()
            CPos = CPos + Square * (DWidth - 1)
            EY = Square - 1 - (DWidth - 1)

            For X = Y + 1 To EY Step DWidth - 1
                MatArray = 0

                For A = 0 To DWidth - 1

                    For B = 0 To DWidth - 1

                        If Matrix(X + A, B) = 105 Then
                            MatArray = MatArray + 255
                            'ElseIf Matrix(X + a, Y + B) <> 109 Then
                            '    MatArray(X, Y) = MatArray(X, Y) + 196
                        End If

                    Next 'B

                Next 'A

                MatArray = MatArray / (DWidth * DWidth)
                SetPixelV Pic, X * XYFactor, Y * XYFactor, MatArray * 65793
                SetPixelV Pic, Y * XYFactor, X * XYFactor, MatArray * 65793
            Next 'X

        Next 'Y

        Close #1
        Open "rnd.eps" For Binary As 1 Len = 10 + ((Square) * 2)
        'On Error Resume Next
        ReDim Matrix(Square, DWidth)
        'End If
        CPos = 1
        Form1.Picture28(1).AutoRedraw = True
        Pic = Form1.Picture28(1).hdc

        Dim DimW As Long, SL As Integer

        DimW = Square - (DWidth - 1)
        SL = DWidth - 1

        For Y = 0 To DimW Step SL
            Get #1, CPos, Matrix()
            CPos = CPos + (DWidth - 1) * Square

            For X = Y + 1 To DimW Step SL
                MatArray = 0

                For A = 0 To SL

                    For B = 0 To SL

                        If Matrix(X + A, B) = 105 Then
                            MatArray = MatArray + 255
                            'ElseIf Matrix(X + a, Y + B) <> 109 Then
                            '    MatArray(X, Y) = MatArray(X, Y) + 196
                        End If

                    Next 'B

                Next 'A

                MatArray = MatArray / (DWidth * DWidth)
                SetPixelV Pic, X * XYFactor, Y * XYFactor, MatArray * 65793
                SetPixelV Pic, Y * XYFactor, X * XYFactor, MatArray * 65793
            Next 'X

        Next 'Y

        Close #1
        Form1.Picture28(0).AutoRedraw = True
        Form1.Picture28(0).Picture = Form1.Picture26.Image
    End If

    Form1.Picture26.Refresh
    'form1.picture26.Refresh

    If ErrorFlagX = 1 Then
        Form1.Picture26.ZOrder
        Form1.ScaleMode = 3
        Form1.Picture27.ScaleMode = 3
        Form1.Picture27.Width = Square
        Form1.Picture27.Height = Square
        Form1.Picture27.AutoRedraw = True
        Open "out.eps" For Binary As 1 Len = 10 + ((Square) * 2)
        ReDim Matrix(Square - 1)
        Pic = Form1.Picture27.hdc

        For Y = 0 To Square
            Get #1, , Matrix()

            For X = Y + 1 To Square - 1

                If Matrix(X) = 105 Then
                    SetPixelV Pic, X, Y, 255 * 65793
                    SetPixelV Pic, Y, X, 255 * 65793
                Else
                    SetPixelV Pic, X, Y, 0
                    SetPixelV Pic, Y, X, 0
                End If

            Next 'X

            Form1.ProgressBar1.Value = 70 + (Y / Square) * 30
        Next 'Y

        Close #1
    End If

    'Call StartReticulateB(0)
    Form1.ProgressBar1.Value = 100
    'Form1.Picture27.Visible = True
    'form1.picture27.Paintform1.picture form1.picture26.Image, 0, 0, form1.picture27.Width, form1.picture27.Height, 0, 0, form1.picture26.Width, form1.picture26.Height
    Form1.Picture27.Refresh
    ChDir ODir$
    ChDrive ODir$
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Screen.MousePointer = 0
    RETFlag = 3
    
    'Form1.Command5.Enabled = True
    Form1.Command10.Enabled = True
End Sub
Public Sub DrawBigMatrix()

    Dim ImgDC As Long  'DC handle
    Dim ImgDIB As Long 'DIB handle
    Dim OldDIB As Long 'Old DIB handle
    Dim X As Long, Y As Long
    Dim ScanLine As Long 'Number of bytes per line of bitmap data
    Dim ImgInfo As BITMAPINFO
    Dim ImgData() As Byte 'Image data

    'Create DC
    
    'Test for null return
    On Error GoTo BigProb
    ImgDC = CreateCompatibleDC(Form1.Picture27.hdc)
    On Error GoTo 0
    
    If ImgDC = 0 Then
        MsgBox "Error creating DC", vbCritical, App.Title
        GoTo BigProb
    End If

    'Set up drawing surface and create DIB

    With Form1.Picture27
        .ScaleMode = vbPixels
        .AutoRedraw = True
        ImgDIB = CreateCompatibleBitmap( _
           .hdc, .ScaleWidth, .ScaleHeight)
    End With

    'Test for null return

    If ImgDIB = 0 Then
        MsgBox "Error creating DIB", vbCritical, App.Title
        DeleteDC ImgDC
        Exit Sub
    End If

    'Bind DIB to DC
    OldDIB = SelectObject(ImgDC, ImgDIB)
    'Test for null return

    If OldDIB = 0 Then
        MsgBox "Error binding DIB", vbCritical, App.Title
        DeleteObject ImgDIB
        DeleteDC ImgDC
        Exit Sub
    End If

    'Set some information about the image

    With ImgInfo.bmiHeader
        .biBitCount = 8
        .biClrImportant = 256
        .biClrUsed = 256
        .biHeight = Form1.Picture27.ScaleHeight
        .biWidth = Form1.Picture27.ScaleWidth
        '.biWidth = Square
        .biPlanes = 1
        .biSize = 40
        ScanLine = ((.biWidth + 3) \ 4) * 4
        .biSizeImage = ScanLine * .biHeight
        '.biSizeImage = .biHeight * .biHeight
    End With

    ReDim ImgData(ScanLine - 1, Form1.Picture27.ScaleHeight - 1) As Byte
    'If FormatFlag = 0 Then

    If Form1.Picture27.ScaleHeight = ScanLine Then
        'Make some space in memory for the image data
        Open "out.eps" For Binary Access Read As #1
        Get #1, , ImgData()
        Close #1
    Else
        Open "out.eps" For Binary Access Read As #1
        ReDim Matrix(Form1.Picture27.ScaleHeight - 1, Form1.Picture27.ScaleHeight - 1) As Byte
        Pic = Form1.Picture26.hdc
        Get #1, , Matrix()

        For X = 0 To Square - 1

            For Y = 0 To Square - 1
                ImgData(X, Y) = Matrix(X, Y)
            Next 'Y

        Next 'X

        Close #1
    End If

    'Else
    'End If
    ImgInfo.bmiColors(105).rgbBlue = 255
    ImgInfo.bmiColors(105).rgbGreen = 255
    ImgInfo.bmiColors(105).rgbRed = 255
    ImgInfo.bmiColors(120).rgbBlue = 128
    ImgInfo.bmiColors(120).rgbGreen = 128
    ImgInfo.bmiColors(120).rgbRed = 128

    If SetDIBits(ImgDC, ImgDIB, 0, Form1.Picture27.ScaleHeight, ImgData(0, 0), ImgInfo, 0) = 0 Then MsgBox "Error refreshing image data", vbCritical, App.Title
    'Draw to screen

    With Form1.Picture27
        ' BitBlt .hdc, 0, 0, .ScaleWidth, _
        '     .ScaleHeight, ImgDC, 0, 0, vbSrcCopy
        StretchBlt .hdc, 0, .ScaleHeight, .ScaleWidth, -.ScaleHeight, ImgDC, 0, 0, .ScaleWidth, .ScaleHeight, vbSrcCopy
        .Refresh
    End With

    SelectObject ImgDC, OldDIB 'De-select DIB
    DeleteObject ImgDIB 'Destroy DIB
    DeleteDC ImgDC 'Destroy DC
    Form1.Command5.Enabled = True
    Form4.ScaleMode = 3
    Form4.Picture3.ScaleMode = 3
    Form4.Picture3.Width = Square
    Form4.Picture3.Height = Square
    
    BitBlt Form4.Picture3.hdc, 0, 0, Square, Square, Form1.Picture27.hdc, 0, 1, &HCC0020
    Form4.ScaleMode = 1
    Exit Sub

BigProb:
    Form1.Command5.Enabled = False
    
    
End Sub
Public Sub SaveMatrixTxt()

    With Form1.CommonDialog1
        .filename = ""
        .DefaultExt = ".csv"   'Specify the default extension.
        'Specify which file extensions will be preferred.
        '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
        .Filter = "CSV File (*.csv)|*.csv"
        .Action = 2 'Specify that the "open file" action is required.
        matrixname$ = .filename  'Stores selected file name in the
        SBMPnameII = .FileTitle
    End With

    If matrixname$ = "" Then Screen.MousePointer = 0: Exit Sub
    Screen.MousePointer = 11

    Dim Matrix() As Byte

    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    Open "out.eps" For Binary Access Read As #1
    ReDim Matrix(Form1.Picture27.ScaleHeight - 1, Form1.Picture27.ScaleHeight - 1) As Byte
    Get #1, , Matrix()
    Close #1
    ChDir ODir$
    ChDrive ODir$
    Open matrixname$ For Output As #1

    Dim OString As String

    OString = ","

    For X = 0 To Square - 2
        OString = OString + Trim$(CStr(RetXPos(X + 1))) + ","
    Next 'X

    OString = OString + Trim$(CStr(RetXPos(X + 1)))
    Print #1, OString

    For Y = 0 To Square - 1
        OString = Trim$(CStr(RetXPos(Y + 1))) + ","

        For X = 0 To Square - 2

            If Matrix(X, Y) = 105 Then
                OString = OString + "0,"
            ElseIf Matrix(X, Y) = 109 Then
                OString = OString + "1,"
            Else
                OString = OString + ","
            End If

        Next 'X

        If Matrix(X, Y) = 105 Then
            OString = OString + "0"
        ElseIf Matrix(X, Y) = 109 Then
            OString = OString + "1"
        End If

        Print #1, OString
    Next 'Y

    Close #1
    Screen.MousePointer = 0
End Sub
Public Sub WriteNames(S1, S2, S3, c1, c2, c3)

    Dim LOSpace As Integer, YPos As Integer, TotLen As Integer, L1 As Integer, L2 As Integer, L3 As Integer, DrawLen As Integer, XPos1 As Integer, XPos2 As Integer, XPos3 As Integer
    Dim OFontSize As Double

    OFontSize = Form1.Picture7.FontSize
    L1 = Form1.Picture7.TextWidth(StraiName(S1) + " - " + StraiName(S2))
    L2 = Form1.Picture7.TextWidth(StraiName(S1) + " - " + StraiName(S3))
    L3 = Form1.Picture7.TextWidth(StraiName(S2) + " - " + StraiName(S3))
    DrawLen = Form1.Picture7.ScaleWidth - 30
    TotLen = L1 + L2 + L3

    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    Else

        Do Until TotLen < DrawLen
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            L1 = Form1.Picture7.TextWidth(StraiName(S1) + " - " + StraiName(S2))
            L2 = Form1.Picture7.TextWidth(StraiName(S1) + " - " + StraiName(S3))
            L3 = Form1.Picture7.TextWidth(StraiName(S2) + " - " + StraiName(S3))
            TotLen = L1 + L2 + L3
        Loop

        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    End If

    YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S2)
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S3)
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(S2) & " - " & StraiName(S3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S2)
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S3)
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(S2) & " - " & StraiName(S3)
    Form1.Picture7.CurrentX = XPos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c1
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S2)
    Form1.Picture7.CurrentX = XPos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c2
    Form1.Picture7.Print StraiName(S1) & " - " & StraiName(S3)
    Form1.Picture7.CurrentX = XPos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c3
    Form1.Picture7.Print StraiName(S2) & " - " & StraiName(S3)
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
End Sub
Public Sub SeqCols()
    ReDim IDCount(Len(StrainSeq(0)) + 200, 4)
    ReDim Identical(Len(StrainSeq(0)) + 200)
    ReDim SeqColRef(Len(StrainSeq(0)) + 200, NextNo)
    ReDim ColDist(Len(StrainSeq(0)) + 200, NextNo)
    ReDim SiteHomol(Len(StrainSeq(0)) + 200)

    Dim Col As Integer
    Dim X As Long, Y As Long, Z As Long, SY As Long, EY As Long, LSeq
    Dim NumReplace As Long
    Dim Tot As Long

    Startval = Form1.ProgressBar1.Value
    Varsites = 0
    LSeq = Len(StrainSeq(0))
    Dummy = GetSiteHomol(LSeq + 1, NextNo, SeqNum(0, 0), IDCount(0, 0), SiteHomol(0))
    NumReplace = 0

    For X = 1 To LSeq

        If IDCount(X, 0) = NextNo + 1 Or IDCount(X, 1) = NextNo + 1 Or IDCount(X, 2) = NextNo + 1 Or IDCount(X, 3) = NextNo + 1 Then
            Identical(X) = 1
        Else
            Varsites = Varsites + 1
            'Check for strange characters in this column
            'IDCount(X, 4) = Nextno + 1 - IDCount(X, 0) - IDCount(X, 1) - IDCount(X, 2) - IDCount(X, 3)
            If IDCount(X, 4) > 0 Then
                EY = IDCount(X, 4) - 1

                For Z = 0 To EY
                    'TString = Mid$(StrainSeq(Z), X, 1)

                    If SeqNum(X, Z) <> 66 And SeqNum(X, Z) <> 68 And SeqNum(X, Z) <> 72 And SeqNum(X, Z) <> 85 And SeqNum(X, Z) <> 46 Then
                        Mid$(StrainSeq(Z), X, 1) = "-"
                        SeqNum(X, Z) = 46
                        NumReplace = NumReplace + 1
                    End If

                Next 'Z

            End If
            Col = 0
            If IDCount(X, 0) >= IDCount(X, 1) And IDCount(X, 0) >= IDCount(X, 2) And IDCount(X, 0) >= IDCount(X, 3) Then

                If IDCount(X, 0) / (NextNo + 1) > 0.75 Then
                    Col = 1
                ElseIf IDCount(X, 0) / (NextNo + 1) > 0.5 Then
                    Col = 2
                ElseIf IDCount(X, 0) / (NextNo + 1) >= 0.25 Then
                    Col = 3
                End If

                Tot = 0

                For Y = 0 To NextNo

                    If SeqNum(X, Y) = 66 Then
                        SeqColRef(X, Y) = Col
                        Tot = 1

                        If Y < NextNo Then
                            Z = Y + 1

                            Do

                                If SeqNum(X, Z) = 66 Then
                                    Tot = Tot + 1
                                    Z = Z + 1

                                    If Z > NextNo Then
                                        ColDist(X, Y) = Tot
                                        Y = Z
                                        Exit Do
                                    End If

                                Else
                                    ColDist(X, Y) = Tot
                                    Y = Z
                                    Exit Do
                                End If

                            Loop

                        Else
                            ColDist(X, Y) = 1
                        End If

                    End If

                Next 'Y

            ElseIf IDCount(X, 1) >= IDCount(X, 0) And IDCount(X, 1) >= IDCount(X, 2) And IDCount(X, 1) >= IDCount(X, 3) Then

                If IDCount(X, 1) / (NextNo + 1) > 0.75 Then
                    Col = 1
                ElseIf IDCount(X, 1) / (NextNo + 1) > 0.5 Then
                    Col = 2
                ElseIf IDCount(X, 1) / (NextNo + 1) >= 0.25 Then
                    Col = 3
                End If

                For Y = 0 To NextNo

                    If SeqNum(X, Y) = 68 Then
                        SeqColRef(X, Y) = Col
                        Tot = 1

                        If Y < NextNo Then
                            Z = Y + 1

                            Do

                                If SeqNum(X, Z) = 68 Then
                                    Tot = Tot + 1
                                    Z = Z + 1

                                    If Z > NextNo Then
                                        ColDist(X, Y) = Tot
                                        Y = Z
                                        Exit Do
                                    End If

                                Else
                                    ColDist(X, Y) = Tot
                                    Y = Z
                                    Exit Do
                                End If

                            Loop

                        Else
                            ColDist(X, Y) = 1
                        End If

                    End If

                Next 'Y

            ElseIf IDCount(X, 2) >= IDCount(X, 0) And IDCount(X, 2) >= IDCount(X, 1) And IDCount(X, 2) >= IDCount(X, 3) Then
                
                If IDCount(X, 2) / (NextNo + 1) > 0.75 Then
                    Col = 1
                ElseIf IDCount(X, 2) / (NextNo + 1) > 0.5 Then
                    Col = 2
                ElseIf IDCount(X, 2) / (NextNo + 1) >= 0.25 Then
                    Col = 3
                End If

                For Y = 0 To NextNo

                    If SeqNum(X, Y) = 72 Then
                        SeqColRef(X, Y) = Col
                        Tot = 1

                        If Y < NextNo Then
                            Z = Y + 1

                            Do

                                If SeqNum(X, Z) = 72 Then
                                    Tot = Tot + 1
                                    Z = Z + 1

                                    If Z > NextNo Then
                                        ColDist(X, Y) = Tot
                                        Y = Z
                                        Exit Do
                                    End If

                                Else
                                    ColDist(X, Y) = Tot
                                    Y = Z
                                    Exit Do
                                End If

                            Loop

                        Else
                            ColDist(X, Y) = 1
                        End If

                    End If

                Next 'Y

            ElseIf IDCount(X, 3) >= IDCount(X, 0) And IDCount(X, 3) >= IDCount(X, 1) And IDCount(X, 3) >= IDCount(X, 2) Then

                If IDCount(X, 3) / (NextNo + 1) > 0.75 Then
                    Col = 1
                ElseIf IDCount(X, 3) / (NextNo + 1) > 0.5 Then
                    Col = 2
                ElseIf IDCount(X, 3) / (NextNo + 1) >= 0.25 Then
                    Col = 3
                End If

                For Y = 0 To NextNo

                    If SeqNum(X, Y) = 85 Then
                        SeqColRef(X, Y) = Col
                        Tot = 1

                        If Y < NextNo Then
                            Z = Y + 1

                            Do

                                If SeqNum(X, Z) = 85 Then
                                    Tot = Tot + 1
                                    Z = Z + 1

                                    If Z > NextNo Then
                                        ColDist(X, Y) = Tot
                                        Y = Z
                                        Exit Do
                                    End If

                                Else
                                    ColDist(X, Y) = Tot
                                    Y = Z
                                    Exit Do
                                End If

                            Loop

                        Else
                            ColDist(X, Y) = 1
                        End If

                    End If

                Next 'Y

            End If

        End If

        If X / Int(LSeq / 10) = Int(X / Int(LSeq / 10)) Then
            Form1.ProgressBar1.Value = X / LSeq * 100
        End If

    Next 'X

End Sub
Public Sub RXoverB()
    Exit Sub
    If RETFlag = 0 Then
        Response = MsgBox("There is a reasonable chance that Reticulate will take a very long time to analyse the currently loaded alignment.  This is because this computer does not have enough physical memory to properly handle the compatibility matrix that reticulate will generate.  Memory shortages may compromise the performance of RDP and/or other currently running programs (including windows itself)." & Chr$(13) & Chr$(10) & Chr$(13) & Chr$(10) & "Would you still like to analyse these sequences using reticulate?", 36, "RDP Warning")

        If Response = 7 Then Exit Sub
        Call StartReticulate
        Form1.Command13(1).Enabled = True
        Form1.Command8(1).Enabled = True
    End If
    Dim ODir As String
    Dim Z As Long, B As Long

    Form1.ProgressBar1 = 10
    Form1.Command29.Enabled = False

    If RETFlag = 1 Then Call WriteMatrix
    Form1.SSPanel1.Caption = "Executing Reticulate"
    Form1.Command25.Enabled = True
    Do
        
        If RETFlag = 3 Then Exit Do
        DoEvents
        If AbortFlag = 1 Then
            Form1.SSPanel1.Caption = ""
            Exit Sub
        End If
        Sleep (100)
    Loop

    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path

    Dim RWinLen As Long

    'Dim MaxWhite As Double'
    'Dim MinWhite As Double

    Dim Startx As Integer
    Dim Endx As Integer
    Dim Matrix() As Byte
    Dim RowArray() As Double
    Dim Cnt As Long, Y As Long, X As Long

    Open "out.eps" For Binary As 1 Len = 10 + ((Square) * 2)
    ReDim Matrix(Square, Square)
    Get #1, , Matrix()
    Close #1
    ReDim RowArray(Square)

    For Y = 0 To Square
        Cnt = 0

        For X = RetYPos(XOverList(RelX, RelY).Beginning) To RetYPos(XOverList(RelX, RelY).Ending)

            If Matrix(X, Y) = 105 Then
                Cnt = Cnt + 1
                RowArray(Y) = RowArray(Y) + 1
            ElseIf Matrix(X, Y) = 109 Then
                Cnt = Cnt + 1
            End If

        Next 'X

        If Cnt > 0 Then
            RowArray(Y) = RowArray(Y) / Cnt
        Else
            EndY = Y - 1
            Y = Square
        End If

    Next 'Y

    If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
        RWinLen = RetYPos(XOverList(RelX, RelY).Ending) - RetYPos(XOverList(RelX, RelY).Beginning)
    Else
        RWinLen = RetYPos(XOverList(RelX, RelY).Ending) + (RetYPos(Len(StrainSeq(0))) - RetYPos(XOverList(RelX, RelY).Beginning))
    End If

    RWinLen = CInt(RWinLen / 2)
    Form1.ProgressBar1 = 20
    ReDim RetPlot(10, Square)
    MinWhite = 1
    MaxWhite = 0
    Y = 0
    Startx = Y - RWinLen
    Endx = Y + RWinLen

    For X = Startx To Endx
        Cnt = Cnt + 1

        If X >= 0 And X <= EndY Then
            RetPlot(0, Y) = RetPlot(0, Y) + RowArray(X)
        ElseIf X < 0 Then

            If EndY + X >= 0 Then
                RetPlot(0, Y) = RetPlot(0, Y) + RowArray(EndY + X)
            End If

        Else

            If X - EndY >= 0 Then
                RetPlot(0, Y) = RetPlot(0, Y) + RowArray(X - EndY)
            End If

        End If

    Next 'X

    'RWinLen = RWinLen * 2 + 1
    X = Startx + 1
    Z = Endx + 1

    For Y = 1 To EndY
        Cnt = 0

        If X >= 0 And X <= EndY Then
            RetPlot(0, Y) = RetPlot(0, Y - 1) - RowArray(X)
        ElseIf X < 0 Then
            RetPlot(0, Y) = RetPlot(0, Y - 1) - RowArray(EndY + X)
        Else
            RetPlot(0, Y) = RetPlot(0, Y - 1) - RowArray(X - EndY)
        End If

        X = X + 1

        If Z >= 0 And Z <= EndY Then
            RetPlot(0, Y) = RetPlot(0, Y) + RowArray(Z)
        ElseIf Z < 0 Then
            RetPlot(0, Y) = RetPlot(0, Y) + RowArray(EndY + Z)
        Else
            RetPlot(0, Y) = RetPlot(0, Y) + RowArray(Z - EndY)
        End If

        Z = Z + 1
        RetPlot(0, Y - 1) = RetPlot(0, Y - 1) / (Z - X)

        If RetPlot(0, Y - 1) > MaxWhite Then MaxWhite = RetPlot(0, Y - 1)

        If RetPlot(0, Y - 1) < MinWhite Then MinWhite = RetPlot(0, Y - 1)
    Next 'Y

    Form1.ProgressBar1 = 30
    RetPlot(0, Y - 1) = RetPlot(0, Y - 1) / (Z - X)
    Open "rnd.eps" For Binary As 1 Len = 10 + ((Square) * 2)
    ReDim Matrix(Square, Square)
    Get #1, , Matrix()
    Close #1
    ChDir ODir$
    ChDrive ODir$

    Dim Strt As Integer
    Dim ND As Integer
    Dim Step As Integer

    Form1.ProgressBar1 = 40

    For B = 1 To 10
        ReDim RowArray(Square)
        Step = (Square - (RetYPos(XOverList(RelX, RelY).Ending) - RetYPos(XOverList(RelX, RelY).Beginning))) / 10

        For Y = 0 To Square
            Cnt = 0
            Strt = (B - 1) * Step
            ND = (B - 1) * Step + (RetYPos(XOverList(RelX, RelY).Ending) - RetYPos(XOverList(RelX, RelY).Beginning))

            For X = Strt To ND
                'Exit Sub

                If Matrix(X, Y) = 105 Then
                    Cnt = Cnt + 1
                    RowArray(Y) = RowArray(Y) + 1
                ElseIf Matrix(X, Y) = 109 Then
                    Cnt = Cnt + 1
                End If

            Next 'X

            If Cnt > 0 Then
                RowArray(Y) = RowArray(Y) / Cnt
            Else
                EndY = Y - 1
                'Exit Sub
                Y = Square
            End If

        Next 'Y

        Y = 0
        Startx = Y - RWinLen
        Endx = Y + RWinLen

        For X = Startx To Endx
            Cnt = Cnt + 1

            If X >= 0 And X <= EndY Then
                RetPlot(B, Y) = RetPlot(B, Y) + RowArray(X)
            ElseIf X < 0 Then

                If EndY + X >= 0 Then
                    RetPlot(B, Y) = RetPlot(B, Y) + RowArray(EndY + X)
                End If

            Else
                RetPlot(B, Y) = RetPlot(B, Y) + RowArray(X - EndY)
            End If

        Next 'X

        'RWinLen = RWinLen * 2 + 1
        X = Startx + 1
        Z = Endx + 1

        For Y = 1 To EndY
            Cnt = 0

            If X >= 0 And X <= EndY Then
                RetPlot(B, Y) = RetPlot(B, Y - 1) - RowArray(X)
            ElseIf X < 0 Then
                RetPlot(B, Y) = RetPlot(B, Y - 1) - RowArray(EndY + X)
            Else
                RetPlot(B, Y) = RetPlot(B, Y - 1) - RowArray(X - EndY)
            End If

            X = X + 1

            If Z >= 0 And Z <= EndY Then
                RetPlot(B, Y) = RetPlot(B, Y) + RowArray(Z)
            ElseIf Z < 0 Then
                RetPlot(B, Y) = RetPlot(B, Y) + RowArray(EndY + Z)
            Else
                RetPlot(B, Y) = RetPlot(B, Y) + RowArray(Z - EndY)
            End If

            Z = Z + 1
            RetPlot(B, Y - 1) = RetPlot(B, Y - 1) / (Z - X)

            If RetPlot(B, Y - 1) > MaxWhite Then MaxWhite = RetPlot(B, Y - 1)

            If RetPlot(B, Y - 1) < MinWhite Then MinWhite = RetPlot(B, Y - 1)
        Next 'Y

        Form1.ProgressBar1.Value = 40 + B / 10 * 50
    Next 'B

    ' Form1.ProgressBar1 = 80
    For X = 1 To Len(StrainSeq(0))
        If RetXPos(X) = 0 Then Exit For
        XDiffpos(X) = RetXPos(X)
    Next 'X
    LenXOverSeq = X - 1
    
    Call DoAxes(Len(StrainSeq(0)), -1, MaxWhite, MinWhite, 1, "Whiteness")

    Dim PntAPI As POINTAPI

    'Form1.Picture7.Picture = LoadPicture()
    Form1.Picture7.ForeColor = RGB(180, 180, 180)
    Form1.Picture7.DrawWidth = 3
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + RetXPos(0) * XFactor, PicHeight - (15 + (RetPlot(0, 0) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)), PntAPI)

    For X = 1 To EndY
        Dummy = LineTo(Form1.Picture7.hdc, 30 + RetXPos(X) * XFactor, PicHeight - (15 + (RetPlot(0, X) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)))
    Next 'X

    Form1.Picture7.DrawWidth = 1

    Dim Offst As Integer

    For B = 1 To 10
        Offst = (10 - B) * Step
        Form1.Picture7.ForeColor = RGB(164, 164, 164)
        Dummy = MoveToEx(Form1.Picture7.hdc, 30 + RetXPos(0 + Offst) * XFactor, PicHeight - (15 + (RetPlot(B, 0) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)), PntAPI)
        ' Exit Sub

        For X = 1 To EndY - 1

            If X + Offst > EndY - 1 Then
                Z = X + Offst - EndY

                If Z = 0 Then
                    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + RetXPos(Z) * XFactor, PicHeight - (15 + (RetPlot(B, X) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)), PntAPI)
                End If

            Else
                Z = X + Offst
            End If

            Dummy = LineTo(Form1.Picture7.hdc, 30 + RetXPos(Z) * XFactor, PicHeight - (15 + (RetPlot(B, X) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)))
            'Exit Sub
        Next 'X

    Next 'B

    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + RetXPos(0) * XFactor, PicHeight - (15 + (RetPlot(0, 0) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)), PntAPI)

    For X = 1 To EndY
        Dummy = LineTo(Form1.Picture7.hdc, 30 + RetXPos(X) * XFactor, PicHeight - (15 + (RetPlot(0, X) - MinWhite) / (MaxWhite - MinWhite) * (PicHeight - 35)))
    Next 'X

    Call Highlight

    Form1.Picture7.Enabled = True
    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.Picture7.Refresh
    Form1.SSPanel1.Caption = ""
End Sub

Public Sub RecombMap()

    Dim LP As Double
    
    Dim ENumb As Long
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    'If MCFlag = 1 Or MCFlag = 2 Then
        LP = -Log10(LowestProb)
    'ElseIf MCFlag = 0 Then
    '    LP = -Log10(LowestProb / MCCorrection)
    'End If
    
    PPMax = 1
    For X = 1 To ENumb
        If (BestEvent(X, 0) > 0 Or BestEvent(X, 1) > 0) And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability > 0 And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Accept < 2 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber
            Else
                SEN = SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            
            If CNum > ConsensusProg Then
                If XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability < PPMax And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability > 0 Then
                    PPMax = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability
                End If
            End If
        End If
    Next X
    
    PPMax = -Log10(PPMax)
    MinPVal = PPMax
    DoAxes Len(StrainSeq(0)), -1, PPMax, LP, 0, "-Log(P-Val)"
    
    
    Dim DistCol As Long
                   
                
    CurPPos = 0
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    HFactor = (Form1.Picture7.Height - 75)
    TOffset = 20
    Dim PntAPI As POINTAPI
    For Z = 1 To ENumb
        
        X = BestEvent(Z, 0)
        Y = BestEvent(Z, 1)
        'If X = 54 And Y = 1 Then
        '    X = X
        'End If
        GoOn = 1
        
        If (X > 0 Or Y > 0) And XOverList(X, Y).Probability > 0 And XOverList(X, Y).Accept < 2 Then 'Or XOverList(X, Y).OutsideFlag = 0 And Distance(X, XOverList(X, Y).MinorP) < Distance(X, XOverList(X, Y).MajorP) Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XOverList(X, Y).Eventnumber
            Else
                SEN = SuperEventlist(XOverList(X, Y).Eventnumber)
            End If
            
            For A = 0 To AddNum - 1
                If Confirm(SEN, A) > 0 Then
                    CNum = CNum + 1
                End If
            Next A
            
            If CNum > ConsensusProg Then
                BE = XOverList(X, Y).Beginning
                EN = XOverList(X, Y).Ending
                PV = -Log10(XOverList(X, Y).Probability)
                If PV > LP Then
                    MDist = Distance(XOverList(X, Y).MinorP, XOverList(X, Y).MajorP)
                    DistCol = Int(((MDist - MinDistSch) / (MaxDistSch - MinDistSch)) * 768)
                            
                    Call DistColour(DistCol)
                    'DistCol = 0
                    Form1.Picture7.ForeColor = DistCol
                    MhDC = Form1.Picture7.hdc
                    If BE < EN Then
                        MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                        LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                        LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                    Else
                        MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                        LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                        LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + 1 * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                        
                        MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                        LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                        LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
                        LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                    End If
                End If
            End If
        End If
                    
    Next Z
    Form1.Picture7.Refresh
End Sub
Public Sub RecombMapII()
    Dim RecMap() As Long, SEN As Long
    ReDim RecMap(Len(StrainSeq(0)))
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    B = 0
    C = 0
    NextNo = NextNo
    For X = 1 To ENumb
        
        
        If (BestEvent(X, 0) > 0 Or BestEvent(X, 1) > 0) And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability > 0 And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Accept < 2 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber
            Else
                SEN = SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            
            If CNum > ConsensusProg Then
                ST = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Beginning
                EN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Ending
                If ST < EN Then
                    For Y = ST To EN
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                Else
                    For Y = ST To Len(StrainSeq(0))
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                    For Y = 1 To EN
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                End If
                C = C + 1
            End If
        ElseIf XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability = 0 Then
            B = B + 1
        End If
    
        
    Next X
    PPMax = 0
    For X = 1 To Len(StrainSeq(0))
        If RecMap(X) > PPMax Then PPMax = RecMap(X)
    Next X
    
    MinPVal = PPMax
    MCMinChiP = PPMax
    DoAxes Len(StrainSeq(0)), -1, PPMax, 0, 0, "Number of events"
    
    
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    HFactor = (Form1.Picture7.Height - 75)
    TOffset = 20
    Dim PntAPI As POINTAPI
    Form1.Picture7.ForeColor = 0
    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(Len(StrainSeq(0)))
    For Z = 1 To Len(StrainSeq(0))
        MCPrintData(Z) = RecMap(Z)
        MCPrintPos(Z) = Z
    Next Z
    MhDC = Form1.Picture7.hdc
    
    MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMap(1)) / (PPMax)) * HFactor, PntAPI
    'Exit Sub
    For Z = 2 To Len(StrainSeq(0))
    
        MhDC = Form1.Picture7.hdc
        LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - RecMap(Z) / PPMax) * HFactor
    Next Z
    Form1.Picture7.Refresh
End Sub
Public Sub RecombMapIII()
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double, Win As Long
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Dim PermutationX As Long
    
    PermutationX = MatPermNo
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), pCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For X = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(X, Y) = LowestProb
        Next Y
    Next X
    
    For X = 0 To NextNo
            For Y = 1 To CurrentXover(X)
                If XOverList(X, Y).ProgramFlag <= AddNum - 1 Then
                    If BPV(SuperEventlist(XOverList(X, Y).Eventnumber), XOverList(X, Y).ProgramFlag) > XOverList(X, Y).Probability And XOverList(X, Y).Probability > 0 Then
                        BPV(SuperEventlist(XOverList(X, Y).Eventnumber), XOverList(X, Y).ProgramFlag) = XOverList(X, Y).Probability
                    End If
                End If
            Next Y
    Next X
    Dim PValCon As Double
    For X = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(X, Y) = LowestProb And Confirm(X, Y) > 0 Then
                
                PValCon = ConfirmP(X, Y) / Confirm(X, Y)
                PValCon = 10 ^ (-PValCon)
                'ConfirmP(X, Y) = PValCon
                If BPV(X, Y) > PValCon Then
                    BPV(X, Y) = PValCon
                End If
            End If
        Next Y
    Next X
    
    
    For X = 0 To NextNo
        For Y = 1 To CurrentXover(X)
            Enu = SuperEventlist(XOverList(X, Y).Eventnumber)
            If Enu = 4 Then
                X = X
            End If
            'If Enu = 3 Then
            '    X = X
            'End If
            NC = 0
            If BPV(Enu, 0) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 1) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 3) < LowestProb Then
                
                NC = NC + 1
                
            ElseIf BPV(Enu, 4) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 2) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 5) < LowestProb Then
                
                NC = NC + 1
                
            End If
            
            If XOverList(X, Y).Probability > 0 And XOverList(X, Y).Probability < LowestProb And NC > ConsensusProg And XOverList(X, Y).Accept <> 2 And XOverList(X, Y).ProgramFlag <= AddNum - 1 And XOverList(X, Y).MissIdentifyFlag <> 3 And XOverList(X, Y).MissIdentifyFlag <> 13 Then
                Excl(Enu) = 1
            Else
                X = X
            End If
        Next Y
    Next X
    For X = 0 To SEventNumber
        XX = Excl(X)
    Next X
    
    Dim BPos() As Long, APos() As Long, TypeSeq
    ReDim APos(Len(StrainSeq(0))), BPos(Len(StrainSeq(0)))
    TypeSeq = TypeSeqNumber
    If TypeSeq > PermNextNo Or TypeSeq < 0 Then TypeSeq = 0
    
    For X = 1 To Len(StrainSeq(0))
        APos(X) = X - SeqSpaces(X, TypeSeq)
        BPos(X - SeqSpaces(X, TypeSeq)) = X
    Next X
    
    Win = MatWinSize
    B = 0
    C = 0
    If BPCvalFlag = 0 Or X = X Then
        BPCvalFlag = 1
        ReDim BPCVal(1, 1)
         Dim DN As Long
        DN = 1
        Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
    End If
    
    zz = 0
    
    'Make exclusions
    
    For X = 1 To ENumb
        If X = 40 Then
            X = X
        End If
        If Excl(X) = 1 And (BestEvent(X, 0) > 0 Or BestEvent(X, 1) > 0) Then
            zz = zz + 1
            CNum = 0
            SEN = X 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
           
            
            If X = X Then
                D = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Daughter
                P1 = XOverList(BestEvent(X, 0), BestEvent(X, 1)).MajorP
                P2 = XOverList(BestEvent(X, 0), BestEvent(X, 1)).MinorP
                ST = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Beginning
                EN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Ending
                If XOverList(BestEvent(X, 0), BestEvent(X, 1)).SBPFlag <> 3 Then
                    If XOverList(BestEvent(X, 0), BestEvent(X, 1)).SBPFlag <> 1 Then
                        Z = ST
                        Size = 1
                        If Z <= ST Then
                            For Y = Z To ST
                                RecMap(Y) = RecMap(Y) + 1 / Size
                                
                            Next Y
                        Else
                            For Y = Z To Len(StrainSeq(0))
                                RecMap(Y) = RecMap(Y) + 1 / Size
                                
                            Next Y
                            For Y = 1 To ST
                                RecMap(Y) = RecMap(Y) + 1 / Size
                            Next Y
                        End If
                        
                    End If
                    If XOverList(BestEvent(X, 0), BestEvent(X, 1)).SBPFlag <> 2 Then
                        Z = EN
                        Size = 1
                                  
                        If EN <= Z Then
                            For Y = EN To Z
                                RecMap(Y) = RecMap(Y) + 1 / Size
                                
                            Next Y
                        Else
                            For Y = EN To Len(StrainSeq(0))
                                RecMap(Y) = RecMap(Y) + 1 / Size
                                
                            Next Y
                            For Y = 1 To Z
                                RecMap(Y) = RecMap(Y) + 1 / Size
                            Next Y
                        End If
                        'RecMap(En) = RecMap(En) + 1
                    End If
                End If

            End If
        End If
    
        
    Next X
    XX = zz
    
    'Map sites to positions in type sequence that will be used to modify the plot
    
    PPMax = 0
    For X = 1 To Len(StrainSeq(0))
        If RecMap(X) > PPMax Then PPMax = RecMap(X)
    Next X
    Dim hWin As Long
    hWin = CLng(Win / 2)
    
    If CircularFlag = 0 And X = 12345 Then
        ST = CLng(Win / 2)
        EN = APos(Len(StrainSeq(0))) - ST
    Else
        ST = 1
        EN = APos(Len(StrainSeq(0)))
    End If
    Dim Tot As Double
    For X = ST To EN
        If X = ST Then
            'do first window
            For A = ST - hWin To ST + hWin - 1
                If A < 1 Then
                    stx = APos(Len(StrainSeq(0))) + A
                    If stx < Len(StrainSeq(0)) Then
                        ENx = BPos(stx + 1) - 1
                    Else
                        ENx = BPos(stx + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                    End If
                    stx = BPos(stx)
                
                ElseIf A > APos(Len(StrainSeq(0))) Then
                    stx = A - APos(Len(StrainSeq(0)))
                    ENx = BPos(stx + 1) - 1
                    stx = BPos(stx)
                Else
                    ENx = BPos(A + 1) - 1
                    stx = BPos(A)
                End If
                If ENx = 0 Then ENx = Len(StrainSeq(0))
                
                
                    For Z = stx To ENx
                    
                        If Z < 1 Then
                            Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                        Else
                            Tot = Tot + RecMap(Z)
                        End If
                    Next Z
                
                
                
            Next A
            X = X
            
        Else
            A = X - hWin
            If A < 1 Then
                    stx = APos(Len(StrainSeq(0))) + A
                    ENx = BPos(stx - 1) + 1
                    stx = BPos(stx)
                
                ElseIf A > APos(Len(StrainSeq(0))) Then
                    stx = A - APos(Len(StrainSeq(0)))
                    ENx = BPos(stx - 1) + 1
                    stx = BPos(stx)
                Else
                    ENx = BPos(A - 1) + 1
                    stx = BPos(A)
               
            End If
            'If ENx <> stx Then
            '    X = X
            'End If
            For Z = ENx To stx
                If Z < 1 Then
                    Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                ElseIf Z > Len(StrainSeq(0)) Then
                    Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                Else
                    Tot = Tot - RecMap(Z)
                End If
            Next Z
            A = X + hWin - 1
            If A < 1 Then
                    stx = APos(Len(StrainSeq(0))) + A
                    ENx = BPos(stx + 1) - 1
                    stx = BPos(stx)
                
                ElseIf A >= APos(Len(StrainSeq(0))) Then
                    stx = A - APos(Len(StrainSeq(0)))
                    ENx = BPos(stx + 1) - 1
                    stx = BPos(stx)
                Else
                    ENx = BPos(A + 1) - 1
                    stx = BPos(A)
                
            End If
            
            For Z = stx To ENx
                If Z < 1 Then
                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                ElseIf Z > Len(StrainSeq(0)) Then
                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                Else
                    Tot = Tot + RecMap(Z)
                End If
            Next Z
        End If
        RecMapSmooth(X) = Tot / Win
    Next X
    
    'GPerms = 5
    'Adjust recmap
    Dim RMapSmooth() As Double, RMapBounds() As Double
        ReDim RMapSmooth(GPerms, Len(StrainSeq(0)))
        ReDim RMapBounds(4, Len(StrainSeq(0)))
    If GPerms > 0 Then
        
        
        For A = 1 To GPerms
            Tot = 0
            'BPListHolder(X, CPermNo)
            For X = ST To EN
                If X = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                        Else
                            Tot = Tot + BPListHolder(Z, A)
                        End If
                        
                    Next Z
                    
                Else
                    Z = X - hWin
                    If Z < 1 Then
                        Tot = Tot - BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot - BPListHolder(Z, A)
                    End If
                    Z = X + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot + BPListHolder(Z, A)
                    End If
                    
                End If
                RMapSmooth(A, X) = Tot / Win
            Next X
        Next A
        
        
        Dim OrderArray() As Long, Tester As Double
        For Y = 1 To Len(StrainSeq(0))
            ReDim OrderArray(GPerms)
            For X = 1 To GPerms
                Tester = RMapSmooth(X, Y)
                For Z = 1 To GPerms
                    If Tester < RMapSmooth(Z, Y) Then OrderArray(X) = OrderArray(X) + 1
                Next Z
                X = X
            Next X
            Dim Target(4) As Double
            Target(0) = Int((GPerms * 0.99) + 1)
            If Target(0) > GPerms Then Target(0) = GPerms
            Target(1) = Int((GPerms * 0.95) + 1)
            If Target(1) > GPerms Then Target(1) = GPerms
            Target(2) = Int((GPerms * 0.05))
            If Target(2) < 0 Then Target(2) = 0
            Target(3) = Int((GPerms * 0.01))
            If Target(3) < 0 Then Target(3) = 0
            Target(4) = Int(GPerms * 0.5)
            
            For X = 0 To 3
                For Z = 1 To GPerms
                    If OrderArray(Z) = Target(X) Then
                        RMapBounds(X, Y) = RMapSmooth(Z, Y)
                        Exit For
                    End If
                Next Z
                If Z > GPerms Then
                    If X < 2 Then
                    'find closest smaller value to target
                        Tot = 0
                        For Z = 1 To GPerms
                            If OrderArray(Z) < Target(X) Then
                                If OrderArray(Z) > Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(X, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the smallest value
                            Tot = 0
                            For Z = 1 To GPerms
                                If OrderArray(Z) > Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(X, Y) = RMapSmooth(Z, Y)
                                    X = X
                                
                                End If
                             
                            Next Z
                            X = X
                        End If
                    Else
                        'find closest larger value to target
                        Tot = 1000000
                        For Z = 1 To GPerms
                            If OrderArray(Z) > Target(X) Then
                                If OrderArray(Z) < Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(X, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the largest value
                            Tot = 1000
                            For Z = 1 To GPerms
                                If OrderArray(Z) < Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(X, Y) = RMapSmooth(Z, Y)
                                
                                
                                End If
                             
                            Next Z
                            X = X
                        End If
                    End If
                End If
            Next X
            Tot = 0
            For Z = 1 To GPerms
                Tot = Tot + RMapSmooth(Z, Y)
            Next Z
            RMapBounds(4, Y) = Tot / GPerms
        Next Y
        'RecMapSmooth(X)
        For X = DN To Len(StrainSeq(0)) - DN + 1
            RecMapSmooth(X) = RecMapSmooth(X) - RMapBounds(4, X)
        Next X
        
        For X = DN To Len(StrainSeq(0)) - DN + 1
            RMapBounds(0, X) = RecMapSmooth(X) + (RMapBounds(4, X) - RMapBounds(0, X))
            RMapBounds(1, X) = RecMapSmooth(X) + (RMapBounds(4, X) - RMapBounds(1, X))
            RMapBounds(2, X) = RecMapSmooth(X) - (RMapBounds(2, X) - RMapBounds(4, X))
            RMapBounds(3, X) = RecMapSmooth(X) - (RMapBounds(3, X) - RMapBounds(4, X))
            X = X
        Next X
    End If
    PPMax = 0
    Dim PPMin As Double
    PPMin = 100
    For X = DN To Len(StrainSeq(0)) - DN + 1
        If RecMapSmooth(X) > PPMax Then PPMax = RecMapSmooth(X)
        If RecMapSmooth(X) < PPMin Then PPMin = RecMapSmooth(X)
        For Y = 0 To 3
            If RMapBounds(Y, X) > PPMax Then PPMax = RMapBounds(Y, X)
            If RMapBounds(Y, X) < PPMin Then PPMin = RMapBounds(Y, X)
        Next Y
    Next X
    If PPMax < (BPCVal(0, 0) / Win) Then PPMax = BPCVal(0, 0) / Win
    
    ReDim MCPrintPos(APos(Len(StrainSeq(0))))
    ReDim MCPrintData(6, APos(Len(StrainSeq(0))))
    For Z = 1 To APos(Len(StrainSeq(0)))
        MCPrintData(0, Z) = RecMapSmooth(Z)
        MCPrintPos(Z) = Z
    Next Z
    Dim TempXDiffPos() As Long
    ReDim TempXDiffPos(Len(StrainSeq(0)))
    Z = 1
    For X = 1 To Len(StrainSeq(0))
        TempXDiffPos(X) = XDiffpos(X)
        XDiffpos(X) = 0
        If RecMap(X) > 0 Then
            XDiffpos(Z) = X
            Z = Z + 1
        End If
        
    Next X
    For X = DN To APos(Len(StrainSeq(0)) - DN + 1)
        
        XDiffpos(X) = APos(XDiffpos(X))
        MCPrintData(6, X) = APos(XDiffpos(X))
        
    Next X
    olenxoverseq = LenXOverSeq
    LenXOverSeq = Z
    MinPVal = PPMax
    MCMinChiP = PPMax
    DoAxes APos(Len(StrainSeq(0))), TypeSeq, PPMax * Win, PPMin * Win, 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"
    RDPUD = PPMax * Win
    LenXOverSeq = olenxoverseq
    BSCStepWin = Win
    For X = 1 To Len(StrainSeq(0))
        XDiffpos(X) = TempXDiffPos(X)
    Next X
    
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / APos(Len(StrainSeq(0))))
    HFactor = (PicHeight - 35)
    TOffset = 20
    Dim PntAPI As POINTAPI
    If Form1.Picture7.DrawWidth = 0 Then Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawStyle = 2
    'MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMapSmooth(1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    MhDC = Form1.Picture7.hdc
    MoveToEx MhDC, LOffset + 1 * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
    
    MoveToEx MhDC, LOffset - 5 + 1 * WFactor, TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
    
    
    MCPrintData(5, 0) = BPCVal(0, 0) / Win
    MCPrintData(5, 1) = BPCVal(0, 1) / Win
    
    Form1.Picture7.DrawStyle = 0
    
    XX = UBound(PValMap, 2)
    
    
    If X = X Then
    'show only local 99 and 95% CIs
        Form1.Picture7.ForeColor = RGB(255, 255, 255)
        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        Next X
        Form1.Picture7.ForeColor = RGB(150, 150, 150)
        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        Next X
    Else
        'do coulourful plot
        For Z = PermutationX To PermutationX / 2 Step -1
            If Z > 0.75 * PermutationX Then
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - PermutationX / 2) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX * 0.75)) / (PermutationX * 0.25)))
            Else
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (255 - 255 * ((PermutationX * 0.75) - Z) / (PermutationX * 0.25)))
            End If
            
            'Form1.Picture7.ForeColor = RGB(127 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50)
            'Form1.Picture7.ForeColor = RGB(200 + 55 * (Z - 50) / 50, 0 + 255 * (Z - 50) / 50, 127 + 128 * (Z - 50) / 50)
            
            MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValMap(1, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
            LineTo MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0))), Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            For X = 2 To APos(Len(StrainSeq(0)))
                LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            Next X
        
        Next Z
    End If
    
    Form1.Picture7.ForeColor = RGB(128, 128, 128)
   ' MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValmap( 1, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
   ' For X = 2 To Len(StrainSeq(0))
   '     LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValmap( X, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
   ' Next X
    Form1.Picture7.ForeColor = RGB(130, 130, 130)
    MCPrintData(1, 1) = PValMap(1, 0.05 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.05 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, 0.05 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(1, X) = PValMap(X, 0.05 * PermutationX) / Win
    Next X
    MCPrintData(2, 1) = PValMap(1, 0.95 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.95 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, 0.95 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(2, X) = PValMap(X, 0.95 * PermutationX) / Win
    Next X
    Form1.Picture7.ForeColor = RGB(200, 200, 200)
    MCPrintData(3, 1) = PValMap(1, 0.01 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.01 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, 0.01 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(3, X) = PValMap(X, 0.01 * PermutationX) / Win
    Next X
    MCPrintData(4, 1) = PValMap(1, 0.99 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.99 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, 0.99 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(4, X) = PValMap(X, 0.99 * PermutationX) / Win
    Next X
    Form1.Picture7.ForeColor = 0
    If GPerms > 0 Then
        Form1.Picture7.DrawWidth = CLng((Form1.Picture7.ScaleWidth - LOffset * 2) / Len(StrainSeq(0)) + 0.5)
        
        Form1.Picture7.DrawStyle = 0
        For X = 0 To 1
            If X = 0 Or X = 3 Then
                Form1.Picture7.ForeColor = HalfColour
                Y = 3
            Else
                Form1.Picture7.ForeColor = RGB(128, 128, 128)
                Y = 2
            End If
            MhDC = Form1.Picture7.hdc
            MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RMapBounds(X, 1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
            LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (RMapBounds(Y, 1) - PPMin) / (PPMax - PPMin)) * HFactor
            For Z = 2 To APos(Len(StrainSeq(0)))
            
                MhDC = Form1.Picture7.hdc
                LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RMapBounds(X, Z) - PPMin) / (PPMax - PPMin)) * HFactor
                LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RMapBounds(Y, Z) - PPMin) / (PPMax - PPMin)) * HFactor
            Next Z
        Next X
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.DrawStyle = 0
        Form1.Picture7.ForeColor = 0
        MoveToEx MhDC, LOffset - 5 + 0 * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
        LineTo MhDC, LOffset + APos(Len(StrainSeq(0))) * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor
        
    End If
    
    Form1.Picture7.ForeColor = 0
    MhDC = Form1.Picture7.hdc
    MoveToEx MhDC, LOffset + DN * WFactor, TOffset + (1 - (RecMapSmooth(DN) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For Z = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
    
        MhDC = Form1.Picture7.hdc
        LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RecMapSmooth(Z) - PPMin) / (PPMax - PPMin)) * HFactor
    Next Z
    Form1.Picture7.Refresh
End Sub
Public Sub RecMapOut()
    Dim RecMapSmooth() As Double, Win As Long
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Win = 100
    B = 0
    C = 0
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    For X = 1 To ENumb
        If (BestEvent(X, 0) > 0 Or BestEvent(X, 1) > 0) And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability > 0 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber
            Else
                SEN = SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            If CNum > ConsensusProg Then
                ST = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Beginning
                EN = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Ending
                RecMap(ST) = RecMap(ST) + 1
                RecMap(EN) = RecMap(EN) + 1

            End If

        
        End If
    
        
    Next X
    PPMax = 0
    For X = 1 To Len(StrainSeq(0))
        If RecMap(X) > PPMax Then PPMax = RecMap(X)
    Next X
    Dim hWin As Long
    hWin = CLng(Win / 2)
    
    If CircularFlag = 1 Then
        ST = CLng(Win / 2)
        EN = Len(StrainSeq(0)) - ST
    Else
        ST = 1
        EN = Len(StrainSeq(0))
    End If
    Dim Tot As Long
    For X = ST To EN
        If X = ST Then
            'do first window
            For Z = ST - hWin To ST + hWin - 1
                If Z < 1 Then
                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                ElseIf Z > Len(StrainSeq(0)) Then
                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                Else
                    Tot = Tot + RecMap(Z)
                End If
                
            Next Z
            
        Else
            Z = X - hWin
            If Z < 1 Then
                Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
            ElseIf Z > Len(StrainSeq(0)) Then
                Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
            Else
                Tot = Tot - RecMap(Z)
            End If
            Z = X + hWin - 1
            If Z < 1 Then
                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
            ElseIf Z > Len(StrainSeq(0)) Then
                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
            Else
                Tot = Tot + RecMap(Z)
            End If
            
        End If
        RecMapSmooth(X) = Tot / Win
    Next X
    Dim SpaceSeq() As Long
    ReDim SpaceSeq(Len(StrainSeq(0)))
    For X = 1 To Len(StrainSeq(0))
        If SeqNum(X, 0) > 50 Then
            Y = Y + 1
            SpaceSeq(Y) = X
        End If
    Next X
    For X = 1 To Len(StrainSeq(0)) - SeqSpaces(Len(StrainSeq(0)), 0)
        Print #10, X & "," & Str(RecMapSmooth(SpaceSeq(X)))
    Next X
    
    
End Sub
Public Sub SaveWMFPlot()
    WMFName = "c:/testwmf.wmf"
    Dim SP As Long, EP As Long
    Dim PColIn As Long, HFactor As Double, WFactor As Double
    Dim OldFont As Long, OldPen As Long, Pen As Long, LOffset As Long, TOffset As Long, MhDC As Long, EMFCls As Long
    Dim PntAPI As POINTAPI
    Dim LPn As LOGPEN
    Dim Red As Long, Green As Long, Green2 As Long, Blue As Long
    'LPn.lopnColor = RGB(255, 0, 0)
    'LPn.lopnWidth.XPos = 5
    'LPn.lopnWidth.Y = 5
    'LPn.lopnStyle = 0

    Dim rct As RECT
    Dim LoFnt As Long

    If CopyFlag = 0 Then

        With Form1.CommonDialog1
            .filename = ""
            '.InitDir = currentdir
            .DefaultExt = ".emf"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "EMF File (*.emf)|*.emf"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            semfname$ = .filename  'Stores selected file name in the
            'string, fname$.
            SEMFnameII = .FileTitle
        End With

    Else
        On Error Resume Next
        Kill "tmp2.emf"
        On Error GoTo 0
        SEMFnameII = "tmp2.emf"
        semfname$ = "tmp2.emf"
    End If
'Exit Sub
    rct.Bottom = 10000
    'Exit Sub
    rct.left = 0
    rct.Top = 0

    If ManFlag = 3 Or ManFlag = 1 Or ManFlag = 4 Or ManFlag = 8 Or ManFlag = 9 Or ManFlag = 7 Then
        rct.right = 25000
        rct.Bottom = 16000
    Else
        If RelX > 0 Or RelY > 0 Then
            If XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
                rct.right = 25000
                rct.Bottom = 14000
            Else
                rct.right = 19000
            End If
        Else
            rct.right = 19000
        End If
    End If
    
    HFactor = 200
    WFactor = 500 / Len(StrainSeq(0))
    LOffset = 70
    TOffset = 60
    'Kill "c:\test18.emf"
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, semfname$, rct, "")
    Form1.Picture1.AutoRedraw = True
    'Get original Metafile font and pen
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    Pen = CreatePenIndirect(LPn)
    OldPen = SelectObject(MhDC, Pen)
    'Draw Axes
    MoveToEx MhDC, LOffset - 10, TOffset - 10, PntAPI
    LineTo MhDC, LOffset - 10, TOffset
    LineTo MhDC, LOffset - 5, TOffset
    LineTo MhDC, LOffset - 10, TOffset
    LineTo MhDC, LOffset - 10, TOffset
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 2
    LineTo MhDC, LOffset - 5, TOffset + HFactor / 2
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 2
    LineTo MhDC, LOffset - 10, TOffset + HFactor
    LineTo MhDC, LOffset - 5, TOffset + HFactor
    LineTo MhDC, LOffset - 10, TOffset + HFactor
    LineTo MhDC, LOffset - 10, TOffset + HFactor + 10
    LineTo MhDC, LOffset, TOffset + HFactor + 10
    LineTo MhDC, LOffset, TOffset + HFactor + 5
    LineTo MhDC, LOffset, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 4, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 4, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 4, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 2, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 2, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 2, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.333, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.333, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.333, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)), TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)), TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)), TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)) + 10, TOffset + HFactor + 10
    SetBkColor MhDC, RGB(255, 255, 255)
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    SelectObject MhDC, LoFnt
    
    Dim AxLen As Long, AxStr As String
    TypeSeq = 0
    If TypeSeq > NextNo Then TypeSeq = 0
    If CurrentCheck = 15 Then
        AxStr = "Nucleotide position in relation to " + StraiName(TypeSeq)
        AxLen = UBound(MCPrintPos, 1)
    Else
        AxStr = "Position in alignment"
        AxLen = Len(StrainSeq(0))
    End If
    TextOut MhDC, LOffset - 4.5, TOffset + HFactor + 15, "1", 1
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 4 - Len(CStr(Int(Len(StrainSeq(0)) / 4))) * 4.5, TOffset + HFactor + 15, CStr(Int(AxLen / 4)), Len(CStr(Int(AxLen / 4)))
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 2 - Len(CStr(Int(Len(StrainSeq(0)) / 2))) * 4.5, TOffset + HFactor + 15, CStr(Int(AxLen / 2)), Len(CStr(Int(AxLen / 2)))
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.333 - Len(CStr(Int(Len(StrainSeq(0)) / 1.333))) * 4.5, TOffset + HFactor + 15, CStr(Int(AxLen / 1.333)), Len(CStr(Int(AxLen / 1.333)))
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) - Len(CStr(Int(Len(StrainSeq(0))))) * 4.5, TOffset + HFactor + 15, CStr(Int(AxLen)), Len(CStr(Int(AxLen)))
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 2 - 21 * 4, TOffset + HFactor + 35, AxStr, Len(AxStr)

    If ManFlag = -1 Then

        If CurrentCheck <> 14 And CurrentCheck <> 15 And CurrentCheck <> 12 And CurrentCheck <> 13 And CurrentCheck <> 10 And XOverList(RelX, RelY).ProgramFlag <> 4 And CurrentCheck <> 5 And XOverList(RelX, RelY).ProgramFlag <> 6 And XOverList(RelX, RelY).ProgramFlag <> 6 + AddNum And XOverList(RelX, RelY).ProgramFlag <> 5 And XOverList(RelX, RelY).ProgramFlag <> 5 + AddNum And XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum And CurrentCheck <> 5 And CurrentCheck <> 21 And CurrentCheck <> 22 And CurrentCheck <> 20 And CurrentCheck <> 6 And CurrentCheck <> 23 And CurrentCheck <> 8 Then
            If (XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 1 Then
            
            Else
                SetTextColor MhDC, RGB(190, 190, 0)
                Out$ = StraiName(Seq1) & " - " & StraiName(Seq2)
                TextOut MhDC, LOffset, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Green
                Out$ = StraiName(Seq1) & " - " & StraiName(Seq3)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 3, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Purple
                Out$ = StraiName(Seq2) & " - " & StraiName(Seq3)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.5, TOffset + HFactor + 60, Out$, Len(Out$)
            End If
        End If

    End If

    SetTextColor MhDC, QBColor(0)

    If ManFlag > -1 Then

        If ManFlag = 3 Or ManFlag = 1 Or ManFlag = 4 Or ManFlag = 8 Or ManFlag = 7 Then
            TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17

            For X = 1 To NumberOfSeqs
                LPn.lopnColor = SeqCol(RevSeq(X))
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, 600, TOffset + X * 20, PntAPI)
                Dummy = LineTo(MhDC, 650, TOffset + X * 20)
                TextOut MhDC, 660, TOffset + X * 20 - 10, StraiName(RevSeq(X)), Len(StraiName(RevSeq(X)))
            Next 'X
        ElseIf ManFlag = 9 Then
            'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17

            For X = 1 To NumberOfSeqs
                LPn.lopnColor = SeqCol(RevSeq(X))
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, 600, TOffset + X * 20, PntAPI)
                Dummy = LineTo(MhDC, 650, TOffset + X * 20)
                TextOut MhDC, 660, TOffset + X * 20 - 10, StraiName(RevSeq(X)), Len(StraiName(RevSeq(X)))
            Next 'X
        End If

        If ManFlag = 3 Then
            TextOut MhDC, LOffset - 40, TOffset - 10, "100", 3
            TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, " 50", 3
            TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "  0", 3

            For X = 1 To NumberOfSeqs
                LPn.lopnColor = SeqCol(RevSeq(X))
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + PltPos(PosCount) * WFactor, TOffset + (1 - PltVal(X, PosCount) / BSBootReps) * HFactor, PntAPI)

                Do While PltPos(PosCount + 1) > 0 And PltPos(PosCount + 1) <= Len(StrainSeq(0))
                    PosCount = PosCount + 1
                    Dummy = LineTo(MhDC, LOffset + PltPos(PosCount) * WFactor, TOffset + (1 - PltVal(X, PosCount) / BSBootReps) * HFactor)
                Loop

            Next 'X

            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 240, "Bootstrap support (%)", 21
        ElseIf ManFlag = 1 Then
            TextOut MhDC, LOffset - 50, TOffset - 10, Mid$(CStr(MinGCP), 1, 4), Len(Mid$(CStr(MinGCP), 1, 4))
            TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Mid$(CStr(MinGCP / 2), 1, 4), Len(Mid$(CStr(MinGCP / 2), 1, 4))
            TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0.0", 3
            LPn.lopnColor = QBColor(0)
            LPn.lopnStyle = 2
            Pen = CreatePenIndirect(LPn)
            SelectObject MhDC, Pen
            GlobalAddj = NumberOfSeqs
            COff = -Log10(LowestProb / GlobalAddj)
            'MinGCP = LowestProb / GlobalAddj

            If COff <= MinGCP Then
                MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinGCP) * HFactor, PntAPI
                LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinGCP) * HFactor
            End If

            COff = -Log10(LowestProb)
            MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinGCP) * HFactor, PntAPI
            LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinGCP) * HFactor

            For X = 0 To NumberOfSeqs
                LPn.lopnColor = SeqCol(RevSeq(X))
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(X, CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(X, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(X, CurPPos) / MinGCP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(X, CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(X, CurPPos) / MinGCP) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(X, CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(X, CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(X, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(X, CurPPos) / MinGCP) * HFactor
                    CurPPos = CurPPos + 1
                Loop

            Next 'X

            LPn.lopnColor = Green
            Pen = CreatePenIndirect(LPn)
            SelectObject MhDC, Pen
            CurPPos = 0
            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 220, "-Log(KA P-Value)", 16
        ElseIf ManFlag = 4 Then
            MCOverlapR = 0
            TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP), 1, 3), Len(Mid$(CStr(MCMinChiP), 1, 3))
            TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 1, 3), Len(Mid$(CStr(MCMinChiP / 2), 1, 3))
            TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
            LPn.lopnColor = QBColor(0)
            LPn.lopnStyle = 2
            Pen = CreatePenIndirect(LPn)
            SelectObject MhDC, Pen
            COff = -Log10(LowestProb / NumberOfSeqs)

            If COff <= MCMinChiP Then
                MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
            End If

            COff = -Log10(LowestProb)

            If COff <= MCMinChiP Then
                MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
            End If

            LPn.lopnStyle = 0
            Pen = CreatePenIndirect(LPn)
            SelectObject MhDC, Pen

            For X = 1 To LenXOverSeq
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
            Next 'X

            For X = 0 To NumberOfSeqs - 1
                LPn.lopnColor = SeqCol(RevSeq(X + 1))
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 1

                Do While MCPrintPos(PosCount) - MCOverlapR < 0
                    PosCount = PosCount + 1
                Loop

                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount) - MCOverlapR) * WFactor, TOffset + (1 - (-Log10(MCPrintData(X, PosCount)) / MCMinChiP)) * HFactor, PntAPI)
                PosCount = PosCount + 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf PosCount > LenXOverSeq - 1 Then
                    
                    
                        Exit Do
                    ElseIf PosCount > UBound(MCPrintPos, 1) Then
                        Exit Do
                    ElseIf PosCount + 3 <= UBound(MCPrintPos, 1) Then
                        
                        If MCPrintPos(PosCount + 3) = 0 Then
                            Exit Do
                        End If
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount) - MCOverlapR) * WFactor, TOffset + (1 - (-Log10(MCPrintData(X, PosCount)) / MCMinChiP)) * HFactor)
                    PosCount = PosCount + 1
                Loop

            Next 'X

            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 210, "-Log(P[Chi2])", 13
        ElseIf ManFlag = 5 Then
            On Error Resume Next
            TextOut MhDC, LOffset - 50, TOffset - 10, Trim$(CStr(Int((MaxL - MinL) * 10) / 10)), Len(Trim$(CStr(Int((MaxL - MinL) * 10) / 10)))
            TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(Int(((MaxL - MinL) / 2) * 10) / 10)), Len(Trim$(CStr(Int(((MaxL - MinL) / 2) * 10) / 10)))
            TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, " 0.0", 4
            LPn.lopnColor = RGB(0, 0, 0)
            Pen = CreatePenIndirect(LPn)
            SelectObject MhDC, Pen
            PosCount = 1
            Dummy = MoveToEx(MhDC, LOffset + (LXPos(PosCount)) * WFactor, TOffset + (((LSurface(PosCount) - MinL) / (MaxL - MinL))) * HFactor, PntAPI)

            Do
                PosCount = PosCount + 1

                If LXPos(PosCount) = 0 Then Exit Do
                Dummy = LineTo(MhDC, LOffset + (LXPos(PosCount)) * WFactor, TOffset + (((LSurface(PosCount) - MinL) / (MaxL - MinL))) * HFactor)
            Loop

            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 240, "Log likelihood ratio", 20
            On Error GoTo 0
        ElseIf ManFlag = 7 Then

            If MaxDistX < 1 Then
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Trim$(CStr((CInt(MaxDistX * 100) / 100))), Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
            Else
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Trim$(CStr((CInt(MaxDistX * 100) / 100))), Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
            End If

            If MaxDistX / 2 < 1 Then
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
            Else
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
            End If

            TextOut MhDC, LOffset - 50, TOffset - 10, "0.00", 4

            For X = 1 To NumberOfSeqs
                LPn.lopnColor = SeqCol(RevSeq(X))
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(X, PosCount)) / MaxDistX)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf PosCount > UBound(MCPrintPos, 1) Then
                        Exit Do
                    ElseIf PosCount + 3 <= UBound(MCPrintPos, 1) Then
                        
                        If MCPrintPos(PosCount + 3) = 0 Then
                            Exit Do
                        End If
                    ElseIf (MCPrintPos(PosCount)) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(X, PosCount) / MaxDistX))) * HFactor)
                    PosCount = PosCount + 1
                Loop

            Next 'X

            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 200, "Distance", 8
        ElseIf ManFlag = 8 Then
            'On Error Resume Next

            If TOHigh < 1 Then
                TextOut MhDC, LOffset - 50, TOffset - 10, "0" & Trim$(CStr((CInt(TOHigh * 100) / 100))), 1 + Len(Trim$(CStr(CInt(TOHigh * 100) / 100)))
            Else
                TextOut MhDC, LOffset - 50, TOffset - 10, Trim$(CStr((CInt(TOHigh * 100) / 100))), Len(Trim$(CStr(CInt(TOHigh * 100) / 100)))
            End If

            If TOHigh / 2 < 1 Then
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, "0" & Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)), 1 + Len(Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)))
            Else
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)), Len(Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)))
            End If

            TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0.00", 4

            For Y = 0 To TOPerms
                PlotPos = Int((TOWinLen + TOStepSize * TOSmooth) / 2)
                Dummy = MoveToEx(MhDC, LOffset + PlotPos * WFactor, TOffset + ((1 - (SmoothDSS(Y, 0) / TOHigh)) * HFactor), PntAPI)
                'Exit For

                For X = 1 To Int(TOEndPlot + 1) - TOSmooth
                    PlotPos = PlotPos + TOStepSize
                    Dummy = LineTo(MhDC, LOffset + PlotPos * WFactor, TOffset + ((1 - (SmoothDSS(Y, X) / TOHigh)) * HFactor))
                Next 'X

                If Y = 0 Then
                    LPn.lopnColor = QuaterColour
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                End If

            Next 'Y

            LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
            SelectObject MhDC, LoFnt
            TextOut MhDC, LOffset - 70, 180, "DSS", 3
            'On Error GoTo 0
        ElseIf ManFlag = 9 Then
           On Error Resume Next
                SSLo = SSLo + 0.00001
                SSUp = SSUp + 0.00001
                TextOut MhDC, LOffset - 45, TOffset - 10, Mid$(CStr(SSUp), 2, 4), 4
                TextOut MhDC, LOffset - 45, TOffset - 10 + HFactor / 2, Mid$(CStr(SSLo + (SSUp - SSLo) / 2), 2, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(SSLo), 1, 5), 5
                
                
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqSS(SSOLoSeq)
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor)
                
                'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17

                For X = 1 To 15
                    LPn.lopnColor = RGB(X * (255 / 15), (255 - (255 / 15) * (X - 1)), (255 - (255 / 15) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + X * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + X * 20)
                    OutS = "P" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + X * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                For X = 1 To 9
                    LPn.lopnColor = RGB((255 - (255 / 9) * (X - 1)), X * (255 / 9), (255 - (255 / 9) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + (X + 15) * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + (X + 15) * 20)
                    OutS = "S" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + (X + 15) * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
        
                    
                    For X = 1 To 15
                        LPn.lopnColor = RGB(255 / X, X * (255 / 15), 255)
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        PosCount = 1
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X
                    
                    For X = 1 To 9
                        LPn.lopnColor = RGB(255 / X, 128, X * (255 / 15))
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        
                        PosCount = 1
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X


                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 190, "Z Value", 7
                On Error GoTo 0
        
        End If

    Else

        If CurrentCheck > -1 Or ((XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Then

            If CurrentCheck = 0 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, "1.0", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, "0.5", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                
                Call FindSubSeqRDP
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X

                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 0) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 0) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 0) / (XOverWindowX + 1)) * HFactor)
                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 1) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 1) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 1) / (XOverWindowX + 1)) * HFactor)
                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 2) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 2) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                XDiffpos(LenXOverSeq) = XDiffpos(LenXOverSeq)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 2) / (XOverWindowX + 1)) * HFactor)
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "Pairwise identity", 17
            ElseIf CurrentCheck = 13 Then
                On Error Resume Next
                Call FindSubSeqPP
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
                Red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
                Blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
                
                
                TextOut MhDC, LOffset - 45, TOffset - 10, "1.00", 4
                TextOut MhDC, LOffset - 45, TOffset - 10 + HFactor / 2, Mid$(CStr(CDbl(MRV + (1 - MRV) / 2)), 1, 4), 4
                If MRV < 0 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(MRV), 1, 5), 5
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(MRV), 1, 4), 4
                End If
                
                SetTextColor MhDC, Red
                Out$ = StraiName(Seq1)
                TextOut MhDC, LOffset, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Green
                Out$ = StraiName(Seq2)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 3, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Blue
                Out$ = StraiName(Seq3)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.5, TOffset + HFactor + 60, Out$, Len(Out$)
                 SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
                'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17
      
                LPn.lopnColor = ThreeQuaterColour
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                For Y = 0 To NumberOfSeqs
                    If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
                        
                                                
                        Dummy = MoveToEx(MhDC, LOffset + (XDiffpos(1)) * WFactor, TOffset + HFactor - (((PPWinScoreT(1, Y) - MRV) / (MaRV - MRV)) * HFactor), PntAPI)
                    
                        For Z = 2 To LenXOverSeq
                            Dummy = LineTo(MhDC, LOffset + (XDiffpos(Z)) * WFactor, TOffset + HFactor - (((PPWinScoreT(Z, Y) - MRV) / (MaRV - MRV)) * HFactor))
                        Next Z
                    End If
                Next Y
                    
                For X = 0 To 2
                    If X = 0 Then
                        Y = Seq1
                        LPn.lopnColor = Green
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    ElseIf X = 1 Then
                        Y = Seq2
                        LPn.lopnColor = Blue
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    ElseIf X = 2 Then
                        Y = Seq3
                        LPn.lopnColor = Red
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    End If
                                           
                                                
                        Dummy = MoveToEx(MhDC, LOffset + (XDiffpos(1)) * WFactor, TOffset + HFactor - (((PPWinScoreT(1, Y) - MRV) / (MaRV - MRV)) * HFactor), PntAPI)
                    
                        For Z = 2 To LenXOverSeq
                            Dummy = LineTo(MhDC, LOffset + (XDiffpos(Z)) * WFactor, TOffset + HFactor - (((PPWinScoreT(Z, Y) - MRV) / (MaRV - MRV)) * HFactor))
                        Next Z
                    
                Next X


                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 190, "Correlation", 11
                On Error GoTo 0
            ElseIf CurrentCheck = 1 Or ((XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1 And CurrentCheck = -1) Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MinPx), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MinPx / 2), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqGC
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                For X = 0 To NextNo

                    If MaskSeq(X) < 2 Then
                        Unmasked = Unmasked + 1
                    End If

                Next 'X

                GlobalAddj = (Unmasked * (Unmasked - 1) / 2)
                COff = -Log10(LowestProb / GlobalAddj)

                If COff <= MinPx Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinPx) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinPx) * HFactor
                End If

                COff = -Log10(LowestProb)

                If COff <= MinPx Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinPx) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinPx) * HFactor
                End If

                LPn.lopnColor = RGB(190, 190, 0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(0, CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(0, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(0, CurPPos) / MinPx) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(0, CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(0, CurPPos) / MinPx) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(0, CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(0, CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(0, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(0, CurPPos) / MinPx) * HFactor
                    CurPPos = CurPPos + 1
                Loop

                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(1, CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(1, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(1, CurPPos) / MinPx) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(1, CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(1, CurPPos) / MinPx) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(1, CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(1, CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(1, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(1, CurPPos) / MinPx) * HFactor
                    CurPPos = CurPPos + 1
                Loop

                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(1, CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(2, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(2, CurPPos) / MinPx) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(2, CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(2, CurPPos) / MinPx) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(2, CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(2, CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(2, CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(2, CurPPos) / MinPx) * HFactor
                    CurPPos = CurPPos + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "-Log(KA P-Value)", 16
            ElseIf CurrentCheck = 12 Then
                
                Dim LP As Double
                'If MCFlag = 1 Or MCFlag = 2 Then
                    LP = -Log10(LowestProb)
                'ElseIf MCFlag = 0 Then
                '    LP = -Log10(LowestProb / MCCorrection)
                'End If
                If LongWindedFlag = 0 Then
                    ENumb = Eventnumber
                Else
                    ENumb = SEventNumber
                End If
                PPMax = 1
                
                For X = 1 To ENumb
                    If BestEvent(X, 0) > 0 Or BestEvent(X, 1) > 0 Then
                        If XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability < PPMax And XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability > 0 Then
                            PPMax = XOverList(BestEvent(X, 0), BestEvent(X, 1)).Probability
                        End If
                    End If
                Next X
                
                PPMax = -Log10(PPMax)
                
                
                TextOut MhDC, LOffset - 50, TOffset - 10, Mid$(CStr(PPMax), 1, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Mid$(CStr(LP + (PPMax - LP) / 2), 1, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(LP), 1, 4), 4
                Dim DistCol As Long
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
                CurPPos = 0
                Dim PV As Double
                For Z = 1 To ENumb
                    X = BestEvent(Z, 0)
                    Y = BestEvent(Z, 1)
                    GoOn = 1
                    If X > 0 Or Y > 0 Then
                    
                        
                        
                        If GoOn = 1 Then 'And XOverList(X, Y).OutsideFlag = 0 And Distance(X, XOverList(X, Y).MinorP) < Distance(X, XOverList(X, Y).MajorP) Then
                            BE = XOverList(X, Y).Beginning
                            EN = XOverList(X, Y).Ending
                            PV = -Log10(XOverList(X, Y).Probability)
                            If PV > LP Then
                                'MDist = (Distance(XOverList(X, Y).MinorP, XOverList(X, Y).MajorP) - (1 - Distance(XOverList(X, Y).MinorP, XOverList(X, Y).MajorP)))
                                MDist = Distance(XOverList(X, Y).MinorP, XOverList(X, Y).MajorP)
                                DistCol = Int(((MDist - MinDistSch) / (MaxDistSch - MinDistSch)) * 768)
                        
                                Call DistColour(DistCol)
                                
                                LPn.lopnColor = DistCol
                                LPn.lopnStyle = 0
                                Pen = CreatePenIndirect(LPn)
                                SelectObject MhDC, Pen
                                If BE < EN Then
                                    MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                                    LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                    LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                Else
                                    MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                                    LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                    LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + 1 * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                    
                                    MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
                                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
                                    LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                End If
                            End If
                        End If
                    End If
                Next Z
                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0
                
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "-Log(P-Value)", 13
            ElseIf CurrentCheck = 2 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, "100", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, " 50", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "  0", 3
                
                Call FindSubSeqBS
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 240, "Bootstrap support (%)", 21
            ElseIf CurrentCheck = 3 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, "100", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, " 50", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "  0", 3
                
                Call FindSubSeqBS
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 240, "Bootstrap support (%)", 21
            ElseIf CurrentCheck = 4 Or CurrentCheck = 21 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen

                If CurrentCheck = 4 Then
                    COff = -Log10(LowestProb / MCCorrection)
                Else
                    COff = -Log10(LowestProb / MCCorrect)
                End If

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                COff = -Log10(LowestProb)

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                If CurrentCheck = 4 Then
                    LPn.lopnStyle = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    
                    For X = 1 To LenXOverSeq
                        Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 20, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 10)
                    Next 'X

                    For Y = 0 To 2
                        If Y = 0 Then
                            PColIn = Yellow
                        ElseIf Y = 1 Then
                            PColIn = Green
                        ElseIf Y = 2 Then
                            PColIn = Purple
                        End If
                        
                        LPn.lopnColor = PColIn
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        
                        PosCount = 1
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(Y, PosCount)) / MCMinChiP)) * HFactor, PntAPI)
                        
                        PosCount = PosCount + 1
    
                        Do
                            If PosCount > UBound(MCPrintPos) Then
                                Exit Do
                            End If
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(Y, PosCount)) / MCMinChiP)) * HFactor)
                            PosCount = PosCount + 1
                        Loop
                    Next Y
                    
                    

                Else
                    LPn.lopnColor = QBColor(0)
                    LPn.lopnStyle = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    
                    For X = 1 To Len(MCXoverSeq(0))
                        Dummy = MoveToEx(MhDC, LOffset + MCXDiffPos(X) * WFactor, TOffset - 20, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + MCXDiffPos(X) * WFactor, TOffset - 10)
                    Next 'X
                    PosCount = 1
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1) - MCFullOR) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount)) / MCMinChiP)) * HFactor, PntAPI)
                    PosCount = 2

                    Do

                        If PosCount > UBound(MCPrintPos) Then
                            Exit Do
                        
                        End If

                        Dummy = LineTo(MhDC, LOffset + MCPrintPos(PosCount) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount)) / MCMinChiP)) * HFactor)
                        PosCount = PosCount + 1
                    Loop
                End If

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 210, "-Log(P[Chi2])", 13
            ElseIf CurrentCheck = 10 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen

                COff = -Log10(LowestProb / MCCorrection)
                
                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                COff = -Log10(LowestProb)

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If
                
                Green2 = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
                Red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
                Blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
                 
                SetTextColor MhDC, Red
                Out$ = StraiName(Seq1)
                TextOut MhDC, LOffset, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Green2
                Out$ = StraiName(Seq2)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 3, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Blue
                Out$ = StraiName(Seq3)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.5, TOffset + HFactor + 60, Out$, Len(Out$)
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                SP = -3
                
                For Y = 0 To 2
                    SP = SP + 3
                    If Y = 0 Then
                        PColIn = Red
                    ElseIf Y = 1 Then
                        PColIn = Green2
                    ElseIf Y = 2 Then
                        PColIn = Blue
                    End If
                        
                    LPn.lopnColor = PColIn
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    For X = 1 To xLenXoverSeq(Y)
                        Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X, Y) * WFactor, TOffset - 20 + SP, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + MCPrintPos(X, Y) * WFactor, TOffset - 20 + SP + 3)
                    Next 'X
                Next Y
                For Y = 0 To 2
                    If Y = 0 Then
                        PColIn = Red
                    ElseIf Y = 1 Then
                        PColIn = Green2
                    ElseIf Y = 2 Then
                        PColIn = Blue
                    End If
                        
                    LPn.lopnColor = PColIn
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                        
                    PosCount = 1
                        
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount, Y)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount, Y)) / MCMinChiP)) * HFactor, PntAPI)
                        
                    PosCount = PosCount + 1
    
                        For PosCount = 2 To xLenXoverSeq(Y) - 1
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount, Y)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount, Y)) / MCMinChiP)) * HFactor)
                        Next
                    Next Y
                    SetTextColor MhDC, 0
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 210, "-Log(P[Chi2])", 13
            ElseIf CurrentCheck = 5 Then
                On Error Resume Next
                SSLo = SSLo + 0.00001
                SSUp = SSUp + 0.00001
                TextOut MhDC, LOffset - 45, TOffset - 10, Mid$(CStr(SSUp), 2, 4), 4
                TextOut MhDC, LOffset - 45, TOffset - 10 + HFactor / 2, Mid$(CStr(SSLo + (SSUp - SSLo) / 2), 2, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(SSLo), 1, 5), 5
                
                
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqSS(SSOLoSeq)
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor)
                
                'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17

                For X = 1 To 15
                    LPn.lopnColor = RGB(X * (255 / 15), (255 - (255 / 15) * (X - 1)), (255 - (255 / 15) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + X * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + X * 20)
                    OutS = "P" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + X * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                For X = 1 To 9
                    LPn.lopnColor = RGB((255 - (255 / 9) * (X - 1)), X * (255 / 9), (255 - (255 / 9) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + (X + 15) * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + (X + 15) * 20)
                    OutS = "S" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + (X + 15) * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
        
                    
                    For X = 1 To 15
                        LPn.lopnColor = RGB(255 / X, X * (255 / 15), 255)
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        PosCount = 1
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X
                    
                    For X = 1 To 9
                        LPn.lopnColor = RGB(255 / X, 128, X * (255 / 15))
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        
                        PosCount = 1
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X


                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 190, "Z Value", 7
                On Error GoTo 0
            ElseIf CurrentCheck = 6 Then
            
                On Error Resume Next
                TextOut MhDC, LOffset - 50, TOffset - 10, Trim$(CStr(Int((MaxL - MinL) * 10) / 10)), Len(Trim$(CStr(Int((MaxL - MinL) * 10) / 10)))
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(Int(((MaxL - MinL) / 2) * 10) / 10)), Len(Trim$(CStr(Int(((MaxL - MinL) / 2) * 10) / 10)))
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, " 0.0", 4
                
                
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqBS
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                PosCount = 1
                Dummy = MoveToEx(MhDC, LOffset + (LXPos(PosCount)) * WFactor, TOffset + (((LSurface(PosCount) - MinL) / (MaxL - MinL))) * HFactor, PntAPI)

                Do
                    PosCount = PosCount + 1

                    If LXPos(PosCount) = 0 Then Exit Do
                    Dummy = LineTo(MhDC, LOffset + (LXPos(PosCount)) * WFactor, TOffset + (((LSurface(PosCount) - MinL) / (MaxL - MinL))) * HFactor)
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 240, "Log likelihood ratio", 20
                On Error GoTo 0
            ElseIf CurrentCheck = 7 Or CurrentCheck = 22 Then
                TextOut MhDC, LOffset - 50, TOffset - 10, "0" & Trim$(CStr(Int(MaxWhite * 100) / 100)), 1 + Len(Trim$(CStr(Int((MaxWhite) * 100) / 100)))
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, "0" & Trim$(CStr(Int((((MaxWhite - MinWhite) / 2) + MinWhite) * 100) / 100)), 1 + Len(Trim$(CStr(Int((((MaxWhite - MinWhite) / 2) + MinWhite) * 100) / 100)))
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0" & Trim$(CStr(Int(MinWhite * 100) / 100)), 1 + Len(Trim$(CStr(Int((MinWhite) * 100) / 100)))
                LPn.lopnColor = RGB(196, 196, 196)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 1
                Step = (Square - (RetYPos(XOverList(RelX, RelY).Ending) - RetYPos(XOverList(RelX, RelY).Beginning))) / 10
                Dummy = MoveToEx(MhDC, LOffset + RetXPos(0) * WFactor, TOffset + (1 - (RetPlot(Y, 0) - MinWhite) / (MaxWhite - MinWhite)) * HFactor, PntAPI)

                For Y = 1 To 10
                    Offst = Int((10 - Y) * Step)
                    Dummy = MoveToEx(MhDC, LOffset + RetXPos(0 + Offst) * WFactor, TOffset + (1 - (RetPlot(Y, 0) - MinWhite) / (MaxWhite - MinWhite)) * HFactor, PntAPI)

                    For X = 1 To EndY - 1

                        If X + Offst > EndY - 1 Then
                            Z = X + Offst - EndY

                            If Z = 0 Then
                                Dummy = MoveToEx(MhDC, LOffset + RetXPos(Z) * WFactor, TOffset + (1 - (RetPlot(Y, X) - MinWhite) / (MaxWhite - MinWhite)) * HFactor, PntAPI)
                            End If

                        Else
                            Z = X + Offst
                        End If

                        'PosCount = PosCount + 1
                        Dummy = LineTo(MhDC, LOffset + RetXPos(Z) * WFactor, TOffset + (1 - (RetPlot(Y, X) - MinWhite) / (MaxWhite - MinWhite)) * HFactor)
                    Next 'X

                Next 'Y
                
                For X = 1 To Len(StrainSeq(0))
                    If RetXPos(X) = 0 Then Exit For
                    XDiffpos(X) = RetXPos(X)
                Next 'X
                LenXOverSeq = X - 1
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                PosCount = 1
                Dummy = MoveToEx(MhDC, LOffset + RetXPos(0) * WFactor, TOffset + (1 - (RetPlot(0, 0) - MinWhite) / (MaxWhite - MinWhite)) * HFactor, PntAPI)

                For X = 1 To EndY
                    'PosCount = PosCount + 1
                    Dummy = LineTo(MhDC, LOffset + RetXPos(X) * WFactor, TOffset + (1 - (RetPlot(0, X) - MinWhite) / (MaxWhite - MinWhite)) * HFactor)
                Next 'X

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 200, "Whiteness", 9
            ElseIf CurrentCheck = 8 Then

                If MaxDistX < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0" & Trim$(CStr((CInt(MaxDistX * 100) / 100))), 1 + Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Trim$(CStr((CInt(MaxDistX * 100) / 100))), Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
                End If

                If MaxDistX / 2 < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, "0" & Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), 1 + Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
                End If

                TextOut MhDC, LOffset - 50, TOffset - 10, "0.00", 4
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqBS
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(0, PosCount)) / MaxDistX)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(0, PosCount) / MaxDistX))) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(1, PosCount) / MaxDistX))) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(1, PosCount) / MaxDistX))) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(2, PosCount) / MaxDistX))) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(2, PosCount) / MaxDistX))) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 200, "Distance", 8
            ElseIf CurrentCheck = 9 Then
                On Error Resume Next

                If TOHigh < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10, "0" & Trim$(CStr((CInt(TOHigh * 100) / 100))), 1 + Len(Trim$(CStr(CInt(TOHigh * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10, Trim$(CStr((CInt(TOHigh * 100) / 100))), Len(Trim$(CStr(CInt(TOHigh * 100) / 100)))
                End If

                If TOHigh / 2 < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, "0" & Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)), 1 + Len(Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)), Len(Trim$(CStr(CInt((TOHigh / 2) * 100) / 100)))
                End If

                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0.00", 4
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqBS
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X

                For Y = 0 To TOPerms
                    PlotPos = Int((TOWinLen + TOStepSize * TOSmooth) / 2)
                    Dummy = MoveToEx(MhDC, (LOffset + PlotPos * WFactor), (TOffset + ((1 - (SmoothDSS(Y, 0) / TOHigh)) * HFactor)), PntAPI)

                    For X = 1 To Int(TOEndPlot + 1) - TOSmooth
                        PlotPos = PlotPos + TOStepSize
                        Dummy = LineTo(MhDC, (LOffset + PlotPos * WFactor), (TOffset + ((1 - (SmoothDSS(Y, X) / TOHigh)) * HFactor)))
                    Next 'X

                    If Y = 0 Then
                        LPn.lopnColor = QuaterColour
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    End If

                Next 'Y

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 180, "DSS", 3
                On Error GoTo 0
            ElseIf CurrentCheck = 23 Then

                If MaxDistX < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0" & Trim$(CStr((CInt(MaxDistX * 100) / 100))), 1 + Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Trim$(CStr((CInt(MaxDistX * 100) / 100))), Len(Trim$(CStr(CInt(MaxDistX * 100) / 100)))
                End If

                If MaxDistX / 2 < 1 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, "0" & Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), 1 + Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)), Len(Trim$(CStr(CInt((MaxDistX / 2) * 100) / 100)))
                End If

                TextOut MhDC, LOffset - 50, TOffset - 10, "0.00", 4
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqBSII
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(PosCount)) / MaxDistX)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (((MCPrintData(PosCount) / MaxDistX))) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 200, "Distance", 8
            ElseIf CurrentCheck = 14 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP) & ".000", 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen

                      
                SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
               ' For X = 1 To LenXoverSeq
               '     Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 20, PntAPI)
               '     Dummy = LineTo(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 10)
               ' Next 'X
                
                        
                    LPn.lopnColor = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                        
                    PosCount = 1
                        
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(1)) / MCMinChiP)) * HFactor, PntAPI)
                        
                    PosCount = PosCount + 1
    
                        For PosCount = 2 To Len(StrainSeq(0))
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(PosCount)) / MCMinChiP)) * HFactor)
                        Next

                    SetTextColor MhDC, 0
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 230, "Number of events", 16
            ElseIf CurrentCheck = 14 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP) & ".000", 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen

                      
                SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
               ' For X = 1 To LenXoverSeq
               '     Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 20, PntAPI)
               '     Dummy = LineTo(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 10)
               ' Next 'X
                
                        
                    LPn.lopnColor = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                        
                    PosCount = 1
                        
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(1)) / MCMinChiP)) * HFactor, PntAPI)
                        
                    PosCount = PosCount + 1
    
                        For PosCount = 2 To Len(StrainSeq(0))
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(PosCount)) / MCMinChiP)) * HFactor)
                        Next

                    SetTextColor MhDC, 0
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 230, "Number of events", 16
            ElseIf CurrentCheck = 15 Then
                
                WFactor = 500 / UBound(MCPrintPos, 1)
                Win = BSCStepWin
                TextOut MhDC, LOffset - 50, TOffset - 10, Mid$(CStr(MCMinChiP * Win) & ".000", 1, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP * Win / 2) & ".000", 1, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, "0.00", 4
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
               Dummy = MoveToEx(MhDC, LOffset, TOffset + (1 - ((MCPrintData(5, 0)) / MCMinChiP)) * HFactor, PntAPI)
               Dummy = LineTo(MhDC, LOffset + (UBound(MCPrintPos, 1)) * WFactor, TOffset + (1 - ((MCPrintData(5, 0)) / MCMinChiP)) * HFactor)
               
               Dummy = MoveToEx(MhDC, LOffset, TOffset + (1 - ((MCPrintData(5, 1)) / MCMinChiP)) * HFactor, PntAPI)
               Dummy = LineTo(MhDC, LOffset + (UBound(MCPrintPos, 1)) * WFactor, TOffset + (1 - ((MCPrintData(5, 1)) / MCMinChiP)) * HFactor)
                      
                SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Z = 1
                Dim TempXDiffPos() As Long
                ReDim TempXDiffPos(Len(StrainSeq(0)) + 200)
                For X = 1 To UBound(MCPrintPos, 1)
                    
                    TempXDiffPos(X) = MCPrintData(6, X)
                      
                Next X
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + TempXDiffPos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + TempXDiffPos(X) * WFactor, TOffset - 10)
                Next 'X
                
                        
                    LPn.lopnColor = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    For Z = 0 To 4
                        
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(Z, 1)) / MCMinChiP)) * HFactor, PntAPI)
                            
                       
                        For PosCount = 2 To UBound(MCPrintPos, 1)
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(Z, PosCount)) / MCMinChiP)) * HFactor)
                        Next
                    Next Z
                    'Now do the closed versions of the confidence intervals
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(1, 1)) / MCMinChiP)) * HFactor, PntAPI)
                            
                       
                        For PosCount = 2 To UBound(MCPrintPos, 1)
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / MCMinChiP)) * HFactor)
                        Next
                        For PosCount = UBound(MCPrintPos, 1) To 1 Step -1
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / MCMinChiP)) * HFactor)
                        Next
                        Dummy = LineTo(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(1, 1)) / MCMinChiP)) * HFactor)
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(3, 1)) / MCMinChiP)) * HFactor, PntAPI)
                        For PosCount = 2 To UBound(MCPrintPos, 1)
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(3, PosCount)) / MCMinChiP)) * HFactor)
                        Next
                        For PosCount = UBound(MCPrintPos, 1) To 1 Step -1
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(4, PosCount)) / MCMinChiP)) * HFactor)
                        Next
                        Dummy = LineTo(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - ((MCPrintData(3, 1)) / MCMinChiP)) * HFactor)
                        
                        
                    SetTextColor MhDC, 0
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                
                TextOut MhDC, LOffset - 75, 290, "Breakpoints per " & Trim(Str(Win)) & "nt window", Len("Breakpoints per " & Trim(Str(Win)) & "nt window")
            ElseIf CurrentCheck = 20 Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MinP(Seq1, Seq2)), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MinP(Seq1, Seq2) / 2), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                For X = 1 To Len(GCXOverSeq(0))
                    Dummy = MoveToEx(MhDC, LOffset + GCXDiffPos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + GCXDiffPos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                For X = 0 To NextNo

                    If MaskSeq(X) < 2 Then
                        Unmasked = Unmasked + 1
                    End If

                Next 'X

                GlobalAddj = (Unmasked * (Unmasked - 1) / 2)
                COff = -Log10(LowestProb / GlobalAddj)

                If COff <= MinP(Seq1, Seq2) Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinP(Seq1, Seq2)) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinP(Seq1, Seq2)) * HFactor
                End If

                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor
                    CurPPos = CurPPos + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "-Log(KA P-Value)", 16
            End If
            If (RelX Or RelY) > 0 Then
                If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
                    Call FindSubSeqRDP
                ElseIf XOverList(RelX, RelY).ProgramFlag = 6 Or XOverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                    Call FindSubSeqPP
                ElseIf XOverList(RelX, RelY).ProgramFlag = 2 Or XOverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
                    Call FindSubSeqBS
                ElseIf (XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1 Then
                    Call FindSubSeqGC2
                ElseIf (XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum) And pMCTripletFlag = 0 Then
                    Call FindSubSeqMC
                ElseIf (XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum) Then
                    Call FindSubSeqChi
                ElseIf (XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum) Then
                    Call FindSubSeqSS(SSOLoSeq)
                End If
            End If
        Else

            If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
                
                
                TextOut MhDC, LOffset - 40, TOffset - 10, "1.0", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, "0.5", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                
                Call FindSubSeqRDP
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X

                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 0) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 0) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 0) / (XOverWindowX + 1)) * HFactor)
                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 1) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 1) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 1) / (XOverWindowX + 1)) * HFactor)
                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                Dummy = MoveToEx(MhDC, LOffset + XDiffpos(0) * WFactor, TOffset + (1 - XOverHomologyNum(1, 2) / (XOverWindowX + 1)) * HFactor, PntAPI)

                For X = 1 To LenXOverSeq
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset + (1 - XOverHomologyNum(X + 1, 2) / (XOverWindowX + 1)) * HFactor)
                Next 'X

                XDiffpos(LenXOverSeq) = XDiffpos(LenXOverSeq)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - XOverHomologyNum(1, 2) / (XOverWindowX + 1)) * HFactor)
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "Pairwise identity", 17
            ElseIf XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MinP(Seq1, Seq2)), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MinP(Seq1, Seq2) / 2), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
                For X = 1 To Len(GCXOverSeq(0))
                    Dummy = MoveToEx(MhDC, LOffset + GCXDiffPos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + GCXDiffPos(X) * WFactor, TOffset - 10)
                Next 'X
                 
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                For X = 0 To NextNo

                    If MaskSeq(X) < 2 Then
                        Unmasked = Unmasked + 1
                    End If

                Next 'X

                GlobalAddj = (Unmasked * (Unmasked - 1) / 2)
                COff = -Log10(LowestProb / GlobalAddj)

                If COff <= MinP(Seq1, Seq2) Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MinP(Seq1, Seq2)) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MinP(Seq1, Seq2)) * HFactor
                End If

                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                CurPPos = 0

                Do While MCPrintData(CurPPos) > 0
                    MoveToEx MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor, PntAPI
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 1) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 1) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + HFactor
                    LineTo MhDC, LOffset + MCPrintPos(CurPPos, 0) * WFactor, TOffset + (1 - MCPrintData(CurPPos) / MinP(Seq1, Seq2)) * HFactor
                    CurPPos = CurPPos + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 220, "-Log(KA P-Value)", 16
            ElseIf XOverList(RelX, RelY).ProgramFlag = 2 Or XOverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
                TextOut MhDC, LOffset - 40, TOffset - 10, "100", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, " 50", 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "  0", 3
                
                Call FindSubSeqBS
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                LPn.lopnColor = RGB(190, 190, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Green
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LPn.lopnColor = Purple
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                PosCount = 0
                Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor, PntAPI)
                PosCount = 1

                Do

                    If PosCount > Len(StrainSeq(0)) - 3 Then
                        Exit Do
                    ElseIf MCPrintPos(PosCount) = 0 Then
                        Exit Do
                    ElseIf (MCPrintPos(PosCount)) - (MCOverlapR) > Len(StrainSeq(0)) Then
                        Exit Do
                    End If

                    Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(2, PosCount)) / 100)) * HFactor)
                    PosCount = PosCount + 1
                Loop

                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 240, "Bootstrap support (%)", 21
            ElseIf XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 2, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                If MCTripletFlag = 0 Then
                    COff = -Log10(LowestProb / MCCorrection)
                Else
                    COff = -Log10(LowestProb / MCCorrect)
                End If

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                COff = -Log10(LowestProb)

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                If MCTripletFlag = 0 Then
                    LPn.lopnStyle = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    
                    For X = 1 To LenXOverSeq
                        Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 20, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 10)
                    Next 'X

                    For Y = 0 To 2
                        If Y = 0 Then
                            PColIn = Yellow
                        ElseIf Y = 1 Then
                            PColIn = Green
                        ElseIf Y = 2 Then
                            PColIn = Purple
                        End If
                        
                        LPn.lopnColor = PColIn
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        
                        PosCount = 1
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(Y, PosCount)) / MCMinChiP)) * HFactor, PntAPI)
                        
                        PosCount = PosCount + 1
    
                        Do
                            If PosCount > UBound(MCPrintPos) Then
                                Exit Do
                            End If
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(Y, PosCount)) / MCMinChiP)) * HFactor)
                            PosCount = PosCount + 1
                        Loop
                    Next Y

                Else
                    LPn.lopnColor = QBColor(0)
                    LPn.lopnStyle = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen

                    For X = 1 To Len(MCXoverSeq(0))
                        Dummy = MoveToEx(MhDC, LOffset + MCXDiffPos(X) * WFactor, TOffset - 20, PntAPI)
                        Dummy = LineTo(MhDC, LOffset + MCXDiffPos(X) * WFactor, TOffset - 10)
                    Next 'X
                    
                    PosCount = 1
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1) - MCFullOR) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount)) / MCMinChiP)) * HFactor, PntAPI)
                    PosCount = 2

                    Do

                        If PosCount > UBound(MCPrintPos) Then
                            Exit Do
                        
                        End If

                        Dummy = LineTo(MhDC, LOffset + MCPrintPos(PosCount) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount)) / MCMinChiP)) * HFactor)
                        PosCount = PosCount + 1
                    Loop

                End If
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 210, "-Log(P[Chi2])", 13
            ElseIf XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
                TextOut MhDC, LOffset - 40, TOffset - 10, Mid$(CStr(MCMinChiP), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor / 2, Mid$(CStr(MCMinChiP / 2), 1, 3), 3
                TextOut MhDC, LOffset - 40, TOffset - 10 + HFactor, "0.0", 3
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen

                COff = -Log10(LowestProb / MCCorrection)
                
                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If

                COff = -Log10(LowestProb)

                If COff <= MCMinChiP Then
                    MoveToEx MhDC, LOffset - 10, TOffset + (1 - COff / MCMinChiP) * HFactor, PntAPI
                    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor + 10, TOffset + (1 - COff / MCMinChiP) * HFactor
                End If
                 
                SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + MCPrintPos(X) * WFactor, TOffset - 10)
                Next 'X
                
                        
                    LPn.lopnColor = 0
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                        
                    PosCount = 1
                        
                    Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(1)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(1)) / MCMinChiP)) * HFactor, PntAPI)
                        
                    PosCount = PosCount + 1
    
                        For PosCount = 2 To LenXOverSeq - 1
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - (-Log10(MCPrintData(PosCount)) / MCMinChiP)) * HFactor)
                        Next

                    SetTextColor MhDC, 0
                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 210, "-Log(P[Chi2])", 13
            ElseIf XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                On Error Resume Next
                SSLo = SSLo + 0.00001
                SSUp = SSUp + 0.00001
                TextOut MhDC, LOffset - 45, TOffset - 10, Mid$(CStr(SSUp), 2, 4), 4
                TextOut MhDC, LOffset - 45, TOffset - 10 + HFactor / 2, Mid$(CStr(SSLo + (SSUp - SSLo) / 2), 2, 4), 4
                TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(SSLo), 1, 5), 5
                
                
                
                LPn.lopnColor = RGB(0, 0, 0)
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Call FindSubSeqSS(SSOLoSeq)
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((0 - SSLo) / (SSUp - SSLo))) * HFactor)
                
                'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17

                For X = 1 To 15
                    LPn.lopnColor = RGB(X * (255 / 15), (255 - (255 / 15) * (X - 1)), (255 - (255 / 15) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + X * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + X * 20)
                    OutS = "P" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + X * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                For X = 1 To 9
                    LPn.lopnColor = RGB((255 - (255 / 9) * (X - 1)), X * (255 / 9), (255 - (255 / 9) * (X - 1)))
                    Pen = CreatePenIndirect(LPn)
                    SelectObject MhDC, Pen
                    Dummy = MoveToEx(MhDC, 600, TOffset - 40 + (X + 15) * 20, PntAPI)
                    Dummy = LineTo(MhDC, 650, TOffset - 40 + (X + 15) * 20)
                    OutS = "S" + Trim$(Str(X))
                    TextOut MhDC, 660, TOffset - 40 + (X + 15) * 20 - 10, OutS, Len(OutS)
                Next 'X
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 2
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                Dummy = MoveToEx(MhDC, -10 + LOffset + 0 * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - ((-CriticalZ - SSLo) / (SSUp - SSLo))) * HFactor)
                
                LPn.lopnColor = QBColor(0)
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
        
                    
                    For X = 1 To 15
                        LPn.lopnColor = RGB(255 / X, X * (255 / 15), 255)
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        PosCount = 1
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(0, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X
                    
                    For X = 1 To 9
                        LPn.lopnColor = RGB(255 / X, 128, X * (255 / 15))
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                        
                        PosCount = 1
                        
                        Dummy = MoveToEx(MhDC, LOffset + (MCPrintPos(0)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, 0) - SSLo) / (SSUp - SSLo))) * HFactor, PntAPI)
                        For Z = 1 To Len(StrainSeq(0)) - SSWinLen Step SSStep
                            If MCPrintPos(PosCount) = 0 Then Exit For
                            Dummy = LineTo(MhDC, LOffset + (MCPrintPos(PosCount)) * WFactor, TOffset + (1 - ((MCPrintData(1, X, PosCount) - SSLo) / (SSUp - SSLo))) * HFactor)
                            PosCount = PosCount + 1
                        Next Z
                    Next X


                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 190, "Z Value", 7
                On Error GoTo 0
            ElseIf XOverList(RelX, RelY).ProgramFlag = 6 Or XOverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
                On Error Resume Next
                
                For X = 1 To LenXOverSeq
                    Dummy = MoveToEx(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 20, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + XDiffpos(X) * WFactor, TOffset - 10)
                Next 'X
                
                Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
                Red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
                Blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
                
                
                TextOut MhDC, LOffset - 45, TOffset - 10, "1.00", 4
                TextOut MhDC, LOffset - 45, TOffset - 10 + HFactor / 2, Mid$(CStr(CDbl(MRV + (1 - MRV) / 2)), 1, 4), 4
                If MRV < 0 Then
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(MRV), 1, 5), 5
                Else
                    TextOut MhDC, LOffset - 50, TOffset - 10 + HFactor, Mid$(CStr(MRV), 1, 4), 4
                End If
                
                SetTextColor MhDC, Red
                Out$ = StraiName(Seq1)
                TextOut MhDC, LOffset, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Green
                Out$ = StraiName(Seq2)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 3, TOffset + HFactor + 60, Out$, Len(Out$)
                SetTextColor MhDC, Blue
                Out$ = StraiName(Seq3)
                TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) / 1.5, TOffset + HFactor + 60, Out$, Len(Out$)
                 SetTextColor MhDC, 0
                 
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                
                
                'TextOut MhDC, 580, TOffset + X * 20 - 10, StraiName(Form5.Combo1.ListIndex - 1) & " Scanned against:", Len(StraiName(Form5.Combo1.ListIndex - 1)) + 17
      
                LPn.lopnColor = ThreeQuaterColour
                LPn.lopnStyle = 0
                Pen = CreatePenIndirect(LPn)
                SelectObject MhDC, Pen
                For Y = 0 To NumberOfSeqs
                    If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
                        
                                                
                        Dummy = MoveToEx(MhDC, LOffset + (XDiffpos(1)) * WFactor, TOffset + HFactor - (((PPWinScore(1, Y) - MRV) / (MaRV - MRV)) * HFactor), PntAPI)
                    
                        For Z = 2 To LenXOverSeq
                            Dummy = LineTo(MhDC, LOffset + (XDiffpos(Z)) * WFactor, TOffset + HFactor - (((PPWinScore(Z, Y) - MRV) / (MaRV - MRV)) * HFactor))
                        Next Z
                    End If
                Next Y
                    
                For X = 0 To 2
                    If X = 0 Then
                        Y = Seq1
                        LPn.lopnColor = Green
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    ElseIf X = 1 Then
                        Y = Seq2
                        LPn.lopnColor = Blue
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    ElseIf X = 2 Then
                        Y = Seq3
                        LPn.lopnColor = Red
                        Pen = CreatePenIndirect(LPn)
                        SelectObject MhDC, Pen
                    End If
                                           
                                                
                        Dummy = MoveToEx(MhDC, LOffset + (XDiffpos(1)) * WFactor, TOffset + HFactor - (((PPWinScore(1, Y) - MRV) / (MaRV - MRV)) * HFactor), PntAPI)
                    
                        For Z = 2 To LenXOverSeq
                            Dummy = LineTo(MhDC, LOffset + (XDiffpos(Z)) * WFactor, TOffset + HFactor - (((PPWinScore(Z, Y) - MRV) / (MaRV - MRV)) * HFactor))
                        Next Z
                    
                Next X


                LoFnt = CreateFont(20, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
                SelectObject MhDC, LoFnt
                TextOut MhDC, LOffset - 70, 190, "Correlation", 11
                On Error GoTo 0
            End If

        End If

    End If

    'Clear up and close  emf
    Pen = SelectObject(MhDC, OldPen)
    DeleteObject (Pen)
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject (LoFnt)
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    XX = CurDir
    If CopyFlag = 1 Then
        Clipboard.Clear
        Clipboard.SetData LoadPicture("tmp2.emf"), 3
        On Error Resume Next
        Kill "tmp2.emf"
        On Error GoTo 0
    End If

End Sub

Public Sub MultTreeWin()

    'On Error Resume Next
    Dim TTreeTypeFlag As Integer, AddjNum As Integer
    Dim X As Long, OS As Long
    Dim OldFontSize As Double
    OldFontSize = 8.5
    ReDim ColourSeq(PermNextNo)

    AddjNum = 14

    Form1.SSPanel1.Caption = "Drawing Trees"
    Form2.Label1(0) = "UPGMA Ignoring Recombination"
    
    'Do the "Ignoring recombination tree"

    If TreeImage(0) = 0 Then
        '"UPGMA Ignoring Recombination" has not yet been drawn
        'TTreeTypeFlag = TreeTypeFlag
        'TreeTypeFlag = 0

        Call UPGMA(0, 0)
        Call DrawTree

        TreeImage(0) = 1
        
        TreeImage(0) = 1
        
    
    End If
    UnModNextno
    ExtraDx = DoTreeColour(Form2.Picture2(0), 0, 0)
    If Form2.VScroll1(0).Max < Form2.Picture2(0).Height Then
        Form2.VScroll1(0).Value = 0
        Form2.VScroll1(1).Value = 0
        Form2.VScroll1(2).Value = 0
        Form2.VScroll1(3).Value = 0
    End If
    Call Treedrawing(TreeBlocksL(), TBLLen, 1, StraiName(), -Form2.VScroll1(0).Value, 0, 0, TreeDraw(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(0))
    ModNextno
    'Write over names so that coloured ones can be put in their place
    
    'ExtraDx = DoTreeColour(Form2.Picture2(3), 0, 0)
   
    NextNo = TreeNextno
    
    
    If Form1.ProgressBar1.Value < 90 Then
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
    End If

    'Do "UPGMA of All Regions" tree
        If XOverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
            EN = 1
        Else
            EN = XOverList(RelX, RelY).Ending + 1
        End If
        If XOverList(RelX, RelY).Beginning = 1 Then
            BE = Len(StrainSeq(0))
        Else
            BE = XOverList(RelX, RelY).Beginning - 1
        End If
        Form2.Label1(1) = "UPGMA of Region " + Trim$(CStr(EN)) + " - " + Trim$(CStr(BE)) '"UPGMA of Recombinant Region"

    
    
    
    If TreeImage(1) = 0 Then 'And XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
        'If the tree hasn't been drawn yet and what we're dealing with is an RDP result.
        TTreeTypeFlag = TreeTypeFlag
        TreeTypeFlag = 1
        'Save a backup of the refererence sequence number (drawing this tree requires that it find a new set of references)
        OS = SpacerNo

        'Call RTSpacerFind
        Call RecUPGMAIV
        ExtraDx = DoTreeColour(Form2.Picture2(1), 0, 1)
            
        TreeImage(1) = 1
        If XOverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
            EN = 1
        Else
            EN = XOverList(RelX, RelY).Ending + 1
        End If
        If XOverList(RelX, RelY).Beginning = 1 Then
            BE = Len(StrainSeq(0))
        Else
            BE = XOverList(RelX, RelY).Beginning - 1
        End If
        Form2.Label1(1) = "UPGMA of Region " + Trim$(CStr(EN)) + " - " + Trim$(CStr(BE)) '"UPGMA of Recombinant Region"
        
        SpacerNo = OS
        
    
    End If
    
    Call Treedrawing(TreeBlocksL(), TBLLen, 1, StraiName(), -Form2.VScroll1(1).Value, 1, 0, TreeDraw(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(1))
    
    If Form1.ProgressBar1.Value < 90 Then
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
    End If

    'Do the "UPGMA of Recombinant Region" tree
    Form2.Label1(2) = "UPGMA of Region " + Trim$(CStr(XOverList(RelX, RelY).Beginning)) + " - " + Trim$(CStr(XOverList(RelX, RelY).Ending)) '"UPGMA of Recombinant Region"

    If TreeImage(2) = 0 Then
        
        Call RecUPGMAII
        ExtraDx = DoTreeColour(Form2.Picture2(2), 0, 2)
        TreeImage(2) = 1
        
    
    End If
    
    Call Treedrawing(TreeBlocksL(), TBLLen, 1, StraiName(), -Form2.VScroll1(2).Value, 2, 0, TreeDraw(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(2))
    
    If Form1.ProgressBar1.Value < 90 Then
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
    End If

    'Do the "UPGMA of Non-Recombinant Regions" tree
    Form2.Label1(3) = "UPGMA of Non-Recombinant Regions"
    Form2.Picture2(3).AutoRedraw = True

    If TreeImage(3) = 0 Then

        Call RecUPGMAIII

        TreeImage(3) = 1
           
        ExtraDx = DoTreeColour(Form2.Picture2(3), 0, 3)
    End If
    
    Call Treedrawing(TreeBlocksL(), TBLLen, 1, StraiName(), -Form2.VScroll1(3).Value, 3, 0, TreeDraw(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(3))
    

    If Form1.ProgressBar1.Value < 90 Then
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
    End If

        
    ReDim TTFlag(3, 3)

    For X = 0 To 3
        TTFlag(X, 0) = 1
    Next 'X

    Form2.Picture2(0).FontSize = OldFontSize
    Form1.ProgressBar1.Value = 0
    Form2.ProgressBar1.Value = 0
    ReDim CurTree(3)
    Form2.Visible = True
    Form1.SSPanel1.Caption = ""
    Screen.MousePointer = 0
    Form2.Refresh
End Sub

Public Sub LXoverB()
    'This subroutine executes LARD
    If LRDRegion > 2 Then LRDRegion = 2
    If LRDRegion < 1 Then LRDRegion = 1
    Dim TSeq(2) As String, X As Long
    For X = 1 To Len(StrainSeq(0))
        
        TSeq(0) = TSeq(0) + Chr(SeqNum(X, Seq1) - 1)
        TSeq(1) = TSeq(1) + Chr(SeqNum(X, Seq2) - 1)
        TSeq(2) = TSeq(2) + Chr(SeqNum(X, Seq3) - 1)
        
    Next X
    
    Dim PID As Long, ProcessID As Long, LastLen As Long, SCount As Long, FLen As Long, NewSurface As Long, Pict As Long, CurPos As Long, Count As Long, RetVal As Long, NewPos As Long
    Dim PntAPI As POINTAPI
    Dim OldDir As String, LARDCLine As String, TitleTmp As String

    Const STILL_ACTIVE = &H103
    ReDim LXPos(Len(StrainSeq(0)))
    
    Form1.ProgressBar1.Value = 0
    'Disables various parts of the display area
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.ProgressBar1.Value = 3
    Form1.SSPanel1.Caption = "Executing LARD"
    OldDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    
    'Writes the alignment file for LARD
    Open "lardin" For Output As #1
    Dim LRDWin As Byte, LRDWinLen As Long
    
    
    'LRDWin = 1
    'LRDWinLen = 200
    
    
    If LRDWin = 0 Then
        
        NumWins = 1
        
        Print #1, " 3  " + CStr(Len(StrainSeq(0))) ' 200"
        Print #1, "s1"
        Print #1, TSeq(0)
        Print #1, "s2"
        Print #1, TSeq(1)
        Print #1, "s3"
        Print #1, TSeq(2)
        
    Else
        
        'LRDWinLen = 200
        NumWins = (Len(StrainSeq(0)) - LRDWinLen) / LRDStep
        
        For X = 0 To NumWins - 1
            Print #1, " 3  " + CStr(LRDWinLen)
            Z = X * LRDStep + 1
            Print #1, "s1"
            Print #1, Mid$(TSeq(0), Z, LRDWinLen)
            Print #1, "s2"
            Print #1, Mid$(TSeq(1), Z, LRDWinLen)
            Print #1, "s3"
            Print #1, Mid$(TSeq(2), Z, LRDWinLen)
            Print #1, ""
        Next X
    End If
    Close #1
    'Exit Sub
    'Creates a fake outfile and then kills it
    Open "likelihood.surface" For Binary As 1
    Put #1, 1, ""
    Close #1
    On Error Resume Next
    Kill "likelihood.surface"
    On Error GoTo 0
    'Creates a fake stackdump file and then kills it
    Open "LARD.EXE.stackdump" For Output As #1
    Close #1
    Kill "LARD.EXE.stackdump"
    'Constructs the LARD command line
    LARDCLine = "lard.exe"
    
    If LRDWin = 0 Then
        LARDCLine = LARDCLine + " -r" + Trim(Str(CInt(LRDRegion)))
    Else
        LARDCLine = LARDCLine + " -r1"
    End If
    If LRDModel = 0 Or LRDModel = 1 Then

        If LRDModel = 0 Then
            LARDCLine = LARDCLine & " -mHKY"
        Else
            LARDCLine = LARDCLine & " -mF84"
        End If

        LARDCLine = LARDCLine & " -t" & LRDTvRat

        If LRDModel = 0 Or (LRDModel = 1 And LRDBaseFreqFlag = 1) Then

            If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
                LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
            End If

        End If

    Else
        LARDCLine = LARDCLine & " -mREV"

        If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
            LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
        End If

        If LRDACCoeff <> 1 Or LRDAGCoeff <> 1 Or LRDATCoeff <> 1 Or LRDCGCoeff <> 1 Or LRDCTCoeff <> 1 Then
            LARDCLine = LARDCLine & " -t" & LRDACCoeff & " " & LRDAGCoeff & " " & LRDATCoeff & " " & LRDCGCoeff & " " & LRDCTCoeff
        End If

    End If
    
    If LRDWin = 1 Then
        LARDCLine = LARDCLine + " -n" + CStr(Int(NumWins))
        LARDCLine = LARDCLine + " -u" + CStr(CLng(LRDWinLen / 2))
    Else
        LARDCLine = LARDCLine & " -w -s" & LRDStep
        LARDCLine = LARDCLine & " -z" + Trim(Str(CInt(LRDStep * 2)))
    End If
    
    
   

    If LRDCodon1 <> LRDCodon2 Or LRDCodon1 <> LRDCodon3 Then
        LARDCLine = LARDCLine & " -c" & LRDCodon1 & " " & LRDCodon2 & " " & LRDCodon3
    End If

    If LRDCategs > 0 Then
        LARDCLine = LARDCLine & " -g" & LRDCategs
        LARDCLine = LARDCLine & " -a" & LRDShape
    End If
    LARDCLine = LARDCLine & " -vp"
    LARDCLine = LARDCLine & " <lardin"
    'Creates a batch file so that lard can be executed with a command line
    
    
    'LARDCLine = "cmd.exe /c " + LARDCLine + " >c:\test.txt"
    'LARDCLine = "cmd.exe /c ping /? >c:\test.txt"
    X = X
    Open "lard.bat" For Output As #1
    
    Do
        Pos = InStr(1, LARDCLine, ",")
        If Pos = 0 Then Exit Do
        Mid$(LARDCLine, Pos, 1) = "."
    Loop
    Print #1, LARDCLine
    Close #1
    'Checks to see if a previously aborted run of lard was made and terminates it if necessary

    If lProcess > 0 Then
        GetExitCodeProcess lProcess, nRet
        TitleTmp = Space$(256)
        nRet = GetWindowText(lWndJob, TitleTmp, Len(TitleTmp))

        If nRet Then
            TitleTmp = UCase$(left$(TitleTmp, nRet))

            If InStr(TitleTmp, "FINISHED") = 1 Then

                Call SendMessage(lWndJob, WM_CLOSE, 0, 0)

            End If

        End If

        GetExitCodeProcess lProcess, nRet

        If nRet = STILL_ACTIVE Then
            TerminateProcess lProcess, nRet
        End If

        CloseHandle lProcess
        lProcess = 0
    End If
    
    'ProcessID = Shell("lard.bat ", 0)
    'Do
    
    Dim OP As String
    'ProcessID = Shell("lard.bat", 1)
    'OP = GetCommandOutput(LARDCLine, True, True)
    'SS = GetTickCount
    
    Form1.Command25.Enabled = True
    
    Dim EC As Long
    EC = CInt(Len(StrainSeq(0)) / LRDStep) + 2
    'pvalcalc = 2*lik ratio chisquare with 4 df per breakpoint
    If LRDRegion = 2 Then
        
        ExpectFL = EC * EC * 22
            
    End If
    
    If LRDWin = 1 Then
        OP = GetCommandOutput("lard.bat", LRDRegion, True, False)
    Else
        OP = GetCommandOutput("lard.bat", LRDRegion, True, True)
    End If
    'EE = GetTickCount
    'TT = EE - SS '3.734,3.735,3.703 -sleep100, 1.703,1.781,1.734-sleep0
    If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                ChDir OldDir
                ChDrive OldDir
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.Frame7.Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6.Enabled = True
                'I've temporarily removed this to try stabilise the program
                'GetExitCodeProcess lProcess, tExitCode
                'TerminateProcess lProcess, tExitCode
                'CloseHandle lProcess
                Exit Sub
    End If
    XX = Len(OP)
    
    
    Pos = InStr(1, OP, "No recombination: lik=", vbBinaryCompare)
    Pos = Pos + 22
    Pos2 = InStr(Pos + 1, OP, Chr(13), vbBinaryCompare)
    If Pos > 22 Then
        MaxL = Mid$(OP, Pos, Pos2 - Pos)
    
    End If
    
    If LRDWin = 0 Then
    
        Open "likelihood.surface" For Binary As #1
            VarString = String$(LOF(1), " ")
            FLen = LOF(1)
            
            Get #1, 1, VarString
            Close #1
            CurPos = 0
            
            If FLen <> LastLen Then
                LastLen = FLen
                
                If LRDRegion = 1 Then
                
                    ReDim LXPos(0, EC)
                    ReDim LSurface(EC)
                    Do
                        NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
        
                        If NewPos > 0 Then
                            Count = Count + 1
                            
                            If Count > UBound(LXPos, 2) Then
                                ReDim Preserve LXPos(0, Count * 2)
                            End If
                            LXPos(0, Count) = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                        Else
                            Exit Do
                        End If
        
                        NewSurface = InStr(NewPos + 1, VarString, Chr$(13), vbBinaryCompare)
        
                        If NewSurface > 0 Then
                            
                            If Count > UBound(LSurface, 1) Then
                                ReDim Preserve LSurface(Count * 2)
                            End If
                            LSurface(Count) = Val(Mid$(VarString, NewPos + 1, NewSurface - NewPos))
                            If MaxL = 0 Then
                                MaxL = LSurface(Count)
                                MinL = LSurface(Count) - 50
                                Form1.Picture10.ScaleMode = 3
                                Form1.Picture7.ScaleMode = 3
                                Form1.Picture7.BackColor = BackColours
                                Form1.Picture10.BackColor = BackColours
                                Form1.Picture10.ScaleMode = 3
                                Form1.Picture7.ScaleMode = 3
        
                                Call DoAxes(Len(StrainSeq(0)), -1, MaxL - MinL, 0, 1, "Log likelihood ratio")
        
                            End If
        
                        Else
                            Count = Count - 1
        
                            If SCount = 0 Then SCount = 2
                            Form1.Picture7.DrawWidth = 1
        
                            If TManFlag = -1 Then
        
                                Call Highlight
        
                            End If
        
                            Form1.Picture7.ForeColor = 0
                            Pict = Form1.Picture7.hdc
                            MoveToEx Pict, 30 + (LXPos(0, SCount)) * XFactor, PicHeight - (15 + (1 - ((LSurface(SCount) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
        
                            For X = SCount + 1 To Count
                                LineTo Pict, 30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
                            Next 'X
        
                            Form1.Picture7.Refresh
                            Form1.Picture10.Refresh
                            SCount = Count - 1
                            Exit Do
                        End If
        
                        Form1.ProgressBar1.Value = 95 + (LXPos(0, Count) / Len(StrainSeq(0))) * 5
                        CurPos = NewSurface + 1
                    Loop
                Else
                    Dim Count2 As Long, Numcounts As Long
                    Numcounts = EC * (EC) / 2 + 1
                    ReDim LXPos(1, Numcounts)
                    Count2 = 1
                    CurPos = 0
                    ReDim LSurface(Numcounts)
                    Do
                        NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
        
                        If NewPos > 0 Then
                            Count = Count + 1
                            
                            co1 = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                            CurPos = NewPos
                            NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
                            If NewPos > 0 Then
                                co2 = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                            End If
                            CurPos = NewPos
                            
                            
                            If Count > UBound(LXPos, 2) Then ReDim Preserve LXPos(1, Count * 2)
                            LXPos(0, Count) = co1
                            LXPos(1, Count) = co2
                        Else
                            Exit Do
                        End If
        
                        NewSurface = InStr(NewPos + 1, VarString, Chr$(13), vbBinaryCompare)
        
                        If NewSurface > 0 Then
                            
                            If Count > UBound(LSurface, 1) Then ReDim Preserve LSurface(Count * 2)
                            LSurface(Count) = Val(Mid$(VarString, NewPos + 1, NewSurface - NewPos))
                            
        
                        Else
                            
                            
        
                            
                            Form1.Picture7.DrawWidth = 1
        
                            If TManFlag = -1 Then
        
                                Call Highlight
        
                            End If
        
                            Form1.Picture7.ForeColor = 0
                            
                            
                            
                                For X = 1 To Count
                                    Picture7.Line (30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + PicHeight - 35)), 0, B
                                Next 'X
                            
                            Form1.Picture7.Refresh
                            Form1.Picture10.Refresh
                            SCount = Count - 1
                            Exit Do
                        End If
        
                        Form1.ProgressBar1.Value = 95 + (Count2 / EC) * 5
                        CurPos = NewSurface + 1
                    Loop
                End If
    
            End If
    Else
        'read positions from op
        ReDim LXPos(0, NumWins)
        ReDim LSurface(NumWins)
        Open "screen.out" For Output As #1
        Print #1, OP
        Close #1
        X = X
        Pos = InStr(1, OP, "cross", vbBinaryCompare)
        If Pos > 0 Then
            LastPos = Pos
            
            For X = 0 To Int(NumWins) - 1
                For Y = 0 To 2
                    Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                    LastPos = Pos
                    XX = Mid$(OP, Pos, 20)
                    X = X
                Next Y
                TPos = Pos
                Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                LastPos = Pos
                XX = Mid$(OP, TPos + 1, Pos - TPos - 1)
                LSurface(X + 1) = CDbl(Mid$(OP, TPos + 1, Pos - TPos - 1))
                LXPos(0, X + 1) = (LRDStep * X) + LRDWinLen / 2
            Next X
        Else
            'handle this sometime
        End If
    End If
    'MaxL = 0
    MinL = 1000000
    
    
    'If LRDRegion = 2 Then
    '    'get minval at every position along the alignment
    '    Dim maxlik() As Double
    '
        
    'End If
    'If LRDRegion = 1 Then
    
    
   If LRDRegion = 2 Then
        Dim MaxReg() As Double
        ReDim MaxReg(Len(StrainSeq(0)))
        For X = 1 To Count
            MaxReg(LXPos(1, X) - LXPos(0, X)) = MaxL + 1000000
           
        Next X
        For X = 1 To Count
            If MaxReg(LXPos(1, X) - LXPos(0, X)) > LSurface(X) Then
                MaxReg(LXPos(1, X) - LXPos(0, X)) = LSurface(X)
            End If
        Next X
    End If
    
    
   Dim XP1 As Long, XP2 As Long, MinPA As Double, MinPA2 As Double, MinLA As Double, MinLA2 As Double, DB As Long, DE As Long
   
   If ManFlag <> 6 And (RelX > 0 Or RelY > 0) Then
        
        BE = XOverList(RelX, RelY).Beginning
        EN = XOverList(RelX, RelY).Ending + LRDStep
        If LRDRegion = 1 Then
            BE = BE - LRDStep
            EN = EN + LRDStep
        End If
        If EN > Len(StrainSeq(0)) Then EN = EN - Len(StrainSeq(0))
        If BE < 1 Then BE = BE + Len(StrainSeq(0))
        MinLA = 100000000
        MinLA2 = 100000000
        If LRDWin = 0 Then
            If LRDRegion = 1 Then 'look for maxpeaks close to estimated breakpoints
                 For X = 1 To Count
             
                     'If MaxL < LSurface(X) Then
                     '    MaxL = LSurface(X)
                     If MinL > LSurface(X) Then
                         MinL = LSurface(X)
                     End If
                     If BE < EN Then
                     
                        If LXPos(0, X) >= BE And LXPos(0, X) <= EN Then
                            DB = Abs(LXPos(0, X) - BE)
                            If DB > Abs(LXPos(0, X) + Len(StrainSeq(0)) - BE) Then
                                DB = Abs(LXPos(0, X) + Len(StrainSeq(0)) - BE)
                            End If
                            DE = Abs(LXPos(0, X) - EN)
                            If DE > Abs(LXPos(0, X) + Len(StrainSeq(0)) - EN) Then
                                DE = Abs(LXPos(0, X) + Len(StrainSeq(0)) - EN)
                            End If
                            If DB < DE Then
                                If LSurface(X) < MinLA Then
                                    MinLA = LSurface(X)
                                    XP1 = LXPos(0, X)
                                End If
                            Else
                                If LSurface(X) < MinLA2 Then
                                    MinLA2 = LSurface(X)
                                    XP2 = LXPos(0, X)
                                End If
                            End If
                        End If
                     Else
                        If LXPos(0, X) <= BE And LXPos(0, X) >= EN Then
                            DB = Abs(LXPos(0, X) - BE)
                            If DB < Abs(LXPos(0, X) + Len(StrainSeq(0)) - BE) Then
                                DB = Abs(LXPos(0, X) + Len(StrainSeq(0)) - BE)
                            End If
                            DE = Abs(LXPos(0, X) - EN)
                            If DE < Abs(LXPos(0, X) + Len(StrainSeq(0)) - EN) Then
                                DE = Abs(LXPos(0, X) + Len(StrainSeq(0)) - EN)
                            End If
                            If DB < DE Then
                                If LSurface(X) < MinLA Then
                                    MinLA = LSurface(X)
                                    XP1 = LXPos(0, X)
                                End If
                            Else
                                If LSurface(X) < MinLA2 Then
                                    MinLA2 = LSurface(X)
                                    XP2 = LXPos(0, X)
                                End If
                            End If
                        End If
                     End If
                     'if lxpos(x)
             
                 Next 'X
             Else
                Dim MinlPos() As Double
                'redim MatrixL(
                ReDim MinlPos(Len(StrainSeq(0)))
                For X = 1 To Len(StrainSeq(0))
                    MinlPos(X) = 1000000
                Next X
                For X = 1 To Count
                    If MinL > LSurface(X) Then
                        MinL = LSurface(X)
                    End If
                    If LSurface(X) = MaxReg(LXPos(1, X) - LXPos(0, X)) Then
                        For Y = LXPos(0, X) To LXPos(1, X)
                            If MinlPos(Y) > LSurface(X) Then
                                MinlPos(Y) = LSurface(X)
                            End If
                        Next Y
                    End If
                Next X
                If BE < EN Then
                    For X = BE To EN
                        XP1 = BE
                        XP2 = EN
                        
                        
                        If MinLA > MinlPos(X) Then
                            MinLA = MinlPos(X)
                            
                        End If
                    Next X
                        
                Else
                    If Len(StrainSeq(0)) - BE > EN Then
                        XP1 = 1
                        XP2 = BE
                    Else
                        XP1 = EN
                        XP2 = Len(StrainSeq(0))
                    End If
                        
                    For X = 1 To EN
                        If MinLA > MinlPos(X) Then
                            MinLA = MinlPos(X)
                            
                        End If
                    Next X
                    For X = BE To Len(StrainSeq(0))
                        If MinLA > MinlPos(X) Then
                            MinLA = MinlPos(X)
                            
                        End If
                    Next X
                End If
                        
             End If
        
        Else
            MinL = 0
            For X = 1 To NumWins
                If LSurface(X) > MinL Then MinL = LSurface(X)
            Next X
            'sort out minpa etc for scanwindow
            
        End If
    End If
    Dim MC As Double
    If MCFlag = 0 Then
        MC = MCCorrection * (Len(StrainSeq(0)) / LRDStep)
    Else
        MC = (Len(StrainSeq(0)) / LRDStep)
    End If
    
    If LRDWin = 0 Then
        If LRDRegion = 1 Then
            MinPA = ChiPVal3((MaxL - MinLA) * 2, 4) * MC
            MinPA2 = ChiPVal3((MaxL - MinLA2) * 2, 4) * MC
        Else
            MinPA = ChiPVal3((MaxL - MinLA) * 2, 8) * MC
        End If
    Else
        'window minpa worked out here
    End If
    EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    
    PT = 10 ^ (-ConfirmP(EN, 7))
    
    If (Confirm(EN, 7) = 0 Or (Confirm(EN, 7) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 7) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                
                ConfirmP(EN, 7) = -Log10(MinPA)
                
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 7) = -Log10(MinPA2)
                
            End If
            DoEvents
            'XX = -Log10(0.5)
            'X = X

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

    End If
    
    
    If LRDWin = 0 Then
        On Error Resume Next
        Name "likelihood.surface" As "ls.surface"
        On Error GoTo 0
        Open "screen.out" For Output As #1
        Print #1, OP
        Close #1
    End If
    
    
    
    
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.BackColor = BackColours
    
    
    'put likelihoods into matrixl
    If LRDRegion = 2 Then
        dims = CLng((Count * 2) ^ 0.5 + 0.5)
        ReDim MatrixL(dims + 1, dims + 1)
        
        Dim XC As Long, YC As Long
        For X = 1 To Count
          XC = CLng(LXPos(0, X) / (LRDStep))
          YC = CLng(LXPos(1, X) / (LRDStep))
          
          MatrixL(XC, YC) = LSurface(X) - MinL
          MatrixL(YC, XC) = MatrixL(XC, YC)
          
        Next X
        MaxN = FindMaxN(Count, MatrixL(0, 0))
        
        MatBound(11) = MaxN
        Call DrawLRDMat
    End If
    
    
    Dim DF As Double, CritLR As Double
    If LRDWin = 0 Then
        DF = 4 * LRDRegion
        CritLR = (GetCritChi(LowestProb / (MCCorrection * (Len(StrainSeq(0)) / LRDStep)), DF)) / 2
        If (MaxL - MinL) < CritLR Then MinL = MaxL - CritLR
        
        Call DoAxes(Len(StrainSeq(0)), -1, MaxL - MinL, 0, 1, "Log likelihood ratio")
    Else
        DF = 4
        CritLR = (GetCritChi(LowestProb / (MCCorrection * (Len(StrainSeq(0)) / LRDWinLen)), DF)) / 2
        If CritLR > MinL Then MinL = CritLR '12.7
        Call DoAxes(Len(StrainSeq(0)), -1, MinL, 0, 1, "Log likelihood ratio")
    End If
    
    
    
    '14.161
    
    
    
    
    
    
    Form1.Picture7.ForeColor = RGB(180, 180, 180)
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    'First do the background
    
    If LRDWin = 1 Then
        MoveToEx Pict, 30 + (LXPos(0, 1)) * XFactor, PicHeight - (15 + (((LSurface(1)) / (MinL))) * (PicHeight - 35)), PntAPI
        
        For X = 2 To NumWins - 1
            LineTo Pict, 30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (((LSurface(X)) / (MinL))) * (PicHeight - 35))
        Next 'X
    Else
        If LRDRegion = 1 Then
            MoveToEx Pict, 30 + (LXPos(0, 2)) * XFactor, PicHeight - (15 + (1 - ((LSurface(2) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
        
            For X = 3 To Count
                LineTo Pict, 30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
            Next 'X
        
        End If
    End If
    If TManFlag = -1 Then

        Call Highlight

    End If
    'Draw Critical value
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = 0
    Pict = Form1.Picture7.hdc
    
    
    
    
    If LRDWin = 1 Then
        MoveToEx Pict, 25, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35)), PntAPI
        LineTo Pict, 30 + (Len(StrainSeq(0))) * XFactor, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35))
        CritLR = (GetCritChi(LowestProb / (Len(StrainSeq(0)) / LRDWinLen), DF)) / 2
        MoveToEx Pict, 25, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35)), PntAPI
        LineTo Pict, 30 + (Len(StrainSeq(0))) * XFactor, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35))

    Else
        MoveToEx Pict, 25, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
        LineTo Pict, 30 + (Len(StrainSeq(0))) * XFactor, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35))
        CritLR = (GetCritChi(LowestProb / (Len(StrainSeq(0)) / LRDStep), DF)) / 2
        MoveToEx Pict, 25, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
        LineTo Pict, 30 + (Len(StrainSeq(0))) * XFactor, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35))
    End If
    Form1.Picture7.DrawStyle = 0
    
    
    
    Form1.Picture7.ForeColor = 0
    Pict = Form1.Picture7.hdc
    If LRDWin = 1 Then
        MoveToEx Pict, 30 + (LXPos(0, 1)) * XFactor, PicHeight - (15 + (((LSurface(1)) / (MinL))) * (PicHeight - 35)), PntAPI
        
        For X = 2 To NumWins - 1
            LineTo Pict, 30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (((LSurface(X)) / (MinL))) * (PicHeight - 35))
        Next 'X
    Else
        If LRDRegion = 1 Then
            'Then do the foreground
            MoveToEx Pict, 30 + (LXPos(0, 2)) * XFactor, PicHeight - (15 + (1 - ((LSurface(2) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
        
            For X = 3 To Count
                LineTo Pict, 30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
            Next 'X
        Else
           
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
                                
                                LLx = -1
                                'For Y = 1 To Count
                                    If X = 12345 Then
                                        For X = 1 To Count
                                        
                                            Form1.Picture7.Line (30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((MaxL - MinL) / (MaxL - MinL))) * (PicHeight - 35))), 0, B
                                        Next X
                                    ElseIf X = 12345 Then
                                        For X = 1 To Count
                                            If LXPos(0, X) <> LLx Then
                                                Dummy = MoveToEx(Pict, 30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI)
                                                'Dummy = LineTo(Pict, 30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))
                                            Else
                                                Dummy = LineTo(Pict, 30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))
                                            End If
                                            LLx = LXPos(0, X)
                                        
                                        Next 'X
                                    
                                    Else
                                        For X = 1 To Count
                                            If LSurface(X) = MaxReg(LXPos(1, X) - LXPos(0, X)) Then
                                                Form1.Picture7.Line (30 + (LXPos(0, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((MaxL - MinL) / (MaxL - MinL))) * (PicHeight - 35))), 0, B
                                            End If
                                        Next X
                                    End If
                                'Next Y
                                Form1.Picture7.Refresh
                                Form1.Picture10.Refresh
                                
                                SCount = Count - 1
                                
        
        
        End If
    End If
    ProbY = 1
    If LRDRegion = 1 Then
        If MinPA < 1 Then
            ProbTest$ = MinPA
            ProbX = XP1
            Call PrintProbability
        End If
        If MinPA2 < 1 Then
            ProbTest$ = MinPA2
            ProbX = XP2
            Call PrintProbability
        End If
    Else
        If MinPA < 1 Then
            ProbTest$ = MinPA
            ProbX = XP1 + (XP2 - XP1) / 2
            Call PrintProbability
        End If
    End If
    
    ChDir OldDir
    ChDrive OldDir
    'Reenable/disbale all the relevant controlls
    Form1.Command25.Enabled = False
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5
    Form1.Command29.Enabled = True
On Error GoTo 0

End Sub

Public Sub GCMaxChiCheck()
    OldDir = CurDir
    ChDir App.Path
    ChDrive App.Path

    If NJFlag = 0 Then
        Form1.SSPanel1.Caption = "Calculating Tree Dimensions"

        Call UPGMA(0, 0)
        Call DrawTree

        Form1.Label14.Caption = "UPGMA Ignoring Recombination"
        TreeImage(0) = 1
        DoneTree(0, 0) = 1
        NJFlag = 1
        efflag = 0
        'Calculate tree distances
        ReDim TreeDistance(NextNo, NextNo)
        Dummy = TreeDist(NextNo, TreeDistance(0, 0), NodeLength(0), TreeX(0, 0))
        TreeDistFlag = 1
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = "Executing MaxChi"
    ElseIf TreeDistFlag = 0 Then
        ReDim TreeDistance(NextNo, NextNo)
        Dummy = TreeDist(NextNo, TreeDistance(0, 0), NodeLength(0), TreeX(0, 0))
        TreeDistFlag = 1
    End If

    Call FindSubSeqMCII

    MCFullOR = MCOverlapR
    MCFullOL = MCOverlapL

    Dim TempSeq() As String

    ReDim TempSeq(NextNo) As String
    'a$ = left

    For X = 0 To NextNo
        TempSeq(X) = right$(StrainSeq(X), MCOverlapR) & StrainSeq(X) & left$(StrainSeq(X), MCOverlapL)
    Next 'X

    If Len(TempSeq(0)) > 99999 Then

        For X = 0 To NextNo
            TempSeq(X) = left$(TempSeq(X), 99999)
        Next 'X

    End If

    Open "mchi.seq" For Output As #1
    Print #1, "#NEXUS"
    Print #1, ""
    Print #1, "BEGIN DATA;"
    'Print #1, chr$(9) & "DIMENSIONS NTAX=" & trim$(cstr(Nextno + 1)) & " NCHAR=" & trim$(cstr(len(TempSeq(0)))) & ";"
    Print #1, Chr$(9) & "DIMENSIONS NTAX=" & NextNo + 1&; " NCHAR=" & Trim$(CStr(Len(TempSeq(0)))) & ";"
    Pos = InStr(1, StrainSeq(0), "-", vbBinaryCompare)

    If Pos > 0 Then
        Print #1, Chr$(9) & "FORMAT MISSING=? GAP=- DATATYPE=DNA;"
    Else
        Print #1, Chr$(9) & "FORMAT MISSING=? GAP=. DATATYPE=DNA;"
    End If

    Print #1, Chr$(9) & "MATRIX"

    For X = 0 To NextNo
        Print #1, "s" & Trim$(CStr(X + 1))
        Print #1, TempSeq(X)
    Next 'X

    Print #1, Chr$(9) & ";"
    Print #1, "END;"
    Close #1

    If MCProportionFlag = 0 Then

        If LenXOverSeq > MCWinSize * 1.5 Then
            MaxChiCline = "maxchirdp " & "-imchi.seq -w" & MCWinSize & " -a0.05 -s" & MCSteplen  '" -p" & MCPerms
        ElseIf LenXOverSeq / 1.5 > 10 Then
            MaxChiCline = "maxchirdp " & "-imchi.seq -w" & (Int((LenXOverSeq / 1.5) / 2) * 2 - 2) & " -a0.05 -s" & MCSteplen '" -p" & MCPerms
        Else
            Exit Sub
        End If

    Else

        If Int(MCWinFract * LenXOverSeq) > 20 And Int(MCWinFract * LenXOverSeq) < (LenXOverSeq / 1.5) Then
            MaxChiCline = "maxchirdp " & "-imchi.seq -w" & (Int((MCWinFract * LenXOverSeq) / 2) * 2 - 2) & " -a0.05 -s" & MCSteplen '" -p" & MCPerms
        ElseIf Int(MCWinFract * LenXOverSeq) <= 20 Then

            If LenXOverSeq > 15 Then
                MaxChiCline = "maxchirdp " & "-imchi.seq -w20 -a0.05 -s" & MCSteplen '" -p" & MCPerms
            Else
                Exit Sub
            End If

        ElseIf Int(MCWinFract * LenXOverSeq) >= (LenXOverSeq / 1.5) Then

            If LenXOverSeq / 1.5 > 10 Then
                MaxChiCline = "maxchirdp " & "-imchi.seq -w" & (Int((LenXOverSeq / 1.5) / 2) * 2 - 2) & " -a0.05 -s" & MCSteplen '" -p" & MCPerms
            Else
                Exit Sub
            End If

        End If

    End If

    Dim aProcess As Long

    aProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(MaxChiCline, 0))

    Do
        GetExitCodeProcess aProcess, RetVal
        Sleep (100)
    Loop While RetVal = STILL_ACTIVE

    Dummy = CloseHandle(aProcess)
    aProcess = 0
    ChDir OldDir
    ChDrive OldDir
End Sub

Public Sub GetCriticalDiff(Pr)
Dim LastLoChi As Double, LastHiChi As Double, TempChi As Double, hPrb As Double, TPVal As Double, hMChi As Double, A As Long, B As Long, lPrb As Double

If X = 12345 Then
Redo:
    If Pr = 0 Then
        HWindowWidth = CLng(pMCWinSize / 2)
    Else
        HWindowWidth = CLng(pCWinSize / 2)
    End If
End If

If MCFlag = 0 And X = 12345 Then
    If MCTripletFlag = 0 Then
        lPrb = LowestProb / MCCorrection
    Else
        lPrb = LowestProb / MCCorrect
    End If
Else
    lPrb = LowestProb / 6
End If

If lPrb < 0.0001 Then lPrb = 0.0001
'lPrb = 0.05
hPrb = lPrb * 1.000000001
lPrb = lPrb * 0.999999999

'Calculate critical Chi
hMChi = 5
LastChi = 1
TPVal = 10
Do While TPVal > lPrb
   hMChi = hMChi * 2
   TPVal = ChiPVal(hMChi)
   If TPVal = 10 ^ -20 Then
      lPrb = TPVal
      Exit Do
    End If
Loop
LastLoChi = 0
LastHiChi = hMChi * 2
Do
    TPVal = ChiPVal(hMChi)
    If TPVal < lPrb Then
        TempChi = hMChi
        hMChi = hMChi - (hMChi - LastLoChi) / 2
        If hMChi = TempChi Then Exit Do
        LastHiChi = TempChi
    ElseIf TPVal > hPrb Then
        TempChi = hMChi
        hMChi = hMChi + (LastHiChi - hMChi) / 2
        If hMChi = TempChi Then Exit Do
        LastLoChi = TempChi
    Else
        Exit Do
    End If
Loop
CriticalChi = hMChi

LastLoChi = 0
LastHiChi = HWindowWidth
CriticalDiff = HWindowWidth / 2
Dim ChiHold As Double
ChiHold = 0
Do
    A = 0
    B = HWindowWidth
    C = CriticalDiff
    D = HWindowWidth - C
    hMChi = (A * D - B * C) ^ 2 * HWindowWidth * 2
    hMChi = hMChi / (A + B)
    hMChi = hMChi / (C + D)
    hMChi = hMChi / (A + C)
    hMChi = hMChi / (B + D)
    If hMChi > CriticalChi Then
        TempChi = CriticalDiff
        CriticalDiff = CriticalDiff - (CriticalDiff - LastLoChi) / 2
        LastHiChi = TempChi
        ChiHold = hMChi
    ElseIf hMChi < CriticalChi Then
        TempChi = CriticalDiff
        CriticalDiff = CriticalDiff + (LastHiChi - CriticalDiff) / 2
        LastLoChi = TempChi
    Else
        Exit Do
    End If
Loop While LastHiChi <> CriticalDiff And CriticalDiff <> LastLoChi
CriticalDiff = CriticalDiff - 1

If ChiHold < CriticalChi Then
    HWindowWidth = HWindowWidth * 1.5
    GoTo Redo
End If



End Sub
Public Sub GetCriticalZ()
Dim LastLoZ As Double, LastHiZ As Double, TempZ As Double, hPrb As Double, TPVal As Variant, hMZ As Double, lPrb As Double

Redo:

If MCFlag = 0 And TManFlag <> 9 Then
        lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

hPrb = lPrb / 0.9999
lPrb = lPrb * 0.9999

'Calculate critical Z
hMZ = 5
TPVal = 10
Do While TPVal > lPrb
   hMZ = hMZ * 2
   If hMZ < 6 Then
    TPVal = NormalZ(hMZ)
   Else
        temp = ((hMZ - 6) * 10)
        
        If temp > 170 Then temp = 170
        temp = 1.6 ^ temp
        TPVal = (10 ^ -9) / temp
   End If
Loop
LastLoZ = 0
LastHiZ = hMZ * 2
Do
    TPVal = NormalZ(hMZ)
    If TPVal < lPrb Then
        TempZ = hMZ
        hMZ = hMZ - (hMZ - LastLoZ) / 2
        LastHiZ = TempZ
    ElseIf TPVal > hPrb Then
        TempZ = hMZ
        hMZ = hMZ + (LastHiZ - hMZ) / 2
        LastLoZ = TempZ
    Else
        Exit Do
    End If
Loop
CriticalZ = hMZ



End Sub

Public Sub CXoverB()
Dim TWin As Long, X As Long, LO As Long, RO As Long, n As Long, A As Long, B As Long, C As Long, D As Long, SPos As Long, EPos As Long, Step As Long, LSeq As Long, Last As Long, numSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double
oMCWinSize = MCWinSize
oMCWinfract = MCWinFract
SpacerNo = 0

numSites = Len(StrainSeq(0))
Step = CSteplen
Last = numSites
TSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
If XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
    Seq1 = CLng(Abs(XOverList(RelX, RelY).DHolder))
    
    'Seq1 = 6

    If Seq1 = TSeq1 Then
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq2 Then
        Seq2 = TSeq1
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq3 Then
        Seq2 = TSeq1
        Seq3 = tSeq2
    End If
Else
    Seq1 = tSeq3
    Seq2 = TSeq1
    Seq3 = tSeq2
End If

ReDim Scores(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
ReDim ChiVals(Len(StrainSeq(0)))
ReDim ChiPVals(Len(StrainSeq(0)))
ReDim SmoothChi(Len(StrainSeq(0)))
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)

NumTaxa = NextNo + 1
'7.14 of 32
    
LenXOverSeq = 0

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'Else

    'This could be speeded up with better nesting
    LenXOverSeq = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))
'End If
oCWinSize = CWinSize
oCWinfract = CWinFract

If XOverList(RelX, RelY).ProgramFlag = 4 And ExeCheckFlag = 0 Then
    CWinSize = XOverList(RelX, RelY).LHolder
    WindowWidth = CWinSize
    HWindowWidth = CLng(WindowWidth / 2)
Else
    If OptFlag <> 4 Then
            BE = XOverList(RelX, RelY).Beginning
            EN = XOverList(RelX, RelY).Ending
            If BE < EN Then
                CWinSize = XPosdiff(EN) - XPosdiff(BE) + 1
            Else
                CWinSize = XPosdiff(EN) + (LenXOverSeq - XPosdiff(BE)) + 1
            End If
            
            CWinSize = CWinSize * 2
            CWinFract = CWinSize / LenXOverSeq
    End If
    
    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2)
    Else
        If Int(CWinFract * LenXOverSeq) > 20 And Int(CWinFract * LenXOverSeq) < (LenXOverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXOverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXOverSeq) <= 20 Then
    
            If LenXOverSeq > 15 Then
                WindowWidth = 20
            Else
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXOverSeq) >= (LenXOverSeq / 1.5) Then
    
            If LenXOverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXOverSeq / 1.5) / 2) * 2 - 2)
            Else
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2)
        Call GetCriticalDiff(1)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
            CWinSize = HWindowWidth * 2
        End If
    End If
    
    If HWindowWidth > LenXOverSeq / 2 Then
        HWindowWidth = LenXOverSeq - HWindowWidth + 1
        If HWindowWidth < 3 Then
            HWindowWidth = LenXOverSeq / 2
        End If
    End If
End If
SPos = -HWindowWidth
EPos = LenXOverSeq + HWindowWidth

'9 of 32
Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0), XDiffpos(0), SeqNum(0, 0), WinScores(0))

'If Dummy = 0 Then Exit Sub

'9 of 32
'This could be speeded up with better nesting
MChi = CalcChiVals3(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0), ChiVals(0))

If MCFlag = 0 Then
    lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (LenXOverSeq / (HWindowWidth))
MChi = -Log10(MChi)


MCMinChiP = MChi
    

If MCFlag = 0 Then
    If MCMinChiP < -Log10(LowestProb / MCCorrection) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
Else
    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
End If

MChi = MCMinChiP


    For Y = 1 To LenXOverSeq
        If CLng(pCWinSize / 2) > HWindowWidth Then
            ChiVals(Y) = ChiPVal(ChiVals(Y)) * (LenXOverSeq / (HWindowWidth)) * 3
        Else
            ChiVals(Y) = ChiPVal(ChiVals(Y)) * (LenXOverSeq / (CLng(pCWinSize / 2))) * 3
        End If
        'ChiVals(Y) = ChiPVal(ChiVals(Y)) * (LenXoverSeq / (HWindowWidth))
        If ChiVals(Y) > 1 Then
            ChiVals(Y) = 1
        End If
    Next Y





        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        Form1.Picture7 = LoadPicture()
        ReDim MCPrintPos(LenXOverSeq)
        ReDim MCPrintData(LenXOverSeq)
        
        For X = 0 To LenXOverSeq
            MCPrintPos(X) = XDiffpos(X)
        Next X

        YScaleFactor = 0.85
        Call DoAxes(Len(StrainSeq(0)), -1, MChi, 0, 1, "-Log[P(Chi2)]")
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        Form1.Picture7.DrawWidth = 3
        
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            Form1.Picture7.ForeColor = HalfColour
            
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, (30 + (XDiffpos(1) + (XDiffpos(2) - XDiffpos(1)) / 2) * XFactor), -15 + PicHeight - (-Log10(ChiVals(1)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(1) = ChiVals(1)
            For X = 2 To LenXOverSeq - 1
                MCPrintData(X) = ChiVals(X)
                Dummy = LineTo(Pict, 30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor, -15 + PicHeight - (-Log10(ChiVals(X)) / MChi) * (PicHeight - 35))
                
            Next '
        
        Form1.Picture7.DrawWidth = 1
        Call Highlight
        
        Form1.Picture7.DrawStyle = 2

        Dim ZP As Double
    
        If ExeCheckFlag = 1 Or MCFlag <> 0 Then
            ZP = LowestProb
            Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35))), QBColor(0)
        End If
    
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35))), QBColor(0)
        Form1.Picture7.DrawStyle = 0
        
        
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            Form1.Picture7.ForeColor = 0
            
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, (30 + (XDiffpos(1) + (XDiffpos(2) - XDiffpos(1)) / 2) * XFactor), -15 + PicHeight - (-Log10(ChiVals(1)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(1) = ChiVals(1)
            For X = 2 To LenXOverSeq - 1
                MCPrintData(X) = ChiVals(X)
                Dummy = LineTo(Pict, 30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor, -15 + PicHeight - (-Log10(ChiVals(X)) / MChi) * (PicHeight - 35))
                
            Next '
    
      
    'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    'Call Highlight
    Dim TB As Long, TE As Long

    If XOverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XOverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XOverList(RelX, RelY).Beginning - 20
    End If

    If XOverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XOverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XOverList(RelX, RelY).Ending + 20
    End If

    Dim Z As Long, MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If TE > TB Then

        For X = 0 To LenXOverSeq
'
            If XDiffpos(X) >= TB - 50 And XDiffpos(X) < TE + 50 Then

                

                    If MCPrintData(X) < MinPA2 And Abs(TE - (XDiffpos(X))) < Abs(TB - (XDiffpos(X))) Then
                        MinPA2 = MCPrintData(X)
                        XP2 = XDiffpos(X)
                    ElseIf MCPrintData(X) < MinPA And Abs(TE - (XDiffpos(X))) > Abs(TB - (XDiffpos(X))) Then
                        MinPA = MCPrintData(X)
                        XP1 = XDiffpos(X)
                    End If

                

            End If

        Next 'X

    Else

        For X = 1 To LenXOverSeq - 1

            If XDiffpos(X) >= TB - 50 Or XDiffpos(X) <= TE + 50 Then

                

                    If XDiffpos(X) < TE Then

                        If MCPrintData(X) < MinPA2 And Abs(TE - (XDiffpos(X))) < Abs(XDiffpos(X) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA2 = MCPrintData(X)
                            XP2 = XDiffpos(X)
                        ElseIf MCPrintData(X) < MinPA And (Abs(TE - (XDiffpos(X))) > Abs(XDiffpos(X) + (Len(StrainSeq(0)) - TB))) Then
                            MinPA = MCPrintData(X)
                            XP1 = XDiffpos(X)
                        End If

                    Else

                        If MCPrintData(X) < MinPA2 And TE + (Len(StrainSeq(0)) - (XDiffpos(X))) < Abs(XDiffpos(X) - TB) Then
                            MinPA2 = MCPrintData(X)
                            XP2 = XDiffpos(X)
                        ElseIf MCPrintData(X) < MinPA And TE + (Len(StrainSeq(0)) - (XDiffpos(X))) > Abs(XDiffpos(X) - TB) Then
                            MinPA = MCPrintData(X)
                            XP1 = XDiffpos(X)
                        End If

                    End If

                

            End If

        Next 'X

    End If
    
    
    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)
  '  If HWindowWidth > 0 Then
  '      MinPA = MinPA * MCCorrection
  '      MinPA2 = MinPA2 * MCCorrection
  '  Else
  '       MinPA = 1
  '        MinPA2 = 1
  '
  '  End If
    
    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(4, MinPA)
        MinPA2 = StepDown2(4, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    
    PT = 10 ^ (-ConfirmP(EN, 4))
    
    If X = X Or (XOverList(RelX, RelY).ProgramFlag <> 4 And XOverList(RelX, RelY).ProgramFlag <> 4 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 4) = 0 Or (Confirm(EN, 4) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 4) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA2)
            End If

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

    Else

        If XOverList(RelX, RelY).BeginP < XOverList(RelX, RelY).EndP Then

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(0) = XOverList(RelX, RelY).BeginP
                POrder(2) = XOverList(RelX, RelY).Beginning
            Else
                POrder(0) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(1) = XOverList(RelX, RelY).EndP
                POrder(3) = XOverList(RelX, RelY).Ending
            Else
                POrder(1) = 0
            End If

        Else

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(1) = XOverList(RelX, RelY).BeginP
                POrder(3) = XOverList(RelX, RelY).Beginning
            Else
                POrder(1) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(0) = XOverList(RelX, RelY).EndP
                POrder(2) = XOverList(RelX, RelY).Ending
            Else
                POrder(0) = 0
            End If

        End If

    End If

    For A = 0 To 1
        ProbX = POrder(A + 2)

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then Call PrintProbability

        End If

    Next 'A
CWinSize = oCWinSize
CWinFract = oCWinfract
Seq1 = TSeq1
Seq2 = tSeq2
Seq3 = tSeq3
 MCWinSize = oMCWinSize
MCWinFract = oMCWinfract
ReDim CXoverSeq(2)
    
For X = 1 To LenXOverSeq
    CXoverSeq(0) = CXoverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), XDiffpos(X), 1)
    CXoverSeq(1) = CXoverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), XDiffpos(X), 1)
    CXoverSeq(2) = CXoverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), XDiffpos(X), 1)
Next X
    
End Sub
Public Sub CXoverC(SPF)
Dim TWin As Long, X As Long, LO As Long, RO As Long, n As Long, A As Long, B As Long, C As Long, D As Long, SPos As Long, EPos As Long, Step As Long, LSeq As Long, Last As Long, numSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double
Dim Z As Long, MinPA As Double, MinPA2 As Double
numSites = Len(StrainSeq(0))
Step = CSteplen
Last = numSites
TSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
Dim XDiffpos() As Long
Dim XPosdiff() As Long

ReDim Scores(Len(StrainSeq(0)), 2) ' 0=s1,s2Matches etc
ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
ReDim ChiVals(Len(StrainSeq(0)), 2)
ReDim ChiPVals(Len(StrainSeq(0)), 2)
ReDim SmoothChi(Len(StrainSeq(0)), 2)
ReDim XDiffpos(Len(StrainSeq(0)) + 200, 2)
ReDim XPosdiff(Len(StrainSeq(0)) + 200, 2)

ReDim xLenXoverSeq(2)
NumTaxa = NextNo + 1
'7.14 of 32
    
LenXOverSeq = 0


oMCWinSize = MCWinSize
oMCWinfract = MCWinFract

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'Else
'rearrange the seq order so that the correct sequence comes first
If (XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum) Then
    If Abs(CLng(XOverList(RelX, RelY).DHolder)) = Seq2 Then
        CycleNo = 2
    ElseIf Abs(CLng(XOverList(RelX, RelY).DHolder)) = Seq3 Then
        CycleNo = 1
    Else
        CycleNo = 0
    End If

End If
ReDim xLenXoverSeq(2)
For Z = 0 To 2
    If Z = 0 Then
        Seq1 = TSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Z = 1 Then
        Seq1 = tSeq3
        Seq2 = TSeq1
        Seq3 = tSeq2
    Else
        Seq1 = tSeq2
        Seq2 = tSeq3
        Seq3 = TSeq1
    End If
    'This could be speeded up with better nesting
    xLenXoverSeq(Z) = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0, Z), XPosdiff(0, Z))
    If xLenXoverSeq(Z) > LenXOverSeq Then LenXOverSeq = xLenXoverSeq(Z)
'End If
Next Z


oCWinSize = CWinSize
oCWinfract = CWinFract
Dim MAxD As Long, tstD  As Long, winz As Long
MAxD = 0
winz = 4

Dim MinLen As Long, MaxLen As Long
MinLen = 1000000
MaxLen = 0
For X = 0 To 2
    If xLenXoverSeq(X) < MinLen Then MinLen = xLenXoverSeq(X)
    If xLenXoverSeq(X) > MaxLen Then MaxLen = xLenXoverSeq(X)
Next X
If MinLen < 2 Then Exit Sub
If XOverList(RelX, RelY).ProgramFlag = 4 And OptFlag <> 11 Then
    CWinSize = XOverList(RelX, RelY).LHolder
    WindowWidth = CWinSize
    HWindowWidth = CLng(WindowWidth / 2)
Else
    If OptFlag <> 11 Then
        BE = XOverList(RelX, RelY).Beginning
        EN = XOverList(RelX, RelY).Ending
        For Z = 0 To 2
            If BE < EN Then
                If MAxD < XPosdiff(EN, Z) - XPosdiff(BE, Z) + 1 Then
                    MAxD = XPosdiff(EN, Z) - XPosdiff(BE, Z) + 1
                    winz = Z
                End If
            Else
                If MAxD < (XPosdiff(EN, Z) + (xLenXoverSeq(Z) - XPosdiff(BE, Z)) + 1) Then
                    MAxD = XPosdiff(EN, Z) + (xLenXoverSeq(Z) - XPosdiff(BE, Z)) + 1
                    winz = Z
                End If
            End If
        Next Z
    End If

    For Z = 0 To 2
        If (Z = winz And (XOverList(RelX, RelY).ProgramFlag <> 4 And XOverList(RelX, RelY).ProgramFlag <> 4 + AddNum)) Or ((XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum) And CycleNo = Z) Then
        
            If OptFlag <> 11 Then
                    BE = XOverList(RelX, RelY).Beginning
                    EN = XOverList(RelX, RelY).Ending
                    If BE < EN Then
                        CWinSize = XPosdiff(EN, Z) - XPosdiff(BE, Z) + 1
                        'Exit Sub
                    Else
                        CWinSize = XPosdiff(EN, Z) + (LenXOverSeq - XPosdiff(BE, Z)) + 1
                    End If
                    
                    CWinSize = CWinSize * 2
                    CWinFract = CWinSize / LenXOverSeq
            End If
            Exit For
        End If
    Next Z
End If
If CWinSize > MaxLen / 3 Then CWinSize = MaxLen / 3


    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2)
    Else
        If Int(CWinFract * LenXOverSeq) > 20 And Int(CWinFract * LenXOverSeq) < (LenXOverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXOverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXOverSeq) <= 20 Then
    
            If LenXOverSeq > 15 Then
                WindowWidth = 20
            Else
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXOverSeq) >= (LenXOverSeq / 1.5) Then
    
            If LenXOverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXOverSeq / 1.5) / 2) * 2 - 2)
            Else
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
        Call GetCriticalDiff(1)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
        CWinSize = HWindowWidth * 2
    End If
End If

If HWindowWidth > LenXOverSeq / 2 Then
    HWindowWidth = LenXOverSeq - HWindowWidth + 1
    If HWindowWidth < 3 Then
        HWindowWidth = LenXOverSeq / 2
    End If
End If

SPos = -HWindowWidth
EPos = LenXOverSeq + HWindowWidth

'9 of 32
Dim omChi As Double
omChi = 0
Dim Longest As Long
Longest = 0
For Z = 0 To 2
    If Longest < xLenXoverSeq(Z) Then
        Longest = xLenXoverSeq(Z)
    End If
    
Next Z
If Longest < CWinSize Then CWinSize = Longest * 0.6666

For Z = 0 To 2
    If CWinSize < xLenXoverSeq(Z) Then
        If Z = 0 Then
            Seq1 = TSeq1
            Seq2 = tSeq2
            Seq3 = tSeq3
        ElseIf Z = 1 Then
            Seq1 = tSeq3
            Seq2 = TSeq1
            Seq3 = tSeq2
        Else
            Seq1 = tSeq2
            Seq2 = tSeq3
            Seq3 = TSeq1
        End If
        Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, xLenXoverSeq(Z), Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, Z), XDiffpos(0, Z), SeqNum(0, 0), WinScores(0, Z))
    
    'If Dummy = 0 Then Exit Sub
    
    '9 of 32
        'This could be speeded up with better nesting
        MChi = CalcChiVals3(CriticalDiff, HWindowWidth, xLenXoverSeq(Z), Len(StrainSeq(0)), WinScores(0, Z), ChiVals(0, Z))
        If omChi < MChi Then
            omChi = MChi
            HC = xLenXoverSeq(Z)
        End If
    End If
    For Y = 1 To xLenXoverSeq(Z)
        If HWindowWidth < CLng(pCWinSize / 2) Then
            ChiVals(Y, Z) = ChiPVal(ChiVals(Y, Z)) * (xLenXoverSeq(Z) / (HWindowWidth)) * 3
        Else
            ChiVals(Y, Z) = ChiPVal(ChiVals(Y, Z)) * (xLenXoverSeq(Z) / (CLng(pCWinSize / 2))) * 3
        End If
        If ChiVals(Y, Z) > 1 Then ChiVals(Y, Z) = 1
    Next Y
    
Next Z
MChi = omChi
If MCFlag = 0 Then
    lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (HC / (HWindowWidth))
MChi = -Log10(MChi)


MCMinChiP = MChi
    

If MCFlag = 0 Then
    If MCMinChiP < -Log10(LowestProb / MCCorrection) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
Else
    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
End If

MChi = MCMinChiP


    




If SPF = 0 Then
        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        Form1.Picture7 = LoadPicture()
        ReDim MCPrintPos(LenXOverSeq, 2)
        ReDim MCPrintData(LenXOverSeq, 2)
        For Z = 0 To 2
            For X = 0 To LenXOverSeq
                MCPrintPos(X, Z) = XDiffpos(X, Z)
            Next X
        Next Z
        YScaleFactor = 0.85
        
        Call DoAxes(Len(StrainSeq(0)), -1, MChi, 0, 0, "-Log[P(Chi2)]")
        
        Dim Red As Long, Green As Long, Blue As Long
        Red = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        Blue = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
       
        
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        'Form1.Picture7.DrawWidth = 3
        
        Form1.Picture7.DrawWidth = 1
        'Call Highlight
        Call Highlight
        Form1.Picture7.DrawStyle = 2

        Dim ZP As Double
    
        If ExeCheckFlag = 1 Or MCFlag <> 0 Then
            ZP = LowestProb
            Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35))), QBColor(0)
        End If
    
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35))), QBColor(0)
        Form1.Picture7.DrawStyle = 0
        
        
        
        
       For Z = 0 To 2
            If Z = 0 Then
                Form1.Picture7.ForeColor = Red
            ElseIf Z = 1 Then
                Form1.Picture7.ForeColor = Blue
            Else
                Form1.Picture7.ForeColor = Green
            End If
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, (30 + (XDiffpos(1, Z) + (XDiffpos(2, Z) - XDiffpos(1, Z)) / 2) * XFactor), -15 + PicHeight - (-Log10(ChiVals(1, Z)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(1, Z) = ChiVals(1, Z)
            For X = 2 To xLenXoverSeq(Z) - 1
                MCPrintData(X, Z) = ChiVals(X, Z)
                Dummy = LineTo(Pict, 30 + (XDiffpos(X, Z) + (XDiffpos(X + 1, Z) - XDiffpos(X, Z)) / 2) * XFactor, -15 + PicHeight - (-Log10(ChiVals(X, Z)) / MChi) * (PicHeight - 35))
                
            Next '
        Next 'Z
    Dim SP As Long, EP As Long
    For Z = 0 To 2
            
            
            If Z = 0 Then
                Form1.Picture7.ForeColor = Red
                SP = 10
                EP = 13
            ElseIf Z = 1 Then
                Form1.Picture7.ForeColor = Green
                SP = SP + 3
                EP = EP + 3
            Else
                SP = SP + 3
                EP = EP + 3
                Form1.Picture7.ForeColor = Blue
            End If
            Pict = Form1.Picture7.hdc
            For X = 1 To xLenXoverSeq(Z)
                MoveToEx Pict, (30 + XDiffpos(X, Z) * XFactor), SP, PntAPI
                LineTo Pict, (30 + XDiffpos(X, Z) * XFactor), EP
            Next X
        Next Z
    
        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
        
        Dim LOSpace As Integer, YPos As Integer, TotLen As Integer, L1 As Integer, L2 As Integer, L3 As Integer, DrawLen As Integer, XPos1 As Integer, XPos2 As Integer, XPos3 As Integer
        Dim OFontSize As Double
    
        OFontSize = Form1.Picture7.FontSize
        L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
        L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
        L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
        DrawLen = Form1.Picture7.ScaleWidth - 30
        TotLen = L1 + L2 + L3
    
        If DrawLen > TotLen Then
            LOSpace = (DrawLen - TotLen) / 2
            XPos1 = 25
            XPos2 = XPos1 + L1 + LOSpace
            XPos3 = XPos2 + L2 + LOSpace
        Else
    
            Do Until TotLen < DrawLen
                Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
                L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
                L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
                L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
                TotLen = L1 + L2 + L3
            Loop
    
            LOSpace = (DrawLen - TotLen) / 2
            XPos1 = 25
            XPos2 = XPos1 + L1 + LOSpace
            XPos3 = XPos2 + L2 + LOSpace
        End If
    Red = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
            Blue = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
            Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        YPos = Form1.Picture7.Height * (0.92)
        Form1.Picture7.ForeColor = ThreeQuaterColour
        Form1.Picture7.CurrentX = XPos1 - 1
        Form1.Picture7.CurrentY = YPos - 1
        Form1.Picture7.Print StraiName(TSeq1)
        Form1.Picture7.CurrentX = XPos2 - 1
        Form1.Picture7.CurrentY = YPos - 1
        Form1.Picture7.Print StraiName(tSeq2)
        Form1.Picture7.CurrentX = XPos3 - 1
        Form1.Picture7.CurrentY = YPos - 1
        Form1.Picture7.Print StraiName(tSeq3)
        Form1.Picture7.ForeColor = QuaterColour
        Form1.Picture7.CurrentX = XPos1 + 1
        Form1.Picture7.CurrentY = YPos + 1
        Form1.Picture7.Print StraiName(TSeq1)
        Form1.Picture7.CurrentX = XPos2 + 1
        Form1.Picture7.CurrentY = YPos + 1
        Form1.Picture7.Print StraiName(tSeq2)
        Form1.Picture7.CurrentX = XPos3 + 1
        Form1.Picture7.CurrentY = YPos + 1
        Form1.Picture7.Print StraiName(tSeq3)
        Form1.Picture7.CurrentX = XPos1
        Form1.Picture7.CurrentY = YPos
        Form1.Picture7.ForeColor = Red 'RGB(255, 0, 0)
        Form1.Picture7.Print StraiName(TSeq1)
        Form1.Picture7.CurrentX = XPos2
        Form1.Picture7.CurrentY = YPos
        Form1.Picture7.ForeColor = Green 'RGB(0, 255, 0)
        Form1.Picture7.Print StraiName(tSeq2)
        Form1.Picture7.CurrentX = XPos3
        Form1.Picture7.CurrentY = YPos
        Form1.Picture7.ForeColor = Blue 'RGB(0, 0, 255)
        Form1.Picture7.Print StraiName(tSeq3)
        'Form1.Picture7.Refresh
        Form1.Picture7.FontSize = OFontSize
    
    End If
    Dim TB As Long, TE As Long

    If XOverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XOverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XOverList(RelX, RelY).Beginning - 20
    End If

    If XOverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XOverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XOverList(RelX, RelY).Ending + 20
    End If

    
    MinPA = 1
    MinPA2 = 1
    For Z = 0 To 2
        If TE > TB Then
    
            For X = 0 To xLenXoverSeq(Z)
    '
                If XDiffpos(X, Z) >= TB - 50 And XDiffpos(X, Z) < TE + 50 Then
    
                    
    
                        If ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA2 And Abs(TE - (XDiffpos(X, Z))) < Abs(TB - (XDiffpos(X, Z))) Then
                            MinPA2 = ChiVals(X, Z)
                            XP2 = XDiffpos(X, Z)
                        ElseIf ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA And Abs(TE - (XDiffpos(X, Z))) > Abs(TB - (XDiffpos(X, Z))) Then
                            MinPA = ChiVals(X, Z)
                            XP1 = XDiffpos(X, Z)
                        End If
    
                    
    
                End If
    
            Next 'X
    
        Else
    
            For X = 1 To LenXOverSeq - 1
                If ChiVals(X, Z) > 0 Then
                    If XDiffpos(X, Z) >= TB - 50 Or XDiffpos(X, Z) <= TE + 50 Then
        
                        
        
                            If XDiffpos(X, Z) < TE Then
        
                                If ChiVals(X, Z) < MinPA2 And Abs(TE - (XDiffpos(X, Z))) < Abs(XDiffpos(X, Z) + (Len(StrainSeq(0)) - TB)) Then
                                    MinPA2 = ChiVals(X, Z)
                                    XP2 = XDiffpos(X, Z)
                                ElseIf ChiVals(X, Z) < MinPA And (Abs(TE - (XDiffpos(X, Z))) > Abs(XDiffpos(X, Z) + (Len(StrainSeq(0)) - TB))) Then
                                    MinPA = ChiVals(X, Z)
                                    XP1 = XDiffpos(X, Z)
                                End If
        
                            Else
                                
                                    If ChiVals(X, Z) < MinPA2 And TE + (Len(StrainSeq(0)) - (XDiffpos(X, Z))) < Abs(XDiffpos(X, Z) - TB) Then
                                        MinPA2 = ChiVals(X, Z)
                                        XP2 = XDiffpos(X, Z)
                                    ElseIf ChiVals(X, Z) < MinPA And TE + (Len(StrainSeq(0)) - (XDiffpos(X, Z))) > Abs(XDiffpos(X, Z) - TB) Then
                                        MinPA = ChiVals(X, Z)
                                        XP1 = XDiffpos(X, Z)
                                    End If
        
                            End If
        
                        
        
                    End If
                End If
            Next 'X
    
        End If
    Next Z
    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)

    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(4, MinPA)
        MinPA2 = StepDown2(4, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    
    
    PT = 10 ^ (-ConfirmP(EN, 4))
    
    If (XOverList(RelX, RelY).ProgramFlag <> 4 And XOverList(RelX, RelY).ProgramFlag <> 4 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA
        
        If (Confirm(EN, 4) = 0 Or (Confirm(EN, 4) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 4) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA2)
            End If
            
            DoEvents

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

    Else

        If XOverList(RelX, RelY).BeginP < XOverList(RelX, RelY).EndP Then

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(0) = XOverList(RelX, RelY).BeginP
                POrder(2) = XOverList(RelX, RelY).Beginning
            Else
                POrder(0) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(1) = XOverList(RelX, RelY).EndP
                POrder(3) = XOverList(RelX, RelY).Ending
            Else
                POrder(1) = 0
            End If

        Else

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(1) = XOverList(RelX, RelY).BeginP
                POrder(3) = XOverList(RelX, RelY).Beginning
            Else
                POrder(1) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(0) = XOverList(RelX, RelY).EndP
                POrder(2) = XOverList(RelX, RelY).Ending
            Else
                POrder(0) = 0
            End If

        End If

    End If

    For A = 0 To 1
        ProbX = POrder(A + 2)

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then Call PrintProbability

        End If

    Next 'A
    CWinSize = oCWinSize
    CWinFract = oCWinfract
    
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    
    Seq1 = TSeq1
Seq2 = tSeq2
Seq3 = tSeq3
End Sub
Public Sub MCXoverG(SPF)
Dim TWin As Long, X As Long, LO As Long, RO As Long, n As Long, A As Long, B As Long, C As Long, D As Long, SPos As Long, EPos As Long, Step As Long, LSeq As Long, Last As Long, numSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double

numSites = Len(StrainSeq(0))
Step = MCSteplen
Last = numSites

oSeq1 = Seq1
    oSeq2 = Seq2
    oSeq3 = Seq3
    'Seq1 = 12
    'Seq2 = 19
    'Seq3 = 29
 ' 0=s1,s2Matches etc
ReDim ChiVals(Len(StrainSeq(0)), 2)
ReDim ChiPVals(Len(StrainSeq(0)), 2)
ReDim SmoothChi(Len(StrainSeq(0)), 2)
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)

NumTaxa = NextNo + 1
'7.14 of 32
    
LenXOverSeq = 0

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'Else

'This could be speeded up with better nesting
LenXOverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))
'End If
If LenXOverSeq < 2 Then Exit Sub
oMCWinSize = MCWinSize
oMCWinfract = MCWinFract
If XOverList(RelX, RelY).ProgramFlag = 3 And ExeCheckFlag = 0 Then
    MCWinSize = XOverList(RelX, RelY).LHolder
    WindowWidth = MCWinSize
    HWindowWidth = CLng(WindowWidth / 2)
Else
    If (OptFlag <> 4) Then
            BE = XOverList(RelX, RelY).Beginning
            EN = XOverList(RelX, RelY).Ending
            XPosdiff(Len(StrainSeq(0))) = LenXOverSeq
            If BE < EN Then
                MCWinSize = XPosdiff(EN) - XPosdiff(BE) + 1
            Else
                MCWinSize = XPosdiff(EN) + (LenXOverSeq - XPosdiff(BE)) + 1
            End If
            'MCWinSize = 27
            MCWinSize = MCWinSize * 2
            MCWinFract = MCWinSize / LenXOverSeq
    End If
End If
'there may be a problem with mcwinsize - ie it may be either 1 to low or too high - it is probably a rounding problem
If MCProportionFlag = 0 Then
    WindowWidth = MCWinSize
    HWindowWidth = CLng(WindowWidth / 2)
    X = X
Else
    If Int(MCWinFract * LenXOverSeq) > 20 And Int(MCWinFract * LenXOverSeq) < (LenXOverSeq / 1.5) Then
        WindowWidth = (Int((MCWinFract * LenXOverSeq) / 2) * 2 - 2)
    ElseIf Int(MCWinFract * LenXOverSeq) <= 20 Then

        If LenXOverSeq > 15 Then
            WindowWidth = 20
        Else
            Exit Sub
        End If

    ElseIf Int(MCWinFract * LenXOverSeq) >= (LenXOverSeq / 1.5) Then

        If LenXOverSeq / 1.5 > 10 Then
            WindowWidth = (Int((LenXOverSeq / 1.5) / 2) * 2 - 2)
        Else
            Exit Sub
        End If

    End If
    HWindowWidth = CLng(WindowWidth / 2)
    ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    Call GetCriticalDiff(0)
    If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
        MCWinSize = HWindowWidth * 2
    End If
End If


If HWindowWidth > LenXOverSeq / 2 Then
    HWindowWidth = LenXOverSeq - HWindowWidth + 1
    If HWindowWidth < 3 Then
        HWindowWidth = LenXOverSeq / 2
    End If
End If


If HWindowWidth < 4 Then Exit Sub
SPos = -HWindowWidth
EPos = LenXOverSeq + HWindowWidth

'9 OF 32
'HWindowWidth = 7

    
ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)

Dummy = WinScoreCalc(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffpos(0), SeqNum(0, 0), WinScores(0, 0))


'For X = LenXoverSeq - HWindowWidth To LenXoverSeq - 1
'    xx1 = xx1 + Scores(X, 0)
'    xx2 = xx2 + Scores(X, 1)
'    Xx3 = Xx3 + Scores(X, 2) ''

'Next X
'For X = 41 To 50
'    xx1 = xx1 + Scores(X, 0)
'    xx2 = xx2 + Scores(X, 1)
'    Xx3 = Xx3 + Scores(X, 2)

'Next X
'X = LenXoverSeq - 1
'For X = 0 To 20
    'Scores(X, 0) = Scores(X, 0)
    'Scores(X, 1) = Scores(X, 1)
    'Scores(X, 2) = Scores(X, 2)
'    WinScores(X, 0) = WinScores(X, 0)
'    WinScores(X, 1) = WinScores(X, 1)
'    WinScores(X, 2) = WinScores(X, 2)
''    XDiffPos(X) = XDiffPos(X)
'    XPosDiff(X) = XPosDiff(X)
'Next X

'If Dummy = 0 Then Exit Sub
'XDiffPos(462) = XDiffPos(462)
'9 of 32
'This could be speeded up with better nesting
MChi = CalcChiVals(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0, 0), ChiVals(0, 0))


'ChiVals(766, 0) = ChiVals(766, 0)
'ChiVals(766, 1) = ChiVals(766, 1)
'ChiVals(766, 2) = ChiVals(766, 2)
'XPosDiff(1613) = XPosDiff(1613)
'WinScores(766, 0) = WinScores(766, 0)
'WinScores(766, 1) = WinScores(766, 1)
'WinScores(766, 2) = WinScores(483, 2)
If MCFlag = 0 Then
    lPrb = (LowestProb / MCCorrection)
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (LenXOverSeq / (HWindowWidth)) * 3


MChi = -Log10(MChi)


MCMinChiP = MChi
    

'If MCFlag = 0 Then
    If MCMinChiP < -Log10((LowestProb / MCCorrection)) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
'Else
'    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
'End If

MChi = MCMinChiP

For X = 0 To 2
    For Y = 0 To LenXOverSeq
        If CLng(pMCWinSize / 2) > HWindowWidth Then
            ChiVals(Y, X) = ChiPVal(ChiVals(Y, X)) * (LenXOverSeq / (HWindowWidth)) * 3
        Else
            ChiVals(Y, X) = ChiPVal(ChiVals(Y, X)) * (LenXOverSeq / (CLng(pMCWinSize / 2))) * 3
        End If
        If ChiVals(Y, X) > 1 Then ChiVals(Y, X) = 1
    Next Y
Next X

ChiVals(LenXOverSeq, 0) = ChiVals(0, 0)
ChiVals(LenXOverSeq, 1) = ChiVals(0, 1)
ChiVals(LenXOverSeq, 2) = ChiVals(0, 2)
If SPF = 0 Then
        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        Form1.Picture7 = LoadPicture()
        ReDim MCPrintPos(LenXOverSeq)
        ReDim MCPrintData(2, LenXOverSeq)
        
        For X = 0 To LenXOverSeq
            MCPrintPos(X) = XDiffpos(X)
        Next X

        YScaleFactor = 0.85
        
        Call DoAxes(Len(StrainSeq(0)), -1, MChi, 0, 1, "-Log[P(Chi2)]")
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        Form1.Picture7.DrawWidth = 3
        For Y = 0 To 2
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            If Y = 0 Then
                Form1.Picture7.ForeColor = LYellow
            ElseIf Y = 1 Then
                Form1.Picture7.ForeColor = LGreen
            ElseIf Y = 2 Then
                Form1.Picture7.ForeColor = LPurple
            End If
            Pict = Form1.Picture7.hdc
            X = 0
            Dummy = MoveToEx(Pict, (30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor), -15 + PicHeight - (-Log10(ChiVals(0, Y)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(Y, 1) = ChiVals(1, Y)
            For X = 1 To LenXOverSeq - 1
                MCPrintData(Y, X) = ChiVals(X, Y)
                Dummy = LineTo(Pict, 30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor, -15 + PicHeight - (-Log10(ChiVals(X, Y)) / MChi) * (PicHeight - 35))
                
            Next '
        Next '
        Form1.Picture7.DrawWidth = 1
        Call Highlight
        
        Form1.Picture7.DrawStyle = 2

        Dim ZP As Double
    
        If ExeCheckFlag = 1 Or MCFlag <> 0 Then
            ZP = LowestProb '/ (LenXoverSeq / HWindowWidth)
            XX = -Log10(ZP)
            Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35))), QBColor(0)
        End If
    
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35))), QBColor(0)
        Form1.Picture7.DrawStyle = 0
        
        For Y = 0 To 2
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            If Y = 0 Then
                Form1.Picture7.ForeColor = Yellow
            ElseIf Y = 1 Then
                Form1.Picture7.ForeColor = Green
            ElseIf Y = 2 Then
                Form1.Picture7.ForeColor = Purple
            End If
            Pict = Form1.Picture7.hdc
            X = 0
            Dummy = MoveToEx(Pict, (30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor), -15 + PicHeight - (-Log10(ChiVals(0, Y)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(Y, 1) = ChiVals(1, Y)
            For X = 1 To LenXOverSeq - 1
                MCPrintData(Y, X) = ChiVals(X, Y)
                Dummy = LineTo(Pict, 30 + (XDiffpos(X) + (XDiffpos(X + 1) - XDiffpos(X)) / 2) * XFactor, -15 + PicHeight - (-Log10(ChiVals(X, Y)) / MChi) * (PicHeight - 35))
                
            Next '
        Next '
      
        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    End If
    Dim TB As Long, TE As Long

    If XOverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XOverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XOverList(RelX, RelY).Beginning - 20
    End If

    If XOverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XOverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XOverList(RelX, RelY).Ending + 20
    End If

    Dim Z As Long, MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If XPosdiff(TB) = 0 Then
        If TB < Len(StrainSeq(0)) / 2 Then
            bt = 1
        Else
            bt = LenXOverSeq
        End If
    Else
        bt = XPosdiff(TB) - 1
    End If
    If XPosdiff(TE) >= LenXOverSeq Then
        ET = 1
    Else
        ET = XPosdiff(TE) + 1
    End If
    
    If ET > bt Then
        
        For X = bt To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then

                For Z = 0 To 2

                    If ChiVals(X, Z) < MinPA2 And Abs(TE - (XDiffpos(X))) < Abs(TB - (XDiffpos(X))) Then
                        MinPA2 = ChiVals(X, Z)
                        XP2 = XDiffpos(X)
                    ElseIf ChiVals(X, Z) < MinPA And Abs(TE - (XDiffpos(X))) > Abs(TB - (XDiffpos(X))) Then
                        MinPA = ChiVals(X, Z)
                        XP1 = XDiffpos(X)
                    End If

                Next 'Z

            'End If

        Next 'X

    Else

        For X = bt To LenXOverSeq 'ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then

                For Z = 0 To 2

                    If ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA2 And Abs(TE - (XDiffpos(X))) < Abs(TB - (XDiffpos(X))) Then
                        MinPA2 = ChiVals(X, Z)
                        XP2 = XDiffpos(X)
                    ElseIf ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA And Abs(TE - (XDiffpos(X))) > Abs(TB - (XDiffpos(X))) Then
                        MinPA = ChiVals(X, Z)
                        XP1 = XDiffpos(X)
                    End If

                Next 'Z

            'End If

        Next 'X
        For X = 1 To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then

                For Z = 0 To 2

                    If ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA2 And Abs(TE - (XDiffpos(X))) < Abs(TB - (XDiffpos(X))) Then
                        MinPA2 = ChiVals(X, Z)
                        XP2 = XDiffpos(X)
                    ElseIf ChiVals(X, Z) > 0 And ChiVals(X, Z) < MinPA And Abs(TE - (XDiffpos(X))) > Abs(TB - (XDiffpos(X))) Then
                        MinPA = ChiVals(X, Z)
                        XP1 = XDiffpos(X)
                    End If

                Next 'Z

            'End If

        Next 'X

    End If

    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)

    If MCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf MCFlag = 2 Then
        MinPA = StepDown2(3, MinPA)
        MinPA2 = StepDown2(3, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    
    PT = 10 ^ (-ConfirmP(EN, 3))
    
    If X = X Or (XOverList(RelX, RelY).ProgramFlag <> 3 And XOverList(RelX, RelY).ProgramFlag <> 3 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 3) = 0 Or (Confirm(EN, 3) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 3) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA2)
            End If
            DoEvents

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

    Else

        If MinPA < MinPA2 Then

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(0) = XOverList(RelX, RelY).Probability
                POrder(2) = XOverList(RelX, RelY).Beginning
            Else
                POrder(0) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(1) = MinPA2
                POrder(3) = XOverList(RelX, RelY).Ending
            Else
                POrder(1) = 0
            End If

        Else

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(1) = MinPA
                POrder(3) = XOverList(RelX, RelY).Beginning
            Else
                POrder(1) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(0) = XOverList(RelX, RelY).Probability
                POrder(2) = XOverList(RelX, RelY).Ending
            Else
                POrder(0) = 0
            End If

        End If

    End If

    For A = 0 To 1
        ProbX = POrder(A + 2)
        

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then Call PrintProbability

        End If

    Next 'A
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
End Sub
Public Sub CXoverA(FindAllFlag As Byte, BEP, ENP)

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) = 0 And GrpMaskSeq(Seq2) = 0 And GrpMaskSeq(Seq3) = 0 Then
        Exit Sub
    End If
End If

Dim CurWinPos As Long, CurWin As Double, thMChi As Double, XB As Long, XE As Long, BE As Long, EN As Long, LOT(1) As Double, GoOn As Byte, WasteOfTime As Long, TWin As Long, X As Long, LO As Long, RO As Long, n As Long, A As Long, B As Long, C As Long, D As Long, Step As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim DoneThis As Byte
Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
Dim Failcount As Long
Dim hMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long, ZP As Double, PntAPI As POINTAPI, Pict As Long
Dim MaxFailCount As Long, MaxZ As Long

'7.14 of 32
'If SEventNumber = 9 Then
'    X = X
'End If

LenXOverSeq = 0

    
LenXOverSeq = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))

If LenXOverSeq < CriticalDiff * 2 Then Exit Sub

If LenXOverSeq < 7 Then
    Exit Sub
End If

Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXOverSeq, CWinFract, CWinSize, HWindowWidth, lHWindowWidth, GoOn, FindAllFlag, CProportionFlag, XPosdiff())


If GoOn = 0 Then Exit Sub

If HWindowWidth <> lHWindowWidth Then
    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2)
    lHWindowWidth = HWindowWidth
End If

'9 of 32

Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, ScoresX(0), XDiffpos(0), SeqNum(0, 0), WinScoresX(0))

If Dummy = 0 And ShortOutFlag <> 3 Then Exit Sub

If FindAllFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
        If SEventNumber = 1 Then
            ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
        End If
        Dummy = MakeBanWin(Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXOverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosdiff(0), XDiffpos(0))
    Else
        ReDim MDMap(LenXOverSeq), BanWin(LenXOverSeq + HWindowWidth * 2)
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXOverSeq) = 1
        For X = (LenXOverSeq - HWindowWidth + 2) To LenXOverSeq
            BanWin(X) = 1
        Next X
    End If

    '10.605
    '10.465 using offsets
    MChi = CalcChiVals5(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScoresX(0), ChiValsX(0), BanWin(0))
Else
    MChi = CalcChiVals3(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScoresX(0), ChiValsX(0))
End If
'9 of 32


'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3) > LowestProb Then Exit Sub
    Else
        If ((ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then Exit Sub
    End If


If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXOverSeq, HWindowWidth, mtP(), 4)
End If

'Smooth to find peaks (uses a window of positions)
SmoothChiVals3 LenXOverSeq, Len(StrainSeq(0)), ChiValsX(0), SmoothChiX(0)

If LongWindedFlag = 0 Then
    If TreeDistance(Seq1, Seq2) > TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) > TreeDistance(Seq2, Seq3) Then
        HighHomol = 1
        If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
        Else
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
        End If
    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2
        If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
        Else
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
        End If
    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3
        If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
        Else
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
        End If
    End If
End If



MChi = 0
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events

Do
    
    FindMChi3 Len(StrainSeq(0)), LenXOverSeq, MaxX, MaxY, MChi, ChiValsX(0)
    If MChi = 0 Then Exit Sub
    mPrb = ChiPVal2(MChi)
    If mPrb * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
    
    If MCProportionFlag = 0 Then
        If (mPrb * (LenXOverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then Exit Sub
    Else
        If ((mPrb * (LenXOverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then Exit Sub
    End If
    
    If mPrb < LowestProb And mPrb <> 1 Then
        
        Call MakeTWin(FindAllFlag, HWindowWidth, TWin, LenXOverSeq)
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXOverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXOverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        
        Dummy = GetAC(LenXOverSeq, Len(StrainSeq(0)), 0, MaxX, TWin, A, C, ScoresX(0))
        
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXOverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXOverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXOverSeq
            Else
                MaxX = LenXOverSeq - 1
            End If
        End If
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXOverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXOverSeq + LO
        
        RO = (MaxX + TWin)
        If RO >= LenXOverSeq Then
            If MDMap(LenXOverSeq) = 0 Then
                RO = RO - LenXOverSeq
            Else
                TWin = TWin - 1
                RO = LenXOverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXOverSeq + LO
            End If
        End If
        
                'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        If FindAllFlag = 0 Then
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, 0, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, ScoresX(0), MDMap(0))
            Else
                Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, 0, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, ScoresX(0))
            End If
        End If
        
        xMPV = MPV 'MCCorrection * 3
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        If ShortOutFlag = 3 Then
            If MPV <= mtP(4) Then
                mtP(4) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO > LenXOverSeq Then
            If MDMap(RO - LenXOverSeq) = 0 Then
                RO = RO - LenXOverSeq
            Else
                RO = LenXOverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXOverSeq
        End If
        
        If MPV < LowestProb Then
            'Do permutations if necessary
            If MCPerms > 0 Then
                If LO < RO Then
                    LenR = RO - LO
                Else
                    LenR = RO + LenXOverSeq - LO
                End If
                ReDim MCPScore(LenR * 2)
                    'this coluld be speeded up with better nesting of if then's
    
                pmChi = DoChiPerms(MChi, WinWin, LenXOverSeq, LenR, MCPerms, LO, MCPScore(0), ScoresX(0))
                PPVal = pmChi / MCPerms
            Else
                PPVal = -1
            End If
            
            If (MCPerms > 0 And MCPermMaxP < PPVal) Or MCPerms = 0 Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXOverSeq) < 0 Then
                     LO = (-LenXOverSeq + WinWin)
                End If
                
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXOverSeq, 0, ScoresX(0), HiLeft, HiRight)
                
                If HiLeft >= HiRight Then
                    
                                        'Find "best" matching breakpoint position.
                    E = 0
                    For X = LO - WinWin To LO - 1
                        If X < 1 Then
                            E = E + ScoresX(LenXOverSeq + X)
                        ElseIf X > LenXOverSeq Then
                            E = E + ScoresX(X - LenXOverSeq)
                        Else
                            E = E + ScoresX(X)
                        End If
                    Next X
                    P = MaxX - 1
                    M = LO - 1
                    n = LO - WinWin
                    
                    If P < 1 Then
                        P = LenXOverSeq + P
                    End If
                    If n < 1 Then
                        n = LenXOverSeq + n
                    End If
                    If M < 1 Then
                        M = LenXOverSeq + M
                    End If
                    A = E
                    C = TopL
                    CurWin = HiLeft
                    CurWinPos = M
                    Failcount = 0
                    Do
                        
                        A = A - ScoresX(M)
                        C = C - ScoresX(P)
                        C = C + ScoresX(M)
                        P = P - 1
                        n = n - 1
                        M = M - 1
                        If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                            Exit Do
                        End If
                        If P < 1 Then
                            P = LenXOverSeq
                        End If
                        If n < 1 Then
                            n = LenXOverSeq
                        End If
                        If M < 1 Then
                            M = LenXOverSeq
                        End If
                        If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                            Exit Do
                        End If
                        A = A + ScoresX(n)
                        
                        B = WinWin - A
                        D = WinWin - C
                        If A + C > 0 And B + D > 0 Then
                            E = A * D - B * C
                            thMChi = E * E * 2
                            E = (A + C) * (B + D)
                            E = E * WinWin
                            thMChi = thMChi / E
                            If (thMChi < 0) Then
                                thMChi = Abs(hMChi)
                            End If
                            If thMChi > CurWin Then
                                CurWin = thMChi
                                CurWinPos = M
                                Failcount = 0
                            Else
                                Failcount = Failcount + 1
                                If Failcount > WinWin / 10 Then
                                    Exit Do
                                End If
                            End If
                        End If
                
                    Loop
                    LO = CurWinPos + 1
                    If LO > LenXOverSeq Then LO = 1
                    If FindAllFlag = 1 Then
                        XB = XDiffpos(MaxX)
                        XE = XDiffpos(RO)
                        If MCFlag = 0 Then
                            XEP = ChiPVal(ChiValsX(RO)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                            XBP = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        Else
                            XEP = ChiPVal(ChiValsX(RO)) * 3 * LenXOverSeq / HWindowWidth
                            XBP = mPrb * 3 * LenXOverSeq / HWindowWidth
                        
                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1
                        MCMaxY = 1
                    Else
                        LoHiFlag = 1
                        MCMaxY = 0
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXOverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXOverSeq + MaxX
                    ElseIf MaxX > LenXOverSeq Then
                        RO = MaxX - LenXOverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXOverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXOverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXOverSeq Then RO = LenXOverSeq
                    
                    If LO + 1 > LenXOverSeq Then
                        BE = XDiffpos(LO)
                    Else
                        BE = XDiffpos(LO + 1)
                    End If
                    EN = XDiffpos(RO)
                    If MCFlag = 0 Then
                        BPV = ChiPVal(ChiValsX(LO)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        EPV = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                    Else
                        BPV = ChiPVal(ChiValsX(LO)) * 3 * LenXOverSeq / HWindowWidth
                        EPV = mPrb * 3 * LenXOverSeq / HWindowWidth
                    End If
                Else
                    'Find "best" matching breakpoint position.
                    E = 0
                    For X = RO + 1 To RO + WinWin
                        If X < 1 Then
                            E = E + ScoresX(LenXOverSeq + X)
                        ElseIf X > LenXOverSeq Then
                            E = E + ScoresX(X - LenXOverSeq)
                        Else
                            E = E + ScoresX(X)
                        End If
                    Next X
                    n = MaxX
                    M = RO + 1
                    P = RO + WinWin
                    If P > LenXOverSeq Then
                        P = P - LenXOverSeq
                    End If
                    If n > LenXOverSeq Then
                        n = n - LenXOverSeq
                    End If
                    If M > LenXOverSeq Then
                        M = M - LenXOverSeq
                    End If
                    A = TopR
                    C = E
                    CurWin = HiRight
                    CurWinPos = M
                    Failcount = 0
                    Do
                        
                        A = A - ScoresX(n)
                        C = C - ScoresX(M)
                        A = A + ScoresX(M)
                        P = P + 1
                        n = n + 1
                        M = M + 1
                        
                        If P > LenXOverSeq Then
                            P = 1
                        End If
                        If n > LenXOverSeq Then
                            n = 1
                        End If
                        If M > LenXOverSeq Then
                            M = 1
                        End If
                        If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                            Exit Do
                        End If
                        C = C + ScoresX(P)
                        B = WinWin - A
                        D = WinWin - C
                        If A + C > 0 And B + D > 0 Then
                            E = A * D - B * C
                            thMChi = E * E * 2
                            E = (A + C) * (B + D)
                            E = E * WinWin
                            thMChi = thMChi / E
                            If (thMChi < 0) Then
                                thMChi = Abs(hMChi)
                            End If
                            If thMChi > CurWin Then
                                CurWin = thMChi
                                CurWinPos = M
                                Failcount = 0
                            Else
                                Failcount = Failcount + 1
                                If Failcount > WinWin / 10 Then
                                    Exit Do
                                End If
                            End If
                        End If
                
                    Loop
                    RO = CurWinPos - 1
                    If RO < 1 Then RO = LenXOverSeq
                    'MaxX = MaxX
                    If FindAllFlag = 1 Then
                        XB = XDiffpos(LO)
                        XE = XDiffpos(MaxX)
                        If MCFlag = 0 Then
                            XBP = ChiPVal(ChiValsX(LO)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                            XEP = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        Else
                            XBP = ChiPVal(ChiValsX(LO)) * 3 * LenXOverSeq / HWindowWidth
                            XEP = mPrb * 3 * LenXOverSeq / HWindowWidth
                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1
                        MCMaxY = 0
                    Else
                        LoHiFlag = 1
                        MCMaxY = 1
                    End If
                    
                    If RO > LenXOverSeq Then
                        RO = RO - LenXOverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXOverSeq + MaxX
                    ElseIf MaxX > LenXOverSeq Then
                        LO = MaxX - LenXOverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXOverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXOverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXOverSeq Then
                        BE = XDiffpos(LO)
                    Else
                        BE = XDiffpos(LO + 1)
                    End If
                    EN = XDiffpos(RO)
                    
                    
                    If MCFlag = 0 Then
                        BPV = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        EPV = ChiPVal(ChiValsX(RO)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                    Else
                        BPV = mPrb * 3 * LenXOverSeq / HWindowWidth
                        EPV = ChiPVal(ChiValsX(RO)) * 3 * LenXOverSeq / HWindowWidth
                    End If
                End If
                
                MaxX = pMaxX
               
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                Dummy = DestroyPeaks(0, LenXOverSeq, Len(StrainSeq(0)), LO, RO, SmoothChiX(0), ChiValsX(0))
                ChiValsX(MaxZ) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If (CPerms > 0 And CPermMaxP < PPVal) Or (MPV < LowestProb And MCPerms = 0) Then 'it is necessary to destroy the region if it is not accepted
                    GoOn = 1
                     If FindAllFlag = 1 Then
                        
                            If X = X Then
                                If XB < XE Then
                                    For zz = XB To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                Else
                                    For zz = 1 To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                    For zz = XB To Len(StrainSeq(0))
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                End If
                            End If
                    End If
                                            'thats why this cut must be remade here
                    'store the event
                    If LongWindedFlag = 1 Then
                        If CurrentXover(Seq1) <= CurrentXover(Seq2) And CurrentXover(Seq1) <= CurrentXover(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf CurrentXover(Seq2) <= CurrentXover(Seq1) And CurrentXover(Seq2) <= CurrentXover(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        Else
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                    End If
                    
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(4) = oRecombNo(4) + 1
                    
                    If APermFlag = 0 Then
                        Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 4, ProbabilityXOver, SIP)
                    Else
                        SIP = 1
                    End If
                    
                    If SIP = -1 Then
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(4, Seq1, Seq2, Seq3)
                        End If
                    Else
                        XOverList(ActiveSeq, SIP).Daughter = ActiveSeq
                        XOverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XOverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XOverList(ActiveSeq, SIP).SBPFlag = 0
                        XOverList(ActiveSeq, SIP).ProgramFlag = 4
                        If EN = 982 Then
                            X = X
                        End If
                        Call CentreBP(BE, EN, XPosdiff(), XDiffpos(), BWarn, EWarn, CWinSize / 2, LenXOverSeq)
                        If EN = 982 Then
                            X = X
                        End If
                        XOverList(ActiveSeq, SIP).Beginning = BE
                        XOverList(ActiveSeq, SIP).Ending = EN
                        XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        XOverList(ActiveSeq, SIP).PermPVal = PPVal
                        XOverList(ActiveSeq, SIP).BeginP = BPV
                        XOverList(ActiveSeq, SIP).EndP = EPV
                        XOverList(ActiveSeq, SIP).DHolder = Seq1
                        'If Seq1 = 0 And SEventNumber = 1 Then
                        '    X = X
                        'End If
                        'Store the window size used to detect this event
                        XOverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                            If XPosdiff(EN) = LenXOverSeq Then
                                ENx = 1
                            Else
                                ENx = XPosdiff(EN) + 1
                            End If
                            If XPosdiff(BE) = 1 Or XPosdiff(BE) = 0 Then
                                BEx = LenXOverSeq
                            Else
                                BEx = XPosdiff(BE) - 1
                            End If
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(CWinSize / 2, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                                If BWarn = 0 Then Call CheckEndsVB(CWinSize / 2, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                            End If
                            If (MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1) And (MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1 Or (EWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1 Or (BWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        If GoOn = 0 And FindAllFlag = 1 Then 'erase it if it contained missingdata
                            CurrentXover(ActiveSeq) = CurrentXover(ActiveSeq) - 1
                        ElseIf FindAllFlag = 0 Then
                            OActive = ActiveSeq
                            OMajP = ActiveMajorP
                            OMinP = ActiveMinorP
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 4, SIP)
                            Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, CWinSize / 2, LenXOverSeq)
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(4) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        
                        If FindAllFlag = 1 Then
                            GoOn = 1
                            If X = X Then
                                If XB < XE Then
                                    For zz = XB To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next zz
                                Else
                                    For zz = 1 To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next zz
                                    For zz = XB To Len(StrainSeq(0))
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next zz
                                End If
                            End If
                            If GoOn = 1 Then
                                Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 4, ProbabilityXOver, SIP)
                                XOverList(ActiveSeq, SIP) = XOverList(ActiveSeq, SIP - 1)
                                XOverList(ActiveSeq, SIP).SBPFlag = 0
                                'Call CentreBP(BE, EN, XPosdiff(), XDiffpos(), BWarn, EWarn, CWinSize / 2, LenXOverSeq)
                                XOverList(ActiveSeq, SIP).Beginning = EN
                                If BE = 982 Then
                            X = X
                        End If
                                XOverList(ActiveSeq, SIP).Ending = BE
                                XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                XOverList(ActiveSeq, SIP).PermPVal = PPVal
                                XOverList(ActiveSeq, SIP).BeginP = XBP
                                XOverList(ActiveSeq, SIP).EndP = XEP
                                'XOverList(ActiveSeq, SIP).DHolder = Seq1
                                
                                'Store the window size used to detect this event
                                If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                                    If XPosdiff(EN) = LenXOverSeq Then
                                        ENx = 1
                                    Else
                                        ENx = XPosdiff(EN) + 1
                                    End If
                                    If XPosdiff(BE) = 1 Or XPosdiff(BE) = 0 Then
                                        BEx = LenXOverSeq
                                    Else
                                        BEx = XPosdiff(BE) - 1
                                    End If
                                    If SEventNumber > 0 Then
                                        If EWarn = 0 Then Call CheckEndsVB(CWinSize / 2, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosdiff(), XDiffpos())
                                        If BWarn = 0 Then Call CheckEndsVB(CWinSize / 2, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosdiff(), XDiffpos())
                                    End If
                                    If (MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1) And (MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 3
                                    ElseIf MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1 Or (EWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 2
                                    ElseIf MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1 Or (BWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 1
                                    End If
                                    If FindAllFlag = 0 Then
                                        If LoHiFlag = 0 Then
                                            LoHiFlag = 1
                                        Else
                                            LoHiFlag = 0
                                        End If
                                        If MCMaxX = 0 Then
                                            MCMaxX = 1
                                        Else
                                            MCMaxX = 0
                                        End If
                                        OActive = ActiveSeq
                                        OMajP = ActiveMajorP
                                        OMinP = ActiveMinorP
                                            
                                        Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 4, SIP)
                                        Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, CWinSize / 2, LenXOverSeq)
                                    Else
                                        SIP = SIP + 1
                                        
                                    End If
                                End If
                            End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(4) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(4) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        
                        
                        
                       
                        ActiveSeq = OActive
                        ActiveMajorP = OMajP
                        ActiveMinorP = OMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            mPrbL = -Log10(mPrb)
                            DoneThis = 1
                            Call DoAxes(Len(StrainSeq(0)), -1, -Log10(mPrb), 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = LowestProb
                            'Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / mPrbL) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / mPrbL) * (PicHeight - 35))), QBColor(0)
                            'Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / mPrbL) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / mPrbL) * (PicHeight - 35))), QBColor(0)
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            Pict = Form1.Picture7.hdc
                            Dummy = MoveToEx(Pict, (30 + XDiffpos(1) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(ChiValsX(1))) / mPrbL) * (PicHeight - 35), PntAPI)
                                
                            For X = 2 To LenXOverSeq - 1
                                Dummy = LineTo(Pict, 30 + XDiffpos(X) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(ChiValsX(X))) / mPrbL) * (PicHeight - 35))
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then Exit Sub
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then Exit Sub
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then Exit Sub
            RO = pMaxX
            LO = pMaxX
            'destroy the maxx peak
            Dummy = DestroyPeak(0, Len(StrainSeq(0)), RO, LO, LenXOverSeq, LOT(0), SmoothChiX(0), ChiValsX(0))
            If MaxZ = -1 Then Exit Sub
            ChiValsX(MaxZ) = 0
            If Dummy = 0 Then Exit Sub
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop

End Sub
Public Sub MCXoverF(FindAllFlag As Byte, BEP, ENP)

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) = 0 And GrpMaskSeq(Seq2) = 0 And GrpMaskSeq(Seq3) = 0 Then
        Exit Sub
    End If
End If

Dim xMPV As Variant, GoOn As Byte, XB As Long, XE As Long, XBP As Double, XEP As Double, DoneRedo As Byte, LOT(1) As Double, BPP As Double, EPP As Double, BPV As Double, EPV As Double, PPVal As Double, BE As Long, EN As Long, DoneThis As Byte
Dim MaxX As Long, WinWin As Long
Dim Failcount As Long
Dim MPV As Double, hMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long
Dim mPrbL As Double, ZP As Double

Dim WasteOfTime As Long, TWin As Long, X As Long, LO As Long, RO As Long, n As Long, A As Long, B As Long, C As Long, D As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim ProbabilityXOver As Double
Dim Pict As Long
Dim PntAPI As POINTAPI
Dim PV As Double, MaxFailCount As Long
'If SEventNumber = 0 Then
'If Seq1 = 4 Or Seq1 = 5 Or Seq1 = 24 Then
'If Seq2 = 5 Or Seq2 = 4 Or Seq2 = 24 Then
'If Seq3 = 24 Or Seq3 = 4 Or Seq3 = 5 Then
'X = X
'End If
'End If
'End If
'End If




'1.641,1.562
'This could be speeded up with better nesting
LenXOverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))

'3.015,3.078



'I must calculate a more severe critical diff for the mccorrection - ie 2 diffs
'must be calculated - one for here and one for later on in calcchivals.
If LenXOverSeq < CriticalDiff * 2 Then Exit Sub

If LenXOverSeq < 7 Then
    Exit Sub
End If


Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXOverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindAllFlag, MCProportionFlag, XPosdiff())

'3.375,3.281



If GoOn = 0 Then Exit Sub

If HWindowWidth <> lHWindowWidth Then
    ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    lHWindowWidth = HWindowWidth
End If


'3.312
Dummy = WinScoreCalc(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffpos(0), SeqNum(0, 0), WinScores(0, 0))

'4.656,4.750


'This could be speeded up with better nesting

 

If FindAllFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
        If SEventNumber = 1 Then
            ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
        ElseIf UBound(BanWin, 1) <> Len(StrainSeq(0)) + HWindowWidth * 2 Then
            ReDim BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
        End If
        Dummy = MakeBanWin(Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXOverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosdiff(0), XDiffpos(0))
        
       
        X = X
    Else
        ReDim MDMap(LenXOverSeq), BanWin(LenXOverSeq + HWindowWidth * 2)
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXOverSeq) = 1
        For X = (LenXOverSeq - HWindowWidth + 2) To LenXOverSeq
            BanWin(X) = 1
        Next X
    End If

    '10.605
    '10.465 using offsets
    MChi = CalcChiVals4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0, 0), ChiVals(0, 0), BanWin(0))
Else
    MChi = CalcChiVals(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0, 0), ChiVals(0, 0))
End If




'8.203
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3) > LowestProb Then Exit Sub
    Else
        If ((ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then Exit Sub
    End If
'8.313

If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXOverSeq, HWindowWidth, mtP(), 3)
End If


'Smooth to find peaks (uses a window of positions)
SmoothChiVals LenXOverSeq, Len(StrainSeq(0)), ChiVals(0, 0), SmoothChi(0, 0)

'9.125,9.172





MChi = 0
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events



Do
    
    FindMChi Len(StrainSeq(0)), LenXOverSeq, MaxX, MaxY, MChi, ChiVals(0, 0)
    
    '8.828,8.844
    
    If MaxX = -1 Or MaxY = -1 Then
        Exit Sub
    End If
    mPrb = ChiPVal2(MChi)
    If MCProportionFlag = 0 Then
        If (mPrb * (LenXOverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then Exit Sub
    Else
        If ((mPrb * (LenXOverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then Exit Sub
    End If
    '8.907
    'Exit Sub
    'XX = XPosDiff(2688)
    '10.000
    'Exit Sub
    If mPrb < LowestProb Then
        MaxZ = MaxX
        
        If MaxX = 0 Then MaxX = 1
       
        Call MakeTWin(FindAllFlag, HWindowWidth, TWin, LenXOverSeq)
        
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXOverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXOverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        
        Dummy = GetAC(LenXOverSeq, Len(StrainSeq(0)), MaxY, MaxX, TWin, A, C, Scores(0, 0))
        
        'Now find the other breakpoint.
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXOverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXOverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXOverSeq
            Else
                MaxX = LenXOverSeq - 1
            End If
        End If
        
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXOverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXOverSeq + LO
        
        RO = (MaxX + TWin)
        If RO >= LenXOverSeq Then
            If MDMap(LenXOverSeq) = 0 Then
                RO = RO - LenXOverSeq
            Else
                TWin = TWin - 1
                RO = LenXOverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXOverSeq + LO
                        
            End If
        End If
        'XX = MDMap(1)
        'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        If FindAllFlag = 0 Then
            
            
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
            Else
                Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                
            End If
            
        End If
        'xMPV
        
        
        On Error Resume Next
        xMPV = MPV 'MCCorrection * 3
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        On Error GoTo 0
        
        If ShortOutFlag = 3 Then
            If MPV <= mtP(3) Then
                mtP(3) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO > LenXOverSeq Then
            If MDMap(RO - LenXOverSeq) = 0 Then
                RO = RO - LenXOverSeq
            Else
                RO = LenXOverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXOverSeq
        End If
        
        If MPV < LowestProb Then
            
            'Do permutations if necessary
            If MCPerms > 0 Then
                If LO < RO Then
                    LenR = RO - LO
                Else
                    LenR = RO + LenXOverSeq - LO
                End If
                ReDim MCPScore(LenR * 2)
                    'this coluld be speeded up with better nesting of if then's
    
                pmChi = DoChiPerms(MChi, WinWin, LenXOverSeq, LenR, MCPerms, LO, MCPScore(0), Scores(0, MaxY))
                PPVal = pmChi / MCPerms
            Else
                PPVal = -1
            End If
            
            If (MCPerms > 0 And MCPermMaxP < PPVal) Or MCPerms = 0 Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXOverSeq) < 0 Then
                     LO = (-LenXOverSeq + WinWin)
                End If
                
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXOverSeq, MaxY, Scores(0, 0), HiLeft, HiRight)
                
                If HiLeft >= HiRight Then
                                        'Find "best" matching breakpoint position.
                    If X = 12345 Then '39199
                        CurWinPos = OptLeftBPMC(LO, HiLeft, TopL, MaxX, MaxY, WinWin, LenXOverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                        LO = CurWinPos
                    ElseIf X = 12345 Then
                        E = 0
                        For X = LO - WinWin To LO - 1
                            If X < 1 Then
                                E = E + Scores(LenXOverSeq + X, MaxY)
                            ElseIf X > LenXOverSeq Then
                                E = E + Scores(X - LenXOverSeq, MaxY)
                            Else
                                E = E + Scores(X, MaxY)
                            End If
                        Next X
                        P = MaxX - 1
                        M = LO - 1
                        n = LO - WinWin
                        
                        If P < 1 Then
                            P = LenXOverSeq + P
                        End If
                        If n < 1 Then
                            n = LenXOverSeq + n
                        End If
                        If M < 1 Then
                            M = LenXOverSeq + M
                        End If
                        A = E
                        C = TopL
                        CurWin = HiLeft
                        CurWinPos = M
                        Failcount = 0
                        Do
                            
                            A = A - Scores(M, MaxY)
                            C = C - Scores(P, MaxY)
                            C = C + Scores(M, MaxY)
                            P = P - 1
                            n = n - 1
                            M = M - 1
                            If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                                Exit Do
                            End If
                            If P < 1 Then
                                P = LenXOverSeq
                            End If
                            If n < 1 Then
                                n = LenXOverSeq
                            End If
                            If M < 1 Then
                                M = LenXOverSeq
                            End If
                            If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                                Exit Do
                            End If
                            A = A + Scores(n, MaxY)
                            
                            B = WinWin - A
                            D = WinWin - C
                            If A + C > 0 And B + D > 0 Then
                                E = A * D - B * C
                                thMChi = E * E * 2
                                E = (A + C) * (B + D)
                                E = E * WinWin
                                thMChi = thMChi / E
                                If (thMChi < 0) Then
                                    thMChi = Abs(hMChi)
                                End If
                                If thMChi > CurWin Then
                                    CurWin = thMChi
                                    CurWinPos = M
                                    Failcount = 0
                                Else
                                    Failcount = Failcount + 1
                                    If Failcount > WinWin / 10 Then
                                        Exit Do
                                    End If
                                End If
                            End If
                    
                        Loop
                        LO = CurWinPos + 1
                    End If
                    If LO > LenXOverSeq Then LO = 1
                    If FindAllFlag = 1 Then
                        XB = XDiffpos(MaxX)
                        XE = XDiffpos(RO)
                        If MCFlag = 0 Then
                            XEP = ChiPVal(ChiVals(RO, MaxY)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                            XBP = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        Else
                            XEP = ChiPVal(ChiVals(RO, MaxY)) * 3 * LenXOverSeq / HWindowWidth
                            XBP = mPrb * 3 * LenXOverSeq / HWindowWidth
                        
                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXOverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXOverSeq + MaxX
                    ElseIf MaxX > LenXOverSeq Then
                        RO = MaxX - LenXOverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXOverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXOverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXOverSeq Then RO = LenXOverSeq
                    
                    If LO + 1 > LenXOverSeq Then
                        BE = XDiffpos(LO)
                    Else
                        BE = XDiffpos(LO + 1)
                    End If
                    EN = XDiffpos(RO)
                    If MCFlag = 0 Then
                        BPV = ChiPVal(ChiVals(LO, MaxY)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        EPV = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                    Else
                        BPV = ChiPVal(ChiVals(LO, MaxY)) * 3 * LenXOverSeq / HWindowWidth
                        EPV = mPrb * 3 * LenXOverSeq / HWindowWidth
                    End If
                    
                Else
                    'Find "best" matching breakpoint position.
                    If X = 1234567 Then
                        E = 0
                        For X = RO + 1 To RO + WinWin
                            If X < 1 Then
                                E = E + Scores(LenXOverSeq + X, MaxY)
                            ElseIf X > LenXOverSeq Then
                                E = E + Scores(X - LenXOverSeq, MaxY)
                            Else
                                E = E + Scores(X, MaxY)
                                
                            End If
                        Next X
                        n = MaxX
                        M = RO + 1
                        P = RO + WinWin
                        If P > LenXOverSeq Then
                            P = P - LenXOverSeq
                        End If
                        If n > LenXOverSeq Then
                            n = n - LenXOverSeq
                        End If
                        If M > LenXOverSeq Then
                            M = M - LenXOverSeq
                        End If
                        A = TopR
                        C = E
                        CurWin = HiRight
                        CurWinPos = M
                        Failcount = 0
                        Do
                            
                            A = A - Scores(n, MaxY)
                            C = C - Scores(M, MaxY)
                            A = A + Scores(M, MaxY)
                            P = P + 1
                            n = n + 1
                            M = M + 1
                            
                            If P > LenXOverSeq Then
                                P = 1
                            End If
                            If n > LenXOverSeq Then
                                n = 1
                            End If
                            If M > LenXOverSeq Then
                                M = 1
                            End If
                            If MDMap(P) = 1 Or MDMap(n) = 1 Or MDMap(M) = 1 Then
                                Exit Do
                            End If
                            C = C + Scores(P, MaxY)
                            B = WinWin - A
                            D = WinWin - C
                            If A + C > 0 And B + D > 0 Then
                                E = A * D - B * C
                                thMChi = E * E * 2
                                E = (A + C) * (B + D)
                                E = E * WinWin
                                thMChi = thMChi / E
                                If (thMChi < 0) Then
                                    thMChi = Abs(hMChi)
                                End If
                                If thMChi > CurWin Then
                                    CurWin = thMChi
                                    CurWinPos = M
                                    Failcount = 0
                                Else
                                    Failcount = Failcount + 1
                                    If Failcount > WinWin / 10 Then
                                        Exit Do
                                    End If
                                End If
                            End If
                    
                        Loop
                        RO = CurWinPos - 1
                    End If
                    If RO < 1 Then RO = LenXOverSeq
                    If FindAllFlag = 1 Then
                        XB = XDiffpos(LO)
                        XE = XDiffpos(MaxX)
                        If MCFlag = 0 Then
                            XBP = ChiPVal(ChiVals(LO, MaxY)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                            XEP = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        Else
                            XBP = ChiPVal(ChiVals(LO, MaxY)) * 3 * LenXOverSeq / HWindowWidth
                            XEP = mPrb * 3 * LenXOverSeq / HWindowWidth
                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    End If
                    
                    If RO > LenXOverSeq Then
                        RO = RO - LenXOverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXOverSeq + MaxX
                    ElseIf MaxX > LenXOverSeq Then
                        LO = MaxX - LenXOverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXOverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXOverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXOverSeq Then
                        BE = XDiffpos(LO)
                    Else
                        BE = XDiffpos(LO + 1)
                    End If
                    EN = XDiffpos(RO)
                    
                    
                    If MCFlag = 0 Then
                        BPV = mPrb * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                        EPV = ChiPVal(ChiVals(RO, MaxY)) * MCCorrection * 3 * LenXOverSeq / HWindowWidth
                    Else
                        BPV = mPrb * 3 * LenXOverSeq / HWindowWidth
                        EPV = ChiPVal(ChiVals(RO, MaxY)) * 3 * LenXOverSeq / HWindowWidth
                    End If
                    
                End If
                
                MaxX = pMaxX
                
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                'Destroy the completed peaks
                Dummy = DestroyPeaks(MaxY, LenXOverSeq, Len(StrainSeq(0)), LO, RO, SmoothChi(0, 0), ChiVals(0, 0))
                ChiVals(MaxZ, MaxY) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If (MCPerms > 0 And MCPermMaxP < PPVal) Or (MPV < LowestProb And MCPerms = 0) Then 'it is necessary to destroy the region if it is not accepted
                     GoOn = 1
                     If FindAllFlag = 1 Then
                        
                            If X = X Then
                                If XB < XE Then
                                    For zz = XB To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                Else
                                    For zz = 1 To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                    For zz = XB To Len(StrainSeq(0))
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                End If
                            End If
                    End If
                                            'thats why this cut must be remade here
                    'store the event
                    
                        If LongWindedFlag = 1 Then
                            If CurrentXover(Seq1) <= CurrentXover(Seq2) And CurrentXover(Seq1) <= CurrentXover(Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                            ElseIf CurrentXover(Seq2) <= CurrentXover(Seq1) And CurrentXover(Seq2) <= CurrentXover(Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                            Else
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                            End If
                        End If
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(3) = oRecombNo(3) + 1
                    
                    
                    If APermFlag = 0 Then
                        Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 3, ProbabilityXOver, SIP)
                    Else
                        SIP = 1
                    End If
                    
                    If SIP = -1 Then
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(3, Seq1, Seq2, Seq3)
                        End If
                    Else
                        XOverList(ActiveSeq, SIP).Daughter = ActiveSeq
                        XOverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XOverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XOverList(ActiveSeq, SIP).SBPFlag = 0
                        XOverList(ActiveSeq, SIP).ProgramFlag = 3
                        
                        Call CentreBP(BE, EN, XPosdiff(), XDiffpos(), BWarn, EWarn, MCWinSize / 2, LenXOverSeq)
                        XOverList(ActiveSeq, SIP).Beginning = BE
                        XOverList(ActiveSeq, SIP).Ending = EN
                        XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        XOverList(ActiveSeq, SIP).PermPVal = PPVal
                        XOverList(ActiveSeq, SIP).BeginP = BPV
                        XOverList(ActiveSeq, SIP).EndP = EPV
                       
                        'Store the window size used to detect this event
                        XOverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                            If XPosdiff(EN) = LenXOverSeq Then
                                ENx = 1
                            Else
                                ENx = XPosdiff(EN) + 1
                            End If
                            If XPosdiff(BE) = 1 Or XPosdiff(BE) = 0 Then
                                BEx = LenXOverSeq
                            Else
                                BEx = XPosdiff(BE) - 1
                            End If
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(MCWinSize / 2, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                                If BWarn = 0 Then Call CheckEndsVB(MCWinSize / 2, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                            End If
                            If (MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1) And (MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1 Or (EWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1 Or (BWarn = 1) Then
                                XOverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        If GoOn = 0 And FindAllFlag = 1 Then 'erase it if it contained missingdata
                            CurrentXover(ActiveSeq) = CurrentXover(ActiveSeq) - 1
                        ElseIf FindAllFlag = 0 Then
                            OActive = ActiveSeq
                            OMajP = ActiveMajorP
                            OMinP = ActiveMinorP
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                            Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, MCWinSize / 2, LenXOverSeq)
                            X = X
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(3) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        
                        If FindAllFlag = 1 Then
                            GoOn = 1
                            If X = X Then
                                If XB < XE Then
                                    For zz = XB To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                Else
                                    For zz = 1 To XE
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                    For zz = XB To Len(StrainSeq(0))
                                        If MissingData(zz, Seq1) = 1 Or MissingData(zz, Seq2) = 1 Or MissingData(zz, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next zz
                                End If
                            End If
                            If GoOn = 1 Then
                                
                                Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 3, ProbabilityXOver, SIP)
                                XOverList(ActiveSeq, SIP) = XOverList(ActiveSeq, SIP - 1)
                                XOverList(ActiveSeq, SIP).SBPFlag = 0
                                
                                Call CentreBP(XB, XE, XPosdiff(), XDiffpos(), BWarn, EWarn, MCWinSize / 2, LenXOverSeq)
                                XOverList(ActiveSeq, SIP).Beginning = XB
                                XOverList(ActiveSeq, SIP).Ending = XE
                                XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                XOverList(ActiveSeq, SIP).PermPVal = PPVal
                                XOverList(ActiveSeq, SIP).BeginP = XBP
                                XOverList(ActiveSeq, SIP).EndP = XEP
                                
                                'Store the window size used to detect this event
                                If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                                    If XPosdiff(EN) = LenXOverSeq Then
                                        ENx = 1
                                    Else
                                        ENx = XPosdiff(EN) + 1
                                    End If
                                    If XPosdiff(BE) = 1 Or XPosdiff(BE) = 0 Then
                                        BEx = LenXOverSeq
                                    Else
                                        BEx = XPosdiff(BE) - 1
                                    End If
                                    
                                    If SEventNumber > 0 Then
                                        If EWarn = 0 Then Call CheckEndsVB(MCWinSize / 2, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosdiff(), XDiffpos())
                                        If BWarn = 0 Then Call CheckEndsVB(MCWinSize / 2, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosdiff(), XDiffpos())
                                    End If
                                    If (MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1) And (MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 3
                                    ElseIf MDMap(ENx) = 1 Or MDMap(XPosdiff(EN)) = 1 Or (EWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 2
                                    ElseIf MDMap(BEx) = 1 Or MDMap(XPosdiff(BE)) = 1 Or (BWarn = 1) Then
                                        XOverList(ActiveSeq, SIP).SBPFlag = 1
                                    End If
                                    
                                    If LoHiFlag = 0 Then
                                        LoHiFlag = 1
                                    Else
                                        LoHiFlag = 0
                                    End If
                                    If MCMaxX = 0 Then
                                        MCMaxX = 1
                                    Else
                                        MCMaxX = 0
                                    End If
                                    If FindAllFlag = 0 Then
                                        OActive = ActiveSeq
                                        OMajP = ActiveMajorP
                                        OMinP = ActiveMinorP
                                            
                                        Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                                        Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, MCWinSize / 2, LenXOverSeq)
                                    End If
                                End If
                            End If
                            
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(3) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(3) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                    
                        
                        
                        
                        ActiveSeq = OActive
                        ActiveMajorP = OMajP
                        ActiveMinorP = OMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            DoneThis = 1
                            If MCFlag = 0 Then
                                CF = MCCorrection
                            Else
                                CF = 1
                            End If
                            CF = CF * Int((LenXOverSeq / HWindowWidth) + 0.49) * 3
                            mPrbL = -Log10(mPrb * CF)
                            
                            ZP = -Log10(LowestProb / MCCorrection)
                            
                            If mPrbL < ZP Then mPrbL = ZP
                            
                            Call DoAxes(Len(StrainSeq(0)), -1, mPrbL, 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = -Log10(LowestProb)
                            
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                            For Y = 0 To 2
                                If Y = 0 Then
                                    Form1.Picture7.ForeColor = Yellow
                                ElseIf Y = 1 Then
                                    Form1.Picture7.ForeColor = Green
                                ElseIf Y = 2 Then
                                    Form1.Picture7.ForeColor = Purple
                                End If
                                Pict = Form1.Picture7.hdc
                                If -Log10(ChiPVal(ChiVals(1, Y)) * CF) > 0 Then
                                    Dummy = MoveToEx(Pict, (30 + XDiffpos(1) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(ChiVals(1, Y)) * CF) / (mPrbL)) * (PicHeight - 35), PntAPI)
                                Else
                                    Dummy = MoveToEx(Pict, (30 + XDiffpos(1) * XFactor), -15 + PicHeight, PntAPI)
                                End If
                                For X = 2 To LenXOverSeq - 1
                                    If -Log10(ChiPVal(ChiVals(X, Y)) * CF) > 0 Then
                                        Dummy = LineTo(Pict, 30 + XDiffpos(X) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(ChiVals(X, Y)) * CF) / mPrbL) * (PicHeight - 35))
                                    Else
                                        Dummy = LineTo(Pict, 30 + XDiffpos(X) * XFactor, -15 + PicHeight)
                                    End If
                                Next '
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    
                        
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then Exit Sub
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then Exit Sub
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then Exit Sub
            
            
            RO = pMaxX
            LO = pMaxX
            
            'destroy the maxx peak
            Dummy = DestroyPeak(MaxY, Len(StrainSeq(0)), RO, LO, LenXOverSeq, LOT(0), SmoothChi(0, 0), ChiVals(0, 0))
            
            If MaxZ = -1 Or MaxY = -1 Then Exit Sub
            ChiVals(MaxZ, MaxY) = 0
            If Dummy = 0 Then Exit Sub
            
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop

End Sub


Public Sub MCXoverJ()
    
    Dim X As Long, Y As Long, RetVal As Long
    Dim DA As Long, Ma As Long, Mi As Long, Z As Long

    ReDim SubSetF(NextNo)
    ReDim SubSetR(NextNo + 1)
    
    If Seq1 = Seq2 Then Seq1 = Seq3
    
    LSeq = Len(StrainSeq(0))
    IncludeSeq = 0
    ReDim TempSeq(NextNo) As String
    ReDim RevSeq(NextNo)
    'Set up copies of sequences that can be edited and rearranged etc
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    RevSeq(0) = Form5.Combo1.ListIndex - 1
    NumberOfSeqs = 1

    For X = 0 To NextNo

        If Selected(X) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(X)
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    TS = TempSeq(1)
    TempSeq(1) = TempSeq(2)
    TempSeq(2) = TS
    NumberOfSeqs = NumberOfSeqs - 1
    LSeq = Len(StrainSeq(0))

    If MCStripGapsFlag = 1 Then

        For X = 1 To LSeq

            For Z = 0 To NumberOfSeqs

                If Mid$(TempSeq(Z), X, 1) = "-" Then

                    For A = 0 To NumberOfSeqs
                        Mid$(TempSeq(A), X, 1) = "-"
                    Next 'A

                    Exit For
                End If

            Next 'Z

        Next 'X

    End If

    'Find sites used by MaxChi

    Call FindSubSeqMCIII

    
    'Remember that this method requires a set window size
    '(unlike the maxchi triplet scan).
    
    HWindowWidth = CLng(MCWinSize / 2)
    
    'Call GetCriticalDiff
    
    Dim PntAPI As POINTAPI
    'Prepare arrays
    'I MUST MOD THESE FOR JUST 1 SEQ PAIR
    ReDim Scores(Len(StrainSeq(0))) ' 0=s1,s2Matches etc
    ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim ChiVals(Len(StrainSeq(0)))
    ReDim ChiPVals(Len(StrainSeq(0)))
    ReDim MCPrintPos(LenXOverSeq)
    ReDim MCPrintData(NumberOfSeqs, LenXOverSeq)
    
    Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
    Dim MaxY As Integer, Failcount As Integer
    Dim TMChi As Double, hMChi As Double
    Dim HiLeft As Double, HiRight As Double
    Dim pMaxX As Long
    Dim MChi As Double, mmChi As Double
    mmChi = 0
    Seq1 = RevSeq(0)
    For X = 1 To NumberOfSeqs
        Seq2 = RevSeq(X)
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc2(1, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffpos(0), SeqNum(0, 0), WinScores(0))
        'This could be speeded up with better nesting
        MChi = CalcChiVals2(1, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0), ChiVals(0))
        If mmChi < MChi Then mmChi = MChi
        For Y = 0 To LenXOverSeq
            MCPrintData(X - 1, Y) = ChiPVal(ChiVals(Y))
            'If Y > 10 Then
            '    If MCPrintData(X - 1, Y) = MCPrintData(X - 1, Y - 10) And MCPrintData(X - 1, Y) = MCPrintData(X - 1, Y - 5) Then
            '        X = X
            '    End If
            '
            'End If
        Next Y
    Next X
    MChi = mmChi
    MCMinChiP = ChiPVal(MChi)
    
    If MCMinChiP > 0 Then
        MCMinChiP = -Log10(MCMinChiP)
    ElseIf MCMinChiP = 0 Then
        MCMinChiP = -Log10(0.000000001)
    End If

    If MCFlag = 0 Then
        If MCMinChiP < -Log10(LowestProb / ((NumberOfSeqs) * (NumberOfSeqs - 1) / 2)) Then MCMinChiP = -Log10(LowestProb / ((NumberOfSeqs) * (NumberOfSeqs - 1) / 2))
    Else
        If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
    End If
    
    

    Pict = Form1.Picture7.hdc
    
    
        
    For X = 0 To LenXOverSeq
        MCPrintPos(X) = XDiffpos(X)
    Next X
    
    Call DoAxes(Len(StrainSeq(0)), -1, MCMinChiP, 0, 0, "-Log[P(Chi2)]")
    
    Pict = Form1.Picture7.hdc
    
    Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, MCXDiffPos(0))
    
    PosCount = 0
    Form1.Picture7.DrawWidth = 3
    
    
    
    MChi = MCMinChiP
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NumberOfSeqs - 1
        Form1.Picture7.ForeColor = FFillCol(RevSeq(Y + 1))
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, 1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
        
        For X = 2 To LenXOverSeq - 1
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, X)) / MCMinChiP) * (PicHeight - 35)))
            
        Next X
    Next Y
    
    

    PosCount = 0
    Form1.Picture7.DrawWidth = 1
    For Y = 0 To NumberOfSeqs - 1
        Form1.Picture7.ForeColor = SeqCol(RevSeq(Y + 1))
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, 1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
        
        For X = 2 To LenXOverSeq - 1
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, X)) / MCMinChiP) * (PicHeight - 35)))
            
        Next X
    Next Y
    
    'draw p-val cutoff
    Form1.Picture7.DrawStyle = 2

    If ExeCheckFlag = 1 Or MCFlag <> 0 Then
        MCMaxP = LowestProb
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    End If

    MCMaxP = LowestProb / ((NumberOfSeqs) * (NumberOfSeqs) / 2)
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.ProgressBar1.Value = 95

    'shade detected region

    Call Highlight
    
    
    
    
    

    Form1.ProgressBar1.Value = 100
    Form1.Picture7.Refresh
    Form1.Picture10.Refresh
    Counter = Counter + 1
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.SSPanel8.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5

End Sub
Public Sub MCXoverI()
    
    Dim X As Long, Y As Long, RetVal As Long
    Dim DA As Long, Ma As Long, Mi As Long, Z As Long

    ReDim SubSetF(NextNo)
    ReDim SubSetR(NextNo + 1)
    
    If Seq1 = Seq2 Then Seq1 = Seq3
    
    IncludeSeq = 0

    FindSubSeqMCII
    'Exit Sub
    'Remember that this method requires a set window size
    '(unlike the maxchi triplet scan).
    oMCWinSize = MCWinSize
    oMCWinfract = MCWinFract
    If OptFlag <> 4 Then
            BE = XOverList(RelX, RelY).Beginning
            EN = XOverList(RelX, RelY).Ending
            If BE < EN Then
                MCWinSize = (XPosdiff(EN) - XPosdiff(BE)) + 1
            Else
                MCWinSize = XPosdiff(EN) + (LenXOverSeq - XPosdiff(BE)) + 1
            End If
            
            MCWinSize = MCWinSize * 2
            MCWinFract = MCWinSize / LenXOverSeq
    End If
    HWindowWidth = CLng(MCWinSize / 2)
    'HWindowWidth = 51
    'First get critical difference and critical chivals
    Call GetCriticalDiff(0)
    If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
        MCWinSize = HWindowWidth * 2
    End If
    'Prepare arrays
    'I MUST MOD THESE FOR JUST 1 SEQ PAIR
    ReDim Scores(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
    ReDim WinScores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim ChiVals(Len(StrainSeq(0)))
    ReDim ChiPVals(Len(StrainSeq(0)))
    ReDim SmoothChi(Len(StrainSeq(0)))

    
    Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
    Dim MaxY As Integer, Failcount As Integer
    Dim TMChi As Double, hMChi As Double
    Dim HiLeft As Double, HiRight As Double
    Dim pMaxX As Long
    Dim MChi As Double
    Seq3 = Seq1
    Dim XDiffPos2() As Long
    ReDim XDiffPos2(Len(StrainSeq(0)))
    If MCStripGapsFlag = 1 Then
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc2(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffpos(0), SeqNum(0, 0), WinScores(0))
        'LenXOverSeq2 = LenXoverSeq
    Else
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc3(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffpos(0), SeqNum(0, 0), WinScores(0), XDiffPos2(0))
        LenXOverSeq = Dummy
        For Z = 1 To LenXOverSeq
            XDiffpos(Z) = XDiffPos2(Z)
        Next Z
    End If
    
    'Dummy = WinScoreCalc2(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffPos(0), SeqNum(0, 0), WinScores(0))
    'This could be speeded up with better nesting
    MChi = CalcChiVals2(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), WinScores(0), ChiVals(0))

    MCMinChiP = ChiPVal(MChi)
    MCMinChiP = MCMinChiP * (LenXOverSeq / (HWindowWidth))
    If MCMinChiP > 0 Then
        MCMinChiP = -Log10(MCMinChiP)
    ElseIf MCMinChiP = 0 Then
        MCMinChiP = -Log10(0.000000001)
    End If

    If MCFlag = 0 Then
        If MCMinChiP < -Log10(LowestProb / MCCorrect) Then MCMinChiP = -Log10(LowestProb / MCCorrect)
    Else
        If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
    End If
    
    Dim PntAPI As POINTAPI

    Pict = Form1.Picture7.hdc
    
    ReDim MCPrintPos(LenXOverSeq)
    ReDim MCPrintData(LenXOverSeq)
        
    For X = 0 To LenXOverSeq
        MCPrintPos(X) = XDiffpos(X)
    Next X
    
    Call DoAxes(Len(StrainSeq(0)), -1, MCMinChiP, 0, 0, "-Log[P(Chi2)]")
    
    Pict = Form1.Picture7.hdc
    If MCStripGapsFlag = 1 Then
        Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, MCXDiffPos(0))
    Else
        Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, XDiffPos2(0))
    End If
    PosCount = 0
    Form1.Picture7.DrawWidth = 3
    'Min = 10
    For Y = 1 To LenXOverSeq
        ChiVals(Y) = ChiPVal(ChiVals(Y)) * (LenXOverSeq / (HWindowWidth))
        If ChiVals(Y) > 1 Then ChiVals(Y) = 1
        'If ChiVals(Y) < Min Then Min = ChiVals(Y)
    Next Y
    MChi = MCMinChiP
    Pict = Form1.Picture7.hdc
    Form1.Picture7.ForeColor = RGB(180, 180, 180)
    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + (-Log10(ChiVals(1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
    MCPrintData(1) = ChiVals(1)
    For X = 2 To LenXOverSeq - 1
        Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + (-Log10(ChiVals(X)) / MCMinChiP) * (PicHeight - 35)))
        MCPrintData(X) = ChiVals(X)
    Next X
    
    

    PosCount = 0
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = 0
    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + (-Log10(ChiVals(1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
    For X = 2 To LenXOverSeq - 1
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + (-Log10(ChiVals(X)) / MCMinChiP) * (PicHeight - 35)))
    Next X
    
    'draw p-val cutoff
    Form1.Picture7.DrawStyle = 2

    If ExeCheckFlag = 1 Or MCFlag <> 0 Then
        MCMaxP = LowestProb
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    End If

    MCMaxP = LowestProb / MCCorrect
    
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.ProgressBar1.Value = 95

    'shade detected region

    Call Highlight
    'MCMaxP = LowestProb
    
    Dim TB As Long, TE As Long

    If XOverList(RelX, RelY).Beginning - 40 < 0 Then
        TB = XOverList(RelX, RelY).Beginning - 40 + Len(StrainSeq(0))
    Else
        TB = XOverList(RelX, RelY).Beginning - 40
    End If

    If XOverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XOverList(RelX, RelY).Ending + 40 - Len(StrainSeq(0))
    Else
        TE = XOverList(RelX, RelY).Ending + 40
    End If

    Dim MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    
    If TE > TB Then

        For X = 0 To LenXOverSeq
            
            If XDiffpos(X) >= TB And XDiffpos(X) < TE Then

                    If ChiVals(X) < MinPA2 And Abs(TE - XDiffpos(X)) < Abs(TB - XDiffpos(X)) Then
                        MinPA2 = ChiVals(X)
                        XP2 = XDiffpos(X)
                    ElseIf ChiVals(X) < MinPA And Abs(TE - XDiffpos(X)) > Abs(TB - XDiffpos(X)) Then
                        MinPA = ChiVals(X)
                        XP1 = XDiffpos(X)
                    End If

            End If

        Next 'X

    Else

        For X = 0 To LenXOverSeq

            If XDiffpos(X) >= TB Or XDiffpos(X) <= TE Then

                    If XDiffpos(X) < TE Then

                        If ChiVals(X) < MinPA2 And Abs(TE - XDiffpos(X)) < Abs(XDiffpos(X) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA2 = ChiVals(X)
                            XP2 = XDiffpos(X)
                        ElseIf ChiPVal(ChiVals(X)) < MinPA And Abs(TE - XDiffpos(X)) > Abs(XDiffpos(X) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA = ChiVals(X)
                            XP1 = XDiffpos(X)
                        End If

                    Else

                        If ChiVals(X) < MinPA2 And TE + (Len(StrainSeq(0)) - XDiffpos(X)) < Abs(XDiffpos(X) - TB) Then
                            MinPA2 = ChiVals(X)
                            XP2 = XDiffpos(X)
                        ElseIf ChiVals(X) < MinPA And TE + (Len(StrainSeq(0)) - XDiffpos(X)) > Abs(XDiffpos(X) - TB) Then
                            MinPA = ChiVals(X)
                            XP1 = XDiffpos(X)
                        End If

                    End If

            End If

        Next 'X

    End If

    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)

    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrect
        MinPA2 = MinPA2 * MCCorrect
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(3, MinPA)
        MinPA2 = StepDown2(3, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    pt1 = -Log10(MinPA)
    pt2 = -Log10(MinPA2)
    If X = X Or (XOverList(RelX, RelY).ProgramFlag <> 3 And XOverList(RelX, RelY).ProgramFlag <> 3 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 3) = 0 Or (Confirm(EN, 3) = 1 And (pt2 > ConfirmP(EN, 3) Or pt1 > ConfirmP(EN, 3)))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 3) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA2)
            End If
            DoEvents

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

    Else

        If XOverList(RelX, RelY).BeginP < XOverList(RelX, RelY).EndP Then

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(0) = XOverList(RelX, RelY).BeginP
                POrder(2) = XOverList(RelX, RelY).Beginning
            Else
                POrder(0) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(1) = XOverList(RelX, RelY).EndP
                POrder(3) = XOverList(RelX, RelY).Ending
            Else
                POrder(1) = 0
            End If

        Else

            If XOverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(1) = XOverList(RelX, RelY).BeginP
                POrder(3) = XOverList(RelX, RelY).Beginning
            Else
                POrder(1) = 0
            End If

            If XOverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(0) = XOverList(RelX, RelY).EndP
                POrder(2) = XOverList(RelX, RelY).Ending
            Else
                POrder(0) = 0
            End If

        End If

    End If

    For A = 0 To 1
        ProbX = POrder(A + 2)

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then Call PrintProbability

        End If

    Next 'A
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    
    

    Form1.ProgressBar1.Value = 100
    Form1.Picture7.Refresh
    Form1.Picture10.Refresh
    Counter = Counter + 1
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.SSPanel8.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True


End Sub


Public Sub PXover()



Dim PT As Long, PPWinLen As Long, PPStripGaps As Long, IncSelf As Byte, PPPerms As Long
Dim Length As Long
PT = GetTickCount
'Nextno = 5
PPWinLen = 80
PPStripGaps = 0
IncSelf = 0



    NumberOfSeqs = 1
    ReDim TempSeq(NextNo + 1) As String
    ReDim RevSeq(NextNo + 1)
    For X = 0 To NextNo

        If Selected(X) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(X)
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1
    
    


ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
Y = 0
If PPStripGaps = 0 Then
    For X = 1 To Len(StrainSeq(0))
        XPosdiff(X) = Y
        If Identical(X) = 0 Then
            Y = Y + 1
            XPosdiff(X) = Y
            XDiffpos(Y) = X
        End If
    Next X
Else
    For X = 1 To Len(StrainSeq(0))
        XPosdiff(X) = Y
        If Identical(X) = 0 Then
            GoOn = 1
            For Z = 0 To NextNo
                If SeqNum(X, Z) = 46 Then
                    GoOn = 0
                    Exit For
                End If
            Next Z
            If GoOn = 1 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
            End If
        End If
    Next X
End If
Dim WinLen


Dim PDstMat() As Long
ReDim PDstMat(NextNo, NextNo, 1)

LenXOverSeq = Y
WinLen = CInt(PPWinLen / 2)
If WinLen > LenXOverSeq / 2 Then WinLen = CInt(LenXOverSeq / 2)
'Exit Sub
Dim WinScore() As Double
ReDim WinScore(LenXOverSeq, NextNo)
'Do matrix for the first half of first window

For X = 0 To NextNo
    For Y = X + 1 To NextNo
            
            For Z = LenXOverSeq - WinLen + 1 To LenXOverSeq
               
                If SeqNum(XDiffpos(Z), X) <> SeqNum(XDiffpos(Z), Y) And SeqNum(XDiffpos(Z), X) <> 46 And SeqNum(XDiffpos(Z), Y) <> 46 Then
                    PDstMat(X, Y, 0) = PDstMat(X, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 0) = PDstMat(X, Y, 0)
    Next Y
Next X

'Do matrix for the second half of first window
For X = 0 To NextNo
    For Y = X + 1 To NextNo
            
            For Z = 1 To WinLen
                If SeqNum(XDiffpos(Z), X) <> SeqNum(XDiffpos(Z), Y) And SeqNum(XDiffpos(Z), X) <> 46 And SeqNum(XDiffpos(Z), Y) <> 46 Then
                    PDstMat(X, Y, 1) = PDstMat(X, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 1) = PDstMat(X, Y, 1)
    Next Y
Next X
Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

If X = 12345 Then
    NextNo = 8
    PDstMat(0, 1, 0) = 0
    PDstMat(0, 2, 0) = 78
    PDstMat(0, 3, 0) = 148
    PDstMat(0, 4, 0) = 147
    PDstMat(0, 5, 0) = 170
    PDstMat(0, 6, 0) = 178
    PDstMat(0, 7, 0) = 182
    PDstMat(0, 8, 0) = 163
    
    PDstMat(0, 1, 1) = 193
    PDstMat(0, 2, 1) = 85 '200
    PDstMat(0, 3, 1) = 143 '199
    PDstMat(0, 4, 1) = 153 '198
    PDstMat(0, 5, 1) = 192 '84
    PDstMat(0, 6, 1) = 193 '0
    PDstMat(0, 7, 1) = 203 '145
    PDstMat(0, 8, 1) = 187 '139
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 1 To NextNo
        
            SumX = SumX + PDstMat(0, Y, 0)
            SumY = SumY + PDstMat(0, Y, 1)
            SumXY = SumXY + (PDstMat(0, Y, 0) * PDstMat(0, Y, 1))
            SumX2 = SumX2 + PDstMat(0, Y, 0) * PDstMat(0, Y, 0)
            SumY2 = SumY2 + PDstMat(0, Y, 1) * PDstMat(0, Y, 1)
        
    Next Y
    'Nextno = 9
   
        WinScore(1, 0) = ((NextNo * SumXY) - (SumX * SumY)) / _
        (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
        X = X
        Exit Sub
End If
'calc correlation and put into winscore as the first window pos
For X = 0 To NextNo
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NextNo
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            If IncSelf = 1 Then
                NextNo = NextNo + 1
            End If
            If SumX2 > 0 And SumY2 > 0 Then
                WinScore(X, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                'Exit Sub
            Else
                WinScore(X, A) = 1
            End If
            If IncSelf = 1 Then
                NextNo = NextNo - 1
            End If
   
Next X



Dim Begin1 As Long, End2 As Long

For X = 2 To LenXOverSeq
    End2 = X + WinLen - 1
    Begin1 = X - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXOverSeq + Begin1
    If End2 > LenXOverSeq Then End2 = End2 - LenXOverSeq
    For Z = 0 To NextNo
        For Y = Z + 1 To NextNo
            If SeqNum(XDiffpos(Begin1), Y) <> 46 And SeqNum(XDiffpos(Begin1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffpos(Begin1), Y) <> SeqNum(XDiffpos(Begin1), Z))
            End If
            If SeqNum(XDiffpos(X - 1), Y) <> 46 And SeqNum(XDiffpos(X - 1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffpos(X - 1), Y) <> SeqNum(XDiffpos(X - 1), Z))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffpos(X - 1), Y) <> SeqNum(XDiffpos(X - 1), Z))
            End If
            
            If SeqNum(XDiffpos(End2), Y) <> 46 And SeqNum(XDiffpos(End2), Z) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffpos(End2), Y) <> SeqNum(XDiffpos(End2), Z))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
        For A = 0 To NextNo
           SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NextNo
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            If IncSelf = 1 Then
                NextNo = NextNo + 1
            End If
            If SumX2 > 0 And SumY2 > 0 Then
                WinScore(X, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                'Exit Sub
            Else
                WinScore(X, A) = 1
            End If
            If IncSelf = 1 Then
                NextNo = NextNo - 1
            End If
        Next A
    
Next X


           ' For X = 0 To MCPerms
           '     'Make Randomised version of scores
           '     For Z = 1 To LenR * 2
           '         Curnt = LO + Z - 1
           '         If Curnt > LenXoverSeq Then Curnt = Curnt - LenXoverSeq
           '         MCPScore(Z) = Scores(Curnt, MaxY)
            '    Next Z
          '      For Z = 1 To LenR * 2
          '          Randum = CLng(((LenR * 2 - 1) * Rnd) + 1)
          '          If Randum > LenXoverSeq Then Randum = Randum - LenXoverSeq
          '          Tempnt = MCPScore(Z)
          '          MCPScore(Z) = MCPScore(Randum)
          '          MCPScore(Randum) = Tempnt
          '      Next Z

If X = X Then
    Dim MaxRVal As Double, MinRVal As Double
    MinRVal = 1000
    MaxRVal = -1000
    For X = 0 To NextNo
        For Y = 1 To LenXOverSeq
            If WinScore(Y, X) > MaxRVal Then
                MaxRVal = WinScore(Y, X)
            ElseIf WinScore(Y, X) < MinRVal Then
                MinRVal = WinScore(Y, X)
            End If
        Next Y
    Next X
    Dim PntAPI As POINTAPI, Pict As Long
    DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRVal, 0, "Correlation"
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For X = 6 To LenXOverSeq
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + ((WinScore(X, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next X
    Next Y
    Form1.Picture7.DrawWidth = 1
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For X = 6 To LenXOverSeq
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + ((WinScore(X, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next X
    Next Y
End If
End Sub
Public Sub PXoverB()



Dim PPCorrect As Long, PLimit As Long, PPCO As Double, PPWinLen As Long, PPStripGaps As Long, IncSelf As Byte, PPPerms As Long, PPSeed As Long
Dim Length As Long

'Nextno = 5
PPWinLen = 170
PPStripGaps = 1
IncSelf = 0
PPSeed = 3
PPPerms = 1000
PPCO = 0.05


ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
Y = 0
If PPStripGaps = 0 Then
    For X = 1 To Len(StrainSeq(0))
        XPosdiff(X) = Y
        If Identical(X) = 0 Then
            Y = Y + 1
            XPosdiff(X) = Y
            XDiffpos(Y) = X
        End If
    Next X
Else
    For X = 1 To Len(StrainSeq(0))
        XPosdiff(X) = Y
        If Identical(X) = 0 Then
            GoOn = 1
            For Z = 0 To NextNo
                If SeqNum(X, Z) = 46 Then
                    GoOn = 0
                    Exit For
                End If
            Next Z
            If GoOn = 1 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
            End If
        End If
    Next X
End If
Dim WinLen


Dim PDstMat() As Long
ReDim PDstMat(NextNo, NextNo, 1)

LenXOverSeq = Y
WinLen = CInt(PPWinLen / 2)
If WinLen > LenXOverSeq / 2 Then WinLen = CInt(LenXOverSeq / 2)

PPCorrect = (NextNo + 1) * (LenXOverSeq) / PPWinLen
PLimit = PPPerms * (PPCO / PPCorrect) + 1
PLimit = PPPerms
Dim WinScore() As Double
ReDim WinScore(LenXOverSeq, NextNo)

'Make RndTemplate
Dim RndTemplate() As Long
ReDim RndTemplate(PPWinLen, PPPerms)
For Y = 1 To PPPerms
    For X = 1 To WinLen * 2
        RndTemplate(X, Y) = X
    Next X
Next Y
Dim Randum As Long, Tempnt As Long
Rnd (-PPSeed)
For Y = 1 To PPPerms
    For X = 1 To WinLen * 2
        Randum = CLng(((PPWinLen - 1) * Rnd) + 1)
        If Randum = 0 Then
            X = X
        End If
        Tempnt = RndTemplate(X, Y)
        RndTemplate(X, Y) = RndTemplate(Randum, Y)
        RndTemplate(Randum, Y) = Tempnt
    Next X
Next Y
Dim SwapSites() As Long, NumSwaps() As Long
ReDim SwapSites(PPPerms, WinLen, 1)
ReDim NumSwaps(PPPerms)
For Y = 1 To PPPerms
    NumSwaps(Y) = 0
    For X = 1 To WinLen
        If RndTemplate(X, Y) > WinLen Then
            NumSwaps(Y) = NumSwaps(Y) + 1
            SwapSites(Y, NumSwaps(Y), 0) = RndTemplate(X, Y) - WinLen
        End If
    Next X
    NumSwaps(Y) = 0
    For X = WinLen + 1 To WinLen * 2
        If RndTemplate(X, Y) < WinLen + 1 Then
            NumSwaps(Y) = NumSwaps(Y) + 1
            SwapSites(Y, NumSwaps(Y), 1) = RndTemplate(X, Y) - WinLen
        End If
    Next X
    X = X
Next Y
'Exit Sub
For X = 0 To NextNo
    For Y = X + 1 To NextNo
            For Z = (LenXOverSeq - WinLen + 1) To LenXOverSeq
                If SeqNum(XDiffpos(Z), X) <> SeqNum(XDiffpos(Z), Y) And SeqNum(XDiffpos(Z), X) <> 46 And SeqNum(XDiffpos(Z), Y) <> 46 Then
                    PDstMat(X, Y, 0) = PDstMat(X, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 0) = PDstMat(X, Y, 0)
    Next Y
Next X

'Do matrix for the second half of first window
For X = 0 To NextNo
    For Y = X + 1 To NextNo
            
            For Z = 1 To WinLen
                If SeqNum(XDiffpos(Z), X) <> SeqNum(XDiffpos(Z), Y) And SeqNum(XDiffpos(Z), X) <> 46 And SeqNum(XDiffpos(Z), Y) <> 46 Then
                    PDstMat(X, Y, 1) = PDstMat(X, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 1) = PDstMat(X, Y, 1)
    Next Y
Next X

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc correlation and put into winscore as the first window pos
For X = 0 To NextNo
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NextNo
                If X <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(X, Y, 0)
                    SumY = SumY + PDstMat(X, Y, 1)
                    SumXY = SumXY + PDstMat(X, Y, 0) * PDstMat(X, Y, 1)
                    SumX2 = SumX2 + PDstMat(X, Y, 0) * PDstMat(X, Y, 0)
                    SumY2 = SumY2 + PDstMat(X, Y, 1) * PDstMat(X, Y, 1)
                    
                End If
    Next Y
    If IncSelf = 1 Then
        NextNo = NextNo + 1
    End If
    If SumX2 > 0 And SumY2 > 0 Then
        WinScore(1, X) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
    Else
        WinScore(X, 1) = 1
    End If
    If IncSelf = 1 Then
        NextNo = NextNo - 1
    End If
Next X

'do perms for first two windows
Dim tPDstMat() As Long, S1 As Byte, S2 As Byte, Offset As Long, Pos As Long, PermScore As Double, OC() As Long
Offset = 1
ReDim OC(NextNo)
If X = 12345 Then
    For B = 1 To PPPerms
            
        ReDim tPDstMat(NextNo, NextNo, 1)
        
        For X = 0 To NextNo
            If OC(X) < PLimit Then
                For Y = X + 1 To NextNo
                
                    tPDstMat(X, Y, 1) = PDstMat(X, Y, 1)
                    tPDstMat(X, Y, 0) = PDstMat(X, Y, 0)
                    For Z = 1 To NumSwaps(B)
                        If SwapSites(B, Z, 0) = 0 Then Exit For
                        Pos = SwapSites(B, Z, 0) + Offset
                        If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                        'first win
                        S1 = SeqNum(XDiffpos(Pos), Y)
                        S2 = SeqNum(XDiffpos(Pos), X)
                        
                        If S1 <> S2 Then
                            If S1 <> 46 And S2 <> 46 Then
                                tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) - 1
                                tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) + 1
                                
                            End If
                        End If
                        'second win
                        Pos = SwapSites(B, Z, 1) + Offset
                        
                        If Pos < 1 Then Pos = Pos + LenXOverSeq
                        S1 = SeqNum(XDiffpos(Pos), Y)
                        S2 = SeqNum(XDiffpos(Pos), X)
                        
                        If S1 <> S2 Then
                            If S1 <> 46 And S2 <> 46 Then
                                tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) + 1
                                tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) - 1
                                
                            End If
                        End If
                    Next Z
               
                    tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
                    tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
                 
                Next Y
            End If
        Next X
        For X = 0 To NextNo
            If OC(X) < PLimit Then
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                    For Y = 0 To NextNo
                        If X <> Y Or IncSelf = 1 Then
                            
                            SumX = SumX + tPDstMat(X, Y, 0)
                            SumY = SumY + tPDstMat(X, Y, 1)
                            SumXY = SumXY + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 1)
                            SumX2 = SumX2 + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 0)
                            SumY2 = SumY2 + tPDstMat(X, Y, 1) * tPDstMat(X, Y, 1)
                            
                        End If
                    Next Y
                    If IncSelf = 1 Then
                        NextNo = NextNo + 1
                    End If
                    If SumX2 > 0 And SumY2 > 0 Then
                        PermScore = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                        'Exit Sub
                    Else
                        WinScore(X, A) = 1
                    End If
                    If IncSelf = 1 Then
                        NextNo = NextNo - 1
                    End If
                    If PermScore < WinScore(1, X) Then OC(X) = OC(X) + 1
                End If
        Next X
    Next B
End If
Dim OutString() As String, tempstring As String
ReDim OutString(NextNo)
Dim Begin1 As Long, End2 As Long
Open "test.csv" For Output As #1
For X = 2 To LenXOverSeq
    
    Offset = X
    End2 = X + WinLen - 1
    Begin1 = X - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXOverSeq + Begin1
    If End2 > LenXOverSeq Then End2 = End2 - LenXOverSeq
    For Z = 0 To NextNo
        
        For Y = Z + 1 To NextNo
            If SeqNum(XDiffpos(Begin1), Y) <> 46 And SeqNum(XDiffpos(Begin1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffpos(Begin1), Y) <> SeqNum(XDiffpos(Begin1), Z))
            End If
            If SeqNum(XDiffpos(X - 1), Y) <> 46 And SeqNum(XDiffpos(X - 1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffpos(X - 1), Y) <> SeqNum(XDiffpos(X - 1), Z))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffpos(X - 1), Y) <> SeqNum(XDiffpos(X - 1), Z))
            End If
            
            If SeqNum(XDiffpos(End2), Y) <> 46 And SeqNum(XDiffpos(End2), Z) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffpos(End2), Y) <> SeqNum(XDiffpos(End2), Z))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NextNo
        OutString(A) = ""
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NextNo
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            If IncSelf = 1 Then
                NextNo = NextNo + 1
            End If
            If SumX2 > 0 And SumY2 > 0 Then
                WinScore(X, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                'Exit Sub
            Else
                WinScore(X, A) = 1
            End If
            If IncSelf = 1 Then
                NextNo = NextNo - 1
            End If
            OutString(A) = OutString(A) + Str(WinScore(X, A))
    Next A
    ReDim OC(NextNo)
    If ((X - 1) / 5) = Int((X - 1) / 5) Then
        For B = 1 To PPPerms
            
            ReDim tPDstMat(NextNo, NextNo, 1)
            
            
            For A = 0 To NextNo
                If OC(A) < PLimit Then
                    For Y = A + 1 To NextNo
                        tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                        tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                        For Z = 1 To NumSwaps(B)
                            If SwapSites(B, Z, 0) = 0 Then Exit For
                            Pos = SwapSites(B, Z, 0) + Offset
                            
                            If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                            'first win
                            S1 = SeqNum(XDiffpos(Pos), Y)
                            S2 = SeqNum(XDiffpos(Pos), A)
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) - 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) + 1
                                    
                                End If
                            End If
                            'second win
                            Pos = SwapSites(B, Z, 1) + Offset
                            
                            
                            
                            If Pos < 1 Then Pos = Pos + LenXOverSeq
                            S1 = SeqNum(XDiffpos(Pos), Y)
                            S2 = SeqNum(XDiffpos(Pos), A)
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) + 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) - 1
                                    
                                End If
                            End If
                        Next Z
                        tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                        tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                    Next Y
                End If
            Next A
            For A = 0 To NextNo
                If OC(A) < PLimit Then
                    SumA = 0
                    SumY = 0
                    SumAY = 0
                    SumA2 = 0
                    SumY2 = 0
                            For Y = 0 To NextNo
                                If A <> Y Or IncSelf = 1 Then
                                    
                                    SumA = SumA + tPDstMat(A, Y, 0)
                                    SumY = SumY + tPDstMat(A, Y, 1)
                                    SumAY = SumAY + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 1)
                                    SumA2 = SumA2 + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 0)
                                    SumY2 = SumY2 + tPDstMat(A, Y, 1) * tPDstMat(A, Y, 1)
                                    
                                End If
                            Next Y
                            If IncSelf = 1 Then
                                NextNo = NextNo + 1
                            End If
                            If SumA2 > 0 And SumY2 > 0 Then
                                PermScore = ((NextNo * SumAY) - (SumA * SumY)) / (Sqr(NextNo * SumA2 - SumA * SumA) * Sqr(NextNo * SumY2 - SumY * SumY))
                            Else
                                WinScore(A, A) = 1
                            End If
                            If IncSelf = 1 Then
                                NextNo = NextNo - 1
                            End If
                            If PermScore < WinScore(X, A) Then OC(A) = OC(A) + 1
                End If
            Next A
        Next B
        
        For A = 0 To NextNo
            OutString(A) = "," + OutString(A) + "," + Str((OC(A) / PPPerms))
        Next A
        tempstring = Str(XDiffpos(X)) & ","
        For A = 0 To NextNo
            tempstring = tempstring + OutString(A)
        Next A
        Form1.SSPanel1.Caption = Str(X) & " of " & Str(LenXOverSeq) & " windows examined"
        Form1.ProgressBar1.Value = X / LenXOverSeq * 100
        Print #1, tempstring
    End If
Next X

Close #1
           

If X = X Then
    Dim MaxRVal As Double, MinRVal As Double
    MinRVal = 1000
    MaxRVal = -1000
    For X = 0 To NextNo
        For Y = 1 To LenXOverSeq
            If WinScore(Y, X) > MaxRVal Then
                MaxRVal = WinScore(Y, X)
            ElseIf WinScore(Y, X) < MinRVal Then
                MinRVal = WinScore(Y, X)
            End If
        Next Y
    Next X
    Dim PntAPI As POINTAPI, Pict As Long
    DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRVal, 0, "Correlation"
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For X = 6 To LenXOverSeq
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + ((WinScore(X, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next X
    Next Y
    Form1.Picture7.DrawWidth = 1
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For X = 6 To LenXOverSeq
            Dummy = LineTo(Pict, 30 + (XDiffpos(X)) * XFactor, PicHeight - (15 + ((WinScore(X, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next X
    Next Y
End If
End Sub
Public Sub PXoverF()

Dim PCategory() As Double, SumA As Long, SumA2 As Long, SumAY As Long, PPPermsX As Long, PScore() As Double, NS As Long, PT As Long, CutOff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = GetTickCount

Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"

'Get variable sites
Call FindSubSeqPP
ReDim LRank(NumberOfSeqs), RRank(NumberOfSeqs)
If IncSelf = 0 Then
    NS = NumberOfSeqs
Else
    NS = NumberOfSeqs + 1
End If
PPCO = 0.05
If MCFlag = 0 Then
    CutOff = (LowestProb / NumberOfSeqs) * PPPerms
Else
    CutOff = (LowestProb) * PPPerms
End If

If CutOff = 0 Then CutOff = 1


Dim WinLen As Long, PDstMat() As Long

ReDim PDstMat(NumberOfSeqs, NumberOfSeqs, 1)

WinLen = CInt(PPWinLen / 2)
If WinLen > LenXOverSeq / 2 Then WinLen = CInt(LenXOverSeq / 2)

If MCFlag = 0 Then
    PPCorrect = (NumberOfSeqs + 1) * (LenXOverSeq / PPWinLen)
Else
    PPCorrect = LenXOverSeq / PPWinLen / 2
End If

PLimit = PPPerms * (PPCO / PPCorrect)

If PLimit = 0 Then
    PLimit = 5
    PPPermsX = (1 / (PPCO / PPCorrect)) * 5
Else
    PPPermsX = PPPerms
End If

ReDim PPWinScore(LenXOverSeq, NumberOfSeqs)
ReDim PScore(LenXOverSeq, NumberOfSeqs)

'Make RndTemplate
If X = X Then
    Dim RndTemplate() As Long
    ReDim RndTemplate(PPWinLen, PPPermsX)
    For Y = 1 To PPPermsX
        For X = 1 To WinLen * 2
            RndTemplate(X, Y) = X
        Next X
    Next Y
End If
Dim Randum As Long, Tempnt As Long
Rnd (-PPSeed)
If X = X Then
    For Y = 1 To PPPermsX
        For X = 1 To WinLen * 2
            Randum = CLng(((PPWinLen - 1) * Rnd) + 1)
            If Randum = 0 Or Randum > WinLen * 2 Then
                X = X
            End If
            Tempnt = RndTemplate(X, Y)
            RndTemplate(X, Y) = RndTemplate(Randum, Y)
            RndTemplate(Randum, Y) = Tempnt
            
            
        Next X
        X = X
    Next Y
End If

'Work out which and how many sites are swapped between halves of windows
Dim SwapSites() As Long, NumSwaps() As Long
ReDim SwapSites(PPPermsX, WinLen, 1)
ReDim NumSwaps(PPPermsX)
Dim DiffRecord() As Long
ReDim DiffRecord(NumberOfSeqs)
If X = X Then
    For Y = 1 To PPPermsX
        NumSwaps(Y) = 0
        For X = 1 To WinLen
            If RndTemplate(X, Y) > WinLen Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 0) = RndTemplate(X, Y) - WinLen
            End If
        Next X
        NumSwaps(Y) = 0
        For X = WinLen + 1 To WinLen * 2
            If RndTemplate(X, Y) <= WinLen Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 1) = RndTemplate(X, Y) - WinLen
            End If
        Next X
        X = X
    Next Y
End If
'Do matrix for the first half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            For Z = (LenXOverSeq - WinLen + 1) To LenXOverSeq
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 0) = PDstMat(X, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 0) = PDstMat(X, Y, 0)
    Next Y
Next X

'Do matrix for the second half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            
            For Z = 1 To WinLen
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 1) = PDstMat(X, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 1) = PDstMat(X, Y, 1)
    Next Y
Next X

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc correlation and put into ppwinscore as the first window pos
For X = 0 To NumberOfSeqs
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NumberOfSeqs
                If X <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(X, Y, 0)
                    SumY = SumY + PDstMat(X, Y, 1)
                    SumXY = SumXY + PDstMat(X, Y, 0) * PDstMat(X, Y, 1)
                    SumX2 = SumX2 + PDstMat(X, Y, 0) * PDstMat(X, Y, 0)
                    SumY2 = SumY2 + PDstMat(X, Y, 1) * PDstMat(X, Y, 1)
                End If
    Next Y
    
    If SumX2 > 0 And SumY2 > 0 Then
        PPWinScore(1, X) = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
        PPWinScore(1, X) = PPWinScore(1, X) + (10 ^ -14)
        X = X
    Else
        PPWinScore(1, X) = 1
    End If
    DiffRecord(X) = SumX + SumY
Next X
Dim MDiff As Long
MDiff = 0
For X = 0 To NumberOfSeqs
    If DiffRecord(X) > MDiff Then MDiff = DiffRecord(X)
    
Next X
ReDim PCategory(NumberOfSeqs, MDiff)
'For X = 0 To NumberOfSeqs
'    PCategory(X, DiffRecord(X)) = PPWinScore(1, X)
'Next X
'do perms for first two windows
Dim tPDstMat() As Long, S1 As Byte, S2 As Byte, Offset As Long, Pos As Long, PermScore As Double, OC() As Long
Offset = 1
ReDim OC(NumberOfSeqs)
SS = GetTickCount
If X = X Then
    For B = 1 To PPPermsX
            
        ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
        
        For X = 0 To NumberOfSeqs
            'If OC(X) < PLimit Then
                For Y = X + 1 To NumberOfSeqs
                    If OC(X) < PLimit Or OC(Y) < PLimit Then
                        tPDstMat(X, Y, 1) = PDstMat(X, Y, 1)
                        tPDstMat(X, Y, 0) = PDstMat(X, Y, 0)
                        tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
                        tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
                        For Z = 1 To NumSwaps(B)
                            If SwapSites(B, Z, 0) = 0 Then Exit For
                            Pos = SwapSites(B, Z, 0) + Offset - 1
                            If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                            'first win
                            S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                            S2 = SeqNum(XDiffpos(Pos), RevSeq(X))
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) - 1
                                    tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) + 1
                                    
                                End If
                            End If
                            'second win
                            Pos = SwapSites(B, Z, 1) + Offset - 1
                            
                            If Pos < 1 Then Pos = Pos + LenXOverSeq
                            S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                            S2 = SeqNum(XDiffpos(Pos), RevSeq(X))
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) + 1
                                    tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) - 1
                                    
                                End If
                            End If
                        Next Z
                        If tPDstMat(X, Y, 1) < 0 Or tPDstMat(X, Y, 0) < 0 Then
                            X = X
                        End If
                        tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
                        tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
                    End If
                Next Y
            'Else
            '    For Y = X + 1 To NumberOfSeqs
            '
            '        tPDstMat(X, Y, 1) = PDstMat(X, Y, 1)
            '        tPDstMat(X, Y, 0) = PDstMat(X, Y, 0)
            '        tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
            '        tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
            '    Next Y
            'End If
        Next X
        
        For X = 0 To NumberOfSeqs
            If OC(X) < PLimit Then
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                    For Y = 0 To NumberOfSeqs
                        If X <> Y Or IncSelf = 1 Then
                            SumX = SumX + tPDstMat(X, Y, 0)
                            SumY = SumY + tPDstMat(X, Y, 1)
                            SumXY = SumXY + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 1)
                            SumX2 = SumX2 + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 0)
                            SumY2 = SumY2 + tPDstMat(X, Y, 1) * tPDstMat(X, Y, 1)
                        End If
                    Next Y
                    If DiffRecord(X) <> SumX + SumY Then
                        X = X
                    End If
                    If SumX2 > 0 And SumY2 > 0 Then
                        PermScore = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                        'Exit Sub
                    Else
                        PermScore = 1
                    End If
                    
                    If PermScore <= PPWinScore(1, X) Then OC(X) = OC(X) + 1
                    
                
                End If
                If PCategory(X, SumX) = 0 Then
                    PCategory(X, SumX) = PermScore
                
                ElseIf PCategory(X, SumX) <> PermScore Then
                    X = X
                    
                    'PermScore = ((NS * SumXY) - (SumX * SumY)) / ((NS * SumX2 - SumX * SumX) ^ 0.5 * (NS * SumY2 - SumY * SumY) ^ 0.5)
                    PCategory(X, SumX) = PCategory(X, SumX) * -1
                    
                    
                ElseIf PCategory(X, SumX) = PermScore Then
                    X = X
                End If
        Next X
        
    Next B
    For X = 0 To NumberOfSeqs
        If OC(X) >= PLimit Then
                PScore(1, X) = 1
        Else
               PScore(1, X) = OC(X) / PPPermsX
        End If
    Next X
End If
EE = GetTickCount
TT = EE - SS
'78
Dim OutString() As String, tempstring As String
ReDim OutString(NumberOfSeqs)
Dim Begin1 As Long, End2 As Long
'Open "test.csv" For Output As #1
For X = 2 To LenXOverSeq
    
    Offset = X
    End2 = X + WinLen - 1
    Begin1 = X - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXOverSeq + Begin1
    If End2 > LenXOverSeq Then End2 = End2 - LenXOverSeq
    For Z = 0 To NumberOfSeqs
        
        For Y = Z + 1 To NumberOfSeqs
            If SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(Begin1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> SeqNum(XDiffpos(Begin1), RevSeq(Z)))
            End If
            If SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(X - 1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
            End If
            
            If SeqNum(XDiffpos(End2), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(End2), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffpos(End2), RevSeq(Y)) <> SeqNum(XDiffpos(End2), RevSeq(Z)))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NumberOfSeqs
        OutString(A) = ""
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NumberOfSeqs
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                'PPWinScore(X, A) = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                'cc = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                AA = ((NS * SumXY) - (SumX * SumY))
                BB = (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                
                If BB > 0 Then
                    PPWinScore(X, A) = AA / BB + (10 ^ -14)
                Else
                    PPWinScore(X, A) = 1
                End If
                X = X
                'Exit Sub
            Else
                PPWinScore(X, A) = 1
            End If
            DiffRecord(A) = SumX + SumY
            'OutString(A) = OutString(A) + Str(ppwinscore(X, A))
    Next A
    ReDim OC(NumberOfSeqs)
    If X = X Then '((X - 1) / 5) = Int((X - 1) / 5) Then
        For B = 1 To PPPermsX
            
            ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
            
            
            For A = 0 To NumberOfSeqs
                '
                    For Y = A + 1 To NumberOfSeqs
                        If OC(A) < PLimit Or OC(Y) < PLimit Then
                
                            tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                            tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                            tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                            For Z = 1 To NumSwaps(B)
                                If SwapSites(B, Z, 0) = 0 Then Exit For
                                Pos = SwapSites(B, Z, 0) + Offset - 1
                                
                                If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                                'first win
                                S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                                S2 = SeqNum(XDiffpos(Pos), RevSeq(A))
                                
                                If S1 <> S2 Then
                                    If S1 <> 46 And S2 <> 46 Then
                                        tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) - 1
                                        tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) + 1
                                        
                                    End If
                                End If
                                'second win
                                Pos = SwapSites(B, Z, 1) + Offset - 1
                                
                                
                                
                                If Pos < 1 Then Pos = Pos + LenXOverSeq
                                S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                                S2 = SeqNum(XDiffpos(Pos), RevSeq(A))
                                
                                If S1 <> S2 Then
                                    If S1 <> 46 And S2 <> 46 Then
                                        tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) + 1
                                        tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) - 1
                                        
                                    End If
                                End If
                            Next Z
                            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                            tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                        End If
                    Next Y
                'Else
                '    For Y = A + 1 To NumberOfSeqs
                '
               '
               '             tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                '            tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                '            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                 '           tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                  '  Next Y
                'End If
            Next A
            For A = 0 To NumberOfSeqs
                If OC(A) < PLimit Then
                    SumA = 0
                    SumY = 0
                    SumAY = 0
                    SumA2 = 0
                    SumY2 = 0
                            For Y = 0 To NumberOfSeqs
                                If A <> Y Or IncSelf = 1 Then
                                    
                                    SumA = SumA + tPDstMat(A, Y, 0)
                                    SumY = SumY + tPDstMat(A, Y, 1)
                                    SumAY = SumAY + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 1)
                                    SumA2 = SumA2 + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 0)
                                    SumY2 = SumY2 + tPDstMat(A, Y, 1) * tPDstMat(A, Y, 1)
                                    
                                End If
                            Next Y
                           
                            If SumA2 > 0 And SumY2 > 0 Then
                                PermScore = ((NS * SumAY) - (SumA * SumY)) / (Sqr(NS * SumA2 - SumA * SumA) * Sqr(NS * SumY2 - SumY * SumY))
                            Else
                                PermScore = 1
                            End If
                            
                            If PermScore < PPWinScore(X, A) Then OC(A) = OC(A) + 1
                    If DiffRecord(A) <> SumA + SumY Then
                        X = X
                    End If
                    
                End If
                
            Next A
        Next B
        For Z = 0 To NumberOfSeqs
            If OC(Z) >= PLimit Then
                PScore(X, Z) = 1
            Else
               PScore(X, Z) = OC(Z) / PPPermsX
            End If
        Next Z
        
        'TempString = Str(XDiffPos(X)) & ","
        
        Form1.SSPanel1.Caption = Str(X) & " of " & Str(LenXOverSeq) & " windows examined"
        Form1.ProgressBar1.Value = X / LenXOverSeq * 100
        'Print #1, TempString
    End If
Next X

'Close #1
           
'smooth plot over 10nt window
Dim SmoothScore() As Double, NextScore As Long
ReDim SmoothScore(LenXOverSeq, NumberOfSeqs)
For X = 0 To NumberOfSeqs
    'smooth first window
    For Y = -4 To 6
        If Y < 1 Then
            Pos = LenXOverSeq + Y
        Else
            Pos = Y
        End If
        SmoothScore(1, X) = SmoothScore(1, X) + PScore(Pos, X)
    Next Y
    'SmoothScore(Y, X) = SmoothScore(Y, X) / 11
    'do next 4 windows
    For Y = 2 To 5
        Start = LenXOverSeq - 6 + Y
        Pos = Y + 5
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PScore(Start, X) + PScore(Pos, X)
    Next Y
    For Y = 6 To LenXOverSeq - 5
        Start = Y - 5
        Pos = Y + 5
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PScore(Start, X) + PScore(Pos, X)
    Next Y
    For Y = LenXOverSeq - 4 To LenXOverSeq
        Start = Y - 5
        Pos = (Y + 5) - LenXOverSeq
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PScore(Start, X) + PScore(Pos, X)
    Next Y
    For Y = 1 To LenXOverSeq
        SmoothScore(Y, X) = SmoothScore(Y, X) / 11
    Next Y
Next X
Dim MaxRVal As Double, MinRVal As Double
'Do Plots
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlations
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, LP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For X = 0 To NumberOfSeqs
    zzz = 0
    MissNo = 0
    If ShowPlotFlag = 1 Then
        If X = 123456 Then
    
            If MinRValX = 1000 Then
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXOverSeq
                        If PPWinScore(Y, Z) > MaxRVal Then
                            MaxRVal = PPWinScore(Y, Z)
                        ElseIf PPWinScore(Y, Z) < MinRValX Then
                            MinRValX = PPWinScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 0, "Correlation"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            For Y = X To X
                
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 6 To LenXOverSeq Step 5
                    Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            Next Y
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                Form1.Picture7.ForeColor = QuaterColour
                If Y <> X Then
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq Step 5
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = X
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
            
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
            For Z = 6 To LenXOverSeq Step 5
                Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
            Next Z
        Else 'plot smoothed values
            If MinRValX = 1000 Then
            ReDim SmoothBak(LenXOverSeq, NumberOfSeqs)
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXOverSeq
                        SmoothBak(Y, Z) = SmoothScore(Y, Z)
                        If SmoothScore(Y, Z) > MaxRVal Then
                            MaxRVal = SmoothScore(Y, Z)
                        ElseIf SmoothScore(Y, Z) < MinRValX Then
                            MinRValX = SmoothScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 1, "Correlation"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            Y = X
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 2 To LenXOverSeq
                    Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                
                If Y <> X Then
                    Form1.Picture7.ForeColor = FFillCol(Y) 'ThreeQuaterColour 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = X
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
        
        End If
        Form1.Picture7.Refresh
    End If
    Do
        
        'find next lowest score
        MinRVal = 1
        For Y = 1 To LenXOverSeq
            If SmoothScore(Y, X) < MinRVal Then
                MinRVal = SmoothScore(Y, X)
                MinPos = Y
            End If
        Next Y
        MinRVal = PPWinScore(MinPos, X)
         
        'Set up the scoreing for this window  and incrimentally increase its size until
        'correlations stop dropping
        
        'Start with a window size of 10 on each side of the partition
        SubWinLen = Int(WinLen / 2)
        MissNum = 0
        Do While SubWinLen < WinLen Or MissNum < 10
            'Do matrix for the first half of window
            A = X
            If zzz = 6 And X = 3 Then
                X = X
            End If
            If SubWinLen = Int(WinLen / 2) Then
                For Y = 0 To NumberOfSeqs
                
                        PDstMat(A, Y, 0) = 0
                        For Z = (MinPos - SubWinLen) To MinPos - 1
                            If Z < 1 Then
                                Pos = LenXOverSeq + Z
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                        
                Next Y
            
            
                'Do matrix for the second half of window
                A = X
                For Y = 0 To NumberOfSeqs
                        PDstMat(A, Y, 1) = 0
                        For Z = MinPos To MinPos + SubWinLen - 1
                            If Z > LenXOverSeq Then
                                Pos = Z - LenXOverSeq
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
        
            Else
                Z = (MinPos - SubWinLen)
                If Z < 1 Then
                    Pos = LenXOverSeq + Z
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                    End If
                    
                    PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                Next Y
                Z = MinPos + SubWinLen - 1
                If Z > LenXOverSeq Then
                    Pos = Z - LenXOverSeq
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                    End If
                    PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
            End If
        
        'calc correlation and put into corr
            A = X
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            
            For Y = 0 To NumberOfSeqs
                If Y <> A Or IncSelf = 1 Then
                            SumX = SumX + PDstMat(A, Y, 0)
                            SumY = SumY + PDstMat(A, Y, 1)
                            SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                            SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                            SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
                        
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                
                AA = (((NS) * SumXY) - (SumX * SumY))
                BB = (Sqr((NS) * SumX2 - SumX * SumX) * Sqr((NS) * SumY2 - SumY * SumY))
                If BB = 0 Then
                    Corr = 1
                Else
                    Corr = AA / BB
                End If
            Else
                Corr = 1
            End If
            
            If (Corr <= MinRVal + 0.0000000001) Then
                If X = 3 Then
                    XDiffpos(MinPos) = XDiffpos(MinPos)
                End If
                MissNum = 0
                WinWinLen = SubWinLen
                MinRVal = Corr
                For Y = 0 To NumberOfSeqs
                    pLeftDist(Y) = PDstMat(A, Y, 0)
                    
                    pRightDist(Y) = PDstMat(A, Y, 1)
                Next Y
            ElseIf SubWinLen >= WinLen Then
                MissNum = MissNum + 1
                
            End If
            
            SubWinLen = SubWinLen + 1
            
        Loop
        'Check with permutations to see whether the minrval is significant or not
            WinStartPos = MinPos - WinWinLen
            
            NumHits = 0
            zzz = zzz + 1
            For Y = 1 To PPPermsX
                
                For Z = 0 To NumberOfSeqs
                    If Y > 1 And (RightDist(Z) < 0 Or LeftDist(Z) < 0 Or RightDist(Z) > WinWinLen Or LeftDist(Z) > WinWinLen) Then
                        X = X
                        Exit Sub
                        
                    End If
                    RightDist(Z) = pRightDist(Z)
                    LeftDist(Z) = pLeftDist(Z)
                    
                Next Z
                
                ReDim RandWin(WinWinLen * 2)
                For Z = 1 To WinWinLen * 2
                    RandWin(Z) = Z
                Next Z
                For Z = 0 To WinWinLen * 2 - 1
                    Randum = CLng(((WinWinLen * 2 - 1) * Rnd))
                    If Randum = WinWinLen * 2 Then
                        X = X
                    ElseIf Randum = 0 Then
                        X = X
                    End If
                    tmp = RandWin(Z)
                    RandWin(Z) = RandWin(Randum)
                    RandWin(Randum) = tmp
                   
                Next Z
                For Z = 0 To WinWinLen - 1
                    Randum = RandWin(Z)
                    If Randum > WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXOverSeq
                        ElseIf P2 > LenXOverSeq Then
                            P2 = P2 - LenXOverSeq
                        End If
                        
                        S1 = SeqNum(XDiffpos(P2), RevSeq(A))
                        For B = 0 To NumberOfSeqs
                            S2 = SeqNum(XDiffpos(P2), RevSeq(B))
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    RightDist(B) = RightDist(B) - 1
                                    
                                    LeftDist(B) = LeftDist(B) + 1
                                Else
                                    X = X
                                End If
                                
                            End If
                        Next B
                    End If
                Next Z
                
                For Z = WinWinLen To WinWinLen * 2 - 1
                    Randum = RandWin(Z)
                    
                    If Randum <= WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXOverSeq
                        ElseIf P2 > LenXOverSeq Then
                            P2 = P2 - LenXOverSeq
                        End If
                        
                        S1 = SeqNum(XDiffpos(P2), RevSeq(A))
                        For B = 0 To NumberOfSeqs
                            S2 = SeqNum(XDiffpos(P2), RevSeq(B))
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    RightDist(B) = RightDist(B) + 1
                                    LeftDist(B) = LeftDist(B) - 1
                                    
                                End If
                                
                            End If
                        Next B
                    End If
                    LeftDist(0) = LeftDist(0)
                    If LeftDist(0) = -1 Then
                        X = X
                    End If
                Next Z
                
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                For B = 0 To NumberOfSeqs
                       If B <> X Or IncSelf = 1 Then
                                SumX = SumX + LeftDist(B)
                                SumY = SumY + RightDist(B)
                                SumXY = SumXY + LeftDist(B) * RightDist(B)
                                
                                SumX2 = SumX2 + LeftDist(B) * LeftDist(B)
                                SumY2 = SumY2 + RightDist(B) * RightDist(B)
                      End If
                Next B
                
                If SumX2 > 0 And SumY2 > 0 Then
                    Corr = (((NS + 1) * SumXY) - (SumX * SumY)) / (Sqr((NS + 1) * SumX2 - SumX * SumX) * Sqr((NS + 1) * SumY2 - SumY * SumY))
                Else
                    Corr = 1
                End If
               
                If Corr <= MinRVal Then
                    NumHits = NumHits + 1
                    If NumHits > CutOff Then
                        ProbVal = 1
                        Exit For
                    End If
                End If
                
            Next Y
            
            ProbVal = NumHits / PPPermsX
            If MCFlag = 0 Then
                ProbVal = ProbVal * NumberOfSeqs
           
            End If
            
            If MCFlag = 0 Then
                
                ProbVal = ProbVal * NumberOfSeqs
            ElseIf MCFlag = 2 Then
            
                Dim ProbabilityXOver As Double
                If ProbVal = 0 Then
                
                    ProbabilityXOver = (1 / PPPermsX) - (10 ^ (-10))
                Else
                    ProbabilityXOver = ProbVal
                End If
                
                If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                    PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                    PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                End If
            
            End If
             
            If ProbVal > LowestProb Then
            'Exit Sub
                MissNo = MissNo + 1
                If MissNo = 5 Then
                    Exit Do
                Else 'delete this peak
                    Start = MinPos
                    
                    Do
                        LStart = Start
                        Start = Start - 1
                        If Start < 1 Then Start = LenXOverSeq
                        If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                    Loop
                    LO = LStart
                    Start = MinPos
                    Do
                        LStart = Start
                        Start = Start + 1
                        If Start > LenXOverSeq Then Start = 1
                        If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                    Loop
                    If LO < Start Then
                        For Z = LO To Start
                            SmoothScore(Z, X) = 1
                        Next Z
                    Else
                        For Z = LO To LenXOverSeq
                            SmoothScore(Z, X) = 1
                        Next Z
                        For Z = 1 To Start
                            SmoothScore(Z, X) = 1
                        Next Z
                    End If
                End If
                
            Else
                MissNo = 0
                Call UpdateXOList(RevSeq(X), CurrentXover(), XOverList())
                
                'Keep track of signal numbers
                oRecombNo(100) = oRecombNo(100) + 1
                oRecombNo(6) = oRecombNo(6) + 1
                
                'Find which side second BP is on
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Daughter = RevSeq(X)
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).ProgramFlag = 6
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).PermPVal = ProbVal
                
                If ProbVal > 0 Then
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = ProbVal
                Else
                    If MCFlag = 0 Then
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = (1 / PPPermsX) * NumberOfSeqs - (10 ^ (-10))
                    Else
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = (1 / PPPermsX) - 1 ^ 10 - 10
                    End If
                End If
                
                
                LP = MinPos - SubWinLen - 1
                RP = MinPos + SubWinLen - 1
                If LP < 1 Then LP = LenXOverSeq + LP
                If RP > LenXOverSeq Then RP = RP - LenXOverSeq
                If PPWinScore(LP, A) <= PPWinScore(RP, A) Then 'ie left is most likely
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning = XDiffpos(LP)
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending = XDiffpos(MinPos)
                    OriFlag = 0
                Else
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning = XDiffpos(MinPos)
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending = XDiffpos(RP)
                    OriFlag = 1
                End If
                
                
                'Find best parents by looking for sequences with biggest
                'change in rank on either side of breakpoint
                Dim DiffDist() As Double, LODist As Double, HiDist As Double, Hi As Long
                ReDim DiffDist(NumberOfSeqs)
              '  TL = 0
              '  TR = 0
              '  For Z = 0 To numberofseqs
              '      TL = TL + LeftDist(Z)
              '      TR = TR + RightDist(Z)
              '  Next Z
              '  For Z = 0 To numberofseqs
              '      DiffDist(Z) = LeftDist(Z) / TL - RightDist(Z) / TR
              '      X = X
              '  Next Z
                
                For Z = 0 To NumberOfSeqs
                'Z = X
                    LRank(Z) = 0
                    RRank(Z) = 0
                    For B = 0 To NumberOfSeqs
                        If pLeftDist(B) <= pLeftDist(Z) Then LRank(Z) = LRank(Z) + 1
                        If pRightDist(B) <= pRightDist(Z) Then RRank(Z) = RRank(Z) + 1
                        X = X
                    Next B
                    X = X
                Next Z
                'Exit Sub
                
                
                For Z = 0 To NumberOfSeqs
                    DiffDist(Z) = LRank(Z) - RRank(Z)
                    'Exit Sub
                Next Z
                
                
                'delete region
                    
                    Start = XPosdiff(XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning)
                    'Start = MinPos
                        circ = 0
                        Do
                            LStart = Start
                            Start = Start - 1
                            If Start < 1 Then
                                Start = LenXOverSeq
                                circ = circ + 1
                                If circ = 2 Then Exit Do
                            End If
                            If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                        Loop
                        If circ = 2 Then Exit Do
                        LO = LStart
                        Start = XPosdiff(XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending)
                        Do
                            LStart = Start
                            Start = Start + 1
                            If Start > LenXOverSeq Then Start = 1
                            If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                        Loop
                        If LO < Start Then
                            For Z = LO To Start
                                SmoothScore(Z, X) = 1
                            Next Z
                        Else
                            For Z = LO To LenXOverSeq
                                SmoothScore(Z, X) = 1
                            Next Z
                            For Z = 1 To Start
                                SmoothScore(Z, X) = 1
                            Next Z
                        End If
                
                LODist = 100000
                HiDist = 100000
                LO = -1
                Hi = -1
                For Z = 0 To NumberOfSeqs
                    
                    If DiffDist(Z) < 0 And Z <> X And LODist > pLeftDist(Z) Then
                        LODist = pLeftDist(Z)
                        LO = Z
                    End If
                    If DiffDist(Z) > 0 And Z <> X And HiDist > pRightDist(Z) Then
                        HiDist = pRightDist(Z)
                        Hi = Z
                    End If
                    
                Next Z
                
                
                
                If LO = -1 Or Hi = -1 Then
                    'I need to look at movement around the trendline
                    
        
                    X = X
                Else
                    If OriFlag = 1 Then
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP = RevSeq(Hi)
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP = RevSeq(LO)
                    
                    Else
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP = RevSeq(LO)
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP = RevSeq(Hi)
                    End If
                    
                    
                        D = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Daughter
                        Mi = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP
                        Ma = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP
                        
                        
                        If D = Ma Or D = Mi Or Ma > NextNo Or Ma > NextNo Then
                            X = X
                            Exit Sub
                        End If
                        
                        FindDaughter D, Mi, Ma, 0, 0, 6, CurrentXover(RevSeq(X))
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(6) = 1
                            Call UpdatePlotB(D, Ma, Mi, CurrentXover(RevSeq(X)))
    
                        End If
                End If
            End If
            
            
        XDiffpos(MinPos) = XDiffpos(MinPos)
        ET = GetTickCount
        
        If ET - LT > 500 Then
            Form1.ProgressBar1.Value = X / NumberOfSeqs * 100
            If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 1
            Form1.Label5(1).Caption = DoTimeII(ET - PT)
            Form1.Label57(0).Caption = DoTimeII(ET - ST)
            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(6) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
            End If
            LT = ET
            Form1.SSPanel13.Caption = "Approximately " & DoTime((ET - PT) * (100 / Form1.ProgressBar1.Value) - (ET - PT)) & " remaining"
            Form1.SSPanel1.Caption = Str(X) & " of" & Str(NumberOfSeqs) & " sequences examined"
            DoEvents
            If AbortFlag = 1 Then
            
                Exit For
            End If
        End If
    Loop
    
Next X

Form1.ProgressBar1.Value = 0

If TotalPPRecombinants > 0 Then ProgF(6) = 1
End Sub

Public Sub PXoverC()

Dim NS As Long, PT As Long, CutOff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = GetTickCount

Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"

'Get variable sites
Call FindSubSeqPP
ReDim LRank(NumberOfSeqs), RRank(NumberOfSeqs)
If IncSelf = 0 Then
    NS = NumberOfSeqs
Else
    NS = NumberOfSeqs + 1
End If
PPCO = 0.05
If MCFlag = 0 Then
    CutOff = (LowestProb / NumberOfSeqs) * PPPerms
Else
    CutOff = (LowestProb) * PPPerms
End If

If CutOff = 0 Then CutOff = 1


Dim WinLen As Long, PDstMat() As Long

ReDim PDstMat(NumberOfSeqs, NumberOfSeqs, 1)

WinLen = CInt(PPWinLen / 2)
If WinLen > LenXOverSeq / 2 Then WinLen = CInt(LenXOverSeq / 2)

PPCorrect = (NumberOfSeqs + 1) * (LenXOverSeq) / PPWinLen
PLimit = PPPerms * (PPCO / PPCorrect) + 1
PLimit = PPPerms

ReDim PPWinScore(LenXOverSeq, NumberOfSeqs)

'Make RndTemplate
If X = 12345 Then
    Dim RndTemplate() As Long
    ReDim RndTemplate(PPWinLen, PPPerms)
    For Y = 1 To PPPerms
        For X = 1 To WinLen * 2
            RndTemplate(X, Y) = X
        Next X
    Next Y
End If
Dim Randum As Long, Tempnt As Long
Rnd (-PPSeed)
If X = 12345 Then
    For Y = 1 To PPPerms
        For X = 1 To WinLen * 2
            Randum = CLng(((PPWinLen - 1) * Rnd) + 1)
            
            Tempnt = RndTemplate(X, Y)
            RndTemplate(X, Y) = RndTemplate(Randum, Y)
            RndTemplate(Randum, Y) = Tempnt
        Next X
    Next Y
End If

'Work out which and how many sites are swapped between halves of windows
Dim SwapSites() As Long, NumSwaps() As Long
ReDim SwapSites(PPPerms, WinLen, 1)
ReDim NumSwaps(PPPerms)
If X = 12345 Then
    For Y = 1 To PPPerms
        NumSwaps(Y) = 0
        For X = 1 To WinLen
            If RndTemplate(X, Y) > WinLen Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 0) = RndTemplate(X, Y) - WinLen
            End If
        Next X
        NumSwaps(Y) = 0
        For X = WinLen + 1 To WinLen * 2
            If RndTemplate(X, Y) < WinLen + 1 Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 1) = RndTemplate(X, Y) - WinLen
            End If
        Next X
    Next Y
End If
'Do matrix for the first half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            For Z = (LenXOverSeq - WinLen + 1) To LenXOverSeq
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 0) = PDstMat(X, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 0) = PDstMat(X, Y, 0)
    Next Y
Next X

'Do matrix for the second half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            
            For Z = 1 To WinLen
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 1) = PDstMat(X, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 1) = PDstMat(X, Y, 1)
    Next Y
Next X

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc correlation and put into ppwinscore as the first window pos
For X = 0 To NumberOfSeqs
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NumberOfSeqs
                If X <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(X, Y, 0)
                    SumY = SumY + PDstMat(X, Y, 1)
                    SumXY = SumXY + PDstMat(X, Y, 0) * PDstMat(X, Y, 1)
                    SumX2 = SumX2 + PDstMat(X, Y, 0) * PDstMat(X, Y, 0)
                    SumY2 = SumY2 + PDstMat(X, Y, 1) * PDstMat(X, Y, 1)
                    
                End If
    Next Y
    
    If SumX2 > 0 And SumY2 > 0 Then
        PPWinScore(1, X) = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
    Else
        PPWinScore(X, 1) = 1
    End If
    
Next X

'do perms for first two windows
Dim tPDstMat() As Long, S1 As Byte, S2 As Byte, Offset As Long, Pos As Long, PermScore As Double, OC() As Long
Offset = 1
ReDim OC(NumberOfSeqs)
If X = 12345 Then
    For B = 1 To PPPerms
            
        ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
        
        For X = 0 To NumberOfSeqs
            If OC(X) < PLimit Then
                For Y = X + 1 To NumberOfSeqs
                
                    tPDstMat(X, Y, 1) = PDstMat(X, Y, 1)
                    tPDstMat(X, Y, 0) = PDstMat(X, Y, 0)
                    For Z = 1 To NumSwaps(B)
                        If SwapSites(B, Z, 0) = 0 Then Exit For
                        Pos = SwapSites(B, Z, 0) + Offset
                        If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                        'first win
                        S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                        S2 = SeqNum(XDiffpos(Pos), RevSeq(X))
                        
                        If S1 <> S2 Then
                            If S1 <> 46 And S2 <> 46 Then
                                tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) - 1
                                tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) + 1
                                
                            End If
                        End If
                        'second win
                        Pos = SwapSites(B, Z, 1) + Offset
                        
                        If Pos < 1 Then Pos = Pos + LenXOverSeq
                        S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                        S2 = SeqNum(XDiffpos(Pos), RevSeq(X))
                        
                        If S1 <> S2 Then
                            If S1 <> 46 And S2 <> 46 Then
                                tPDstMat(X, Y, 1) = tPDstMat(X, Y, 1) + 1
                                tPDstMat(X, Y, 0) = tPDstMat(X, Y, 0) - 1
                                
                            End If
                        End If
                    Next Z
               
                    tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
                    tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
                 
                Next Y
            End If
        Next X
        For X = 0 To NumberOfSeqs
            If OC(X) < PLimit Then
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                    For Y = 0 To NumberOfSeqs
                        If X <> Y Or IncSelf = 1 Then
                            
                            SumX = SumX + tPDstMat(X, Y, 0)
                            SumY = SumY + tPDstMat(X, Y, 1)
                            SumXY = SumXY + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 1)
                            SumX2 = SumX2 + tPDstMat(X, Y, 0) * tPDstMat(X, Y, 0)
                            SumY2 = SumY2 + tPDstMat(X, Y, 1) * tPDstMat(X, Y, 1)
                            
                        End If
                    Next Y
                    
                    If SumX2 > 0 And SumY2 > 0 Then
                        PermScore = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                        'Exit Sub
                    Else
                        PPWinScore(X, A) = 1
                    End If
                    
                    If PermScore < PPWinScore(1, X) Then OC(X) = OC(X) + 1
                End If
        Next X
    Next B
End If
Dim OutString() As String, tempstring As String
ReDim OutString(NumberOfSeqs)
Dim Begin1 As Long, End2 As Long
'Open "test.csv" For Output As #1
For X = 2 To LenXOverSeq
    
    Offset = X
    End2 = X + WinLen - 1
    Begin1 = X - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXOverSeq + Begin1
    If End2 > LenXOverSeq Then End2 = End2 - LenXOverSeq
    For Z = 0 To NumberOfSeqs
        
        For Y = Z + 1 To NumberOfSeqs
            If SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(Begin1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> SeqNum(XDiffpos(Begin1), RevSeq(Z)))
            End If
            If SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(X - 1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
            End If
            
            If SeqNum(XDiffpos(End2), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(End2), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffpos(End2), RevSeq(Y)) <> SeqNum(XDiffpos(End2), RevSeq(Z)))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NumberOfSeqs
        OutString(A) = ""
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NumberOfSeqs
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                'PPWinScore(X, A) = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                'cc = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                AA = ((NS * SumXY) - (SumX * SumY))
                BB = (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                
                If BB > 0 Then
                    PPWinScore(X, A) = AA / BB
                Else
                    PPWinScore(X, A) = 1
                End If
                X = X
                'Exit Sub
            Else
                PPWinScore(X, A) = 1
            End If
            
            'OutString(A) = OutString(A) + Str(ppwinscore(X, A))
    Next A
    ReDim OC(NumberOfSeqs)
    If X = 123456 Then '((X - 1) / 5) = Int((X - 1) / 5) Then
        For B = 1 To PPPerms
            
            ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
            
            
            For A = 0 To NumberOfSeqs
                If OC(A) < PLimit Then
                    For Y = A + 1 To NumberOfSeqs
                        tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                        tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                        For Z = 1 To NumSwaps(B)
                            If SwapSites(B, Z, 0) = 0 Then Exit For
                            Pos = SwapSites(B, Z, 0) + Offset
                            
                            If Pos > LenXOverSeq Then Pos = Pos - LenXOverSeq
                            'first win
                            S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                            S2 = SeqNum(XDiffpos(Pos), RevSeq(A))
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) - 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) + 1
                                    
                                End If
                            End If
                            'second win
                            Pos = SwapSites(B, Z, 1) + Offset
                            
                            
                            
                            If Pos < 1 Then Pos = Pos + LenXOverSeq
                            S1 = SeqNum(XDiffpos(Pos), RevSeq(Y))
                            S2 = SeqNum(XDiffpos(Pos), RevSeq(A))
                            
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) + 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) - 1
                                    
                                End If
                            End If
                        Next Z
                        tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                        tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                    Next Y
                End If
            Next A
            For A = 0 To NumberOfSeqs
                If OC(A) < PLimit Then
                    SumA = 0
                    SumY = 0
                    SumAY = 0
                    SumA2 = 0
                    SumY2 = 0
                            For Y = 0 To NumberOfSeqs
                                If A <> Y Or IncSelf = 1 Then
                                    
                                    SumA = SumA + tPDstMat(A, Y, 0)
                                    SumY = SumY + tPDstMat(A, Y, 1)
                                    SumAY = SumAY + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 1)
                                    SumA2 = SumA2 + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 0)
                                    SumY2 = SumY2 + tPDstMat(A, Y, 1) * tPDstMat(A, Y, 1)
                                    
                                End If
                            Next Y
                           
                            If SumA2 > 0 And SumY2 > 0 Then
                                PermScore = ((NS * SumAY) - (SumA * SumY)) / (Sqr(NS * SumA2 - SumA * SumA) * Sqr(NS * SumY2 - SumY * SumY))
                            Else
                                PPWinScore(A, A) = 1
                            End If
                            
                            If PermScore < PPWinScore(X, A) Then OC(A) = OC(A) + 1
                End If
            Next A
        Next B
        
        For A = 0 To NumberOfSeqs
            OutString(A) = "," + OutString(A) + "," + Str((OC(A) / PPPerms))
        Next A
        'TempString = Str(XDiffPos(X)) & ","
        For A = 0 To NumberOfSeqs
            tempstring = tempstring + OutString(A)
        Next A
        Form1.SSPanel1.Caption = Str(X) & " of " & Str(LenXOverSeq) & " windows examined"
        Form1.ProgressBar1.Value = X / LenXOverSeq * 100
        'Print #1, TempString
    End If
Next X

'Close #1
           
'smooth plot over 10nt window
Dim SmoothScore() As Double, NextScore As Long
ReDim SmoothScore(LenXOverSeq, NumberOfSeqs)
For X = 0 To NumberOfSeqs
    'smooth first window
    For Y = -4 To 6
        If Y < 1 Then
            Pos = LenXOverSeq + Y
        Else
            Pos = Y
        End If
        SmoothScore(1, X) = SmoothScore(1, X) + PPWinScore(Pos, X)
    Next Y
    'SmoothScore(Y, X) = SmoothScore(Y, X) / 11
    'do next 4 windows
    For Y = 2 To 5
        Start = LenXOverSeq - 6 + Y
        Pos = Y + 5
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PPWinScore(Start, X) + PPWinScore(Pos, X)
    Next Y
    For Y = 6 To LenXOverSeq - 5
        Start = Y - 5
        Pos = Y + 5
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PPWinScore(Start, X) + PPWinScore(Pos, X)
    Next Y
    For Y = LenXOverSeq - 4 To LenXOverSeq
        Start = Y - 5
        Pos = (Y + 5) - LenXOverSeq
        SmoothScore(Y, X) = SmoothScore(Y - 1, X) - PPWinScore(Start, X) + PPWinScore(Pos, X)
    Next Y
    For Y = 1 To LenXOverSeq
        SmoothScore(Y, X) = SmoothScore(Y, X) / 11
    Next Y
Next X
Dim MaxRVal As Double, MinRVal As Double
'Do Plots
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlations
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, LP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For X = 0 To NumberOfSeqs
    zzz = 0
    MissNo = 0
    If ShowPlotFlag = 1 Then
        If X = 123456 Then
    
            If MinRValX = 1000 Then
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXOverSeq
                        If PPWinScore(Y, Z) > MaxRVal Then
                            MaxRVal = PPWinScore(Y, Z)
                        ElseIf PPWinScore(Y, Z) < MinRValX Then
                            MinRValX = PPWinScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 0, "Correlation"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            For Y = X To X
                
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 6 To LenXOverSeq Step 5
                    Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            Next Y
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                Form1.Picture7.ForeColor = QuaterColour
                If Y <> X Then
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq Step 5
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = X
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
            
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
            For Z = 6 To LenXOverSeq Step 5
                Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
            Next Z
        Else 'plot smoothed values
            If MinRValX = 1000 Then
            ReDim SmoothBak(LenXOverSeq, NumberOfSeqs)
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXOverSeq
                        SmoothBak(Y, Z) = SmoothScore(Y, Z)
                        If SmoothScore(Y, Z) > MaxRVal Then
                            MaxRVal = SmoothScore(Y, Z)
                        ElseIf SmoothScore(Y, Z) < MinRValX Then
                            MinRValX = SmoothScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 1, "Correlation"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            Y = X
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 2 To LenXOverSeq
                    Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                
                If Y <> X Then
                    Form1.Picture7.ForeColor = FFillCol(Y) 'ThreeQuaterColour 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = X
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXOverSeq
                        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
        
        End If
        Form1.Picture7.Refresh
    End If
    Do
        
        'find next lowest score
        MinRVal = 1
        For Y = 1 To LenXOverSeq
            If SmoothScore(Y, X) < MinRVal Then
                MinRVal = SmoothScore(Y, X)
                MinPos = Y
            End If
        Next Y
        MinRVal = PPWinScore(MinPos, X)
         
        'Set up the scoreing for this window  and incrimentally increase its size until
        'correlations stop dropping
        
        'Start with a window size of 10 on each side of the partition
        SubWinLen = Int(WinLen / 2)
        MissNum = 0
        Do While SubWinLen < WinLen Or MissNum < 10
            'Do matrix for the first half of window
            A = X
            If zzz = 6 And X = 3 Then
                X = X
            End If
            If SubWinLen = Int(WinLen / 2) Then
                For Y = 0 To NumberOfSeqs
                
                        PDstMat(A, Y, 0) = 0
                        For Z = (MinPos - SubWinLen) To MinPos - 1
                            If Z < 1 Then
                                Pos = LenXOverSeq + Z
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                        
                Next Y
            
            
                'Do matrix for the second half of window
                A = X
                For Y = 0 To NumberOfSeqs
                        PDstMat(A, Y, 1) = 0
                        For Z = MinPos To MinPos + SubWinLen - 1
                            If Z > LenXOverSeq Then
                                Pos = Z - LenXOverSeq
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
        
            Else
                Z = (MinPos - SubWinLen)
                If Z < 1 Then
                    Pos = LenXOverSeq + Z
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                    End If
                    
                    PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                Next Y
                Z = MinPos + SubWinLen - 1
                If Z > LenXOverSeq Then
                    Pos = Z - LenXOverSeq
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffpos(Pos), RevSeq(A)) <> SeqNum(XDiffpos(Pos), RevSeq(Y)) And SeqNum(XDiffpos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffpos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                    End If
                    PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
            End If
        
        'calc correlation and put into corr
            A = X
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            
            For Y = 0 To NumberOfSeqs
                If Y <> A Or IncSelf = 1 Then
                            SumX = SumX + PDstMat(A, Y, 0)
                            SumY = SumY + PDstMat(A, Y, 1)
                            SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                            SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                            SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
                        
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                
                AA = (((NS) * SumXY) - (SumX * SumY))
                BB = (Sqr((NS) * SumX2 - SumX * SumX) * Sqr((NS) * SumY2 - SumY * SumY))
                If BB = 0 Then
                    Corr = 1
                Else
                    Corr = AA / BB
                End If
            Else
                Corr = 1
            End If
            
            If (Corr <= MinRVal + 0.0000000001) Then
                If X = 3 Then
                    XDiffpos(MinPos) = XDiffpos(MinPos)
                End If
                MissNum = 0
                WinWinLen = SubWinLen
                MinRVal = Corr
                For Y = 0 To NumberOfSeqs
                    pLeftDist(Y) = PDstMat(A, Y, 0)
                    
                    pRightDist(Y) = PDstMat(A, Y, 1)
                Next Y
            ElseIf SubWinLen >= WinLen Then
                MissNum = MissNum + 1
                
            End If
            
            SubWinLen = SubWinLen + 1
            
        Loop
        'Check with permutations to see whether the minrval is significant or not
            WinStartPos = MinPos - WinWinLen
            
            NumHits = 0
            zzz = zzz + 1
            For Y = 1 To PPPerms
                
                For Z = 0 To NumberOfSeqs
                    If Y > 1 And (RightDist(Z) < 0 Or LeftDist(Z) < 0 Or RightDist(Z) > WinWinLen Or LeftDist(Z) > WinWinLen) Then
                        X = X
                        Exit Sub
                        
                    End If
                    RightDist(Z) = pRightDist(Z)
                    LeftDist(Z) = pLeftDist(Z)
                    
                Next Z
                
                ReDim RandWin(WinWinLen * 2)
                For Z = 1 To WinWinLen * 2
                    RandWin(Z) = Z
                Next Z
                For Z = 0 To WinWinLen * 2 - 1
                    Randum = CLng(((WinWinLen * 2 - 1) * Rnd))
                    If Randum = WinWinLen * 2 Then
                        X = X
                    ElseIf Randum = 0 Then
                        X = X
                    End If
                    tmp = RandWin(Z)
                    RandWin(Z) = RandWin(Randum)
                    RandWin(Randum) = tmp
                   
                Next Z
                For Z = 0 To WinWinLen - 1
                    Randum = RandWin(Z)
                    If Randum > WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXOverSeq
                        ElseIf P2 > LenXOverSeq Then
                            P2 = P2 - LenXOverSeq
                        End If
                        
                        S1 = SeqNum(XDiffpos(P2), RevSeq(A))
                        For B = 0 To NumberOfSeqs
                            S2 = SeqNum(XDiffpos(P2), RevSeq(B))
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    RightDist(B) = RightDist(B) - 1
                                    
                                    LeftDist(B) = LeftDist(B) + 1
                                Else
                                    X = X
                                End If
                                
                            End If
                        Next B
                    End If
                Next Z
                
                For Z = WinWinLen To WinWinLen * 2 - 1
                    Randum = RandWin(Z)
                    
                    If Randum <= WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXOverSeq
                        ElseIf P2 > LenXOverSeq Then
                            P2 = P2 - LenXOverSeq
                        End If
                        
                        S1 = SeqNum(XDiffpos(P2), RevSeq(A))
                        For B = 0 To NumberOfSeqs
                            S2 = SeqNum(XDiffpos(P2), RevSeq(B))
                            If S1 <> S2 Then
                                If S1 <> 46 And S2 <> 46 Then
                                    RightDist(B) = RightDist(B) + 1
                                    LeftDist(B) = LeftDist(B) - 1
                                    
                                End If
                                
                            End If
                        Next B
                    End If
                    LeftDist(0) = LeftDist(0)
                    If LeftDist(0) = -1 Then
                        X = X
                    End If
                Next Z
                
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                For B = 0 To NumberOfSeqs
                       If B <> X Or IncSelf = 1 Then
                                SumX = SumX + LeftDist(B)
                                SumY = SumY + RightDist(B)
                                SumXY = SumXY + LeftDist(B) * RightDist(B)
                                
                                SumX2 = SumX2 + LeftDist(B) * LeftDist(B)
                                SumY2 = SumY2 + RightDist(B) * RightDist(B)
                      End If
                Next B
                
                If SumX2 > 0 And SumY2 > 0 Then
                    Corr = (((NS + 1) * SumXY) - (SumX * SumY)) / (Sqr((NS + 1) * SumX2 - SumX * SumX) * Sqr((NS + 1) * SumY2 - SumY * SumY))
                Else
                    Corr = 1
                End If
               
                If Corr <= MinRVal Then
                    NumHits = NumHits + 1
                    If NumHits > CutOff Then
                        ProbVal = 1
                        Exit For
                    End If
                End If
                
            Next Y
            
            ProbVal = NumHits / PPPerms
            If MCFlag = 0 Then
                ProbVal = ProbVal * NumberOfSeqs
           
            End If
             
            If ProbVal > LowestProb Then
            'Exit Sub
                MissNo = MissNo + 1
                If MissNo = 5 Then
                    Exit Do
                Else 'delete this peak
                    Start = MinPos
                    
                    Do
                        LStart = Start
                        Start = Start - 1
                        If Start < 1 Then Start = LenXOverSeq
                        If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                    Loop
                    LO = LStart
                    Start = MinPos
                    Do
                        LStart = Start
                        Start = Start + 1
                        If Start > LenXOverSeq Then Start = 1
                        If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                    Loop
                    If LO < Start Then
                        For Z = LO To Start
                            SmoothScore(Z, X) = 1
                        Next Z
                    Else
                        For Z = LO To LenXOverSeq
                            SmoothScore(Z, X) = 1
                        Next Z
                        For Z = 1 To Start
                            SmoothScore(Z, X) = 1
                        Next Z
                    End If
                End If
                
            Else
                MissNo = 0
                Call UpdateXOList(RevSeq(X), CurrentXover(), XOverList())
                
                'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(6) = oRecombNo(6) + 1
                'Find which side second BP is on
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Daughter = RevSeq(X)
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).ProgramFlag = 6
                XOverList(RevSeq(X), CurrentXover(RevSeq(X))).PermPVal = ProbVal
                If ProbVal > 0 Then
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = ProbVal
                Else
                    If MCFlag = 0 Then
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = (1 / PPPerms) * NumberOfSeqs - (10 ^ (-10))
                    Else
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Probability = (1 / PPPerms) - 1 ^ 10 - 10
                    End If
                End If
                
                LP = MinPos - SubWinLen - 1
                RP = MinPos + SubWinLen - 1
                If LP < 1 Then LP = LenXOverSeq + LP
                If RP > LenXOverSeq Then RP = RP - LenXOverSeq
                If PPWinScore(LP, A) <= PPWinScore(RP, A) Then 'ie left is most likely
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning = XDiffpos(LP)
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending = XDiffpos(MinPos)
                    OriFlag = 0
                Else
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning = XDiffpos(MinPos)
                    XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending = XDiffpos(RP)
                    OriFlag = 1
                End If
                
                
                'Find best parents by looking for sequences with biggest
                'change in rank on either side of breakpoint
                Dim DiffDist() As Double, LODist As Double, HiDist As Double, Hi As Long
                ReDim DiffDist(NumberOfSeqs)
              '  TL = 0
              '  TR = 0
              '  For Z = 0 To numberofseqs
              '      TL = TL + LeftDist(Z)
              '      TR = TR + RightDist(Z)
              '  Next Z
              '  For Z = 0 To numberofseqs
              '      DiffDist(Z) = LeftDist(Z) / TL - RightDist(Z) / TR
              '      X = X
              '  Next Z
                
                For Z = 0 To NumberOfSeqs
                'Z = X
                    LRank(Z) = 0
                    RRank(Z) = 0
                    For B = 0 To NumberOfSeqs
                        If pLeftDist(B) <= pLeftDist(Z) Then LRank(Z) = LRank(Z) + 1
                        If pRightDist(B) <= pRightDist(Z) Then RRank(Z) = RRank(Z) + 1
                        X = X
                    Next B
                    X = X
                Next Z
                'Exit Sub
                
                
                For Z = 0 To NumberOfSeqs
                    DiffDist(Z) = LRank(Z) - RRank(Z)
                    'Exit Sub
                Next Z
                
                
                'delete region
                    
                    Start = XPosdiff(XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Beginning)
                    'Start = MinPos
                        circ = 0
                        Do
                            LStart = Start
                            Start = Start - 1
                            If Start < 1 Then
                                Start = LenXOverSeq
                                circ = circ + 1
                                If circ = 2 Then Exit Do
                            End If
                            If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                        Loop
                        If circ = 2 Then Exit Do
                        LO = LStart
                        Start = XPosdiff(XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Ending)
                        Do
                            LStart = Start
                            Start = Start + 1
                            If Start > LenXOverSeq Then Start = 1
                            If SmoothScore(Start, X) < SmoothScore(LStart, X) Then Exit Do
                        Loop
                        If LO < Start Then
                            For Z = LO To Start
                                SmoothScore(Z, X) = 1
                            Next Z
                        Else
                            For Z = LO To LenXOverSeq
                                SmoothScore(Z, X) = 1
                            Next Z
                            For Z = 1 To Start
                                SmoothScore(Z, X) = 1
                            Next Z
                        End If
                
                LODist = 100000
                HiDist = 100000
                LO = -1
                Hi = -1
                For Z = 0 To NumberOfSeqs
                    
                    If DiffDist(Z) < 0 And Z <> X And LODist > pLeftDist(Z) Then
                        LODist = pLeftDist(Z)
                        LO = Z
                    End If
                    If DiffDist(Z) > 0 And Z <> X And HiDist > pRightDist(Z) Then
                        HiDist = pRightDist(Z)
                        Hi = Z
                    End If
                    
                Next Z
                
                
                
                If LO = -1 Or Hi = -1 Then
                    'I need to look at movement around the trendline
                    
        
                    X = X
                Else
                    If OriFlag = 1 Then
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP = RevSeq(Hi)
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP = RevSeq(LO)
                    
                    Else
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP = RevSeq(LO)
                        XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP = RevSeq(Hi)
                    End If
                    
                    
                        D = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).Daughter
                        Mi = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MinorP
                        Ma = XOverList(RevSeq(X), CurrentXover(RevSeq(X))).MajorP
                        
                        
                        If D = Ma Or D = Mi Or Ma > NextNo Or Ma > NextNo Then
                            X = X
                            Exit Sub
                        End If
                        
                        FindDaughter D, Mi, Ma, 0, 0, 6, CurrentXover(RevSeq(X))
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(6) = 1
                            Call UpdatePlotB(D, Ma, Mi, CurrentXover(RevSeq(X)))
    
                        End If
                End If
            End If
            
            
        XDiffpos(MinPos) = XDiffpos(MinPos)
        ET = GetTickCount
        
        If ET - LT > 500 Then
            Form1.ProgressBar1.Value = X / NumberOfSeqs * 100
            If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 1
            Form1.Label5(1).Caption = DoTimeII(ET - PT)
            Form1.Label57(0).Caption = DoTimeII(ET - ST)
            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(6) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
            End If
            LT = ET
            Form1.SSPanel13.Caption = "Approximately " & DoTime((ET - PT) * (100 / Form1.ProgressBar1.Value) - (ET - PT)) & " remaining"
            Form1.SSPanel1.Caption = Str(X) & " of" & Str(NumberOfSeqs) & " sequences examined"
            DoEvents
            If AbortFlag = 1 Then
            
                Exit For
            End If
        End If
    Loop
    
Next X

Form1.ProgressBar1.Value = 0

If TotalPPRecombinants > 0 Then ProgF(6) = 1
End Sub
Public Sub FindSubSeqPP()

ReDim SubMaskSeq(NextNo + 1)
ReDim RevSeq(NextNo)
'If IndividualB <> -1 Then
    
NumberOfSeqs = 0
If RelX <> 0 Or RelY <> 0 Then
    For X = 0 To PermNextNo
        If pMaskSeq(X) <= 1 Then
            SubMaskSeq(NumberOfSeqs) = X
            RevSeq(X) = NumberOfSeqs
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next 'X
Else
    For X = 0 To PermNextNo
        If MaskSeq(X) <= 1 Then
            SubMaskSeq(NumberOfSeqs) = X
            RevSeq(X) = NumberOfSeqs
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next 'X
End If
NumberOfSeqs = NumberOfSeqs - 1
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
Y = 0
Dim BakDist As Long
BakDist = 1
Dim Match() As Long
ReDim Match(255)
If CurrentCheck <> -1 Or (RelX = 0 And RelY = 0) Or Len(PPXOSeq(0)) > 0 Then
    If PPStripGaps = 0 Then
        For X = 1 To Len(StrainSeq(0))
            XPosdiff(X) = Y
            'ReDim Match(255)
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(X, RevSeq(Z))) = Match(SeqNum(X, RevSeq(Z))) + 1
                'If Match(SeqNum(X, RevSeq(Z))) <> 46 Then
                    If Match(SeqNum(X, RevSeq(Z))) + Match(46) < Z + 1 Then Exit For
                'Else
                
                'End If
            Next Z
            If Z < NumberOfSeqs + 1 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
            End If
        Next X
    Else
        For X = 1 To Len(StrainSeq(0))
            XPosdiff(X) = Y
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(X, RevSeq(Z))) = Match(SeqNum(X, RevSeq(Z))) + 1
                If Match(SeqNum(X, RevSeq(Z))) < Z + 1 Or Match(46) > 0 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 And Match(46) = 0 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
            End If
        Next X
    End If
Else
    ReDim PPXOSeq(NextNo)
    If PPStripGaps = 0 Then
        For X = 1 To Len(StrainSeq(0))
            XPosdiff(X) = Y
            'ReDim Match(255)
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(X, RevSeq(Z))) = Match(SeqNum(X, RevSeq(Z))) + 1
                If Match(SeqNum(X, RevSeq(Z))) + Match(46) < Z + 1 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                For Z = 0 To NumberOfSeqs
                    PPXOSeq(RevSeq(Z)) = PPXOSeq(RevSeq(Z)) + Mid$(StrainSeq(RevSeq(Z)), X, 1)
                Next Z
            End If
        Next X
    Else
        For X = 1 To Len(StrainSeq(0))
            XPosdiff(X) = Y
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(X, RevSeq(Z))) = Match(SeqNum(X, RevSeq(Z))) + 1
                If Match(SeqNum(X, RevSeq(Z))) < Z + 1 Or Match(46) > 0 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 And Match(46) = 0 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                For Z = 0 To NumberOfSeqs
                    PPXOSeq(RevSeq(Z)) = PPXOSeq(RevSeq(Z)) + Mid$(StrainSeq(RevSeq(Z)), X, 1)
                Next Z
            End If
        Next X
    End If
End If
LenXOverSeq = Y

End Sub

Public Sub PXoverD()



Dim NS As Long, PT As Long, CutOff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = GetTickCount
ReDim LRank(NumberOfSeqs), RRank(NumberOfSeqs)
Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"

'numberofseqs = 5


'Get variable sites
Call FindSubSeqPP

If IncSelf = 0 Then
    NS = NumberOfSeqs
Else
    NS = NumberOfSeqs + 1
End If

Dim WinLen As Long, PDstMat() As Long

ReDim PDstMat(NumberOfSeqs, NumberOfSeqs, 1)
If ExeCheckFlag = 1 And OptFlag <> 13 Then
    If XPosdiff(XOverList(RelX, RelY).Ending) > XPosdiff(XOverList(RelX, RelY).Beginning) Then
        WinLen = XPosdiff(XOverList(RelX, RelY).Ending) - XPosdiff(XOverList(RelX, RelY).Beginning)
    Else
        WinLen = XPosdiff(XOverList(RelX, RelY).Ending) + (LenXOverSeq - XPosdiff(XOverList(RelX, RelY).Beginning))
    End If
Else
 WinLen = CInt(PPWinLen / 2)
End If

If WinLen > LenXOverSeq / 2 Then WinLen = CInt(LenXOverSeq / 2)


ReDim PPWinScoreT(LenXOverSeq, NumberOfSeqs)

'Do matrix for the first half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            For Z = (LenXOverSeq - WinLen + 1) To LenXOverSeq
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 0) = PDstMat(X, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 0) = PDstMat(X, Y, 0)
    Next Y
Next X

'Do matrix for the second half of first window
For X = 0 To NumberOfSeqs
    For Y = X + 1 To NumberOfSeqs
            
            For Z = 1 To WinLen
                If SeqNum(XDiffpos(Z), RevSeq(X)) <> SeqNum(XDiffpos(Z), RevSeq(Y)) And SeqNum(XDiffpos(Z), RevSeq(X)) <> 46 And SeqNum(XDiffpos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(X, Y, 1) = PDstMat(X, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, X, 1) = PDstMat(X, Y, 1)
    Next Y
Next X

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc correlation and put into PPWinScoreTTas the first window pos
For X = 0 To NumberOfSeqs
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NumberOfSeqs
                If X <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(X, Y, 0)
                    SumY = SumY + PDstMat(X, Y, 1)
                    SumXY = SumXY + PDstMat(X, Y, 0) * PDstMat(X, Y, 1)
                    SumX2 = SumX2 + PDstMat(X, Y, 0) * PDstMat(X, Y, 0)
                    SumY2 = SumY2 + PDstMat(X, Y, 1) * PDstMat(X, Y, 1)
                    
                End If
    Next Y
    
    If SumX2 > 0 And SumY2 > 0 Then
        PPWinScoreT(1, X) = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
    Else
        PPWinScoreT(X, 1) = 1
    End If
    
Next X

Exit Sub

Dim Begin1 As Long, End2 As Long

For X = 2 To LenXOverSeq
    
    Offset = X
    End2 = X + WinLen - 1
    Begin1 = X - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXOverSeq + Begin1
    If End2 > LenXOverSeq Then End2 = End2 - LenXOverSeq
    For Z = 0 To NumberOfSeqs
        
        For Y = Z + 1 To NumberOfSeqs
            If SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(Begin1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffpos(Begin1), RevSeq(Y)) <> SeqNum(XDiffpos(Begin1), RevSeq(Z)))
            End If
            If SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(X - 1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffpos(X - 1), RevSeq(Y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
            End If
            
            If SeqNum(XDiffpos(End2), RevSeq(Y)) <> 46 And SeqNum(XDiffpos(End2), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffpos(End2), RevSeq(Y)) <> SeqNum(XDiffpos(End2), RevSeq(Z)))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NumberOfSeqs
       
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NumberOfSeqs
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                AA = ((NS * SumXY) - (SumX * SumY))
                BB = (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                
                If BB > 0 Then
                    PPWinScoreT(X, A) = AA / BB
                Else
                    PPWinScoreT(X, A) = 1
                End If
            Else
                PPWinScoreT(X, A) = 1
            End If
            
            'OutString(A) = OutString(A) + Str(PPWinScoreT(X, A))
    Next A
Next X

'Close #1
           

Dim MaxRVal As Double, MinRVal As Double
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlations
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, LP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For Z = 0 To NumberOfSeqs
    For Y = 1 To LenXOverSeq
        If PPWinScoreT(Y, Z) > MaxRVal Then
            MaxRVal = PPWinScoreT(Y, Z)
        ElseIf PPWinScoreT(Y, Z) < MinRValX Then
            MinRValX = PPWinScoreT(Y, Z)
            'If MinRValX < 0 Then
            '    X = X
            'End If
        End If
    Next Y
Next Z

DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 1, "Correlation"
MRV = MinRValX

MaRV = MaxRVal
Dim Red As Long, Green As Long, Blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        Red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        Blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
If X = 12345 Then
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
                
    For X = 0 To 2
        If X = 0 Then
            Y = Seq1
        ElseIf X = 1 Then
            Y = Seq2
        ElseIf X = 2 Then
            Y = Seq3
        End If
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 2 To LenXOverSeq 'Step 5
            Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    Next X
End If
Form1.Picture7.DrawWidth = 1
Pict = Form1.Picture7.hdc
            
For Y = 0 To NumberOfSeqs
    Form1.Picture7.ForeColor = ThreeQuaterColour
    If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 6 To LenXOverSeq Step 5
            Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    End If
Next Y
Call Highlight
For X = 0 To 2
    If X = 0 Then
        Y = Seq1
        Form1.Picture7.ForeColor = Green
    ElseIf X = 1 Then
        Y = Seq2
        Form1.Picture7.ForeColor = Blue
    ElseIf X = 2 Then
        Y = Seq3
        Form1.Picture7.ForeColor = Red
    End If
     'FFillCol(Y)
    Pict = Form1.Picture7.hdc
    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
    For Z = 2 To LenXOverSeq 'Step 5
        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
    Next Z
Next X
 OFontSize = Form1.Picture7.FontSize
    L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
    L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
    L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
    DrawLen = Form1.Picture7.ScaleWidth - 30
    TotLen = L1 + L2 + L3

    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    Else

        Do Until TotLen < DrawLen
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
            L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
            L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
            TotLen = L1 + L2 + L3
        Loop

        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    End If
       
YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq3)
    Form1.Picture7.CurrentX = XPos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Red 'RGB(255, 0, 0)
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Green 'RGB(0, 255, 0)
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Blue 'RGB(0, 0, 255)
    Form1.Picture7.Print StraiName(Seq3)
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
        
Form1.Picture7.Refresh
    
        
        
End Sub
Public Sub PXoverE()



Dim NS As Long, PT As Long, CutOff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = GetTickCount
ReDim LRank(NextNo), RRank(NextNo)
Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"

'Get variable sites



Call FindSubSeqPP


Dim MaxRVal As Double, MinRVal As Double
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlations
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, LP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For Z = 0 To NumberOfSeqs
    For Y = 1 To LenXOverSeq
        If PPWinScore(Y, Z) > MaxRVal Then
            MaxRVal = PPWinScore(Y, Z)
        ElseIf PPWinScore(Y, Z) < MinRValX Then
            MinRValX = PPWinScore(Y, Z)
            'If MinRValX < 0 Then
            '    X = X
            'End If
        End If
    Next Y
Next Z

DoAxes Len(StrainSeq(0)), -1, MaxRVal, MinRValX, 1, "Correlation"
MRV = MinRValX
MaRV = MaxRVal
Dim Red As Long, Green As Long, Blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        Red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        Blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
If X = 12345 Then
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
                
    For X = 0 To 2
        If X = 0 Then
            Y = Seq1
        ElseIf X = 1 Then
            Y = Seq2
        ElseIf X = 2 Then
            Y = Seq3
        End If
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 2 To LenXOverSeq 'Step 5
            Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    Next X
End If
Form1.Picture7.DrawWidth = 1
Pict = Form1.Picture7.hdc
            
For Y = 0 To NumberOfSeqs
    Form1.Picture7.ForeColor = ThreeQuaterColour
    If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 2 To LenXOverSeq
            Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    End If
Next Y
Call Highlight
For X = 0 To 2
    If X = 0 Then
        Y = Seq1
        Form1.Picture7.ForeColor = Green
    ElseIf X = 1 Then
        Y = Seq2
        Form1.Picture7.ForeColor = Blue
    ElseIf X = 2 Then
        Y = Seq3
        Form1.Picture7.ForeColor = Red
    End If
     'FFillCol(Y)
    Pict = Form1.Picture7.hdc
    Dummy = MoveToEx(Pict, 30 + (XDiffpos(1)) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
    For Z = 2 To LenXOverSeq 'Step 5
        Dummy = LineTo(Pict, 30 + (XDiffpos(Z)) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
    Next Z
Next X
 OFontSize = Form1.Picture7.FontSize
    L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
    L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
    L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
    DrawLen = Form1.Picture7.ScaleWidth - 30
    TotLen = L1 + L2 + L3

    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    Else

        Do Until TotLen < DrawLen
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            L1 = Form1.Picture7.TextWidth(StraiName(Seq1))
            L2 = Form1.Picture7.TextWidth(StraiName(Seq2))
            L3 = Form1.Picture7.TextWidth(StraiName(Seq3))
            TotLen = L1 + L2 + L3
        Loop

        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    End If
       
YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print StraiName(Seq3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print StraiName(Seq3)
    Form1.Picture7.CurrentX = XPos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Red 'RGB(255, 0, 0)
    Form1.Picture7.Print StraiName(Seq1)
    Form1.Picture7.CurrentX = XPos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Green 'RGB(0, 255, 0)
    Form1.Picture7.Print StraiName(Seq2)
    Form1.Picture7.CurrentX = XPos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Blue 'RGB(0, 0, 255)
    Form1.Picture7.Print StraiName(Seq3)
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
Form1.ProgressBar1 = 0
Form1.SSPanel1 = ""
Form1.Picture7.Refresh
    
        
        
End Sub
Public Sub DrawBSPlotsII()
    'Draws plots for the automated bootscan

    Dim PntAPI As POINTAPI
    Dim Pict As Long, X As Long, PosCount As Long, Zero As Long, One As Long, Two As Long

    'Draw the axes
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
           
    LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
    
    Call DoAxes(Len(StrainSeq(0)), -1, 100, 0, 1, "Bootstrap support (%)")

    'Dimension arrays for drawing metafiles
    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(2, Len(StrainSeq(0)))
    PosCount = 0

    Do While PltPos(PosCount + 1) > 0
        MCPrintPos(PosCount) = PltPos(PosCount)
        MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
        MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
        MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
        PosCount = PosCount + 1
    Loop

    'Draw the line fade
    Form1.Picture7.DrawWidth = 3

    For X = 2 To 0 Step -1

        If X = 2 Then
            Form1.Picture7.ForeColor = LPurple
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LYellow
        End If

        Pict = Form1.Picture7.hdc
        PosCount = 0
        Do While PltPos(PosCount + 2) > 0
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
                
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount + 1) * XFactor, 20 + (1 - PltVal(X, PosCount + 1) / BSBootReps) * (PicHeight - 35))
                
            End If
            PosCount = PosCount + 1
        Loop

    Next 'X

    'Form1.ProgressBar1.Value = 93
    Form1.Picture7.DrawWidth = 1
    'Highlight the recombinant region
    
    If (RelX > 0 Or RelY > 0) And RunFlag = 1 Then

        Call Highlight

    End If

    'Do cutoff line
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.DrawStyle = 2
    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
    Form1.Picture7.DrawStyle = 0

    'Do the foregreound plot

    For X = 0 To 2

        If X = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        Pict = Form1.Picture7.hdc
        
        
        
        'Dummy = MoveToEx(Pict, 30 + PltPos(0) * XFactor, 20 + (1 - PltVal(X, 0) / BSBootReps) * (PicHeight - 35), PntAPI)
        PosCount = 0

        Do While PltPos(PosCount + 2) > 0
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
                
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount + 1) * XFactor, 20 + (1 - PltVal(X, PosCount + 1) / BSBootReps) * (PicHeight - 35))
                
            End If
            PosCount = PosCount + 1
        Loop

    Next 'X

    'Form1.ProgressBar1.Value = 100
    'Do the key

    If TManFlag = -1 Then

        If BOOTSCANFlag = 1 And ((Form1.Combo1.ListIndex = 2 And ExeCheckFlag = 1) Or ExeCheckFlag = 0) Then

            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

        Else

            Call WriteNames(RevSeq(Seq1), RevSeq(Seq2), RevSeq(Seq3), Yellow, Green, Purple)

        End If

    End If

    'Form1.Picture7.Refresh
    'Form1.Picture10.Refresh
End Sub
Public Sub DrawBSPlotsIII(SPF, FindAllFlag As Byte)
    'Does Plots for the "re-bootscan check"
    Dim MinPA As Double
    Dim PntAPI As POINTAPI
    Dim Zero As Long, Pict As Long
    Dim One As Long, Two As Long, PosCount As Long
    
    
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
           
    LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
    
    Zero = 0
    One = 1
    Two = 2
    If FindAllFlag = 0 And SPF = 0 Then
        s1colb = LYellow
        s1col = Yellow
        s2colb = LGreen
        s2col = Green
        s3colb = LPurple
        s3col = Purple
        'Draw the axes
        'Form1.Picture7.Picture = LoadPicture()
        Call DoAxes(Len(StrainSeq(0)), -1, 100, 0, 1, "Bootstrap support (%)")
    
        Form1.Picture7.DrawWidth = 3
        PosCount = 0
        ReDim MCPrintPos(Len(StrainSeq(0)))
        ReDim MCPrintData(2, Len(StrainSeq(0)))
    
        Do While PltPos(PosCount + 2) > 0
            'Exit Sub
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSCBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSCBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSCBootReps) * 100
            PosCount = PosCount + 1
            Pict = Form1.Picture7.hdc
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
                Form1.Picture7.ForeColor = s3colb
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + (1 - PltVal(2, PosCount - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(2, PosCount) / BSCBootReps) * (PicHeight - 35))
                Form1.Picture7.ForeColor = s2colb
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + (1 - PltVal(1, PosCount - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(1, PosCount) / BSCBootReps) * (PicHeight - 35))
                Form1.Picture7.ForeColor = s1colb
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + ((1 - PltVal(0, PosCount - 1) / BSCBootReps) * (PicHeight - 35)), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, (20 + ((1 - PltVal(0, PosCount) / BSCBootReps) * (PicHeight - 35))))
            End If
        Loop
    
        Form1.Picture7.DrawWidth = 1
    
        Call Highlight
        
        'Draw cutoff line
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawStyle = 2
        MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
        LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
        Form1.Picture7.DrawStyle = 0
    
        PosCount = 0
    
        Do While PltPos(PosCount + 2) > 0
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSCBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSCBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSCBootReps) * 100
            PosCount = PosCount + 1
            Pict = Form1.Picture7.hdc
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
                Form1.Picture7.ForeColor = s1col
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + ((1 - PltVal(0, PosCount - 1) / BSCBootReps) * (PicHeight - 35)), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, (20 + ((1 - PltVal(0, PosCount) / BSCBootReps) * (PicHeight - 35))))
                Form1.Picture7.ForeColor = s3col
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + (1 - PltVal(2, PosCount - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(2, PosCount) / BSCBootReps) * (PicHeight - 35))
                Form1.Picture7.ForeColor = s2col
                Dummy = MoveToEx(Pict, 30 + PltPos(PosCount - 1) * XFactor, 20 + (1 - PltVal(1, PosCount - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(1, PosCount) / BSCBootReps) * (PicHeight - 35))
            End If
        Loop
    End If
    
    RE = XOverList(RelX, RelY).Ending
    RS = XOverList(RelX, RelY).Beginning
    
    If BSPValFlag > 0 And TManFlag = -1 Then
            
            'I disabled this because it screws up the variable site view in the sequence display
            ' - it does not match up with the variable sites found with findsubseqbs
           
            
           
            
            LSeq = Len(StrainSeq(0))
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            Dim NJSubDistance() As Double
            ReDim NJSubDistance(NextNo, NextNo)
            Dummy = DistanceCalcE(ActiveMajorP, NextNo, LSeq + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(ActiveMinorP, NextNo, LSeq + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(ActiveSeq, NextNo, LSeq + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dim ScoreP As Byte, hMChi As Double, XOverLen As Long
            If NJSubDistance(ActiveSeq, ActiveMinorP) > NJSubDistance(ActiveSeq, ActiveMajorP) And NJSubDistance(ActiveSeq, ActiveMinorP) > NJSubDistance(ActiveMajorP, ActiveMinorP) Then
                Hi1 = ActiveSeq
                Hi2 = ActiveMinorP
                LO = ActiveMajorP
            ElseIf NJSubDistance(ActiveSeq, ActiveMajorP) > NJSubDistance(ActiveSeq, ActiveMinorP) And NJSubDistance(ActiveSeq, ActiveMajorP) > NJSubDistance(ActiveMajorP, ActiveMinorP) Then
                Hi1 = ActiveSeq
                Hi2 = ActiveMajorP
                LO = ActiveMinorP
            Else
                Hi1 = ActiveMajorP
                Hi2 = ActiveMinorP
                LO = ActiveSeq
                'Temp = ActiveSeq
                'ActiveSeq = ActiveMajorP
                'ActiveMajorP = Temp
            End If
                If (Hi1 = Seq1 And Hi2 = Seq2) Or (Hi2 = Seq1 And Hi1 = Seq2) Then
                    'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                        ScoreP = 0
                    'Else
                    '    If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                    '        ScoreP = 1
                    '    Else
                    '        ScoreP = 2
                    '    End If
                    'End If
                ElseIf (Hi1 = Seq1 And Hi2 = Seq3) Or (Hi2 = Seq1 And Hi1 = Seq3) Then
                    'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                        ScoreP = 1
                    'Else
                    '    If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                    '        ScoreP = 0
                    '    Else
                    '        ScoreP = 2
                    '    End If
                    'End If
                ElseIf (Hi1 = Seq3 And Hi2 = Seq2) Or (Hi2 = Seq3 And Hi1 = Seq2) Then
                    'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                        ScoreP = 2
                    'Else
                    '    If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                    '        ScoreP = 0
                    '    Else
                    '        ScoreP = 1
                    '    End If
                    'End If
                End If
                If RS < RE Then
                    XOverLen = XPosdiff(RE) - XPosdiff(RS) + 1
                    For X = XPosdiff(RS) To XPosdiff(RE)
                        A = A + Scores(X, ScoreP)
                    Next X
                    For X = 1 To XPosdiff(RS) - 1
                        C = C + Scores(X, ScoreP)
                    Next X
                    For X = XPosdiff(RE) + 1 To LenXOverSeq
                        C = C + Scores(X, ScoreP)
                    Next X
                Else
                    XOverLen = XPosdiff(RE) + (LenXOverSeq - XPosdiff(RS)) + 1
                    For X = XPosdiff(RE) + 1 To XPosdiff(RS) - 1
                        C = C + Scores(X, ScoreP)
                    Next X
                    For X = 1 To XPosdiff(RE)
                        A = A + Scores(X, ScoreP)
                    Next X
                    For X = XPosdiff(RS) To LenXOverSeq
                        A = A + Scores(X, ScoreP)
                    Next X
                End If
            
            If BSPValFlag = 1 Then
                'Using binomial dist
                'IndProb = C / (LenXoverSeq - XOverLen) '0.25 ' ((1 - Distance(hi1, Hi2))) / ((1 - Distance(hi1, LO)) + (1 - Distance(Hi2, LO)) + (1 - Distance(hi1, Hi2)))
                indprob = (C + A)
                If LenXOverSeq = 0 Then Exit Sub
                indprob = indprob / (LenXOverSeq)
                'LenXoverSeq = CLng(d1 + d2 + d3 - Abs(d2 - d3) - Abs(d1 - d2) - Abs(d1 - d3))
                If XOverLen > 2 Then
                                        If XOverLen >= 170 Then
                                            A = CLng(A * 169 / XOverLen)
                                            AFact = XOverLen / 169
                                            XOverLen = 169
                                            
                                        Else
                                            AFact = 1
                                        End If
                        'C routine that calculates the probability of the "recomination" having occured by chance.
                    ProbabilityXOver = ProbCalc(Fact(0), XOverLen, A, indprob, LenXOverSeq)
                    ProbabilityXOver = ProbabilityXOver ^ AFact
                
                X = X
                Else
                    ProbabilityXOver = 1
                End If
                
            ElseIf BSPValFlag = 2 Then
                
                    C = CLng(C * (XOverLen / LenXOverSeq))
                    B = XOverLen - A
                    D = XOverLen - C
                    If (A + C > 0) And (B + D > 0) Then
                        hMChi = (A * D - B * C) ^ 2 * XOverLen * 2
                        hMChi = hMChi / (A + B)
                        hMChi = hMChi / (C + D)
                        hMChi = hMChi / (A + C)
                        hMChi = hMChi / (B + D)
                        If hMChi > 0 Then
                            ProbabilityXOver = ChiPVal(hMChi)
                        Else
                            ProbabilityXOver = 1
                        End If
                    Else
                       ProbabilityXOver = 1
                    End If
                    'ProbabilityXOver = ProbabilityXOver * (LenXoverSeq / (XOverLen * 2))
                
                
            End If
            
            If pMCFlag = 0 Then
                ProbabilityXOver = ProbabilityXOver * MCCorrection
            ElseIf pMCFlag = 2 Then
                ProbabilityXOver = StepDown2(2, ProbabilityXOver)
            End If
            
    
            If RE > RS Then
                ProbX = RS + (RE - RS) / 2
            Else
                If Len(StrainSeq(0)) - RS > RE Then
                    ProbX = RS + (Len(StrainSeq(0)) - RS) / 2
                Else
                    ProbX = 1 + RE / 2
                End If
            End If
            If BSCutOff < 0.9 Then
                ProbY = 1
            Else
                ProbY = 0.85
            End If
            ProbTest = ProbabilityXOver
            MinPA = ProbabilityXOver
            If MinPA > 0 Then
                If MinPA < 1 Then
                    If SPF = 0 Then Call PrintProbability
                End If
                If LongWindedFlag = 0 Then
                    EN = XOverList(RelX, RelY).Eventnumber
                Else
                    EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
                End If
                
                If XOverList(RelX, RelY).ProgramFlag <> 2 And XOverList(RelX, RelY).ProgramFlag <> 2 + AddNum Then
                    PT = 10 ^ (-ConfirmP(EN, 2))
                    
                    If (Confirm(EN, 2) = 0 Or (Confirm(EN, 2) = 1 And MinPA < PT)) And MinPA < 1 Then
                        Confirm(EN, 2) = 1
                        ConfirmP(EN, 2) = -Log10(MinPA)
                        DoEvents
            
                        If Form1.HScroll3.Value = 0 Then
                            Form1.HScroll3.Value = 1
                        Else
                            Form1.HScroll3.Value = 0
                        End If
            
                    End If
            
                End If
            End If
    End If
    If SPF = 0 Then
        Form1.Picture7.Refresh
        Form1.Picture10.Refresh
    End If
    If TManFlag = -1 And SPF = 0 Then

        If BOOTSCANFlag = 1 And ((Form1.Combo1.ListIndex = 2 And ExeCheckFlag = 1) Or ExeCheckFlag = 0) Then

            Call WriteNames(SubMaskSeq(Seq1), SubMaskSeq(Seq2), SubMaskSeq(Seq3), s1col, s2col, s3col)

        Else

            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

        End If

    End If
     
End Sub



Public Sub BootscanChecking()
Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking Bootscan results
    OptFlag = -1
    
    Screen.MousePointer = 11 'Hourglass

    If CurrentCheck = 0 Then
        XOverWindowX = CDbl(Form3.Text2.Text)
        xSpacerFlag = SpacerFlag
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
        
        Call FindSubSeqBS
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        Call FindSubSeqBS
        
    ElseIf CurrentCheck = 1 Then

        Call GCCheck(0)
        
        Call FindSubSeqBS

    ElseIf CurrentCheck = 2 Then

        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else
            'Only draw it if it has not already been drawn

            If Form1.Image3(0).Picture = 0 Then
                'Sort out plot colours
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                
                Call FindSubSeqBS
                
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If

    ElseIf CurrentCheck = 3 Then
        'Only draw it if it has not already been drawn

        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqBS
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call LXoverB

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqBS

    ElseIf CurrentCheck = 8 Then

        Call DXoverE

    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then

            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqBS
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If

    'Need to get a string of variable sites for the sequence display.

    

    SpacerNo = 0
    Screen.MousePointer = 0 'Change back to default
End Sub

Public Sub RDPChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Screen.MousePointer = 11
    OptFlag = -1
    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 1 Then
        
        'If togglex = 0 Then
            Call GCCheck(0)
            
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else

            If Form1.Image3(0).Picture = 0 Then
                
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call FindSubSeqRDP

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call FindSubSeqRDP

    ElseIf CurrentCheck = 4 Then
        
        Call MCXoverG(0)
        
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 5 Then
        
        Call SSXoverB(0)
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call LXoverB
            
            Call FindSubSeqRDP

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqRDP

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqRDP
        
    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqRDP

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If
    ElseIf CurrentCheck = 10 Then
        
        Call CXoverC(0)
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2

    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII
    End If
    Dim AH(2) As Long
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqRDP())
        'Call FindSubSeqRDP
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
    Else

        Call FindSubSeqRDP

    End If

    Screen.MousePointer = 0
End Sub

Public Sub PhylProChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Screen.MousePointer = 11
    OptFlag = -1
    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
        Call FindSubSeqPP
    ElseIf CurrentCheck = 1 Then
        
        'If togglex = 0 Then
            Call GCCheck(0)
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqPP
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else

            If Form1.Image3(0).Picture = 0 Then
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call FindSubSeqPP

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call FindSubSeqPP

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqPP
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
        Call FindSubSeqPP
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call LXoverB
            
            Call FindSubSeqPP

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If
        Call FindSubSeqPP
    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqPP

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqPP
        
    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqPP

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If
    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqPP
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If
    Dim AH(2) As Long
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqpP)
        'Call FindSubSeqpP
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
    Else

        Call FindSubSeqPP

    End If

    Screen.MousePointer = 0
End Sub
Public Sub GCChecking2()
Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Screen.MousePointer = 11
    OptFlag = -1
    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        Call FindSubSeqGC2
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 1 Then
        
        'If togglex = 0 Then
            Call GCCheck(0)
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else

            If Form1.Image3(0).Picture = 0 Then
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call FindSubSeqGC2

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call FindSubSeqGC2

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call LXoverB
            
            Call FindSubSeqGC2

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqGC2

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqGC2
        
    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqGC2

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If
    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If
    Dim AH(2) As Long
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqRDP)
        'call FindSubSeqGC2
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
    Else

        Call FindSubSeqGC2

    End If

    Screen.MousePointer = 0
End Sub
Public Sub MaxChiChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking MaxChi results with triplet scanning
    OptFlag = -1
    Screen.MousePointer = 11

    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call GetXOSMC
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        Call GetXOSMC
    ElseIf CurrentCheck = 1 Then
        
        Call GCCheck(0)

        Call GetXOSMC

    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else
            
            If Form1.Image3(0).Picture = 0 Then
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call GetXOSMC
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call GetXOSMC

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            'Call ModSeqNum(0)
            Call FindSubSeqBS
            
            Call LXoverB

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call GetXOSMC
            'Call UnModSeqNum(0)
        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call GetXOSMC

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call GetXOSMC

    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call GetXOSMC

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call GetXOSMC
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If

    SpacerNo = 0
    Screen.MousePointer = 0
End Sub
Public Sub ChimaeraChecking()
    'This is the subroutine that is called when checking MaxChi results with triplet scanning
    Dim WeightMod() As Long, Scratch() As Integer
    OptFlag = -1
    Screen.MousePointer = 11
    

    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call FindSubSeqChi
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 13 Then
        Call PXoverD
        Call FindSubSeqChi
    ElseIf CurrentCheck = 1 Then
        
        Call GCCheck(0)

        Call FindSubSeqChi

    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else
            
            If Form1.Image3(0).Picture = 0 Then
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
                XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call FindSubSeqChi

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call LXoverB

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqChi

        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqChi

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqChi

    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqChi

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If

    SpacerNo = 0
    Screen.MousePointer = 0
End Sub

Public Sub SiScanChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking MaxChi results with triplet scanning
    OptFlag = -1
    Screen.MousePointer = 11

    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call FindSubSeqSS(SSOLoSeq)
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 1 Then
        
        Call GCCheck(0)

        Call FindSubSeqSS(SSOLoSeq)

    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If BOOTSCANFlag = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverL(0)

        Else
            
            If Form1.Image3(0).Picture = 0 Then
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                If AbortFlag = 0 Then
                    Form1.Image3(0).Picture = Form1.Picture7.Image
                Else
                    AbortFlag = 0
                End If

            Else
               XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
            End If

        End If
        
        Call FindSubSeqSS(SSOLoSeq)
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        If Form1.Image3(0).Picture = 0 Then
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
           
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            If AbortFlag = 0 Then
                Form1.Image3(0).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If

        Else
            XL = "Bootstrap support (%)"
                Form1.Picture10.Enabled = True
                Form1.Picture10.Picture = LoadPicture()
                Form1.Picture10.CurrentX = 5
                Form1.Picture10.FontSize = 6
                TW = Form1.Picture7.TextWidth(XL)
                Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2
                Call DoText(Form1.Picture10, Form1.Picture10.Font, XL, 90)
                Form1.Picture7.Picture = Form1.Image3(0).Picture
        End If
        
        Call FindSubSeqSS(SSOLoSeq)

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        If Form1.Image3(1).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call LXoverB

            If AbortFlag = 0 Then
                Form1.Image3(1).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqSS(SSOLoSeq)

        Else
            Call DoAxes(Len(StrainSeq(0)), -1, 10, 0, 0, "Log likelihood ratio"): Form1.Picture7.Picture = Form1.Image3(1).Picture
        End If

    ElseIf CurrentCheck = 7 Then

        Call RXoverB
        
        Call FindSubSeqSS(SSOLoSeq)

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqSS(SSOLoSeq)

    ElseIf CurrentCheck = 9 Then

        If Form1.Image3(2).Picture = 0 Then
            
            Call FindSubSeqBS
            
            Call TXover3

            If AbortFlag = 0 Then
                Form1.Image3(2).Picture = Form1.Picture7.Image
            Else
                AbortFlag = 0
            End If
            
            Call FindSubSeqSS(SSOLoSeq)

        Else
            Form1.Picture7.Picture = Form1.Image3(2).Picture
        End If

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqSS(SSOLoSeq)
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        Call RecombMapIII

    End If

    SpacerNo = 0
    Screen.MousePointer = 0
End Sub
Public Sub MaxChiCheckingII()
    'This is the subroutine that is called when checking MaxChi results when
    'entire dataset was scanned simmultaneously
    Screen.MousePointer = 11

    If CurrentCheck = 20 Then

        Call GCDraw

    ElseIf CurrentCheck = 21 And NoMCFlag = 0 Then

        Call MCXoverI

    ElseIf CurrentCheck = 22 Then

        Call RXoverB

    ElseIf CurrentCheck = 23 Then

        Call DXoverG

    ElseIf CurrentCheck = 24 Then

        Call RecOverview2

    End If

    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
End Sub
Public Sub DoCombo(TypeA As Byte)
    Form1.Frame7.Enabled = True
    Form1.Command25.Enabled = False

    If TypeA = 0 Then
        Form1.Combo1.Enabled = True
        Form1.Command29.Enabled = True
        Form1.Combo1.Clear
        Form1.Combo1.BackColor = QBColor(15)
        Form1.Combo1.AddItem "RDP", 0
        Form1.Combo1.AddItem "GENECONV", 1
        Form1.Combo1.AddItem "Bootscan", 2
        Form1.Combo1.AddItem "Re-Bootscan", 3
        Form1.Combo1.AddItem "MaxChi", 4
        Form1.Combo1.AddItem "Chimaera", 5
        Form1.Combo1.AddItem "SiScan", 6
        Form1.Combo1.AddItem "PhylPro", 7
        Form1.Combo1.AddItem "LARD", 8
        'Form1.Combo1.AddItem "Reticulate", 9
        Form1.Combo1.AddItem "TOPAL", 9
        Form1.Combo1.AddItem "Distance Plot", 10
        
        
        Form1.Combo1.AddItem "Overview", 11
        Form1.Combo1.AddItem "Event Map", 12
        'Form1.Combo1.AddItem "Event Density", 14
        Form1.Combo1.AddItem "Breakpoint Density", 13
    Else
        Form1.Combo1.Clear
        Form1.Combo1.BackColor = QBColor(15)
        Form1.Combo1.AddItem "GENECONV", 0
        Form1.Combo1.AddItem "MaxChi", 1
        Form1.Combo1.AddItem "PhylPro", 2
        'Form1.Combo1.AddItem "Reticulate", 3
        Form1.Combo1.AddItem "Distance Plot", 3
        Form1.Combo1.AddItem "Overview", 4
    End If

    DontDoComboFlag = 1

    If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
        Form1.Combo1.ListIndex = 0
    ElseIf XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
        If pGCTripletflag = 0 Then
            Form1.Combo1.ListIndex = 0
        Else
            Form1.Combo1.ListIndex = 1
        End If
    ElseIf XOverList(RelX, RelY).ProgramFlag = 2 Or XOverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
        Form1.Combo1.ListIndex = 2
    ElseIf XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum Then

        If MCTripletFlag = 0 Then
            Form1.Combo1.ListIndex = 4
        Else
            Form1.Combo1.ListIndex = 1
        End If
    ElseIf XOverList(RelX, RelY).ProgramFlag = 4 Or XOverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
        Form1.Combo1.ListIndex = 5
    ElseIf XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
        Form1.Combo1.ListIndex = 6
        ElseIf XOverList(RelX, RelY).ProgramFlag = 6 Or XOverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
        Form1.Combo1.ListIndex = 7
    End If

    DontDoComboFlag = 0
    Form1.Combo1.Enabled = True
    If XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
        Form1.Command29.Enabled = True
    End If
End Sub
Public Sub GCChecking()
    'This is the subroutine that is called when checking GENECONV results
    Screen.MousePointer = 11

    If CurrentCheck = 20 Then

        Call GCDraw

    ElseIf CurrentCheck = 21 And NoMCFlag = 0 Then

        If XOverList(RelX, RelY).OutsideFlag = 0 Then

            If (XOverList(RelX, RelY).ProgramFlag = 1 Or XOverList(RelX, RelY).ProgramFlag = 1 + AddNum) And XOverList(RelX, RelY).OutsideFlag = 1 Then
            Else

                Call MCXoverI
                Form1.Command29.Enabled = True
            End If

        End If

    ElseIf CurrentCheck = 22 Then

        Call RXoverB

    ElseIf CurrentCheck = 23 Then
        SS = GetTickCount
        Call DXoverG
        EE = GetTickCount
        TT = EE - SS
    ElseIf CurrentCheck = 24 Then

        Call RecOverview2

    End If

    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
End Sub

Public Sub ResizeForm3()
    Dim QuarterFrame As Long, TextWidth As Long, TextLeft As Long, ButtonWidth As Long, ButtonLeft As Long, FullFrame As Long, HalfFrame As Long, HalfLeft As Long, FullLeft As Long
    
    With Form3
        '.Left = 700
        '.Top = 100
        zz = .Width
        .Width = 8790
        .Height = 5950
        'Sort out spacing of the background area
        .Frame1.left = 0
        .Frame1.Top = 0
        
        .Frame1.Width = .Width
        .Frame1.Height = 5950
        .TabStrip1.left = 0
        .TabStrip1.Height = .Frame1.Height
        
        .TabStrip1.Width = .Frame1.Width
        XX = .Frame1.Width
        .TabStrip1.Top = 0
        .TabStrip2.left = 0
        .TabStrip2.Height = .Frame1.Height
        .TabStrip2.Width = .Frame1.Width
        .TabStrip2.Top = 0
        .TabStrip2.TabFixedWidth = .TabStrip2.Width - 4 * Screen.TwipsPerPixelX
        .TabStrip2.Font.Size = 12
        .TabStrip2.Font.Bold = True

        Dim X As Integer

        For X = 0 To 13
            .Frame2(X).Top = 650
            .Frame2(X).left = 200
            .Frame2(X).Width = 8390
            .Frame2(X).Height = 4650
        Next 'X

        '.frame2(0) - General .options
        
        FullFrame = .Width - 600 '8190
        FullLeft = 100
        HalfFrame = ((FullFrame - FullLeft) / 2) '3995
        HalfLeft = HalfFrame + FullLeft * 2
        QuarterFrame = HalfFrame - FullLeft * 2
        ButtonWidth = .Command7.Width
        ButtonLeft = HalfFrame - ButtonWidth - FullLeft
        TextWidth = 500
        TextLeft = HalfFrame - FullLeft - TextWidth
       
        .Frame8.left = 100
        .Frame8.Top = 200
        .Frame8.Width = FullFrame
        .Frame8.Height = 950
        
        .Text6.left = TextLeft
        .Text6.Top = 200
        .Text6.Width = 500
        .Text6.Height = 300
        .Label2.left = 200
        .Label2.Top = 250
        .Label2.Width = 1000
        .Label2.Height = 350
        .Label3.left = 200
        .Label3.Top = 600
        .Label3.Width = 2100
        .Label3.Height = 350
        '.command10.Width = 1000
        .Command10.Top = 550
        '.command10.Height = 350
        .Command10.left = ButtonLeft
        .Label19.left = 200
        .Label19.Top = 950
        .Label19.Width = 2100
        .Label19.Height = 350
        '.command3.Width = 1000
        .Command3.Top = 900
        '.command3.Height = 350
        .Command3.left = ButtonLeft
        '.frame9.Left = 100
        '.frame9.Top = 1800
        '.frame9.Width = 5900
        '.frame9.Height = 700
        
        .Frame27.left = HalfLeft
        .Frame27.Top = 1250
        .Frame27.Width = HalfFrame
        .Frame27.Height = 1700
        
        .Check10.left = 200
        .Check10.Top = 300
        
        .Check9.left = 200
        .Check9.Top = 650
        
        .Check11.left = 200
        .Check11.Top = 900
        
        .Label43.left = 200
        .Label43.Top = 1350
        
        .Command7.Top = 1300
        .Command7.left = ButtonLeft
        
        .Frame10.left = 100
        .Frame10.Top = 1250
        .Frame10.Width = HalfFrame
        .Frame10.Height = 1700
        .Command2.left = ButtonLeft
        .Command2.Top = 250
        '.command2.Width = 1000
        '.command2.Height = 350
        .Label16.left = 200
        .Label16.Top = 300
        .Label16.Width = 2100
        .Label16.Height = 350
        .Text3.left = TextLeft
        .Text3.Top = 600
        .Text3.Width = 500
        .Text3.Height = 300
        .Label18.left = 200
        .Label18.Top = 650
        .Label18.Width = 3000
        .Label18.Height = 350
        .Label23.left = 200
        .Label23.Top = 1000
        .Label23.Width = 2500
        .Label23.Height = 350
        '.command16.Width = 1000
        .Command16.Top = 950
        '.command16.Height = 350
        .Command16.left = ButtonLeft
        .Label20.left = 200
        .Label20.Top = 1350
        .Label20.Width = 2100
        .Label20.Height = 350
        '.command5.Width = 1000
        .Command5.Top = 1300
        '.command5.Height = 350
        .Command5.left = ButtonLeft
        .Frame9.left = 100
        .Frame9.Top = 3050
        .Frame9.Width = FullFrame
        .Frame9.Height = 1500

        Dim ColBoxDim As Integer

        '            .label50.Top = 300
        '           .label50.Left = 600
        ColBoxDim = 200
        .Check4.left = 250
        .Check4.Top = 200
        .Picture26(0).Width = ColBoxDim
        .Picture26(0).Height = ColBoxDim
        .Picture26(0).left = .Check4.left + 1325
        .Picture26(0).Top = 250
        .Picture26(0).BackColor = ProgColour(0)
        .Check5.left = 250
        .Check5.Top = 550
        .Picture26(1).Width = ColBoxDim
        .Picture26(1).Height = ColBoxDim
        .Picture26(1).left = .Check5.left + 1325
        .Picture26(1).Top = 600
        .Picture26(1).BackColor = ProgColour(1)
        .Check1.left = 2175
        .Check1.Top = 200
        .Picture26(2).Width = ColBoxDim
        .Picture26(2).Height = ColBoxDim
        .Picture26(2).left = .Check1.left + 1325
        .Picture26(2).Top = 250
        .Picture26(2).BackColor = ProgColour(2)
        .Check2.left = 2175
        .Check2.Top = 550
        .Picture26(3).Width = ColBoxDim
        .Picture26(3).Height = ColBoxDim
        .Picture26(3).left = .Check2.left + 1325
        .Picture26(3).Top = 600
        .Picture26(3).BackColor = ProgColour(3)
        .Check3.left = 4100
        .Check3.Top = 200
        .Picture26(4).Width = ColBoxDim
        .Picture26(4).Height = ColBoxDim
        .Picture26(4).left = .Check3.left + 1325
        .Picture26(4).Top = 250
        .Picture26(4).BackColor = ProgColour(4)
        .Check6.left = 4100
        .Check6.Top = 550
        .Picture26(5).Width = ColBoxDim
        .Picture26(5).Height = ColBoxDim
        .Picture26(5).left = .Check6.left + 1325
        .Picture26(5).Top = 600
        .Picture26(5).BackColor = ProgColour(5)
        .Check12.left = 6025
        .Check12.Top = 200
        .Picture26(6).Width = ColBoxDim
        .Picture26(6).Height = ColBoxDim
        .Picture26(6).left = .Check12.left + 1325
        .Picture26(6).Top = 250
        .Picture26(6).BackColor = ProgColour(6)
        For X = 0 To 6
        .Picture26(X).ZOrder
        Next X
        .Picture27.Height = 250
        .Picture27.Width = FullFrame - 500
        .Picture27.left = 250
        .Picture27.Top = 1150
        .Label60.Top = 900
        .Label60.left = 250
        .Label60.Width = 4000
        
        '.option buttons
        .Frame12.Top = 200
        .Frame12.left = 100
        .Frame12.Width = FullFrame
        .Frame12.Height = 3000

        For X = 0 To 4
            .Frame4(X).Top = 200
            .Frame4(X).left = 4000
            .Frame4(X).Visible = False
        Next 'X

        .Frame4(SpacerFlag).Visible = True
        .Option2.Top = 300
        .Option2.left = 210
        .Option3.Top = 700
        .Option3.left = 210
        .Option4.Top = 1100
        .Option4.left = 210
        .Option5.Top = 1500
        .Option5.left = 210
        .Option6.Top = 1900
        .Option6.left = 210
        
        '.labels for .option buttons
        .Label4.Top = 300
        .Label4.left = 600
        .Label5.Top = 700
        .Label5.left = 600
        .Label6.Top = 1100
        .Label6.left = 600
        .Label7.Top = 1500
        .Label7.left = 600
        .Frame3.left = 480
        .Frame3.Top = 1900
        .Frame11.Top = 3300
        .Frame11.left = 100
        .Frame11.Width = FullFrame
        .Frame11.Height = 1250
        .Text2.left = TextLeft
        .Text2.Top = 200
        .Text2.Width = TextWidth
        .Text2.Height = 300
        .Label17.left = 250
        .Label17.Top = 250
        .Label17.Width = 1000
        .Label17.Height = 350
        .Label49.Top = 550
        .Label49.left = 250
        .Text7 = MiDistance * 100
        .Text8 = MaDistance * 100
        .Text7.Top = 800
        .Text7.left = 250
        .Text7.Width = 600
        .Label25.Top = 850
        .Label25.left = 850
        .Text8.Top = 800
        .Text8.left = 1300
        .Text8.Width = 600
        .Label24.Top = 850
        .Label24.left = 1950
        
        
        '.frame2(2) - GC .options

        For X = 0 To 8
            .Command28(X).MouseIcon = Form1.Command18.MouseIcon
            .Command28(X).MousePointer = 99
        Next 'X

        .Frame14.Top = 200
        .Frame14.left = 100
        .Frame14.Width = HalfFrame
        .Frame14.Height = 1800
        
        .Label39.Top = 220
        .Label39.left = 100
        .Command28(8).Top = 200
        .Command28(8).left = ButtonLeft
        
        .Label29.Top = 520
        .Label29.left = 100
        .Command28(2).Top = 500
        .Command28(2).left = ButtonLeft
        
        .Label32.Top = 820
        .Label32.left = 100
        .Command28(4).Top = 800
        .Command28(4).left = ButtonLeft
        
        .Label31.Top = 1120
        .Label31.left = 100
        .Command28(3).Top = 1100
        .Command28(3).left = ButtonLeft
        
        .Label47.Top = 1420
        .Label47.left = 100
        .Text21.Top = 1400
        .Text21.left = 1800
        .Text21.Width = 600
        .Label48.Top = 1420
        .Label48.left = 2500
        .Text22.Top = 1400
        .Text22.left = 2700
        .Text22.Width = 600
        .Frame13.Top = 2150
        .Frame13.left = 100
        .Frame13.Width = HalfFrame
        .Frame13.Height = 2400
        .Label26.Top = 220
        .Label26.left = 100
        .Text9.Top = 200
        
        .Text9.Width = 990
        .Text9.left = HalfFrame - .Text9.Width - FullLeft
        .Text9.Height = 200
        .Label27.Top = 520
        .Label27.left = 100
        .Command28(0).Top = 500
        .Command28(0).left = ButtonLeft
        .Label33.Top = 820
        .Label33.left = 100
        
        
        
        .Command29.Top = 800
        .Command29.Width = 990
        .Command29.left = HalfFrame - FullLeft - .Command29.Width
        
        .Command28(5).Top = 800
        .Command28(5).left = .Command29.left - .Command28(5).Width
        
        .Label34.Top = 1120
        .Label34.left = 100
        .Command28(6).Top = 1100
        .Command28(6).left = ButtonLeft
        .Label30.Top = 1420
        .Label30.left = 100
        .Text10.Top = 1400
        .Text10.left = TextLeft
        .Text10.Width = TextWidth
        .Text10.Height = 290
        .Label35.Top = 1720
        .Label35.left = 100
        .Text11.Top = 1700
        .Text11.left = TextLeft
        .Text11.Width = TextWidth
        .Text11.Height = 290
        .Label28.Top = 2020
        .Label28.left = 100
        .Command28(1).Top = 2000
        .Command28(1).left = ButtonLeft
        .Frame15.Top = 200
        .Frame15.left = HalfLeft
        .Frame15.Width = HalfFrame
        .Frame15.Height = 2800
        .Label36.Top = 220
        .Label36.left = 100
        .Text12.Top = 200
        .Text12.left = TextLeft
        .Text12.Width = TextWidth
        .Text12.Height = 200
        .Label38.Top = 520
        .Label38.left = 100
        .Text14.Top = 600
        .Text14.left = TextLeft
        .Text14.Width = TextWidth
        .Text14.Height = 200
        .Label37.Top = 1020
        .Label37.left = 100
        .Text13.Top = 1100
        .Text13.left = TextLeft
        .Text13.Width = TextWidth
        .Text13.Height = 200
        .Label40.Top = 1520
        .Label40.left = 100
        .Text15.Top = 1500
        .Text15.left = TextLeft
        .Text15.Width = TextWidth
        .Text15.Height = 200
        .Label41.Top = 1820
        .Label41.left = 100
        .Text16.Top = 1800
        .Text16.left = TextLeft
        .Text16.Width = TextWidth
        .Text16.Height = 200
        .Label42.Top = 2120
        .Label42.left = 100
        .Text17.Top = 2100
        .Text17.left = TextLeft
        .Text17.Width = TextWidth
        .Text17.Height = 200
        .Label44.Top = 2420
        .Label44.left = 100
        .Text18.Top = 2400
        .Text18.left = TextLeft
        .Text18.Width = TextWidth
        .Text18.Height = 200
        .Frame16.Top = 3150
        .Frame16.left = HalfLeft
        .Frame16.Width = HalfFrame
        .Frame16.Height = 1400
        .Label45.Top = 220
        .Label45.left = 100
        .Text19.Top = 300
        .Text19.left = TextLeft
        .Text19.Width = TextWidth
        .Text19.Height = 200
        .Label46.Top = 720
        .Label46.left = 100
        .Text20.Top = 700
        .Text20.left = TextLeft
        .Text20.Width = TextWidth
        .Text20.Height = 200
        .Label59.Top = 1020
        .Label59.left = 100
        .Command28(7).left = ButtonLeft
        .Command28(7).Top = 1000
        
        'Bootscan .options
        .Frame5.Top = 150
        .Frame5.left = 100
        .Frame5.Width = HalfFrame
        .Frame5.Height = 2350
        .Label1(0).Top = 220
        .Label1(0).left = 100
        .Text1(0).Top = 200
        .Text1(0).left = TextLeft
        .Text1(0).Width = TextWidth
        .Text1(0).Height = 200
        .Label1(1).Top = 520
        .Label1(1).left = 100
        .Text1(1).Top = 500
        .Text1(1).left = TextLeft
        .Text1(1).Width = TextWidth
        .Text1(1).Height = 200
        .Label1(37).Top = 820
        .Label1(37).left = 100
        .Command28(23).Top = 800
        .Command28(23).left = ButtonLeft
        .Label1(2).Top = 1120
        .Label1(2).left = 100
        .Text1(2).Top = 1100
        .Text1(2).left = TextLeft
        .Text1(2).Width = TextWidth
        .Text1(2).Height = 200
        .Label1(3).Top = 1420
        .Label1(3).left = 100
        .Text1(3).Top = 1400
        .Text1(3).left = TextLeft
        .Text1(3).Width = TextWidth
        .Text1(3).Height = 200
        .Label1(6).Top = 1720
        .Label1(6).left = 100
        .Text1(5).Top = 1700
        .Text1(5).left = TextLeft
        .Text1(5).Width = TextWidth
        .Text1(5).Height = 200
        
        .Label1(48).Top = 2020
        .Label1(48).left = 100
        .Command28(28).Top = 2000
        .Command28(28).left = ButtonLeft
        
        .Frame7(0).Top = 150
        .Frame7(0).left = HalfLeft
        .Frame7(0).Width = HalfFrame
        .Frame7(0).Height = 2350
        .Label1(4).Top = 220
        .Label1(4).left = 100
        .Command28(9).Top = 200
        .Command28(9).left = ButtonLeft
        .Label1(5).Top = 520
        .Label1(5).left = 100
        .Text1(4).Top = 500
        .Text1(4).left = TextLeft
        .Text1(4).Width = TextWidth
        .Text1(4).Height = 200
        .Label1(39).Top = 820
        .Label1(39).left = 100
        .Text1(28).Top = 800
        .Text1(28).left = TextLeft
        .Text1(28).Width = TextWidth
        .Text1(28).Height = 200
        .Frame21(5).Top = 1100
        .Frame21(5).left = 100
        .Frame21(5).Width = QuarterFrame
        .Frame21(5).Height = 1125
        .Label21(34).Top = 220
        .Label21(34).left = 100
        .Command28(24).Top = 200
        .Command28(24).left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(32).Top = 520
        .Label21(32).left = 100
        .Text23(28).Top = 500
        .Text23(28).left = 1000
        .Text23(28).Width = TextWidth
        .Text23(28).Height = 200
        .Label21(30).Top = 820
        .Label21(30).left = 100
        .Text23(26).Top = 800
        .Text23(26).left = 1000
        .Text23(26).Width = TextWidth
        .Text23(26).Height = 200
        .Label21(31).Top = 520
        .Label21(31).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(27).Top = 500
        .Text23(27).left = QuarterFrame - TextWidth - FullLeft
        .Text23(27).Width = TextWidth
        .Text23(27).Height = 200
        .Label21(33).Top = 820
        .Label21(33).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(29).Top = 800
        .Text23(29).left = QuarterFrame - TextWidth - FullLeft
        .Text23(29).Width = TextWidth
        .Text23(29).Height = 200
        .Frame17.Top = 150
        .Frame17.left = HalfLeft
        .Frame17.Width = HalfFrame
        .Frame17.Height = 4375
        .Label1(8).Top = 220
        .Label1(8).left = 100
        .Text1(6).Top = 200
        .Text1(6).left = TextLeft
        .Text1(6).Width = TextWidth
        .Text1(6).Height = 200
        .Label1(9).Top = 520
        .Label1(9).left = 100
        .Text1(7).Top = 500
        .Text1(7).left = TextLeft
        .Text1(7).Width = TextWidth
        .Text1(7).Height = 200
        .Label1(38).Top = 820
        .Label1(38).left = 100
        .Command28(25).Top = 800
        .Command28(25).left = ButtonLeft
        .Label1(12).Top = 1120
        .Label1(12).left = 100
        .Text1(10).Top = 1100
        .Text1(10).left = TextLeft
        .Text1(10).Width = TextWidth
        .Text1(10).Height = 200
        .Check7.Top = 1350
        .Check7.left = 100
        .Check8.Top = 1950
        .Check8.left = 100
        .Frame18.Top = 2300
        .Frame18.left = 100
        .Frame18.Width = QuarterFrame
        .Frame18.Height = 1100
        .Label1(14).Top = 220
        .Label1(14).left = 100
        .Text1(11).Top = 200
        .Text1(11).left = QuarterFrame - TextWidth - FullLeft
        .Text1(11).Width = TextWidth
        .Text1(11).Height = 200
        .Label1(7).Top = 220
        .Label1(7).left = 100
        .Text1(8).Top = 200
        .Text1(8).left = QuarterFrame - TextWidth - FullLeft
        .Text1(8).Width = TextWidth
        .Text1(8).Height = 200
        .Label1(15).Top = 520
        .Label1(15).left = 100
        .Text1(12).Top = 500
        .Text1(12).left = QuarterFrame - TextWidth - FullLeft
        .Text1(12).Width = TextWidth
        .Text1(12).Height = 200
        .Label1(10).Top = 520
        .Label1(10).left = 100
        .Text1(9).Top = 500
        .Text1(9).left = QuarterFrame - TextWidth - FullLeft
        .Text1(9).Width = TextWidth
        .Text1(9).Height = 200
        
        'MaxChi .options
        .Frame23.Top = 200
        .Frame23.left = 100
        .Frame23.Width = HalfFrame
        .Frame23.Height = 2200
        .Label1(13).Top = 320
        .Label1(13).left = 100
        .Command28(13).Top = 300
        .Command28(13).left = ButtonLeft
        .Label1(11).Top = 720
        .Label1(11).left = 100
        .Command28(12).Top = 700
        .Command28(12).left = ButtonLeft
        .Label1(27).Top = 1120
        .Label1(27).left = 100
        .Text1(21).Top = 1100
        .Text1(21).left = TextLeft
        .Text1(21).Width = TextWidth
        .Text1(21).Height = 200
        
        .Label1(16).Top = 1520
        .Label1(16).left = 100
        .Command28(14).Top = 1500
        .Command28(14).left = ButtonLeft
        
        .Frame22.Top = 2575
        .Frame22.left = 100
        .Frame22.Width = HalfFrame
        .Frame22.Height = 1200
        .Label1(24).Top = 320
        .Label1(24).left = 100
        .Text1(18).Top = 300
        .Text1(18).left = TextLeft
        .Text1(18).Width = TextWidth
        .Text1(18).Height = 200
        .Label1(23).Top = 720
        .Label1(23).left = 100
        .Text1(17).Top = 700
        .Text1(17).left = TextLeft
        .Text1(17).Width = TextWidth
        .Text1(17).Height = 200
        
        'Chimaera options
        .Frame28.Top = 200
        .Frame28.left = 100
        .Frame28.Width = HalfFrame
        .Frame28.Height = 1300
        
        .Label1(55).Top = 320
        .Label1(55).left = 100
        .Command28(39).Top = 300
        .Command28(39).left = ButtonLeft
        .Label1(56).Top = 720
        .Label1(56).left = 100
        .Text1(36).Top = 700
        .Text1(36).left = TextLeft
        .Text1(36).Width = TextWidth
        .Text1(36).Height = 200
        
        .Frame29.Top = 1675
        .Frame29.left = 100
        .Frame29.Width = HalfFrame
        .Frame29.Height = 1200
        .Label1(53).Top = 320
        .Label1(53).left = 100
        .Text1(37).Top = 300
        .Text1(37).left = TextLeft
        .Text1(37).Width = TextWidth
        .Text1(37).Height = 200
        .Label1(54).Top = 720
        .Label1(54).left = 100
        .Text1(38).Top = 700
        .Text1(38).left = TextLeft
        .Text1(38).Width = TextWidth
        .Text1(38).Height = 200
        
        'SiScan
        
        .Frame26(0).Top = 200
        .Frame26(0).left = 100
        .Frame26(0).Width = HalfFrame
        .Frame26(0).Height = 1950
        
        .Label22(0).Top = 320
        .Label22(0).left = 100
        
        .Text24(0).Top = 300
        .Text24(0).left = TextLeft
        .Text24(0).Width = TextWidth
        .Text24(0).Height = 200
        
        .Label22(1).Top = 720
        .Label22(1).left = 100
        
        .Text24(1).Top = 700
        .Text24(1).left = TextLeft
        .Text24(1).Width = TextWidth
        .Text24(1).Height = 200
        
        
        .Label22(3).Top = 1120
        .Label22(3).left = 100
        
        .Command28(33).Top = 1080
        .Command28(33).left = ButtonLeft
        
        .Label22(4).Top = 1520
        .Label22(4).left = 100
        
        .Command28(36).Top = 1480
        .Command28(36).left = ButtonLeft
        
        .Frame26(2).Top = 200
        .Frame26(2).left = HalfLeft
        .Frame26(2).Width = HalfFrame
        .Frame26(2).Height = 1950
        
        .Label22(2).Top = 320
        .Label22(2).left = 100
        
        .Text24(2).Top = 300
        .Text24(2).left = TextLeft
        .Text24(2).Width = TextWidth
        .Text24(2).Height = 200
        
        .Label22(8).Top = 720
        .Label22(8).left = 100
        
        .Text24(4).Top = 700
        .Text24(4).left = TextLeft
        .Text24(4).Width = TextWidth
        .Text24(4).Height = 200
        
        .Label22(7).Top = 1120
        .Label22(7).left = 100
        
        .Text24(3).Top = 1100
        .Text24(3).left = TextLeft
        .Text24(3).Width = TextWidth
        .Text24(3).Height = 200
        
        .Label22(6).Top = 1520
        .Label22(6).left = 100
        
        .Command28(34).Top = 1480
        .Command28(34).left = ButtonLeft
        
        .Frame26(1).Top = 2200
        .Frame26(1).left = 100
        .Frame26(1).Width = HalfFrame
        .Frame26(1).Height = 720
        
        .Label22(5).Top = 300
        .Label22(5).left = 100
        
        .Command28(35).Top = 280
        .Command28(35).left = ButtonLeft
        
        'Phylpro Options
        .Frame30(0).Top = 200
        .Frame30(0).left = 100
        .Frame30(0).Width = HalfFrame
        .Frame30(0).Height = 1520
        
        .Label14(0).left = 100
        .Label14(0).Top = 320
        .Text4(0).Top = 300
        .Text4(0).left = TextLeft
        .Text4(0).Width = TextWidth
        .Text4(0).Height = 200
        
        .Label14(1).left = 100
        .Label14(1).Top = 720
        .Command28(37).Top = 680
        .Command28(37).left = ButtonLeft
        
        .Label14(2).left = 100
        .Label14(2).Top = 1120
        .Command28(38).Top = 1080
        .Command28(38).left = ButtonLeft
        
        .Frame30(1).Top = 1820
        .Frame30(1).left = 100
        .Frame30(1).Width = HalfFrame
        .Frame30(1).Height = 1120
        
        .Label14(3).left = 100
        .Label14(3).Top = 320
        .Text4(1).Top = 300
        .Text4(1).left = TextLeft
        .Text4(1).Width = TextWidth
        .Text4(1).Height = 200
        
        .Label14(4).left = 100
        .Label14(4).Top = 720
        .Text4(2).Top = 700
        .Text4(2).left = TextLeft
        .Text4(2).Width = TextWidth
        .Text4(0).Height = 200
        
        'LARD .options
        .Frame19.Top = 200
        .Frame19.left = 100
        .Frame19.Width = FullFrame
        .Frame19.Height = 3600
        
        .Label21(0).Top = 320
        .Label21(0).left = 100
        .Command28(10).Top = 280
        .Command28(10).left = ButtonLeft
        .Label21(6).Top = 720
        .Label21(6).left = 100
        .Text23(5).Top = 700
        .Text23(5).left = TextLeft
        .Text23(5).Width = TextWidth
        .Text23(5).Height = 200
        .Label21(7).Top = 1120
        .Label21(7).left = 100
        .Text23(6).Top = 1100
        .Text23(6).left = TextLeft
        .Text23(6).Width = TextWidth
        .Text23(6).Height = 200
        .Label21(12).Top = 1520
        .Label21(12).left = 100
        .Text23(11).Top = 1500
        .Text23(11).left = TextLeft
        .Text23(11).Width = TextWidth
        .Text23(11).Height = 200
        .Frame21(2).Top = 1920
        .Frame21(2).left = 100
        .Frame21(2).Width = QuarterFrame
        .Frame21(2).Height = 1520
        .Label21(16).Top = 320
        .Label21(16).left = 100
        .Text23(13).Top = 300
        .Text23(13).left = 1070
        .Text23(13).Width = TextWidth
        .Text23(13).Height = 200
        .Label21(18).Top = 720
        .Label21(18).left = 100
        .Text23(15).Top = 700
        .Text23(15).left = 1070
        .Text23(15).Width = TextWidth
        .Text23(15).Height = 200
        .Label21(14).Top = 1120
        .Label21(14).left = 100
        .Text23(16).Top = 1100
        .Text23(16).left = 1070
        .Text23(16).Width = TextWidth
        .Text23(16).Height = 200
        .Label21(17).Top = 320
        .Label21(17).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(14).Top = 300
        .Text23(14).left = QuarterFrame - TextWidth - FullLeft
        .Text23(14).Width = TextWidth
        .Text23(14).Height = 200
        .Label21(15).Top = 720
        .Label21(15).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(12).Top = 700
        .Text23(12).left = QuarterFrame - TextWidth - FullLeft
        .Text23(12).Width = TextWidth
        .Text23(12).Height = 200
        .Label21(19).Top = 1120
        .Label21(19).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(17).Top = 1100
        .Text23(17).left = QuarterFrame - TextWidth - FullLeft
        .Text23(17).Width = TextWidth
        .Text23(17).Height = 200
        .Frame21(1).Top = 200
        .Frame21(1).left = HalfLeft
        .Frame21(1).Width = QuarterFrame
        .Frame21(1).Height = 1520
        .Label21(13).Top = 320
        .Label21(13).left = 100
        .Command28(11).Top = 280
        .Command28(11).left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(10).Top = 720
        .Label21(10).left = 100
        .Text23(9).Top = 700
        .Text23(9).left = 1070
        .Text23(9).Width = TextWidth
        .Text23(9).Height = 200
        .Label21(8).Top = 1120
        .Label21(8).left = 100
        .Text23(7).Top = 1100
        .Text23(7).left = 1070
        .Text23(7).Width = TextWidth
        .Text23(7).Height = 200
        .Label21(9).Top = 720
        .Label21(9).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(8).Top = 700
        .Text23(8).left = QuarterFrame - TextWidth - FullLeft
        .Text23(8).Width = TextWidth
        .Text23(8).Height = 200
        .Label21(11).Top = 1120
        .Label21(11).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(10).Top = 1100
        .Text23(10).left = QuarterFrame - TextWidth - FullLeft
        .Text23(10).Width = TextWidth
        .Text23(10).Height = 200
        .Frame21(0).Top = 1920
        .Frame21(0).left = HalfLeft
        .Frame21(0).Width = QuarterFrame
        .Frame21(0).Height = 1520
        .Label21(3).Top = 320
        .Label21(3).left = 100
        .Text23(2).Top = 300
        .Text23(2).left = QuarterFrame - TextWidth - FullLeft
        .Text23(2).Width = TextWidth
        .Text23(2).Height = 200
        .Label21(4).Top = 720
        .Label21(4).left = 100
        .Text23(3).Top = 700
        .Text23(3).left = QuarterFrame - TextWidth - FullLeft
        .Text23(3).Width = TextWidth
        .Text23(3).Height = 200
        .Label21(5).Top = 1120
        .Label21(5).left = 100
        .Text23(4).Top = 1100
        .Text23(4).left = QuarterFrame - TextWidth - FullLeft
        .Text23(4).Width = TextWidth
        .Text23(4).Height = 200
        .Frame20.Top = 3800
        .Frame20.left = 100
        .Frame20.Width = FullFrame
        .Frame20.Height = 750
        .Label21(1).Top = 320
        .Label21(1).left = 100
        .Text23(0).Top = 300
        .Text23(0).left = TextLeft
        .Text23(0).Width = TextWidth
        .Text23(0).Height = 200
        .Label21(2).Top = 320
        .Label21(2).left = HalfLeft
        .Text23(1).Top = 300
        .Text23(1).left = 6200
        .Text23(1).Width = TextWidth
        .Text23(1).Height = 200
        'Reticulate .options
        .Combo1.Top = 200
        .Combo1.left = 100
        .Combo1.Width = 2800
        .Combo1.AddItem "Compaibility matrix (IJ)"
        .Combo1.AddItem "Modularity matrix"
        .Combo1.AddItem "Recombination matrix"
        .Combo1.AddItem "Recombinant region count matrix"
        .Combo1.AddItem "Breakpoint matrix"
        .Combo1.AddItem "Breakpoint distribution plot"
        
       
        .Combo1.ListIndex = 0
        .Frame25(0).Top = .Combo1.Top + .Combo1.Height + 10
        .Frame25(0).left = 100
        .Frame25(0).Width = FullFrame
        
        .Label1(17).Top = 320
        .Label1(17).left = 100
        .Command28(15).Top = 280
        .Command28(15).left = ButtonLeft
        
        .Label1(22).Top = 640
        .Label1(22).left = 100
        .Combo2.Top = 600
        .Combo2.left = .Command28(15).left - (.Combo2.Width - .Command28(15).Width)
        
        .Label1(26).Top = 960
        .Label1(26).left = 100
        .Text5(0).Top = 920
        .Text5(0).left = .Command28(15).left - (.Text5(0).Width - .Command28(15).Width)
        
        .Label1(57).Top = 1280
        .Label1(57).left = 100
        .Text5(1).Top = 1240
        .Text5(1).left = .Command28(15).left - (.Text5(1).Width - .Command28(15).Width)
        
        .Label1(58).Top = 1600
        .Label1(58).left = 100
        .Picture1.Height = .Text5(1).Height
        .Picture1.Width = .Combo2.Width - .Command28(15).Width
        .Picture1.left = .Combo2.left
        .Picture1.Top = 1560
        
        .Command28(19).left = .Command28(15).left
        .Command28(19).Width = .Command28(15).Width
        .Command28(19).Height = .Command28(15).Height
        .Command28(19).Top = 1560
        .Frame25(0).Height = .Picture1.Top + 420
       
        'Distance plot .options
        .Frame24(0).Top = 200
        .Frame24(0).left = 100
        .Frame24(0).Width = HalfFrame
        .Frame24(0).Height = 1100
        .Label1(18).Top = 320
        .Label1(18).left = 100
        .Text1(13).Top = 300
        .Text1(13).left = TextLeft
        .Text1(13).Width = TextWidth
        .Text1(13).Height = 200
        .Label1(19).Top = 720
        .Label1(19).left = 100
        .Text1(14).Top = 700
        .Text1(14).left = TextLeft
        .Text1(14).Width = TextWidth
        .Text1(14).Height = 200
        .Frame24(1).Top = 1300
        .Frame24(1).left = 100
        .Frame24(1).Width = HalfFrame
        .Frame24(1).Height = 3120
        .Label1(21).Top = 320
        .Label1(21).left = 100
        .Command28(18).Top = 280
        .Command28(18).left = ButtonLeft
        .Label1(20).Top = 720
        .Label1(20).left = 100
        .Text1(15).Top = 700
        .Text1(15).left = TextLeft
        .Text1(15).Width = TextWidth
        .Text1(15).Height = 200
        .Label1(40).Top = 1120
        .Label1(40).left = 100
        .Text1(29).Top = 1100
        .Text1(29).left = TextLeft
        .Text1(29).Width = TextWidth
        .Text1(29).Height = 200
        .Frame21(3).Top = 1500
        .Frame21(3).left = 100
        .Frame21(3).Width = QuarterFrame
        .Frame21(3).Height = 1520
        .Label21(20).Top = 320
        .Label21(20).left = 100
        .Command28(17).Top = 280
        .Command28(17).left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(22).Top = 720
        .Label21(22).left = 100
        .Text23(19).Top = 700
        .Text23(19).left = 1020
        .Text23(19).Width = TextWidth
        .Text23(19).Height = 200
        .Label21(23).Top = 1120
        .Label21(23).left = 100
        .Text23(20).Top = 1100
        .Text23(20).left = 1020
        .Text23(20).Width = TextWidth
        .Text23(20).Height = 200
        .Label21(24).Top = 720
        .Label21(24).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(21).Top = 700
        .Text23(21).left = QuarterFrame - TextWidth - FullLeft
        .Text23(21).Width = TextWidth
        .Text23(21).Height = 200
        .Label21(21).Top = 1120
        .Label21(21).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(18).Top = 1100
        .Text23(18).left = QuarterFrame - TextWidth - FullLeft
        .Text23(18).Width = TextWidth
        .Text23(18).Height = 200
        'TOPAL .options
        .Frame24(3).Top = 200
        .Frame24(3).left = 100
        .Frame24(3).Width = HalfFrame
        .Frame24(3).Height = 1500
        .Label1(30).Top = 320
        .Label1(30).left = 100
        .Text1(22).Top = 300
        .Text1(22).left = TextLeft
        .Text1(22).Width = TextWidth
        .Text1(22).Height = 200
        .Label1(29).Top = 720
        .Label1(29).left = 100
        .Text1(19).Top = 700
        .Text1(19).left = TextLeft
        .Text1(19).Width = TextWidth
        .Text1(19).Height = 200
        .Label1(31).Top = 1120
        .Label1(31).left = 100
        .Text1(23).Top = 1100
        .Text1(23).left = TextLeft
        .Text1(23).Width = TextWidth
        .Text1(23).Height = 200
        .Frame24(2).Top = 200
        .Frame24(2).left = HalfLeft
        .Frame24(2).Width = HalfFrame
        .Frame24(2).Height = 3120
        .Label1(25).Top = 320
        .Label1(25).left = 100
        .Command28(21).Top = 280
        .Command28(21).left = ButtonLeft
        .Label1(28).Top = 720
        .Label1(28).left = 100
        .Text1(16).Top = 700
        .Text1(16).left = TextLeft
        .Text1(16).Width = TextWidth
        .Text1(16).Height = 200
        .Label1(41).Top = 1120
        .Label1(41).left = 100
        .Text1(30).Top = 1100
        .Text1(30).left = TextLeft
        .Text1(30).Width = TextWidth
        .Text1(30).Height = 200
        .Frame21(4).Top = 1500
        .Frame21(4).left = 100
        .Frame21(4).Width = QuarterFrame
        .Frame21(4).Height = 1520
        .Label21(29).Top = 320
        .Label21(29).left = 100
        .Command28(20).Top = 280
        .Command28(20).left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(27).Top = 720
        .Label21(27).left = 100
        .Text23(24).Top = 700
        .Text23(24).left = 1020
        .Text23(24).Width = TextWidth
        .Text23(24).Height = 200
        .Label21(26).Top = 1120
        .Label21(26).left = 100
        .Text23(23).Top = 1100
        .Text23(23).left = 1020
        .Text23(23).Width = TextWidth
        .Text23(23).Height = 200
        .Label21(25).Top = 720
        .Label21(25).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(22).Top = 700
        .Text23(22).left = QuarterFrame - TextWidth - FullLeft
        .Text23(22).Width = TextWidth
        .Text23(22).Height = 200
        .Label21(28).Top = 1120
        .Label21(28).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(25).Top = 1100
        .Text23(25).left = QuarterFrame - TextWidth - FullLeft
        .Text23(25).Width = TextWidth
        .Text23(25).Height = 200
        .Frame24(4).Top = 1800
        .Frame24(4).left = 100
        .Frame24(4).Width = HalfFrame
        .Frame24(4).Height = 1500
        .Label1(34).Top = 320
        .Label1(34).left = 100
        .Command28(22).Top = 280
        .Command28(22).left = ButtonLeft
        .Label1(33).Top = 720
        .Label1(33).left = 100
        .Text1(25).Top = 700
        .Text1(25).left = TextLeft
        .Text1(25).Width = TextWidth
        .Text1(25).Height = 200
        .Label1(32).Top = 1120
        .Label1(32).left = 100
        .Text1(26).Top = 1100
        .Text1(26).left = TextLeft
        .Text1(26).Width = TextWidth
        .Text1(26).Height = 200
        .Frame24(5).Top = 3400
        .Frame24(5).left = 100
        .Frame24(5).Width = HalfFrame
        .Frame24(5).Height = 1100
        .Label1(36).Top = 320
        .Label1(36).left = 100
        .Text1(27).Top = 300
        .Text1(27).left = TextLeft
        .Text1(27).Width = TextWidth
        .Text1(27).Height = 200
        .Label1(35).Top = 720
        .Label1(35).left = 100
        .Text1(24).Top = 700
        .Text1(24).left = TextLeft
        .Text1(24).Width = TextWidth
        .Text1(24).Height = 200
        'Tree .options
        .Frame6(0).Top = 150
        .Frame6(0).left = 100
        .Frame6(0).Width = HalfFrame
        .Frame6(0).Height = 1100
        .Label1(45).Top = 320
        .Label1(45).left = 100
        .Text1(33).Top = 300
        .Text1(33).left = TextLeft
        .Text1(33).Width = TextWidth
        .Text1(33).Height = 200
        .Label1(46).Top = 720
        .Label1(46).left = 100
        .Text1(34).Top = 700
        .Text1(34).left = TextLeft
        .Text1(34).Width = TextWidth
        .Text1(34).Height = 200
        .Frame6(1).Top = 1400 '150
        .Frame6(1).left = 100 'halfleft
        .Frame6(1).Width = HalfFrame
        .Frame6(1).Height = 2300
        .Label1(47).Top = 320
        .Label1(47).left = 100
        .Text1(35).Top = 300
        .Text1(35).left = TextLeft
        .Text1(35).Width = TextWidth
        .Text1(35).Height = 200
        .Label1(49).Top = 720
        .Label1(49).left = 100
        .Command28(29).Top = 700
        .Command28(29).left = ButtonLeft
        .Label1(50).Top = 1120
        .Label1(50).left = 100
        .Command28(30).Top = 1100
        .Command28(30).left = ButtonLeft
        .Label1(51).Top = 1520
        .Label1(51).left = 100
        .Command28(31).Top = 1500
        .Command28(31).left = ButtonLeft
        .Label1(52).Top = 1920
        .Label1(52).left = 100
        .Command28(32).Top = 1900
        .Command28(32).left = ButtonLeft
        .Frame7(1).Top = 150 '2250
        .Frame7(1).left = HalfLeft '100
        .Frame7(1).Width = HalfFrame
        .Frame7(1).Height = 3075
        .Label1(44).Top = 320
        .Label1(44).left = 100
        .Command28(27).Top = 300
        .Command28(27).left = ButtonLeft
        .Label1(43).Top = 720
        .Label1(43).left = 100
        .Text1(32).Top = 700
        .Text1(32).left = TextLeft
        .Text1(32).Width = TextWidth
        .Text1(32).Height = 200
        .Label1(42).Top = 1120
        .Label1(42).left = 100
        .Text1(31).Top = 1100
        .Text1(31).left = TextLeft
        .Text1(31).Width = TextWidth
        .Text1(31).Height = 200
        .Frame21(6).Top = 1500
        .Frame21(6).left = 100
        .Frame21(6).Width = QuarterFrame
        .Frame21(6).Height = 1475
        .Label21(35).Top = 320
        .Label21(35).left = 100
        .Command28(26).Top = 300
        .Command28(26).left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(37).Top = 720
        .Label21(37).left = 100
        .Text23(31).Top = 700
        .Text23(31).left = 1000
        .Text23(31).Width = TextWidth
        .Text23(31).Height = 200
        .Label21(39).Top = 1120
        .Label21(39).left = 100
        .Text23(33).Top = 1100
        .Text23(33).left = 1000
        .Text23(33).Width = TextWidth
        .Text23(33).Height = 200
        .Label21(38).Top = 720
        .Label21(38).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(32).Top = 700
        .Text23(32).left = QuarterFrame - TextWidth - FullLeft
        .Text23(32).Width = TextWidth
        .Text23(32).Height = 200
        .Label21(36).Top = 1120
        .Label21(36).left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(30).Top = 1100
        .Text23(30).left = QuarterFrame - TextWidth - FullLeft
        .Text23(30).Width = TextWidth
        .Text23(30).Height = 200
        'OK and Cancel Buttons
        .Command11.Top = 5450
        .Command11.left = 2750
        .Command11.Width = 1000
        .Command11.Height = 350
        .Command6.Top = 5450
        .Command6.left = 3800
        .Command6.Width = 1000
        .Command6.Height = 350
        .Command4.Top = 5450
        .Command4.left = 4850
        .Command4.Width = 1000
        .Command4.Height = 350
    End With

End Sub

Public Sub ResizeForm2()
    Form1.ScaleMode = 1

    With Form2
        .ScaleMode = 1
        .Top = 0
        Form2OHeight = Form1OHeight
        Form2OWidth = 2 * Form1.SSPanel6(1).Width + 12 * Screen.TwipsPerPixelX
        .ScaleWidth = Form1.SSPanel6(1).Width + 12 * Screen.TwipsPerPixelX
        .ScaleMode = 1
        .Height = Form1OHeight
        .SSPanel1(0).left = 0 '4 * Screen.TwipsPerPixelX
        .SSPanel1(0).Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1(0).Height = (.ScaleHeight - Form1.SSPanel7.Height - 8 * Screen.TwipsPerPixelY)
        .SSPanel1(0).Width = Form1.SSPanel6(1).Width
        .SSPanel1(1).left = 0
        .SSPanel1(1).Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1(1).Height = .SSPanel1(0).Height
        .SSPanel1(1).Width = Form1.SSPanel6(1).Width
        .SSPanel1(2).left = .SSPanel1(0).left + .SSPanel1(0).Width + 4 * Screen.TwipsPerPixelX '4 * Screen.TwipsPerPixelX
        .SSPanel1(2).Top = .SSPanel1(1).Top
        .SSPanel1(2).Height = .SSPanel1(0).Height
        .SSPanel1(2).Width = Form1.SSPanel6(1).Width
        .SSPanel1(2).ZOrder
        .SSPanel1(3).left = .SSPanel1(0).left + .SSPanel1(0).Width + 4 * Screen.TwipsPerPixelX
        .SSPanel1(3).Top = .SSPanel1(1).Top
        .SSPanel1(3).Height = .SSPanel1(0).Height
        .SSPanel1(3).Width = Form1.SSPanel6(1).Width

        Dim X As Integer

        For X = 0 To 3
            .Command1(X).Height = Form1.Command1.Height
            .Command1(X).Width = Form1.Command1.Height
            .Command1(X).Top = 4 * Screen.TwipsPerPixelY
            .Command1(X).left = .SSPanel1(0).Width - .Command1(X).Width - 4 * Screen.TwipsPerPixelX
        Next 'X

        For X = 0 To 3
            .Label1(X).left = 4 * Screen.TwipsPerPixelX
            .Label1(X).Width = .Command1(0).left - 4 * Screen.TwipsPerPixelX
            .Label1(X).Height = Form1.Command1.Height
            .Label1(X).Top = 7 * Screen.TwipsPerPixelY
        Next 'X

        For X = 0 To 3
            .Picture2(X).left = 4 * Screen.TwipsPerPixelY
            .Picture2(X).Width = Form1.Picture16.Width
            .Picture2(X).Top = .Label1(X).Top + .Label1(X).Height + 4 * Screen.TwipsPerPixelX
            .Picture2(X).Height = .SSPanel1(0).Height - .Picture2(X).Top - 4 * Screen.TwipsPerPixelX
            .Picture2(X).ScaleMode = 3
            '.Picture2(X).Top = 0
            '.Picture2(X).Left = 0
            '.Picture2(X).Height = Form1.Picture16.Height
            '.Picture2(X).Width = 3400 * HAddjust
            .VScroll1(X).left = Form1.VScroll1.left
            .VScroll1(X).Width = 12 * Screen.TwipsPerPixelX
            .VScroll1(X).Height = .Picture2(X).Height
            .VScroll1(X).Top = .Picture2(X).Top
            .VScroll1(X).Max = -.Picture2(X).ScaleHeight + (NextNo + 6) * 15
            .VScroll1(X).LargeChange = .Picture2(X).ScaleHeight
        Next 'X

        .SSPanel2.left = 0
        .SSPanel2.Top = Form1.SSPanel7.Top
        .SSPanel2.Height = Form1.SSPanel7.Height
        .SSPanel2.Width = .ScaleWidth
        .SSPanel3.Top = Form1.SSPanel1.Top
        .SSPanel3.left = Form1.SSPanel1.left
        .SSPanel3.Width = Form1.SSPanel1.Width
        .SSPanel3.Height = Form1.SSPanel1.Height
        .Command2.Height = .SSPanel3.Height
        .Command2.Top = .SSPanel3.Top
        .Command2.Width = 900 * HAddjust
        .Command2.left = .SSPanel2.Width - .Command2.Width - 30 * HAddjust
        
        .Command5.Height = .SSPanel3.Height
        .Command5.Top = .SSPanel3.Top
        .Command5.Width = .Command1(0).Width
        .Command5.left = .Command2.left - .Command5.Width
        
        .Command4.Height = .SSPanel3.Height
        .Command4.Top = .SSPanel3.Top
        .Command4.Width = .Command1(0).Width
        .Command4.left = .Command5.left - .Command4.Width
        
        .SSPanel4.left = .SSPanel3.left + .SSPanel3.Width + 30 * HAddjust
        .SSPanel4.Top = .SSPanel3.Top
        .SSPanel4.Height = .SSPanel3.Height
        .SSPanel4.Width = .SSPanel2.Width - .SSPanel4.left - 30 * HAddjust - .Command2.Width - .Command4.Width - .Command5.Width
        
        .ProgressBar1.Height = .SSPanel4.Height - 60 * VAddjust
        .ProgressBar1.Top = 30 * VAddjust
        .ProgressBar1.left = 30 * HAddjust
        .ProgressBar1.Width = .SSPanel4.Width - 60 * HAddjust
    End With

End Sub
Public Sub OrderBreakPoints()
'Exit Sub
Dim Eventnumber As Long, BEP As Long, BeP2 As Long, ENP As Long, ENP2 As Long, OF As Byte, OF2 As Byte, Ma2 As Long, Mi2 As Long, LenXOver As Long, BE As Long, EN As Long, Be2 As Long, En2 As Long, GroupEvents() As Long, BackEventsA() As Long, BackEventsB() As Long

ReDim GroupEvents(NextNo, XOverListSize)
'ReDim BackEventsA( oRecombNo(100) )
'ReDim BackEventsB( oRecombNo(100) )

Form1.SSPanel1.Caption = "Finding Unique Events"
Eventnumber = 0
'Group Events
For X = 0 To NextNo
    For Y = 1 To CurrentXover(X)
        If GroupEvents(X, Y) = 0 Then
            Eventnumber = Eventnumber + 1
            GroupEvents(X, Y) = Eventnumber
            BE = XOverList(X, Y).Beginning
            EN = XOverList(X, Y).Ending
            'Mi = XOverList(X, Y).MinorP
            
            If BE > EN Then EN = Len(StrainSeq(0)) + EN
            ENP = EN
            BEP = BE
            LenXOver = EN - BE
            EN = EN - LenXOver / 4
            BE = BE + LenXOver / 4
            For Z = Y + 1 To CurrentXover(X)
                If GroupEvents(X, Z) = 0 Then
                            Be2 = XOverList(X, Z).Beginning
                            En2 = XOverList(X, Z).Ending
                            If Be2 < En2 Then
                                If EN > Len(StrainSeq(0)) Then
                                    Be2 = Be2 + Len(StrainSeq(0))
                                    En2 = En2 + Len(StrainSeq(0))
                                End If
                            Else
                                If EN > Len(StrainSeq(0)) Then
                                    En2 = En2 + Len(StrainSeq(0))
                                Else
                                    Be2 = Be2 - Len(StrainSeq(0))
                                End If
                            End If
                            LenXOver = En2 - Be2
                            ENP2 = En2
                            BeP2 = Be2
                            En2 = En2 - LenXOver / 4
                            Be2 = Be2 + LenXOver / 4
                            If (Be2 < EN And En2 > BE) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                                'add check for parentals etc.
                                GroupEvents(X, Z) = Eventnumber
                            End If
                    End If
                    
                Next Z
           
        End If
    Next Y
    Form1.ProgressBar1.Value = ((X / NextNo) * 0.2) * 100
Next X

Dim Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long

ReDim EventTraceA(Eventnumber, oRecombNo(100) + oRecombNo(1))
ReDim EventTraceB(Eventnumber, oRecombNo(100) + oRecombNo(1))
ReDim EventPos(Eventnumber)
Dim EventBegin() As Long, EventEnd() As Long
'ReDim EventBegin(EventNumber)
'ReDim EventEnd(EventNumber)

For X = 0 To NextNo
    For Y = 1 To CurrentXover(X)
        Eventholder = GroupEvents(X, Y)
        EventPos(Eventholder) = EventPos(Eventholder) + 1
        EventTraceA(Eventholder, EventPos(Eventholder)) = X
        EventTraceB(Eventholder, EventPos(Eventholder)) = Y
    Next Y
Next X

'Group events for different sequences

For X = 1 To Eventnumber
    For B = 1 To EventPos(X)
        BE = XOverList(EventTraceA(X, B), EventTraceB(X, B)).Beginning
        EN = XOverList(EventTraceA(X, B), EventTraceB(X, B)).Ending
        
        Mi = XOverList(EventTraceA(X, B), EventTraceB(X, B)).MinorP
        Ma = XOverList(EventTraceA(X, B), EventTraceB(X, B)).MajorP
        OF = XOverList(EventTraceA(X, B), EventTraceB(X, B)).OutsideFlag
        If BE > EN Then EN = Len(StrainSeq(0)) + EN
                
        LenXOver = EN - BE
        BEP = BE
        ENP = EN
        EN = EN - LenXOver / 4
        BE = BE + LenXOver / 4
        For Y = X + 1 To Eventnumber
            For A = 1 To EventPos(Y)
                Be2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).Beginning
                En2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).Ending
                Mi2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).MinorP
                Ma2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).MajorP
                OF2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).OutsideFlag
                
                If Be2 < En2 Then
                    If EN > Len(StrainSeq(0)) Then
                        Be2 = Be2 + Len(StrainSeq(0))
                        En2 = En2 + Len(StrainSeq(0))
                    End If
                Else
                    If EN > Len(StrainSeq(0)) Then
                        En2 = En2 + Len(StrainSeq(0))
                    Else
                        Be2 = Be2 - Len(StrainSeq(0))
                    End If
                End If
                LenXOver = En2 - Be2
                BeP2 = Be2
                ENP2 = En2
                En2 = En2 - LenXOver / 4
                Be2 = Be2 + LenXOver / 4
                If Be2 < EN And En2 > BE Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                    'Now check for parentals etc.
                    If (Mi = Mi2 And OF2 <> 2 And OF <> 2) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                        For Z = 1 To EventPos(Y)
                            EventPos(X) = EventPos(X) + 1
                            EventTraceA(X, EventPos(X)) = EventTraceA(Y, Z)
                            EventTraceB(X, EventPos(X)) = EventTraceB(Y, Z)
                            GroupEvents(EventTraceA(X, EventPos(X)), EventTraceB(X, EventPos(X))) = GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) ' = X
                            GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) = 0
                            EventTraceA(Y, Z) = 0
                            EventTraceB(Y, Z) = 0
                            
                            
                        Next Z
                        A = EventPos(Y)
                            EventPos(Y) = 0
                            Y = Eventnumber
                        
                    End If
                End If
            Next A
        Next Y
    Next B
    Form1.ProgressBar1.Value = 20 + ((X / Eventnumber) * 0.2) * 100
    T = GetTickCount
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = "Sorting  " & X & " of " & Eventnumber & " Events"
    End If
Next X

Dim HiScore As Double, WinPar As Long, MiC2 As Long, NumScore As Long, MaScore As Long, MiScore As Long, BPosScoreMa() As Double, BPosScoreMi() As Double, Mac As Long, MiC As Long, DC As Long, DoneSeqArray() As Long, MaPArray() As Long, MiPArray() As Long, DArray() As Long
Dim OLFlag As Byte, SC As Double, MC As Double, NB As Long, NE As Long, MinB As Long, MaxB As Long, MinE As Long, MaxE As Long
Dim NJSubDistance() As Double
ReDim NJSubDistance(NextNo, NextNo)
'Dim MaMiDist() As Double '
'Dim MiDDist() As Double
'Dim MaDDist() As Double
Dim MinDist() As Double
Dim MaxDist() As Double
For X = 1 To Eventnumber
    If EventPos(X) > 0 Then
        ReDim DoneSeqArray(NextNo + 1)
        ReDim MaPArray(EventPos(X))
        ReDim MiPArray(EventPos(X))
        ReDim DArray(EventPos(X))
        ReDim MinDist(NextNo)
        ReDim MaxDist(NextNo)
        For Z = 0 To NextNo
            MinDist(Z) = 100
        Next Z
        'ReDim mamidist(EventPos(X))
        'ReDim MiDDist(EventPos(X))
        'ReDim MaDDist(EventPos(X))
        Mac = 0
        MiC = 0
        DC = 0
        OLFlag = 0
        MaxB = -Len(StrainSeq(0))
        MinB = 2 * Len(StrainSeq(0))
        MaxE = -Len(StrainSeq(0))
        MinE = 2 * Len(StrainSeq(0))
        For B = 1 To EventPos(X)
           RelX = EventTraceA(X, B)
           RelY = EventTraceB(X, B)
           Ma = XOverList(RelX, RelY).MajorP
           Mi = XOverList(RelX, RelY).MinorP
           D = XOverList(RelX, RelY).Daughter
           BE = XOverList(RelX, RelY).Beginning
           EN = XOverList(RelX, RelY).Ending
           OF = XOverList(RelX, RelY).OutsideFlag
           
           If BE > EN Then
                OLFlag = 1
                EN = Len(StrainSeq(0)) + EN
           Else
                If MaxE > Len(StrainSeq(0)) Then
                    BE = BE + Len(StrainSeq(0))
                    EN = EN + Len(StrainSeq(0))
                End If
           End If
           
           
            If MaxE < EN Then MaxE = EN
            If MinE > EN Then MinE = EN
            If MinB > BE Then MinB = BE
            If MaxB < BE Then MaxB = BE
            
            If Ma <= NextNo And Mi <= NextNo Then
                Dummy = DistanceCalcE(Ma, NextNo, Len(StrainSeq(0)) + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                Dummy = DistanceCalcE(Mi, NextNo, Len(StrainSeq(0)) + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                 If NJSubDistance(Ma, D) > MaxDist(Ma) Then MaxDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) > MaxDist(Mi) Then MaxDist(Mi) = NJSubDistance(Mi, D)
                 If NJSubDistance(Ma, D) < MinDist(Ma) Then MinDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) < MinDist(Mi) Then MinDist(Mi) = NJSubDistance(Mi, D)
                'MaMiDist(B) = NJSubDistance(Ma, Mi)
                'MaDDist(B) = NJSubDistance(Ma, D)
                'MiDDist(B) = NJSubDistance(Mi, D)
                If NJSubDistance(Mi, D) > NJSubDistance(Ma, D) And NJSubDistance(Mi, D) > NJSubDistance(Ma, Mi) And Distance(Ma, D) > Distance(Mi, D) And Distance(Ma, D) > Distance(Mi, Ma) Or OF > 0 Then
                    If DoneSeqArray(Ma) = 0 And OF <> 1 Then
                             DoneSeqArray(Ma) = 1
                             Mac = Mac + 1
                             MaPArray(Mac) = Ma
                             'MaDDist(MaC) = MaDDist(B)
                             
                     End If
                     If DoneSeqArray(Mi) = 0 And OF <> 2 Then
                             DoneSeqArray(Mi) = 1
                             MiC = MiC + 1
                             MiPArray(MiC) = Mi
                             'MiDDist(MiC) = MiDDist(B)
                     End If
                     If DoneSeqArray(D) = 0 Then
                         DoneSeqArray(D) = 1
                         DC = DC + 1
                         DArray(DC) = D
                     End If
               '      For Z = 1 To MaC
               '         If MaPArray(Z) = Ma And MaDDist(Z) < MaDDist(B) Then
               '             MaDDist(Z) = MaDDist(B)
               '             Exit For
               '         End If
               '      Next Z
               '      For Z = 1 To MiC
               '         If MiPArray(Z) = Mi And MiDDist(Z) < MiDDist(B) Then
               '             MiDDist(Z) = MiDDist(B)
               '             Exit For
               '         End If
               '      Next Z
                End If
            End If
        Next B
        'Weed out any obviously sub-optimal parentals/daughters
       MiC2 = 0
       'Find minor parent with the hi score
       HiScore = 0
       WinPar = -1
       For B = 1 To MiC
            If MaxDist(MiPArray(B)) >= HiScore Then
                HiScore = MaxDist(MiPArray(B))
                WinPar = MiPArray(B)
            End If
       Next B
       For B = 1 To MiC
                    If MaxDist(MiPArray(B)) > MinDist(WinPar) Then
                        MiC2 = MiC2 + 1
                        MiPArray(MiC2) = MiPArray(B)
                    End If
        Next B
        If MiC <> MiC2 Then
            MiC = MiC2
        End If
        'Now find the best breakpoint to explain all the data
       
        Pos = 0
        If MiC > 0 And Mac > 0 Then
            If MaxB > MinE Then
                
                MidP = Int((MaxB - MinE) / 2)
                MaxB = MaxB - MidP
                MinE = MaxB + 1
                'MaxB = MinE - 1
            End If
            If MaxB < MinB Then MinB = MaxB
            If MinE > MaxE Then MaxE = MinE
            If MinB <> MaxB Then
                If MinB > MaxB Then
                
                    MaxB = Len(StrainSeq(0)) + MaxB
                
                End If
                ReDim BPosScoreMa(MaxB - MinB)
                ReDim BPosScoreMi(MaxB - MinB)
                    For Y = MinB To MaxB
                        If Y > Len(StrainSeq(0)) Then
                            PosN = Y - Len(StrainSeq(0))
                        Else
                            PosN = Y
                        End If
                        NumScore = 0
                        For A = 1 To Mac
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                    Else
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                        End If
                        NumScore = 0
                        For A = 1 To MiC
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                    Else
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                        End If
                        Pos = Pos + 1
                    Next Y
                    NB = MaxB
                    SC = 0
                    MC = -Len(StrainSeq(0)) * 2
                    For Y = MaxB To MinB Step -1
                       
                        If BPosScoreMi(Y - MinB) <> BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) <> 0 And BPosScoreMa(Y - MinB) <> 0 Then
                            SC = SC + (BPosScoreMi(Y - MinB) - BPosScoreMa(Y - MinB))
                            If SC >= MC Then
                                MC = SC
                                 If Y > Len(StrainSeq(0)) Then
                                    NB = Y - Len(StrainSeq(0))
                                Else
                                    NB = Y
                                End If
                            End If
                        End If
                        'If BPosScoreMi(Y - MinB) > BPosScoreMa(Y - MinB) Then
                        '    NB = Y
                       ' ElseIf BPosScoreMi(Y - MinB) < BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) < 0 Then
                       '     Exit For
                       ' End If
                    Next Y
               
               
                'If MC > 0 Then
                    For B = 1 To EventPos(X)
                        If NB > Len(StrainSeq(0)) Then NB = NB - Len(StrainSeq(0))
                        RelX = EventTraceA(X, B)
                        RelY = EventTraceB(X, B)
                        XOverList(RelX, RelY).Beginning = NB
                        
                    Next B
                'End If
            End If
            Pos = 0
            ReDim BPosScoreMa(MaxE - MinE)
            ReDim BPosScoreMi(MaxE - MinE)
            If MinE <> MaxE Then
                If MinE > MaxE Then
                    MaxE = Len(StrainSeq(0)) + MaxE
                End If
                For Y = MinE To MaxE
                    If Y > Len(StrainSeq(0)) Then
                        PosN = Y - Len(StrainSeq(0))
                    Else
                        PosN = Y
                    End If
                    NumScore = 0
                    For A = 1 To Mac
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                Else
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                    End If
                    NumScore = 0
                    For A = 1 To MiC
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                Else
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                    End If
                    Pos = Pos + 1
                Next Y
                NE = MinE
                SC = 0
                MC = -Len(StrainSeq(0)) * 2
                For Y = MinE To MaxE
                    
                    If BPosScoreMi(Y - MinE) <> BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) <> 0 And BPosScoreMa(Y - MinE) <> 0 Then
                        SC = SC + (BPosScoreMi(Y - MinE) - BPosScoreMa(Y - MinE))
                        If SC >= MC Then
                            
                            MC = SC
                            If Y > Len(StrainSeq(0)) Then
                                NE = Y - Len(StrainSeq(0))
                            Else
                                NE = Y
                            End If
                        End If
                    End If
                    'If BPosScoreMi(Y - MinE) > BPosScoreMa(Y - MinE) Then
                    '    NE = Y
                   ' ElseIf BPosScoreMi(Y - MinE) < BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) < 0 Then
                    '    Exit For
                   ' End If
                Next Y
                If NE > Len(StrainSeq(0)) Then
                    NE = NE - Len(StrainSeq(0))
                End If
                'If MC > 0 Then
                    For B = 1 To EventPos(X)
                        RelX = EventTraceA(X, B)
                        RelY = EventTraceB(X, B)
                        XOverList(RelX, RelY).Ending = NE
                    Next B
                'End If
            End If
        
        End If
    End If
    Form1.ProgressBar1.Value = 40 + ((X / Eventnumber) * 0.6) * 100
    T = GetTickCount
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = X * 2 & " of " & Eventnumber * 2 & " Breakpoints Adjusted"
    End If
Next X

End Sub
Public Sub OrderBreakPointsII()
'Exit Sub
'(1)Find order in which events occured.  Basically which branches of tree involved and
'take the root of those branches - maybe use recombination free tree to find ordering.
'(2)Work from the latest event back to the earliest and progressively mask events.
'(3)masking will prevent "mixed" events and will remove sequences (or at elast bits of them)
'from consideration when determining breakpoints.
'(4)Mask could include an event identifier
'(5)work from oldest to newest events and capture all sequences displaying evidence of these events
'if masking was done properly it will be possible to decide which sequences still (or at least should)
'have bits of evidence from overlapped events

Dim Eventnumber As Long, BEP As Long, BeP2 As Long, ENP As Long, ENP2 As Long, OF As Byte, OF2 As Byte, Ma2 As Long, Mi2 As Long, LenXOver As Long, BE As Long, EN As Long, Be2 As Long, En2 As Long, GroupEvents() As Long, BackEventsA() As Long, BackEventsB() As Long

ReDim GroupEvents(NextNo, XOverListSize)
'ReDim BackEventsA( oRecombNo(100) )
'ReDim BackEventsB( oRecombNo(100) )

Form1.SSPanel1.Caption = "Finding Unique Events"
Eventnumber = 0
'Group Events
For X = 0 To NextNo
    For Y = 1 To CurrentXover(X)
        If GroupEvents(X, Y) = 0 Then
            Eventnumber = Eventnumber + 1
            GroupEvents(X, Y) = Eventnumber
            BE = XOverList(X, Y).Beginning
            EN = XOverList(X, Y).Ending
            'Mi = XOverList(X, Y).MinorP
            
            If BE > EN Then EN = Len(StrainSeq(0)) + EN
            ENP = EN
            BEP = BE
            LenXOver = EN - BE
            EN = EN - LenXOver / 4
            BE = BE + LenXOver / 4
            For Z = Y + 1 To CurrentXover(X)
                If GroupEvents(X, Z) = 0 Then
                            Be2 = XOverList(X, Z).Beginning
                            En2 = XOverList(X, Z).Ending
                            If Be2 < En2 Then
                                If EN > Len(StrainSeq(0)) Then
                                    Be2 = Be2 + Len(StrainSeq(0))
                                    En2 = En2 + Len(StrainSeq(0))
                                End If
                            Else
                                If EN > Len(StrainSeq(0)) Then
                                    En2 = En2 + Len(StrainSeq(0))
                                Else
                                    Be2 = Be2 - Len(StrainSeq(0))
                                End If
                            End If
                            LenXOver = En2 - Be2
                            ENP2 = En2
                            BeP2 = Be2
                            En2 = En2 - LenXOver / 4
                            Be2 = Be2 + LenXOver / 4
                            If (Be2 < EN And En2 > BE) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                                'add check for parentals etc.
                                GroupEvents(X, Z) = Eventnumber
                            End If
                    End If
                    
                Next Z
           
        End If
    Next Y
    Form1.ProgressBar1.Value = ((X / NextNo) * 0.2) * 100
Next X

Dim Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long

ReDim EventTraceA(Eventnumber, oRecombNo(100))
ReDim EventTraceB(Eventnumber, oRecombNo(100))
ReDim EventPos(Eventnumber)
Dim EventBegin() As Long
Dim EventEnd() As Long
'ReDim EventBegin(EventNumber)
'ReDim EventEnd(EventNumber)

For X = 0 To NextNo
    For Y = 1 To CurrentXover(X)
        Eventholder = GroupEvents(X, Y)
        EventPos(Eventholder) = EventPos(Eventholder) + 1
        EventTraceA(Eventholder, EventPos(Eventholder)) = X
        EventTraceB(Eventholder, EventPos(Eventholder)) = Y
    Next Y
Next X

'Group events for different sequences

For X = 1 To Eventnumber
    For B = 1 To EventPos(X)
        BE = XOverList(EventTraceA(X, B), EventTraceB(X, B)).Beginning
        EN = XOverList(EventTraceA(X, B), EventTraceB(X, B)).Ending
        
        Mi = XOverList(EventTraceA(X, B), EventTraceB(X, B)).MinorP
        Ma = XOverList(EventTraceA(X, B), EventTraceB(X, B)).MajorP
        OF = XOverList(EventTraceA(X, B), EventTraceB(X, B)).OutsideFlag
        If BE > EN Then EN = Len(StrainSeq(0)) + EN
                
        LenXOver = EN - BE
        BEP = BE
        ENP = EN
        EN = EN - LenXOver / 4
        BE = BE + LenXOver / 4
        For Y = X + 1 To Eventnumber
            For A = 1 To EventPos(Y)
                Be2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).Beginning
                En2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).Ending
                Mi2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).MinorP
                Ma2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).MajorP
                OF2 = XOverList(EventTraceA(Y, A), EventTraceB(Y, A)).OutsideFlag
                
                If Be2 < En2 Then
                    If EN > Len(StrainSeq(0)) Then
                        Be2 = Be2 + Len(StrainSeq(0))
                        En2 = En2 + Len(StrainSeq(0))
                    End If
                Else
                    If EN > Len(StrainSeq(0)) Then
                        En2 = En2 + Len(StrainSeq(0))
                    Else
                        Be2 = Be2 - Len(StrainSeq(0))
                    End If
                End If
                LenXOver = En2 - Be2
                BeP2 = Be2
                ENP2 = En2
                En2 = En2 - LenXOver / 4
                Be2 = Be2 + LenXOver / 4
                If Be2 < EN And En2 > BE Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                    'Now check for parentals etc.
                    If (Mi = Mi2 And OF2 <> 2 And OF <> 2) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                        For Z = 1 To EventPos(Y)
                            EventPos(X) = EventPos(X) + 1
                            EventTraceA(X, EventPos(X)) = EventTraceA(Y, Z)
                            EventTraceB(X, EventPos(X)) = EventTraceB(Y, Z)
                            GroupEvents(EventTraceA(X, EventPos(X)), EventTraceB(X, EventPos(X))) = GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) ' = X
                            GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) = 0
                            EventTraceA(Y, Z) = 0
                            EventTraceB(Y, Z) = 0
                            
                            
                        Next Z
                        A = EventPos(Y)
                            EventPos(Y) = 0
                            Y = Eventnumber
                        
                    End If
                End If
            Next A
        Next Y
    Next B
    Form1.ProgressBar1.Value = 20 + ((X / Eventnumber) * 0.2) * 100
    T = GetTickCount
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = "Sorting  " & X & " of " & Eventnumber & " Events"
    End If
Next X

Dim HiScore As Double, WinPar As Long, MiC2 As Long, NumScore As Long, MaScore As Long, MiScore As Long, BPosScoreMa() As Double, BPosScoreMi() As Double, Mac As Long, MiC As Long, DC As Long, DoneSeqArray() As Long, MaPArray() As Long, MiPArray() As Long, DArray() As Long
Dim OLFlag As Byte, SC As Double, MC As Double, NB As Long, NE As Long, MinB As Long, MaxB As Long, MinE As Long, MaxE As Long
Dim NJSubDistance() As Double
ReDim NJSubDistance(NextNo, NextNo)
'Dim MaMiDist() As Double '
'Dim MiDDist() As Double
'Dim MaDDist() As Double
Dim MinDist() As Double
Dim MaxDist() As Double
For X = 1 To Eventnumber
    If EventPos(X) > 0 Then
        ReDim DoneSeqArray(NextNo + 1)
        ReDim MaPArray(EventPos(X))
        ReDim MiPArray(EventPos(X))
        ReDim DArray(EventPos(X))
        ReDim MinDist(NextNo)
        ReDim MaxDist(NextNo)
        For Z = 0 To NextNo
            MinDist(Z) = 100
        Next Z
        'ReDim mamidist(EventPos(X))
        'ReDim MiDDist(EventPos(X))
        'ReDim MaDDist(EventPos(X))
        Mac = 0
        MiC = 0
        DC = 0
        OLFlag = 0
        MaxB = -Len(StrainSeq(0))
        MinB = 2 * Len(StrainSeq(0))
        MaxE = -Len(StrainSeq(0))
        MinE = 2 * Len(StrainSeq(0))
        For B = 1 To EventPos(X)
           RelX = EventTraceA(X, B)
           RelY = EventTraceB(X, B)
           Ma = XOverList(RelX, RelY).MajorP
           Mi = XOverList(RelX, RelY).MinorP
           D = XOverList(RelX, RelY).Daughter
           BE = XOverList(RelX, RelY).Beginning
           EN = XOverList(RelX, RelY).Ending
           OF = XOverList(RelX, RelY).OutsideFlag
           
           If BE > EN Then
                OLFlag = 1
                EN = Len(StrainSeq(0)) + EN
           Else
                If MaxE > Len(StrainSeq(0)) Then
                    BE = BE + Len(StrainSeq(0))
                    EN = EN + Len(StrainSeq(0))
                End If
           End If
           
           
            If MaxE < EN Then MaxE = EN
            If MinE > EN Then MinE = EN
            If MinB > BE Then MinB = BE
            If MaxB < BE Then MaxB = BE
            
            If Ma <= NextNo And Mi <= NextNo Then
                Dummy = DistanceCalcE(Ma, NextNo, Len(StrainSeq(0)) + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                Dummy = DistanceCalcE(Mi, NextNo, Len(StrainSeq(0)) + 1, XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                 If NJSubDistance(Ma, D) > MaxDist(Ma) Then MaxDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) > MaxDist(Mi) Then MaxDist(Mi) = NJSubDistance(Mi, D)
                 If NJSubDistance(Ma, D) < MinDist(Ma) Then MinDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) < MinDist(Mi) Then MinDist(Mi) = NJSubDistance(Mi, D)
                'MaMiDist(B) = NJSubDistance(Ma, Mi)
                'MaDDist(B) = NJSubDistance(Ma, D)
                'MiDDist(B) = NJSubDistance(Mi, D)
                If NJSubDistance(Mi, D) > NJSubDistance(Ma, D) And NJSubDistance(Mi, D) > NJSubDistance(Ma, Mi) And Distance(Ma, D) > Distance(Mi, D) And Distance(Ma, D) > Distance(Mi, Ma) Or OF > 0 Then
                    If DoneSeqArray(Ma) = 0 And OF <> 1 Then
                             DoneSeqArray(Ma) = 1
                             Mac = Mac + 1
                             MaPArray(Mac) = Ma
                             'MaDDist(MaC) = MaDDist(B)
                             
                     End If
                     If DoneSeqArray(Mi) = 0 And OF <> 2 Then
                             DoneSeqArray(Mi) = 1
                             MiC = MiC + 1
                             MiPArray(MiC) = Mi
                             'MiDDist(MiC) = MiDDist(B)
                     End If
                     If DoneSeqArray(D) = 0 Then
                         DoneSeqArray(D) = 1
                         DC = DC + 1
                         DArray(DC) = D
                     End If
               '      For Z = 1 To MaC
               '         If MaPArray(Z) = Ma And MaDDist(Z) < MaDDist(B) Then
               '             MaDDist(Z) = MaDDist(B)
               '             Exit For
               '         End If
               '      Next Z
               '      For Z = 1 To MiC
               '         If MiPArray(Z) = Mi And MiDDist(Z) < MiDDist(B) Then
               '             MiDDist(Z) = MiDDist(B)
               '             Exit For
               '         End If
               '      Next Z
                End If
            End If
        Next B
        'Weed out any obviously sub-optimal parentals/daughters
       MiC2 = 0
       'Find minor parent with the hi score
       HiScore = 0
       WinPar = -1
       For B = 1 To MiC
            If MaxDist(MiPArray(B)) >= HiScore Then
                HiScore = MaxDist(MiPArray(B))
                WinPar = MiPArray(B)
            End If
       Next B
       For B = 1 To MiC
                    If MaxDist(MiPArray(B)) > MinDist(WinPar) Then
                        MiC2 = MiC2 + 1
                        MiPArray(MiC2) = MiPArray(B)
                    End If
        Next B
        If MiC <> MiC2 Then
            MiC = MiC2
        End If
        'Now find the best breakpoint to explain all the data
       
        Pos = 0
        If MiC > 0 And Mac > 0 Then
            If MaxB > MinE Then
                
                MidP = Int((MaxB - MinE) / 2)
                MaxB = MaxB - MidP
                MinE = MaxB + 1
                'MaxB = MinE - 1
            End If
            If MaxB < MinB Then MinB = MaxB
            If MinE > MaxE Then MaxE = MinE
            If MinB <> MaxB Then
                If MinB > MaxB Then
                
                    MaxB = Len(StrainSeq(0)) + MaxB
                
                End If
                ReDim BPosScoreMa(MaxB - MinB)
                ReDim BPosScoreMi(MaxB - MinB)
                    For Y = MinB To MaxB
                        If Y > Len(StrainSeq(0)) Then
                            PosN = Y - Len(StrainSeq(0))
                        Else
                            PosN = Y
                        End If
                        NumScore = 0
                        For A = 1 To Mac
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                    Else
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                        End If
                        NumScore = 0
                        For A = 1 To MiC
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                    Else
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                        End If
                        Pos = Pos + 1
                    Next Y
                    NB = MaxB
                    SC = 0
                    MC = -Len(StrainSeq(0)) * 2
                    For Y = MaxB To MinB Step -1
                       
                        If BPosScoreMi(Y - MinB) <> BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) <> 0 And BPosScoreMa(Y - MinB) <> 0 Then
                            SC = SC + (BPosScoreMi(Y - MinB) - BPosScoreMa(Y - MinB))
                            If SC >= MC Then
                                MC = SC
                                 If Y > Len(StrainSeq(0)) Then
                                    NB = Y - Len(StrainSeq(0))
                                Else
                                    NB = Y
                                End If
                            End If
                        End If
                        'If BPosScoreMi(Y - MinB) > BPosScoreMa(Y - MinB) Then
                        '    NB = Y
                       ' ElseIf BPosScoreMi(Y - MinB) < BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) < 0 Then
                       '     Exit For
                       ' End If
                    Next Y
               
               
                'If MC > 0 Then
                    For B = 1 To EventPos(X)
                        If NB > Len(StrainSeq(0)) Then NB = NB - Len(StrainSeq(0))
                        RelX = EventTraceA(X, B)
                        RelY = EventTraceB(X, B)
                        XOverList(RelX, RelY).Beginning = NB
                        
                    Next B
                'End If
            End If
            Pos = 0
            ReDim BPosScoreMa(MaxE - MinE)
            ReDim BPosScoreMi(MaxE - MinE)
            If MinE <> MaxE Then
                If MinE > MaxE Then
                    MaxE = Len(StrainSeq(0)) + MaxE
                End If
                For Y = MinE To MaxE
                    If Y > Len(StrainSeq(0)) Then
                        PosN = Y - Len(StrainSeq(0))
                    Else
                        PosN = Y
                    End If
                    NumScore = 0
                    For A = 1 To Mac
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                Else
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                    End If
                    NumScore = 0
                    For A = 1 To MiC
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                Else
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                    End If
                    Pos = Pos + 1
                Next Y
                NE = MinE
                SC = 0
                MC = -Len(StrainSeq(0)) * 2
                For Y = MinE To MaxE
                    
                    If BPosScoreMi(Y - MinE) <> BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) <> 0 And BPosScoreMa(Y - MinE) <> 0 Then
                        SC = SC + (BPosScoreMi(Y - MinE) - BPosScoreMa(Y - MinE))
                        If SC >= MC Then
                            
                            MC = SC
                            If Y > Len(StrainSeq(0)) Then
                                NE = Y - Len(StrainSeq(0))
                            Else
                                NE = Y
                            End If
                        End If
                    End If
                    'If BPosScoreMi(Y - MinE) > BPosScoreMa(Y - MinE) Then
                    '    NE = Y
                   ' ElseIf BPosScoreMi(Y - MinE) < BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) < 0 Then
                    '    Exit For
                   ' End If
                Next Y
                If NE > Len(StrainSeq(0)) Then
                    NE = NE - Len(StrainSeq(0))
                End If
                'If MC > 0 Then
                    For B = 1 To EventPos(X)
                        RelX = EventTraceA(X, B)
                        RelY = EventTraceB(X, B)
                        XOverList(RelX, RelY).Ending = NE
                    Next B
                'End If
            End If
        
        End If
    End If
    Form1.ProgressBar1.Value = 40 + ((X / Eventnumber) * 0.6) * 100
    T = GetTickCount
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = X * 2 & " of " & Eventnumber * 2 & " Breakpoints Adjusted"
    End If
Next X

End Sub
Public Sub BenchMark()
Exit Sub
    Dim Counter As Double
    Dim CString As String

    BMark = 0
    CString = String$(10000, "A")
    BB = GetTickCount

    Do
        BMark = BMark + 1
        Counter = Counter + 786467
        Counter = Counter * 10
        Counter = Counter / 10
        Counter = Counter ^ 2
        Counter = Sqr(Counter)
        Counter = Counter - 786467
        CString = left$(CString, 9000)
        CString = right$(CString, 8000)
        CString = Mid$(CString, 2000, 5000)
        CString = CString + CString
        EE = GetTickCount

        If (EE - BB) > 1000 Then Exit Do
    Loop

    RelSpeed = BMark / 1200
End Sub
Public Sub ScanBSPlots(CycleCount As Long, FindAllFlag As Byte)
     Dim OverlapNum As Integer, GoOnFlag As Integer
    Dim HiSeqs(2, 2) As Long
    Dim AD As Long, AMi As Long, AMa As Long, EN As Long, BE As Long, PPVal As Double, PVal As Double, FirstFull As Long, LastFull As Long, Z As Long, DA As Long, Mi As Long, Ma As Long, YE As Long
    Dim TotalProb As Double, MedHomol As Double, LowHomol As Double, HighHomol As Double
    Dim TS As Integer, ProbCounter As Integer
    Dim S1 As Long, S2 As Long, S3 As Long, SeqLen As Long, PosCount As Long, CurPos As Long, Y As Long, X As Long
    Dim OActive As Integer
    Dim OMajP As Integer, OMinP As Integer
    
    
    SeqLen = Len(StrainSeq(0))
    'Work out which sequences are most likely to share a recombinant region
    
    YE = (SeqLen - BSStepWin) / BSStepSize
    'I have to be very careful here - if this routine is accessed via bsxoverr then
    'I must use submasks for everything.  If it is accessed through bsxovers then I must
    'use the unprocessed seq numbers
    
    If SEventNumber = 0 Then
        S1 = SubMaskSeq(Seq1): S2 = SubMaskSeq(Seq2): S3 = SubMaskSeq(Seq3)
    Else
        S1 = Seq1: S2 = Seq2: S3 = Seq3
    End If
    
    AvHomol(0) = Distance(S1, S2)
    AvHomol(1) = Distance(S1, S3)
    AvHomol(2) = Distance(S2, S3)
    
    If AvHomol(0) = AvHomol(1) And AvHomol(0) = AvHomol(2) Then

        If Distance(S1, S2) > Distance(S1, S3) And Distance(S1, S2) > Distance(S2, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01

            If Distance(S1, S3) > Distance(S2, S3) Then
                AvHomol(2) = AvHomol(2) - 0.01
            Else
                AvHomol(1) = AvHomol(1) - 0.01
            End If

        ElseIf Distance(S1, S3) > Distance(S1, S2) And Distance(S1, S3) > Distance(S2, S3) Then
            AvHomol(1) = AvHomol(1) + 0.01

            If Distance(S1, S2) > Distance(S2, S3) Then
                AvHomol(2) = AvHomol(2) - 0.01
            Else
                AvHomol(0) = AvHomol(0) - 0.01
            End If

        ElseIf Distance(S1, S3) > Distance(S1, S3) And Distance(S2, S3) > Distance(S1, S2) Then
            AvHomol(2) = AvHomol(2) + 0.01

            If Distance(S1, S2) > Distance(S1, S3) Then
                AvHomol(1) = AvHomol(1) - 0.01
            Else
                AvHomol(0) = AvHomol(0) - 0.01
            End If

        End If

    ElseIf AvHomol(0) = AvHomol(1) Then

        If Distance(S1, S2) > Distance(S1, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01
        Else
            AvHomol(1) = AvHomol(1) + 0.01
        End If

    ElseIf AvHomol(0) = AvHomol(2) Then

        If Distance(S1, S2) > Distance(S2, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01
        Else
            AvHomol(2) = AvHomol(2) + 0.01
        End If

    ElseIf AvHomol(1) = AvHomol(2) Then

        If Distance(S1, S3) > Distance(S2, S3) Then
            AvHomol(1) = AvHomol(1) + 0.01
        Else
            AvHomol(2) = AvHomol(2) + 0.01
        End If

    End If

    If AvHomol(0) >= AvHomol(1) And AvHomol(0) >= AvHomol(2) Then
        HighHomol = 0
        If AvHomol(1) > AvHomol(2) Then
            MedHomol = 1: LowHomol = 2: ActiveSeq = S1: ActiveMajorP = S2: ActiveMinorP = S3
        Else
            MedHomol = 2: LowHomol = 1: ActiveSeq = S2: ActiveMajorP = S1: ActiveMinorP = S3
        End If

    ElseIf AvHomol(1) >= AvHomol(0) And AvHomol(1) >= AvHomol(2) Then
        HighHomol = 1
        If AvHomol(0) > AvHomol(2) Then
            MedHomol = 0: LowHomol = 2: ActiveSeq = S1: ActiveMajorP = S3: ActiveMinorP = S2
        Else
            MedHomol = 2: LowHomol = 0: ActiveSeq = S3: ActiveMajorP = S1: ActiveMinorP = S2
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(0) Then
        HighHomol = 2
        If AvHomol(0) > AvHomol(1) Then
            MedHomol = 0: LowHomol = 1: ActiveSeq = S2: ActiveMajorP = S3: ActiveMinorP = S1
        Else
            MedHomol = 1: LowHomol = 0: ActiveSeq = S3: ActiveMajorP = S2: ActiveMinorP = S1
        End If

        
    End If

    If ShowPlotFlag = 1 Then
        s1col = Yellow: s2col = Green: s3col = Purple: s1colb = mYellow: s2colb = LGreen: s3colb = LPurple
        Call DrawBSPlotsII
        Call WriteNames(S1, S2, S3, Yellow, Green, Purple)
        Form1.Frame17.Visible = False
    End If
    
    If FindAllFlag = 0 Then
        PosCount = GoOnA(CycleCount)
    Else
        ReDim GoOnA(0), GoOnB(0)
        PosCount = 1
        CycleCount = 0
        GoOnA(0) = 1
        GoOnB(0) = UBound(PltVal, 2) - 1
    End If
    
    
    'Exit Sub
    

    OverlapNum = (BSStepWin / BSStepSize)
   

    For Y = (BSStepWin + BSStepSize * GoOnA(CycleCount)) To (BSStepWin + BSStepSize * GoOnB(CycleCount)) Step BSStepSize
            PVal = 100000000
            
            If PltVal(MedHomol, PosCount) >= BSCutOff * BSBootReps Then
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, MedHomol, HighHomol, LowHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            ElseIf PltVal(LowHomol, PosCount) >= BSCutOff * BSBootReps Then 'This is the other possibility
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, LowHomol, HighHomol, MedHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            ElseIf PltVal(HighHomol, PosCount) >= BSCutOff * BSBootReps Then  'This is the third possibility
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, HighHomol, MedHomol, LowHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            End If
            
            If (BSPValFlag = 0 And PVal < (1 - BSCutOff)) Or (BSPValFlag > 0 And PVal > 0 And PVal < LowestProb) Then
                'Keep track of signal numbers
                oRecombNo(100) = oRecombNo(100) + 1
                oRecombNo(2) = oRecombNo(2) + 1
                If CurrentXover(S1) <= CurrentXover(S2) And CurrentXover(S1) <= CurrentXover(S3) Then
                    AD = S1: AMi = S2: AMa = S3
                ElseIf CurrentXover(S2) <= CurrentXover(S1) And CurrentXover(S2) <= CurrentXover(S3) Then
                    AD = S2: AMi = S1: AMa = S3
                Else
                    AD = S3: AMi = S1: AMa = S2
                End If
                
                If SEventNumber > 0 Then
                    splitx = 0
                    
                    Z = CheckSplit(Len(StrainSeq(0)), BE, EN, S1, S2, S3, splitx, MissingData(0, 0))
                
                End If
                
                If APermFlag = 0 Then
                    Call UpdateXOList3(AD, CurrentXover(), XOverList(), 2, PVal, SIP)
                Else
                    SIP = 1
                End If
                
                
                If SIP > 0 Then
                
                    XOverList(AD, SIP).Daughter = AD
                    XOverList(AD, SIP).MajorP = AMi
                    XOverList(AD, SIP).MinorP = AMa
                    XOverList(AD, SIP).Beginning = BE
                    XOverList(AD, SIP).Ending = EN
                    XOverList(AD, SIP).ProgramFlag = 2
                    XOverList(AD, SIP).Probability = PVal
                    XOverList(AD, SIP).PermPVal = PPVal
                    Call FixEnds(BWarn, EWarn, MissingData(), XOverList(), AD, SIP)
                    Call CentreBP(XOverList(AD, SIP).Beginning, XOverList(AD, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, 10, LenXOverSeq)
                    
                    If ShortOutFlag = 1 Then
                        ShortOutput(2) = 1
                        AbortFlag = 1
                        Exit Sub
                    End If
                    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        StartPlt(2) = 1
                        Call UpdatePlotB(AD, AMa, AMi, SIP)
                                            
                    End If
                End If
                
            End If
        
            PosCount = PosCount + 1
        
            If PosCount > UBound(PltVal, 2) Then Exit For
    Next ' Y

End Sub

Public Sub BSXoverR()

    SS = Abs(GetTickCount)
    Dim Largest As Double, Smallest As Double, S1 As Long, S2 As Long, S3 As Long
    Dim Modification As Double, DoneThis() As Byte, NumDone() As Double, MidNode() As Double, TallyDist As Double, MaxCurPos As Long, TB(1) As Long, MD As Double, oRec As Long, B As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    Dim OrderArray() As Byte
    Dim T0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long
    ReDim DstOut(BSBootReps - 1)
    'Start the timer
    StartT = Abs(GetTickCount)
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    
    
    'Dim NTree As Tree
    
    'Dim SubGrpMaskseq() As Byte
    ReDim MidNode(2)
    'ReDim SubMaskSeq(NextNo + 1), SubGrpMaskseq(NextNo + 1)
    ReDim RevSeq(NextNo)
    'If IndividualB <> -1 Then
    
    If IndividualA <> -1 Then
        NumberOfSeqs = 0
        For X = 0 To NextNo
            If MaskSeq(X) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = X
                RevSeq(X) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
            End If
        Next 'X

        NumberOfSeqs = NumberOfSeqs - 1
        ReDim tSeqNum(Len(StrainSeq(0)), NumberOfSeqs)
        For X = 0 To NumberOfSeqs
            For Y = 1 To Len(StrainSeq(0))
                tSeqNum(Y, X) = SeqNum(Y, SubMaskSeq(X))
            Next Y
        Next X
    Else
        'If sequences have been disabled/masked
        NumberOfSeqs = 0

        For X = 0 To NextNo

            If MaskSeq(X) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = X
                RevSeq(X) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
                X = X
            End If

        Next 'X

        NumberOfSeqs = NumberOfSeqs - 1
        ReDim tSeqNum(Len(StrainSeq(0)), NumberOfSeqs)
        For X = 0 To NumberOfSeqs
            For Y = 1 To Len(StrainSeq(0))
                tSeqNum(Y, X) = SeqNum(Y, SubMaskSeq(X))
            Next Y
        Next X
    End If
    
    NameLen = Len(Trim$(CStr(NumberOfSeqs)))
    If NameLen < 2 Then NameLen = 2
    
    SZE = CLng((NumberOfSeqs * (NumberOfSeqs + 1) * (NumberOfSeqs - 1)) / 6)
    ReDim OrderArray(SZE)
    
    ReDim GoOnA(SZE)
    ReDim GoOnB(SZE)
    Cnt = 0
    For Seq1 = 0 To NumberOfSeqs - 2
        For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
            For Seq3 = Seq2 + 1 To NumberOfSeqs
                If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                    OrderArray(Cnt) = 0
                ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                    OrderArray(Cnt) = 1
                ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) Then
                    OrderArray(Cnt) = 2
                End If
                Cnt = Cnt + 1
            Next
        Next
    Next
    
    On Error Resume Next
    Kill "BSScanData"
    Kill "BSfile2"
    On Error GoTo 0
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(BSStepWin)
    ReDim Prod2(BSStepWin)
    ReDim Prod3(BSStepWin)
    ReDim Alias(BSStepWin)
    ReDim Ally(BSStepWin)
    ReDim Location(BSStepWin)
    ReDim Px(NumberOfSeqs, BSStepWin)
    ReDim ttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    ReDim DistVal(BSBootReps + 1)
    ReDim Num1(BSBootReps + 1)
    ReDim Num2(BSBootReps + 1)
    ReDim DEN(BSBootReps + 1)
    ReDim Num(BSBootReps + 1)
    ReDim WeightMod(BSBootReps, BSStepWin - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim Scratch(BSStepWin)
    'Do
        Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
       
    'Loop
    COffCount = (1 - BSCutOff) * BSBootReps
    
    
    Rnd (-BSRndNumSeed)

    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    ReDim BSFilePos(NextNo, NextNo)
    ReDim PltPos(NumWins + 1)
    'Work out nt positions at the center of every window

    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    MaxCurPos = NumberOfSeqs * 3
    FF = FreeFile
    Open "BSScanData" For Binary As #FF
    

    ReDim bttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim NodeLen(MaxCurPos)
    ReDim TempNodeOrder(MaxCurPos)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    
    'Work out file read/write parameters
    Cnt = 0
    For X = 0 To NumberOfSeqs
        For Y = X + 1 To NumberOfSeqs
            BSFilePos(SubMaskSeq(X), SubMaskSeq(Y)) = Cnt
            BSFilePos(SubMaskSeq(Y), SubMaskSeq(X)) = Cnt
            Cnt = Cnt + 1
        Next 'Y
    Next 'X
    BSRWSize = BSBootReps * 2
    BSRSize = BSRWSize * (NumWins + 1)
    BSWinRWChunk = BSRWSize * (NumberOfSeqs + 1) * (NumberOfSeqs) / 2
    GlobalMemoryStatus MemSit
    BufferSize = MemSit.dwTotalPhys / 16
    BSRWBuffer = CLng(BufferSize / BSWinRWChunk)
    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
    FCNT = 0
    Dim ValidX() As Double, DiffsX() As Double
    For B = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), B, BSStepSize, BSStepWin, ttSeqNum(0, 0), tSeqNum(0, 0)
        If BSSubModelFlag <> 3 Then
            
            If BSSubModelFlag = 0 Then
                ReDim ValidX(BSBootReps), DiffsX(BSBootReps), DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
                Dummy = FastBootDist(0, BSBootReps, NumberOfSeqs, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), ttSeqNum(0, 0), DstMat(0, 0, 0))
            Else
                ReDim Weight(BSBootReps, BSStepWin)
                
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, NumberOfSeqs + 1, BSStepWin, ttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), Num(0), WeightMod(0, 0)
            End If
        Else

            For X = 0 To BSBootReps - 1
                
                If X > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(X, Z)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                bttSeqNum(SP, Y) = ttSeqNum(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To NumberOfSeqs
                            bttSeqNum(Z, Y) = ttSeqNum(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, NumberOfSeqs + 1, BSStepWin, bttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To NumberOfSeqs - 1

                    For Z = Y + 1 To NumberOfSeqs
                        DstMat(X, Y, Z) = tMat(Y, Z)
                        DstMat(X, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

            Next 'X

        End If
        
        If BSTypeFlag > 0 Then
            
            For X = 0 To BSBootReps - 1
               If B = 41 Then
                    X = X
                End If
                Dim Hi As Double, Hi2 As Double
                Dim AbBe() As Byte
                ReDim AbBe(MaxCurPos)
                GoOn = 0
                Hi = 0
                Hi2 = 0
                For Y = 0 To NumberOfSeqs
                    For Z = 0 To NumberOfSeqs
                        tMat(Y, Z) = DstMat(X, Y, Z)
                        If DstMat(X, Y, Z) > 0 Then
                            If Hi = 0 Then
                                Hi = DstMat(X, Y, Z)
                            ElseIf Hi2 = 0 And DstMat(X, Y, Z) <> Hi Then
                                Hi2 = DstMat(X, Y, Z)
                                If Hi <> DstMat(X, Y, Z) Then
                                    GoOn = 1
                                End If
                            ElseIf Hi > 0 And Hi2 > 0 And DstMat(X, Y, Z) <> Hi And DstMat(X, Y, Z) <> Hi2 Then
                                
                                    GoOn = 1
                                
                            End If
                        End If
                    Next 'Z

                Next 'Y
                
                ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                If GoOn = 1 Then
                    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
                    ReDim ColTotals(NumberOfSeqs)
                    Dim TreeArray() As Double
                    ReDim TreeArray(NumberOfSeqs, NumberOfSeqs)
                    LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 2, NumberOfSeqs + 1, tMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
                    
                    LTree = LTree + 1
                    
                    
                    ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                    Call Tree2Array(NameLen, NumberOfSeqs, LTree, SHolder(), TMat2())
                        
                     
                End If
                    
                
                'find largest and smallest distances and then standardise so that they fall between 32000 and 0
                Smallest = 1000
                Largest = -1000
                For Seq1 = 0 To NumberOfSeqs - 1
    
                    For Seq2 = Seq1 + 1 To NumberOfSeqs
                        If TMat2(Seq1, Seq2) < Smallest Then
                            
                            Smallest = TMat2(Seq1, Seq2)
                        ElseIf TMat2(Seq1, Seq2) > Largest Then
                            Largest = TMat2(Seq1, Seq2)
                        End If
                        
                    Next 'Seq2
    
                Next 'Seq1
                
                
                If (Largest - Smallest) > 0 Then
                    Modification = 1 / (Largest - Smallest)
                Else
                    Modification = 0
                End If
                If Modification > 0 Then
                
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            'TMat2(Seq1, Seq2) = (TMat2(Seq1, Seq2) - Smallest) * Modification
                            'If TMat2(Seq1, Seq2) < 0.000032 Then TMat2(Seq1, Seq2) = 0
                            DstMat(X, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(X, Seq2, Seq1) = DstMat(X, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                Else
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            DstMat(X, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(X, Seq2, Seq1) = DstMat(X, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                
                End If

            
            Next 'X

        End If
        Cnt = 0
        For X = 0 To NumberOfSeqs - 1
            For Y = X + 1 To NumberOfSeqs
                    'this coluld be speeded up with better nesting of if then's

                Dummy = ScanPositive(B, BSCutOff, COffCount, X, Y, NumberOfSeqs, BSBootReps, GoOnA(Cnt), GoOnB(Cnt), OrderArray(Cnt), DstMat(0, 0, 0))
                DubToInt X, Y, BSBootReps, NumberOfSeqs, DstMat(0, 0, 0), BSFileBuffer(FCNT) 'DstOut(0)
                FCNT = FCNT + BSBootReps
                If FCNT >= BSRWBuffer * BSWinRWChunk - BSBootReps Then
                    ReDim Preserve BSFileBuffer(FCNT - 1)
                    Put #FF, , BSFileBuffer()
                    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
                    FCNT = 0
                End If
                Cnt = Cnt + Dummy
            Next 'Y
        Next 'X
       
        
        'Update progress indicaters
        
        BSEnd = Abs(GetTickCount())
        If Abs(BSEnd - LastT) > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
            LastT = BSEnd
            Hold = ((B + 1) * 0.6) / (NumWins + 1)
            With Form1
                .ProgressBar1 = (B / NumWins) * 60
                .SSPanel1.Caption = B & " of " & NumWins & " windows examined"
                .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - StartT) / Hold) - Abs(BSEnd - StartT))) & " remaining"
                .Label66(0).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart)))
                .Label57(0).Caption = DoTimeII(Abs(BSEnd - Abs(ST)))
                DoEvents
            End With
            
            If AbortFlag = 1 Then
                Close #FF
                ChDir ODir
                ChDrive ODir
                Exit Sub
            End If
        End If
        'Erase DstMat
    Next 'B
    
    ReDim Preserve BSFileBuffer(FCNT - 1)
    Put #FF, , BSFileBuffer()
    MD = MD
    'Close #FF
    
    Erase DstMat
    Erase bttSeqNum
    Erase tMat
    Erase SHolder
    Erase NodeLen
    Erase TempNodeOrder
    Erase Weight
    Erase NodeOrder
    Erase DoneNode
    Erase RootNode
    Erase TMat2
    
  
    Erase Prod1
    Erase Prod2
    Erase Prod3
    Erase Alias
    Erase Ally
    Erase Location
    Erase Px
    Erase ttSeqNum
    Erase DistVal
    Erase Num1
    Erase Num2
    Erase DEN
    Erase Num
    Erase WeightMod
    Erase OrderArray
    Erase BSFileBuffer
    Dim FF2 As Long, ReadNo As Long
    ReadNo = (BSRWBuffer * BSWinRWChunk) / (2 * BSBootReps * (NumWins))
    'ReadNo = 2
    ReDim BSFileBuffer(BSBootReps * (NumWins) * ReadNo - 1)
    Dim PosA As Long, SortArray() As Integer
    ReDim SortArray(BSBootReps * ReadNo)
    S1 = 0
    S2 = 1
    Pos = 1
    'PosA = 0
    Dim NumPairs As Long
    NumPairs = NumberOfSeqs * (NumberOfSeqs + 1) / 2
    
    ' On Error Resume Next
    'For X = 500 To 2000
    '
    '
    '    Close #X
    '
    'Next X
    'On Error GoTo 0
    
    'For X = 10 To 500
   '
   '
   '     Close #X
   '
   ' Next X
    
    'If AbortFlag = 1 Then
        
    'End If
    
    FF2 = FreeFile
    'for x =
    BSFileName = "BSfile2"
    Open BSFileName For Binary As #FF2
    
    SPos = 1
    For X = 1 To NumPairs Step ReadNo
            Pos = SPos
            For Y = 0 To NumWins - 1
                PosA = 0
               Get #FF, Pos, SortArray()
                PosA = ReSortArray(Y, NumWins, PosA, ReadNo, BSBootReps, BSFileBuffer(0), SortArray(0))
                Pos = Pos + BSWinRWChunk
                
            Next Y
            
            BSEnd = Abs(GetTickCount()) 'Take the time
            If BSEnd - LastT > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
                LastT = BSEnd
                If AbortFlag = 1 Then
                        Close #FF
                        Close #FF2
                        ChDir ODir
                        ChDrive ODir
                        Exit Sub
                End If
                                
                'Write progress to the screen
                                
                With Form1
                                    '.ProgressBar1 = 60 + (B / MCCorrection) * 40
                                    .SSPanel1.Caption = X & " of " & NumPairs & " pairs sorted"
                                   '.SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - StartT) / Hold) - (BSEnd - StartT))) & " remaining"
                                    '.Label66(1).Caption = cstr(TotalBSRecombinants)
                                    '.Label57(1).Caption = cstr( oRecombNo(100) )
                                    .Label66(0).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                    .Label57(0).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                    DoEvents
                End With
            
            End If
            SPos = SPos + ReadNo * BSBootReps * 2
            
            Put #FF2, , BSFileBuffer()
    Next X
Close #FF
On Error Resume Next
Kill "BSScandata"
On Error GoTo 0
Erase SortArray
Erase BSFileBuffer
'Close #FF2
'Exit Sub
StartT = Abs(GetTickCount)
    SS = Abs(GetTickCount)

    'Open "BSScandata" For Binary Access Read As #FF Len = BSBootReps
    
    ReDim T0(BSBootReps * (NumWins + 1) - 1)
    ReDim T1(BSBootReps * (NumWins + 1) - 1)
    ReDim T2(BSBootReps * (NumWins + 1) - 1)
    Dim OverlapNumB As Integer
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim PltVal(2, NumWins)
    OverlapNumB = (BSStepWin / BSStepSize)
    B = 0
    If IndividualB <> -1 Then
        Seq1 = RevSeq(IndividualA)
            Seq2 = RevSeq(IndividualB)
                'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                                        
                        For Seq3 = 0 To NumberOfSeqs
                            
                            If SelGrpFlag = 1 Then
                                If GrpMaskSeq(Seq1) = 0 And GrpMaskSeq(Seq2) = 0 And GrpMaskSeq(Seq3) = 0 Then
                                    Exit Sub
                                End If
                            End If
                            
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 And Seq3 <> Seq2 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                           
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                 Next 'Y
                                           Else
                                                For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           TSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            S2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), S1, S2, S3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
                                            'Call FindSubSeqBS
                                           
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                B = B + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount()) 'Take the time
                                If Abs(BSEnd - LastT) > 500 Then ' Give an update on progress every half second
                                    LastT = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        Close #FF
                                        Close #FF2
                                        ChDir ODir
                                        ChDrive ODir
                                        Exit Sub
                                    End If
                                    
                                    Hold = B / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        If 60 + (B / MCCorrection) * 40 <= 100 Then
                                            .ProgressBar1 = 60 + (B / MCCorrection) * 40
                                            .SSPanel1.Caption = B & " of " & MCCorrection & " triplets examined"
                                            .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - StartT) / Hold) - Abs(BSEnd - StartT))) & " remaining"
                                        End If
                                        UpdateRecNums (SEventNumber)
                                        .Label66(0).Caption = DoTimeII(Abs(BSEnd - BSStart)) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label57(0).Caption = DoTimeII(Abs(BSEnd - ST)) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        DoEvents
                                    End With
                
                                End If
                            End If
                        Next 'Seq3
                    
    ElseIf IndividualA <> -1 Then
        Seq1 = RevSeq(IndividualA)
                For Seq2 = 0 To NumberOfSeqs - 1
                    If Seq2 <> Seq1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                        
                        For Seq3 = Seq2 + 1 To NumberOfSeqs
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                           
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                 Next 'Y
                                           Else
                                                For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           TSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            S2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), S1, S2, S3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
                                            
                                           ' Call FindSubSeqBS
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                B = B + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount()) 'Take the time
                                If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                    LastT = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        Close #FF
                                        Close #FF2
                                        ChDir ODir
                                        ChDrive ODir
                                        Exit Sub
                                    End If
                                    
                                    Hold = B / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        .ProgressBar1 = 60 + (B / MCCorrection) * 40
                                        .SSPanel1.Caption = B & " of " & MCCorrection & " triplets examined"
                                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - StartT) / Hold) - (BSEnd - StartT))) & " remaining"
                                        UpdateRecNums (SEventNumber)
                                        .Label66(0).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label57(0).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        DoEvents
                                    End With
                
                                End If
                            End If
                        Next 'Seq3
                    End If
                Next 'Seq2

    Else
        For Seq1 = 0 To NumberOfSeqs - 2
            'If MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
                    'If Then
                        
                        For Seq3 = Seq2 + 1 To NumberOfSeqs
                            If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                
                                If GoOnA(TotalCycles) > 0 Then
                                    GoOnA(TotalCycles) = 1
                                    GoOnB(TotalCycles) = NumWins
                                    If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                           
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                 Next 'Y
                                           Else
                                                For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's
                                                        For F = 0 To BSBootReps
                                                            XX = T0(F)
                                                        Next F
                                                      GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      'GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                                                Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           TSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            S2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), S1, S2, S3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
                                            'Call FindSubSeqBS
                                           ' zz = 0
                                           'For X = 0 To Len(StrainSeq(0))
                                           '     zz = zz + Scores(X, 2)
                                           'Next X
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                B = B + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount()) 'Take the time
                                If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                    LastT = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        Close #FF
                                        Close #FF2
                                        ChDir ODir
                                        ChDrive ODir
                                        Exit Sub
                                    End If
                                    
                                    Hold = B / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        .ProgressBar1 = 60 + (B / MCCorrection) * 40
                                        .SSPanel1.Caption = B & " of " & MCCorrection & " triplets examined"
                                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - StartT) / Hold) - (BSEnd - StartT))) & " remaining"
                                        UpdateRecNums (SEventNumber)
                                        .Label66(0).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label57(0).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        DoEvents
                                    End With
                
                                End If
                            Else
                                TotalCycles = TotalCycles + 1
                            End If
                        Next 'Seq3
                    'End If
                Next 'Seq2
            'End If
        Next 'Seq1
    End If
    Erase GoOnA
    Erase GoOnB
    Erase PltVal
    
    
                            BSEnd = Abs(GetTickCount()) 'Take the time
                            'If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                LastT = BSEnd
                                
                                
                                'Write progress to the screen
                                
                                With Form1
                                    UpdateRecNums (SEventNumber)
                                    .Label66(0).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart))) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                    .Label57(0).Caption = DoTimeII(Abs(BSEnd - Abs(ST))) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                    DoEvents
                                End With
            X = X
                            'End If
    
    
    '3.127
    EE = GetTickCount
    TT = EE - SS
    Close #FF2
    ChDir ODir
    ChDrive ODir
End Sub

Public Sub BSXoverM(SPF, FindAllFlag As Byte, WeightMod() As Long)
    'Exit Sub
    SS = GetTickCount
    Dim btTempSeq2() As Integer
    Dim SP As Long
    Dim B As Long, LTree As Long, StartT As Long, NumWins As Long
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
   
    Dim tMat() As Double, TMat2() As Double, SHolder() As Byte, TempSeq2() As Integer, PntAPI As POINTAPI
    Dim ValidX() As Double, DiffsX() As Double
    BSCBootReps = BSBootReps
    BSCStepWin = BSStepWin
    BSCStepSize = BSStepSize
    BSCTypeFlag = BSTypeFlag
    
   
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 2)
    
    
    For X = 1 To LSeq
        TempSeq2(X, 0) = SeqNum(X, Seq1)
        TempSeq2(X, 1) = SeqNum(X, Seq2)
        TempSeq2(X, 2) = SeqNum(X, Seq3)
    Next
    
    NumberOfSeqs = 3
    
    If FindAllFlag = 0 And SPF = 0 Then
        Call DoAxes(Len(StrainSeq(0)), -1, 100, 0, 1, "Bootstrap support (%)")
        
        Call Highlight
        
        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
        
        Form1.Picture8.Enabled = False
        Form1.Picture10.Enabled = False
        Form1.Combo1.Enabled = False
        Form1.Command29.Enabled = False
        Form1.SSPanel2.Enabled = False
        Form1.Picture5.Enabled = False
        Form1.Command6.Enabled = False
        Form1.Command25.Enabled = True
        
        'Do cutoff line
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawStyle = 2
        Pict = Form1.Picture7.hdc
        MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
        LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
        Form1.Picture7.DrawStyle = 0
    End If
     
    
    ReDim TTempSeq2(BSCStepWin, 2)
    ReDim DstMat(BSCBootReps, 2, 2)
    
    ReDim tMat(2, 2)
    ReDim SHolder((3 + 1) * 40 * 2)
    ReDim DstMat(BSBootReps, 2, 2)
    
    If BSSubModelFlag > 0 Then
        ReDim DistVal(BSCBootReps + 1)
        ReDim xx1(3), xx2(3)
        ReDim Prod1(BSCStepWin), Prod2(BSCStepWin), Prod3(BSCStepWin)
        ReDim Alias(BSCStepWin), Ally(BSCStepWin)
        ReDim Location(BSCStepWin)
        ReDim Px(2, BSCStepWin)
        ReDim Num(BSCBootReps + 1), Num1(BSCBootReps + 1), Num2(BSCBootReps + 1)
        ReDim DEN(BSCBootReps + 1)
        ReDim Weight(BSBootReps, BSStepWin)
    Else
        ReDim ValidX(BSBootReps), DiffsX(BSBootReps)
    End If
    
    
    
    NumWins = Int(Len(StrainSeq(0)) / BSCStepSize) + 2
    
    ReDim PltPos(NumWins + 1), PltVal(2, NumWins)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSCStepSize * Z)
    Next 'Z

    
    
    For B = 0 To NumWins
        
        MakeSubAlign 2, Len(StrainSeq(0)), B, BSCStepSize, BSCStepWin, TTempSeq2(0, 0), TempSeq2(0, 0)

        If BSSubModelFlag <> 3 Then
            
            If BSSubModelFlag = 0 And X = X Then
                
                Dummy = FastBootDist(0, BSCBootReps, 2, BSCStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), TTempSeq2(0, 0), DstMat(0, 0, 0))

            Else
                BootDist BSCBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, 3, BSCStepWin, TTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), Num(0), WeightMod(0, 0)
            End If
        Else

            

            ReDim btTempSeq2(BSCStepWin, 2)

            For X = 0 To BSCBootReps - 1

                If X > 0 Then
                    SP = 0

                    For Z = 0 To BSCStepWin - 1

                        For A = 1 To WeightMod(X, Z)
                            SP = SP + 1

                            For Y = 0 To 2
                                btTempSeq2(SP, Y) = TTempSeq2(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSCStepWin

                        For Y = 0 To 2
                            btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSCBootReps, BSCStepWin)
                ReDim tMat(2, 2)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, 3, BSCStepWin, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To 1

                    For Z = Y + 1 To 2
                        DstMat(X, Y, Z) = tMat(Y, Z)
                        DstMat(X, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

                Erase tMat
            Next 'X

        End If

        'On Error Resume Next
        'DstMat(0, 0, 0) = DstMat(0, 0, 0)
        'On Error GoTo 0

        If BSCTypeFlag > 0 Then
            ReDim tMat(3, 3)
            ReDim SHolder((3 + 1) * 40 * 2)

            For X = 0 To BSCBootReps - 1

                For Y = 0 To 2

                    For Z = 0 To 2
                        tMat(Y, Z) = DstMat(X, Y, Z)
                    Next 'Z

                Next 'Y

                For Y = 0 To 2
                    tMat(Y, 3) = 6
                    tMat(3, Y) = 6
                Next Y
                ReDim ColTotals(3)
                Dim TreeArray() As Double
                ReDim TreeArray(3, 3)
                LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 0, 4, tMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
                LTree = LTree + 1
                A = LTree

                Do
                    If SHolder(A) = 41 Then
                        Exit Do
                    End If
                    A = A - 1
                Loop
                
                'Convert the treeinfo (stared in newic format as an ascii array
                'in sholder) into a 2-d array describing the topology of a midpoint
                'rooted version of the tree
                SHolder(A + 1) = 59
                LTree = A + 1
                ReDim TMat2(3, 3)
                
                Call Tree2Array(2, NumberOfSeqs, LTree, SHolder(), TMat2())
            Next 'X

        End If
        
        
        
        '50.42
        If X = X Then
            Dummy = GetPltValX(B, BSBootReps, DstMat(0, 0, 0), PltVal(0, 0))
        Else
            For X = 0 To BSCBootReps - 1
                If DstMat(X, 0, 1) < 2 And DstMat(X, 0, 2) < 2 And DstMat(X, 1, 2) < 2 Then
                
                    If DstMat(X, 0, 1) < DstMat(X, 0, 2) And DstMat(X, 0, 1) < DstMat(X, 1, 2) Then
                            PltVal(0, B) = PltVal(0, B) + 1
                    ElseIf DstMat(X, 0, 2) < DstMat(X, 0, 1) And DstMat(X, 0, 2) < DstMat(X, 1, 2) Then
                            PltVal(1, B) = PltVal(1, B) + 1
                    ElseIf DstMat(X, 1, 2) < DstMat(X, 0, 1) And DstMat(X, 1, 2) < DstMat(X, 0, 2) Then
                            PltVal(2, B) = PltVal(2, B) + 1
                    End If
                End If
    
            Next 'x
        End If
        
       '50.58
        If FindAllFlag = 0 And SPF = 0 Then
            If B > 0 And PltPos(B) > 0 And PltPos(B) < Len(StrainSeq(0)) Then
                Pict = Form1.Picture7.hdc
                
                Form1.Picture7.ForeColor = Purple
                Dummy = MoveToEx(Pict, 30 + PltPos(B - 1) * XFactor, 20 + (1 - PltVal(2, B - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(B) * XFactor, 20 + (1 - PltVal(2, B) / BSCBootReps) * (PicHeight - 35))
                Form1.Picture7.ForeColor = Green
                Dummy = MoveToEx(Pict, 30 + PltPos(B - 1) * XFactor, 20 + (1 - PltVal(1, B - 1) / BSCBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(B) * XFactor, 20 + (1 - PltVal(1, B) / BSCBootReps) * (PicHeight - 35))
                Form1.Picture7.ForeColor = Yellow
                Dummy = MoveToEx(Pict, 30 + PltPos(B - 1) * XFactor, 20 + ((1 - PltVal(0, B - 1) / BSCBootReps) * (PicHeight - 35)), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(B) * XFactor, (20 + ((1 - PltVal(0, B) / BSCBootReps) * (PicHeight - 35))))
                Form1.Picture7.Refresh
            End If
        
            If AbortFlag = 1 Then
                Form1.Command25.Enabled = False
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6.Enabled = True
                Exit Sub
            End If
        
            'Update progress indicaters
            If B / 5 = Int(B / 5) And SPF = 0 Then
    
                With Form1
                    .ProgressBar1 = (B / NumWins) * 100
                    .SSPanel1.Caption = B & " of " & NumWins & " windows examined"
                    
                End With
                DoEvents
            End If
        
        End If

        'Erase DstMat
    Next 'B
    '57.89
    
    If FindAllFlag = 0 Then
        Call DrawBSPlotsIII(SPF, FindAllFlag)
        FindSubSeqBS
        If SPF = 0 Then
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            Form1.Command25.Enabled = False
        End If
    Else
        ReDim Scores(Len(StrainSeq(0)), 2)
        S1 = SubMaskSeq(Seq1)
        S2 = SubMaskSeq(Seq2)
        S3 = SubMaskSeq(Seq3)
        
        LenXOverSeq = BSSubSeq(Len(StrainSeq(0)), S1, S2, S3, SeqNum(0, 0), XPosdiff(0), XDiffpos(0), Scores(0, 0))
        
        '57.83
        Call ScanBSPlots(1, 1)
        '61.01
        
    End If
    '1.39
    
    
    
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    
End Sub
Public Sub BSXoverN()
    SS = GetTickCount

    Dim Modi As Double, DoneThis() As Byte, NumDone() As Double, MidNode(2) As Double, TallyDist As Double, MaxCurPos As Long, TB(1) As Long, MD As Double, B As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    Dim RootNode() As Long
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    ReDim DstOut(BSBootReps - 1)
    
    Call DoAxes(Len(StrainSeq(0)), -1, 100, 0, 0, "Bootstrap support (%)")
    
    'Do cutoff line
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.DrawStyle = 2
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
    Form1.Picture7.DrawStyle = 0
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    
    LSeq = Len(StrainSeq(0))
    ReDim RevSeq(NextNo)
    
    NumberOfSeqs = 1
    For X = 0 To NextNo

        If Selected(X) = 1 Then
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    ReDim TempSeq2(LSeq, NumberOfSeqs)
    Y = Form5.Combo1.ListIndex - 1
    For X = 1 To LSeq
        TempSeq2(X, 0) = SeqNum(X, Y)
    Next
    
    Z = 1
    For Y = 0 To NextNo
        If Selected(Y) = 1 Then
            For X = 1 To LSeq
                TempSeq2(X, Z) = SeqNum(X, Y)
            Next
            Z = Z + 1
        End If
    Next
    
    'Call DoLegend
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(BSStepWin)
    ReDim Prod2(BSStepWin)
    ReDim Prod3(BSStepWin)
    ReDim Alias(BSStepWin)
    ReDim Ally(BSStepWin)
    ReDim Location(BSStepWin)
    ReDim Px(NumberOfSeqs, BSStepWin)
    ReDim TTempSeq2(BSStepWin, NumberOfSeqs)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    ReDim DistVal(BSBootReps + 1)
    ReDim Num1(BSBootReps + 1)
    ReDim Num2(BSBootReps + 1)
    ReDim DEN(BSBootReps + 1)
    ReDim Num(BSBootReps + 1)
    ReDim WeightMod(BSBootReps, BSStepWin - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)

    For Y = 0 To BSBootReps

        For X = 1 To BSStepWin
            WeightMod(Y, X - 1) = 1
        Next 'X

    Next 'Y

    Rnd (-BSRndNumSeed)

    Dim Scratch() As Integer

    For Y = 1 To BSBootReps
        ReDim Scratch(BSStepWin)
        RndNum2 = CLng(BSStepWin / 4) + CLng(((BSStepWin / 4) * Rnd))

        For X = 1 To RndNum2

            Do
                RndNum = CLng(((BSStepWin - 1) * Rnd) + 1)
            Loop While Scratch(RndNum - 1) = 1

            Scratch(RndNum - 1) = 1
            WeightMod(Y, RndNum - 1) = 0

            Do
                RndNum = CLng(((BSStepWin - 1) * Rnd) + 1)
            Loop While WeightMod(Y, RndNum - 1) = 0

            WeightMod(Y, RndNum - 1) = WeightMod(Y, RndNum - 1) + 1
            Scratch(RndNum - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    
    ReDim PltPos(NumWins + 1)
    'Work out nt positions at the center of every window

    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    FF = FreeFile
    ReDim PltVal(NumberOfSeqs, NumWins)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    Dim AbBe() As Long
    Dim ValidX() As Double, DiffsX() As Double
    For B = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), B, BSStepSize, BSStepWin, TTempSeq2(0, 0), TempSeq2(0, 0)

        If BSSubModelFlag <> 3 Then
            If BSSubModelFlag = 0 Then
                ReDim ValidX(BSBootReps), DiffsX(BSBootReps), DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
                Dummy = FastBootDist(0, BSBootReps, NumberOfSeqs, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), TTempSeq2(0, 0), DstMat(0, 0, 0))
            Else
                ReDim Weight(BSBootReps, BSStepWin)
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, NumberOfSeqs + 1, BSStepWin, TTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), Num(0), WeightMod(0, 0)
            End If
        Else

            Dim btTempSeq2() As Integer
            Dim SP As Long

            ReDim btTempSeq2(BSStepWin, NumberOfSeqs)

            For X = 0 To BSBootReps - 1

                If X > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(X, Z)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                btTempSeq2(SP, Y) = TTempSeq2(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To NumberOfSeqs
                            btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                ReDim tMat(NumberOfSeqs, NumberOfSeqs)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, NumberOfSeqs + 1, BSStepWin, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To NumberOfSeqs - 1

                    For Z = Y + 1 To NumberOfSeqs
                        DstMat(X, Y, Z) = tMat(Y, Z)
                        DstMat(X, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

                Erase tMat
            Next 'X

        End If

        'On Error Resume Next
        'DstMat(0, 0, 0) = DstMat(0, 0, 0)
        'On Error GoTo 0

        If BSTypeFlag > 0 Then
            ReDim tMat(NumberOfSeqs, NumberOfSeqs)
            ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)

            For X = 0 To BSBootReps - 1
                
                For Y = 0 To NumberOfSeqs

                    For Z = 0 To NumberOfSeqs
                        tMat(Y, Z) = DstMat(X, Y, Z)
                    Next 'Z

                Next 'Y

                ReDim ColTotals(NumberOfSeqs)
                Dim TreeArray() As Double
                ReDim TreeArray(NumberOfSeqs, NumberOfSeqs)
                LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 0, NumberOfSeqs + 1, tMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
                LTree = LTree + 1
                A = LTree

                Do

                    If SHolder(A) = 41 Then
                        Exit Do
                    End If

                    A = A - 1
                Loop

                SHolder(A + 1) = 59
                LTree = A + 1
                'Dim ttr As String
                ttr = ""
                
                For A = 1 To LTree + 1
                   ttr = ttr + Chr(SHolder(A - 1))
                Next A
                MaxCurPos = NumberOfSeqs * NumberOfSeqs
                'SHolder(57) = Asc(59)
                ReDim NodeOrder(MaxCurPos)
                ReDim NodeLen(MaxCurPos)
                ReDim DoneNode(MaxCurPos)
                ReDim TempNodeOrder(MaxCurPos)
                ReDim RootNode(MaxCurPos, MaxCurPos)
                ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                NameLen = Len(Trim$(CStr(NumberOfSeqs + 1))) + 1
                ReDim AbBe(MaxCurPos)
                ReDim NumDone(MaxCurPos)
                
                
                
               Call Tree2Array(NameLen, NumberOfSeqs, LTree, SHolder(), TMat2())
                
               If X = 12345 Then
                'TreeToArray NameLen, NumberOfSeqs, LTree, SHolder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
                    Done0 = 0
                    For zz = 0 To MaxCurPos
                        If NodeOrder(zz) = 0 And Done0 = 1 Then
                            NodeOrder(zz) = NumberOfSeqs + 1
                            Exit For
                        ElseIf NodeOrder(zz) = 0 And Done0 = 0 Then
                           Done0 = 1
                        End If
                    Next zz
                    
                    If X = X Then
                        
                        
                        ReDim NumDone(MaxCurPos)
                        ReDim DoneThis(MaxCurPos)
                        
                        
                       
                    'Dim DXTmat2() As Double
                    ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                     For Y = 0 To MaxCurPos
                        NodeLen(Y) = CLng(NodeLen(Y) * 10000) / 10000
                     Next Y
                    For Y = 0 To MaxCurPos
                    
                    
                        If NodeOrder(Y) = NumberOfSeqs + 1 And Y > 2 Then Exit For
                        For Z = 0 To MaxCurPos
                            NumDone(Z) = 1
                        Next Z
                        If NodeOrder(Y) <= NumberOfSeqs Then
                        
                            TallyDist = NodeLen(NodeOrder(Y))
                            For Z = Y + 1 To MaxCurPos
                                If NodeOrder(Z) = NumberOfSeqs + 1 Then Exit For
                                If NodeOrder(Z) > NumberOfSeqs Then
                                    TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                    NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                    
                                Else
                                    TMat2(NodeOrder(Y), NodeOrder(Z)) = (CLng((TallyDist + NodeLen(NodeOrder(Z))) * 10000)) / 10000
                                    TMat2(NodeOrder(Z), NodeOrder(Y)) = TMat2(NodeOrder(Y), NodeOrder(Z))
                                End If
                            Next Z
                        End If
                    Next Y
                        
                        
                        
                        
                        'Find greatest distance between seqs in tree
                        MD = 0
                        For Seq1 = 0 To NumberOfSeqs - 1
                            For Seq2 = Seq1 + 1 To NumberOfSeqs
                                If MD < TMat2(Seq1, Seq2) Then
                                    MD = TMat2(Seq1, Seq2)
                                    TB(0) = Seq1
                                    TB(1) = Seq2
                                End If
                            Next
                        Next
                        
                        MD = (CLng(MD * 100000) / 2) / 100000
                        For Y = 0 To MaxCurPos
                            NumDone(Y) = 1
                        Next Y
                        
                        'Find Midpoint of the Tree
                        For Y = 0 To MaxCurPos
                         If NodeOrder(Y) = TB(0) Then
                             
                             Pos = Y + 1
                             Do
                                    'mark the route
                                 If NodeOrder(Pos) > NumberOfSeqs Then
                                     NumDone(NodeOrder(Pos)) = NumDone(NodeOrder(Pos)) * -1
                                 Else
                                     If NodeOrder(Pos) = TB(1) Then
                                       Exit Do
                                     End If
                                 End If
                                 Pos = Pos + 1
                             Loop
                             TallyDist = NodeLen(NodeOrder(Y))
                             If TallyDist < MD Then
                                For Z = Y + 1 To Pos
                                    If NodeOrder(Z) > NumberOfSeqs Or NodeOrder(Z) = NodeOrder(Pos) Then
                                        If NumDone(NodeOrder(Z)) = -1 Or NodeOrder(Z) = NodeOrder(Pos) Then
                                            NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            If TallyDist + NodeLen(NodeOrder(Z)) < MD Then
                                               TallyDist = TallyDist + NodeLen(NodeOrder(Z))
                                            Else
                                                Inside = 0
                                                C = Z
                                                Do While C > 0
                                                    C = C - 1
                                                    If NodeOrder(C) = NodeOrder(Z) Then
                                                        Inside = 1
                                                        Exit Do
                                                    End If
                                                    
                                                Loop
                                                'midpoint found
                                                If Inside = 0 Then
                                                    MidNode(0) = Z
                                                    MidNode(1) = MD - TallyDist
                                                    MidNode(2) = NodeLen(NodeOrder(Z)) - MidNode(1)
                                                    Exit For
                                                ElseIf Inside = 1 Then
                                                    MidNode(0) = Z
                                                    MidNode(2) = MD - TallyDist
                                                    MidNode(1) = NodeLen(NodeOrder(Z)) - MidNode(2)
                                                    Exit For
                                                End If
                                            End If
                                        End If
                                    End If
                                Next Z
                            Else
                                MidNode(0) = Y
                                MidNode(2) = MD
                                MidNode(1) = NodeLen(NodeOrder(Y)) - MidNode(2)
                            End If
                             Exit For
                         ElseIf NodeOrder(Y) = TB(1) Then
                            Pos = Y + 1
                             
                             'mark the route between the most distant sequences
                             Do
                               
                                 If NodeOrder(Pos) > NumberOfSeqs Then
                                     NumDone(NodeOrder(Pos)) = NumDone(NodeOrder(Pos)) * -1
                                 Else
                                     If NodeOrder(Pos) = TB(0) Then
                                       Exit Do
                                     End If
                                 End If
                                 Pos = Pos + 1
                             Loop
                             
                             'TallyDist = 0
                            TallyDist = NodeLen(NodeOrder(Y))
                            If TallyDist < MD Then
                                For Z = Y + 1 To Pos
                                    If NodeOrder(Z) > NumberOfSeqs Or NodeOrder(Z) = NodeOrder(Pos) Then
                                        If NumDone(NodeOrder(Z)) = -1 Or NodeOrder(Z) = NodeOrder(Pos) Then
                                            NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            If TallyDist + NodeLen(NodeOrder(Z)) < MD Then
                                               TallyDist = TallyDist + NodeLen(NodeOrder(Z))
                                            Else
                                                Inside = 0
                                                C = Z
                                                Do While C > 0
                                                    C = C - 1
                                                    If NodeOrder(C) = NodeOrder(Z) Then
                                                        Inside = 1
                                                        Exit Do
                                                    End If
                                                    
                                                Loop
                                                'midpoint found
                                                If Inside = 0 Then
                                                    MidNode(0) = Z
                                                    MidNode(1) = MD - TallyDist
                                                    MidNode(2) = NodeLen(NodeOrder(Z)) - MidNode(1)
                                                    Exit For
                                                ElseIf Inside = 1 Then
                                                    MidNode(0) = Z
                                                    MidNode(2) = MD - TallyDist
                                                    MidNode(1) = NodeLen(NodeOrder(Z)) - MidNode(2)
                                                    Exit For
                                                End If
                                                
                                            End If
                                        End If
                                    End If
                                Next Z
                            Else
                                MidNode(0) = Y
                                MidNode(2) = MD
                                MidNode(1) = NodeLen(NodeOrder(Y)) - MidNode(2)
                            End If
                            Exit For
                             
                         End If
                     Next Y
                     
                     'Find out which sequences are "above" and which are "below" the midnode
                     
                     For Y = 0 To MaxCurPos
                        If NodeOrder(Y) = NodeOrder(MidNode(0)) Then Exit For
                        AbBe(Y) = 1
                     Next Y
                     For Y = MaxCurPos To 0 Step -1
                        If Y = MaxCurPos Then
                            Do While NodeOrder(Y) = 0
                                Y = Y - 1
                            Loop
                        End If
                        If NodeOrder(Y) = NodeOrder(MidNode(0)) Then Exit For
                        AbBe(Y) = 3
                     Next Y
                     For Y = MaxCurPos To 0 Step -1
                        If Y = MaxCurPos Then
                            Do While NodeOrder(Y) = 0
                                Y = Y - 1
                            Loop
                        End If
                        If AbBe(Y) = 0 Then
                            AbBe(Y) = 2
                        End If
                     Next Y
                     'now modify the tree distance matrix to reflect equil distances from the root
                     'In effect its lengthening the terminal branches so that the distance between
                     'sequences in a distance matrix will reflect their reletive positions in the tree
                     'in relation to the midpoint "root"
                     'first do the "left" part of the tree
                     For Y = 0 To MaxCurPos
                        
                            If NodeOrder(Y) <= NumberOfSeqs And DoneThis(NodeOrder(Y)) = 0 And AbBe(Y) > 0 Then
                                DoneThis(NodeOrder(Y)) = 1
                                TallyDist = 0
                                For Z = 0 To MaxCurPos
                                    NumDone(Z) = 1
                                Next Z
                                If NodeOrder(Y) = NodeOrder(MidNode(0)) Then
                                
                                Else
                                    TallyDist = TallyDist + NodeLen(NodeOrder(Y))
                                    NumDone(NodeOrder(Y)) = NumDone(NodeOrder(Y)) * -1
                                    If AbBe(Y) = 2 Or AbBe(Y) = 1 Then
                                        For Z = Y + 1 To MaxCurPos
                                            
                                            If NodeOrder(Z) = NodeOrder(MidNode(0)) Then
                                                TallyDist = TallyDist + MidNode(AbBe(Y))
                                                Modi = CLng((MD - TallyDist) * 100000) / 100000
                                                If Modi < 0 Then
                                                    X = X
                                                    Modi = 0
                                                End If
                                                C = NodeOrder(Y)
                                                For A = 0 To NumberOfSeqs
                                                    If A <> C Then
                                                        If (A = 0 And C = 2) Or (A = 2 And C = 0) Then
                                                            X = X
                                                        End If
                                                        TMat2(A, C) = TMat2(A, C) + Modi
                                                        TMat2(C, A) = TMat2(A, C)
                                                        If TMat2(A, C) < 0 And Modi < 0 Then
                                                            X = X
                                                        End If
                                                    End If
                                                Next A
                                                Exit For
                                            ElseIf NodeOrder(Z) > NumberOfSeqs Then
                                                'there is still a very big problem with this - its ading more distances than it should
                                                TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                                NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            End If
                                        Next Z
                                    Else
                                        For Z = Y - 1 To 0 Step -1
                                            
                                            If NodeOrder(Z) = NodeOrder(MidNode(0)) Then
                                                TallyDist = TallyDist + MidNode(1)
                                                Modi = CLng((MD - TallyDist) * 100000) / 100000
                                                If Modi < 0 Then
                                                    X = X
                                                    Modi = 0
                                                End If
                                                C = NodeOrder(Y)
                                                For A = 0 To NumberOfSeqs
                                                    If A <> C Then
                                                        If (A = 0 And C = 2) Or (A = 2 And C = 0) Then
                                                            X = X
                                                        End If
                                                        TMat2(A, C) = TMat2(A, C) + Modi
                                                        TMat2(C, A) = TMat2(A, C)
                                                        
                                                    End If
                                                Next A
                                                Exit For
                                            ElseIf NodeOrder(Z) > NumberOfSeqs Then
                                                'there is still a very big problem with this - its ading more distances than it should
                                                TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                                NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                                
                                                
                                            End If
                                        Next Z
                                    End If
                                End If
                            ElseIf AbBe(Y) = 0 Then
                                Exit For
                            End If
                        
                     Next Y
                     
                            
                    End If
               End If
                For s1x = 0 To NumberOfSeqs - 1

                    For s2x = s1x + 1 To NumberOfSeqs
                        DstMat(X, s1x, s2x) = TMat2(s1x, s2x)
                        DstMat(X, s2x, s1x) = DstMat(X, s1x, s2x)
                    Next 'Seq2

                Next 'Seq1

            Next 'X

        End If
        If B = 80 Then
            X = X
        End If
        For Y = 0 To BSBootReps - 1

            'For B = 0 To NumSets - 1
                'Read the distance values
                HiVal = 100

                If TopDistFlag = 0 Then

                    For Z = 1 To NumberOfSeqs
                        
                        If HiVal >= DstMat(Y, 0, Z) Then
                            HiVal = DstMat(Y, 0, Z)
                            HiSeq = Z
                        End If

                    Next 'Z

                    PltVal(HiSeq, B) = PltVal(HiSeq, B) + 1

                Else

                    For Z = 1 To NumberOfSeqs
                        
                        If HiVal >= DstMat(Y, 0, Z) Then
                            HiVal = DstMat(Y, 0, Z)
                            HiSeq = Z
                        End If

                    Next 'Z

                    A = HiSeq

                    For Z = 1 To NumberOfSeqs

                        If Z <> A Then
                            

                            If DstMat(Y, A, Z) < HiVal Then
                                NoScoreFlag = 1
                                Exit For
                            End If

                        End If

                    Next 'Z

                    If NoScoreFlag = 0 Then
                        PltVal(HiSeq, B) = PltVal(HiSeq, B) + 1
                    Else
                        NoScoreFlag = 0
                    End If

                End If

            'Next 'X

        Next 'Y

        If B > 0 And PltPos(B) > 0 And PltPos(B) < Len(StrainSeq(0)) Then
            Pict = Form1.Picture7.hdc
            For X = 1 To NumberOfSeqs
                Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
                Dummy = MoveToEx(Pict, 30 + PltPos(B - 1) * XFactor, 20 + (1 - PltVal(X, B - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
                Dummy = LineTo(Pict, 30 + PltPos(B) * XFactor, 20 + (1 - PltVal(X, B) / BSBootReps) * (PicHeight - 35))
            Next X
            Form1.Picture7.Refresh
        End If
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        If B / 5 = Int(B / 5) Then

            With Form1
                .ProgressBar1 = (B / NumWins) * 100
                .SSPanel1.Caption = B & " of " & NumWins & " windows examined"
                
            End With

        End If
        
        DoEvents

        'Erase DstMat
    Next 'B
    Call DrawManBSPlot
    'Call DrawBSPlotsIII
    
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5

    
    EE = GetTickCount
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub
Public Sub ResizeForm1()
    'Resizes the interface to suit the current windows screen resolution

    Dim ScreenTwipsPerPixelX  As Long
    
    
    ScreenTwipsPerPixelX = Screen.TwipsPerPixelX
    TwipPerPix = ScreenTwipsPerPixelX
    Form1.ScaleMode = 1
    Form1OWidth = Screen.Width + 8 * Screen.TwipsPerPixelX
    Form1OHeight = Screen.Height - 20 * Screen.TwipsPerPixelY
    Form1.Width = Screen.Width + 8 * Screen.TwipsPerPixelX
    Form1.Height = Screen.Height - 20 * Screen.TwipsPerPixelY
    
    With Form1

        Dim RedoPicsFlag As Byte

        If NextNo > 0 Then
            RedoPicsFlag = 1
            .Picture1.Picture = LoadPicture()
            .Picture2.Picture = LoadPicture()
            .Picture16.Picture = LoadPicture()
            '.Picture26.Picture = LoadPicture()

            If .Picture16.Picture <> 0 Then .Picture16.Picture = LoadPicture()

            If Form4.Visible = True Then Unload Form4

            If RunFlag = 1 Then

                If Form2.Visible = True Then Unload Form2
                .Picture7.Picture = LoadPicture()
                .Picture10.Picture = LoadPicture()
                .Picture19.Picture = LoadPicture()
                .Picture20.Picture = LoadPicture()
                ORFFlag = 0
                .Picture6.Picture = LoadPicture()
                .VScroll2.Value = 0
            End If

        End If

        .Text5.Text = XOverWindowX
        .Text1.Text = LowestProb

        If RedoPicsFlag = 0 Then
            .SSPanel6(0).Enabled = False
            .SSPanel6(1).Enabled = False
            .SSPanel6(2).Enabled = False
            .SSPanel3.Enabled = False
            .SSPanel4.Enabled = False
            .SSPanel5.Enabled = False
            .Picture7.Enabled = False
        Else
            .SSPanel6(0).Enabled = True
            .SSPanel6(1).Enabled = True
            .SSPanel6(2).Enabled = True
            .SSPanel3.Enabled = True
            .SSPanel4.Enabled = True

            If RunFlag = 1 Then
                .SSPanel5.Enabled = True
                .Picture7.Enabled = True
            End If

        End If

        .Command9.Visible = True
        .Command9.Enabled = False
        '.command9.style = 0
        .Command9.BackColor = Form3.Command4.BackColor
        'Adjust arrangement and sizes of controlls on the screen according to the
        'current screen resolution and font sizes.
        .Picture1.Font.Name = "Courier"
        .Picture13.Top = 0
        .Picture13.left = 0
        '.Picture1.Font.Name = "Courier New"
        .Picture13.FontSize = 8.25
        .Picture2.FontSize = 7
        .Picture7.FontSize = 7

        If Screen.Height = 7200 Then

            If ScreenTwipsPerPixelX = 12 Then   'ie 800 X 600 resolution with large fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
                .Command20.Top = 1500 * VAddjust
                .Command20.left = 2575 * HAddjust
                .Command20.Width = 1200 * HAddjust
                .Command20.Height = 350 * VAddjust
            Else       'ie 640 X 480 resolution with small fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
                .Command15.Caption = "Hmology"
                'PrintSeqLen = 58 * HAddjust / TYF
                .Command20.Top = 1500 * VAddjust
                .Command20.left = 2575 * HAddjust
                .Command20.Width = 1200 * HAddjust
                .Command20.Height = 350 * VAddjust
            End If

        ElseIf Screen.Height = 9000 Then  'ie 800 X 600 resolution with small fonts
            HAddjust = 1
            VAddjust = 1
            .Label58.FontSize = 8
            'PrintSeqLen = 58 / TYF
            .Command20.Top = 1500 * VAddjust
            .Command20.left = 2575 * HAddjust
            .Command20.Width = 1200 * HAddjust
            .Command20.Height = 350 * VAddjust
        ElseIf Screen.Height = 9216 Then  'ie 1024 X 758 resolution with large fonts
            VAddjust = 9316 / 9000
            HAddjust = Screen.Width / 12000
            .Picture1.Top = 0
            .Picture13.FontSize = 6
            'PrintSeqLen = 70 * HAddjust / TYF
            .Command15.Caption = "Hmology"
            .Picture1.Font.Name = "Courier New"
            .Picture1.FontSize = 8
            .Picture2.FontSize = 5
            .Picture7.FontSize = 5
            .Command7.FontSize = 7
            .Command20.Top = 1500 * VAddjust
            .Command20.left = 2575 * HAddjust
            .Command20.Width = 1200 * HAddjust
            .Command20.Height = 350 * VAddjust
        ElseIf Screen.Height >= 11520 Then  'ie 1024 X 768 resolution with small fonts
            VAddjust = 11700 / 9000
            HAddjust = Screen.Width / 12000
            'PrintSeqLen = 58 * HAddjust / TYF
            .Command20.Top = 1500 * VAddjust
            .Command20.left = 2575 * HAddjust
            .Command20.Width = 1400 * HAddjust
            .Command20.Height = 350 * VAddjust
        Else
            VAddjust = Screen.Height / 9000
            HAddjust = Screen.Width / 12000
            'PrintSeqLen = 58 * HAddjust / TYF
            .Command20.Top = 1500 * VAddjust
            .Command20.left = 2575 * HAddjust
            .Command20.Width = 1200 * HAddjust
            .Command20.Height = 350 * VAddjust
        End If

        If ScreenTwipsPerPixelX = 12 Then
            .Label58.FontSize = 6
            .Label58.Height = 200
            .Command15.Caption = "Hmology"
            .Picture1.Font.Name = "Courier New"
            .Picture1.FontSize = 8
            .Picture13.FontSize = 6
            .Label14.FontSize = 7
            'PrintSeqLen = 58 / TYF
            .Command1.FontSize = 8
            .Command18.FontSize = 8
            .Command22.FontSize = 8
            .Command12.FontSize = 8
            .Command19.FontSize = 8
            .Command9.FontSize = 8
            .Command38.FontSize = 8
            .Label1.FontSize = 7
            .Label15.FontSize = 7
            .Label21.FontSize = 6
            .Frame7.FontSize = 6.5
            .Frame6.FontSize = 6.5
            .Picture3.FontSize = 7
            .Picture2.FontSize = 6
            .Picture7.FontSize = 6
            .Command7.FontSize = 7
            .Command13(0).FontSize = 7
            .Command13(1).FontSize = 7
            .Command4(0).FontSize = 7
            .Command4(1).FontSize = 7
            .Command8(0).FontSize = 7
            .Command8(1).FontSize = 7
            RowSpace = 250
            .Label52.FontSize = 6
            .Label54.FontSize = 6
            .Label55.FontSize = 6
            .Label5(0).FontSize = 6
            .Label5(1).FontSize = 6
            .Label5(2).FontSize = 6
            .Label61.FontSize = 6
            .Label63.FontSize = 6
            .Label64.FontSize = 6
            .Label65.FontSize = 6
            .Label56.FontSize = 6
            .Label53.FontSize = 6
            .Label50(0).FontSize = 6
            .Label50(1).FontSize = 6
            .Label51(0).FontSize = 6
            .Label51(1).FontSize = 6
            .Label66(0).FontSize = 6
            .Label66(1).FontSize = 6
            .Label67(0).FontSize = 6
            .Label67(1).FontSize = 6
            .Label68(0).FontSize = 6
            .Label68(1).FontSize = 6
            .Label69(0).FontSize = 6
            .Label69(1).FontSize = 6
            .Label57(0).FontSize = 6
            .Label57(1).FontSize = 6
        Else
            .Label58.FontSize = 8.25
            .Label58.Height = 285
            .Command15.Caption = "Homology"
            .Picture1.Font.Name = "Courier"
            .Picture1.FontSize = 9.75
            .Picture13.FontSize = 8.25
            .Label14.FontSize = 8.25
            'PrintSeqLen = 58 / TYF
            .Command1.FontSize = 8.25
            .Command18.FontSize = 8.25
            .Command22.FontSize = 8.25
            .Command7.FontSize = 8.25
            .Command38.FontSize = 8.25
            .Command12.FontSize = 8.25
            .Command19.FontSize = 8.25
            .Command9.FontSize = 8.25
            .Label1.FontSize = 8.25
            .Label15.FontSize = 8.25
            .Label21.FontSize = 6.75
            .Frame7.FontSize = 8.25
            .Frame6.FontSize = 8.25
            .Picture2.FontSize = 6.75
            .Picture7.FontSize = 6.75
            .Command13(0).FontSize = 8.25
            .Command13(1).FontSize = 8.25
            .Command4(0).FontSize = 8.25
            .Command4(1).FontSize = 8.25
            .Command8(0).FontSize = 8.25
            .Command8(1).FontSize = 8.25

            If Screen.Height > 7200 Then
                RowSpace = 350
                .Label52.FontSize = 8.25
                .Label54.FontSize = 8.25
                .Label55.FontSize = 8.25
                .Label5(0).FontSize = 8.25
                .Label5(1).FontSize = 8.25
                .Label5(2).FontSize = 8.25
                .Label61.FontSize = 8.25
                .Label63.FontSize = 8.25
                .Label64.FontSize = 8.25
                .Label65.FontSize = 8.25
                .Label56.FontSize = 8.25
                .Label53.FontSize = 8.25
                .Label50(0).FontSize = 8.25
                .Label50(1).FontSize = 8.25
                .Label51(0).FontSize = 8.25
                .Label51(1).FontSize = 8.25
                .Label66(0).FontSize = 8.25
                .Label66(1).FontSize = 8.25
                .Label67(0).FontSize = 8.25
                .Label67(1).FontSize = 8.25
                .Label68(0).FontSize = 8.25
                .Label68(1).FontSize = 8.25
                .Label69(0).FontSize = 8.25
                .Label69(1).FontSize = 8.25
                .Label57(0).FontSize = 8.25
                .Label57(1).FontSize = 8.25
            Else
                RowSpace = 250
                .Label52.FontSize = 6
                .Label54.FontSize = 6
                .Label55.FontSize = 6
                .Label5(0).FontSize = 6
                .Label5(1).FontSize = 6
                .Label5(2).FontSize = 6
                .Label61.FontSize = 6
                .Label63.FontSize = 6
                .Label64.FontSize = 6
                .Label65.FontSize = 6
                .Label56.FontSize = 6
                .Label53.FontSize = 6
                .Label50(0).FontSize = 6
                .Label50(1).FontSize = 6
                .Label51(0).FontSize = 6
                .Label51(1).FontSize = 6
                .Label66(0).FontSize = 6
                .Label66(1).FontSize = 6
                .Label67(0).FontSize = 6
                .Label67(1).FontSize = 6
                .Label68(0).FontSize = 6
                .Label68(1).FontSize = 6
                .Label69(0).FontSize = 6
                .Label69(1).FontSize = 6
                .Label57(0).FontSize = 6
                .Label57(1).FontSize = 6
            End If

        End If

        'Do comparison Table

        Dim LeftCorner As Long
        Dim TopCorner As Long
        Dim ColSpace As Integer

        LeftCorner = 800
        TopCorner = 0
        ColSpace = 1500
        .Frame17.Top = 0
        .Frame17.left = 0
        .Frame17.Width = .Picture7.ScaleWidth
        .Frame17.Height = .Picture7.ScaleHeight * VAddjust
        .Line44.X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line44.Y1 = (RowSpace * 0.75 + TopCorner) * VAddjust
        .Line44.X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line44.Y2 = (RowSpace * 0.75 + TopCorner) * VAddjust
        .Line45.X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line45.Y1 = (RowSpace * 6.75 + TopCorner) * VAddjust
        .Line45.X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line45.Y2 = (RowSpace * 6.75 + TopCorner) * VAddjust
        .Line46.X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line46.Y1 = (RowSpace * 8 + TopCorner) * VAddjust
        .Line46.X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line46.Y2 = (RowSpace * 8 + TopCorner) * VAddjust
        '.Command20.Visible = True
        .Frame7.Enabled = True
        .Command25.Enabled = True
        .Command20.Top = (RowSpace * 9 + TopCorner) * VAddjust
        .Command20.left = (ColSpace * 1 + LeftCorner) * HAddjust
        .Command20.Width = ColSpace * HAddjust
        .Command20.Height = 350 * VAddjust
        ' .picture7.Line ((ColSpace * 1 + LeftCorner) * HAddjust, (RowSpace * 1 + TopCorner) * VAddjust)-((ColSpace * 3 + LeftCorner) * HAddjust, (RowSpace * 1 + TopCorner) * VAddjust), QBColor(0)
        '.Label21.FontSize = .Label21.FontSize * VAddjust
        'If .Label21.FontSize > .Command1.FontSize Then .Label21.FontSize = .Command1.FontSize
        'Sort out spacing of .command buttons (buttons in .sspanel2)
        .SSPanel2.left = 0
        .SSPanel2.Top = 0
        .SSPanel2.Width = 605 * Screen.TwipsPerPixelX
        .SSPanel2.Height = 28 * Screen.TwipsPerPixelY
        .HScroll3.Top = .SSPanel2.Top + 2
        .HScroll3.left = .SSPanel2.left + 2
        .HScroll3.Max = 1
        'Open Button
        .Command1.Top = 2 * Screen.TwipsPerPixelY
        .Command1.Height = .SSPanel2.Height - 4 * Screen.TwipsPerPixelY
        .Command1.left = 5 * Screen.TwipsPerPixelX
        .Command1.Width = 70 * Screen.TwipsPerPixelX
        .Command2.Top = .Command1.Top
        .Command2.Height = .Command1.Height
        .Command2.left = 74 * Screen.TwipsPerPixelX
        .Command2.Width = 16 * Screen.TwipsPerPixelX
        'Save Button
        .Command18.left = 90 * Screen.TwipsPerPixelX
        .Command18.Width = 85 * Screen.TwipsPerPixelX
        .Command18.Top = .Command1.Top
        .Command18.Height = .Command1.Height
        .Command23.Top = .Command1.Top
        .Command23.Height = .Command1.Height
        .Command23.left = 159 * Screen.TwipsPerPixelX
        .Command23.Width = 16 * Screen.TwipsPerPixelX
        .Command23.Visible = False
        'Xover button
        .Command22.left = 175 * Screen.TwipsPerPixelX
        .Command22.Width = 85 * Screen.TwipsPerPixelX
        .Command22.Top = .Command1.Top
        .Command22.Height = .Command1.Height
        .Command16.Top = .Command1.Top
        .Command16.Height = .Command1.Height
        .Command16.left = 244 * Screen.TwipsPerPixelX
        .Command16.Width = 16 * Screen.TwipsPerPixelX
        .Command16.Visible = False
        'Draw Tree
        .Command7.left = 260 * Screen.TwipsPerPixelX
        .Command7.Width = 85 * Screen.TwipsPerPixelX
        .Command7.Top = .Command1.Top
        .Command7.Height = .Command1.Height
        
        .Command11.Top = .Command1.Top
        .Command11.Height = .Command1.Height
        .Command11.left = 329 * Screen.TwipsPerPixelX
        .Command11.Width = 16 * Screen.TwipsPerPixelX
        .Command11.Visible = False
        'matrices
        .Command38.left = 345 * Screen.TwipsPerPixelX
        .Command38.Width = 85 * Screen.TwipsPerPixelX
        .Command38.Top = .Command1.Top
        .Command38.Height = .Command1.Height
        
        .Command37.Top = .Command1.Top
        .Command37.Height = .Command1.Height
        .Command37.left = 414 * Screen.TwipsPerPixelX
        .Command37.Width = 16 * Screen.TwipsPerPixelX
        .Command37.Visible = False
        
        'save?
        .Command3.Top = .Command1.Top
        .Command3.Height = .Command1.Height
        .Command3.left = 160 * HAddjust
        .Command3.Width = 800 * HAddjust
        .Command1.MouseIcon = .Command18.MouseIcon
        .Command1.MousePointer = 99
        
        .Command12.left = 430 * Screen.TwipsPerPixelX
        .Command12.Width = 85 * Screen.TwipsPerPixelX
        .Command12.Top = .Command1.Top
        .Command12.Height = .Command1.Height
        .Command19.left = 515 * Screen.TwipsPerPixelX
        .Command19.Width = 85 * Screen.TwipsPerPixelX
        .Command19.Top = .Command1.Top
        .Command19.Height = .Command1.Height
        .Command19.MouseIcon = .Command18.MouseIcon
        .Command19.MousePointer = 99
        'Arrange homology panel/window (.sspanel4)
        .SSPanel4.left = .SSPanel2.left
        .SSPanel4.Top = .SSPanel2.Height + 3 * Screen.TwipsPerPixelY
        .SSPanel4.Height = .SSPanel2.Height + 2 * Screen.TwipsPerPixelY
        .SSPanel4.Width = 8100 * HAddjust
        .SSPanel11.Width = 68 * Screen.TwipsPerPixelX
        .SSPanel11.left = .SSPanel4.Width - .SSPanel11.Width - 4 * Screen.TwipsPerPixelX
        .SSPanel11.Top = 3 * Screen.TwipsPerPixelY
        .SSPanel11.Height = .SSPanel4.Height - 6 * Screen.TwipsPerPixelY
        .Command21.Top = .SSPanel11.Top
        .Command21.Height = .SSPanel11.Height
        .Command21.Width = .SSPanel11.Height
        .Command21.left = .SSPanel11.left - .Command21.Width - 4 * Screen.TwipsPerPixelX
        .Command15.Top = .SSPanel11.Top
        .Command15.left = .SSPanel11.left
        .Command15.Height = .SSPanel11.Height
        .Command15.Width = .SSPanel11.Width
        .Command15.Visible = False
        .Label15.left = 2 * Screen.TwipsPerPixelX
        .Label15.Width = .SSPanel11.Width - 4 * Screen.TwipsPerPixelX
        .Label15.Top = 4 * Screen.TwipsPerPixelY
        .Label15.Height = .SSPanel11.Height - 8 * Screen.TwipsPerPixelY
        .Picture4.Top = .SSPanel11.Top
        .Picture4.Height = .SSPanel11.Height
        .Picture4.left = 4 * Screen.TwipsPerPixelX
        .Picture4.Width = .Command21.left - 8 * Screen.TwipsPerPixelX
        .Picture11.Top = .SSPanel11.Top
        .Picture11.Height = .SSPanel11.Height
        .Picture11.left = .Picture4.left
        .Picture11.Width = .Picture4.Width
        'Arrange .progressbar panel (.sspanel7)
        .SSPanel7.Height = 30 * Screen.TwipsPerPixelY
        .SSPanel7.Top = Form1.ScaleHeight - .SSPanel7.Height
        .SSPanel7.left = 0
        .SSPanel7.Width = Screen.Width
        .SSPanel1.left = 4 * Screen.TwipsPerPixelX
        .SSPanel1.Width = 300 * Screen.TwipsPerPixelX
        .SSPanel1.Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1.Height = .SSPanel7.Height - 8 * Screen.TwipsPerPixelY
        .SSPanel12.left = .SSPanel1.Width + 8 * Screen.TwipsPerPixelX
        .SSPanel12.Height = .SSPanel1.Height
        .SSPanel12.Top = .SSPanel1.Top
        .SSPanel12.Width = .SSPanel7.Width - (.SSPanel12.left + 4 * Screen.TwipsPerPixelX)
        .ProgressBar1.ZOrder
        .ProgressBar1.left = 3 * Screen.TwipsPerPixelX
        .ProgressBar1.Width = .SSPanel12.Width - 6 * Screen.TwipsPerPixelX
        .ProgressBar1.Height = .SSPanel12.Height - 6 * Screen.TwipsPerPixelY
        .ProgressBar1.Top = 3 * Screen.TwipsPerPixelY
        .SSPanel13.left = 3 * Screen.TwipsPerPixelX
        .SSPanel13.Height = .ProgressBar1.Height
        .SSPanel13.Top = .ProgressBar1.Top
        .SSPanel13.Width = 225 * Screen.TwipsPerPixelX

        Dim X As Long

        'Arrange recombination info panel (.sspanel6(0))
        For X = 0 To 2
            .SSPanel6(X).left = .SSPanel4.Width + .SSPanel4.left + 4 * Screen.TwipsPerPixelX
            .SSPanel6(X).Top = .SSPanel4.Top
            .SSPanel6(X).Height = .SSPanel4.Height + (.SSPanel7.Top - (.SSPanel4.Top + .SSPanel4.Height) - 12 * Screen.TwipsPerPixelY) / 1.8
            .SSPanel6(X).Width = .ScaleWidth - .SSPanel6(X).left
        Next 'X

        'Arrange all buttons
        .SSPanel6(0).ZOrder

        For X = 0 To 1
            .Command13(X).Top = .Command6.Top
            .Command13(X).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 2
            .Command13(X).Height = .Command1.Height
        Next 'X

        .Command13(0).left = 1 * Screen.TwipsPerPixelX
        .Command13(1).left = .Command13(0).left + .Command13(0).Width
        
        .SSPanel16.Width = .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY
        .SSPanel16.Top = .Command13(0).Top + .Command13(0).Height + 4 * Screen.TwipsPerPixelY
        .SSPanel16.left = 4 * Screen.TwipsPerPixelY
        .SSPanel16.Height = 22 * Screen.TwipsPerPixelY
        .SSPanel16.Caption = ""
        .SSPanel16.ForeColor = BackColours
        .SSPanel16.BackColor = HalfColour
        .SSPanel16.Font.Bold = True
        .Picture32.Top = .Command13(0).Top + .Command13(0).Height + 30 * Screen.TwipsPerPixelY
        .Picture32.left = 4 * Screen.TwipsPerPixelY
        .Picture32.Width = .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY
        .Picture32.Height = .SSPanel6(0).Height - .Picture32.Top - 4 * Screen.TwipsPerPixelY
        .Picture32.ScaleMode = 1
        .VScroll4.Top = .Picture32.Top
        .VScroll4.Width = 12 * Screen.TwipsPerPixelY
        .VScroll4.left = .SSPanel6(0).Width - .VScroll4.Width - 4 * Screen.TwipsPerPixelY
        .VScroll4.Height = .Picture32.Height
        .VScroll4.Min = 0
        .VScroll4.LargeChange = .Picture32.ScaleHeight / Screen.TwipsPerPixelY
        .VScroll4.SmallChange = 13
        .VScroll4.Enabled = False
        .Picture2.Top = 0
        .Picture2.left = 0
        .Picture2.Width = .Picture32.ScaleWidth
        .Picture2.Height = 15000
        .Picture2.ScaleMode = 1
        .Picture2.MouseIcon = .Command1.MouseIcon
        'Arrange Tree Panel (.sspanel6(1))

        For X = 0 To 1
            .Command8(X).Top = .Command6.Top
            .Command8(X).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 2
            .Command8(X).Height = .Command1.Height
        Next 'X

        .Command8(1).left = 1 * Screen.TwipsPerPixelX
        .Command8(0).left = .Command13(0).left + .Command13(0).Width
        .Command17.Height = .Command21.Height
        .Command17.Width = .Command21.Width
        .Command17.left = .SSPanel6(0).Width - .Command17.Width - 4 * Screen.TwipsPerPixelX
        
        .Command17.Top = .Command8(0).Top + .Command8(0).Height + 4 * Screen.TwipsPerPixelY
        .Command14.Top = .Command17.Top
        .Command35.Top = .Command17.Top
        .Command36.Top = .Command17.Top
        
        .Command14.Height = .Command17.Height
        .Command35.Height = .Command17.Height
        .Command36.Height = .Command17.Height
        
        .Command14.Width = .Command17.Width
        .Command35.Width = .Command17.Width
        .Command36.Width = .Command17.Width
        
        .Command14.left = .Command17.left - .Command14.Width
        .Command35.left = .Command14.left - .Command14.Width
        .Command36.left = .Command35.left - .Command14.Width
        
        .Label14.Top = .Command17.Top + 3 * Screen.TwipsPerPixelY
        .Label14.left = 4 * Screen.TwipsPerPixelX
        .Label14.Height = .Command17.Height
        .Label14.Width = .Command36.left - 8 * Screen.TwipsPerPixelX
        
        .VScroll1.Top = .Command17.Top + .Command17.Height + 4 * Screen.TwipsPerPixelY
        .VScroll1.Width = 12 * Screen.TwipsPerPixelY
        .VScroll1.left = .SSPanel6(1).Width - .VScroll1.Width - 4 * Screen.TwipsPerPixelY
        .VScroll1.Height = .SSPanel6(1).Height - .VScroll1.Top - 4 * Screen.TwipsPerPixelY
        .Picture16.Top = .VScroll1.Top
        .Picture16.left = 4 * Screen.TwipsPerPixelY
        .Picture16.Height = .VScroll1.Height
        .Picture16.Width = .VScroll1.left - 8 * Screen.TwipsPerPixelX
        .Picture16.ScaleMode = 1
        .Command28.Top = 0
        .Command29.left = 0
        .Command28.Width = .Command1.Width
        .Command28.Height = .Command1.Height
        'Arrange Compatibility Matrix Panel
        'Arrange all buttons

        For X = 0 To 1
            .Command4(X).Top = .Command6.Top
            .Command4(X).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 2
            .Command4(X).Height = .Command1.Height
        Next 'X

        .Command4(0).left = 1 * Screen.TwipsPerPixelX
        .Command4(1).left = .Command13(0).left + .Command13(0).Width
        .Command5.Height = .Command21.Height
        .Command5.Width = .Command21.Width
        .Command5.left = .SSPanel6(0).Width - .Command17.Width - 4 * Screen.TwipsPerPixelX
        .Command5.Top = .Command8(0).Top + .Command8(0).Height + 4 * Screen.TwipsPerPixelY
        .Command10.Top = .Command17.Top
        .Command10.Height = .Command17.Height
        .Command10.Width = .Command17.Width
        .Command10.left = .Command17.left - .Command14.Width
        .Label4.Top = .Command17.Top + 3 * Screen.TwipsPerPixelY
        .Label4.left = 4 * Screen.TwipsPerPixelX
        .Label4.Height = .Command17.Height
        .Label4.Width = .Command14.left - 8 * Screen.TwipsPerPixelX
        .Picture29.Top = .Command1.Height * 2 + .Command4(0).Top + 8 * Screen.TwipsPerPixelY
        .Picture17.Width = .VScroll1.Width + 2 * Screen.TwipsPerPixelX
        .HScroll4.Height = 12 * Screen.TwipsPerPixelY
        If RETFlag <= 2 Then

            If .SSPanel6(0).Height - .Picture29.Top - 4 * Screen.TwipsPerPixelY - 50 - .HScroll4.Height < .SSPanel6(1).Width - .Picture17.Width * 5 - 8 * Screen.TwipsPerPixelX Then
                .Picture29.Height = .SSPanel6(0).Height - .Picture29.Top - 4 * Screen.TwipsPerPixelY - 50 - .HScroll4.Height
                .Picture29.Width = .Picture29.Height
                .Picture29.left = 4 * Screen.TwipsPerPixelY '50 '(.SSPanel6(2).Width - .Picture29.Width) / 2
            Else
                .Picture29.Width = .SSPanel6(1).Width - .Picture17.Width * 5 - 8 * Screen.TwipsPerPixelX
                .Picture29.left = 4 * Screen.TwipsPerPixelY '50 '4 * Screen.TwipsPerPixelX
                .Picture29.Height = .Picture29.Width
            End If

            .Picture26.Top = 0
            .Picture26.Height = .Picture29.Width - 5 * Screen.TwipsPerPixelX
            .Picture26.Width = .Picture29.Width + 15 * Screen.TwipsPerPixelX
            .Picture26.left = 0
            .Picture26.BackColor = Form1.BackColor
            .Picture28(0).Height = .Picture29.Width
            .Picture28(0).Width = .Picture29.Width
            .Picture28(1).Height = .Picture29.Width
            .Picture28(1).Width = .Picture29.Width
        Else
            .Picture29.left = 1 * Screen.TwipsPerPixelX + (.SSPanel6(2).Width - .Picture29.Width) / 2
            .Picture29.Height = .SSPanel6(0).Height - .Picture29.Top - 1 * Screen.TwipsPerPixelY - 50 - HScroll4.Height
        End If
        '.Picture29.Top = .Picture29.Top + (.SSPanel6(1).Height - .Picture29.Top - .Picture29.Height) / 2
        .HScroll4.Top = .Picture29.Top + .Picture29.Height + 50
        .HScroll4.Height = 12 * Screen.TwipsPerPixelY
        .HScroll4.left = .Picture29.left
        .HScroll4.Width = .Picture29.Width
        .HScroll4.Enabled = False
        .VScroll5.Enabled = False
        .Picture17.Top = .Picture29.Top + 10 * Screen.TwipsPerPixelY
        .Picture17.Height = .Picture29.Height / 2
        
        .Picture17.left = .Picture29.left + .Picture29.Width + 50
        .Picture17.BackColor = Form1.BackColor
        
        
        
        
        .Line1(0).Y1 = .Picture17.Top + 1 * Screen.TwipsPerPixelY
        .Line1(0).Y2 = .Line1(0).Y1
        .Line1(1).Y1 = .Picture17.Top + (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 4 + 1 * Screen.TwipsPerPixelY
        .Line1(2).Y1 = .Picture17.Top + (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 2 + 1 * Screen.TwipsPerPixelY
        .Line1(3).Y1 = .Picture17.Top + .Picture17.Height - 2 * Screen.TwipsPerPixelY - (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 4
        .Line1(4).Y1 = .Picture17.Top + .Picture17.Height - 2 * Screen.TwipsPerPixelY
        
        .Line1(1).Y2 = .Line1(1).Y1
        .Line1(2).Y2 = .Line1(2).Y1
        .Line1(3).Y2 = .Line1(3).Y1
        .Line1(4).Y2 = .Line1(4).Y1
        
        
        
        .Line1(0).X1 = .Picture17.left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(1).X1 = .Picture17.left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(2).X1 = .Picture17.left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(3).X1 = .Picture17.left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(4).X1 = .Picture17.left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        
        .Line1(0).X2 = .Picture17.left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(1).X2 = .Picture17.left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(2).X2 = .Picture17.left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(3).X2 = .Picture17.left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(4).X2 = .Picture17.left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        
        
        For X = 0 To 4
            .Line1(X).Visible = False
        Next X
        
        .Label6(0).left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(1).left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(2).left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(3).left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(4).left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(5).left = .Picture17.left
        .Label6(0).Top = .Line1(0).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(1).Top = .Line1(1).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(2).Top = .Line1(2).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(3).Top = .Line1(3).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(4).Top = .Line1(4).Y1 - 5 * Screen.TwipsPerPixelY
        
        
        .Picture18.Top = .Picture29.Top + 10 * Screen.TwipsPerPixelY
        .Picture18.Height = .Picture29.Height / 2
        .Picture18.Width = .VScroll1.Width + 2 * Screen.TwipsPerPixelX
        .Picture18.left = .SSPanel6(0).left
        .Picture18.BackColor = Form1.BackColor
        
        .VScroll5.Width = .VScroll1.Width
        .VScroll5.left = .Picture17.left
        
        .VScroll5.Top = .Picture17.Top + .Picture17.Height + 50
        .VScroll5.Height = .Picture29.Top + .Picture29.Height - .VScroll5.Top
        
        
        
        .Label6(5).Top = .Picture17.Top + .Picture17.Height + 5 * Screen.TwipsPerPixelY
        
        If .SSPanel6(0).Width - .Label6(5).left - Screen.TwipsPerPixelX >= 0 Then
            .Label6(5).Width = .SSPanel6(0).Width - .Label6(5).left - Screen.TwipsPerPixelX
        End If
        .SSPanel15.left = .VScroll5.left + .VScroll5.Width + 50
        
        If .VScroll5.Top > .Picture18.Top + .Picture18.Height + 50 Then
            .SSPanel15.Top = .VScroll5.Top
        Else
            .SSPanel15.Top = .Picture18.Top + .Picture18.Height + 50
        End If
        
        .SSPanel15.Height = .Picture29.Top + .Picture29.Height - .SSPanel15.Top
        
        .SSPanel15.Width = .SSPanel6(0).Width - 50 - .SSPanel15.left
        If .SSPanel15.Width > 800 Then
            .SSPanel15.left = .SSPanel15.left + (.SSPanel15.Width - 800) / 2
            .SSPanel15.Width = 800
        End If
        For X = 0 To 2
            .Label7(X).left = 50
            .Label7(X).Width = .SSPanel15.Width - 100
            .Label7(X).Top = 100 + ((.SSPanel15.Height - 100) / 3) * (X)
        Next X
        
        .Command40.Top = .HScroll4.Top
        .Command40.left = .SSPanel15.left
        .Command40.Width = .SSPanel15.Width / 2
        .Command40.Height = .HScroll4.Height
        
        .Command39.Top = .Command40.Top
        .Command39.left = .Command40.left + .Command40.Width
        .Command39.Width = .Command40.Width
        .Command39.Height = .Command40.Height
        
        'Arrange Sequence Window (.sspanel3)
        .SSPanel3.left = .SSPanel2.left
        .SSPanel3.Width = .SSPanel4.Width
        .SSPanel3.Top = .SSPanel4.Top + .SSPanel4.Height + 4 * Screen.TwipsPerPixelY
        .SSPanel3.Height = .SSPanel6(0).Height - .SSPanel4.Height - 4 * Screen.TwipsPerPixelY
        .Command6.Top = .Picture4.Top
        .Command6.Height = .Picture4.Height
        .Command6.Width = .Picture4.Height
        .Command6.left = .SSPanel3.Width - .Command6.Width - 4 * Screen.TwipsPerPixelX
        .Command6.MouseIcon = .Command18.MouseIcon
        .Command6.MousePointer = 99
        .Picture14.Top = .Picture4.Top
        .Picture14.Height = .Picture4.Height
        .Picture14.left = .Picture4.left
        .Picture14.Width = .Picture4.Width
        .Label21.Top = 1 * Screen.TwipsPerPixelY
        .Label21.Height = .Command6.Height + 3 * Screen.TwipsPerPixelY
        .Label21.left = .Picture4.left + .Picture4.Width + 4 * Screen.TwipsPerPixelX
        .Label21.Width = .Command6.left - .Label21.left - 4 * Screen.TwipsPerPixelX
        .Picture13.Width = .Picture14.Width
        .Picture13.Height = .Picture14.ScaleHeight
        .Picture13.left = -35
        .HScroll1.left = .Picture4.left
        .HScroll1.Width = .Picture4.Width
        .HScroll1.Height = 12 * Screen.TwipsPerPixelY
        .HScroll1.Top = .SSPanel3.Height - .HScroll1.Height - 4 * Screen.TwipsPerPixelY
        .HScroll1.Max = 99
        .VScroll3.Top = 2 * .Command6.Top + .Command6.Height
        .VScroll3.Width = 12 * Screen.TwipsPerPixelX
        .VScroll3.left = .SSPanel3.Width - .VScroll3.Width - 4 * Screen.TwipsPerPixelX
        .VScroll3.Height = .HScroll1.Top - .VScroll3.Top - 4 * Screen.TwipsPerPixelX
        .VScroll3.SmallChange = 2
        .VScroll3.LargeChange = 10
        .Picture8.left = .Label21.left
        .Picture8.Top = .VScroll3.Top
        .Picture8.Height = .VScroll3.Height
        .Picture8.Width = .VScroll3.left - .Picture8.left - 4 * Screen.TwipsPerPixelX
        .Picture8.ScaleMode = 1
        .Picture9.Top = .VScroll3.Top
        .Picture9.Height = .VScroll3.Height
        .Picture9.left = .Picture4.left
        .Picture9.Width = .Picture4.Width
        .Picture9.ScaleMode = 1
        .Picture1.Width = .Picture9.Width
        .Picture1.Height = .Picture9.Height
        .Picture1.Top = 0
        .Picture1.left = 0
        .Picture1.ScaleMode = 1
        PrintSeqLen = (3 + .Picture9.Width / .Picture1.TextWidth("A"))
        .Picture3.left = 1 * Screen.TwipsPerPixelX
        .Picture3.Top = 0
        .Picture3.Width = .Picture8.Width
        .Command34.left = .Picture8.left
        .Command34.Top = .HScroll1.Top
        .Command34.Height = .HScroll1.Height
        .Command34.Width = .Picture8.Width / 2
        .Command33.left = .Picture8.left + .Picture8.Width / 2
        .Command33.Top = .HScroll1.Top
        .Command33.Height = .HScroll1.Height
        .Command33.Width = .Picture8.Width / 2
        

        'Arrange XOver Plot panel (.sspanel8)
        .SSPanel8.Top = .SSPanel3.Top + .SSPanel3.Height + 4 * Screen.TwipsPerPixelY
        .SSPanel8.left = 0
        .SSPanel8.Width = .SSPanel3.Width
        .SSPanel8.Height = .SSPanel7.Top - .SSPanel8.Top - 4 * Screen.TwipsPerPixelY
        .Picture10.left = .Picture4.left
        .Picture10.Top = .Picture4.Top
        .Picture10.Height = .SSPanel8.Height - .Picture10.Top - 4 * Screen.TwipsPerPixelX
        .Picture10.Width = .Picture4.Width
        .Picture10.ScaleMode = 1
        .Picture7.AutoRedraw = True
        .Picture7.DrawWidth = 1
        .Picture7.Height = .Picture10.ScaleHeight
        .Picture7.Width = .Picture10.ScaleWidth - 20 * Screen.TwipsPerPixelX
        .Picture7.Top = -1
        .Picture7.left = 20 * Screen.TwipsPerPixelX
        .Picture7.MouseIcon = .Command1.MouseIcon
        
        For Z = 0 To 2
            .Image3(Z).Height = .Picture10.ScaleHeight
            .Image3(Z).Width = .Picture10.ScaleWidth - 20
        Next 'Z

        .Picture19.ScaleMode = 3
        .Picture19.Top = 0
        .Picture19.ScaleHeight = 23 * Screen.TwipsPerPixelY
        .Picture19.left = .Picture7.left + 30 * Screen.TwipsPerPixelX
        .Picture19.Width = .Picture7.Width - 40 * Screen.TwipsPerPixelX
        .Picture20.ScaleMode = 3
        .Picture20.Top = 0
        .Picture20.Height = .Picture19.Height
        .Picture20.AutoRedraw = True
        .Picture20.ForeColor = 0
        .Picture20.DrawMode = 13
        .Picture20.DrawWidth = 1
        .Picture20.left = .Picture19.left
        .Picture20.Width = .Picture19.Width
        'Arrange Settings for plot Panel
        .SSPanel10.left = .Picture8.left
        .SSPanel10.Width = .SSPanel8.Width - .SSPanel10.left - 4 * Screen.TwipsPerPixelX
        .SSPanel10.Top = .Picture10.Top
        .SSPanel10.Height = .Picture10.Height
        'Arrange Components of panel
        .SSPanel9.left = 4 * Screen.TwipsPerPixelX
        .SSPanel9.Width = .SSPanel10.Width - 8 * Screen.TwipsPerPixelX
        .SSPanel9.Top = 4 * Screen.TwipsPerPixelX
        .SSPanel9.Height = .SSPanel11.Height
        .Label1.Top = .Label15.Top
        .Label1.left = 1 * Screen.TwipsPerPixelX
        .Label1.Width = .SSPanel9.Width - 2 * Screen.TwipsPerPixelX
        .Label1.Height = .Label15.Height
        .Frame6.left = .SSPanel9.left
        .Frame6.Width = .SSPanel9.Width
        .Frame6.Top = .SSPanel9.Top + .SSPanel9.Height + 4 * Screen.TwipsPerPixelY
        .Frame6.Height = 48 * Screen.TwipsPerPixelY
        .Text1.Top = 16 * Screen.TwipsPerPixelY
        .Text1.left = 4 * Screen.TwipsPerPixelX
        .Text1.Height = .Combo1.Height
        .Text1.Width = .Frame6.Width - 8 * Screen.TwipsPerPixelY
        .Frame7.left = .SSPanel9.left
        .Frame7.Width = .SSPanel9.Width
        .Frame7.Top = .Frame6.Top + .Frame6.Height + 4 * Screen.TwipsPerPixelY
        .Frame7.Height = 103 * Screen.TwipsPerPixelY
        .Combo1.Clear
        .Combo1.BackColor = .BackColor
        .Combo1.left = .Text1.left
        .Combo1.Width = .Text1.Width
        .Combo1.Top = .Text1.Top
        '.Combo1.Height = .Text1.Height
        .Combo1.Enabled = False
        .Command29.left = .Text1.left
        .Command29.Width = .Text1.Width
        .Command29.Top = .Combo1.Top + .Combo1.Height + 4 * Screen.TwipsPerPixelY
        .Command29.Height = .Command1.Height '- 2 * Screen.TwipsPerPixelY
        .Command29.MouseIcon = .Command18.MouseIcon
        .Command29.MousePointer = 99
        .Command29.Enabled = False
        .Command25.left = .Text1.left
        .Command25.Width = .Text1.Width
        .Command25.Top = .Command29.Top + .Command29.Height + 4 * Screen.TwipsPerPixelY
        .Command25.Height = .Command1.Height '- 2 * Screen.TwipsPerPixelY
        .Command25.MouseIcon = .Command18.MouseIcon
        .Command25.MousePointer = 99
        .Command25.Enabled = False
        'Arrange recombination .picture panel (.sspanel5)
        .SSPanel5.Top = .SSPanel8.Top
        .SSPanel5.left = .SSPanel6(0).left
        .SSPanel5.Height = .SSPanel8.Height
        .SSPanel5.Width = .SSPanel6(0).Width
        '.picture5.Visible = False
        '.command9.ZOrder
        .Label58.Caption = ""
        .Label58.Height = .Command1.Height
        .Label58.Width = 90 * Screen.TwipsPerPixelX
        .Label58.Top = .SSPanel5.Height - .Label58.Height - 5 * Screen.TwipsPerPixelY
        .Label58.left = 4 * Screen.TwipsPerPixelX
        .Command30.Width = .Command6.Width
        .Command30.left = .Label58.left + .Label58.Width + 4 * Screen.TwipsPerPixelX
        .Command30.Height = .Command6.Height
        .Command30.Top = .Label58.Top
        .Command30.MouseIcon = .Command18.MouseIcon
        .Command30.MousePointer = 99
        .Command30.Enabled = False
        .Command9.Width = .Command30.Width * 1.75
        .Command9.left = .Command30.left + .Command30.Width
        .Command9.Height = .Command30.Height
        .Command9.Top = .Command30.Top
        .Command9.BackColor = Form1.BackColor
        .VScroll2.Width = 12 * Screen.TwipsPerPixelX
        .VScroll2.left = .SSPanel5.Width - .VScroll2.Width - 4 * Screen.TwipsPerPixelX
        .VScroll2.Height = .Label58.Top - 5 * Screen.TwipsPerPixelY
        .VScroll2.Top = .Picture4.Top
        .Picture5.Top = .VScroll2.Top
        .Picture5.left = .Picture4.left
        .Picture5.Height = .VScroll2.Height
        .Picture5.Width = .VScroll2.left - 8 * Screen.TwipsPerPixelY
        .Picture10.ScaleMode = 1
        .HScroll2.left = .Command9.left + .Command9.Width + 4 * Screen.TwipsPerPixelX
        .HScroll2.Width = .VScroll2.left - .HScroll2.left - 4 * Screen.TwipsPerPixelX
        .HScroll2.Top = .Command30.Top
        .HScroll2.Height = 12 * Screen.TwipsPerPixelY
        .Picture6.Top = 0 * VAddjust
        .Picture6.left = 0 * HAddjust
        '.picture6.ScaleHeight = 2500 * VAddjust
        .Picture6.ScaleWidth = 4200
        .Picture6.FontSize = 6.75 * Screen.TwipsPerPixelY / 14
        .HScroll2.LargeChange = .Picture5.Width
        .Label58.Height = .Label58.Height - 4 * Screen.TwipsPerPixelX
        .Label58.Top = .Label58.Top + 2 * Screen.TwipsPerPixelX

        If RedoPicsFlag = 1 Then

            Call DoInterface

            '.Timer3.Enabled = False
            RedoPicsFlag = 0
            .Picture1.Picture = LoadPicture()
            .Picture4.Enabled = True
            .Picture11.Enabled = True
            .SSPanel11.Visible = True

            Call CalcHomology2(1)

            .Command21.Enabled = True
            .Picture4.ToolTipText = "Identity Display (Window Size =" + CStr(FullWindowSize) + ")"
            .Picture11.ToolTipText = "Identity Display (Window Size =" + CStr(FullWindowSize) + ")"

            If .HScroll1.Value = 0 Then
                .HScroll1.Value = 1
            Else
                .HScroll1.Value = 0
            End If

            'If .Command13(1).Enabled = True Then Call WriteMatrix

            If RunFlag = 1 Then

                Call IntegrateXOvers(0)

                .Picture10.ScaleMode = 3
                .Picture7.ScaleMode = 3
                .Picture10.BackColor = BackColours
                .Picture7.BackColor = BackColours
                
                

                For X = 0 To 3
                    TreeImage(X) = 0
                    'Exit Sub
                Next 'X

                For X = 0 To 3
                    For A = 0 To 3
                        DoneTree(X, A) = 0
                    Next A
                Next X

                Dim Y As Integer


            End If

            '.Visible = True
            '.Timer3.Enabled = True
        End If

        If .Picture26.Picture > 0 Then
            '.Command5.Enabled = True
            .Command10.Enabled = True
        End If

        .ProgressBar1.Value = 0
        .SSPanel1.Caption = ""
        .Refresh
    End With
XX = Form1.ScaleHeight
End Sub
Public Sub Highlight()
     'Highlights recombinant region in the plot display
    If ManFlag > -1 Or TManFlag > 1 Then Exit Sub
    Dim EP As Long, SP As Long, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim ColHL As Long

    If ScanFlagX = 0 Then
        
        For X = 1 To Len(StrainSeq(0))
            Form1.Picture7.DrawMode = 13
            If MissingData(X, Seq1) + MissingData(X, Seq2) + MissingData(X, Seq3) > 0 Then
                    SP = X
                    Do While MissingData(X, Seq1) + MissingData(X, Seq2) + MissingData(X, Seq3) > 0
                      X = X + 1
                      If X > Len(StrainSeq(0)) Then Exit Do
                    Loop
                    EP = X - 1
                    X1 = 30 + SP * XFactor + XFactor
                    X2 = 30 + EP * XFactor + XFactor
                    Y1 = 10
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(197, 197, 255), BF
                    Form1.Picture7.DrawMode = 13
            End If
                    
        Next X
        ColHL = RGB(0, 255, 255)

        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            Y1 = 10
            Y2 = PicHeight - 15
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), ColHL, BF
            Form1.Picture7.DrawMode = 13
        Else
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
            Y1 = 10
            Y2 = PicHeight - 15
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), ColHL, BF
            X1 = 30 + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            Y1 = 10
            Y2 = PicHeight - 15
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), ColHL, BF
            Form1.Picture7.DrawMode = 13
        End If
        
        
    End If

End Sub
Public Sub DrawManBSPlot()

    Dim PosCount As Long, Pict As Long, X As Long
    Dim PntAPI As POINTAPI
    Dim YScaleFactor As Double

    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.BackColor = BackColours
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    SeqLen = Len(StrainSeq(0))

    Call DoAxes(Len(StrainSeq(0)), -1, 100, 0, 0, "Bootstrap support (%)")
    
    'Do cutoff line
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.DrawStyle = 2
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
    Form1.Picture7.DrawStyle = 0
    
    
    Form1.Picture7.DrawWidth = 3

    For X = 1 To NumberOfSeqs
        PosCount = 0
        Form1.Picture7.ForeColor = FFillCol(RevSeq(X))
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
        'Exit Sub

        Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
            PosCount = PosCount + 1
            Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35))
            'Exit Sub
        Loop

    Next 'X

    Form1.Picture7.DrawWidth = 1

    For X = 1 To NumberOfSeqs
        PosCount = 0
        Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)

        Do While PltPos(PosCount + 1) <= Len(StrainSeq(0)) And PltPos(PosCount + 1) > 0
            PosCount = PosCount + 1
            Dummy = LineTo(Pict, 30 + PltPos(PosCount) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35))
        Loop

    Next 'X

    Form1.Picture7.Refresh
    Form1.Picture10.Refresh
End Sub
Public Sub FindSubSeqSS(oSeq As Long)
Y = 0
'Nextno = Nextno
ReDim SSSubSeq(3)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
For X = 1 To Len(StrainSeq(0))
    XPosdiff(X) = Y
    
    'Exit Sub
    If PScores(X) > 0 Then
        Y = Y + 1
        XDiffpos(Y) = X
        XPosdiff(X) = Y
        SSSubSeq(0) = SSSubSeq(0) + Chr(SeqNum(X, Seq1) - 1)
        SSSubSeq(1) = SSSubSeq(1) + Chr(SeqNum(X, Seq2) - 1)
        SSSubSeq(2) = SSSubSeq(2) + Chr(SeqNum(X, Seq3) - 1)
        If RelX > 0 Or RelY > 0 Then
            If oSeq <= NextNo Or XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                SSSubSeq(3) = SSSubSeq(3) + Chr(SeqNum(X, oSeq) - 1)
            End If
        Else
            If oSeq <= NextNo Then
                SSSubSeq(3) = SSSubSeq(3) + Chr(SeqNum(X, oSeq) - 1)
            End If
        End If
    End If
Next X
LenXOverSeq = Y


End Sub
Public Sub SSXoverB(SPF)

Dim oSeq As Long
Dim TraceSub() As Long
ReDim TraceSub(NextNo)
For X = 0 To NextNo
    TraceSub(X) = X
Next X
Call OrderSeqs(TSeq1, tSeq2, tSeq3, Seq1, Seq2, Seq3, TraceSub())


SS = GetTickCount
ossoutlyerflag = SSOutlyerFlag
Dim MaxZ As Double, WPS As Byte, WinNum As Long, LSeq As Long, RndNum As Long
Dim ZPScoreHolder() As Double, ZSScoreHolder() As Double, PScoreHolder() As Long, SScoreHolder() As Long
Dim CUR As Byte, CorrectP As Double

LSeq = Len(StrainSeq(0))

Screen.MousePointer = 11
If SPF = 0 Then
    Form1.SSPanel1.Caption = "Performing SiScan"
End If


If MCFlag = 0 And TManFlag <> 9 Then
    CorrectP = LowestProb / MCCorrection
Else
    CorrectP = 1
End If

If CriticalZ = 0 Then Call GetCriticalZ

Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte
ReDim HRandTemplate(SSWinLen), TakenPos(SSWinLen), VRandTemplate(Len(StrainSeq(0)), SSNumPerms), DoGroupP(1, 2), DoGroupS(1, 2), DG1(15), DG2(14), Seq34Conv(5, 5)

Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())


SSS = GetTickCount

TotalSSRecombinants = 0

If SSStep = 0 Then SSStep = 100

WinNum = LSeq / SSStep + 1



'Triplet specific stuff
ReDim SScoreHolder(WinNum, 14)
ReDim PScoreHolder(WinNum, 15)
ReDim ZPScoreHolder(WinNum, 15)
ReDim ZSScoreHolder(WinNum, 14)

Dim SHPos As Long
Dim PermPScores() As Long
Dim SeqScore3() As Integer
ReDim SeqScore3(LSeq)
Dim MeanPScore() As Double
ReDim MeanPScore(15)
'Dim PScores() As Byte
Dim YPos As Byte
Dim SDPScore() As Double
ReDim SDPScore(15)
Dim HN1 As Byte
Dim HN2 As Byte
Dim HN3 As Byte
Dim Hi As Integer
Dim HV As Integer, LV1 As Integer, LV2 As Integer, HP As Integer, LP1 As Integer, LP2 As Integer
Dim Tally() As Long
'ReDim PermPScores(SSNumPerms, 15)
Dim PermSScores() As Long
ReDim PermSScores(SSNumPerms, 14)

Dim PScores2() As Byte
SSOLSeq = ""
SSOLSeqName = ""


If SSOutlyerFlag = 2 Then
    Call GetOutie
    oSeq = Outie
    SSOLSeq = StrainSeq(oSeq)
    SSOLSeqName = StraiName(oSeq)
ElseIf SSOutlyerFlag = 3 Then
    oSeq = ManSSOLSeq
ElseIf SSOutlyerFlag = 0 Then
    oSeq = NextNo + 1
'ElseIf SSOutlyerFlag = 1 Then
'    oSeq = XOverList(RelX, RelY).LHolder
'    SSOLSeq = StrainSeq(oSeq)
'    SSOLSeqName = StraiName(oSeq)
End If


C = 0

FHPos = 0

If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) And Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
    ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
    HV = 0: LV1 = 1: LV2 = 2
    HP = 2: LP1 = 3: LP2 = 4
ElseIf Distance(Seq1, Seq3) > Distance(Seq1, Seq2) And Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
    ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
    HV = 1: LV1 = 0: LV2 = 2
    HP = 3: LP1 = 2: LP2 = 4
Else
    ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
    HV = 2: LV1 = 0: LV2 = 1
    HP = 4: LP1 = 2: LP2 = 3
End If
            
'Calculate 3 sequence scores
ReDim PScores(Len(StrainSeq(0)))
'This could be speeded up with better nesting
Get3Score SSGapFlag, Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), SeqScore3(0)

Dim OLS As Integer, INS As Integer, CTD As Double
ReDim PScores2(LSeq)
If (RelX > 0 Or RelY > 0) Then
    If (XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum) And CLng(XOverList(RelX, RelY).DHolder) > -1000000 And CLng(Abs(CLng(XOverList(RelX, RelY).DHolder))) <= NextNo Then
        oSeq = Abs(CLng(XOverList(RelX, RelY).DHolder))
        SSOLSeq = StrainSeq(TreeTrace(oSeq))
        SSOLSeqName = StraiName(TreeTrace(oSeq))
    ElseIf (XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum) And (CLng(XOverList(RelX, RelY).DHolder) > NextNo) Then
        SSOutlyerFlag = 0
        oSeq = NextNo + 1
        SSOLSeq = String(Len(StrainSeq(0)), " ")
        SSOLSeqName = "Randomised"
    Else
    
        If X = X Then
            SSOutlyerFlag = pSSOutlyerFlag
            Call GetSSOutlyer(oSeq, 1, TraceSub())
                
        Else
            If SSOutlyerFlag = 1 Then ' Find outlyer seq if necessary 0 = use rndseq, 2 = use most distant seq
                
                Do
                    If TreeDistance(Seq1, Seq2) > TreeDistance(Seq1, Seq3) Then
                        INS = Seq1: OLS = Seq3
                    ElseIf TreeDistance(Seq1, Seq3) > TreeDistance(Seq1, Seq2) Then
                        INS = Seq1: OLS = Seq2
                    ElseIf TreeDistance(Seq2, Seq3) > TreeDistance(Seq1, Seq2) Then
                        INS = Seq2: OLS = Seq1
                    End If
                    CTD = 0
                    For X = 0 To NextNo
                        If TreeDistance(OLS, X) < TreeDistance(OLS, INS) And TreeDistance(OLS, X) >= CTD And X <> OLS Then
                            If TreeDistance(OLS, X) = CTD Then
                                If Distance(OLS, X) > Distance(OLS, oSeq) Then
                                    oSeq = X
                                    CTD = TreeDistance(OLS, X)
                                    SSOLSeq = StrainSeq(oSeq)
                                    SSOLSeqName = StraiName(oSeq)
                                End If
                            Else
                                oSeq = X
                                CTD = TreeDistance(OLS, X)
                                SSOLSeq = StrainSeq(oSeq)
                                SSOLSeqName = StraiName(oSeq)
                            End If
                        End If
                    Next X
                    
                    If CTD > 0 Then
                        Exit Do
                    Else
                        SSOutlyerFlag = 0
                        SSOLSeq = String(Len(StrainSeq(0)), " ")
                        SSOLSeqName = "Randomised"
                        Exit Do
                    End If
                Loop
            ElseIf SSOutlyerFlag = 0 Then
                SSOLSeq = String(Len(StrainSeq(0)), " ")
                SSOLSeqName = "Randomised"
            End If
        End If
    End If
Else

    If NextNo = 2 Then
        SSOutlyerFlag = 0
        oSeq = NextNo + 1
        SSOLSeq = String(Len(StrainSeq(0)), " ")
        SSOLSeqName = "Randomised"
    End If
End If
            

SSOLoSeq = oSeq
            
'Construct horizontal randomisation array (used for every window)to generate the
'fourth randomised sequence
            
Dim ZMax As Double, ZMin As Double

ZMax = -10
ZMin = 10


'Examine the windows
If oSeq = -1 Then oSeq = Outie
If X = X Then 'SPF = 0 Then
    If SPF = 0 Then
        Form1.ProgressBar1 = 20
    End If
    For X = 1 To LSeq - SSWinLen Step SSStep
        'Quick check to see if this window is worth examining
        SHPos = CLng(X / SSStep)
        If FHPos = 0 Then FHPos = SHPos
        If SSOutlyerFlag = 0 Then
            
            'ReDim Preserve SeqNum(Len(StrainSeq(0)), Nextno + 1)
            xxx = UBound(PScores)
            If X = 12345 Then
                ReDim PScores(15)
                
                oSeq = NextNo + 1
                
                GetPScoresRnd X, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate(0)
                
                For Y = 0 To SSWinLen - 1
                    Mid(SSOLSeq, X + Y, 1) = Mid$(StrainSeq(Seq1), X + HRandTemplate(Y + 1), 1)
                Next ' Y
            Else
            
                For Y = 0 To SSWinLen - 1
                    HN = SeqScore3(X + Y)
                    Hi = X + HRandTemplate(Y + 1)
                    Hi = SeqNum(Hi, Seq1)
                    Mid(SSOLSeq, X + Y, 1) = Mid$(StrainSeq(Seq1), X + HRandTemplate(Y + 1), 1)
                    SeqNum(X + Y, NextNo + 1) = Hi
                    If SeqNum(X + Y, Seq1) = Hi Then
                        PScores(Y + 1) = Seq34Conv(HN, 1)
                    Else
                        Select Case HN
                            Case 1
                                If SeqNum(X + Y, Seq2) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 2)
                                ElseIf SeqNum(X + Y, Seq3) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 3)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 2
                                If SeqNum(X + Y, Seq3) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 3)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 3, 4
                                If SeqNum(X + Y, Seq2) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 2)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 5
                                PScores(Y + 1) = Seq34Conv(HN, 4)
                        End Select
                    End If
                Next ' Y
            End If
        Else
            GetPScores X, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
        End If
                        
                        
                        
                        
        'Do Perms
        'Calculate actual scores
        ReDim PermPScores(SSNumPerms, 15)
                        
        Dummy = DoPerms(Len(StrainSeq(0)), SSWinLen, SSNumPerms, PScores(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
                        
        XD = MakeZValue(SHPos, WinNum, 15, SSNumPerms, DG1(0), PermPScores(0, 0), ZPScoreHolder(0, 0))
                        
        SScoreHolder(SHPos, 1) = PermPScores(0, 2) + PermPScores(0, 7) + PermPScores(0, 8)
        SScoreHolder(SHPos, 2) = PermPScores(0, 3) + PermPScores(0, 6) + PermPScores(0, 9)
        SScoreHolder(SHPos, 3) = PermPScores(0, 4) + PermPScores(0, 5) + PermPScores(0, 10)
        SScoreHolder(SHPos, 4) = PermPScores(0, 2) + PermPScores(0, 8) + PermPScores(0, 11) + PermPScores(0, 12)
        SScoreHolder(SHPos, 5) = PermPScores(0, 3) + PermPScores(0, 9) + PermPScores(0, 11) + PermPScores(0, 13)
        SScoreHolder(SHPos, 6) = PermPScores(0, 4) + PermPScores(0, 10) + PermPScores(0, 12) + PermPScores(0, 13)
        SScoreHolder(SHPos, 7) = PermPScores(0, 5) + PermPScores(0, 10) + PermPScores(0, 11) + PermPScores(0, 14)
        SScoreHolder(SHPos, 8) = PermPScores(0, 6) + PermPScores(0, 9) + PermPScores(0, 12) + PermPScores(0, 14)
        SScoreHolder(SHPos, 9) = PermPScores(0, 7) + PermPScores(0, 8) + PermPScores(0, 13) + PermPScores(0, 14)
        SScoreHolder(SHPos, 10) = PermPScores(0, 2) + PermPScores(0, 8) + PermPScores(0, 12) ' + PermPScores(0, 11)
        SScoreHolder(SHPos, 11) = PermPScores(0, 3) + PermPScores(0, 9) + PermPScores(0, 13) ' + PermPScores(0, 11)
        SScoreHolder(SHPos, 12) = PermPScores(0, 5) + PermPScores(0, 10) + PermPScores(0, 14) '+ PermPScores(0, 11)
                        
        For Z = 0 To SSNumPerms
            PermSScores(Z, 1) = PermPScores(Z, 2) + PermPScores(Z, 7) + PermPScores(Z, 8)
            PermSScores(Z, 2) = PermPScores(Z, 3) + PermPScores(Z, 6) + PermPScores(Z, 9)
            PermSScores(Z, 3) = PermPScores(Z, 4) + PermPScores(Z, 5) + PermPScores(Z, 10)
            PermSScores(Z, 4) = PermPScores(Z, 2) + PermPScores(Z, 8) + PermPScores(Z, 11) + PermPScores(Z, 12)
            PermSScores(Z, 5) = PermPScores(Z, 3) + PermPScores(Z, 9) + PermPScores(Z, 11) + PermPScores(Z, 13)
            PermSScores(Z, 6) = PermPScores(Z, 4) + PermPScores(Z, 10) + PermPScores(Z, 12) + PermPScores(Z, 13)
            PermSScores(Z, 7) = PermPScores(Z, 5) + PermPScores(Z, 10) + PermPScores(Z, 11) + PermPScores(Z, 14)
            PermSScores(Z, 8) = PermPScores(Z, 6) + PermPScores(Z, 9) + PermPScores(Z, 12) + PermPScores(Z, 14)
            PermSScores(Z, 9) = PermPScores(Z, 7) + PermPScores(Z, 8) + PermPScores(Z, 13) + PermPScores(Z, 14)
            PermSScores(Z, 10) = PermPScores(Z, 2) + PermPScores(Z, 8) + PermPScores(Z, 12) '+ PermPScores(Z, 11)
            PermSScores(Z, 11) = PermPScores(Z, 3) + PermPScores(Z, 9) + PermPScores(Z, 13) '+ PermPScores(Z, 11)
            PermSScores(Z, 12) = PermPScores(Z, 5) + PermPScores(Z, 10) + PermPScores(Z, 14) '+ PermPScores(Z, 11)
        Next Z
        
        XD = MakeZValue(SHPos, WinNum, 12, SSNumPerms, DG2(0), PermSScores(0, 0), ZSScoreHolder(0, 0))
                    
        For Z = 1 To 15
            If ZPScoreHolder(SHPos, Z) > ZMax Then
                ZMax = ZPScoreHolder(SHPos, Z)
            ElseIf ZPScoreHolder(SHPos, Z) < ZMin Then
                ZMin = ZPScoreHolder(SHPos, Z)
            End If
        Next Z
        
        For Z = 1 To 12
            If ZSScoreHolder(SHPos, Z) > ZMax Then
                ZMax = ZSScoreHolder(SHPos, Z)
            ElseIf ZSScoreHolder(SHPos, Z) < ZMin Then
                ZMin = ZSScoreHolder(SHPos, Z)
            End If
        Next Z
        If SPF = 0 Then
            Form1.ProgressBar1 = 20 + (X / Len(StrainSeq(0))) * 75
        End If
    Next 'x
End If
ReDim XDiffpos(Len(StrainSeq(0)) + 200), XPosdiff(Len(StrainSeq(0)) + 200), PScores(Len(StrainSeq(0)))

GetPScores 1, Len(StrainSeq(0)), Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)

For X = 1 To Len(StrainSeq(0))
    PScores(X) = Abs(PScores(X) * (DG1(PScores(X)) - 1))
Next X



    Call FindSubSeqSS(oSeq) '(oSeq)
If SPF = 0 Then
    
    If ZMax < CriticalZ Then ZMax = CriticalZ
    If ZMin > -CriticalZ Then ZMin = -CriticalZ
    
    Call DoAxes(Len(StrainSeq(0)), -1, ZMax, ZMin, 1, "Z - Score")
    
    SSUp = ZMax
    SSLo = ZMin
    
    Form1.Picture7.DrawWidth = 3
    
    Dim PntAPI As POINTAPI
    
    Y = 4
    
    
    ReDim MCPrintPos(Len(StrainSeq(0))), MCPrintData(1, 15, Len(StrainSeq(0))), PltCol(15), PltCol2(12)
    
    For X = 0 To 15
        PltCol(X) = RGB(240, 240, 240)
    Next X
    For X = 0 To 9
        PltCol2(X) = RGB(240, 240, 240)
    Next X
    
    mYellow = RGB(225, 225, CInt(BkB - BkB / 2))
    mPurple = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
    mGreen = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 6))
    
    
    If TSeq1 = Seq3 And tSeq2 = Seq2 Then
        PltCol(2) = mPurple 'mYellow
        PltCol(3) = Green 'mPurple
        PltCol(5) = mYellow 'Green
        PltCol(8) = mPurple 'mYellow
        PltCol(9) = Green 'mPurple
        PltCol(10) = mYellow 'Green
        PltCol2(1) = mPurple 'mYellow
        PltCol2(2) = Green 'mPurple
        PltCol2(3) = mYellow 'Green
        PltCol2(4) = mPurple 'mYellow
        PltCol2(5) = Green 'mPurple
        PltCol2(7) = mYellow 'Green
    ElseIf TSeq1 = Seq2 And tSeq2 = Seq3 Then
        PltCol(2) = Green 'mYellow
        PltCol(3) = mPurple
        PltCol(5) = mYellow 'Green
        PltCol(8) = Green 'mYellow
        PltCol(9) = mPurple
        PltCol(10) = mYellow 'Green
        PltCol2(1) = Green 'mYellow
        PltCol2(2) = mPurple
        PltCol2(3) = mYellow 'Green
        PltCol2(4) = Green 'mYellow
        PltCol2(5) = mPurple
        PltCol2(7) = mYellow 'Green
    ElseIf TSeq1 = Seq1 And tSeq2 = Seq2 Then
        PltCol(2) = mYellow
        PltCol(3) = Green 'mPurple
        PltCol(5) = mPurple 'Green
        PltCol(8) = mYellow
        PltCol(9) = Green 'mPurple
        PltCol(10) = mPurple 'Green
        PltCol2(1) = mYellow
        PltCol2(2) = Green 'mPurple
        PltCol2(3) = mPurple 'Green
        PltCol2(4) = mYellow
        PltCol2(5) = Green 'mPurple
        PltCol2(7) = mPurple 'Green
    ElseIf TSeq1 = Seq1 And tSeq2 = Seq3 Then
        PltCol(2) = Green 'mPurple 'mYellow
        PltCol(3) = mYellow 'Green 'mPurple
        PltCol(5) = mPurple 'mYellow 'Green
        PltCol(8) = Green 'mPurple 'mYellow
        PltCol(9) = mYellow 'Green 'mPurple
        PltCol(10) = mPurple 'mYellow 'Green
        PltCol2(1) = Green 'mPurple 'mYellow
        PltCol2(2) = mYellow 'Green 'mPurple
        PltCol2(3) = mPurple 'mYellow 'Green
        PltCol2(4) = Green 'mPurple 'mYellow
        PltCol2(5) = mYellow 'Green 'mPurple
        PltCol2(7) = mPurple 'mYellow 'Green
    ElseIf TSeq1 = Seq2 And tSeq2 = Seq1 Then
        PltCol(2) = mYellow
        PltCol(3) = mPurple
        PltCol(5) = Green
        PltCol(8) = mYellow
        PltCol(9) = mPurple
        PltCol(10) = Green
        PltCol2(1) = mYellow
        PltCol2(2) = mPurple
        PltCol2(3) = Green
        PltCol2(4) = mYellow
        PltCol2(5) = mPurple
        PltCol2(7) = Green
    ElseIf tSeq2 = Seq1 And tSeq3 = Seq2 Then
        'this has been wrong once before
        PltCol(2) = mPurple 'mYellow
        PltCol(3) = mYellow 'Green 'mPurple
        PltCol(5) = Green
        PltCol(8) = mPurple 'mYellow
        PltCol(9) = mYellow 'Green 'mPurple
        PltCol(10) = Green
        PltCol2(1) = mPurple 'mYellow
        PltCol2(2) = mYellow 'Green 'mPurple
        PltCol2(3) = Green
        PltCol2(4) = mPurple 'mYellow
        PltCol2(5) = mYellow 'Green 'mPurple
        PltCol2(7) = Green
    Else
        PltCol(2) = Green 'mPurple 'mYellow
        PltCol(3) = mYellow 'Green 'mPurple
        PltCol(5) = mPurple 'mYellow 'Green
        PltCol(8) = Green 'mPurple 'mYellow
        PltCol(9) = mYellow 'Green 'mPurple
        PltCol(10) = mPurple 'mYellow 'Green
        PltCol2(1) = Green 'mPurple 'mYellow
        PltCol2(2) = mYellow 'Green 'mPurple
        PltCol2(3) = mPurple 'mYellow 'Green
        PltCol2(4) = Green 'mPurple 'mYellow
        PltCol2(5) = mYellow 'Green 'mPurple
        PltCol2(7) = mPurple 'mYellow 'Green
    End If
    
    
    ReDim PltCol3(15)
    
    Form1.ProgressBar1 = 100
    
    For X = 0 To 15
        PltCol3(X) = PltCol(X)
        XX = RGB(240, 240, 240)
        If PltCol3(X) = Green Then
            PltCol3(X) = mGreen
        
        ElseIf PltCol(X) = RGB(240, 240, 240) Then
            PltCol3(X) = HalfColour
        End If
    Next X
    Dim HLT(2)
    Dim FST As Byte
    If TManFlag <> 9 Then
        If XOverList(RelX, RelY).ProgramFlag <> 0 And XOverList(RelX, RelY).LHolder <> 0 + AddNum And XOverList(RelX, RelY).LHolder >= 11 And XOverList(RelX, RelY).LHolder <= 13 Then
            FST = 0
            HLT(0) = 1
            HLT(1) = 2
            HLT(2) = 3
            For Z = 1 To 3
                If PltCol2(Z) = mPurple Then
                    PltCol2(Z) = LPurple
                    'PltCol3(Z) = Purple
                ElseIf PltCol2(Z) = mYellow Then
                    PltCol2(Z) = LYellow
                    'PltCol3(Z) = Yellow
                ElseIf PltCol2(Z) = Green Then
                    PltCol2(Z) = LGreen
                    'PltCol3(Z) = Green
                End If
            Next Z
            
            
            'PltCol2(1) = LGreen
            'PltCol2(2) = LPurple
            'PltCol2(3) = LYellow
            
            'PltCol3(2) = Green
            'PltCol3(3) = Purple
            
            PltCol3(7) = Green
            PltCol3(6) = Purple
            
            PltCol3(8) = Green
            PltCol3(9) = Purple
            PltCol3(10) = Yellow
            PltCol3(4) = Yellow
            PltCol3(5) = Yellow
            
            
            If DG1(11) = 0 Then
                PltCol3(11) = RGB(230, 230, 160)
            End If
            
        ElseIf XOverList(RelX, RelY).LHolder >= 14 And XOverList(RelX, RelY).LHolder <= 17 Then
            FST = 0
            HLT(0) = 4
            HLT(1) = 5
            HLT(2) = 7
            For Z = 4 To 7
                If PltCol2(Z) = mPurple Then
                    PltCol2(Z) = LPurple
                   ' PltCol3(Z) = Purple
                ElseIf PltCol2(Z) = mYellow Then
                    PltCol2(Z) = LYellow
                   ' PltCol3(Z) = Yellow
                ElseIf PltCol2(Z) = Green Then
                    PltCol2(Z) = LGreen
                   ' PltCol3(Z) = Green
                End If
            Next Z
            
            PltCol3(2) = PltCol2(4)
            PltCol3(3) = PltCol2(5)
            PltCol3(5) = PltCol2(7)
            PltCol3(8) = PltCol2(4)
            PltCol3(9) = PltCol2(5)
            PltCol3(10) = PltCol2(7)
            PltCol3(12) = PltCol2(4)
            PltCol3(13) = PltCol2(5)
            PltCol3(14) = PltCol2(7)
            
            For Z = 1 To 14
                If PltCol3(Z) = LPurple Then
                    PltCol3(Z) = Purple
                ElseIf PltCol3(Z) = LYellow Then
                    PltCol3(Z) = Yellow
                ElseIf PltCol3(Z) = LGreen Then
                    PltCol3(Z) = Green
                End If
            
            Next Z
            'If DG1(11) = 0 Then
            
            
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        ElseIf XOverList(RelX, RelY).LHolder >= 2 And XOverList(RelX, RelY).LHolder <= 5 Then
            FST = 1
            HLT(0) = 2
            HLT(1) = 3
            HLT(2) = 5
            
            For Z = 2 To 5
                If PltCol(Z) = mPurple Then
                    PltCol(Z) = LPurple
                    PltCol3(Z) = Purple
                ElseIf PltCol(Z) = mYellow Then
                    PltCol(Z) = LYellow
                    PltCol3(Z) = Yellow
                ElseIf PltCol(Z) = Green Then
                    PltCol(Z) = LGreen
                    PltCol3(Z) = Green
                End If
            Next Z
            
            'PltCol(2) = LGreen
            'PltCol(3) = LPurple
            'PltCol(5) = LYellow
            
            'PltCol3(2) = Green
            'PltCol3(3) = Purple
            'PltCol3(5) = Yellow
            'If DG1(11) = 0 Then
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        ElseIf XOverList(RelX, RelY).LHolder >= 8 And XOverList(RelX, RelY).LHolder <= 10 Then
            FST = 1
            HLT(0) = 8
            HLT(1) = 9
            HLT(2) = 10
            For Z = 8 To 10
                If PltCol(Z) = mPurple Then
                    PltCol(Z) = LPurple
                    PltCol3(Z) = Purple
                ElseIf PltCol(Z) = mYellow Then
                    PltCol(Z) = LYellow
                    PltCol3(Z) = Yellow
                ElseIf PltCol(Z) = Green Then
                    PltCol(Z) = LGreen
                    PltCol3(Z) = Green
                End If
            Next Z
            
            'PltCol(8) = LGreen
            'PltCol(9) = LPurple
            'PltCol(10) = LYellow
            'PltCol3(8) = Green
            'PltCol3(9) = Purple
            'PltCol3(10) = Yellow
            'If DG1(11) = 0 Then
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        End If
    End If
    
    Form1.Picture7.DrawWidth = 3
    CUR = 0
    
    
    If RelX > 0 Or RelY > 0 Then
        If XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            If FST = 0 Then
                Do
                    Form1.Picture7.ForeColor = PltCol2(HLT(CUR))
                    Y = HLT(CUR)
                    Pict = Form1.Picture7.hdc
                    
                        MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                        SPos = 1
                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                            LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                            SPos = SPos + 1
                        Next X
                    
                    CUR = CUR + 1
                    If CUR = 3 Then Exit Do
                Loop
            Else
                Do
                    Form1.Picture7.ForeColor = PltCol(HLT(CUR))
                    Y = HLT(CUR)
                    Pict = Form1.Picture7.hdc
                    
                    MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                    SPos = 1
                    For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                        LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                        SPos = SPos + 1
                    Next X
                    CUR = CUR + 1
                    If CUR = 3 Then Exit Do
                Loop
            End If
        End If
    End If
    Form1.Picture7.DrawWidth = 1
    
    Call Highlight
    XX = StraiName(TSeq1)
    XX = StraiName(tSeq2)
    XX = StraiName(tSeq3)
    Call WriteNames(TSeq1, tSeq2, tSeq3, Yellow, Green, Purple)
    SPos = 0
    For X = 1 To LSeq - SSWinLen Step SSStep
        MCPrintPos(SPos) = X + SSWinLen / 2
        SPos = SPos + 1
    Next X
    
    For Y = 1 To 15
        If PltCol(Y) = PltCol(15) Then
            Form1.Picture7.ForeColor = PltCol(Y)
            Pict = Form1.Picture7.hdc
            'If DG1(Y) = 0 and Then
                MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                MCPrintData(0, Y, 0) = ZPScoreHolder(0, Y)
                SPos = 1
                For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                    'If ZPScoreHolder(SPos, Y) > 0 Then
                        LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                    'End If
                    MCPrintData(0, Y, SPos) = ZPScoreHolder(SPos, Y)
                    SPos = SPos + 1
                    
                Next X
            'End If
        End If
    Next Y
    
    Form1.Picture7.DrawWidth = 1
    'Zero Line
    'Form1.Picture7.ForeColor = RGB(0, 0, 0)
    'Pict = Form1.Picture7.hdc
    'MoveToEx Pict, 25, (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
    'LineTo Pict, (30 + Len(StrainSeq(0)) * XFactor), (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    'Critical Z lines
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, (PicHeight - (15 + ((CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
    LineTo Pict, (30 + Len(StrainSeq(0)) * XFactor), (PicHeight - (15 + ((CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, (PicHeight - (15 + ((-CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
    LineTo Pict, (30 + Len(StrainSeq(0)) * XFactor), (PicHeight - (15 + ((-CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    Form1.Picture7.DrawStyle = 0
    
    
    For Y = 1 To 9
        If PltCol2(Y) = PltCol2(9) Then
            Form1.Picture7.ForeColor = PltCol2(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            MCPrintData(1, Y, 0) = ZSScoreHolder(0, Y)
            SPos = 1
            For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                MCPrintData(1, Y, SPos) = ZSScoreHolder(SPos, Y)
                SPos = SPos + 1
            Next X
        End If
    Next Y
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
    LineTo Pict, (30 + Len(StrainSeq(0)) * XFactor), (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    For Y = 1 To 15
        If PltCol(Y) <> PltCol(15) Then
            Form1.Picture7.ForeColor = PltCol(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            MCPrintData(0, Y, 0) = ZPScoreHolder(0, Y)
            SPos = 1
            For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                MCPrintData(0, Y, SPos) = ZPScoreHolder(SPos, Y)
                SPos = SPos + 1
            Next X
        End If
    Next Y
    
    For Y = 1 To 9
        If PltCol2(Y) <> PltCol2(9) Then
            Form1.Picture7.ForeColor = PltCol2(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            MCPrintData(1, Y, 0) = ZSScoreHolder(0, Y)
            SPos = 1
            For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                MCPrintData(1, Y, SPos) = ZSScoreHolder(SPos, Y)
                SPos = SPos + 1
            Next X
        End If
    Next Y
    Form1.Picture7.DrawWidth = 1
    
    
    'Zero Line
    
    
    Form1.Picture7.DrawStyle = 0
    
    Y = 4
    CUR = 0
    If X = 12345 Then
    PltCol(2) = mGreen
    PltCol(3) = LPurple
    PltCol(5) = LYellow
    PltCol(8) = mGreen
    PltCol(9) = LPurple
    PltCol(10) = LYellow
    PltCol2(1) = mGreen
    PltCol2(2) = LPurple
    PltCol2(3) = LYellow
    PltCol2(4) = mGreen
    PltCol2(5) = LPurple
    PltCol2(7) = LYellow
    End If
    If RelX > 0 Or RelY > 0 Then
        If XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            If FST = 0 Then
                For Z = 0 To 1
                    If Z = 0 Then
                        Form1.Picture7.DrawWidth = 2
                        For A = 0 To 2
                            If PltCol2(HLT(A)) = mGreen Or PltCol2(HLT(A)) = Green Or PltCol2(HLT(A)) = LGreen Then
                                PltCol2(HLT(A)) = mGreen
                            ElseIf PltCol2(HLT(A)) = mPurple Or PltCol2(HLT(A)) = Purple Or PltCol2(HLT(A)) = LPurple Then
                                PltCol2(HLT(A)) = mPurple
                            Else
                                PltCol2(HLT(A)) = mYellow
                            End If
                        
                        Next A
                    Else
                        Form1.Picture7.DrawWidth = 1
                        For A = 0 To 2
                            If PltCol2(HLT(A)) = mGreen Or PltCol2(HLT(A)) = Green Or PltCol2(HLT(A)) = LGreen Then
                                PltCol2(HLT(A)) = Green
                            ElseIf PltCol2(HLT(A)) = mPurple Or PltCol2(HLT(A)) = Purple Or PltCol2(HLT(A)) = LPurple Then
                                PltCol2(HLT(A)) = Purple
                            Else
                                PltCol2(HLT(A)) = Yellow
                            End If
                        
                        Next A
                    End If
                    CUR = 0
                    Do
                        Form1.Picture7.ForeColor = PltCol2(HLT(CUR))
                        Y = HLT(CUR)
                        Pict = Form1.Picture7.hdc
                        
                        MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                        SPos = 1
                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                            LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                            SPos = SPos + 1
                        Next X
                        CUR = CUR + 1
                        If CUR = 3 Then Exit Do
                    Loop
                    X = X
                Next Z
            Else
                For Z = 0 To 1
                    If Z = 0 Then
                        Form1.Picture7.DrawWidth = 2
                        PltCol(HLT(0)) = mGreen
                        PltCol(HLT(1)) = mPurple
                        PltCol(HLT(2)) = mYellow
                    Else
                        Form1.Picture7.DrawWidth = 1
                        PltCol(HLT(0)) = Green
                        PltCol(HLT(1)) = Purple
                        PltCol(HLT(2)) = Yellow
                    End If
                    CUR = 0
                    Do
                        Form1.Picture7.ForeColor = PltCol(HLT(CUR))
                        Y = HLT(CUR)
                        Pict = Form1.Picture7.hdc
                        
                        MoveToEx Pict, (30 + (SSWinLen / 2) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                        SPos = 1
                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
                            LineTo Pict, (30 + (X + (SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                            SPos = SPos + 1
                        Next X
                        CUR = CUR + 1
                        If CUR = 3 Then Exit Do
                    Loop
                Next Z
            End If
        End If
    End If
    PltCol3(0) = RGB(64, 64, 64)
End If

Dim TB As Long, TE As Long




If TManFlag <> 9 Then
    
    TB = XOverList(RelX, RelY).Beginning
    TE = XOverList(RelX, RelY).Ending
    MaxZ = 0
    
    
    
    
    Dim MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If ExeCheckFlag = 1 Or OptFlag = 9 Or XOverList(RelX, RelY).ProgramFlag = 5 Or XOverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                                        Dim LRegion As Long
                                        If TB < TE Then
                                            LRegion = TE - TB + 1
                                        Else
                                            LRegion = TE + (Len(StrainSeq(0)) - TB + 1)
                                        End If
                                        'If LRegion > Len(StrainSeq(0)) / 4 Then LRegion = Len(StrainSeq(0)) / 4
                                        

                                        If SSOutlyerFlag = 0 Then
                                            ReDim PScores2(15)
                                            Dim HRandTemplate2() As Long
                                            ReDim HRandTemplate2(LRegion)
                                            ReDim TakenPos(LRegion)
                                            For Z = 1 To LRegion
                                                RndNum = Int((LRegion * Rnd) + 1)
                                                If TakenPos(RndNum) = 0 Then
                                                    HRandTemplate2(Z) = RndNum
                                                    TakenPos(RndNum) = 1
                                                Else 'find next available position to the right
                                                    Y = RndNum
                                                    Do While TakenPos(Y) = 1
                                                        Y = Y + 1
                                                        If Y > LRegion Then Y = 1
                                                    Loop
                                                    HRandTemplate2(Z) = Y
                                                    TakenPos(Y) = 1
                                                End If
                                            Next 'X
                                            
                                            GetPScoresRnd TB, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores2(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate2(0)
                                            
                                            
                                        Else
                                            ReDim PScores2(15)
                                            GetPScores2 TB, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores2(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
                                        End If
                                        
                                      
                                        Dim tZPScore() As Double, tZSScore() As Double
                                        ReDim tZPScore(1, 15)
                                        ReDim tZSScore(1, 14)
                                        ReDim PermPScores(SSNumPerms, 15)
                                        Dummy = DoPerms3(Len(StrainSeq(0)), LRegion, SSNumPerms, PScores2(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
                                        MakeZValue 0, 1, 15, SSNumPerms, DG1(0), PermPScores(0, 0), tZPScore(0, 0)
                                        
                                        DoSums SSNumPerms, PermSScores(0, 0), PermPScores(0, 0)
                                
                                        SScoreHolder(SHPos, 1) = PermSScores(0, 1)
                                        SScoreHolder(SHPos, 2) = PermSScores(0, 2)
                                        SScoreHolder(SHPos, 3) = PermSScores(0, 3)
                                        SScoreHolder(SHPos, 4) = PermSScores(0, 4)
                                        SScoreHolder(SHPos, 5) = PermSScores(0, 5)
                                        SScoreHolder(SHPos, 7) = PermSScores(0, 7)
                                    
                                        'Calculate Z Scores
                                        MakeZValue 0, 1, 12, SSNumPerms, DG2(0), PermSScores(0, 0), tZSScore(0, 0)
                                        
                                        
                                        
                                        
                                        
                                        WinP = 0
                                        WPS = 0
                                        
                                        If X = 12345 Then
                                            For Z = 0 To 15
                                                If tZPScore(0, Z) > MaxZ Then
                                                    MaxZ = tZPScore(0, Z)
                                                    WinP = Z
                                                    WinScore = Z
                                                    WPS = 1
                                                End If
                                            Next Z
                                            For Z = 0 To 14
                                                If tZSScore(0, Z) > MaxZ Then
                                                    MaxZ = tZSScore(0, Z)
                                                    WinP = Z
                                                    WinScore = Z
                                                    WPS = 2
                                                End If
                                            Next Z
                                            X = X
                                        Else
                                        
                                        
                                            For Z = 0 To 1
                                                'If tZPScore(0, DoGroupP(Z, HV)) < tZPScore(0, DoGroupP(Z, LV1)) Or tZPScore(0, DoGroupP(Z, HV)) < tZPScore(0, DoGroupP(Z, LV2)) Then
                                                    
                                                    For Y = 0 To 2
                                                        If Y <> HV Then
                                                            If Abs(tZPScore(0, DoGroupP(Z, Y))) > MaxZ Then
                                                                
                                                                MaxZ = Abs(tZPScore(0, DoGroupP(Z, Y)))
                                                                WinScore = DoGroupP(Z, Y)
                                                                WPS = 1
                                                            End If
                                                        End If
                                                    Next Y
                                                'End If
                                            Next Z
                                            For Z = 0 To 1
                                                'If tZSScore(0, DoGroupS(Z, HV)) < tZSScore(0, DoGroupS(Z, LV1)) Or tZSScore(0, DoGroupS(Z, HV)) < tZSScore(0, DoGroupS(Z, LV2)) Then
                                                    For Y = 0 To 2
                                                            If Y <> HV Then
                                                                If Abs(tZSScore(0, DoGroupS(Z, Y))) > MaxZ Then
                                                                    MaxZ = Abs(tZSScore(0, DoGroupS(Z, Y)))
                                                                    WinScore = DoGroupS(Z, Y)
                                                                    WPS = 2
                                                                End If
                                                            End If
                                                    Next Y
                                                'End If
                                            Next Z
                                            X = X
                                        End If
        
        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            sizer = (XOverList(RelX, RelY).Ending - XOverList(RelX, RelY).Beginning)
        Else
            sizer = (XOverList(RelX, RelY).Ending + Len(StrainSeq(0)) - XOverList(RelX, RelY).Beginning)
        End If
        WinP = NormalZ(MaxZ)
        WinP = WinP * (Len(StrainSeq(0)) / sizer)
        If MCFlag = 0 Then
            WinP = WinP * MCCorrection
        ElseIf pMCFlag = 2 Then
            WinP = StepDown2(5, WinP)
        End If
        ProbTest = Str(WinP)
        MinPA = WinP
    Else
        ProbTest = XOverList(RelX, RelY).Probability
        
    End If
    If TB < TE Then
        ProbX = TB + (TE - TB) / 2
    Else
        ProbX = 1 + (TE - 1) / 2
    End If
    'Dim ProbTest As String
    ProbY = 1

    
    If MinPA < 1 Then
        If SPF = 0 Then Call PrintProbability
    End If
End If



If RelX > 0 Or RelY > 0 Then
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    If XOverList(RelX, RelY).ProgramFlag <> 5 And XOverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
        PT = 10 ^ (-ConfirmP(EN, 5))
                
        If (Confirm(EN, 5) = 0 Or (Confirm(EN, 5) = 1 And MinPA < PT)) And MinPA < 1 Then
            Confirm(EN, 5) = 1
            ConfirmP(EN, 5) = -Log10(MinPA)
            DoEvents

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

    End If

End If




SSOutlyerFlag = ossoutlyerflag
Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5



Seq1 = TSeq1: Seq2 = tSeq2: Seq3 = tSeq3
If SPF = 0 Then
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
End If
EE = GetTickCount
TT = EE - SS
End Sub


Public Sub BSXoverL(SPF)
    'Routine used to retrieve automated bootscan data from the file "BSScanData"
    If SPF = 1 Then Exit Sub
    Dim NumSets As Long, Y As Long, X As Long, TSeq1 As Long, tSeq2 As Long, tSeq3 As Long
    Dim ODir As String

    BSTypeFlag = pBSTypeFlag
    BSStepSize = pBSStepSize
    BSStepWin = pBSStepWin
    BSBootReps = pBSBootReps
    Form1.SSPanel1.Caption = "Retrieving Bootscan Data"
    Form1.ProgressBar1.Value = 5
    'Set appropriate directory location
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    NumberOfSeqs = 0
    ReDim Preserve pMaskSeq(NextNo), SubMaskSeq(NextNo), RevSeq(NextNo)
    
        For X = 0 To NextNo

            If pMaskSeq(X) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = X
                RevSeq(X) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
                
            End If

        Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    NumSets = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    ReDim PltPos(NumSets + 1)

    Dim NSets As Long

    NSets = NumSets - 1

    For Z = 0 To NSets
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    Dim FF As Integer

    FF = FreeFile
    Open BSFileName For Binary Access Read As #FF
    ReDim PltVal(2, NumSets)

    Dim T0() As Integer
    Dim T1() As Integer
    Dim T2() As Integer
    ReDim T0(BSBootReps * (NumSets + 1) - 1)
    ReDim T1(BSBootReps * (NumSets + 1) - 1)
    ReDim T2(BSBootReps * (NumSets + 1) - 1)
    'ReDim T0(BSBootReps - 1)
    'ReDim T1(BSBootReps - 1)
    'ReDim T2(BSBootReps - 1)
    Get #FF, (BSFilePos(TreeTrace(Seq1), TreeTrace(Seq2)) * BSBootReps * (NumSets) * 2 + 1), T0()
    Get #FF, (BSFilePos(TreeTrace(Seq1), TreeTrace(Seq3)) * BSBootReps * (NumSets) * 2 + 1), T1()
    Get #FF, (BSFilePos(TreeTrace(Seq2), TreeTrace(Seq3)) * BSBootReps * (NumSets) * 2 + 1), T2()
                                       
    For Y = 0 To NumSets
        'this coluld be speeded up with better nesting of if then's
X = X
        GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
        Form1.ProgressBar1.Value = 5 + (Y / NumSets) * 80
    Next 'Y
    

   ' For Y = 0 To NumSets
   '     Get #FF, BSFilePos(Seq1, Seq2) * BSRWSize + Y * BSWinRWChunk + 1, T0()
   '     Get #FF, BSFilePos(Seq1, Seq3) * BSRWSize + Y * BSWinRWChunk + 1, T1()
   '     Get #FF, BSFilePos(Seq2, Seq3) * BSRWSize + Y * BSWinRWChunk + 1, T2()
   '     GetPltVal BSBootReps, Y, T0(0), T1(0), T2(0), PltVal(0, 0)
   '     Form1.ProgressBar1.Value = 5 + (Y / NumSets) * 80
   ' Next 'Y

    Close #FF
    
    Call DrawBSPlotsII

    
    'PltVal(0, 16) = X
    Form1.SSPanel1.Caption = ""
    BSTypeFlag = xBSTypeFlag
    BSStepSize = xBSStepSize
    BSStepWin = xBSStepWin
    BSBootReps = xBSBootReps
    ChDir ODir$
    ChDrive ODir$
End Sub
Public Sub DXoverB()

    Dim PosCount As Long, Counter As Long, Y As Long, X As Long
    Dim YScaleFactor As Double
    Dim Header As String, T As String

    Form1.ProgressBar1 = 10
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path

    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    SeqLen = Len(StrainSeq(0))
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(3)
    ReDim BootName(NextNo + 1)
    BootName(0) = "A0        "
    BootName(1) = "A1        "
    BootName(2) = "A2        "
    TempSeq(0) = StrainSeq(Seq1) + StrainSeq(Seq1)
    TempSeq(1) = StrainSeq(Seq2) + StrainSeq(Seq2)
    TempSeq(2) = StrainSeq(Seq3) + StrainSeq(Seq3)
    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)

    If BSCCenterFlag = 1 And X = 12345 Then

        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            Y = XOverList(RelX, RelY).Beginning + Int((XOverList(RelX, RelY).Ending - XOverList(RelX, RelY).Beginning) / 2)
            Y = Y + Int(DPWindow / 2)

            If Y > DPWindow Then

                Do
                    X = Y - DPWindow

                    If X < 1 Then
                        Exit Do
                    Else
                        Y = X
                    End If

                Loop

                Y = Y + DPWindow
                StartWin = Y
            Else
                Y = DPWindow
            End If

        Else
            Y = DPWindow
        End If

    Else
        Y = DPWindow
    End If

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(2, Len(StrainSeq(0)))
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    Header$ = "   " + CStr(3) + "  " + CStr(DPWindow)
    'Close #1
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    On Error GoTo 0
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(3)
    Counter = 0

    Do While Y < SeqLen + Int(DPWindow / 2)
        Counter = Counter + 1
        Print #1, Header$

        For X = 0 To 2
            T$ = Mid$(TempSeq(X), Y - (DPWindow - 1), DPWindow)
            Boots(X) = BootName(X) + T$
            Print #1, Boots(X)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then
        Print #1, DPCoeffVar
    End If

    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Open "outfilex" For Binary Access Read As #1
    'Exit Sub

    If LOF(1) < 10 Then
        Close #1
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command6.Enabled = True
        Form1.Command25.Enabled = False
        Exit Sub
    End If

    Dim GetInteger As Integer
    Dim GetString As String

    GetString = String$(10, " ")

    For X = 0 To Counter - 1
        Input #1, GetInteger
        'Close #1
        'Exit Sub
        Input #1, GetString
        Input #1, GetString
        MCPrintPos(X) = X * DPStep + DPWindow / 2
        MCPrintData(0, X) = (CDbl(right$(GetString, 6)))
        Input #1, GetString
        MCPrintData(1, X) = (CDbl(Mid$(GetString, 13, 6)))
        MCPrintData(2, X) = (CDbl(right$(GetString, 6)))
    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    MinDistX = 10
    MaxDistX = 0

    For X = 0 To 2

        For Y = 0 To Counter - 1

            If MCPrintData(X, Y) > MaxDistX Then

                If MCPrintData(X, Y) > 2 Then
                    MCPrintData(X, Y) = 2
                    MaxDistX = MCPrintData(X, Y)
                Else
                    MaxDistX = MCPrintData(X, Y)
                End If

            End If

        Next 'Y

    Next 'X

    Form1.Picture7.ScaleMode = 3

    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 0, "Distance")

    If CurrentCheck = 8 Then

        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

    End If

    Form1.Picture7.DrawWidth = 3

    For X = 0 To 2

        If X = 0 Then
            Form1.Picture7.ForeColor = LYellow
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LPurple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI

        For Y = 1 To Counter - 1
            LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    Call Highlight

    For X = 0 To 2

        If X = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub
Public Sub DXoverF()

    SS = GetTickCount

    Dim B As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    Dim RootNode() As Long
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long, Pict As Long
    
    
    ReDim RevSeq(NextNo)
    
    NumberOfSeqs = 1
    For X = 0 To NextNo

        If Selected(X) = 1 Then
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    
    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, NumberOfSeqs)
    Y = Form5.Combo1.ListIndex - 1
    For X = 1 To LSeq
        TempSeq2(X, 0) = SeqNum(X, Y)
    Next
    
    Z = 1
    For Y = 0 To NextNo
        If Selected(Y) = 1 Then
            For X = 1 To LSeq
                TempSeq2(X, Z) = SeqNum(X, Y)
            Next
            Z = Z + 1
        End If
    Next
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(NumberOfSeqs, DPWindow)
    ReDim TTempSeq2(DPWindow, NumberOfSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim Num(1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    
    For Y = 0 To 0

        For X = 1 To DPWindow
            WeightMod(Y, X - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(NumberOfSeqs, NumWins)
    For B = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), B, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, NumberOfSeqs)
            
        X = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To NumberOfSeqs
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(NumberOfSeqs, NumberOfSeqs)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, NumberOfSeqs + 1, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        For Z = 1 To NumberOfSeqs
            On Error Resume Next
            MCPrintData(Z, B) = tMat(0, Z)
            On Error GoTo 0
        Next
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (B / NumWins) * 100
        'End If
        
        DoEvents

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0

    For X = 1 To NumberOfSeqs

        For Y = 0 To NumWins - 1

            If MCPrintData(X, Y) > MaxDistX And MCPrintData(X, Y) <> 10 Then

                If MCPrintData(X, Y) > 2 Then
                    MCPrintData(X, Y) = 2
                    MaxDistX = MCPrintData(X, Y)
                Else
                    MaxDistX = MCPrintData(X, Y)
                End If

            End If

        Next 'Y

    Next 'X
    smoothflag = 1
    If smoothflag = 1 Then
        Dim VarSiteSmooth2() As Double
        ReDim VarSiteSmooth2(NumberOfSeqs, NumWins + 10)
        Call SmoothIt2D(MCPrintData(), VarSiteSmooth2(), 1, NumWins - 1, 0, NumberOfSeqs)
        For Y = 0 To NumberOfSeqs
            For X = 1 To NumWins
                MCPrintData(Y, X) = VarSiteSmooth2(Y, X)
            Next X
        Next Y
    
    End If
    Form1.Picture7.ScaleMode = 3
    'MaxDistX = 0.05
    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 0, "Distance")
    'Call DoAxes( Len(strainseq(0)), -1,0, 0.05, 0, "Distance")

    Form1.Picture7.DrawWidth = 3
    
    For X = 1 To NumberOfSeqs
        Pict = Form1.Picture7.hdc
        Form1.Picture7.ForeColor = FFillCol(RevSeq(X))
        Dummy = MoveToEx(Pict, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To NumWins - 1
            'Picture7.ForeColor = green
            If MCPrintData(X, Y) > MaxDistX Then
                
            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
                MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
            Else
                LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
            End If
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    For X = 1 To NumberOfSeqs
        Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
        Dummy = MoveToEx(Pict, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To NumWins - 1
            'Picture7.ForeColor = green
            If MCPrintData(X, Y) > MaxDistX Then
                
            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
                MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
            Else
                LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
            End If
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh
    
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5

    EE = GetTickCount
    TT = EE - SS
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub
Public Sub DXoverE()

    SS = GetTickCount

    Dim B As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    Dim RootNode() As Long
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long

    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 2)

    For X = 1 To LSeq
        TempSeq2(X, 0) = SeqNum(X, Seq1)
        TempSeq2(X, 1) = SeqNum(X, Seq2)
        TempSeq2(X, 2) = SeqNum(X, Seq3)
    Next
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(2, DPWindow)
    ReDim TTempSeq2(DPWindow, 2)
    ReDim DistVal(0 + 1)
    ReDim Num1(0 + 1)
    ReDim Num2(0 + 1)
    ReDim DEN(0 + 1)
    ReDim Num(0 + 1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(2, 2)
    ReDim SHolder((3 + 1) * 40 * 2)

    For Y = 0 To 0

        For X = 1 To DPWindow
            WeightMod(Y, X - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(2, NumWins)
    For B = 0 To NumWins
        
        MakeSubAlign 2, Len(StrainSeq(0)), B, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, 2)
            
        X = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To 2
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(2, 2)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, 3, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        MCPrintData(0, B) = tMat(0, 1)
        MCPrintData(1, B) = tMat(0, 2)
        MCPrintData(2, B) = tMat(1, 2)
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (B / NumWins) * 100
        'End If
        
        DoEvents

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0
    realmax = 0
    For X = 0 To 2

        For Y = 0 To NumWins - 1
            If MCPrintData(X, Y) > realmax Then
                realmax = MCPrintData(X, Y)
            End If
            If MCPrintData(X, Y) > MaxDistX And MCPrintData(X, Y) < 10 Then

                If MCPrintData(X, Y) > 2 Then
                    MCPrintData(X, Y) = 2
                    MaxDistX = MCPrintData(X, Y)
                Else
                    MaxDistX = MCPrintData(X, Y)
                End If

            End If

        Next 'Y

    Next 'X

    Form1.Picture7.ScaleMode = 3
    
    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 1, "Distance")

    If CurrentCheck = 8 Then

        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

    End If

    Form1.Picture7.DrawWidth = 3

    For X = 0 To 2

        If X = 0 Then
            Form1.Picture7.ForeColor = LYellow
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LPurple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI
        
        For Y = 1 To NumWins - 1
            If MCPrintData(X, Y) > MaxDistX Then
                
            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
                MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
            Else
                LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
            End If
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    Call Highlight

    For X = 0 To 2

        If X = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf X = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI

        For Y = 1 To NumWins - 1
            If MCPrintData(X, Y) > MaxDistX Then
                
            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
                MoveToEx Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
            Else
                LineTo Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
            End If
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh

    
    EE = GetTickCount
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub
Public Sub DXoverG()

    SS = GetTickCount

    Dim B As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    Dim RootNode() As Long
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long
    
    If Seq1 = Seq2 And Seq1 = Seq3 Then Exit Sub
    If Seq1 = NextNo + 1 Or Seq2 = NextNo + 1 Or Seq3 = NextNo + 1 Then Exit Sub
    
    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 1)
    
    If Seq1 <> Seq2 Then
        For X = 1 To LSeq
            TempSeq2(X, 0) = SeqNum(X, Seq1)
            TempSeq2(X, 1) = SeqNum(X, Seq2)
        Next
    Else
        For X = 1 To LSeq
            TempSeq2(X, 0) = SeqNum(X, Seq1)
            TempSeq2(X, 1) = SeqNum(X, Seq3)
        Next
    End If
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(1, DPWindow)
    ReDim TTempSeq2(DPWindow, 1)
    ReDim DistVal(0 + 1)
    ReDim Num1(0 + 1)
    ReDim Num2(0 + 1)
    ReDim DEN(0 + 1)
    ReDim Num(0 + 1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(1, 1)

    For Y = 0 To 0

        For X = 1 To DPWindow
            WeightMod(Y, X - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(NumWins)
    For B = 0 To NumWins
        
        MakeSubAlign 1, Len(StrainSeq(0)), B, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, 1)
            
        X = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To 1
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(1, 1)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, 2, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        MCPrintData(B) = tMat(0, 1)
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (B / NumWins) * 100
        'End If
        
        DoEvents

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0

    

        For Y = 0 To NumWins - 1

            If MCPrintData(Y) > MaxDistX Then

                If MCPrintData(Y) > 2 Then
                    MCPrintData(Y) = 2
                    MaxDistX = MCPrintData(Y)
                Else
                    MaxDistX = MCPrintData(Y)
                End If

            End If

        Next 'Y

    Form1.Picture7.ScaleMode = 3
    
    Call FindSubSeqBSII
    
    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 1, "Distance")

    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB(168, 168, 168)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To NumWins - 1
        Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To NumWins - 1
        Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    'Next 'x

    Call Highlight

    Form1.Picture7.Refresh

    
    EE = GetTickCount
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub
Public Sub DXoverD()

    Dim Counter As Long, X As Long, PosCount As Long, Y As Long, Z As Long
    Dim YScaleFactor As Double
    Dim ODir As String, Header As String, T As String

    Form1.ProgressBar1 = 10
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path

    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(NextNo)
    ReDim BootName(NextNo + 1)
    ReDim RevSeq(NextNo + 1)
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    NumberOfSeqs = 1

    For X = 0 To NextNo

        If Selected(X) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(X)
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1

    For X = 0 To NumberOfSeqs
        TempSeq(X) = right$(TempSeq(X), DPWindow / 2 + 1) + TempSeq(X) + left$(TempSeq(X), DPWindow / 2 + 1)
    Next 'X

    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)
    'Dim DPStep As Integer
    Y = DPWindow

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(NumberOfSeqs, Len(StrainSeq(0)))
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    Header$ = "   " + CStr(NumberOfSeqs + 1) + "  " + CStr(DPWindow)
    'Close #1
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    On Error GoTo 0
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(NextNo)
    Counter = 0

    Do While Y < SeqLen + DPWindow
        Counter = Counter + 1
        Print #1, Header$

        For X = 0 To NumberOfSeqs
            BootName(X) = "A" & Trim$(CStr(X))
            BootName(X) = BootName(X) + String$(10 - (Len(BootName(X))), " ")
            T$ = Mid$(TempSeq(X), Y - (DPWindow - 1), DPWindow)
            Boots(X) = BootName(X) + T$
            Print #1, Boots(X)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then
        Print #1, DPCoeffVar
    End If

    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Open "outfilex" For Binary Access Read As #1
    'Exit Sub

    Dim GetInteger As Integer
    Dim GetString As String

    GetString = String$(10, " ")

    For X = 0 To Counter - 1
        Input #1, GetInteger
        Input #1, GetString
        Input #1, GetString
        MCPrintPos(X) = X * DPStep '+ DPWindow / 2 - dpeindow
        MCPrintData(1, X) = (CDbl(right$(GetString, 6)))

        For Z = 2 To NumberOfSeqs
            Input #1, GetString
            MCPrintData(Z, X) = (CDbl(Mid$(GetString, 13, 6)))
            'MCPrintData(2, X) = (CDbl(Right$(GetString, 6)))
        Next 'Z

    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    MinDistX = 10
    MaxDistX = 0

    For X = 1 To NumberOfSeqs

        For Y = 0 To Counter - 1

            If MCPrintData(X, Y) > MaxDistX Then

                If MCPrintData(X, Y) > 2 Then
                    MCPrintData(X, Y) = 2
                    MaxDistX = MCPrintData(X, Y)
                Else
                    MaxDistX = MCPrintData(X, Y)
                End If

            End If

        Next 'Y

    Next 'X

    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.BackColor = BackColours
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3

    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 0, "Distance")

    Form1.Picture7.DrawWidth = 3

    For X = 1 To NumberOfSeqs
        Form1.Picture7.ForeColor = FFillCol(RevSeq(X))
        Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)))
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    For X = 1 To NumberOfSeqs
        Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
        Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)))
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
    ChDir ODir
    ChDrive ODir
End Sub
Public Sub DXoverC()

    Dim YScaleFactor As Double
    Dim PosCount As Long, X As Long, Counter As Long, Y As Long
    Dim Header As String, T As String

    Form1.ProgressBar1 = 10

    If Seq1 = Seq2 And Seq1 = Seq3 Then Exit Sub

    If Seq1 = NextNo + 1 Or Seq2 = NextNo + 1 Or Seq3 = NextNo + 1 Then Exit Sub
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    ODir$ = CurDir
    ChDir App.Path
    ChDrive App.Path

    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    SeqLen = Len(StrainSeq(0))
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(2)
    ReDim BootName(NextNo + 1)
    BootName(0) = "A0        "
    BootName(1) = "A1        "
    'BootName(2) = "A2        "

    If Seq1 <> Seq2 Then
        TempSeq(0) = StrainSeq(Seq1)
        TempSeq(1) = StrainSeq(Seq2)
    Else
        TempSeq(0) = StrainSeq(Seq1)
        TempSeq(1) = StrainSeq(Seq3)
    End If

    '   TempSeq(2) = StrainSeq(Seq3)
    'replace . with -

    For X = 0 To 1
        Pos = 0

        Do
            Pos = InStr(Pos + 1, TempSeq(X), ".", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(TempSeq(X), Pos, 1) = "-"
            Else
                Exit Do
            End If

        Loop

    Next 'X

    For X = 0 To 1
        Pos = 0

        Do
            Pos = InStr(Pos + 1, TempSeq(X), "*", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(TempSeq(X), Pos, 1) = "-"
            Else
                Exit Do
            End If

        Loop

    Next 'X

    TempSeq(0) = TempSeq(0) + TempSeq(0)
    TempSeq(1) = TempSeq(1) + TempSeq(1)
    'TempSeq(2) = TempSeq(2) + TempSeq(2)
    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)
    'Dim DPStep As Integer

    If BSCCenterFlag = 1 And X = 12345 Then

        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            Y = XOverList(RelX, RelY).Beginning + Int((XOverList(RelX, RelY).Ending - XOverList(RelX, RelY).Beginning) / 2)
            Y = Y + Int(DPWindow / 2)

            If Y > DPWindow Then

                Do
                    X = Y - DPWindow

                    If X < 1 Then
                        Exit Do
                    Else
                        Y = X
                    End If

                Loop

                Y = Y + DPWindow
                StartWin = Y
            Else
                Y = DPWindow
            End If

        Else
            Y = DPWindow
        End If

    Else
        Y = DPWindow
    End If

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(Len(StrainSeq(0)))
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    Header$ = "   " + CStr(2) + "  " + CStr(DPWindow)
    'Close #1
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    On Error GoTo 0
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(3)
    Counter = 0

    Do While Y < SeqLen + Int(DPWindow / 2)
        Counter = Counter + 1
        Print #1, Header$

        For X = 0 To 1
            T$ = Mid$(TempSeq(X), Y - (DPWindow - 1), DPWindow)
            Boots(X) = BootName(X) + T$
            Print #1, Boots(X)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then Print #1, DPCoeffVar
    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        Close #1
        Exit Sub
    End If

    'Exit Sub

    Dim GetInteger As Integer
    Dim GetString As String

    GetString = String$(10, " ")
    CurPos = 1

    For X = 0 To Counter - 1
        Input #1, GetInteger
        Input #1, GetString
        Input #1, GetString
        MCPrintPos(X) = X * DPStep + DPWindow / 2
        MCPrintData(X) = (CDbl(right$(GetString, 6)))
    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    MinDistX = 10
    MaxDistX = 0

    For Y = 0 To Counter - 1

        If MCPrintData(Y) > MaxDistX Then

            If MCPrintData(Y) > 2 Then
                MCPrintData(Y) = 2
                MaxDistX = MCPrintData(Y)
            Else
                MaxDistX = MCPrintData(Y)
            End If

        End If

    Next 'Y

    Form1.Picture7.ScaleMode = 3

    Call DoAxes(Len(StrainSeq(0)), -1, 0, MaxDistX, 0, "Distance")

    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB(168, 168, 168)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To Counter - 1
        'Picture7.ForeColor = green
        Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    Form1.Picture7.DrawWidth = 1
    'For x = 0 To 1
    ' If x = 0 Then
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    ' ElseIf x = 1 Then
    '     Form1.Picture7.ForeColor = RGB(128, 0, 128)
    'Else
    '    Form1.Picture7.ForeColor = RGB(0, 128, 128)
    'End If
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + MCPrintPos(0) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To Counter - 1
        'Picture7.ForeColor = green
        Dummy = LineTo(Form1.Picture7.hdc, 30 + MCPrintPos(Y) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    'Next 'x

    Call Highlight

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
End Sub

Public Sub DoCols()
    ReDim SeqCol(NextNo + 1)
    ReDim FFillCol(NextNo + 1)

Exit Sub

    Dim HowClose As Integer, BColor As Integer, RColor As Integer, GColor As Integer

    HowClose = 4

    Dim X As Integer
    Dim TX As Integer

    If NextNo / 2 = Int(NextNo / 2) Then
        OddF = 0
    Else
        OddF = 1
    End If

    For X = 0 To NextNo + 1
        TX = X

        If TX / 3 = Int(TX / 3) Then
            RColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            GColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)

            If TX <= NextNo / 2 Then
                BColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                BColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

        ElseIf TX / 2 = Int(TX / 2) Then

            If TX <= NextNo / 2 Then
                RColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                RColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

            GColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            BColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)
        Else

            If TX <= NextNo / 2 Then
                GColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                GColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

            BColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            RColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)
            'BColor = Int(((Nextno - TX) / ((Nextno + 1) / 2) - Int((Nextno - TX) / ((Nextno + 1) / 2))) * 255)
            'RColor = Int(((Nextno - TX) / 3.46 - Int((Nextno - TX) / 3.46)) * 255)
        End If

        If ((Abs(RColor - 196) + Abs(GColor - 196) + Abs(BColor - 196)) / HowClose) < 30 Then

            If RColor < 196 Then
                RColor = RColor - 120

                If RColor < 0 Then RColor = 255 + RColor
            Else
                RColor = RColor + 120

                If RColor > 255 Then RColor = RColor - 255
            End If

            If GColor < 196 Then
                GColor = GColor - 120

                If GColor < 0 Then GColor = 255 + GColor
            Else
                GColor = GColor + 120

                If GColor > 255 Then GColor = GColor - 255
            End If

            If BColor < 196 Then
                BColor = BColor - 120

                If BColor < 0 Then BColor = 255 + BColor
            Else
                BColor = BColor + 120

                If BColor > 255 Then BColor = BColor - 255
            End If

        End If

        SeqCol(X) = RGB(RColor, GColor, BColor) '11,73,2

        If RColor > 196 Then
            RColor = CInt(((RColor - 196) / HowClose) + 196)
        Else
            RColor = 196 - CInt(((196 - RColor) / HowClose))
        End If

        If GColor > 196 Then
            GColor = CInt(((GColor - 196) / HowClose) + 196)
        Else
            GColor = 196 - CInt(((196 - GColor) / HowClose))
        End If

        If BColor > 196 Then
            BColor = CInt(((BColor - 196) / HowClose) + 196)
        Else
            BColor = 196 - CInt(((196 - BColor) / HowClose))
        End If

        RColor = RColor + (BkR - RColor) / 2
        GColor = GColor + (BkG - GColor) / 2
        BColor = BColor + (BkB - BColor) / 2
        FFillCol(X) = RGB(RColor, GColor, BColor)
    Next 'X

End Sub
Public Sub DoAxes2(UValA As Double, LValA As Double, UValB As Double, LValB As Double, UValC As Long, LValC As Long, DDFlag As Byte, XLegendA As String, XLegendB As String, XLegendC As String)

    Dim MFactor As Double
    Dim Partnumber As Integer
    Dim Outnum As Double, SOutNum As String, TH As Long
    Dim StartY As Integer
    Dim YE As Long, YS As Long

    Form1.Picture7.AutoRedraw = True
    Form1.Picture10.AutoRedraw = True
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture7.ForeColor = QBColor(0)

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
        Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
    End If

    Dim YScaleFactor As Double

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    OPicheight = PicHeight
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    TH = Form1.Picture7.TextHeight("0")
    'Form1.Frame17.Visible = False
    Partnumber = (PicHeight / 3 - 35) / (TH * 3)

    If Partnumber < 3 Then Partnumber = 3

    Dim P1 As Long, P2 As Long, P3 As Long, P4 As Long

    StartY = 15
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10

    If DDFlag = 1 Then
        'shade detected region

        Call Highlight

    End If

    Form1.Picture7.Line (25, P1)-(25, P4), QBColor(0)
    Form1.Picture7.Line (25, P2)-(Form1.Picture7.ScaleWidth - 5, P2), QBColor(0)
    Form1.Picture7.Line (25, P3)-(Form1.Picture7.ScaleWidth - 5, P3), QBColor(0)
    Form1.Picture7.Line (25, P4)-(Form1.Picture7.ScaleWidth - 5, P4), QBColor(0)
    'Y axis tick marks

    Dim YIncriment As Double

    'YIncriment = ((PicHeight - StartY - 10 - 25) / 3) / (PartNumber - 1)
    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (Partnumber - 1))

    Dim Z As Integer
    Dim Y As Long

    
    For Z = 0 To 2
        YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        YS = CLng(YE + YIncriment * (Partnumber - 1))

        For Y = YE To YS Step YIncriment
            Form1.Picture7.Line (25, Y)-(28, Y), QBColor(0)
        Next 'Y

    Next 'Z

    'X-Axis tick marks

    For Z = 0 To 2
        Y = StartY + ((PicHeight - 10 - StartY) / 3) + ((PicHeight - 10 - StartY) / 3) * Z
        Form1.Picture7.Line (30, Y)-(30, Y - 3), QBColor(0)
        Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, Y)-(Form1.Picture7.ScaleWidth - 10, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, Y - 3), QBColor(0)
    Next 'Z

    Dim XVal As String

    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentY = 14
    Form1.Picture7.CurrentX = 7
    MFactor = 1

    Dim X As Integer
    Dim UVal As Double, LVal As Double

    X = 0

    For Z = 0 To 2
        X = 0

        If Z = 0 Then
            UVal = UValA
            LVal = LValA
        ElseIf Z = 1 Then
            UVal = UValB
            LVal = LValB
        Else
            UVal = UValC
            LVal = LValC
        End If

        MFactor = 1
        YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        YS = CLng(YE + YIncriment * (Partnumber - 1))

        For Y = YS To YE Step -(YIncriment)
            Outnum = (LVal + (UVal - LVal) * (X / (Partnumber - 1))) * MFactor

            If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then

                If LVal * 1000 > UVal Then
                    MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                    XLegendA = XLegendA + " (x " & Trim$(CStr(MFactor)) & ")"
                    Outnum = Outnum * MFactor
                Else
                    Outnum = 0
                End If

            End If

            SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
            'Exit Sub
            Outnum = (CLng(Outnum * 100)) / 100
            'If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = "0" & SOutNum

            If Outnum = Int(Outnum) Then SOutNum = SOutNum + ".0"

            If Outnum >= 100 And Outnum < 1000 Then
                On Error Resume Next
                SOutNum = " " & Trim$(CStr(Int(CDbl(SOutNum))))
                SOutNum = " " & Trim$(CStr(Int(Val(SOutNum))))
                On Error GoTo 0
            End If

            If Len(SOutNum) < 4 Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 Then
                SOutNum = left$(SOutNum, 4)
            End If

            Form1.Picture7.CurrentY = CLng(Y - TH / 2)
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            X = X + 1
        Next 'Y

    Next 'Z

    Form1.Picture10.Enabled = True
    Form1.Picture10.Picture = LoadPicture()
    Form1.Picture10.CurrentX = 5
    Form1.Picture10.FontSize = 6

    Dim TW As Integer

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendA)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P1 + TW + (P2 - P1 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendA, 90)

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendB)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P2 + TW + (P3 - P2 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendB, 90)

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendC)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P3 + TW + (P4 - P3 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendC, 90)

    'YScaleFactor = 0.85
    '
    'Form1.Picture7.CurrentX = 30
    'Form1.Picture7.CurrentY = Form1.Picture7.Height * (YScaleFactor + 0.08)
    Form1.Picture7.CurrentY = PicHeight - 9
    Form1.Picture7.CurrentX = 29
    Form1.Picture7.Print "1"
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(Len(StrainSeq(0)) / 4)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4 - ((Len(XVal) + 1) / 2) * 5.5
    Form1.Picture7.Print Int(Len(StrainSeq(0)) / 4)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(Len(StrainSeq(0)) / 2)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (((Len(XVal) + 1) / 2) * 5.5)
    Form1.Picture7.Print Int(Len(StrainSeq(0)) / 2)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(Len(StrainSeq(0)) / 1.333)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (((Len(XVal) + 1) / 2) * 5.5)
    Form1.Picture7.Print Int(Len(StrainSeq(0)) / 1.3333)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(Len(StrainSeq(0)))
    Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
    Form1.Picture7.Print Len(StrainSeq(0))
    '25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5
    Form1.Picture7.CurrentY = PicHeight
    Form1.Picture7.CurrentX = 25 + (Form1.Picture7.ScaleWidth - 30 - Form1.Picture7.TextWidth("Position in alignment")) / 2
    Form1.Picture7.Print "Position in alignment"
    'If TManFlag > -1 Then
    '    If XOverList(RelX, RelY).SBPFlag < 3 And XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
    '        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    '    End If
    'End If
    Form1.Picture7.Enabled = True

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
        Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
        Form1.Picture20.Visible = True
    End If

End Sub
Public Sub DoAxes(LSX, An, UVal As Double, LVal As Double, DDFlag As Byte, XLegend As String)
    'Draws axes for many of the graphs that appear in the plot display.

    Dim Outnum As Variant, MFactor As Double, YIncriment As Double
    Dim YS As Long, YE As Long, TH As Long, Pict As Long
    Dim Partnumber As Integer, Y As Integer, X As Integer, TW As Integer
    Dim SOutNum As String, XVal As String

    'Prepare the pictureboxes in the plot display

    With Form1.Picture10
        .AutoRedraw = True
        .BackColor = BackColours
        .ScaleMode = 3
        .Picture = LoadPicture()
        .ForeColor = QBColor(0)
    End With

    With Form1.Picture7
        .AutoRedraw = True
        .BackColor = BackColours
        .ScaleMode = 3
        .Picture = LoadPicture()
        .ForeColor = QBColor(0)

        If ORFFlag = 0 Then
            Height = Form1.Picture10.ScaleHeight
            .Top = 0
        Else
            .Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
            .Top = Form1.Picture20.ScaleHeight - 5
        End If

    End With

    Dim YScaleFactor As Double

    'Set up some scaling variables
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / LSX)
    TH = Form1.Picture7.TextHeight("0")
    'If necessary draw an indicator of the variable sites used to make the plots

    If DDFlag = 1 Then
        'Form1.Picture7.DrawMode = 7
        'Form1.Picture7.ForeColor = BackColours
        'Pict = Form1.Picture7.hdc
        'Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPos(0))
        'Form1.Picture7.DrawMode = 15
        'Form1.Picture7.ForeColor = RGB(128, 128, 128)
        'Pict = Form1.Picture7.hdc
        'Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPos(0))
        'Form1.Picture7.DrawMode = 5
        'Form1.Picture7.ForeColor = RGB(128, 128, 128)
        Pict = Form1.Picture7.hdc
        Dummy = DrawDiffs(Pict, LenXOverSeq, XFactor, XDiffpos(0))
        'Form1.Picture7.DrawMode = 13
        'Form1.Picture7.ForeColor = 0
    End If
    
    'Work out how many tick marks to display on the Y-axis
    Partnumber = (PicHeight - 35) / (TH * 4)

    If Partnumber < 3 Then Partnumber = 3
    YIncriment = (PicHeight - 35) / (Partnumber - 1)
    'Draw X and Y axes
    Form1.Picture7.Line (25, 15)-(25, PicHeight - 10), QBColor(0)
    Form1.Picture7.Line (25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5, PicHeight - 10), QBColor(0)
    YE = PicHeight - 15 + (YIncriment - 1)
    'Draw tick marks on the Y-Axis

    For Y = 20 To YE Step YIncriment
        Form1.Picture7.Line (25, Y)-(28, Y), QBColor(0)
    Next 'Y

    'Draw X-Axis tick marks
    Form1.Picture7.Line (30, PicHeight - 10)-(30, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 10, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight - 10)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight - 10)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight - 10)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight - 13), QBColor(0)
    Form1.Picture7.CurrentY = 14
    Form1.Picture7.CurrentX = 7
    YS = PicHeight - 15
    YE = 20 - (YIncriment - 1)
    'Print Y-Axis tick lables
    MFactor = 1
    X = 0

    For Y = YS To YE Step -YIncriment
        
        Outnum = (LVal + (UVal - LVal) * (X / (Partnumber - 1))) * MFactor
        If Outnum >= 0 Then
            Outnum = Outnum + 0.000000001
        ElseIf Outnum <= 0 Then
            Outnum = Outnum - 0.000000001
        End If
        If Outnum > 0 And Outnum < 0.01 And MFactor = 1 And UVal > LVal Then

            If Abs(LVal * 1000) > UVal Then
                MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                XLegend = XLegend + " (x " & Trim$(CStr(MFactor)) & ")"
                Outnum = Outnum * MFactor
            ElseIf Abs(Outnum * 100) < UVal And UVal <= 1 Then
                
                Outnum = 0.00000001
                'Outnum = 0
            End If
        
            
            
        End If

        If Outnum < 10 ^ 8 Then
            Outnum = Outnum * 1000
            Outnum = CLng(Outnum)
            Outnum = Outnum / 1000
        End If
        SOutNum = Trim$(CStr(Outnum))
        If UVal >= 0.02 Then
            If Outnum = Int(Outnum) Then SOutNum = SOutNum + ".0"
    
            If Abs(Outnum) >= 100 And Abs(Outnum) < 1000 Then
                SOutNum = " " & Trim$(CStr(Int(Val(SOutNum))))
            ElseIf Abs(Outnum) < 1 Then
                Outnum = CLng(Outnum * 100)
                SOutNum = CStr(Outnum)
                If Len(SOutNum) < 2 Then
                    SOutNum = String(2 - Len(SOutNum), "0") + SOutNum
                ElseIf Outnum < 0 And Len(SOutNum) < 3 Then
                    SOutNum = String(3 - Len(SOutNum), "0") & Mid$(SOutNum, 2, 3)
                End If
                If Val(SOutNum) >= 0 Then
                    If Val(SOutNum) < 100 Then
                        SOutNum = "0." & SOutNum
                    Else
                        SOutNum = "1.00"
                    End If
                ElseIf Outnum < 0 Then
                    If Outnum > -100 Then
                        SOutNum = "-0." & Mid$(SOutNum, 2, Len(SOutNum) - 1)
                    Else
                        SOutNum = "-1.00"
                    End If
                End If
            End If
            
            If Len(SOutNum) < 4 Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 Then
                SOutNum = left$(SOutNum, 4)
            End If
    
            Form1.Picture7.CurrentY = Y - TH / 2 - 2
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            X = X + 1
        Else
            Outnum = CLng(Outnum * 1000)
            'Exit Sub
            SOutNum = CStr(Outnum)
            If Len(SOutNum) < 3 Then
                SOutNum = String(3 - Len(SOutNum), "0") + SOutNum
            End If
            SOutNum = "0." & SOutNum
            
            
            If Len(SOutNum) < 5 Then
                SOutNum = SOutNum + String$(5 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 5 Then
                SOutNum = left$(SOutNum, 5)
            End If
    
            Form1.Picture7.CurrentY = Y - TH / 2 - 2
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            X = X + 1
        End If
    Next 'Y

    'Print X-Axis tick labels
    Form1.Picture7.CurrentY = PicHeight - 9
    Form1.Picture7.CurrentX = 29
    Form1.Picture7.Print "1"
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(LSX / 4)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4 - ((Len(XVal) + 1) / 2) * 5.5
    Form1.Picture7.Print Int(LSX / 4)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(LSX / 2)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (((Len(XVal) + 1) / 2) * 5.5)
    Form1.Picture7.Print Int(LSX / 2)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(LSX / 1.333)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (((Len(XVal) + 1) / 2) * 5.5)
    Form1.Picture7.Print Int(LSX / 1.3333)
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = Int(LSX)
    Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
    Form1.Picture7.Print LSX
    'Print X axis label
    Dim OSt As String
    Form1.Picture7.CurrentY = PicHeight
    If An = -1 Then
        OSt = "Position in alignment"
        
    Else
        OSt = "Nucleotide position in relation to " + Trim(StraiName(An))
    
    End If
    Form1.Picture7.CurrentX = 25 + (Form1.Picture7.ScaleWidth - 30 - Form1.Picture7.TextWidth(OSt)) / 2
    Form1.Picture7.Print OSt
    'Print Y axis label
    Form1.Picture10.Enabled = True
    Form1.Picture10.Picture = LoadPicture()
    Form1.Picture10.CurrentX = 5
    Form1.Picture10.FontSize = 6
    TW = Form1.Picture7.TextWidth(XLegend)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegend, 90)

    YScaleFactor = 0.85
    Form1.Picture7.CurrentX = 30
    Form1.Picture7.CurrentY = Form1.Picture7.Height * (YScaleFactor + 0.08)
    Form1.Picture7.Enabled = True
    'Sizes pictures according to whether an ORF map is being displayed or not

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
        Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
    End If

End Sub
Public Sub GCCheck(SPF)

    Dim xMinP() As Double
Dim COff As Double
    ReDim xMinP(NextNo, NextNo)
    Screen.MousePointer = 11
    
    Dim BT1 As Long, BT2 As Long, ET1 As Long, ET2 As Long
    Dim MinPA As Double
    Dim X1 As Integer
    Dim X2 As Integer
    Dim Y1 As Integer
    Dim Y2 As Integer
    Dim Prob As Double
    Dim Beginning As Long
    Dim Ending As Long
    Dim RetVal As Long

    'Dim hProcess As Long

    Dim YScaleFactor As Double

    Call FindSubSeqGC2
    MinPx = -Log10(LowestProb / MCCorrection)
    
    MinPA = 1
    If SPF = 0 Then
        Form1.SSPanel1.Caption = "Executing GENECONV"
    End If
    Const STILL_ACTIVE = &H103

    Do
        GetExitCodeProcess cProcess, RetVal
    Loop While RetVal = STILL_ACTIVE

    Dummy = CloseHandle(cProcess)
    cProcess = 0
    ReDim MCPrintData(2, Len(StrainSeq(0)))
    ReDim MCPrintPos(2, Len(StrainSeq(0)), 1)
    Open GCCFile For Binary Access Read As #1

    Dim Results As String

    Results = String$(30000, " ")

    Dim FLen As Long

    FLen = LOF(1)
    Results = String$(FLen, " ")

    Dim CurrentStart As Long

    CurrentStart = 1
    Get #1, CurrentStart, Results

    Dim NPos As Long, GiPos As Long

    NPos = InStr(1, Results, "GI ", vbBinaryCompare)
    GiPos = NPos + 10

    Dim temp As String

    If NPos > 0 Then
        Close #1
        Open GCCFile For Binary Access Read As #1
        temp$ = " "
        Get #1, NPos, temp$
        Input #1, temp$
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        MinPx = Val(Trim$(left$(temp$, NPos))) / 3
        MinPx = -Log10(MinPx)
    End If

    Dim NPos2 As Long

    NPos2 = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos2 > 0 Then
        Close #1
        Open GCCFile For Binary Access Read As #1
        temp$ = String(70, " ")
        Get #1, NPos2, temp$
        'Input #1, Temp$

        If Len(temp$) = 0 Then

            Do While Len(temp$) = 0
                Input #1, temp$
            Loop

        End If

        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos2, Len(temp$) - NPos + 1))
        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos2, Len(temp$) - NPos + 1))
        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)

        If -Log10(Val(Trim$(left$(temp$, NPos2))) / 3) > MinPx Then
            MinPx = Val(Trim$(left$(temp$, NPos2))) / 3
            MinPx = -Log10(MinPx)
        End If

    End If

    'Exit Sub

    If MinPx < -Log10(LowestProb / MCCorrection) Then
        MinPx = -Log10(LowestProb / MCCorrection)
    End If
    MinPx = MinPx + 0.5
    If SPF = 0 Then
        Form1.Picture7.Picture = LoadPicture()
        Form1.Picture1.Enabled = True
        Form1.Picture7.Enabled = True
    
        Call DoAxes(Len(StrainSeq(0)), -1, MinPx, 0, 1, "-Log(KA P-Val)")
    End If
    ReDim Preserve xMinP(NextNo, NextNo)
    xMinP(GCSeq1, GCSeq2) = MinPx
    xMinP(GCSeq2, GCSeq1) = MinPx
    xMinP(GCSeq1, GCSeq3) = MinPx
    xMinP(GCSeq3, GCSeq1) = MinPx
    xMinP(GCSeq2, GCSeq3) = MinPx
    xMinP(GCSeq3, GCSeq2) = MinPx
    'Dim CurrentStart As Long
    CurrentStart = 1

    Dim TargetString As String
    Dim CurPPos As Long

    CurPPos = 0
    'Do 1 - 2
    Get #1, CurrentStart, Results
    TargetString = StraiName(GCSeq1) + ";" + StraiName(GCSeq2)
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = StraiName(GCSeq2) + ";" + StraiName(GCSeq1)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If
    
    
    
    TargetString = Trim$(TargetString)
    Close #1
    
    If SPF = 0 Then
        
        YScaleFactor = 0.85
        PicHeight = Form1.Picture7.Height * YScaleFactor
        XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
        Form1.Picture7.AutoRedraw = True
        'Show RDP plot
    
        Call Highlight
        
        Form1.Picture2.ForeColor = QBColor(0)
        COff = -Log10((LowestProb / (MCCorrection)))
        Y1 = PicHeight - (15 + (COff / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
        Form1.Picture7.DrawStyle = 2
        Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
        Y1 = PicHeight - (15 + (-Log10(LowestProb) / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
        Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
        Form1.Picture7.DrawStyle = 0
    End If
    Dim G As Byte
    Dim TargetCompare As String, TempEnd As String

    
        Open GCCFile For Binary Access Read As #1

For G = 0 To 1
        If NPos > 0 Then
            temp$ = " "
            Get #1, NPos - 10, temp$

            Do While Not EOF(1)
                Input #1, temp$

                If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    TargetCompare$ = Mid$(temp$, 1, NPos - 1)

                    If TargetCompare$ <> TargetString Then
                        
                        Input #1, temp$

                        If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
                            TargetCompare$ = Mid$(temp$, 1, NPos - 1)
        
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If

                        X1 = 30 + Beginning * XFactor + XFactor
                        X2 = 30 + Ending * XFactor + XFactor
                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                        If SPF = 0 Then
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.AutoRedraw = True
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If

                        X1 = 30 + Beginning * XFactor + XFactor
                        X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        If SPF = 0 Then
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            MCPrintData(0, CurPPos) = Prob
                            MCPrintPos(0, CurPPos, 0) = 1
                            MCPrintPos(0, CurPPos, 1) = Ending
                        
                            'Prob = -Log(Prob)
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                        End If
                        CurPPos = CurPPos + 1
                    End If

                ElseIf left$(temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(0, CurPPos) = Prob
                            MCPrintPos(0, CurPPos, 0) = Beginning
                            MCPrintPos(0, CurPPos, 1) = Ending
                            
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                        End If
                        CurPPos = CurPPos + 1
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(0, CurPPos) = Prob
                            MCPrintPos(0, CurPPos, 0) = Beginning
                            MCPrintPos(0, CurPPos, 1) = Len(StrainSeq(0))
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = 1
                            MCPrintPos(1, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            'Prob = -Log(Prob)
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
                        End If
                    End If

                ElseIf left$(temp$, 8) = "#   Name" Then
                Else

                    If left$(temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(StraiName(GCSeq3))
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        temp$ = " "
        Get #1, NPos - 10, temp$
        TargetString = Trim$(StraiName(GCSeq3))
        'Form1.Picture7.DrawStyle = 2
    Next 'G

    

    'Form1.Picture7.DrawStyle = 0
    Close #1
    CurPPos = 0
    'do 1-3
    TargetString = StraiName(GCSeq1) + ";" + StraiName(GCSeq3)
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = StraiName(GCSeq3) + ";" + StraiName(GCSeq1)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If

    TargetString = Trim$(TargetString)

   
    Open GCCFile For Binary Access Read As #1

    For G = 0 To 1
        If NPos > 0 Then
            temp$ = " "
            Get #1, NPos - 10, temp$
    
            Do While Not EOF(1)
                Input #1, temp$

                If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    TargetCompare$ = Mid$(temp$, 1, NPos - 1)

                    If TargetCompare$ <> TargetString Then
                        
                        Input #1, temp$

                        If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
                            TargetCompare$ = Mid$(temp$, 1, NPos - 1)
        
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If (ET2 - BT1) > (ET1 - BT2) Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = Beginning
                            MCPrintPos(1, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.AutoRedraw = True
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = Beginning
                            MCPrintPos(1, CurPPos, 1) = Len(StrainSeq(0))
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = 1
                            MCPrintPos(1, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            'Prob = -log10(Prob)
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                        End If
                    End If

                ElseIf left$(temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = Beginning
                            MCPrintPos(1, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = Beginning
                            MCPrintPos(1, CurPPos, 1) = Len(StrainSeq(0))
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            'Prob = -Log(Prob)
                            MCPrintData(1, CurPPos) = Prob
                            MCPrintPos(1, CurPPos, 0) = 1
                            MCPrintPos(1, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Green, B
                        End If
                    End If

                ElseIf left$(temp$, 8) = "#   Name" Then
                Else

                    If left$(temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(StraiName(GCSeq2))
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        TargetString = Trim$(StraiName(GCSeq2))
        'Form1.Picture7.DrawStyle = 2
    Next 'G



    'Form1.Picture7.DrawStyle = 0
    Close #1
    CurPPos = 0
    'do 2-3
    CurrentStart = 1
    TargetString = StraiName(GCSeq2) + ";" + StraiName(GCSeq3)
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = StraiName(GCSeq3) + ";" + StraiName(GCSeq2)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If

    TargetString = Trim$(TargetString)

    
        Open GCCFile For Binary Access Read As #1

    For G = 0 To 1
        If NPos > 0 Then
            temp$ = " "
            Get #1, NPos - 10, temp$

            Do While Not EOF(1)
                Input #1, temp$

                If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    TargetCompare$ = Mid$(temp$, 1, NPos - 1)

                    If TargetCompare$ <> TargetString Then
                        
                        Input #1, temp$

                        If left$(temp$, 2) = "PI" Or Mid$(temp$, 2, 2) = "PI" Or left$(temp$, 2) = "PO" Or Mid$(temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)
                            TargetCompare$ = Mid$(temp$, 1, NPos - 1)
        
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = Beginning
                            MCPrintPos(2, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = Len(StrainSeq(0))
                            MCPrintPos(2, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            'Prob = -log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = 1
                            MCPrintPos(2, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                        End If
                    End If

                ElseIf left$(temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP(GCSeq1, GCSeq2) = -1 Then xMinP(GCSeq1, GCSeq2) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = Val(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = Val(TempEnd$)
                        End If

                    End If

                    If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If
                        
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = Beginning
                            MCPrintPos(2, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        If SPF = 0 Then
                            X1 = 30 + Beginning * XFactor + XFactor
                            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                            Prob = -Log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = Beginning
                            MCPrintPos(2, CurPPos, 1) = Len(StrainSeq(0))
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                            X1 = 30 + 0 * XFactor + XFactor
                            X2 = 30 + Ending * XFactor + XFactor
                            'Prob = -log10(Prob)
                            MCPrintData(2, CurPPos) = Prob
                            MCPrintPos(2, CurPPos, 0) = 1
                            MCPrintPos(2, CurPPos, 1) = Ending
                            CurPPos = CurPPos + 1
                            Y1 = PicHeight - (15 + (Prob / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
                            Y2 = PicHeight - 15
                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
                        End If
                    End If

                ElseIf left$(temp$, 8) = "#   Name" Then
                Else

                    If left$(temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(StraiName(GCSeq1))
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        TargetString = Trim$(StraiName(GCSeq1))
        'Form1.Picture7.DrawStyle = 2
    Next 'G

    
MinPVal = xMinP(GCSeq1, GCSeq2)
    Close #1
    'Form1.Picture7.DrawStyle = 0
    If SPF = 0 Then
        Call WriteNames(GCSeq1, GCSeq2, GCSeq3, Yellow, Green, Purple)
    End If
    

    Form1.Picture2.ForeColor = QBColor(0)
    'COff = -Log10((LowestProb / (MCCorrection)))
    'Y1 = PicHeight - (15 + (COff / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
    'Form1.Picture7.DrawStyle = 2
    'Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    'Y1 = PicHeight - (15 + (-Log10(LowestProb) / xMinP(GCSeq1, GCSeq2)) * (PicHeight - 35))
    'Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    
    Form1.Picture7.DrawStyle = 0

    If ORFFlag = 1 Then
        Form1.Picture20.Picture = Form1.Picture19.Image
        Form1.Picture20.Visible = True
    End If
    
    If pMCFlag = 0 Then

        MinPA = MinPA * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(1, MinPA)
    End If
    
    'See whether a results here should be added to the confirmation table or not.
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    PT = 10 ^ (-ConfirmP(EN, 1))
    
    If (Confirm(EN, 1) = 0 Or (Confirm(EN, 1) = 1 And MinPA < PT)) And MinPA < 1 Then
        Confirm(EN, 1) = 1
        ConfirmP(EN, 1) = -Log10(MinPA)
        DoEvents

        If Form1.HScroll3.Value = 0 Then
            Form1.HScroll3.Value = 1
        Else
            Form1.HScroll3.Value = 0
        End If

    End If
    
    ProbTest = MinPA
    ProbY = 1

    If XOverList(RelX, RelY).Ending > XOverList(RelX, RelY).Beginning Then
        ProbX = XOverList(RelX, RelY).Beginning + (XOverList(RelX, RelY).Ending - XOverList(RelX, RelY).Beginning) / 2

        If MinPA < 1 Then
            If SPF = 0 Then Call PrintProbability
        End If

    Else

        If Len(StrainSeq(0)) - XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
            ProbX = XOverList(RelX, RelY).Beginning + (Len(StrainSeq(0)) - XOverList(RelX, RelY).Beginning) / 2

            If MinPA < 1 Then
                If SPF = 0 Then Call PrintProbability
            End If
        Else
            ProbX = XOverList(RelX, RelY).Ending / 2

            If MinPA < 1 Then
                If SPF = 0 Then Call PrintProbability
            End If

        End If

    End If
    If SPF = 0 Then
        Form1.SSPanel1.Caption = ""
        Screen.MousePointer = 0
    End If
End Sub
Static Function Log10(X As Double)

    If X > 0 Then
        Log10 = Log(X) / Log(10#)
    Else
        Log10 = Log(10) / Log(10#)
    End If

End Function
Static Function StepUp(X, Y)
CurrentCorrect = X
If CurrentCorrect >= AddNum Then CurrentCorrect = CurrentCorrect - AddNum
Dim LPV As Double
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If

Dim RPV As Double
If MCFlag = 2 Then
    For Z = 0 To 100
        
        If PValCat(CurrentCorrect, Z) > 0 Then
            RPV = Y / PValCat(CurrentCorrect, Z)
            LPV = CInt(-Log10(RPV) * 2)
            If LPV > 100 Then LPV = 100
            If Y > (RPV * PValCat(CurrentCorrect, LPV) * 0.99999) And Y < RPV * PValCat(CurrentCorrect, LPV) / 0.99999 Then
              Exit For
            End If
        End If
    Next Z
    
End If
StepUp = RPV



End Function
Static Function StepDown2(X, Y)
CurrentCorrect = X
Dim LPV2 As Double
LPV2 = Y
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If

LPV = CInt(-Log10(LPV2) * 2)
If LPV > 0 Then
    If LPV < 100 Then
        If PValCat(CurrentCorrect, LPV + 1) > 0 Then
            If (Y * PValCat(CurrentCorrect, LPV)) > (MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)) Then
                PVal = Y * PValCat(CurrentCorrect, LPV)
            Else
                PVal = MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)
            End If
        Else
            PVal = Y * MC
        End If
    Else
        PVal = Y * MC
    End If
End If

StepDown2 = PVal
End Function
Static Function Exp10(X As Double)
    
    'If X > 0 Then
        Exp10 = Exp(X * Log(10#))
    'Else
    '    Exp10 = 1
    'End If

End Function
Public Sub GCCompare()

    Dim NewName As String
    Dim ODir As String

    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    NewName = "comptf"
    On Error Resume Next
    Close #1
    
    Open NewName For Output As #1
    'Exit Sub
    'NewName = comptf
    'output in FASTA format
    If LongWindedFlag = 1 Then
        Dim TempSeq(2) As String
        LS = Len(StrainSeq(0))
        TempSeq(0) = ""
        TempSeq(1) = ""
        TempSeq(2) = ""
        For X = 1 To Len(StrainSeq(0))
            TempSeq(0) = TempSeq(0) + Chr(SeqNum(X, GCSeq1) - 1)
            TempSeq(1) = TempSeq(1) + Chr(SeqNum(X, GCSeq2) - 1)
            TempSeq(2) = TempSeq(2) + Chr(SeqNum(X, GCSeq3) - 1)
        Next X
        
    End If
    
    Print #1, ">" & StraiName(GCSeq1)
    Print #1, TempSeq(0)
    Print #1, ">" & StraiName(GCSeq2)
    Print #1, TempSeq(1)
    Print #1, ">" & StraiName(GCSeq3)
    Print #1, TempSeq(2)
    Close #1
    GCCFile = CurDir & "\comp.frags"
    GCCompCfg = CurDir & "\comp.cfg"
    Open "comp.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=comptf"
    Print #1, "-Outfile=comp"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    ' Print #1, "/mkz"

    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    If GCCodeFlag = 0 Then
    Else
        Print #1, "-Mitcodes"
    End If

    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'Print #1, "-SortGfragsBySeq"
    'Print #1, "-SortGfragsBoth"
    '  If GCEndLen > 0 Then
    '      Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    '
    '  End If
    ' If GCOffsetAddjust > 0 Then
    '     Print #1, "-AddOffset=" & GCOffsetAddjust
    ' End If
    Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=1"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v1000" '& GCMaxOverlapFrags
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    Print #1, "-Numsim=0"
    'Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal
    Print #1, "-Maxkapairwisepval=0.99999"
    'Print #1, "/mz"
    'Print #1, "-Listonly=" & StraiName(GCSeq1) & "," & StraiName(GCSeq2) & ";" & StraiName(GCSeq1) & "," & StraiName(GCSeq3) & ";" & StraiName(GCSeq2) & "," & StraiName(GCSeq3)
    Close #1
    'LowestProb = cdbl(Form1.Text1.Text)
    'Print #1, "/x"
    cProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(App.Path & "\geneconv comp.cfg", 0))
    On Error GoTo 0
    
    
    On Error Resume Next
    ChDir ODir
    ChDrive ODir
    On Error GoTo 0
End Sub

Public Sub DoText(AngPict As Object, AngFont As StdFont, AngText As String, Angle As Single)     ' Parameters:
    'angpict: picture box, etc to draw text in
    'angfont: Font object with info about font to use
    'angtext: text to print
    'angle : angle, measured anti-clockwise from horizontal: ----->

    Dim newfont As Long
    Dim OldFont As Long
    Dim angweight As Long

    If AngFont.Bold = True Then
        angweight = FW_BOLD
    Else
        angweight = FW_NORMAL
    End If

    newfont = CreateFont(AngFont.Size * 2, 0, Angle * 10, 0, angweight, AngFont.Italic, AngFont.Underline, AngFont.Strikethrough, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH Or FF_DONTCARE, AngFont.Name)
    OldFont = SelectObject(AngPict.hdc, newfont)
    AngPict.Print AngText
    newfont = SelectObject(AngPict.hdc, OldFont)

    If DeleteObject(newfont) = 0 Then
        'could not remove font from GDI heap
    End If

End Sub

Public Sub GCXOverB()
    
    If ShortOutFlag = 0 Then
        On Error Resume Next
            LowestProb = Val(Form1.Text1.Text)
            LowestProb = CDbl(Form1.Text1.Text)
        On Error GoTo 0
    End If
    Dim tExitCode As Long

    Const STILL_ACTIVE = &H103

    If hProcess > 0 Then
        GetExitCodeProcess hProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess hProcess, tExitCode
        End If

        CloseHandle hProcess
        hProcess = 0
    End If

    Dim X As Long, Y As Long
    Dim NewName As String, ODir As String, LList As String

    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    NewName = "tf"
    GCFragSeq = CurDir & "tf"
    GCFragCfg = CurDir & "config.cfg"
    Open NewName For Output As #1
    'output in FASTA format

    For X = 0 To NextNo

        If MaskSeq(X) <= 1 Then

            If MaskSeq(X) = 1 Then MaskFlag = 1
            Print #1, ">" & StraiName(X)
            Print #1, StrainSeq(X)
        End If

    Next 'X

    Close #1
    'Dim DOSCommand As String
    'DOSCommand = "dir  > tempout.dat"
    'Open "dbat.bat" For Output As #1
    'Print #1, DOSCommand
    'Close #1
    Open "config.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=" & GCOutfileName
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If
    Dim ProbString As String
    
    If MCFlag = 0 Then
        ProbString = LowestProb
    Else
        ProbString = (LowestProb * MCCorrect)
    End If
    Pos = InStr(1, ProbString, ",", vbBinaryCompare)
    If Pos > 0 Then Mid(ProbString, Pos, 1) = "."
    If ShortOutFlag = 3 And GCNumPerms > 0 Then
    
    Else
        Print #1, "-Maxkaglobalpval=" & ProbString
    End If
    
    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    If GCCodeFlag = 0 Then
    Else
        Print #1, "-Mitcodes"
    End If

    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)

    If GCOutFlag = 0 Then
        'Label27.Caption = "Space separated output"
        Print #1, "-Dumpfrag"
    ElseIf GCOutFlag = 1 Then
        'Label27.Caption = "Tab separated output"
        Print #1, "-Dumptab"
    ElseIf GCOutFlag = 2 Then
        'Label27.Caption = "DIF-format spreadsheet output"
        Print #1, "-Dumpdif"
    ElseIf GCOutFlag = 3 Then
        'Label27.Caption = "Output in all formats"
        Print #1, "-Dumpall"
    End If

    If GCOutFlagII = 0 Then
        'Label33.Caption = "Simple output"
        'Command29.Enabled = False
    Else
        'Label33.Caption = "Maximum output"
        Print #1, "/sb /sp  /sd -Show_maxmeansims -ShowUnal"
    End If

    If GCSortFlag = 0 Then
        'Label34.Caption = "Sort fragment lists by P-Value"
    ElseIf GCSortFlag = 1 Then
        'Label34.Caption = "Sort fragment lists alphabetically by name"
        Print #1, "-SortGfragsBySeq"
    ElseIf GCSortFlag = 2 Then
        'Label34.Caption = "Sort fragment lists by P-Value then name"
        Print #1, "-SortGfragsBoth"
    End If

    If GCEndLen > 0 Then
        Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    End If

    If GCOffsetAddjust > 0 Then
        Print #1, "-AddOffset=" & GCOffsetAddjust
    End If

    If GCLogFlag = 0 Then
        'Label28.Caption = "Write log file"
    ElseIf GCLogFlag = 1 Then
        'Label28.Caption = "Append existing log file"
        Print #1, "-Logappend"
    ElseIf GCLogFlag = 2 Then
        'Label28.Caption = "Do not write log file"
        Print #1, "-Nolog"
    End If

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If
    Dim NFr As Double
    If GCMaxGlobFrags > GCMaxPairFrags Then
        NFr = GCMaxGlobFrags
    Else
        NFr = GCMaxPairFrags
    End If
    
    If MCFlag = 0 Then
        Print #1, "-ListGlobal=" & NFr
        Print #1, "-ListPerPair=0"
    Else
        Print #1, "-ListGlobal=0"
        Print #1, "-ListPerPair=" & NFr
        
    End If
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore
    Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    Print #1, "-Numsim=" & GCNumPerms

    If GCNumPerms > 0 Then
        Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    End If

    If MaskFlag = 1 Then
        'Listonly List
        LList$ = ""

        For X = 0 To NextNo

            If MaskSeq(X) = 0 Then

                For Y = X + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(X) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    'Print #1, "-Mult_poly_only"
    'Print #1, "/x"
    'GCGroupFlag = 1
    If GCGroupFlag = 1 Then
        For X = 0 To NextNo
            If GCGroups(X) <> "" Then
                'Print #1, GCGroups(X)
            Else
                Exit For
            End If
        Next X
    End If
    
    
    Close #1
    
    
    'RetVal = Shell(App.Path & "\geneconv tempfile", 1)   ' Run geneconv
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell("dbat.bat", 1))
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell(App.Path & "\geneconv tempfile  /n0 /mkg " & LowestProb & " /v9 -ExpFormat", 0))
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(App.Path & "\geneconv config.cfg", 0))
    ChDir ODir
    ChDrive ODir
End Sub
Public Sub GCXoverC(SPF)
    Dim TStr As String
   
    If ShortOutFlag = 0 Then
        On Error Resume Next
            LowestProb = Val(Form1.Text1.Text)
            LowestProb = CDbl(Form1.Text1.Text)
        On Error GoTo 0
    End If
    
    Dim tExitCode As Long

    Const STILL_ACTIVE = &H103

    If hProcess > 0 Then
        GetExitCodeProcess hProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess hProcess, tExitCode
        End If

        CloseHandle hProcess
        hProcess = 0
    End If

    Dim X As Long, Y As Long
    Dim NewName As String, ODir As String, LList As String

    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    NewName = "tf"
    GCFragSeq = CurDir & "tf"
    GCFragCfg = CurDir & "config.cfg"
    Open NewName For Output As #1
    'output in FASTA format

    For X = 0 To NextNo

        If MaskSeq(X) <= 1 Then

            If MaskSeq(X) = 1 Then MaskFlag = 1
            Print #1, ">" & StraiName(X)
            Print #1, StrainSeq(X)
        End If

    Next 'X

    Close #1
    'Dim DOSCommand As String
    'DOSCommand = "dir  > tempout.dat"
    'Open "dbat.bat" For Output As #1
    'Print #1, DOSCommand
    'Close #1
    Open "config.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=" & GCOutfileName
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If MCFlag = 0 Then
        TStr = Str(LowestProb)
        Pos = InStr(1, TStr, ",", vbBinaryCompare)
        If Pos > 0 Then Mid(TStr, Pos, 1) = "."
        Print #1, "-Maxkaglobalpval=" & TStr
    Else
        TStr = Str(LowestProb / MCCorrect)
        Pos = InStr(1, TStr, ",", vbBinaryCompare)
        If Pos > 0 Then Mid(TStr, Pos, 1) = "."
        Print #1, "-Maxkaglobalpval=" & TStr
    End If

    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    If GCCodeFlag = 0 Then
    Else
        Print #1, "-Mitcodes"
    End If

    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)

    If GCOutFlag = 0 Then
        'Label27.Caption = "Space separated output"
        Print #1, "-Dumpfrag"
    ElseIf GCOutFlag = 1 Then
        'Label27.Caption = "Tab separated output"
        Print #1, "-Dumptab"
    ElseIf GCOutFlag = 2 Then
        'Label27.Caption = "DIF-format spreadsheet output"
        Print #1, "-Dumpdif"
    ElseIf GCOutFlag = 3 Then
        'Label27.Caption = "Output in all formats"
        Print #1, "-Dumpall"
    End If

    If GCOutFlagII = 0 Then
        'Label33.Caption = "Simple output"
        'Command29.Enabled = False
    Else
        'Label33.Caption = "Maximum output"
        Print #1, "/sb /sp  /sd -Show_maxmeansims -ShowUnal"
    End If

    If GCSortFlag = 0 Then
        'Label34.Caption = "Sort fragment lists by P-Value"
    ElseIf GCSortFlag = 1 Then
        'Label34.Caption = "Sort fragment lists alphabetically by name"
        Print #1, "-SortGfragsBySeq"
    ElseIf GCSortFlag = 2 Then
        'Label34.Caption = "Sort fragment lists by P-Value then name"
        Print #1, "-SortGfragsBoth"
    End If

    If GCEndLen > 0 Then
        Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    End If

    If GCOffsetAddjust > 0 Then
        Print #1, "-AddOffset=" & GCOffsetAddjust
    End If

    If GCLogFlag = 0 Then
        'Label28.Caption = "Write log file"
    ElseIf GCLogFlag = 1 Then
        'Label28.Caption = "Append existing log file"
        Print #1, "-Logappend"
    ElseIf GCLogFlag = 2 Then
        'Label28.Caption = "Do not write log file"
        Print #1, "-Nolog"
    End If

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=" & GCMaxGlobFrags
    Print #1, "-ListPerPair=" & GCMaxPairFrags
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore
    Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    Print #1, "-Numsim=" & GCNumPerms

    If GCNumPerms > 0 Then
        Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    End If

    If MaskFlag = 1 Then
        'Listonly List
        LList$ = ""

        For X = 0 To NextNo

            If MaskSeq(X) = 0 Then

                For Y = X + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(X) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    'Print #1, "-Mult_poly_only"
    'Print #1, "/x"
    'GCGroupFlag = 1
    If GCGroupFlag = 1 Then
        For X = 0 To NextNo
            If GCGroups(X) <> "" Then
                'Print #1, GCGroups(X)
            Else
                Exit For
            End If
        Next X
    End If
    
    
    Close #1
    
    
    'RetVal = Shell(App.Path & "\geneconv tempfile", 1)   ' Run geneconv
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell("dbat.bat", 1))
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell(App.Path & "\geneconv tempfile  /n0 /mkg " & LowestProb & " /v9 -ExpFormat", 0))
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(App.Path & "\geneconv config.cfg", 0))
    
    
    
    ChDir ODir
    ChDrive ODir
End Sub
Public Sub GCXoverE()
'this is the triplet scanning version of geneconv
Dim LSeq As Long, Y As Long, X As Long, SX As Long, NDiff() As Long, MissPen() As Double

LSeq = Len(StrainSeq(0))
'find relevant sites
ReDim XDiffpos(LSeq + 200)
ReDim XPosdiff(LSeq + 200)
Dim SubSeq() As Byte

ReDim SubSeq(LSeq, 6)
ReDim NDiff(5)
ReDim MissPen(5)
Y = 0
If GCMonoSiteFlag = 0 Then
    For X = 1 To LSeq
        XPosdiff(X) = Y
        If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                SubSeq(Y, 0) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(X, Seq2) = SeqNum(X, Seq3)) / 255
            ElseIf GCIndelFlag = 1 Then
                SX = X
                X = X + 1
                Do While (SeqNum(X, Seq1) = 46 Or SeqNum(X, Seq2) = 46 Or SeqNum(X, Seq3) = 46) And X < LSeq
                    X = X + 1
                Loop
                X = X - 1
                Y = Y + 1
                XPosdiff(CLng(SX + (X - SX) / 2)) = Y
                XDiffpos(Y) = CLng(SX + (X - SX) / 2)
                SubSeq(Y, 0) = CByte(Mid$(StrainSeq(Seq1), SX, X - SX + 1) = Mid$(StrainSeq(Seq2), SX, X - SX + 1)) / 255
                SubSeq(Y, 1) = CByte(Mid$(StrainSeq(Seq1), SX, X - SX + 1) = Mid$(StrainSeq(Seq3), SX, X - SX + 1)) / 255
                SubSeq(Y, 2) = CByte(Mid$(StrainSeq(Seq2), SX, X - SX + 1) = Mid$(StrainSeq(Seq3), SX, X - SX + 1)) / 255
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                SubSeq(Y, 0) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(X, Seq2) = SeqNum(X, Seq3)) / 255
            End If
            SubSeq(Y, 6) = CByte((SubSeq(Y, 0) = 0 And SubSeq(Y, 1) = 0 And SubSeq(Y, 2) = 0)) / 255
        End If
        
    Next X
Else
    For X = 1 To LSeq
        XPosdiff(X) = Y
        'If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                SubSeq(Y, 0) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(X, Seq2) = SeqNum(X, Seq3)) / 255
            ElseIf GCIndelFlag = 1 Then
                SX = X
                X = X + 1
                Do While (SeqNum(X, Seq1) = 46 Or SeqNum(X, Seq2) = 46 Or SeqNum(X, Seq3) = 46) And X < LSeq
                    X = X + 1
                Loop
                X = X - 1
                Y = Y + 1
                XPosdiff(CLng(SX + (X - SX) / 2)) = Y
                XDiffpos(Y) = CLng(SX + (X - SX) / 2)
                SubSeq(Y, 0) = CByte(Mid$(StrainSeq(Seq1), SX, X - SX) = Mid$(StrainSeq(Seq2), SX, X - SX)) / 255
                SubSeq(Y, 1) = CByte(Mid$(StrainSeq(Seq1), SX, X - SX) = Mid$(StrainSeq(Seq3), SX, X - SX)) / 255
                SubSeq(Y, 2) = CByte(Mid$(StrainSeq(Seq2), SX, X - SX) = Mid$(StrainSeq(Seq3), SX, X - SX)) / 255
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                SubSeq(Y, 0) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(X, Seq1) = SeqNum(X, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(X, Seq2) = SeqNum(X, Seq3)) / 255
            End If
        'End If
        SubSeq(Y, 6) = CByte((SubSeq(Y, 0) = 0 And SubSeq(Y, 1) = 0 And SubSeq(Y, 2) = 0)) / 255
    Next X
End If

LenXOverSeq = Y
XDiffpos(Y + 1) = LSeq
For X = 1 To LenXOverSeq
    NDiff(0) = NDiff(0) + SubSeq(X, 0)
    NDiff(1) = NDiff(1) + SubSeq(X, 1)
    NDiff(2) = NDiff(2) + SubSeq(X, 2)
Next X

If NDiff(0) = LenXOverSeq Or NDiff(1) = LenXOverSeq Or NDiff(2) = LenXOverSeq Then Exit Sub

'for outer frags (ie matches instead of differences)
NDiff(3) = NDiff(0) + NDiff(1) 'seq1
NDiff(4) = NDiff(0) + NDiff(2)  'seq2
NDiff(5) = NDiff(1) + NDiff(2)  'seq3

'for inner fargs (ie genuine differences)
NDiff(0) = LenXOverSeq - NDiff(0)
NDiff(1) = LenXOverSeq - NDiff(1)
NDiff(2) = LenXOverSeq - NDiff(2)

MissPen(0) = Int(LenXOverSeq * GCMissmatchPen / NDiff(0)) + 1
MissPen(1) = Int(LenXOverSeq * GCMissmatchPen / NDiff(1)) + 1
MissPen(2) = Int(LenXOverSeq * GCMissmatchPen / NDiff(2)) + 1

MissPen(3) = Int(LenXOverSeq * GCMissmatchPen / NDiff(3)) + 1
MissPen(4) = Int(LenXOverSeq * GCMissmatchPen / NDiff(4)) + 1
MissPen(5) = Int(LenXOverSeq * GCMissmatchPen / NDiff(5)) + 1


'Calc LL and KMax
Dim LL() As Double, KMax() As Double, q As Double, P As Double
ReDim LL(5)
ReDim KMax(5)

For X = 0 To 5
    LL(X) = 0
    
    If NDiff(X) > 0 And NDiff(X) < LenXOverSeq Then 'And MissPen(X) >= 1 And (MissPen(X) + 1) * ndiff(x) > lenxoverseq Then
    
        P = NDiff(X) / LenXOverSeq
        q = 1 - P
        mP = MissPen(X) * P
        '/* If the mismatch penalty is infinite: */
        If GCMissmatchPen = 0 Then
            LL(X) = -Log(q)
            KMax(X) = P
        Else
   
            '/* ll and kmax depend only on MissPen(X), ndiff(x), and lenxoverseq: */
            '/*   Have we seen these values before? */
            'Maybe I should work out a way to fill an array with these values and
            'look them up - array dims would be MissPen(X),lenxoverseq,ndiff(x)f
            '/* Use the Newton-Raphson method to compute ll by solving   */
            '/*                                                   */
            '/*    phi(ll) = q*exp(ll)+p*exp(-MissPen(X)*ll) = 1,  ll>0   */
            '/*                                                   */
            '/* Note  phi(0)=1 and phi'(0) = 1-(MissPen(X)+1)*p < 0,      */
            '/*    which should guarantees a solution  ll>0       */
            '/*                                                   */
            '/* The global minimum of phi(ll) is at ll0=log(mp/q)/(MissPen(X)+1)   */
    
            K = 0
            ll0 = Log(mP / q) / (MissPen(X) + 1)
            Z = Exp(2 * ll0)
            Do
                
                zm = Z ^ (-MissPen(X))
                yy = q * Z + P * zm - 1
                zdel = yy / (q - mP * zm / Z)
                Z = Z - zdel
                
            Loop While (Abs(zdel) > 0.000001 Or Abs(yy) > 0.000001)
    
            LL(X) = Log(Z)
            KMax(X) = (Exp(LL(X)) - 1) * (q - mP * Exp(-(MissPen(X) + 1) * LL(X)))
       End If
    End If
Next X

'Find fragment lists
Dim FragSep() As Long, FragCount() As Long, FragSt() As Long, FragEn() As Long, FragScore() As Long

ReDim FragSt(LenXOverSeq, 6)
ReDim FragEn(LenXOverSeq, 6)
ReDim FragScore(LenXOverSeq, 6)
ReDim MFragSt(LenXOverSeq, 6)
ReDim MFragEn(LenXOverSeq, 6)
ReDim MFragScore(LenXOverSeq, 6)

ReDim FragCount(6)
ReDim MFragCount(6)
'Find Fragments
For X = 1 To LenXOverSeq
    
    For Y = 0 To 2
        If SubSeq(X, Y) = 1 Then Exit For
    Next Y
    If Y = 3 Then
        Y = 6
    End If
    FragSt(FragCount(Y), Y) = X
    X = X + 1
    Do While SubSeq(X, Y) = 1 And X <= LenXOverSeq
        X = X + 1
    Loop
    X = X - 1
    If X > LenXOverSeq Then
        'sort out frags that overlap the ends
    End If
    FragEn(FragCount(Y), Y) = X
    FragScore(FragCount(Y), Y) = FragEn(FragCount(Y), Y) - FragSt(FragCount(Y), Y) + 1
        'If Y <= 2 Then
             For Z = 0 To 2
                 If Y <> Z Then
                     FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                     FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                     FragScore(FragCount(Z), Z) = -FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                     FragCount(Z) = FragCount(Z) + 1
                 End If
             Next Z
        ' End If
        If Y = 0 Then
            Z = 5
        ElseIf Y = 1 Then
            Z = 4
        ElseIf Y = 2 Then
            Z = 3
        ElseIf Y = 6 Then
            Z = 6
        End If
        If Z < 6 Then
            
            If FragCount(Z) > 0 Then
                If FragScore(FragCount(Z) - 1, Z) > 0 Then
                    
                    FragEn(FragCount(Z) - 1, Z) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(Z) - 1, Z) = FragScore(FragCount(Z) - 1, Z) + FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    
                Else
                    FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(Z), Z) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(Z) = FragCount(Z) + 1
                End If
            Else
                FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                FragScore(FragCount(Z), Z) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                FragCount(Z) = FragCount(Z) + 1
            End If
            
            For A = 3 To 5
                If A <> Z Then
                    FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(A), A) = -FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(A) = FragCount(A) + 1
                End If
            Next A
        Else
            If FragCount(3) > 0 Then
                For A = 3 To 5
                    If FragScore(FragCount(A) - 1, A) > 0 Then
                            
                        FragEn(FragCount(A) - 1, A) = FragEn(FragCount(Y), Y)
                        FragScore(FragCount(A) - 1, A) = FragScore(FragCount(A) - 1, A) + FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                            
                    Else
                        FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                        FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                        FragScore(FragCount(A), A) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                        FragCount(A) = FragCount(A) + 1
                    End If
                Next A
            Else
                For A = 3 To 5
                    FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(A), A) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(A) = FragCount(A) + 1
                Next A
            End If
        End If
            
        If Y <= 2 Then
            FragCount(Y) = FragCount(Y) + 1
        End If
        FragCount(6) = FragCount(6) + 1
    
    
Next X

For X = 0 To 6
    FragSt(FragCount(X), X) = LenXOverSeq
    FragEn(FragCount(X), X) = LenXOverSeq
Next X

Dim FragMaxScore() As Long, MaxScorePos() As Long, TempScore As Long
ReDim FragMaxScore(LenXOverSeq, 5), MaxScorePos(LenXOverSeq, 5)
If GCMissmatchPen > 0 And X = X Then

    'Find the max score per frag by joing up frags, basically start at leftmost frag and
    'expand right, finding the max score including that frag -these are inner frags
    Dim Polys As Long, Diffs As Long
    
    If CircularFlag = 0 Then
        For X = 0 To 5
            For Y = 0 To FragCount(X)
                If FragScore(Y, X) > 0 Then
                 
                  TempScore = FragScore(Y, X)
                  Polys = TempScore
                  Diffs = 0
                  FragMaxScore(Y, X) = TempScore
                  MaxScorePos(Y, X) = Y
                  For Z = Y + 1 To FragCount(X)
                    Polys = Polys + Abs(FragScore(Z, X))
                    If FragScore(Z, X) <= 0 Then
                        Diffs = Diffs + Abs(FragScore(Z, X))
                    End If
                    
                    TempScore = Polys - Diffs + Diffs * (-MissPen(X))
                    
                    If TempScore >= FragMaxScore(Y, X) Then
                        FragMaxScore(Y, X) = TempScore
                        MaxScorePos(Y, X) = Z
                    ElseIf TempScore < -15 Then
                        Exit For
                    End If
                  Next Z
                End If
            Next Y
        Next X
    Else
        For X = 0 To 5
            For Y = 0 To FragCount(X)
                If FragScore(Y, X) > 0 Then
                  TempScore = FragScore(Y, X)
                  Polys = TempScore
                  Diffs = 0
                  FragMaxScore(Y, X) = TempScore
                  
                  For Z = Y + 1 To FragCount(X)
                    Polys = Polys + Abs(FragScore(Z, X))
                    If FragScore(Z, X) < 0 Then
                        Diffs = Diffs + Abs(FragScore(Z, X))
                    End If
                    
                    TempScore = Polys - Diffs + Diffs * (-MissPen(X))
                    
                    If TempScore >= FragMaxScore(Y, X) Then
                        FragMaxScore(Y, X) = TempScore
                        MaxScorePos(Y, X) = Z
                    ElseIf TempScore < -10 Then
                        Exit For
                    End If
                  Next Z
                    If TempScore > -10 Then
                        For Z = 0 To Y - 1
                          Polys = Polys + Abs(FragScore(Z, X))
                          If FragScore(Z, X) < 0 Then
                              Diffs = Diffs + Abs(FragScore(Z, X))
                          End If
                          
                          TempScore = Polys - Diffs + Diffs * (-MissPen(X))
                          
                          If TempScore >= FragMaxScore(Y, X) Then
                              FragMaxScore(Y, X) = TempScore
                              MaxScorePos(Y, X) = Z
                          ElseIf TempScore < -10 Then
                              Exit For
                          End If
                        Next Z
                    End If
                End If
            Next Y
        Next X
    End If
Else
    For X = 0 To 5
        For Y = 0 To FragCount(X)
            FragMaxScore(Y, X) = FragScore(Y, X)
            MaxScorePos(Y, X) = Y
        Next Y
    Next X
End If


Dim PVals() As Double, KAScore As Double, PVal As Double, MaxScore As Double, MaxY As Long, LKLen As Double
ReDim PVals(LenXOverSeq, 5)
Addon = 0
For X = 0 To 5
    MaxScore = 0
    
    'LKLen = Log(KMax(X) * NDiff(X))
    LKLen = Log(KMax(X) * LenXOverSeq)
    
    For Y = 0 To FragCount(X)
     
        
        
        KAScore = LL(X) * FragMaxScore(Y, X) - LKLen
        PVals(Y, X) = 1 - Exp(-Exp(-KAScore))
        'PVals(Y, X) = 1 - Exp(-KMax(X) * NDiff(X) * Exp(-(LL(X) * FragMaxScore(Y, X))))
        If FragMaxScore(Y, X) > MaxScore Then MaxScore = FragMaxScore(Y, X)
        
    Next Y
Next X
MaxScore = 10000
For X = 0 To 5
    For Y = 0 To FragCount(X)
        If MaxScore > PVals(Y, X) Then
            MaxScore = PVals(Y, X)
        End If
    Next Y
Next X
If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection

MaxScore = -Log10(MaxScore)
If MaxScore <= 0 Then MaxScore = 5
DoAxes Len(StrainSeq(0)), -1, MaxScore, 0, 1, "-Log(KA P-Val)"
Call Highlight
For X = 0 To 5
    
    If X = 0 Then
        Form1.Picture7.ForeColor = Yellow
    ElseIf X = 1 Then
        Form1.Picture7.ForeColor = Green
    ElseIf X = 2 Then
        Form1.Picture7.ForeColor = Purple
    ElseIf X = 3 Then
        Form1.Picture7.ForeColor = Purple
    ElseIf X = 4 Then
        Form1.Picture7.ForeColor = Green
    ElseIf X = 5 Then
        Form1.Picture7.ForeColor = Yellow
    End If
    For Y = 0 To FragCount(X)
        If FragSt(Y, X) > 0 Then
            
            
            'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
            If PVals(Y, X) < 0.9995 Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                Prob = -Log10(PVals(Y, X))
                Beginning = XDiffpos(FragSt(Y, X) - 1) + 1
                Ending = XDiffpos(FragEn(MaxScorePos(Y, X), X) + 1) - 1
                
                X1 = 30 + Beginning * XFactor + XFactor
                X2 = 30 + Ending * XFactor + XFactor
                
                
                'MCPrintData(0, CurPPos) = Prob
                'MCPrintPos(0, CurPPos, 0) = Beginning
                'MCPrintPos(0, CurPPos, 1) = Ending
                'CurPPos = CurPPos + 1
                Y1 = PicHeight - (15 + (Prob / MaxScore) * (PicHeight - 35))
                Y2 = PicHeight - 15
                Form1.Picture7.AutoRedraw = True
                Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
            End If
        Else
            Exit For
        End If
    Next Y
Next X

End Sub
Public Sub FindSubSeqGC2()
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
ReDim GCXOverSeq(2)
Y = 0
If GCMonoSiteFlag = 0 Then
    For X = 1 To Len(StrainSeq(0))
        
        XPosdiff(X) = Y
        If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                GCXOverSeq(0) = GCXOverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), X, 1)
                GCXOverSeq(1) = GCXOverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), X, 1)
                GCXOverSeq(2) = GCXOverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), X, 1)
            ElseIf GCIndelFlag = 1 Then
                SX = X
                X = X + 1
                
                If X < Len(StrainSeq(0)) Then
                    Do While X <= Len(StrainSeq(0))
                        If (SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46) Then
                            Exit Do
                        End If
                        X = X + 1
                    Loop
                End If
                X = X - 1
                Y = Y + 1
                
                If SX <> X Then
                
                    For Z = SX To X
                            If SeqNum(Z, Seq1) <> 46 Or SeqNum(Z, Seq2) <> 46 Or SeqNum(Z, Seq3) <> 46 Then
                                XDiffpos(Y) = Z
                                XPosdiff(Z) = Y
                                GCXOverSeq(0) = GCXOverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), Z, 1)
                                GCXOverSeq(1) = GCXOverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), Z, 1)
                                GCXOverSeq(2) = GCXOverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), Z, 1)
                                Exit For
                            End If
                    Next Z
                    
                Else
                    XPosdiff(X) = Y
                    XDiffpos(Y) = X
                    GCXOverSeq(0) = GCXOverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), X, 1)
                    GCXOverSeq(1) = GCXOverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), X, 1)
                    GCXOverSeq(2) = GCXOverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), X, 1)
                End If
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                GCXOverSeq(0) = GCXOverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), X, 1)
                GCXOverSeq(1) = GCXOverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), X, 1)
                GCXOverSeq(2) = GCXOverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), X, 1)
            End If
        End If
        
    Next X
Else
    GCXOverSeq(0) = StrainSeq(TreeTrace(Seq1))
    GCXOverSeq(1) = StrainSeq(TreeTrace(Seq2))
    GCXOverSeq(2) = StrainSeq(TreeTrace(Seq3))
    For X = 1 To Len(StrainSeq(0))
        XPosdiff(X) = Y
        'If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
                
            ElseIf GCIndelFlag = 1 Then
                SX = X
                X = X + 1
                Do While (SeqNum(X, Seq1) = 46 Or SeqNum(X, Seq2) = 46 Or SeqNum(X, Seq3) = 46) And X < Len(StrainSeq(0))
                    X = X + 1
                Loop
                X = X - 1
                Y = Y + 1
                XPosdiff(CLng(SX + (X - SX) / 2)) = Y
                XDiffpos(Y) = CLng(SX + (X - SX) / 2)
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosdiff(X) = Y
                XDiffpos(Y) = X
            End If
        'End If
    Next X
End If

LenXOverSeq = Y
XDiffpos(Y + 1) = Len(StrainSeq(0))
End Sub
Public Sub GCXoverD(FindAllFlag)


If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) = 0 And GrpMaskSeq(Seq2) = 0 And GrpMaskSeq(Seq3) = 0 Then
        Exit Sub
    End If
End If
'this is the auto triplet scanning version of geneconv
Dim Beginning As Long, Ending As Long, DoneRedo As Byte, THld As Double, FragSc As Double, LTG As Double, critval(5) As Double, pvm1, kmtl
Dim LSeq As Long, Y As Long, X As Long, SX As Long, NDiff() As Long, MissPen() As Double
Dim MaxX As Long, MaxY As Long, MPV As Double
Dim TempScore As Long
Dim ProbabilityXOver As Double
Dim KAScore As Variant, PVal As Double, MaxScore As Double, LKLen As Double
Dim Polys As Long, Diffs As Long
Dim FragSep() As Long, FragCount(6) As Long
Dim MaxDiff As Long
Dim MinDiff As Long
Dim FragMinScore As Long, tPX As Double
Dim LL(5) As Double, KMax(5) As Double, q As Double, P As Double, mx As Long
Dim DoneThis As Byte, B1 As Long, E1 As Long
Dim DeleteArray() As Long, PCO As Double

LSeq = Len(StrainSeq(0))
HiFragScore(0) = 0
HiFragScore(1) = 0
HiFragScore(2) = 0
HiFragScore(3) = 0
HiFragScore(4) = 0
HiFragScore(5) = 0

ReDim NDiff(5), MissPen(5)

'XX = FragScore(121, 0)
'XX = FragScore(121, 1)
'XX = FragScore(121, 2)
'XX = FragScore(0, 3)
'XX = FragScore(106, 4)
'XX = FragScore(106, 5)
' 1.000 5k perms
'2.766 5k perms



'find relevant sites
'this coluld be speeded up with better nesting of if then's
LenXOverSeq = FindSubSeqGCA(GCIndelFlag, LSeq, Seq1, Seq2, Seq3, SeqNum(0, 0), SubSeq(0, 0), XPosdiff(0), XDiffpos(0), NDiff(0))

SubSeq(LenXOverSeq + 1, 0) = 0
SubSeq(LenXOverSeq + 1, 1) = 0
SubSeq(LenXOverSeq + 1, 2) = 0
SubSeq(LenXOverSeq + 1, 6) = 0

If NDiff(0) = LenXOverSeq Or NDiff(1) = LenXOverSeq Or NDiff(2) = LenXOverSeq Then Exit Sub

'2.223
'1.883
'lxo = 349,n0=250,1=39,2=49,3=289,4=299,5=88
XDiffpos(LenXOverSeq + 1) = LSeq

Y = XDiffpos(LenXOverSeq) + 1

For X = LSeq To Y Step -1
    XPosdiff(X) = LenXOverSeq
Next

'1.875

'for outer frags (ie matches instead of differences)
NDiff(3) = NDiff(0) + NDiff(1) 'seq1
NDiff(4) = NDiff(0) + NDiff(2)  'seq2
NDiff(5) = NDiff(1) + NDiff(2)  'seq3

'for inner fargs (ie genuine differences)
NDiff(0) = LenXOverSeq - NDiff(0)
NDiff(1) = LenXOverSeq - NDiff(1)
NDiff(2) = LenXOverSeq - NDiff(2)

LTG = LenXOverSeq * GCMissmatchPen
'ltg=349
MissPen(0) = Int(LTG / NDiff(0)) + 1
MissPen(1) = Int(LTG / NDiff(1)) + 1
MissPen(2) = Int(LTG / NDiff(2)) + 1
'mpen = 4,2,2
MaxDiff = 0
MinDiff = Len(StrainSeq(0))

For X = 0 To 5
    If MinDiff > NDiff(X) Then MinDiff = NDiff(X)
    If MaxDiff < NDiff(X) Then MaxDiff = NDiff(X)
Next X

If MinDiff < 3 And MaxDiff > MinDiff * 10 Then Exit Sub


If NDiff(3) = 0 Then NDiff(3) = 1
If NDiff(4) = 0 Then NDiff(4) = 1
If NDiff(5) = 0 Then NDiff(5) = 1

MissPen(3) = Int(LTG / NDiff(3)) + 1
MissPen(4) = Int(LTG / NDiff(4)) + 1
MissPen(5) = Int(LTG / NDiff(5)) + 1

'1.962
'1.563 desktop

'Find Fragments
GoOn = GetFrags(CircularFlag, LenXOverSeq, Len(StrainSeq(0)), SubSeq(0, 0), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))

'6.309,6.179,6.480
'6.028,5.468,5.458
'5.377,5.278,5.377

'3.609, 3.625 desktop
'3.531,3.571

If GoOn = 0 And ShortOutFlag <> 3 Then Exit Sub

For X = 0 To 6
    FragSt(FragCount(X), X) = LenXOverSeq
    FragEn(FragCount(X), X) = LenXOverSeq
Next X

 
GetMaxFragScore LenXOverSeq, Len(StrainSeq(0)), CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)



'11.877,11.827
'11.1126 - using offsets
'11.026,11.036 - using offsets in maxfragscore rather than a holder.

'5.671, 5.656 -desktop
For X = 0 To 5
    If HiFragScore(X) > 3 Then
        HighEnough(X) = 1
    Else
        HighEnough(X) = 0
    End If
Next X


'Calc LL and KMax

CalcKMax GCMissmatchPen, LenXOverSeq, MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0)

'5.688,5.687


'//(log(kmax*lenxoverseq)-log(-log(1-pval)))/ll(x) = score
'calculate critical fragment length
If MCFlag = 0 Then
    PCO = LowestProb / MCCorrection
Else
    PCO = LowestProb
End If

If PCO > 1 Then
    Exit Sub
End If

'Exit Sub
For X = 0 To 5
    If KMax(X) > 0 Then
        kmtl = KMax(X) * LenXOverSeq
        kmtl = Log(kmtl)
        
        pvm1 = (1 - PCO)
        
        
        pvm1 = -Log(pvm1)
        If pvml > 0 Then
            pvm1 = -Log(pvm1)
            critval(X) = (kmtl + pvm1) / LL(X)
            If critval(X) < 4 Then critval(X) = 4
        Else
            critval(X) = 4
        End If
    End If
Next X

GoOn = 0
For X = 0 To 5
    HighEnough(X) = 0
    If HiFragScore(X) > 3 And HiFragScore(X) > critval(X) Then
        HighEnough(X) = 1
        GoOn = 1
    End If
Next X

If GoOn = 0 Then Exit Sub

Addon = 0

'5.813,5.828
MaxScore = GCCalcPVal(Len(StrainSeq(0)), LenXOverSeq, FragMaxScore(0, 0), PVals(0, 0), FragCount(0), KMax(0), LL(0), HighEnough(0), critval(0))

'5.906,5.844

If ShortOutFlag = 3 Then
    If MaxScore * MCCorrection <= mtP(1) Then
        mtP(1) = MaxScore * MCCorrection
    End If
End If


If MaxScore > PCO Then Exit Sub

ReDim DeleteArray(LenXOverSeq + 1)

DoneThis = 0
zzzxz = 0
'Exit Sub


Do
    MPV = GCGetHiPVal(Len(StrainSeq(0)), LenXOverSeq, FragCount(0), PVals(0, 0), MaxY, MaxX, HighEnough(0))
    zzzxz = zzzxz + 1
    '10.425,10.735
    '9.974
   ' If zzzxz = 1 And Seq1 = 16 And Seq3 = 38 And Seq2 = 24 And SEventNumber = 2 Then
   '     X = X
   ' End If
    
    If MPV > PCO Then Exit Sub
    X = MaxX
    Y = MaxY
    
    
    GoOn = DelPVals(GCMaxOverlapFrags, Y, X, Len(StrainSeq(0)), PVals(0, 0), FragCount(0), FragSt(0, 0), FragEn(0, 0), MaxScorePos(0, 0), DeleteArray(0))
    
    If GoOn = 1 Then
        
        
        
        'For Y = 0 To FragCount(X)
            'If FragSt(Y, X) > 0 Then
                
                
                'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
                If PVals(Y, X) < PCO Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                    
                    If FragSt(Y, X) > 0 Then
                        If LongWindedFlag = 0 Then
                            Beginning = XDiffpos(FragSt(Y, X) - 1) + 1
                        Else
                            Beginning = XDiffpos(FragSt(Y, X))
                        End If
                    Else
                        Beginning = 1
                    End If
                    If LongWindedFlag = 0 Then
                        Ending = XDiffpos(FragEn(MaxScorePos(Y, X), X) + 1) - 1
                    Else
                        Ending = XDiffpos(FragEn(MaxScorePos(Y, X), X))
                    End If
                    
                    
                    If LongWindedFlag = 1 Then
                        If CurrentXover(Seq1) <= CurrentXover(Seq2) And CurrentXover(Seq1) <= CurrentXover(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf CurrentXover(Seq2) <= CurrentXover(Seq1) And CurrentXover(Seq2) <= CurrentXover(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        Else
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                        'check to see if an event has been extended accross a tract of
                        'missing data
                         splitx = 0
                         EWarn = 0
                         BWarn = 0
                         If XPosdiff(Beginning) > 0 Then
                            bee = XDiffpos(XPosdiff(Beginning) - 1)
                        Else
                            bee = Beginning
                        End If
                        If XDiffpos(Ending) < Len(StrainSeq(0)) Then
                            enn = XDiffpos(XPosdiff(Ending) + 1)
                        Else
                            enn = Ending
                        End If
                        If bee < 1 Then bee = Len(StrainSeq(0))
                        If enn > Len(StrainSeq(0)) Then enn = 1
                        Z = CheckSplit(Len(StrainSeq(0)), bee, enn, Seq1, Seq2, Seq3, splitx, MissingData(0, 0))
                        
                    Else
                        splitx = 0
                        If X = 0 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf X = 1 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq2
                        ElseIf X = 2 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq1
                        ElseIf X = 3 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf X = 4 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf X = 5 Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq1
                        End If
                    End If
                    'SplitX = 0
                    'If X >= 3 Then SplitX = 0
                    XX = X
                    If splitx = 1 And X < 3 Then
                        For A = 0 To 1
                            If A = 0 Then
                                BTarget = XPosdiff(Beginning)
                                
                                ETarget = XPosdiff(Z) - 1
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            Else
                                B = FindMissing(Len(StrainSeq(0)), Seq1, Seq2, Seq3, Z, Ending, MissingData(0, 0))
                                If XPosdiff(B) <> 0 Then
                                    BTarget = XPosdiff(B) + 1
                                Else
                                    Gg = B
                                    Do While XPosdiff(Gg) = 0
                                        Gg = Gg + 1
                                        
                                        If Gg > Len(StrainSeq(0)) Then
                                            Gg = 0
                                            
                                        End If
                                    Loop
                                    BTarget = XPosdiff(Gg)
                                End If
                                ETarget = XPosdiff(Ending)
                                
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            End If
                            
                            ProbabilityXOver = MakeSubProb(X, Len(StrainSeq(0)), LenXOverSeq, BTarget, ETarget, SubSeq(0, 0), LL(0), KMax(0), MissPen(0), critval(0))
                            If ProbabilityXOver < PCO Then
                            '3.8621
                                If MCFlag = 0 Then
                                    ProbabilityXOver = ProbabilityXOver * MCCorrection
                                End If
                                If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                    'Keep track of signal numbers
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(1) = oRecombNo(1) + 1
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 1, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                        
                                    If MCFlag = 2 Then
                                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    'if p high eough then add it to list, if not discard then repeat from Z to en.
                                    If SIP > 0 Then
                                        Beginning = XDiffpos(BTarget)
                                        Ending = XDiffpos(ETarget)
                                        
                                        XOverList(ActiveSeq, SIP).Beginning = Beginning
                                        XOverList(ActiveSeq, SIP).Ending = Ending
                                        
                                        
                                        
                                        'Make a reminder that one of the berakpoints went undetected
                                        If A = 0 Then
                                            XOverList(ActiveSeq, SIP).SBPFlag = 2
                                            EWarn = 1
                                        Else
                                            XOverList(ActiveSeq, SIP).SBPFlag = 1
                                            BWarn = 1
                                        End If
                                        XOverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                        XOverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                        XOverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                        XOverList(ActiveSeq, SIP).ProgramFlag = 1
                                        XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                        If XOverList(ActiveSeq, SIP).SBPFlag = 1 Then BWarn = 1
                                        If XOverList(ActiveSeq, SIP).SBPFlag = 2 Then EWarn = 1
                                        If SEventNumber > 0 Then
                                            If EWarn = 0 Then Call CheckEndsVB(10, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosdiff(), XDiffpos())
                                            If BWarn = 0 Then Call CheckEndsVB(10, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosdiff(), XDiffpos())
                                        End If
                                        Call FixEnds(BWarn, EWarn, MissingData(), XOverList(), ActiveSeq, SIP)
                                        Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, 10, LenXOverSeq)
                                        If FindAllFlag = 1 And X = 12345 Then
                                            If APermFlag = 0 Then
                                                Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 1, ProbabilityXOver, SIP)
                                            Else
                                                SIP = 1
                                            End If
                                            If SIP > 0 Then
                                                XOverList(ActiveSeq, SIP) = XOverList(ActiveSeq, SIP - 1)
                                                XOverList(ActiveSeq, SIP).Ending = Beginning
                                                XOverList(ActiveSeq, SIP).Beginning = Ending
                                            End If
                                        End If
                                        If X = 12345 Then
                                            If XOverList(ActiveSeq, SIP).Beginning < XOverList(ActiveSeq, SIP).Ending Then
                                                For Z = XOverList(ActiveSeq, SIP).Beginning To XOverList(ActiveSeq, SIP).Ending
                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                        X = X
                                                    End If
                                                Next Z
                                            Else
                                                For Z = 1 To XOverList(ActiveSeq, SIP).Ending
                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                        X = X
                                                    End If
                                                Next Z
                                                For Z = XOverList(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                        X = X
                                                    End If
                                                Next Z
                                            End If
                                            XX = zzzxz
                                        End If
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(0) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(1) = 1
                                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                                        End If
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(1, Seq1, Seq2, Seq3)
                                    End If
                                        
                                End If
                                
                            End If
                            
                        Next A
                    ElseIf splitx = 0 Then
                        If MCFlag = 0 Then
                            ProbabilityXOver = PVals(Y, X) * MCCorrection
                        Else
                            ProbabilityXOver = PVals(Y, X)
                        End If
                        
                        If MCFlag = 2 Then
                            If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                            ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                            End If
                        End If
                        
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(1) = oRecombNo(1) + 1
                        
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 1, ProbabilityXOver, SIP)
                        Else
                            SIP = 1
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(1) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        If SIP > 0 Then
                            
                            XOverList(ActiveSeq, SIP).Daughter = ActiveSeq
                            XOverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                            XOverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                            XOverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                            XOverList(ActiveSeq, SIP).Beginning = Beginning
                            XOverList(ActiveSeq, SIP).Ending = Ending
                            XOverList(ActiveSeq, SIP).ProgramFlag = 1
                            
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(10, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosdiff(), XDiffpos())
                                If BWarn = 0 Then Call CheckEndsVB(10, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosdiff(), XDiffpos())
                            End If
                            Call FixEnds(BWarn, EWarn, MissingData(), XOverList(), ActiveSeq, SIP)
                            Call CentreBP(XOverList(ActiveSeq, SIP).Beginning, XOverList(ActiveSeq, SIP).Ending, XPosdiff(), XDiffpos(), BWarn, EWarn, 10, LenXOverSeq)
                            If FindAllFlag = 1 And X = 12345 Then
                                If APermFlag = 0 Then
                                    Call UpdateXOList3(ActiveSeq, CurrentXover(), XOverList(), 1, ProbabilityXOver, SIP)
                                Else
                                    SIP = 1
                                End If
                                If SIP > 0 Then
                                    XOverList(ActiveSeq, SIP) = XOverList(ActiveSeq, SIP - 1)
                                    XOverList(ActiveSeq, SIP).Ending = Beginning
                                    XOverList(ActiveSeq, SIP).Beginning = Ending
                                End If
                            End If
                            
                            'If Seq1 = 57 Or Seq2 = 57 Or Seq3 = 57 And XOverList(ActiveSeq, SIP).Beginning = 2301 And XOverList(ActiveSeq, SIP).Ending = 53 Then
                            '                XxX = SEventNumber
                            '            End If
                                        
                                    If X = X Then
                                        If XOverList(ActiveSeq, SIP).Beginning < XOverList(ActiveSeq, SIP).Ending Then
                                            For Z = XOverList(ActiveSeq, SIP).Beginning To XOverList(ActiveSeq, SIP).Ending
                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                    X = X
                                                End If
                                            Next Z
                                        Else
                                            For Z = 1 To XOverList(ActiveSeq, SIP).Ending
                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                    X = X
                                                End If
                                            Next Z
                                            For Z = XOverList(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
                                                    X = X
                                                End If
                                            Next Z
                                        End If
                                       XX = zzzxz
                                    End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(1) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                            End If
                            
                        ElseIf DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                        End If
                   Else
                        FragMaxScore(MaxY, MaxX) = 0
                   End If
                   tMa = ActiveMajorP
                   tMi = ActiveMinorP
                   Ac = ActiveSeq
                        
                                      
                    ActiveMajorP = tMa
                    ActiveMinorP = tMi
                    ActiveSeq = Ac
                    
                    If ShowPlotFlag = 1 And DoneThis = 0 Then
                        Call DoAxes(Len(StrainSeq(0)), -1, -Log10(MaxScore), 0, 1, "-Log(KA P-Val)")
                        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                        If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection
                        Form1.Picture2.ForeColor = QBColor(0)
                        COff = -Log10((LowestProb / (MCCorrection)))
                        Y1 = PicHeight - (15 + (COff / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 2
                        Y1 = PicHeight - (15 + (-Log10(LowestProb) / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 0
                        'Form1.Picture7.AutoRedraw = True
                        DoneThis = 1
                        
                        For A = 5 To 0 Step -1
                            
    
                            If A = 0 Then
                                Form1.Picture7.ForeColor = Yellow
                            ElseIf A = 1 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 2 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 3 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 4 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 5 Then
                                Form1.Picture7.ForeColor = Yellow
                            End If
                            
                            
                                For B = 0 To FragCount(A)
                                    If PVals(B, A) < 0.9999 And PVals(B, A) > 0 Then
                                    
                                        Prob = -Log10(PVals(B, A))
                                        
                                        If FragSt(B, A) > 0 Then
                                            B1 = XDiffpos(FragSt(B, A) - 1) + 1
                                        Else
                                            B1 = 1
                                        End If
                                        E1 = XDiffpos(FragEn(MaxScorePos(B, A), A) + 1) - 1
                                        X1 = 30 + B1 * XFactor + XFactor
                                        X2 = 30 + E1 * XFactor + XFactor
                                        
                                        
                                        Y1 = PicHeight - (15 + (Prob / -Log10(MaxScore)) * (PicHeight - 35))
                                        Y2 = PicHeight - 15
                                        Form1.Picture7.AutoRedraw = True
                                        'Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
                                    End If
                                Next B
                           
                        Next A
                        Form1.Picture7.Refresh
                        Form1.Frame17.Visible = False
                        'X = X
                        'XX = FragMaxScore(MaxY, MaxX)
                        'XX = FragSt(MaxY, MaxX)
                        'XX = FragEn(MaxY, MaxX)
                        'XX = FragCount(MaxX)
                        'XX = LenXOverSeq
                        'XX = KMax(MaxX)
                        'XX = LL(MaxX)
                        'XX = Log(KMax(MaxX) * LenXOverSeq)
                        'XX = (LL(MaxX) * FragMaxScore(MaxY, MaxX))
                    End If
                    
                    If splitx = 1 And MaxX > 3 Then
                        PVals(MaxY, MaxX) = 100
                    Else
                        
                       
                            Dummy = MakeDeleteArray(FragSt(Y, X), FragEn(MaxScorePos(Y, X), X), FragCount(X), DeleteArray(0))
                       
                    End If
                    
                End If
            'Else
            '    Exit For
            'End If
        End If
        
Loop
'124
End Sub
Public Sub GCManXOver()

    Dim LSeq As Long, X As Long, NPos2 As Long, G As Long
    Dim TempEnd As String, NewName As String, ODir As String, LList As String, TargetCompare As String
    Dim COff As Double

    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    LSeq = Len(StrainSeq(0))
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.BackColor = BackColours
    Screen.MousePointer = 11
    Form1.SSPanel1.Caption = "Executing GENECONV"
    'Set up copies of sequences that can be edited and rearranged etc
    ReDim TempSeq(NextNo)
    ReDim RevSeq(NextNo)
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    RevSeq(0) = Form5.Combo1.ListIndex - 1
    NumberOfSeqs = 1

    For X = 0 To NextNo

        If Selected(X) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(X)
            RevSeq(NumberOfSeqs) = X
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1
    NewName = "manseqs"
    'Make GENECONV input file in FASTA format
    Open NewName For Output As #1

    For X = 0 To NumberOfSeqs
        Print #1, ">S" & Trim$(CStr(X))
        Print #1, TempSeq(X)
    Next 'X

    Close #1
    'Make GENECONV configuration file
    Open "mancfg.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=manseqs"
    Print #1, "-Outfile=manfrag"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If GCSeqTypeFlag = 0 Then
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        Print #1, "-Use_individual_indels"
    End If

    If GCCodeFlag = 0 Then
    Else
        Print #1, "-Mitcodes"
    End If

    If GCMonoSiteFlag = 0 Then
    Else
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'If GCOffsetAddjust > 0 Then
    '    Print #1, "-AddOffset=" & GCOffsetAddjust
    'End If
    Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=1"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v10"
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    Print #1, "-Numsim=0"
    Print #1, "-Maxkapairwisepval=0.99999"
    LList$ = "S0 "

    For X = 1 To NumberOfSeqs
        LList$ = LList$ + "S0,S" + Trim$(CStr(X)) + " "
    Next 'X

    Print #1, "-Listonly=" + LList$
    'Print #1, "/x"
    Close #1
    If ShortOutFlag = 0 Then
        On Error Resume Next
            LowestProb = Val(Form1.Text1.Text)
            LowestProb = CDbl(Form1.Text1.Text)
        On Error GoTo 0
    End If
    
    Form1.ProgressBar1 = 5

    Dim mgcProcess As Long

    mgcProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(App.Path & "\geneconv mancfg.cfg", 0))

    Dim xMinP() As Double

    ReDim xMinP(NextNo, NextNo)
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture1.Enabled = True
    Form1.Picture7.Enabled = True

    Dim Beginning As Long, Ending As Long, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim YScaleFactor As Double, Prob As Double
    Dim RetVal As Long, CurrentStart As Long

    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / LSeq)
    Const STILL_ACTIVE = &H103

    Do
        GetExitCodeProcess mgcProcess, RetVal
    Loop While RetVal = STILL_ACTIVE

    Dummy = CloseHandle(mgcProcess)
    mgcProcess = 0
    Form1.ProgressBar1 = 50
    ReDim MCPrintData(NumberOfSeqs, LSeq)
    ReDim MCPrintPos(NumberOfSeqs, LSeq, 1)

    Dim Results As String
    Dim FLen As Long
    Dim TargetString As String, temp As String
    Dim CurPPos As Long, NPos As Long, GiPos As Long
    MinPx = 0
    Open "manfrag.frags" For Binary Access Read As #1
    Results = String$(30000, " ")
    FLen = LOF(1)
    Results = String$(FLen, " ")
    CurrentStart = 1
    Get #1, CurrentStart, Results
    'First look for inner fragments
    NPos = InStr(1, Results, "GI ", vbBinaryCompare)
    GiPos = NPos + 10

    If NPos > 0 Then
        Close #1
        Open "manfrag.frags" For Binary Access Read As #1
        Get #1, NPos, temp$
        Input #1, temp$
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
        NPos = InStr(1, temp$, " ", vbBinaryCompare)
        MinPx = CDbl(Trim$(left$(temp$, NPos))) / 3
        MinPx = -Log10(MinPx)
    End If

    NPos2 = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos2 > 0 Then
        Close #1
        Open "manfrag.frags" For Binary Access Read As #1
        
        Get #1, NPos2, temp$
        Input #1, temp$
        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos2, Len(temp$) - NPos + 1))
        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)
        temp$ = Trim$(Mid$(temp$, NPos2, Len(temp$) - NPos + 1))
        NPos2 = InStr(1, temp$, " ", vbBinaryCompare)

        If -Log10(CDbl(Trim$(left$(temp$, NPos2))) / 3) > MinPx Then
            MinPx = CDbl(Trim$(left$(temp$, NPos2))) / 3
            MinPx = -Log10(MinPx)
        End If

    End If

    'Exit Sub

    If MinPx < -Log10(LowestProb / NumberOfSeqs) Then
        MinPx = -Log10(LowestProb / NumberOfSeqs)
    End If

    ReDim Preserve xMinP(NextNo, NextNo)

    For X = 0 To NumberOfSeqs
        xMinP(RevSeq(0), RevSeq(X)) = MinPx
        xMinP(RevSeq(X), RevSeq(0)) = xMinP(RevSeq(0), RevSeq(X))
    Next 'X

    Get #1, CurrentStart, Results
    Close #1

    For G = 0 To NumberOfSeqs
        CurrentStart = 1
        CurPPos = 0
        'Do 1 - 2

        If G = 0 Then
            TargetString = "PO  S0"
            NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
            TargetString = "S0"
        Else
            TargetString = "S0;S" + Trim$(CStr(G))
            NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
        End If

        Form1.Picture7.AutoRedraw = True

        If NPos > 0 Then
            Open "manfrag.frags" For Binary Access Read As #1
            Get #1, NPos - 50, temp$

            Do While Not EOF(1)
                Input #1, temp$

                If left$(temp$, 2) = "PI" Or left$(temp$, 2) = "PO" Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    TargetCompare$ = Mid$(temp$, 1, NPos - 1)

                    If TargetCompare$ <> TargetString Then Exit Do
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        'Prob = CDbl(Mid$(temp$, 1, NPos - 1))
                        On Error Resume Next
                            Prob = Val(Mid$(temp$, 1, NPos - 1))
                            Prob = CDbl(Mid$(temp$, 1, NPos - 1))
                           
                        On Error GoTo 0
                        If Prob = 1 Then Exit Do

                        If xMinP(RevSeq(0), RevSeq(G)) < -Log10(Prob) Then xMinP(RevSeq(0), RevSeq(G)) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    If xMinP(RevSeq(0), RevSeq(G)) < -Log10(Prob) Then xMinP(RevSeq(0), RevSeq(G)) = -Log10(Prob)
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = CDbl(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = CDbl(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            Ending = CDbl(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = CDbl(TempEnd$)
                        End If

                    End If

                    If Beginning < Ending Then
                        Prob = -Log10(Prob)
                        MCPrintData(G, CurPPos) = Prob
                        MCPrintPos(G, CurPPos, 0) = Beginning
                        MCPrintPos(G, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    Else
                        Prob = -Log10(Prob)
                        MCPrintData(G, CurPPos) = Prob
                        MCPrintPos(G, CurPPos, 0) = Beginning
                        MCPrintPos(G, CurPPos, 1) = LSeq
                        CurPPos = CurPPos + 1
                        MCPrintData(G, CurPPos) = Prob
                        MCPrintPos(G, CurPPos, 0) = 1
                        MCPrintPos(G, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    End If

                ElseIf left$(temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = CDbl(Mid$(temp$, 1, NPos - 1))

                        If xMinP(RevSeq(0), RevSeq(G)) = -1 Then xMinP(RevSeq(0), RevSeq(G)) = -Log10(Prob)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = CDbl(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(temp$, 1, NPos - 1)
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = CDbl(Mid$(temp$, 1, NPos - 1))
                                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                            End If

                        ElseIf left$(TempEnd$, 2) = "CA" Then
                            Ending = CDbl(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = CDbl(TempEnd$)
                        End If

                    End If

                    If Beginning < Ending Then
                        Prob = -Log10(Prob)
                        MCPrintData(G, CurPPos) = Prob
                        MCPrintPos(G, CurPPos, 0) = Beginning
                        MCPrintPos(G, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    Else
                        Prob = -Log10(Prob)
                        MCPrintData(G, CurPPos) = Prob
                        MCPrintPos(G, CurPPos, 0) = Beginning
                        MCPrintPos(G, CurPPos, 1) = LSeq
                        CurPPos = CurPPos + 1
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = 1
                        MCPrintPos(1, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    End If

                ElseIf left$(temp$, 9) = "#   Names" Then
                Else

                    If left$(temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop

        End If

        Form1.ProgressBar1 = 50 + ((G - 1) / (NumberOfSeqs)) * 50
        Close #1
    Next 'G

    'Form1.Picture7.Line (25, 30)-(25, PicHeight), QBColor(0)
    'Form1.Picture7.Line (25, PicHeight)-(Form1.Picture7.ScaleWidth - 5, PicHeight), QBColor(0)
    MinGCP = 0

    For X = 0 To NumberOfSeqs

        If MinGCP < xMinP(RevSeq(0), RevSeq(X)) Then
            MinGCP = xMinP(RevSeq(0), RevSeq(X))
        End If

    Next 'X
    
    'If MinGCP > LowestProb Then X = X 'MinGCP = LowestProb
    If MinPx < -Log10(MinGCP) Then MinPx = -Log10(MinGCP)

    Call DoAxes(Len(StrainSeq(0)), -1, MinGCP, 0, 0, "-Log(KA P-Val)")

    Form1.Picture7.AutoRedraw = True

    For G = 0 To NumberOfSeqs

        For CurPPos = 0 To LSeq
            Beginning = MCPrintPos(G, CurPPos, 0)
            Ending = MCPrintPos(G, CurPPos, 1)

            If Beginning = Ending Then Exit For
            X1 = 30 + Beginning * XFactor + XFactor
            X2 = 30 + Ending * XFactor + XFactor
            Prob = MCPrintData(G, CurPPos)


            Y1 = PicHeight - (15 + (Prob / MinGCP) * (PicHeight - 35))
            Y2 = PicHeight - 15
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), SeqCol(RevSeq(G)), B
        Next 'CurPPos

    Next 'G

    COff = -Log10(LowestProb / NumberOfSeqs)
    Y1 = PicHeight - (15 + (COff / MinGCP) * (PicHeight - 35))
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    Y1 = PicHeight - (15 + (-Log10(LowestProb) / MinGCP) * (PicHeight - 35))
    Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.Picture2.ForeColor = QBColor(0)
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5

    If ORFFlag = 1 Then
        Form1.Picture20.Picture = Form1.Picture19.Image
        Form1.Picture20.Visible = True
    End If

    Form1.SSPanel1.Caption = ""
    Screen.MousePointer = 0
    Form1.ProgressBar1 = 0
    'Kill GCCFile
    ChDir ODir
    ChDrive ODir
End Sub

Public Sub GCXOver()
    Seq1 = 0
    Seq2 = 0
    oRecombNo(1) = 0
    Dim DA As Long, Mi As Long, T As Long, RetVal As Long, X As Long, CPos As Long, NPos As Long
    Dim Results As String, ActualDir As String, ODir As String, temp As String, Map As String, mip As String, TempEnd As String
    
    If UBound(XOverList, 2) < XOverListSize Then
       ReDim Preserve XOverList(NextNo, XOverListSize)
    End If
    
    
    'Make sure we're working in RDP's install directory
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    'Start the timer
    GCST = GetTickCount()
    Form1.SSPanel1.Caption = "Executing GENECONV"
    ReDim GCImageIndex(NextNo + 1, NextNo + 1)
    ReDim RevGCIndex1(10)
    ReDim RevGCIndex2(10)
    ReDim MinP(NextNo, NextNo)
    Form1.ProgressBar1.Value = 25
    
    'Find the informative sites that GC looks at
SS = GetTickCount
    Call GCFindSites
    GCFoundSitesFlag = 1
    EE = GetTickCount
    TT = EE - SS
    'Wait for GC execution to finish (it was started in the subroutine GCXoverB)
    Const STILL_ACTIVE = &H103

    Do
        'Check on how things are going every half second.
        Sleep (500)
        GetExitCodeProcess hProcess, RetVal
        DoEvents

        If AbortFlag = 1 Then
            AbortFlag = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            ABFl(1) = 1
            Exit Sub
        End If

        ET = GetTickCount
        Form1.Label51(0).Caption = DoTimeII(ET - GCST)
        Form1.Label57(0).Caption = DoTimeII(ET - ST)
    Loop While RetVal = STILL_ACTIVE

    'Release the handle
    CloseHandle hProcess
    hProcess = 0
    'Update progress indicators
    UpdateRecNums (SEventNumber)
    Form1.ProgressBar1.Value = 50
    
    'Bit for mtDNA Project
    If ShortOutFlag = 3 And GCNumPerms > 0 Then
        Open GCOutfileName + ".sum" For Binary Access Read As #1
        Results = String$(LOF(1), " ")
        Get #1, 1, Results
        Close #1
        Pos = InStr(1, Results, "SCORE", vbBinaryCompare)
        
        If Pos > 0 Then
            mtP(1) = Val(Trim(Mid(Results, Pos + 18, 13)))
            NPos = InStr(Pos, Results, "Not found", vbBinaryCompare)
            If NPos = 0 Then
                Pos = InStr(Pos, Results, "frags", vbBinaryCompare)
                tVal = Val(Trim(Mid(Results, Pos + 18, 13)))
                If tVal < mtP(1) Then
                    mtP(1) = tVal
                End If
            End If
        End If
        X = X
        ChDrive ODir
        ChDir ODir
        Exit Sub
    End If
    'Reexecutes GC in the background to get information on marginally significant fragments
    If ShortOutFlag <> 3 Then
        Call GCDrawC
    End If
    'Look for signiifcant fragments within the GC outfile - Note this is some seriously crap
    'code and must be rewritten - I have no idea why I first load the entire file, close it and
    'then reopen it to read the data - it is slow and messy.
    'Read the outfile into the string "Results"
    Open GCOutfileName + ".frags" For Binary Access Read As #1
    Results = String$(LOF(1), " ")
    Get #1, 1, Results
    Close #1
    'Determine  where within the string "Results" the data on Global Inner fragments begins
    CPos = 1
    NPos = InStr(1, Results, "GI ", vbBinaryCompare)

    If NPos > 0 Then
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, temp$

        Do
            ET = GetTickCount
            Form1.Label51(0).Caption = DoTimeII(ET - GCST)
            Form1.Label57(0).Caption = DoTimeII(ET - ST)
            Input #1, temp$

            If left$(temp$, 2) = "GI" Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                CPos = InStr(1, temp$, ";", vbBinaryCompare)
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If CPos > 0 Then
                    Map$ = Mid$(temp$, 1, CPos - 1)
                    mip$ = Mid$(temp$, CPos + 1, NPos - CPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    For X = 0 To NextNo

                        If StraiName(X) = Map$ Then Seq1 = X

                        If StraiName(X) = mip$ Then Seq2 = X
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXover(), XOverList())
                    
                    XOverList(Seq1, CurrentXover(Seq1)).Daughter = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MajorP = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MinorP = Seq2
                    
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).PermPVal = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Probability = Val(Mid$(temp$, 1, NPos - 1))
                    If MCFlag = 2 Then
        
                        Dim ProbabilityXOver As Double
                        ProbabilityXOver = XOverList(Seq1, CurrentXover(Seq1)).Probability
                        
                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XOverList(Seq1, CurrentXover(Seq1)).Probability <= mtP(1) And XOverList(Seq1, CurrentXover(Seq1)).Probability <> 0 Then
                        mtP(1) = XOverList(Seq1, CurrentXover(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Beginning = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = (Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).LHolder = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
    'XXXZZZ                  XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
'XXXZZZ                      XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XOverList(Seq1, CurrentXover(Seq1)).ProgramFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).MissIdentifyFlag = 1

                If XOverList(Seq1, CurrentXover(Seq1)).Beginning < XOverList(Seq1, CurrentXover(Seq1)).Ending Then

                    If XOverList(Seq1, CurrentXover(Seq1)).Ending - XOverList(Seq1, CurrentXover(Seq1)).Beginning > Len(StrainSeq(0)) / 2 Then

                        If CircularFlag = 1 Then
                            T = XOverList(Seq1, CurrentXover(Seq1)).Ending
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                            XOverList(Seq1, CurrentXover(Seq1)).Beginning = T
                            XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                            XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                        Else

                            If XOverList(Seq1, CurrentXover(Seq1)).Beginning > Len(StrainSeq(0)) - XOverList(Seq1, CurrentXover(Seq1)).Ending Then
                                XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                                XOverList(Seq1, CurrentXover(Seq1)).Beginning = 0
                                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                                XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                            Else
                                XOverList(Seq1, CurrentXover(Seq1)).Beginning = XOverList(Seq1, CurrentXover(Seq1)).Ending
                                XOverList(Seq1, CurrentXover(Seq1)).Ending = Len(StrainSeq(0))
                                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                                XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                            End If

                        End If

                    End If

                Else

                    If XOverList(Seq1, CurrentXover(Seq1)).Beginning - XOverList(Seq1, CurrentXover(Seq1)).Ending < Len(StrainSeq(0)) / 2 Then
                        T = XOverList(Seq1, CurrentXover(Seq1)).Ending
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                        XOverList(Seq1, CurrentXover(Seq1)).Beginning = T
                        XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                        XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                    End If

                End If

                If XOverList(Seq1, CurrentXover(Seq1)).Beginning = Len(StrainSeq(0)) Then XOverList(Seq1, CurrentXover(Seq1)).Beginning = 1
                If XOverList(Seq1, CurrentXover(Seq1)).Ending < 2 Then XOverList(Seq1, CurrentXover(Seq1)).Ending = Len(StrainSeq(0))

                If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    DA = XOverList(Seq1, CurrentXover(Seq1)).Daughter
                    Mi = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                    StartPlt(1) = 1
                    Call UpdatePlotB(DA, DA, Mi, CurrentXover(Seq1))

                End If
                Call UpdateXOList(Seq2, CurrentXover(), XOverList())
                XOverList(Seq2, CurrentXover(Seq2)) = XOverList(Seq1, CurrentXover(Seq1))
                XOverList(Seq2, CurrentXover(Seq2)).Daughter = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                XOverList(Seq2, CurrentXover(Seq2)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                XOverList(Seq2, CurrentXover(Seq2)).MinorP = XOverList(Seq1, CurrentXover(Seq1)).Daughter
                
                XOverList(Seq2, CurrentXover(Seq2)).ProgramFlag = 1
                
            Else

                If left$(temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    Form1.ProgressBar1.Value = 75
    'Determine  where within the string "Results" the data on Pairwise Inner fragments begins
    NPos = InStr(1, Results, "PI ", vbBinaryCompare)

    If NPos > 0 Then
        
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, temp$
        Do
            ET = GetTickCount
            Form1.Label51(0).Caption = DoTimeII(ET - GCST)
            Form1.Label57(0).Caption = DoTimeII(ET - ST)
            Input #1, temp$

            If left$(temp$, 2) = "PI" Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                CPos = InStr(1, temp$, ";", vbBinaryCompare)
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If CPos > 0 Then
                    Map$ = Mid$(temp$, 1, CPos - 1)
                    mip$ = Mid$(temp$, CPos + 1, NPos - CPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    For X = 0 To NextNo

                        If StraiName(X) = Map$ Then Seq1 = X

                        If StraiName(X) = mip$ Then Seq2 = X
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXover(), XOverList())

                    XOverList(Seq1, CurrentXover(Seq1)).Daughter = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MajorP = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MinorP = Seq2
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).PermPVal = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    If MCFlag = 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).Probability = (Val(Mid$(temp$, 1, NPos - 1))) * MCCorrect '(((Nextno + 1) * (Nextno + 1)) / 2)
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Probability = (Val(Mid$(temp$, 1, NPos - 1)))
                    End If
                    If MCFlag = 2 Then
        
                        
                        ProbabilityXOver = XOverList(Seq1, CurrentXover(Seq1)).Probability
                        
                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XOverList(Seq1, CurrentXover(Seq1)).Probability <= mtP(1) And XOverList(Seq1, CurrentXover(Seq1)).Probability <> 0 Then
                        mtP(1) = XOverList(Seq1, CurrentXover(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Beginning = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).LHolder = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
             'XXXZZZ       XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
     'XXXZZZ               XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                
                If temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XOverList(Seq1, CurrentXover(Seq1)).ProgramFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).MissIdentifyFlag = 1

                If XOverList(Seq1, CurrentXover(Seq1)).Beginning < XOverList(Seq1, CurrentXover(Seq1)).Ending Then

                    If XOverList(Seq1, CurrentXover(Seq1)).Ending - XOverList(Seq1, CurrentXover(Seq1)).Beginning > Len(StrainSeq(0)) / 2 Then

                        If CircularFlag = 1 Then
                            T = XOverList(Seq1, CurrentXover(Seq1)).Ending
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                            XOverList(Seq1, CurrentXover(Seq1)).Beginning = T
                            XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                            XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                        Else

                            If XOverList(Seq1, CurrentXover(Seq1)).Beginning > Len(StrainSeq(0)) - XOverList(Seq1, CurrentXover(Seq1)).Ending Then
                                XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                                XOverList(Seq1, CurrentXover(Seq1)).Beginning = 0
                                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                                XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                            Else
                                XOverList(Seq1, CurrentXover(Seq1)).Beginning = XOverList(Seq1, CurrentXover(Seq1)).Ending
                                XOverList(Seq1, CurrentXover(Seq1)).Ending = Len(StrainSeq(0))
                                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                                XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                            End If

                        End If

                    End If

                Else

                    If XOverList(Seq1, CurrentXover(Seq1)).Beginning - XOverList(Seq1, CurrentXover(Seq1)).Ending < Len(StrainSeq(0)) / 2 Then
                        T = XOverList(Seq1, CurrentXover(Seq1)).Ending
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = XOverList(Seq1, CurrentXover(Seq1)).Beginning
                        XOverList(Seq1, CurrentXover(Seq1)).Beginning = T
                        XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 2
                        XOverList(Seq1, CurrentXover(Seq1)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                    End If

                End If

                If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    DA = XOverList(Seq1, CurrentXover(Seq1)).Daughter
                    Mi = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                    StartPlt(1) = 1
                    Call UpdatePlotB(DA, DA, Mi, CurrentXover(Seq1))

                End If
                
                Call UpdateXOList(Seq2, CurrentXover(), XOverList())
                
                XOverList(Seq2, CurrentXover(Seq2)) = XOverList(Seq1, CurrentXover(Seq1))
                XOverList(Seq2, CurrentXover(Seq2)).Daughter = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                XOverList(Seq2, CurrentXover(Seq2)).MajorP = XOverList(Seq1, CurrentXover(Seq1)).MinorP
                XOverList(Seq2, CurrentXover(Seq2)).MinorP = XOverList(Seq1, CurrentXover(Seq1)).Daughter
                
                XOverList(Seq2, CurrentXover(Seq2)).ProgramFlag = 1
            Else

                If left$(temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    'I don't know why I close this here only to reopen it in the next few lines
    'It may have something to do with the "Do Events" further on)
    Close #1
    ET = GetTickCount
    Form1.Label51(0).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
    Form1.Label57(0).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
    Form1.Label51(0).Refresh
    Form1.Label51(1).Refresh
    Form1.Label57(0).Refresh
    Form1.Label57(1).Refresh
    DoEvents
    'Determine  where within the string "Results" the data on Global Outer fragments begins
    NPos = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos > 0 Then
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, temp$

        Do
            ET = GetTickCount
            Form1.Label51(0).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
            Form1.Label57(0).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
            Input #1, temp$

            If left$(temp$, 2) = "GO" Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Map$ = Mid$(temp$, 1, NPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    For X = 0 To NextNo

                        If StraiName(X) = Map$ Then Seq1 = X
                    Next 'X

                    ActiveSeq = Seq1
                    
                    Call UpdateXOList(ActiveSeq, CurrentXover(), XOverList())
                    
                    XOverList(Seq1, CurrentXover(Seq1)).Daughter = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MajorP = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MinorP = NextNo + 1
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).PermPVal = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Probability = Val(Mid$(temp$, 1, NPos - 1))
                    If MCFlag = 2 Then
        
                       
                        ProbabilityXOver = XOverList(Seq1, CurrentXover(Seq1)).Probability
                        
                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XOverList(Seq1, CurrentXover(Seq1)).Probability <= mtP(1) And XOverList(Seq1, CurrentXover(Seq1)).Probability <> 0 Then
                        mtP(1) = XOverList(Seq1, CurrentXover(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Beginning = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = (Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).LHolder = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
             'XXXZZZ       XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
            'XXXZZZ        XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XOverList(Seq1, CurrentXover(Seq1)).ProgramFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).MissIdentifyFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 1
            Else

                If left$(temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    Close #1
    Form1.ProgressBar1.Value = 75
    'Determine  where within the string "Results" the data on Pairwise Outer fragments begins
    NPos = InStr(1, Results, "PO ", vbBinaryCompare)

    If NPos > 0 Then
        
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, temp$

        Do
            ET = GetTickCount
            Form1.Label51(0).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
            Form1.Label57(0).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
            Input #1, temp$

            If left$(temp$, 2) = "PO" Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Map$ = Mid$(temp$, 1, NPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    For X = 0 To NextNo

                        If StraiName(X) = Map$ Then Seq1 = X
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXover(), XOverList())

                    XOverList(Seq1, CurrentXover(Seq1)).Daughter = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MajorP = Seq1
                    XOverList(Seq1, CurrentXover(Seq1)).MinorP = NextNo + 1
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).PermPVal = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    If MCFlag = 0 Then
                        XOverList(Seq1, CurrentXover(Seq1)).Probability = (Val(Mid$(temp$, 1, NPos - 1))) * MCCorrect ' (((Nextno + 1) * (Nextno + 1)) / 2)
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Probability = (Val(Mid$(temp$, 1, NPos - 1)))
                    End If
                    If MCFlag = 2 Then
        
                        
                        ProbabilityXOver = XOverList(Seq1, CurrentXover(Seq1)).Probability
                        
                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XOverList(Seq1, CurrentXover(Seq1)).Probability <= mtP(1) And XOverList(Seq1, CurrentXover(Seq1)).Probability <> 0 Then
                        mtP(1) = XOverList(Seq1, CurrentXover(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).Beginning = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(Mid$(temp$, 1, NPos - 1)) - GCOffsetAddjust
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XOverList(Seq1, CurrentXover(Seq1)).Ending = Val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XOverList(Seq1, CurrentXover(Seq1)).LHolder = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
           'XXXZZZ         XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
           'XXXZZZ         XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
 'XXXZZZ                    XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XOverList(Seq1, CurrentXover(Seq1)).ProgramFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).MissIdentifyFlag = 1
                XOverList(Seq1, CurrentXover(Seq1)).OutsideFlag = 1
            Else

                If left$(temp$, 1) = "#" Then Exit Do
            End If

        Loop

    End If

    Close #1
    'Wait for the "Checking" GC execution to finsish
    If ShortOutFlag = 3 Then
        ChDrive ODir
        ChDir ODir
        Exit Sub
    End If
    
    Do
        GetExitCodeProcess gcProcess, RetVal
        Sleep (500)
        ET = GetTickCount
        Form1.Label51(0).Caption = DoTimeII(ET - GCST)
        Form1.Label57(0).Caption = DoTimeII(ET - ST)

        If AbortFlag = 1 Then
            AbortFlag = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0

            If MaxChiFlag = 1 And MCTripletFlag = 1 Then
                NoMCFlag = 0
            Else
                NoMCFlag = 1
            End If

            'I've temporarily removed this to see if it makes the program more stable
            'GetExitCodeProcess gcProcess, tExitCode
            'TerminateProcess gcProcess, tExitCode
            'Dummy = CloseHandle(gcProcess)
            'gcProcess=0
            ABFl(1) = 1
            Exit Sub
        End If

        DoEvents
    Loop While RetVal = STILL_ACTIVE

    CloseHandle gcProcess
    gcProcess = 0
    'Executes MaxChi for a later check of GC results

    

    ChDrive ODir
    ChDir ODir
    ET = GetTickCount
    Form1.Label51(0).Caption = DoTimeII(ET - GCST)
    Form1.Label57(0).Caption = DoTimeII(ET - ST)
    DoEvents
End Sub
Public Sub Reactivate()
    '2,8,5,p8
    Form1.SSPanel2.Enabled = OSS2
    Form1.SSPanel8.Enabled = OSS8
    Form1.SSPanel5.Enabled = OSS5
    Form1.Picture3.Enabled = OP3
    Form1.Picture5.Enabled = OP5
    Form1.Picture16.Enabled = OP16
    Form1.Command28.Visible = False
End Sub
Public Sub Deactivate()
    'Temporarily disables various controlls on the main form
    OSS2 = Form1.SSPanel2.Enabled
    OSS8 = Form1.SSPanel8.Enabled
    OSS5 = Form1.SSPanel5.Enabled
    OP3 = Form1.Picture3.Enabled
    OP5 = Form1.Picture5.Enabled
    OP16 = Form1.Picture16.Enabled
    Form1.SSPanel2.Enabled = False
    Form1.SSPanel8.Enabled = False
    Form1.SSPanel5.Enabled = False
    Form1.Picture3.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Picture16.Enabled = False
End Sub

Public Sub MakeAncestral()

SS = GetTickCount

Call MakeAncTree(1)

Form1.SSPanel1.Caption = "Constructing Ancestral Sequences"
Form1.ProgressBar1 = 5
Form1.Refresh

ReDim AncSeq(Len(StrainSeq(0)), NextNo)
Dim Path() As Long, DonePath() As Long
Dim StartP As Long
Dim CurPos As Long, CurPosB As Long
ReDim Path(NextNo)
ReDim DonePath(NextNo * 2)

'Work out the order of the read.
CurPos = 0
Dim TopNode() As Integer
ReDim TopNode(NextNo * 2)
'Initialise array
For X = 0 To NextNo
    TopNode(X) = -1
    For Y = 0 To NextNo - 1
        Path(X) = -1
    Next Y
Next X

Dim backup() As Long

ReDim backup(NextNo)
CurPos = 0

'Find MRCAs and the order in which to look at nodes
ReDim MRCAMat(NextNo * 2, NextNo * 2)


If X = 12345 Then
    For X = NextNo To NextNo * 2
        
        'BranchMap(X, 0) = BranchMap(X, 0)
        If DonePath(X) = 0 And BranchMap(X, 1) > -1 And BranchMap(X, 2) > -1 Then
            If TopNode(BranchMap(X, 1)) = -1 And TopNode(BranchMap(X, 2)) = -1 Then
                MRCAMat(BranchMap(X, 1), BranchMap(X, 2)) = X
                MRCAMat(BranchMap(X, 2), BranchMap(X, 1)) = X
                Path(CurPos) = X
                CurPos = CurPos + 1
                TopNode(X) = -1
                DonePath(X) = -1
                X = NextNo
            End If
         End If
    Next X
    
    
    Form1.ProgressBar1 = 10
    
    For X = NextNo + 1 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(X, Y) > 0 Then
                MRCAMat(BranchMap(X, 1), Y) = MRCAMat(X, Y)
                MRCAMat(Y, BranchMap(X, 1)) = MRCAMat(X, Y)
                MRCAMat(BranchMap(X, 2), Y) = MRCAMat(X, Y)
                MRCAMat(Y, BranchMap(X, 2)) = MRCAMat(X, Y)
                MRCAMat(X, Y) = 0
                MRCAMat(Y, X) = 0
            End If
                
        Next Y
    Next X
End If
Dim DoneMat() As Byte
ReDim DoneMat(NextNo * 2, NextNo * 2)
For X = NextNo + 1 To NextNo * 2
    MRCAMat(BranchMap(X, 1), BranchMap(X, 2)) = X
    MRCAMat(BranchMap(X, 2), BranchMap(X, 1)) = X
Next X
'Do While GoOn = 1
'    GoOn = 1
    For X = 0 To NextNo
        CPos = X
        Do
            For Y = 0 To NextNo * 2
                If MRCAMat(CPos, Y) > 0 Then
                    MRCAMat(X, Y) = MRCAMat(CPos, Y)
                    MRCAMat(Y, X) = MRCAMat(CPos, Y)
                    'GoOn = 1
                End If
            Next Y
            If CPos = NextNo * 2 Then Exit Do
            CPos = BranchMap(CPos, 0)
        Loop
    Next X
'Loop
Do
    GoOn = 0
    For X = 0 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(X, Y) > 0 And DoneMat(X, Y) = 0 Then
                EPos = MRCAMat(X, Y)
                XPos = X
                YPos = Y
                DoneMat(X, Y) = 1
                                
                Do
                    Do
                        If MRCAMat(XPos, YPos) = 0 Then
                            MRCAMat(XPos, YPos) = EPos
                            MRCAMat(YPos, XPos) = EPos
                            GoOn = 1
                        End If
                        If YPos = EPos Then Exit Do
                        YPos = BranchMap(YPos, 0)
                    Loop
                    If XPos = EPos Then Exit Do
                    XPos = BranchMap(XPos, 0)
                    
                Loop
                'Exit For
            End If
        Next Y
    Next X
    
    If GoOn = 0 Then Exit Do
    'For X = 0 To Nextno * 2
    '    CPos = X
    '    Do
    '        For Y = 0 To Nextno * 2
    '            If MRCAMat(CPos, Y) > 0 Then
    '                MRCAMat(X, Y) = MRCAMat(CPos, Y)
    '                MRCAMat(Y, X) = MRCAMat(CPos, Y)
    '
    '            End If
    '        Next Y
    '        If CPos = Nextno * 2 Then Exit Do
    '        CPos = BranchMap(CPos, 0)
    '    Loop
    'Next X
Loop


'            If BranchMap(X, 2) < BranchMap(X, 1) And BranchMap(X, 2) > Nextno Then
'                If BranchMap(X, 2) < X Then
'                    X = BranchMap(X, 2) - 1
'                Else
'                    X = X - 1
'                End If
 '           ElseIf BranchMap(X, 1) > Nextno Then
'                If BranchMap(X, 1) < X Then
'                    X = BranchMap(X, 1) - 1
'                Else
'                    X = X - 1
 '               End If
'            Else
'                If BranchMap(X, 2) <= Nextno Or BranchMap(X, 1) <= Nextno Then
'                    'X = Nextno
'                    X = X - 1
'                Else
'                    X = X - 1
'                End If
'            End If
'            'X = Nextno
'            Exit For
'            'mrcamat(branchmap(mrcamat(x,1)),y)=
'        End If
'    Next Y
'    X = X
'Next X

'MRCAMat(12, 18) = MRCAMat(12, 18)
'MRCAMat(13, 6) = MRCAMat(13, 6)
'For X = 0 To Nextno
'    If X <> Outie Then
'        MRCAMat(Outie, X) = Nextno + 1
'        MRCAMat(X, Outie) = Nextno + 1
'    End If
'Next X

'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        MRCAMat(X, Y) = MRCAMat(X, Y)
'    Next Y
'Next X



'For X = 0 To Nextno * 2 - 1
'    MRCAMat(X, X) = X
'    CPos = BranchMap(X, 0)
 '   Do
'        'If MRCAMat(X, CPos) <> 0 Then
'        '    X = X
'        'End If
'        MRCAMat(X, CPos) = CPos
'        MRCAMat(CPos, X) = CPos
'        If CPos = Nextno * 2 Then Exit Do
'        CPos = BranchMap(CPos, 0)
'
'    Loop
'Next X
For X = 0 To NextNo * 2
    MRCAMat(X, X) = X
Next X

'For X = 0 To Nextno * 2
'    For Y = X + 1 To Nextno * 2
'        MRCAMat(X, Y) = MRCAMat(X, Y)
'        'If MRCAMat(X, Y) = 0 Then
'        '    X = X
'        'End If
'    Next Y
'Next X

CurPos = CurPos - 1

'12 = a/-
'13 = c/-
'14 = g/-
'15 = t/-

Dim TbT() As Byte, Conv() As Byte, BtB() As Byte

'ReDim BtB(255, 4)

'BtB(0, 1) = 66
'BtB(0, 2) = 66
'BtB(0, 3) = 66
'BtB(0, 11) = 66

'BtB(1, 1) = 68
'BtB(1, 4) = 68
'BtB(1, 5) = 68
'BtB(1, 12) = 68

'BtB(2, 2) = 72
'BtB(2, 4) = 72
'BtB(2, 6) = 72
'BtB(2, 13) = 72

'BtB(3, 3) = 85
'BtB(3, 5) = 85
'BtB(3, 6) = 85
'BtB(3, 14) = 85

'BtB(4, 11) = 46
'BtB(4, 12) = 46
'BtB(4, 13) = 46
'BtB(4, 14) = 46

ReDim Conv(255)

Conv(46) = 4
Conv(66) = 0
Conv(68) = 1
Conv(72) = 2
Conv(85) = 3

'ReDim TbT(4, 4)

'TbT(0, 0) = 66
'TbT(0, 1) = 1
'TbT(0, 2) = 2
'TbT(0, 3) = 3
'TbT(0, 4) = 11

'TbT(1, 1) = 68
'TbT(1, 2) = 4
'TbT(1, 3) = 5
'TbT(1, 4) = 12

'TbT(2, 2) = 72
'TbT(2, 3) = 6
'TbT(2, 4) = 13

'TbT(3, 3) = 85
'TbT(3, 4) = 14

'TbT(4, 4) = 46 '

'For X = 0 To 3
'    For Y = X + 1 To 4
'        TbT(Y, X) = TbT(X, Y)
'    Next Y
'Next X
EE = GetTickCount
TT = EE - SS
Dim NS As Double, S1 As Integer, S3 As Integer, S2 As Integer, N1 As Byte, N2 As Byte, P As Long, MaxT As Double
Dim tHold() As Double, Maxhold() As Double
ReDim Maxhold(NextNo * 2)
ReDim tHold(NextNo * 2, 4)
Form1.ProgressBar1 = 15
If X = X Then
    Dummy = MakeAnc(NextNo, Len(StrainSeq(0)), CurPos, BranchMapX(0, 0), tHold(0, 0), Path(0), Identical(0), Conv(0), AncSeq(0, 0), SeqNum(0, 0))
    
Else
    For X = 1 To Len(StrainSeq(0))
        If Identical(X) = 1 Then
            For Y = 0 To NextNo
                AncSeq(X, Y) = SeqNum(X, 0)
            Next Y
        Else
            ReDim tHold(NextNo * 2, 4)
            'Find known nt states at tips
            For A = 0 To NextNo
                tHold(A, Conv(SeqNum(X, A))) = 1
            Next A
            'First Pass (down)
            For Z = 0 To CurPos
                
                'ns = 0
                P = Path(Z)
                S1 = BranchMap(P, 1)
                S2 = BranchMap(P, 2)
                MaxT = 0
                For A = 0 To 4
                    tHold(P, A) = tHold(S1, A) + tHold(S2, A)
                    If tHold(P, A) > MaxT Then MaxT = tHold(P, A)
                Next A
                            
                'Only Keep winners
                For A = 0 To 4
                    If tHold(P, A) < MaxT Then
                        tHold(P, A) = 0
                    Else
                        'ns = ns + 1
                        tHold(P, A) = 1
                    End If
                    
                    'If THold(P, A) > 0 Then
                    '    THold(P, A) = 1
                    'End If
                Next A
                Maxhold(P) = 1 'MaxT ' / NS
            Next Z
            
            'Second Pass (up)
            For Z = CurPos To 0 Step -1
                    
                    P = Path(Z)
                    S1 = BranchMap(P, 0)
                    S2 = BranchMap(P, 1)
                    S3 = BranchMap(P, 2)
                    MaxT = 0
                    For A = 0 To 4
                        'THold(P, A) = THold(P, A) * Maxhold(P) + THold(S1, A) + THold(S2, A) + THold(S3, A)
                        tHold(P, A) = tHold(S1, A) + tHold(S2, A) + tHold(S3, A)
                        If tHold(P, A) > MaxT Then MaxT = tHold(P, A)
                    Next A
                        
                    'Only Keep winners
                    For A = 0 To 4
                        If tHold(P, A) < MaxT Then
                            tHold(P, A) = 0
                        Else
                            
                            tHold(P, A) = 1
                        End If
                    Next A
                    X = X
            Next Z
            For Z = NextNo + 1 To NextNo * 2 - 1
            '1=a/c
            '2=a/g
            '3=a/t
            '4=c/g
            '5=c/t
            '6=g/t
            '7=a/c/g
            '8=a/c/t
            '9=a/g/t
            '10=c/g/t
            '11=a/c/g/t
                If tHold(Z, 4) > 0 Then
                    AncSeq(X, Z - NextNo) = 46
                ElseIf tHold(Z, 0) > 0 Then
                    If tHold(Z, 1) > 0 Then
                        If tHold(Z, 2) > 0 Then
                            If tHold(Z, 3) > 0 Then 'acgt
                                AncSeq(X, Z - NextNo) = 11
                            Else 'acg
                                AncSeq(X, Z - NextNo) = 7
                            End If
                        ElseIf tHold(Z, 3) > 0 Then 'act
                            AncSeq(X, Z - NextNo) = 8
                        Else 'ac
                            AncSeq(X, Z - NextNo) = 1
                        End If
                    ElseIf tHold(Z, 2) > 0 Then
                        If tHold(Z, 3) > 0 Then 'agt
                            AncSeq(X, Z - NextNo) = 9
                        Else 'ag
                            AncSeq(X, Z - NextNo) = 2
                        End If
                    ElseIf tHold(Z, 3) > 0 Then 'at
                        AncSeq(X, Z - NextNo) = 3
                    Else 'a
                        AncSeq(X, Z - NextNo) = 66
                    End If
                ElseIf tHold(Z, 1) > 0 Then 'c
                    If tHold(Z, 2) > 0 Then
                        If tHold(Z, 3) > 0 Then 'cgt
                            AncSeq(X, Z - NextNo) = 10
                        Else 'cg
                            AncSeq(X, Z - NextNo) = 4
                        End If
                    ElseIf tHold(Z, 3) > 0 Then 'ct
                        AncSeq(X, Z - NextNo) = 5
                    Else 'c
                        AncSeq(X, Z - NextNo) = 68
                    End If
                ElseIf tHold(Z, 2) > 0 Then
                    If tHold(Z, 3) > 0 Then 'gt
                        AncSeq(X, Z - NextNo) = 6
                    Else 'g
                        AncSeq(X, Z - NextNo) = 72
                    End If
                ElseIf tHold(Z, 3) > 0 Then 't
                    AncSeq(X, Z - NextNo) = 85
                Else
                    
                End If
                If AncSeq(X, Z - NextNo) < 46 Then
                    X = X
                End If
                If X = 2516 Then
                    X = X
                End If
            Next Z
        End If
        X = X
    Next X
End If
'3.145s
'Make a conversion matrix
ReDim ConDeg(85, 85)
'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t
For X = 1 To 85
    UnionC(X, X) = X
Next X

For X = 1 To 11
    UnionC(11, X) = X
    UnionC(46, X) = X
    UnionC(X, 46) = X
    UnionC(X, 11) = X
Next X
UnionC(85, 68) = 5
UnionC(85, 66) = 3
UnionC(85, 72) = 6
UnionC(66, 68) = 1
UnionC(68, 72) = 4
UnionC(66, 72) = 2

UnionC(85, 1) = 1
UnionC(85, 2) = 2
UnionC(85, 3) = 85
UnionC(85, 4) = 4
UnionC(85, 5) = 85
UnionC(85, 6) = 85
UnionC(85, 7) = 7
UnionC(85, 8) = 85
UnionC(85, 9) = 85
UnionC(85, 10) = 85
UnionC(85, 11) = 85


UnionC(72, 1) = 1
UnionC(72, 2) = 72
UnionC(72, 3) = 3
UnionC(72, 4) = 72
UnionC(72, 5) = 5
UnionC(72, 6) = 72
UnionC(72, 7) = 72
UnionC(72, 8) = 8
UnionC(72, 9) = 72
UnionC(72, 10) = 72
UnionC(72, 11) = 72

UnionC(68, 1) = 68
UnionC(68, 2) = 2
UnionC(68, 3) = 3
UnionC(68, 4) = 68
UnionC(68, 5) = 68
UnionC(68, 6) = 6
UnionC(68, 7) = 68
UnionC(68, 8) = 68
UnionC(68, 9) = 9
UnionC(68, 10) = 68
UnionC(68, 11) = 68

UnionC(66, 1) = 66
UnionC(66, 2) = 66
UnionC(66, 3) = 66
UnionC(66, 4) = 4
UnionC(66, 5) = 5
UnionC(66, 6) = 6
UnionC(66, 7) = 66
UnionC(66, 8) = 66
UnionC(66, 9) = 66
UnionC(66, 10) = 10
UnionC(66, 11) = 66


UnionC(10, 1) = 68
UnionC(10, 2) = 72
UnionC(10, 3) = 85
UnionC(10, 4) = 4
UnionC(10, 5) = 5
UnionC(10, 6) = 6
UnionC(10, 7) = 4
UnionC(10, 8) = 5
UnionC(10, 9) = 6
UnionC(10, 11) = 10


UnionC(9, 1) = 66
UnionC(9, 2) = 2
UnionC(9, 3) = 3
UnionC(9, 4) = 72
UnionC(9, 5) = 85
UnionC(9, 6) = 6
UnionC(9, 7) = 2
UnionC(9, 8) = 3
UnionC(9, 10) = 6
UnionC(9, 11) = 9


UnionC(8, 1) = 1
UnionC(8, 2) = 66
UnionC(8, 3) = 3
UnionC(8, 4) = 68
UnionC(8, 5) = 5
UnionC(8, 6) = 85
UnionC(8, 7) = 1
UnionC(8, 9) = 3
UnionC(8, 10) = 5
UnionC(8, 11) = 8

UnionC(7, 1) = 1
UnionC(7, 2) = 2
UnionC(7, 3) = 66
UnionC(7, 4) = 4
UnionC(7, 5) = 68
UnionC(7, 6) = 72
UnionC(7, 8) = 1
UnionC(7, 9) = 2
UnionC(7, 10) = 4
UnionC(7, 11) = 7

UnionC(6, 1) = 11
UnionC(6, 2) = 72
UnionC(6, 3) = 85
UnionC(6, 4) = 72
UnionC(6, 5) = 85
UnionC(6, 7) = 72
UnionC(6, 8) = 85
UnionC(6, 9) = 6
UnionC(6, 10) = 6
UnionC(6, 11) = 6

UnionC(5, 1) = 68
UnionC(5, 2) = 11
UnionC(5, 3) = 85
UnionC(5, 4) = 68
UnionC(5, 6) = 85
UnionC(5, 7) = 68
UnionC(5, 8) = 5
UnionC(5, 9) = 85
UnionC(5, 10) = 5
UnionC(5, 11) = 5

UnionC(4, 1) = 68
UnionC(4, 2) = 72
UnionC(4, 3) = 11 '3
UnionC(4, 5) = 68
UnionC(4, 6) = 72
UnionC(4, 7) = 4
UnionC(4, 8) = 68
UnionC(4, 9) = 72
UnionC(4, 10) = 4
UnionC(4, 11) = 4

UnionC(3, 1) = 66
UnionC(3, 2) = 66
UnionC(3, 4) = 11 '4
UnionC(3, 5) = 85
UnionC(3, 6) = 85
UnionC(3, 7) = 66
UnionC(3, 8) = 3
UnionC(3, 9) = 3
UnionC(3, 10) = 85
UnionC(3, 11) = 3

UnionC(2, 1) = 66
UnionC(2, 3) = 66
UnionC(2, 4) = 72
UnionC(2, 5) = 11
UnionC(2, 6) = 72
UnionC(2, 7) = 2
UnionC(2, 8) = 66
UnionC(2, 9) = 2
UnionC(2, 10) = 72
UnionC(2, 11) = 2

UnionC(1, 2) = 66
UnionC(1, 3) = 66
UnionC(1, 4) = 68
UnionC(1, 5) = 68
UnionC(1, 6) = 11
UnionC(1, 7) = 1
UnionC(1, 8) = 1
UnionC(1, 9) = 66
UnionC(1, 10) = 68
UnionC(1, 11) = 1


For X = 0 To 85
    For Y = X + 1 To 85
        'If (UnionC(X, Y) > 0 Or UnionC(Y, X) > 0) And (UnionC(X, Y) <> UnionC(Y, X)) Then
        '        X = X
        '    End If
        If UnionC(X, Y) = 0 Then
            UnionC(X, Y) = UnionC(Y, X)
        Else
            
            UnionC(Y, X) = UnionC(X, Y)
        End If
        ConDeg(X, Y) = 1
    Next Y
Next X
'ConDeg(66, 68) = 1
'ConDeg(66, 72) = 1
'ConDeg(66, 85) = 1
'ConDeg(68, 72) = 1
'ConDeg(68, 85) = 1
'ConDeg(72, 85) = 1



ConDeg(1, 66) = 0.5
ConDeg(2, 66) = 0.5
ConDeg(3, 66) = 0.5
ConDeg(7, 66) = 0.6666
ConDeg(8, 66) = 0.6666
ConDeg(9, 66) = 0.6666
ConDeg(11, 66) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(1, 68) = 0.5
ConDeg(4, 68) = 0.5
ConDeg(5, 68) = 0.5
ConDeg(7, 68) = 0.6666
ConDeg(8, 68) = 0.6666
ConDeg(10, 68) = 0.6666
ConDeg(11, 68) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(2, 72) = 0.5
ConDeg(4, 72) = 0.5
ConDeg(6, 72) = 0.5
ConDeg(7, 72) = 0.6666
ConDeg(9, 72) = 0.6666
ConDeg(10, 72) = 0.6666
ConDeg(11, 72) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(3, 85) = 0.5
ConDeg(5, 85) = 0.5
ConDeg(6, 85) = 0.5
ConDeg(8, 85) = 0.6666
ConDeg(9, 85) = 0.6666
ConDeg(10, 85) = 0.6666
ConDeg(11, 85) = 0.75

'1=a/c

'2=a/g

'3=a/t

'4=c/g

'5=c/t

'6=g/t

'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t


ConDeg(10, 11) = 0.75

ConDeg(9, 10) = 0.7777
ConDeg(9, 11) = 0.75

ConDeg(8, 9) = 0.7777
ConDeg(8, 10) = 0.7777
ConDeg(8, 11) = 0.75

ConDeg(7, 8) = 0.7777
ConDeg(7, 9) = 0.7777
ConDeg(7, 10) = 0.7777
ConDeg(7, 11) = 0.75

ConDeg(6, 7) = 0.8333
ConDeg(6, 8) = 0.8333
ConDeg(6, 9) = 0.6666
ConDeg(6, 10) = 0.6666
ConDeg(6, 11) = 0.75

ConDeg(5, 6) = 0.75
ConDeg(5, 7) = 0.8333
ConDeg(5, 8) = 0.6666
ConDeg(5, 9) = 0.8333
ConDeg(5, 10) = 0.6666
ConDeg(5, 11) = 0.75


ConDeg(4, 5) = 0.75
ConDeg(4, 6) = 0.75
ConDeg(4, 7) = 0.6666
ConDeg(4, 8) = 0.8333
ConDeg(4, 9) = 0.8333
ConDeg(4, 10) = 0.6666
ConDeg(4, 11) = 0.75


ConDeg(3, 4) = 1
ConDeg(3, 5) = 0.75
ConDeg(3, 6) = 0.75
ConDeg(3, 7) = 0.8333
ConDeg(3, 8) = 0.6666
ConDeg(3, 9) = 0.6666
ConDeg(3, 10) = 0.8333
ConDeg(3, 11) = 0.75

ConDeg(2, 3) = 0.75
ConDeg(2, 4) = 0.75
ConDeg(2, 5) = 1
ConDeg(2, 6) = 0.75
ConDeg(2, 7) = 0.6666
ConDeg(2, 8) = 0.8333
ConDeg(2, 9) = 0.6666
ConDeg(2, 10) = 0.8333
ConDeg(2, 11) = 0.75

ConDeg(1, 2) = 0.75
ConDeg(1, 3) = 0.75
ConDeg(1, 4) = 0.75
ConDeg(1, 5) = 0.75
ConDeg(1, 6) = 1
ConDeg(1, 7) = 0.6666
ConDeg(1, 8) = 0.6666
ConDeg(1, 9) = 0.8333
ConDeg(1, 10) = 0.8333
ConDeg(1, 11) = 0.75

ConDeg(1, 1) = 0.5
ConDeg(2, 2) = 0.5
ConDeg(3, 3) = 0.5
ConDeg(4, 4) = 0.5
ConDeg(5, 5) = 0.5
ConDeg(6, 6) = 0.5
ConDeg(7, 7) = 0.6666
ConDeg(8, 8) = 0.6666
ConDeg(9, 9) = 0.6666
ConDeg(10, 10) = 0.6666
ConDeg(11, 11) = 0.75

For X = 0 To 85
    For Y = X + 1 To 85
        ConDeg(Y, X) = ConDeg(X, Y)
    Next Y
Next X

Form1.ProgressBar1 = 55

ReDim AncDstMat(NextNo * 2, NextNo * 2)
Dim Valid As Long

'Make Ancestral sequence at root node

S1 = BranchMap(NextNo * 2, 1)
S2 = BranchMap(NextNo * 2, 2)
Dim S1V As Long, S2V As Long
For X = 0 To Len(StrainSeq(0))
    If S1 > NextNo Then
        S1V = AncSeq(X, S1 - NextNo)
    Else
        S1V = SeqNum(X, S1)
    End If
    If S2 > NextNo Then
        S2V = AncSeq(X, S2 - NextNo)
    Else
        S2V = SeqNum(X, S2)
    End If
    AncSeq(X, NextNo) = UnionC(S1V, S2V)
    X = X
Next X

If X = X Then
    Dummy = GetAncDst(NextNo, Len(StrainSeq(0)), AncSeq(0, 0), SeqNum(0, 0), AncDstMat(0, 0), ConDeg(0, 0))
Else
    For X = 0 To NextNo * 2 - 1
        For Y = NextNo + 1 To NextNo * 2 - 1
            'If BranchMap(X, 0) = Y Then
            If X <> Y Then
                If X > NextNo Then
                    Valid = 0
                    For Z = 1 To Len(StrainSeq(0))
                        If AncSeq(Z, X - NextNo) <> 46 Then
                            If AncSeq(Z, Y - NextNo) <> 46 Then
                                Valid = Valid + 1
                                AncDstMat(X, Y) = AncDstMat(X, Y) + ConDeg(AncSeq(Z, X - NextNo), AncSeq(Z, Y - NextNo))
                            End If
                        End If
                    Next Z
                Else
                    Valid = 0
                    For Z = 1 To Len(StrainSeq(0))
                        If SeqNum(Z, X) <> 46 Then
                            If AncSeq(Z, Y - NextNo) <> 46 Then
                                Valid = Valid + 1
                                AncDstMat(X, Y) = AncDstMat(X, Y) + ConDeg(SeqNum(Z, X), AncSeq(Z, Y - NextNo))
                            End If
                        End If
                    Next Z
                End If
                AncDstMat(X, Y) = AncDstMat(X, Y) / Valid
                AncDstMat(Y, X) = AncDstMat(X, Y)
            End If
        
        Next Y
        
    Next X
End If

If X = X Then
    ReDim AncSeqS(NextNo)
    For X = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            If AncSeq(Y, X) < 46 Then
                AncSeqS(X) = AncSeqS(X) + Trim(Str(AncSeq(Y, X)))
            Else
                AncSeqS(X) = AncSeqS(X) + Chr(AncSeq(Y, X) - 1)
            End If
        Next Y
    Next X
End If
Form1.ProgressBar1 = 100
EE = GetTickCount
TT = EE - SS
X = X
End Sub

Public Sub NJTree2(NJF As Integer)

    Dim TName As String, YCnt As Long, ColTotals() As Double, TreeString2 As String, tTYF As Double, TYFM As Integer
    Dim DoneLine() As Byte, A As Long, B As Long, NLen As Long
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
            
    Form2.Picture2(0).Enabled = False
    Form2.Picture2(1).Enabled = False
    Form2.Picture2(2).Enabled = False
    Form2.Picture2(3).Enabled = False
    
    SS = GetTickCount
    If TBSReps < 1 Then TBSReps = 1
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NHFlag As Integer, NumberOfSeqs As Long, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim PNodeStr() As Long
    Dim LSeq As Long, LPos As Long, X As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim Boots() As String
    Dim GetString As String, BootName As String, Header As String, ODir As String, TString As String
    Dim TreeByte() As Byte
    Dim DLen() As Double, NodeXPos() As Double, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Double, NameXPos() As Double, SeqXPos() As Double, NewFontSize As Double
    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim MatrixByte() As Byte
    Dim MatrixLen As Long
    Dim ScaleVal As String
    Dim ScaleValD As Double
    
    Dim oRec As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    Dim OrderArray() As Byte
    Dim T0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long

    ReDim PNodeStr(NextNo * 2)
    ReDim DLen(NextNo)
    LSeq = TSeqLen



    
    If F2TreeIndex = 0 Then
        If NJF = 1 Then
            NHFlag = 4
            TTF = 1
        ElseIf NJF = 2 Then
            NHFlag = 5
        Else
            NHFlag = 6
        End If

    ElseIf F2TreeIndex = 2 Then

        If NJF = 1 Then
            NHFlag = 7
        ElseIf NJF = 2 Then
            NHFlag = 8
        Else
            NHFlag = 9
        End If
    ElseIf F2TreeIndex = 1 Then

        If NJF = 1 Then
            NHFlag = 10
        ElseIf NJF = 2 Then
            NHFlag = 11
        Else
            NHFlag = 12
        End If
    End If

    NumberOfSeqs = NextNo

    If TBSReps = 0 And (NJF = 1 Or NJF = 2) Then
    
        Form1.ProgressBar1.Value = 10
        Form2.ProgressBar1.Value = 10
    Else
        Form2.ProgressBar1.Value = 5
        Form1.ProgressBar1.Value = 5
    End If

    Form2.Command2.Enabled = True
    'Sort out directory locations
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    'Clean up files
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    Kill "infile_phyml_boot_trees.txt"
    On Error GoTo 0
    ReDim Boots(NextNo + 2)
    'Set up copies of sequences that can be edited and rearranged etc
    NumberOfSeqs = NextNo
    'Set up batch files

    
    If NJF = 3 Then 'ML trees
        Open "dnadist.bat" For Output As #1
        If X = 12345 Then
            
            Print #1, "fastdnaml <infile"
            'Print #1, "fastdnaml <optfile"
            'Print #1, "dnaml <optfile"
            Print #1, "del treefile"
            Print #1, "rename treefile.0 treefile "
            
            
        Else
        'phyml seqs1 0 i 2 0 HKY 4.0 e 1 1.0 BIONJ y y
        'sequences file, data type, sequence format, nb data sets, nb bootstrapped data sets,
        'substitution model, ts/tv ratio , prop. invariable sites, nb categories gamma parameter, starting tree,
        'optimise topology, optimise branch lengths and rate parameters
          OutString = ""
          OutString = "phyml_win32.exe infile 0 s 1"
          ' BS reps
          If TBSReps <= 1 Then
            OutString = OutString + " 0"
          Else
            OutString = OutString + " " + Trim(Str(TBSReps))
          End If
          'Substitution model
          If TModel = 0 Then
                OutString = OutString + " JC69"
          ElseIf TModel = 1 Then
                OutString = OutString + " HKY"
          ElseIf TModel = 2 Then
                OutString = OutString + " GTR"
          ElseIf TModel = 4 Then
                OutString = OutString + " F84"
          End If
          'tvrat
          If TTVRat <> 0.5 Then
                OutString = OutString + " " + Trim(Str(TTVRat * 2))
          Else
                OutString = OutString + " e"
          End If
          
          OutString = OutString + " 0"
          'number rate categories
          
          'gamma correction
          
          'starting tree
          OutString = OutString + " 1 1.0 BIONJ y y"
          '
          Print #1, OutString
          Print #1, "del treefile"
            
            Print #1, "rename infile_phyml_tree.txt treefile "
        End If
        Close #1
    End If
    
    If (NJF = 1 Or NJF = 2) And TBSReps > 2 Then
        
        Call MakeConsenseFiles(NextNo)
        
    End If
    'Work out branch lengths
    

    
    If NJF = 3 Then
        'Do FastDNAML options file
        If Len(TempSeq(0)) > 32000 Then

            For X = 0 To NextNo
                TempSeq(X) = left$(TempSeq(X), 32000)
            Next 'X

        End If

        Open "infile" For Output As #1
        Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
        
        If X = 12335 Then
            Header = Header + " T O"
    
            If TBaseFreqFlag = 1 Then
                Header = Header + " F"
            End If
    
            If TGRFlag = 1 Then
                Header = Header + " G"
            End If
    
            If TRndIOrderFlag = 1 Then
                Header = Header + " J"
            End If
    
            If TBSReps > 1 Then
                Header = Header + " B"
            End If
    
            If TBaseFreqFlag = 1 Then
                Header = Header + " F"
            End If
    
            Header = Header + " Q 4 Y"
            Print #1, Header
            Print #1, "O " & CStr(Outie + 1)
    
            If TBaseFreqFlag = 1 Then
                Print #1, "F " & TAfreq & " " & TCFreq & " " & TGFreq & " " & TTFreq
            End If
    
            If TRndIOrderFlag = 1 Then
                Print #1, "J " + Trim$(CStr(TRndSeed))
            End If
    
            If TBSReps > 1 Then
                Print #1, "B " + Trim$(CStr(TRndSeed))
            End If
    
            Print #1, "T " + Trim$(CStr(TTVRat))
            BatIndex = 4
        Else
            Print #1, Header
            BatIndex = 7
        End If
        NLen = Len(Trim(Str(NumberOfSeqs)))
        If NLen = 1 Then NLen = 2
        For X = 0 To NumberOfSeqs
            
            TName = Trim$(CStr(X))
            TName = String(NLen - Len(TName), "0") & TName
            TName = "S" & TName
            BootName = TName
            BootName = BootName + String$(10 - (Len(BootName)), " ")
            TString = TempSeq(X)
            Boots(X) = BootName + TString
            Print #1, Boots(X)
        Next 'X

        'Set up the initial infile
        Close #1
        
        PBStart = Form1.ProgressBar1.Value
        PBTarget = 95
        Form1.SSPanel1.Caption = "Drawing ML Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    End If

    'Calculate distance matrices
    If NJF = 1 Or NJF = 2 Then
        Dim LS As Long
        LS = TSeqLen
        
        
        
        ReDim ttSeqNum(LS, NextNo)
       
        ReDim WeightMod(TBSReps, LS - 1)
        ReDim tMat(NextNo, NextNo)
        ReDim SHolder((NextNo + 1) * 40 * 2)
        ReDim Scratch(LS)
        ReDim Alias(LS)
        ReDim Ally(LS)
        
        ReDim xx1(3) 'int
        ReDim xx2(3) 'int
        ReDim Weight(TBSReps, LS) 'long
        ReDim Location(LS) 'long
        ReDim Px(NextNo, LS) 'int
        ReDim Prod1(LS) 'doub
        ReDim Prod2(LS) 'doub
        ReDim Prod3(LS) 'doub
        
        ReDim DstMat(TBSReps, NextNo, NextNo) 'double
        ReDim DistVal(TBSReps + 1) 'double
        ReDim Num1(TBSReps + 1) 'long
        ReDim Num2(TBSReps + 1) 'long
        ReDim DEN(TBSReps + 1) 'long
        ReDim Num(TBSReps + 1) ''double
        
        If TBSReps > 1 Then
            SEQBOOT2 TRndSeed, TBSReps, LS, Scratch(0), WeightMod(0, 0)
            'For X = 0 To LS - 1
            '    If WeightMod(1, X) = 0 Then
            '        X = X
            '    End If
            'Next X
        Else
            X = X
            For X = 0 To LS - 1
                WeightMod(0, X) = 1
            Next X
        End If
        Dim SeqScores() As Double
        ReDim SeqScores(NextNo)
        Dim MaxDScore As Double
        MaxDScore = 0
        Dim ValidX() As Double, DiffsX() As Double
        If TModel <> 3 Then
            Form1.SSPanel1.Caption = "Calculating distances"
            Form2.SSPanel3.Caption = "Calculating distances"
            Form1.ProgressBar1 = 20
            Form2.ProgressBar1 = 20
            If TModel = 0 Then
                ReDim ValidX(TBSReps), DiffsX(TBSReps) ', DstMat(BSBootReps, NextNo, NextNo)
                Dummy = FastBootDist(0, TBSReps, NextNo, LS, DiffsX(0), ValidX(0), WeightMod(0, 0), ETSeqNum(0, 0), DstMat(0, 0, 0))
            Else
                BootDist TBSReps, TCoeffVar, TTVRat, TModel, NextNo + 1, LS, ETSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), Num(0), WeightMod(0, 0)
            End If
            Form1.SSPanel1.Caption = "Drawing trees"
            Form2.SSPanel3.Caption = "Drawing trees"
            Form1.ProgressBar1 = 60
            Form2.ProgressBar1 = 60
            
            For X = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(X) = SeqScores(X) + DstMat(0, X, Y)
                Next Y
            Next X
            
            For X = 0 To NextNo
                If SeqScores(X) > MaxDScore Then
                    Outie = X
                    MaxDScore = SeqScores(X)
                End If
            Next X
            
        Else
             ReDim bttSeqNum(TSeqLen, NextNo)
            For X = 0 To TBSReps - 1

                If X > 0 Then
                    SP = 0

                    For Z = 1 To TSeqLen

                        For A = 1 To WeightMod(X, Z - 1)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                bttSeqNum(SP, Y) = ETSeqNum(Z, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To TSeqLen

                        For Y = 0 To NumberOfSeqs
                            bttSeqNum(Z, Y) = ETSeqNum(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(TBSReps, BSStepWin)
                Dummy = DNADIST(TCoeffVar, TTVRat, TBaseFreqFlag, TModel, TAfreq, TCFreq, TGFreq, TTFreq, NextNo + 1, TSeqLen, bttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0))
                
                Form1.SSPanel1.Caption = Str(X) & " of" & Str(TBSReps) & " matrices calculated"
                Form2.SSPanel3.Caption = Str(X) & " of" & Str(TBSReps) & " matrices calculated"
                Form1.ProgressBar1 = 20 + 40 * (X / TBSReps)
                Form2.ProgressBar1 = 20 + 40 * (X / TBSReps)
                'If RelX = 0 And RelY = 0 Then
                
                    For Y = 0 To NumberOfSeqs - 1
                        For Z = Y + 1 To NumberOfSeqs
                            DstMat(X, Y, Z) = tMat(Y, Z)
                            DstMat(X, Z, Y) = tMat(Y, Z)
                            'AbortFlag = 1
                            'Exit Sub
                        Next 'Z
    
                    Next 'Y
               ' Else
               '     For Y = 0 To NumberOfSeqs - 1
               '         For Z = Y + 1 To NumberOfSeqs
               '             If TMat(Y, Z) > 1 Then
               '                 TMat(Y, Z) = 1
               '             End If
               '             DstMat(X, Y, Z) = TMat(Y, Z)
               '             DstMat(X, Z, Y) = TMat(Y, Z)
               '         Next 'Z
               '
               '     Next 'Y
               ' End If

            Next 'X
            For X = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(X) = SeqScores(X) + DstMat(0, X, Y)
                Next Y
            Next X
            
            For X = 0 To NextNo
                If SeqScores(X) > MaxDScore Then
                    MaxDScore = SeqScores(X)
                    Outie = X
                End If
            Next X
            X = X
        End If
        
        If NJF = 1 Then ' ie NJ tree
            For X = 0 To NextNo
                For Y = X + 1 To NextNo
                    DstMat(0, X, Y) = (CLng(DstMat(0, X, Y) * 10000000)) / 10000000
                    DstMat(0, Y, X) = DstMat(0, X, Y)
                    
                Next Y
            Next X
            
            
            Dim TreeString As String
            ReDim tMat(NextNo, NextNo)
            ReDim SHolder((NextNo + 1) * 40 * 2)
            If TBSReps > 1 Then
                Open "infile" For Output As #1
            End If
                
                
                
                'For X = 0 To NextNo
                '    For Y = X + 1 To NextNo
                '        DstMat(0, X, Y) = (CLng(DstMat(0, X, Y) * 10000000)) / 10000000
                '        DstMat(0, Y, X) = DstMat(0, X, Y)
                '        'SMat(X, Y) = (CLng(SMat(X, Y) * 10000000)) / 10000000
                '        'SMat(Y, X) = SMat(X, Y)
                '    Next Y
                'Next X
            For X = 0 To TBSReps - 1
                'DstMat(0, 0, 29) = 0.049
                If (RelX = 0 And RelY = 0) Or X > 0 Then
                    
                    Dummy = TransferDist(NextNo, X, TBSReps, tMat(0, 0), DstMat(0, 0, 0))
                Else
                     Dummy = TransferDist(NextNo, X, TBSReps, tMat(0, 0), DstMat(0, 0, 0))
                   ' For Y = 0 To NextNo - 1
                   '     For Z = Y + 1 To NextNo
                   '         If tMat(Y, Z) > 1 Then
                  '
                  '              tMat(Y, Z) = 1
                  '              tMat(Z, Y) = 1
                  '          End If
                  '      Next 'Z
                  '
                  '  Next 'Y
                End If
                
                
                
                'For Z = 0 To Nextno
                '    XX = tMat(Z, 31)
                '    XX = PermValid(Z, 28)
                '    XX = PermDiffs(Z, 31)
                '    For Y = 1 To Len(StrainSeq(0))
                '        If ETSeqnum(Y, 31) <> 46 Then
                '            X = X
                 '       End If
                '    Next Y
                'Next Z
                
                If X = 12345 Then
                Open "distmat.csv" For Output As #5
                XX = CurDir
                
                For A = 0 To TBSReps
                   For Z = 0 To NextNo    'xxxx
                       OS = ""
                
                       For Y = 0 To NextNo   'xxxx
                           If X = X Then
                               OS = OS + Str(DstMat(A, Z, Y)) + ","
                           Else
                               OS = OS + " 0 ,"
                           End If
                       Next Y
                       Print #5, OS
                   Next Z
                   Print #5, OS
                Next A
              '  'XX = TreeTraceSeqs(1, 46)
                Close #5
                X = X
                End If
                
                ReDim ColTotals(NextNo)
                Dim TreeArray() As Double
                ReDim TreeArray(NextNo, NextNo)
                LTree = NEIGHBOUR(1, 0, TRndSeed, Outie + 1, NextNo + 1, tMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
                'byte array to string
                If X = 12345 Then
                    zz = CurDir
                    Dim ssy As String
                    ssy = ""
                
                    For Z = 1 To LTree
                        ssy = ssy + Chr(SHolder(Z))
                    Next Z '
               
                    
               
                     Open "test.tre" For Output As #10
               
                    Print #10, ssy
                    Close #10
                    XX = UBound(TreeArray, 2)
                    '1,0,3,61,64,63,5120,63,63
                    X = X
                End If
                'XX = TreeTraceSeqs(1, 60)'79
                Form1.SSPanel1.Caption = Str(X) & " of " & Str(TBSReps) & " trees drawn"
                Form2.SSPanel3.Caption = Str(X) & " of " & Str(TBSReps) & " trees drawn"
                Form1.ProgressBar1 = 60 + 40 * (X / TBSReps)
                Form2.ProgressBar1 = 60 + 40 * (X / TBSReps)
                
                TreeString = ""
                TreeString2 = ""
                For Y = 1 To LTree
                    TreeString = TreeString + Chr$(SHolder(Y))
                    TreeString2 = TreeString2 + Chr$(SHolder(Y))
                    If Chr$(SHolder(Y)) = "(" Or Chr$(SHolder(Y)) = ")" Then
                        TreeString2 = TreeString2 + Chr(13)
                    End If
                Next Y
                'Write to consense infile
                If TBSReps > 1 Then
                    
                    Print #1, TreeString2
                End If
                If X = 0 Then
                    GetString = TreeString
                    NHString(NHFlag) = GetString
                    ReDim TreeByte(LTree)
                    For Y = 1 To LTree
                        TreeByte(Y - 1) = SHolder(Y)
                    Next Y
                End If
            Next X
            If TBSReps > 1 Then
                Close #1
            End If
            X = X
            'Exit Sub
        Else
            Open "outfilex2" For Output As #1
            Open "outfilex3" For Output As #2
            For Z = 0 To TBSReps
                If Z = 0 Then
                        Print #2, "  " & CStr(NumberOfSeqs + 1)
                End If
                Print #1, "  " & CStr(NumberOfSeqs + 1)
                NLen = Len(Trim(Str(NumberOfSeqs)))
                If NLen = 1 Then NLen = 2
                For X = 0 To NumberOfSeqs
                
                    
                    TName = Trim$(CStr(X))
                    TName = String(NLen - Len(TName), "0") & TName
                    TName = "S" & TName
                    
                    OutString = TName & String$(9 - Len(TName), " ")
                    
                    For Y = 0 To NumberOfSeqs
            
                        If DstMat(Z, X, Y) = 0 Then
                            OutString = OutString & "  0.0000"
                        ElseIf DstMat(Z, X, Y) = 1 Then
                            OutString = OutString & "  1.0000"
                        ElseIf DstMat(Z, X, Y) > 1 Then
                            OutString = OutString & "  " & Int(DstMat(Z, X, Y) * 10000) / 10000 '& String$((6 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        Else
                            OutString = OutString & "  " & Int(DstMat(Z, X, Y) * 10000) / 10000 '& String$((5 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        End If
            
                    Next 'Y
                    If Z = 0 Then
                        Print #2, OutString
                    End If
                    Print #1, OutString
                Next 'X
            Next 'Z
            Close #2
            Close #1
        End If
        X = X
    Else
        'Do
        ssx = GetTickCount
        'Do
        ShellAndClose "dnadist.bat", 0
        'Loop
        eex = GetTickCount
        TT = eex - ssx
        '23.093 - infile 0 s 1 5 JC69 e e 1 1.0 BIONJ y y
        '20.729 - infile 0 s 1 5 F84 4 e 1 1.0 BIONJ y y
        '16.193 - no invariable sites infile 0 s 1 5 F84 4 0 1 1.0 BIONJ y y
        '15.002 - infile 0 s 1 5 HKY 4 0 1 1.0 BIONJ y y
        '16.393 infile 0 s 1 5 GTR 4 0 1 1.0 BIONJ y y

        X = X
        'Loop
    End If
    
    If AbortFlag = 1 Then
        Form2.Picture2(0).Enabled = True
        Form2.Picture2(1).Enabled = True
        Form2.Picture2(2).Enabled = True
        Form2.Picture2(3).Enabled = True
        
        ChDir ODir
        ChDrive ODir
        Exit Sub
    End If

    If TBSReps < 2 And (NJF = 1 Or NJF = 2) Then
        Form1.ProgressBar1.Value = 60
        Form2.ProgressBar1.Value = 60
    ElseIf NJF = 1 Or NJF = 2 Then
        Form2.ProgressBar1.Value = 10
        Form1.ProgressBar1.Value = 10
    End If

    If NJF = 2 Then
        On Error Resume Next
        Kill "infilex"
        Kill "infile"
        On Error GoTo 0
        'AbortFlag = 1
        'Exit Sub

        
            Name "outfilex3" As "infile"
        

        'Make the NEIGHBOR optfile
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '    Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, TRndSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "2"
            'Print #1, "3"
            Print #1, "y"
        

        Close #1
        Form1.SSPanel1.Caption = "Drawing Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        
        Open "neighbor.bat" For Output As #1
        Print #1, "fitch <optfilen"
        Print #1, "rename outfile outfilex"
        Close #1
        
        
        ShellAndClose "neighbor.bat", 0
        'AbortFlag = 1

        If AbortFlag = 1 Then
            Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            ChDir ODir
            ChDrive ODir
            Exit Sub
        End If

    End If
    If NJF = 3 Or NJF = 2 Then
    'Open treefile and read in the tree.
    
        If TBSReps < 2 And NJF = 2 Then
            Form1.ProgressBar1.Value = 70
            Form2.ProgressBar1.Value = 70
        ElseIf NJF = 1 Or NJF = 2 Then
            Form2.ProgressBar1.Value = 15
            Form1.ProgressBar1.Value = 15
        Else
            Form2.ProgressBar1.Value = 98
            Form1.ProgressBar1.Value = 98
        End If
        If NJF = 2 Then
            Call ReadTreeFile("outtree", GetString, TreeByte())
        Else
            Call ReadTreeFile("treefile", GetString, TreeByte())
        End If
        NHString(NHFlag) = GetString
        Call ReplaceNames(NHFlag, NJF, NumberOfSeqs, NHString())
    End If
    LPos = 0
    'Open "tester.tre" For Output As #1
    'Print #1, NHString(NHFlag)
    'Close #1
    LPos = 0
    'xxx = CurDir
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)

    For X = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(X, Y) = -1
        Next 'Y

    Next 'X
    ReDim DLen(NumberOfSeqs + 1)
    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim NameXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    
        Do While LPos < Len(GetString)
            mZNo = 0
            lZNo = 0
            ZNo = NextNo + 1
            
            ' This collects:
            '(1) internal branch lengths (put into llen)
            '(2) terminal branch lnegths (put into seqxpos)
            '(3) positions of ")" in the encoded tree so that bootstrap values can be added later
            '(4) bracket pairs in which sequences are found (stored in Nodedepth - element 1=bracket pair,2=sequence order)
            If TreeByte(LPos - 1) = 40 Then '(
                'find the matching )
                
                If CCount > -1 Then
                    lZNo = ZNo
                    If ZNo + 1 <= mZNo Then
                        ZNo = mZNo + 1
                    Else
                        ZNo = ZNo + 1
                    End If
                    
                    
                End If
                CCount = CCount + 1
                
                DCount = 1
                SCount = 0
                TPos = LPos + 1
    
                Do
    
                    If TreeByte(TPos - 1) = 40 Then '(
                        DCount = DCount + 1
                        
                        
                    ElseIf TreeByte(TPos - 1) = 41 Then ')
                        
                        
                        
                        DCount = DCount - 1
    
                        If DCount = 0 Then ' Matching ) found - find branch len associated with this subtree
                            If NJF = 3 Then
                                If TreeByte(TPos) <> 58 Then
                                    XPos = TPos + 1
                                    Do While XPos < Len(GetString)
                                        If TreeByte(XPos) = 58 Then
                                            Exit Do
                                        End If
                                        XPos = XPos + 1
                                    Loop
                                    If XPos < Len(GetString) Then
                                        xxx = Mid$(GetString, TPos + 1, (XPos - TPos))
                                        DLen(CCount) = Val(Mid$(GetString, TPos + 1, (XPos - TPos)))
                                    Else
                                        DLen(CCount) = 0
                                    End If
                                    TPos = XPos
                                Else
                                    DLen(CCount) = 0
                                End If
                            End If
                            If TreeByte(TPos) = 58 Then ':
    
                                If TreeByte(TPos + 1) = 45 Then '-
    
                                    If NJF = 3 Then
                                        LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 10))
                                    Else
                                        If TNegBLFlag = 0 Then
                                            LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 8))
                                        Else
                                            LLen(CCount) = Val(Mid$(GetString, TPos + 2, 8))
                                        End If
                                    End If
    
                                    PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                Else
    
                                    If NJF = 3 Then
                                        LLen(CCount) = Val(Mid$(GetString, TPos + 2, 8))
                                    Else
                                        LLen(CCount) = Val(Mid$(GetString, TPos + 2, 7))
                                    End If
                                    If LLen(CCount) = 0 Then
                                        'LLen(CCount) = 0.0001
                                        zzzz = Mid$(GetString, TPos + 2, 8)
                                        X = X
                                    End If
                                    'xxx = DLen(CCount)
                                    PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                End If
    
                            Else
                            
                            
                                LLen(CCount) = 0
                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                            End If
    
                            Exit Do
                        End If
    
                    ElseIf TreeByte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                        
                        PosP = InStr(TPos, GetString, ":", vbBinaryCompare)
                        CSeq = Val(Mid$(GetString, TPos + 1, PosP - TPos - 1))
                        
                        
                        NodeDepth(CCount, SCount) = CSeq
                        SCount = SCount + 1
    
                        If Done(CSeq) = 0 Then
                            Done(CSeq) = 1
    
                            If TreeByte(PosP) = 45 Then  '-
    
                                If NJF = 3 Then
                                    
                                    SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 9))
                                    NameXPos(CSeq) = 0
                                Else
                                    'If Val(Mid$(GetString, PosP + 1, 8)) >= 0 Then
                                    If TNegBLFlag = 1 Then
                                        SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 8))
                                    Else
                                        SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                                    End If
                                    NameXPos(CSeq) = 0
                                    'Else
                                    '    X = X
                                    'End If
                                End If
    
                            Else
    
                                If NJF = 3 Then
                                    'zzzz = Mid$(GetString, PosP + 1, 8)
                                    SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 8))
                                    
                                    NameXPos(CSeq) = SeqXPos(CSeq)
                                    'If SeqXPos(CSeq) = 0 Then
                                    '    SeqXPos(CSeq) = 0.0000001
                                    'End If
                                Else
                                    SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 7))
                                    NameXPos(CSeq) = SeqXPos(CSeq)
                                End If
    
                            End If
    
                        End If
    
                    End If
    
                    TPos = TPos + 1
                Loop
    
            End If
    
            LPos = LPos + 1
            
        Loop
    
    'Get treedistances
    Dim LongDist As Double, CDist As Double, CurS As Long, LongSeq(1) As Long, TreeD() As Double, SepBranch() As Byte, LX As Byte
    
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    
    For X = 0 To NumberOfSeqs
        For Y = 0 To NumberOfSeqs
            If NodeDepth(X, Y) > -1 Then
                SepBranch(X, (NodeDepth(X, Y))) = 1
            End If
        Next Y
    Next X
    
    
    ReDim TreeD(NumberOfSeqs, NumberOfSeqs)
    
    'Do terminal branch lengths
    For X = 0 To NumberOfSeqs
        For Y = X + 1 To NumberOfSeqs
            TreeD(X, Y) = TreeD(X, Y) + SeqXPos(X) + SeqXPos(Y)
            TreeD(Y, X) = TreeD(X, Y)
        Next Y
    Next X
    'Add internal branch lengths
    
    For X = 0 To NumberOfSeqs
        For Y = 0 To NumberOfSeqs
            If NodeDepth(X, Y) > -1 Then
                CurS = NodeDepth(X, Y)
                For Z = 0 To NumberOfSeqs
                    If SepBranch(X, Z) = 0 Then
                        TreeD(CurS, Z) = TreeD(CurS, Z) + LLen(X)
                        TreeD(Z, CurS) = TreeD(Z, CurS) + LLen(X)
                        'X = X
                        'XX = SeqXPos(10)
                    End If
                Next Z
            End If
        Next Y
    Next X
    
    For X = 0 To NumberOfSeqs
        For Y = X + 1 To NumberOfSeqs
            If LongDist < TreeD(X, Y) Then
                LongDist = TreeD(X, Y)
                LongSeq(0) = X
                LongSeq(1) = Y
            End If
        Next Y
    Next X
    LongDist = LongDist / 2
    
    
    LX = 0
    CDist = SeqXPos(LongSeq(0))
    X = -LongSeq(0) - 1
    If CDist < LongDist Then
        For X = NumberOfSeqs To 0 Step -1
            
            If SepBranch(X, LongSeq(0)) = 1 And SepBranch(X, LongSeq(1)) = 0 Then 'ie sequences are separated by this branch
                
                CDist = CDist + LLen(X)
                If CDist > LongDist Then
                    Exit For
                End If
            End If
        Next X
        
        If CDist < LongDist Then
            LX = 1
            X = -LongSeq(1) - 1
            CDist = SeqXPos(LongSeq(1))
            If CDist < LongDist Then
                For X = NumberOfSeqs To 0 Step -1
                    If SepBranch(X, LongSeq(1)) = 1 And SepBranch(X, LongSeq(0)) = 0 Then 'ie sequences are separated by this branch
                    
                        CDist = CDist + LLen(X)
                        If CDist > LongDist Then
                            Exit For
                        End If
                    End If
                Next X
            End If
            
        End If
    End If
    
    Dim TempNodeDepth() As Long, TempLLen() As Double, TempDLen() As Double, TNode As Long, CNodeX As Long, XCnt As Long
    ReDim TempNodeDepth(NumberOfSeqs + 2, NumberOfSeqs + 2), TempLLen(NumberOfSeqs + 2), TempDLen(NumberOfSeqs + 2)
    'For X = NumberOfSeqs To 0 Step -1
    '    For Y = 0 To NumberOfSeqs
    '        If NodeDepth(X, Y) = -1 Then
    '            Exit For
    '        End If
    '    Next Y
    'Next X
    TNode = X
    'TNode = 6
    'LongDist = LLen(TNode) / 2
    'CDist = LLen(TNode)
    Dim oSepBranch() As Byte
    For X = 0 To NumberOfSeqs + 1
        For Y = 0 To NumberOfSeqs + 1
            TempNodeDepth(X, Y) = -1
        Next Y
    Next X
    If TNode < 0 Then 'ie the midpoint is in a terminal branch of sequence abs(x)
        TNode = Abs(TNode + 1)
        
        For X = NumberOfSeqs To 0 Step -1
            If SepBranch(X, TNode) = 1 Then
                
                For Z = X To 1 Step -1
                    TempLLen(2 + X - Z) = LLen(Z)
                    TempDLen(2 + X - Z) = DLen(Z)
                    Cnt = 0
                    If SepBranch(Z, TNode) = 1 Then
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 0 Then
                                TempNodeDepth(2 + X - Z, Cnt) = Y '19/3:0,1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32
                                '18/4:0,1,2,3,4,5,6,7,8,9,10,11,20,21,23,24,25,26,27,28,29,30, 31,32
                                '7/15:0,20,21,23,24,25,26,27,28,29,30,31,32
                                Cnt = Cnt + 1
                            End If
                            
                        Next Y
                        'If NodeDepth(Z, 2) = -1 Then
                        '    For Y = 0 To 1
                        '        If NodeDepth(Z, Y) <> TNode Then
                        '            TempNodeDepth(2 + X - Z, Cnt) = NodeDepth(X, Y)
                        '             Cnt = Cnt + 1
                        '        End If
                        '    Next Y
                        'End If
                    Else
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 1 Then
                                TempNodeDepth(2 + X - Z, Cnt) = Y
                                
                                Cnt = Cnt + 1
                                '17/5:1,2
                                '16/6:1,2,11
                                '15/7:6,7
                                '14/8:3,4
                                '13/9:3,4,5
                                '12/10:9,10
                                '11/11:3,4,5,9,10
                                '10/12:3,4,5,6,7,9,10
                            End If
                        Next Y
                    End If
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(2 + X - Z, Y) = -1
                    Next Y
                Next Z
                TempLLen(1) = SeqXPos(TNode) - LongDist
                'TempDLen(1) = DLen(TNode) 'SeqXPos(TNode) - LongDist
                SeqXPos(TNode) = LongDist
                NameXPos(TNode) = LongDist
                If X > 1 Then
                    XCnt = 0
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If TempNodeDepth(2, Y) = -1 Then Exit For
                        If Y <> TNode Then
                            TempNodeDepth(1, Y) = TempNodeDepth(2, Y)
                            Cnt = Cnt + 1
                        End If
                    Next Y
                    If Cnt < NumberOfSeqs Then
                    
                        For Y = 0 To NumberOfSeqs
                            If NodeDepth(X, Y) <> TNode Then
                                If NodeDepth(X, Y) = -1 Then Exit For
                                TempNodeDepth(1, Cnt) = NodeDepth(X, Y)
                                Cnt = Cnt + 1
                            End If
                        Next Y
                        
                        For Y = Cnt To NumberOfSeqs
                            TempNodeDepth(1, Cnt) = -1
                        Next Y
                    End If
                Else
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If Y <> TNode Then
                            TempNodeDepth(1, Cnt) = Y
                            Cnt = Cnt + 1
                        End If
                        
                    Next Y
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(1, Cnt) = -1
                    Next Y
                End If
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(0, Y) = TempNodeDepth(1, Y)
                Next Y
                'XX = TempNodeDepth(0, 0)
                TempNodeDepth(0, NumberOfSeqs) = TNode
                Exit For
            Else
                TempLLen(X + 1) = LLen(X)
                TempDLen(X + 1) = DLen(X)
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(X + 1, Y) = NodeDepth(X, Y)
                Next Y
            End If
            
            
        Next X
        'TNode = X
        'For X = TNode To 0 Step -1
        '    TempLLen(X) = LLen(X)
        '    For Y = 0 To NumberOfSeqs
        '        TempNodeDepth(X, Y) = NodeDepth(X, Y)
        '    Next Y
        'Next X
        TNode = 0
        
    Else   'it is in internal branch x
        TempLLen(2) = CDist - LongDist
        TempLLen(1) = LLen(TNode) - TempLLen(2)
        TempLLen(0) = LLen(TNode) - TempLLen(2)
        TempDLen(1) = DLen(TNode)
        TempDLen(0) = DLen(TNode)
        Cnt = 0
        For X = 0 To NumberOfSeqs
            If SepBranch(TNode, NodeDepth(0, X)) = 1 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, X)
                Cnt = Cnt + 1
            End If
        Next X
        For X = 0 To NumberOfSeqs
            XX = StraiName(NodeDepth(0, X))
            If SepBranch(TNode, NodeDepth(0, X)) = 0 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, X)
                Cnt = Cnt + 1
            Else
                Exit For
            End If
        Next X
        
        For X = NumberOfSeqs To 0 Step -1
            If SepBranch(TNode, NodeDepth(0, X)) = 0 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, X)
                Cnt = Cnt + 1
            Else
                Exit For
            End If
        Next X
        
        
        'TempNodeDepth(0, Cnt) = NumberOfSeqs + 1
        Cnt = 0
        For X = 0 To NumberOfSeqs
            If SepBranch(TNode, TempNodeDepth(0, X)) = 0 Then
                TempNodeDepth(2, Cnt) = TempNodeDepth(0, X)
                Cnt = Cnt + 1
            End If
        Next X
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(2, Y) = -1
        Next Y
        Cnt = 0
        For X = 0 To NumberOfSeqs
            If SepBranch(TNode, TempNodeDepth(0, X)) = 1 Then
                TempNodeDepth(1, Cnt) = TempNodeDepth(0, X)
                Cnt = Cnt + 1
            End If
        Next X
        TempNodeDepth(1, Cnt) = NumberOfSeqs + 1
        Cnt = Cnt + 1
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(1, Y) = -1
        Next Y
        
        XCnt = TNode + 1
        YCnt = 3
        For X = TNode - 1 To 1 Step -1
            
            If SepBranch(X, NodeDepth(TNode, 0)) = 0 Then
                TempLLen(XCnt) = LLen(X)
                TempDLen(XCnt) = DLen(X)
                Cnt = 0
                For Y = 0 To NumberOfSeqs
                    If SepBranch(X, TempNodeDepth(0, Y)) = 1 Then
                        TempNodeDepth(XCnt, Cnt) = TempNodeDepth(0, Y)
                        Cnt = Cnt + 1
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(XCnt, Y) = -1
                Next Y
                XCnt = XCnt - 1
            Else
                Cnt = 0
                TempLLen(YCnt) = LLen(X)
                TempDLen(YCnt) = DLen(X)
                For Y = 0 To NumberOfSeqs
                    If SepBranch(X, TempNodeDepth(0, Y)) = 0 Then
                        TempNodeDepth(YCnt, Cnt) = TempNodeDepth(0, Y)
                        Cnt = Cnt + 1
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(YCnt, Y) = -1
                Next Y
                YCnt = YCnt + 1
            End If
            
        Next X
        For X = TNode + 1 To NumberOfSeqs
            TempLLen(X + 1) = LLen(X)
            TempDLen(X + 1) = DLen(X)
            For Y = 0 To NumberOfSeqs
                TempNodeDepth(X + 1, Y) = NodeDepth(X, Y)
            Next Y
        
        Next X
       
        
        
    End If
    
    
    
    'Rearrange tempnodedepth so that 0-nextno run with the largest to smallest numbers of entries
    Dim ttNodeDepth() As Long, NumEnt() As Long, Maxent As Long, WinEnt As Long, ttLLen(), ttDLen()
    ReDim NumEnt(NumberOfSeqs), ttLLen(NumberOfSeqs), ttDLen(NumberOfSeqs)
    ReDim ttNodeDepth(NumberOfSeqs, NumberOfSeqs)
    For X = 0 To NumberOfSeqs
        NumEnt(X) = 0
        For Y = 0 To NumberOfSeqs
            If TempNodeDepth(X, Y) > -1 Then
                NumEnt(X) = NumEnt(X) + 1
            End If
        Next Y
    Next X
    For Y = 0 To NumberOfSeqs
        Maxent = -1
        For X = 0 To NumberOfSeqs
            If NumEnt(X) > Maxent Then
                Maxent = NumEnt(X)
                WinEnt = X
            End If
        Next X
        For X = 0 To NumberOfSeqs
            ttNodeDepth(Y, X) = TempNodeDepth(WinEnt, X)
            
        Next X
        ttLLen(Y) = TempLLen(WinEnt)
        ttDLen(Y) = TempDLen(WinEnt)
        NumEnt(WinEnt) = -1
    Next Y
    For X = 0 To NumberOfSeqs
        TempLLen(X) = ttLLen(X)
        TempDLen(X) = ttDLen(X)
        For Y = 0 To NumberOfSeqs
            TempNodeDepth(X, Y) = ttNodeDepth(X, Y)
        Next Y
    Next X
    
    ReDim oSepBranch(NumberOfSeqs + 2)
    If TNode > -1 Then
        For X = 0 To NumberOfSeqs
            oSepBranch(X) = SepBranch(TNode, X) '2,3,4,5,6,10,11,12,17,19,20
        Next X
    Else
        'XX = StraiName(20) 'simmv1,tpctv
        'oSepBranch(TempNodeDepth(0, NumberOfSeqs)) = 1
    End If
    
    
    X = X
    'For X = 3 To NumberOfSeqs
    '    If oSepBranch(TempNodeDepth(X, 0)) = 0 Then
    '        For Y = 0 To NumberOfSeqs
    '            If TempNodeDepth(X, Y) > -1 Then
    '                oSepBranch(TempNodeDepth(X, Y)) = 0
    '            End If
    '            Exit For
    '        Next Y
    '        Exit For
    '    End If
    'Next X
    NumberOfSeqs = NumberOfSeqs + 1
    Dim LongHold() As Long
    Dim DoneOne() As Byte, tOrder() As Long
    ReDim DoneOne(NumberOfSeqs), tOrder(NumberOfSeqs + 1), LongHold(NumberOfSeqs + 1)
    
    
    
    If X = X Then
        ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
        For X = 0 To NumberOfSeqs - 1
            For Y = 0 To NumberOfSeqs - 1
                If TempNodeDepth(X, Y) > -1 Then
                    SepBranch(X, TempNodeDepth(X, Y)) = 1
                Else
                    Exit For
                End If
            Next Y
        Next X
        
        Cnt = 0
        Redo = -2
        If TNode > -1 Then
            For A = 0 To 1
                First = -1
                Target = A
                'If A = 0 Then
                '    Target = 0
                'ElseIf A = 1 Then
                '    Target = 2
                'Else
                '    Target = 1
                'End If
               ' For X = 0 To NumberOfSeqs
               ' XX = StraiName(TempNodeDepth(2, X))
               ' Next X
                For Z = NumberOfSeqs To 0 Step -1
                    If TempNodeDepth(Z, 0) > -1 Then
                        If DoneOne(TempNodeDepth(Z, 0)) = 0 Then
                            Redo = -2
                            First = TempNodeDepth(Z, 0)
                            
                            Last = First
                            'LastX = -1
                            For X = Z To 0 Step -1
                                If SepBranch(X, First) = 1 Then
                                    Add = 0
                                    For Y = 0 To NumberOfSeqs
                                        
                                        If TempNodeDepth(X, Y) > -1 And TempNodeDepth(X, Y) <= NumberOfSeqs - 1 Then
                                            If oSepBranch(TempNodeDepth(X, Y)) = Target Then
                                                If DoneOne(TempNodeDepth(X, Y)) = 0 Then
                                                    Add = Add + 1
                                                    If Add > 2 Then Exit For
                                                End If
                                            End If
                                        End If
                                        
                                    Next Y
                                    If Add <= 2 Then
                                        For Y = 0 To NumberOfSeqs
                                            
                                            If TempNodeDepth(X, Y) > -1 And TempNodeDepth(X, Y) <= NumberOfSeqs - 1 Then
                                                If oSepBranch(TempNodeDepth(X, Y)) = Target Then
                                                    If DoneOne(TempNodeDepth(X, Y)) = 0 Then
                                                        tOrder(Cnt) = TempNodeDepth(X, Y)
                                                        If tOrder(Cnt) = 22 Then
                                                            X = X
                                                        End If
                                                        DoneOne(TempNodeDepth(X, Y)) = 1
                                                        XX = StraiName(TempNodeDepth(X, Y))
                                                        Cnt = Cnt + 1
                                                    End If
                                                End If
                                            End If
                                        Next Y
                                    ElseIf X > 0 Then
                                        ReDim LongHold(NumberOfSeqs + 1)
                                        XCnt = 0
                                        For Y = 0 To NumberOfSeqs
                                                
                                                If TempNodeDepth(X, Y) > -1 And TempNodeDepth(X, Y) <= NumberOfSeqs - 1 Then
                                                    If oSepBranch(TempNodeDepth(X, Y)) = Target Then
                                                        If DoneOne(TempNodeDepth(X, Y)) = 0 Then
                                                            LongHold(XCnt) = TempNodeDepth(X, Y)
                                                            XCnt = XCnt + 1
                                                            XX = StraiName(TempNodeDepth(X, Y))
                                                        End If
                                                    End If
                                                End If
                                        Next Y
                                        GoOn = 0
                                        For Y = NumberOfSeqs To 0 Step -1
                                            For B = 0 To XCnt - 1
                                                If SepBranch(Y, LongHold(B)) = 1 Then
                                                    GoOn = 1
                                                    Exit For
                                                End If
                                            Next B
                                            If GoOn = 1 Then Exit For
                                        Next Y
                                        If Y > X And First <> LongHold(B) Then
                                            First = LongHold(B)
                                            X = Y + 1
                                        'Else
                                        '    For B = 0 To XCnt - 1
                                        '        tOrder(Cnt) = LongHold(B)
                                        '        Cnt = Cnt + 1
                                        '        DoneOne(LongHold(B)) = 1
                                        '    Next B
                                        End If
                                        'Exit For
                                    End If
                                
                                End If
                            Next X
                            'If First <> Last Then
                            '    Z = Z + 1
                            '    Redo = tOrder(0)
                            'End If
                        End If
                    End If
                    If Cnt > NumberOfSeqs + 1 Then Exit For
                    
                    
                Next Z
            Next A
        End If
        'XX = StraiName(TempNodeDepth(0, 0))
        
        tOrder(NumberOfSeqs + 1) = NumberOfSeqs + 1
        For X = 0 To NumberOfSeqs
            TempNodeDepth(0, X) = tOrder(X) '25,0,24,30,31,32,29,26,27,28,23,20,21,1,2,3,4,5,6,7,17,16,19,18,15,13,14,12,9,10,8,11,33,0,0
            '22?
        Next X
        For X = 1 To NumberOfSeqs
            ReDim tOrder(NumberOfSeqs + 1)
            Cnt = 0
            For Y = 0 To NumberOfSeqs - 1
                If SepBranch(X, TempNodeDepth(0, Y)) = 1 Then
                    tOrder(Cnt) = TempNodeDepth(0, Y)
                    Cnt = Cnt + 1
                
                End If
                
            Next Y
            For Y = 0 To Cnt - 1
                TempNodeDepth(X, Y) = tOrder(Y)
            Next Y
            'XX = StraiName(TempNodeDepth(0, 0))
            X = X
        Next X
    ElseIf X = 12345 Then
        ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
        For X = 0 To NumberOfSeqs - 1
            For Y = 0 To NumberOfSeqs - 1
                If TempNodeDepth(X, Y) > -1 Then
                    SepBranch(X, TempNodeDepth(X, Y)) = 1
                Else
                    Exit For
                End If
            Next Y
        Next X
        'Dim tOrderx() As Long
        ReDim tOrder(NumberOfSeqs)
        For X = NumberOfSeqs - 1 To 1 Step -1
            For Y = 0 To NumberOfSeqs
                If TempNodeDepth(X, Y) > -1 Then
                    If SepBranch(X, TempNodeDepth(0, Y)) = 1 Then
                        'for z = 0 to
                    End If
                Else
                    Exit For
                End If
            Next Y
        Next X
    End If
    
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), LLen(NumberOfSeqs + 1)
    
    For X = 0 To NumberOfSeqs
        LLen(X) = TempLLen(X)
        DLen(X) = TempDLen(X)
        For Y = 0 To NumberOfSeqs
            NodeDepth(X, Y) = TempNodeDepth(X, Y)
        Next Y
    Next X
    For X = 0 To NumberOfSeqs
        NodeDepth(X, NumberOfSeqs) = -1
        NodeDepth(X, NumberOfSeqs + 1) = -1
    Next X
    LLen(0) = 0
    NodeDepth(0, NumberOfSeqs) = NumberOfSeqs
    'Dummy = TreeToArray(NameLen, NumberOfSeqs, LTree, T2Holder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0))
    'NumberOfSeqs = NumberOfSeqs + 1
    
    'work out y-positions of all the nodes.
    ReDim SeqYPos(NumberOfSeqs + 1)
    ReDim tSeqYPos(NumberOfSeqs + 1)
    ReDim NodeYPos(NumberOfSeqs + 1)

    For X = 0 To NumberOfSeqs
        SeqYPos(NodeDepth(0, X)) = X
        'Exit Sub
        tSeqYPos(NodeDepth(0, X)) = X
    Next 'X
    'SeqYPos(24) = 20
    'ccount = the number of bracket pairs (ie internal branches) in the tree
    ' Nodedepth - element 1=bracket pair,2=sequence order
    For X = CCount + 1 To 0 Step -1


        For Y = 0 To NumberOfSeqs + 1

            If NodeDepth(X, Y) = -1 Or NodeDepth(X, Y) = NumberOfSeqs Then Exit For
        Next 'Y

        Y = Y - 1
        NodeYPos(X) = tSeqYPos(NodeDepth(X, 0)) + (tSeqYPos(NodeDepth(X, Y)) - tSeqYPos(NodeDepth(X, 0))) / 2
        'Exit Sub
        tSeqYPos(NodeDepth(X, 0)) = NodeYPos(X)
        tSeqYPos(NodeDepth(X, Y)) = NodeYPos(X)
    Next 'X
'Exit Sub
   ' NodeYPos(0) = 1
    NodeYPos(0) = NodeYPos(1)

   ' NodeYPos(x) = 20
    'work out x positions
    ReDim NodeXPos(NumberOfSeqs + 1)

    For X = 0 To CCount + 1
        ReDim Done(NumberOfSeqs + 1)

        For Y = CCount + 1 To X Step -1

            For Z = 0 To NumberOfSeqs

                If NodeDepth(X, Z) = NodeDepth(Y, 0) Then
                    NodeXPos(Y) = NodeXPos(Y) + LLen(X)
                    A = 0

                    Do Until NodeDepth(Y, A) = -1

                        If Done(NodeDepth(Y, A)) = 0 Then
                                If NodeDepth(Y, A) = 0 Then
                                    X = X
                                End If
                                SeqXPos(NodeDepth(Y, A)) = SeqXPos(NodeDepth(Y, A)) + LLen(X) '0,1,8
                                X = X
                            If LLen(X) > 0 Then
                                NameXPos(NodeDepth(Y, A)) = NameXPos(NodeDepth(Y, A)) + LLen(X)
                            End If
                            Done(NodeDepth(Y, A)) = 1
                        End If

                        A = A + 1
                    Loop

                    Exit For
                End If

            Next 'Z

        Next 'Y

    Next 'X

    ' Find sequences branching from root node
    'obviosuly node 1 branches so look for largest xpos of sequences not on node 1
    ReDim Outside(NumberOfSeqs + 1)
    'Outie = NumberOfSeqs
    For X = 0 To NumberOfSeqs
        NotFound = 0

        For Y = 0 To NumberOfSeqs

            If NodeDepth(1, Y) = X Then
                NotFound = 1
                Exit For
            End If

        Next 'Y

        If NotFound = 0 Then
            Outside(X) = 1
        Else
            Outside(X) = 0
        End If

    Next 'X

    Outside(NumberOfSeqs) = 2
    MPosO = -100
    MPosI = -100

    For X = 0 To NumberOfSeqs

        If Outside(X) = 0 Then

            If SeqXPos(X) > MPosI Then
                MPosI = SeqXPos(X)
            End If

        ElseIf Outside(X) = 1 Then

            If SeqXPos(X) > MPosO Then
                MPosO = SeqXPos(X)
            End If

        End If

    Next 'X

    If SeqXPos(Outie) > MPosO Then
        MPosO = SeqXPos(Outie)
        OutFlag = 2
    Else
        OutFlag = 1
    End If

    OutsideAdjust = (MPosI - MPosO) / 2
    OutsideAdjust = 0
    Lowest = 100
    NodeXPos(NextNo + 1) = NodeXPos(0)

    For X = 0 To NumberOfSeqs

        If NodeDepth(X, 0) > -1 Then

            If Outside(NodeDepth(X, 0)) <> OutFlag Then
                NodeXPos(X) = NodeXPos(X) - OutsideAdjust
            Else
                NodeXPos(X) = NodeXPos(X) + OutsideAdjust
            End If

            If NodeXPos(X) < Lowest Then Lowest = NodeXPos(X)
        End If

    Next 'X

    For X = 0 To NumberOfSeqs

        If Outside(X) <> OutFlag Then
            SeqXPos(X) = SeqXPos(X) - OutsideAdjust
        Else
            SeqXPos(X) = SeqXPos(X) + OutsideAdjust
        End If

        If SeqXPos(X) < Lowest Then Lowest = SeqXPos(X)
    Next 'X

    If Lowest < 0 Then
        TotalAdjust = -Lowest

        For X = 1 To NumberOfSeqs
            NodeXPos(X) = NodeXPos(X) + TotalAdjust
        Next 'X

        For X = 0 To NumberOfSeqs
            SeqXPos(X) = SeqXPos(X) + TotalAdjust
            NameXPos(X) = NameXPos(X) + TotalAdjust
        Next 'X

    ElseIf X = X Then
        TotalAdjust = 1
        For X = 0 To NumberOfSeqs
            NodeXPos(X) = NodeXPos(X) - Lowest
        Next 'X

        For X = 0 To NumberOfSeqs
            SeqXPos(X) = SeqXPos(X) - Lowest
            NameXPos(X) = NameXPos(X) - Lowest
        Next 'X
    End If

    MaxXPos = 0

    For X = 0 To NumberOfSeqs

        If SeqXPos(X) > MaxXPos Then MaxXPos = SeqXPos(X)
    Next 'X

    ReDim NameWidth(NumberOfSeqs)
    If MaxXPos = 0 Then
        Form2.Picture2(0).Enabled = True
        Form2.Picture2(1).Enabled = True
        Form2.Picture2(2).Enabled = True
        Form2.Picture2(3).Enabled = True
        Exit Sub
    End If
    DrawXAdjust = (Form1.Picture16.ScaleWidth - 70) / (MaxXPos)
    DrawYAdjust = 14
    
    ReDim NodePath(NumberOfSeqs + 1, NumberOfSeqs + 1)

    For X = 0 To NumberOfSeqs

        For Y = 0 To NumberOfSeqs
            NodePath(X, Y) = -1
            SNodePath(NHFlag, X, Y) = -1
        Next 'Y

    Next 'X
    
    ReDim CxAdd(NumberOfSeqs)

    For X = 0 To NumberOfSeqs
        
        For Y = 0 To NumberOfSeqs

            If NodeDepth(X, Y) = -1 Then Exit For
            'If DoneLine(NodeDepth(X, Y), CxAdd(NodeDepth(X, Y))) = 0 Then
                NodePath(NodeDepth(X, Y), CxAdd(NodeDepth(X, Y))) = X
            '    DoneLine(NodeDepth(X, Y), CxAdd(NodeDepth(X, Y))) = 1
            'Else
            '    X = X
            'End If
            
            CxAdd(NodeDepth(X, Y)) = CxAdd(NodeDepth(X, Y)) + 1
        Next 'Y

    Next 'X

    
    If TBSReps < 2 Then

        If TBSReps < 2 And (NJF = 1 Or NJF = 2) Then
            Form1.ProgressBar1.Value = 90
            Form2.ProgressBar1.Value = 90
        Else
            Form2.ProgressBar1.Value = 99
            Form1.ProgressBar1.Value = 99
        End If
        'Dim DXY(numberofseqs, numberofseqs)
        
        'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=string,1 = line,2 = box)
        'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
        'E = element number
        
        ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
        
        A = -1: B = -1
        For X = 0 To NumberOfSeqs - 1
'XX = TYF2
            For Y = 0 To NumberOfSeqs - 2

                If NodePath(X, Y + 1) > -1 Then
                    If DoneLine(NodePath(X, Y), NodePath(X, Y + 1)) = 0 Then
                        DoneLine(NodePath(X, Y), NodePath(X, Y + 1)) = 1
                        A = A + 1
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                        A = A + 1
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y + 1)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                    
                    Else
                        X = X
                    End If
                ElseIf NodePath(X, Y) > -1 Then
                    A = A + 1
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y)) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(X) * DrawYAdjust
                    A = A + 1
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + SeqYPos(X) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + SeqXPos(X) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(X) * DrawYAdjust
                    
                    XCord(NJF, F2TreeIndex, X) = NameXPos(X) * DrawXAdjust + 15 + 1
                    YCord(NJF, F2TreeIndex, X) = (SeqYPos(X) * DrawYAdjust + 4)
                    RYCord(NJF, F2TreeIndex, SeqYPos(X)) = X
                    
                    B = B + 1
                    TreeDraw(F2TreeIndex, NJF, 0, 0, B) = XCord(NJF, F2TreeIndex, X)
                    TreeDraw(F2TreeIndex, NJF, 0, 1, B) = YCord(NJF, F2TreeIndex, X)
                    TreeDraw(F2TreeIndex, NJF, 0, 2, B) = X
                    TreeDraw(F2TreeIndex, NJF, 0, 3, B) = -1
                    Exit For
                End If

            Next 'Y

        Next 'X

        
        Form1.Picture16.FontSize = 8.25
        ScaleValD = 0.1

        If ScaleValD * DrawXAdjust > Form1.Picture16.ScaleWidth / 2 Then

            Do While ScaleValD * DrawXAdjust > Form1.Picture16.ScaleWidth / 2
                ScaleValD = ScaleValD / 2
            Loop

        End If
        
        A = A + 1
        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 5
        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = ((NextNo + 2) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = (NextNo + 2) * DrawYAdjust
        
        ScaleVal = ScaleValD
        ScaleSize = Form1.Picture16.TextWidth(ScaleVal)
        
        B = B + 1
        TreeDraw(F2TreeIndex, NJF, 0, 0, B) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
        TreeDraw(F2TreeIndex, NJF, 0, 1, B) = (NextNo + 2.5) * DrawYAdjust
        TreeDraw(F2TreeIndex, NJF, 0, 2, B) = -1
        TreeDraw(F2TreeIndex, NJF, 0, 3, B) = -ScaleValD * 10000
        
    ElseIf TBSReps > 1 And NJF = 2 Then 'if necessary do BS replicates for fitch trees
        Form1.ProgressBar1.Value = 20
        Form2.ProgressBar1.Value = 20
        On Error Resume Next
        Kill "infile"

        
        Name "outfilex2" As "infile"
        

        On Error GoTo 0
        
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '   Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, TRndSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "l"
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "m"
            Print #1, TBSReps
            Print #1, "3"
            'Print #1, j
            Print #1, "2"
            Print #1, "3"
            Print #1, "y"
        

        Close #1
        
        

        If AbortFlag = 1 Then
            Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            ChDir ODir
            ChDrive ODir
            Exit Sub
        End If

        BatIndex = 0
        Form1.ProgressBar1.Value = 60
        Form2.ProgressBar1.Value = 60
        Form1.SSPanel1.Caption = "Drawing Trees"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        PBStart = Form1.ProgressBar1.Value
        PBTarget = 90
        BatIndex = 6
       ' Do
        ShellAndClose "neighbor.bat", 0
        
    
        If AbortFlag = 1 Then
              Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            ChDir ODir
            ChDrive ODir
            Exit Sub
        End If

        On Error Resume Next
        Kill "infile"
        Name "outtree" As "infile"
        On Error GoTo 0
        X = X
    End If
    
    If (NJF = 1 Or NJF = 2 Or NJF = 3) And TBSReps > 2 Then
        'find the outgroup position in tree 0
        
        'THIS SHOULD ALWAYS BE NEXTNO+1 IF INITIAL OUTGROUPING WAS MADE
    
         
        'Pos = InStr(1, NHString(NHFlag), "S", vbBinaryCompare)
        'LastPos = Pos + 1
        
        
        
        'NLen = CInt(Log10(Nextno + 1)) + 1
        'numb = 0
        'Do While Pos > 0
        '    xxxx = Mid$(NHString(NHFlag), Pos + 1, NLen)
        '    If Val(Mid$(NHString(NHFlag), Pos + 1, NLen)) = Outie Then
        '        toutie = numb + 1
        '        Exit Do
         '   Else
        '        numb = numb + 1
        '    End If
        '    Pos = InStr(LastPos, NHString(NHFlag), "S", vbBinaryCompare)
        '    'Exit Sub
        '    LastPos = Pos + 1
        '
        '
        'Loop
        toutie = NextNo + 1
                
        Form1.SSPanel1.Caption = "Making Consensus"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        'Do
        ShellAndClose "consense.bat", 0
'Loop
        If AbortFlag = 1 Then
            Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            ChDir ODir
            ChDrive ODir
            Exit Sub
        End If

        Form1.ProgressBar1.Value = 95
        Form2.ProgressBar1.Value = 95
        'Open treefile and read in the tree and bootstrap values.
        If NJF = 2 Or NJF = 1 Then
            Call ReadTreeFile("treefile", GetString, TreeByte())
        
        
            Call MakeBootDepth(TBSReps, NumberOfSeqs, GetString, LLen(), BootDepth(), TreeByte())

            Call MakeDLen(NumberOfSeqs - 1, DLen(), LLen(), NodeDepth(), BootDepth())
            totbs = 0
            XX = UBound(DLen, 1)
            For X = 0 To XX
                totbs = totbs + DLen(X) '11210,11355,11420,11525,11715,11790,12045
                '14660
                '38.177
                '11835
                '27.14
            Next X
            OldBoot = totbs
            XX = (totbs / NumberOfSeqs) '28.817,29.27,29.51,29.857, 30.428, 30.703,31.53
        Else
            For X = 0 To NumberOfSeqs
                DLen(X) = (DLen(X) / TBSReps) * 100
            Next X
        End If
        'DLen(1) = 50
        Dim LastOpen As Long, LastX As Long
        
        
        'Add in bootstrap replicates for NJ and LS trees
        If NJF = 1 Or NJF = 2 Then
            Do
                LastOpen = 0
    
                For X = 0 To NumberOfSeqs
    
                    If PNodeStr(X) > LastOpen Then
                        LastOpen = PNodeStr(X)
                        LastX = X
                    End If
    
                Next 'X
    
                If LastOpen > 0 Then
    
                    If DLen(LastX) > 0 Then
                        NHString(NHFlag) = left$(NHString(NHFlag), LastOpen) + Trim$(CStr(DLen(LastX))) + right$(NHString(NHFlag), Len(NHString(NHFlag)) - (LastOpen))
                    End If
                    PNodeStr(LastX) = -1
                Else
                    Exit Do
                End If
    
            Loop
            
            
    
            'Replace token names
            'If NJF = 1 Then
                Call ReplaceNames(NHFlag, NJF, NumberOfSeqs, NHString())
            'End If
        End If
        

        
        
        Form1.ProgressBar1.Value = 100
        Form2.ProgressBar1.Value = 100
        
        
        
        
        
       'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=sequencename,1 = line)
        'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = bs value)
        'E = element number
        
        ReDim DoneLine(NextNo, NextNo)
        A = -1: B = -1
        For X = 0 To NumberOfSeqs - 1
'XX = TYF2
            For Y = 0 To NumberOfSeqs - 2

                If NodePath(X, Y + 1) > -1 Then
                    If DoneLine(NodePath(X, Y), NodePath(X, Y + 1)) = 0 Then
                        DoneLine(NodePath(X, Y), NodePath(X, Y + 1)) = 1
                        A = A + 1
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                        A = A + 1
                        If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 3, 1, 3, UBound(TreeDraw, 5) + NextNo)
                        End If
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y + 1)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(X, Y + 1)) * DrawYAdjust
                    
                    Else
                        X = X
                    End If
                ElseIf NodePath(X, Y) > -1 Then
                    A = A + 1
                    'XX = UBound(TreeDraw, 5)
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(X, Y)) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(X) * DrawYAdjust
                    
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 3, 1, 3, UBound(TreeDraw, 5) + NextNo)
                        End If
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(X, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + SeqYPos(X) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + SeqXPos(X) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(X) * DrawYAdjust
                    
                    XCord(NJF, F2TreeIndex, X) = NameXPos(X) * DrawXAdjust + 15 + 1
                    YCord(NJF, F2TreeIndex, X) = (SeqYPos(X) * DrawYAdjust + 4)
                    RYCord(NJF, F2TreeIndex, SeqYPos(X)) = X
                    
                    
                    B = B + 1
                    TreeDraw(F2TreeIndex, NJF, 0, 0, B) = XCord(NJF, F2TreeIndex, X)
                    TreeDraw(F2TreeIndex, NJF, 0, 1, B) = YCord(NJF, F2TreeIndex, X)
                    TreeDraw(F2TreeIndex, NJF, 0, 2, B) = X
                    TreeDraw(F2TreeIndex, NJF, 0, 3, B) = -1

                    Exit For
                End If

            Next 'Y

        Next 'X


        For X = 1 To NumberOfSeqs - 2

            If DLen(X) > 0 Then
                
                B = B + 1
                TreeDraw(F2TreeIndex, NJF, 0, 0, B) = NodeXPos(X) * DrawXAdjust + 10
                TreeDraw(F2TreeIndex, NJF, 0, 1, B) = (NodeYPos(X) * DrawYAdjust + 3 + 3)
                TreeDraw(F2TreeIndex, NJF, 0, 2, B) = -1
                TreeDraw(F2TreeIndex, NJF, 0, 3, B) = DLen(X)
                
            End If

        Next 'X

        Form1.Picture16.FontSize = 8.25
        
        ScaleValD = 0.1
        
        If ScaleValD * DrawXAdjust > Form1.Picture16.ScaleWidth / 2 Then

            Do While ScaleValD * DrawXAdjust > Form1.Picture16.ScaleWidth / 2
                ScaleValD = ScaleValD / 2
            Loop

        End If

        
        A = A + 1
        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 5
        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = ((NextNo + 2) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = (NextNo + 2) * DrawYAdjust
        
        ScaleVal = ScaleValD
        ScaleSize = Form1.Picture16.TextWidth(ScaleVal)
        
        B = B + 1
        TreeDraw(F2TreeIndex, NJF, 0, 0, B) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
        TreeDraw(F2TreeIndex, NJF, 0, 1, B) = ((NextNo + 2.5) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 0, 2, B) = -1
        TreeDraw(F2TreeIndex, NJF, 0, 3, B) = -ScaleValD * 10000
        
        Form1.ProgressBar1.Value = 0
        Form2.ProgressBar1.Value = 0
    End If 'finished replicates
    
    
    TDLen(F2TreeIndex, NJF, 1) = A
    TDLen(F2TreeIndex, NJF, 0) = B
    
    'Call Treedrawing(TreeBlocksL(), TBLLen, 0, StraiName(), 0, F2TreeIndex, NJF, TreeDraw(), TDLen(), TreeBlocks(), TBLen(), Form1.picture16)
    
    Form2.SSPanel3.Caption = ""
    Form2.ProgressBar1 = 0
    DoneTree(NJF, F2TreeIndex) = 1
    

    'Store info for making a metafile
    If NextNo > UBound(NodePath, 2) Then Call ModNextno
    For X = 0 To NextNo

        For Y = 0 To NextNo
            SNodePath(NHFlag, X, Y) = NodePath(X, Y)
        Next 'Y

        SNodeXPos(NHFlag, X) = NodeXPos(X)
        SNodeYPos(NHFlag, X) = NodeYPos(X)
        SSeqXPos(NHFlag, X) = SeqXPos(X)
        SSeqYPos(NHFlag, X) = SeqYPos(X)
        SDLen(NHFlag, X) = DLen(X)
    Next 'X
    On Error Resume Next
    ChDir ODir
    ChDrive ODir
    On Error GoTo 0
    Form2.Picture2(0).Enabled = True
    Form2.Picture2(1).Enabled = True
    Form2.Picture2(2).Enabled = True
    Form2.Picture2(3).Enabled = True
    
    Form1.SSPanel6(1).Enabled = True
    Form1.Picture16.Enabled = True
    
    Form2.Command2.Enabled = False
End Sub
Public Sub FindSeqColours()
Dim NodeCol() As Byte, DoneNode() As Byte, NodeIncriment As Long
ReDim NodeCol(NextNo * 2, 2), DoneNode(NextNo * 2)


'Start position for colours is the root node

End Sub

Public Sub MakeAncTree(NJF As Integer)
Dim th1 As Double, th2 As Double, th3 As Double
    SS = GetTickCount
    TSeqLen = Len(StrainSeq(0))
    ReDim BranchMap(NextNo * 2, 2)
    'If 1 < 1 Then 1 = 1
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NHFlag As Integer, NumberOfSeqs As Long, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim PNodeStr() As Long
    Dim LSeq As Long, A As Long, B As Long, LPos As Long, X As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim Boots() As String, MatchNode() As String
    Dim GetString As String, BootName As String, Header As String, ODir As String, TString As String
    Dim TreeByte() As Byte
    Dim DLen() As Double, NodeXPos() As Double, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Double, SeqXPos() As Double, NewFontSize As Double
    Dim MPosO As Double, Lowest As Double, OldFontSize As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim MatrixByte() As Byte
    Dim MatrixLen As Long
    Dim ScaleVal As String
    Dim ScaleValD As Double
    
    Dim oRec As Long, LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Double, TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    Dim OrderArray() As Byte
    Dim T0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long

    ReDim PNodeStr(NextNo * 2)
    ReDim DLen(NextNo)
    LSeq = TSeqLen


    NumberOfSeqs = NextNo
    Form1.Picture16.FontSize = 8.25

    If 1 = 0 And (NJF = 1 Or NJF = 2) Then
    
        Form1.ProgressBar1.Value = 10
        Form2.ProgressBar1.Value = 10
    Else
        Form2.ProgressBar1.Value = 5
        Form1.ProgressBar1.Value = 5
    End If

    Form2.Command2.Enabled = True
    'Sort out directory locations
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    'Clean up files
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    On Error GoTo 0
    ReDim Boots(NextNo + 2)
    'Set up copies of sequences that can be edited and rearranged etc
    'Set up batch files

    
    If NJF = 3 Then 'ML trees
        Open "dnadist.bat" For Output As #1
        Print #1, "fastdnaml <infile"
        'Print #1, "fastdnaml <optfile"
        'Print #1, "dnaml <optfile"
        Print #1, "del treefile"
        Print #1, "rename treefile.0 treefile "
        Close #1
    End If
    
    If NJF = 3 Then
        'Do FastDNAML options file
        If Len(TempSeq(0)) > 32000 Then

            For X = 0 To NextNo
                TempSeq(X) = left$(TempSeq(X), 32000)
            Next 'X

        End If

        Open "infile" For Output As #1
        Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
        Header = Header + " T O"

        If TBaseFreqFlag = 1 Then
            Header = Header + " F"
        End If

        If TGRFlag = 1 Then
            Header = Header + " G"
        End If

        If TRndIOrderFlag = 1 Then
            Header = Header + " J"
        End If

        If 1 > 1 Then
            Header = Header + " B"
        End If

        If TBaseFreqFlag = 1 Then
            Header = Header + " F"
        End If

        Header = Header + " Q 4 Y"
        Print #1, Header
        Print #1, "O " & CStr(Outie + 1)

        If TBaseFreqFlag = 1 Then
            Print #1, "F " & TAfreq & " " & TCFreq & " " & TGFreq & " " & TTFreq
        End If

        If TRndIOrderFlag = 1 Then
            Print #1, "J " + Trim$(CStr(TRndSeed))
        End If

        If 1 > 1 Then
            Print #1, "B " + Trim$(CStr(TRndSeed))
        End If

        Print #1, "T " + Trim$(CStr(TTVRat))

        For X = 0 To NumberOfSeqs
            BootName = "S" & X
            BootName = BootName + String$(10 - (Len(BootName)), " ")
            TString = TempSeq(X)
            Boots(X) = BootName + TString
            Print #1, Boots(X)
        Next 'X

        'Set up the initial infile
        Close #1
        BatIndex = 4
        PBStart = Form1.ProgressBar1.Value
        PBTarget = 95
        Form1.SSPanel1.Caption = "Drawing ML Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    End If
Dim LS As Long
LS = TSeqLen
    'Calculate distance matrices
    If NJF = 1 Or NJF = 2 Then
        
        
        ReDim xx1(3)
        ReDim xx2(3)
        ReDim Prod1(LS)
        ReDim Prod2(LS)
        ReDim Prod3(LS)
        ReDim Alias(LS)
        ReDim Ally(LS)
        ReDim Location(LS)
        ReDim Px(NextNo, LS)
        ReDim ttSeqNum(LS, NextNo)
        ReDim DstMat(NextNo, NextNo)
        ReDim DistVal(1 + 1)
        ReDim Num1(1 + 1)
        ReDim Num2(1 + 1)
        ReDim DEN(1 + 1)
        ReDim Num(1 + 1)
        ReDim WeightMod(1, LS - 1)
        ReDim tMat(NextNo, NextNo)
        ReDim SHolder((NextNo + 1) * 40 * 2)
        ReDim Scratch(LS)
        ReDim Weight(1, LS)
            For X = 0 To LS - 1
                WeightMod(0, X) = 1
            Next X
        Dim SeqScores() As Double
        ReDim SeqScores(NextNo)
        Dim MaxDScore As Double
        MaxDScore = 0
        If TModel <> 3 Then
            Form1.SSPanel1.Caption = "Calculating distances"
            Form2.SSPanel3.Caption = "Calculating distances"
            Form1.ProgressBar1 = 20
            Form2.ProgressBar1 = 20
            'Dim Tmat3() As Double
            'ReDim Tmat3(1, Nextno, Nextno)
            'BootDist 1, TCoeffVar, TTVRat, TModel, Nextno + 1, LS, SeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), Tmat3(0, 0, 0), DistVal(0), Num1(0), Num2(0), Den(0), Num(0), WeightMod(0, 0)
            
            For X = 0 To NextNo
                DstMat(X, X) = 0
                For Y = X + 1 To NextNo
                    
                    If PermValid(X, Y) > 0 Then
                        th2 = PermValid(X, Y) - PermDiffs(X, Y)
                        th1 = th2 / PermValid(X, Y)
                        
                        If th1 > 0.25 Then
                            th2 = (4# * th1 - 1#) / 3#
                            th3 = Log(th2)
                            DstMat(X, Y) = -0.75 * th3
                        Else
                            DstMat(X, Y) = 10#
                        End If
                    
                    Else
                        DstMat(X, Y) = 10#
                        
                    End If
                    DstMat(Y, X) = DstMat(X, Y)
                    
                Next Y
            Next X
            
            'For X = 0 To Nextno
            '    For Y = 0 To Nextno
            '        If CLng(DstMat(X, Y) * 1000000) <> CLng(Tmat3(0, X, Y) * 1000000) Then
            '            X = X
            '        End If
            '    Next Y
            'Next X
            Form1.SSPanel1.Caption = "Drawing trees"
            Form2.SSPanel3.Caption = "Drawing trees"
            Form1.ProgressBar1 = 60
            Form2.ProgressBar1 = 60
            
            For X = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(X) = SeqScores(X) + DstMat(X, Y)
                Next Y
            Next X
            
            For X = 0 To NextNo
                If SeqScores(X) > MaxDScore Then
                    Outie = X
                    MaxDScore = SeqScores(X)
                End If
            Next X
            
        Else
            
                ReDim Weight(BSBootReps, BSStepWin)
                Dummy = DNADIST(TCoeffVar, TTVRat, TBaseFreqFlag, TModel, TAfreq, TCFreq, TGFreq, TTFreq, NextNo + 1, TSeqLen, SeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0))
                
                

            
            For X = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(X) = SeqScores(X) + DstMat(X, Y)
                Next Y
            Next X
            
            For X = 0 To NextNo
                If SeqScores(X) > MaxDScore Then
                    MaxDScore = SeqScores(X)
                    Outie = X
                End If
            Next X
        End If
        
        If NJF = 1 Then
            Dim TreeString As String
            ReDim PermDist(NextNo, NextNo)
            ReDim SHolder((NextNo + 1) * 40 * 2)
            
            
                For Y = 0 To NextNo
                    For Z = 0 To NextNo
                        PermDist(Y, Z) = DstMat(Y, Z)
                        PermDist(Z, Y) = PermDist(Y, Z)
                    Next 'Z
                    
                Next 'Y
                ReDim ColTotals(NextNo)
                Dim TreeArray() As Double
                ReDim TreeArray(NextNo, NextNo)
                LTree = NEIGHBOUR(1, 0, TRndSeed, Outie + 1, NextNo + 1, PermDist(0, 0), SHolder(0), ColTotals(NextNo), TreeArray(0, 0))
                'byte array to string
                
                TreeString = ""
                For Y = 1 To LTree
                    TreeString = TreeString + Chr$(SHolder(Y))
                Next Y
                If X = X Then
                    GetString = TreeString
                    NHString(NHFlag) = GetString
                    ReDim TreeByte(LTree)
                    For Y = 1 To LTree
                        TreeByte(Y - 1) = SHolder(Y)
                    Next Y
                End If
            
            If 1 > 1 Then
                Close #1
            End If
            'Exit Sub
        Else
            Open "outfilex2" For Output As #1
            Open "outfilex3" For Output As #2
            For Z = 0 To 1
                If Z = 0 Then
                        Print #2, "  " & CStr(NumberOfSeqs + 1)
                End If
                Print #1, "  " & CStr(NumberOfSeqs + 1)
    
                For X = 0 To NumberOfSeqs
                    OutString = "S" & Trim$(CStr(X)) & String$(9 - Len(Trim$(CStr(X))), " ")
                    
                    For Y = 0 To NumberOfSeqs
            
                        If DstMat(Z, X, Y) = 0 Then
                            OutString = OutString & "  0.0000"
                        ElseIf DstMat(Z, X, Y) = 1 Then
                            OutString = OutString & "  1.0000"
                        ElseIf DstMat(Z, X, Y) > 1 Then
                            OutString = OutString & "  " & Int(DstMat(Z, X, Y) * 10000) / 10000 '& String$((6 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        Else
                            OutString = OutString & "  " & Int(DstMat(Z, X, Y) * 10000) / 10000 '& String$((5 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        End If
            
                    Next 'Y
                    If Z = 0 Then
                        Print #2, OutString
                    End If
                    Print #1, OutString
                Next 'X
            Next 'Z
            Close #2
            Close #1
        End If
        
    Else
        ShellAndClose "dnadist.bat", 0
    End If
    
    If AbortFlag = 1 Then
        ChDir ODir
        ChDrive ODir
        Exit Sub
    End If

    If 1 < 2 And (NJF = 1 Or NJF = 2) Then
        Form1.ProgressBar1.Value = 60
        Form2.ProgressBar1.Value = 60
    ElseIf NJF = 1 Or NJF = 2 Then
        Form2.ProgressBar1.Value = 10
        Form1.ProgressBar1.Value = 10
    End If

    If NJF = 2 Then
        On Error Resume Next
        Kill "infilex"
        On Error GoTo 0
        'AbortFlag = 1
        'Exit Sub

        
            Name "outfilex3" As "infile"
        

        'Make the NEIGHBOR optfile
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '    Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, TRndSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "2"
            'Print #1, "3"
            Print #1, "y"
        

        Close #1
        Form1.SSPanel1.Caption = "Drawing Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        
        Open "neighbor.bat" For Output As #1
        Print #1, "fitch <optfilen"
        Print #1, "rename outfile outfilex"
        Close #1
        
        
        ShellAndClose "neighbor.bat", 0
        'AbortFlag = 1

        If AbortFlag = 1 Then
            ChDir ODir
            ChDrive ODir
            Exit Sub
        End If

    End If
    If NJF = 2 Or NJF = 3 Then
    'Open treefile and read in the tree.
        Open "treefile" For Binary Access Read As #1
    
        'Open space for the entire treefile (Both a string and a byte array)
        GetString = String$(LOF(1), " ")
        ReDim TreeByte(LOF(1))
        Get #1, 1, GetString
        Get #1, 1, TreeByte()
        Close #1
        NHString(NHFlag) = GetString
    End If
    LPos = 0
    LPos = 0
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)

    For X = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(X, Y) = -1
        Next 'Y

    Next 'X

    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    Dim XNo As Long, YNo As Long, ZNo As Long, lZNo As Long, mZNo As Long
    'dim NodeNo
    ZNo = NextNo + 1
    
    For X = 0 To NextNo * 2
        BranchMap(X, 0) = -1
        BranchMap(X, 1) = -1
        BranchMap(X, 2) = -1
    Next X
    BranchMap(NextNo + 2, 0) = NextNo + 1
    Do While LPos < Len(GetString)
        mZNo = 0
        lZNo = 0
        ZNo = NextNo + 1
        If TreeByte(LPos - 1) = 40 Then '(
            'find the matching )
            
            If CCount > -1 Then
                lZNo = ZNo
                If ZNo + 1 <= mZNo Then
                    ZNo = mZNo + 1
                Else
                    ZNo = ZNo + 1
                End If
                mZNo = ZNo
                If BranchMap(ZNo, 0) = -1 Then
                    BranchMap(ZNo, 0) = lZNo
                End If
            End If
            
            CCount = CCount + 1
            
            DCount = 1
            SCount = 0
            TPos = LPos + 1

            Do

                If TreeByte(TPos - 1) = 40 Then '(
                    DCount = DCount + 1
                    lZNo = ZNo
                    If ZNo + 1 <= mZNo Then
                        ZNo = mZNo + 1
                    Else
                        ZNo = ZNo + 1
                    End If
                    
                    mZNo = ZNo
                    If BranchMap(ZNo, 0) = -1 Then
                        BranchMap(ZNo, 0) = lZNo
                    End If
                    If lZNo > -1 Then
                        If BranchMap(lZNo, 1) = -1 And BranchMap(lZNo, 2) <> ZNo Then
                            BranchMap(lZNo, 1) = ZNo
                        ElseIf BranchMap(lZNo, 2) = -1 And BranchMap(lZNo, 1) <> ZNo Then
                            BranchMap(lZNo, 2) = ZNo
                        End If
                    End If
                ElseIf TreeByte(TPos - 1) = 41 Then ')
                    
                    
                    If ZNo > -1 Then
                        If BranchMap(ZNo, 2) = -1 Then
                            BranchMap(ZNo, 2) = lZNo
                        'ElseIf BranchMap(ZNo, 1) = -1 Then
                        '    BranchMap(ZNo, 1) = lZNo
                        End If
                        lZNo = ZNo
                        ZNo = BranchMap(ZNo, 0)
                        
                   
                    End If
                    DCount = DCount - 1

                    If DCount = 0 Then

                        If TreeByte(TPos) = 58 Then ':

                            If TreeByte(TPos + 1) = 45 Then '-

                                If NJF = 3 Then
                                    LLen(CCount) = Val(Mid$(GetString, TPos + 2, 10))
                                Else
                                    LLen(CCount) = Val(Mid$(GetString, TPos + 2, 8))
                                End If

                                PNodeStr(CCount) = TPos
                            Else

                                If NJF = 3 Then
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 9))
                                Else
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 7))
                                End If

                                PNodeStr(CCount) = TPos
                            End If

                        Else
                            LLen(CCount) = 0
                            PNodeStr(CCount) = TPos
                        End If

                        Exit Do
                    End If

                ElseIf TreeByte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                    
                    PosP = InStr(TPos, GetString, ":", vbBinaryCompare)
                    CSeq = Val(Mid$(GetString, TPos + 1, PosP - TPos - 1))
                    If ZNo > -1 Then
                        If BranchMap(CSeq, 0) = -1 Then
                            BranchMap(CSeq, 0) = ZNo
                        End If
                    
                        If BranchMap(ZNo, 1) = -1 And BranchMap(ZNo, 2) <> CSeq Then
                            BranchMap(ZNo, 1) = CSeq
                        ElseIf BranchMap(ZNo, 2) = -1 And BranchMap(ZNo, 1) <> CSeq Then
                            BranchMap(ZNo, 2) = CSeq
                        End If
                    Else
                        
                    End If
                    NodeDepth(CCount, SCount) = CSeq
                    SCount = SCount + 1

                    If Done(CSeq) = 0 Then
                        Done(CSeq) = 1

                        If TreeByte(PosP) = 45 Then  '-

                            If NJF = 3 Then
                                SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 10))
                            Else
                                SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                            End If

                        Else

                            If NJF = 3 Then
                                SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 9))
                            Else
                                SeqXPos(CSeq) = Val(Mid$(GetString, PosP + 1, 7))
                            End If

                        End If

                    End If

                End If

                TPos = TPos + 1
            Loop

        End If

        LPos = LPos + 1
        
    Loop
    
    BranchMap(NextNo + 1, 0) = Outie 'This is a big problem
    
    'Find midpoint between the two largest distances in the tree
    
    Dim NLen() As Double, DoneSeq() As Long, TallyDist As Double
    ReDim NLen(NextNo * 2 + 1)
    
    For X = 0 To NextNo
        NLen(X) = SeqXPos(X)
        NLen(X + NextNo + 1) = LLen(X)
    Next X
    
    ReDim TMat2(NextNo * 2, NextNo * 2)
    ReDim DoneSeq(NextNo * 2)
    
    
    'Store Unrooted Branchmap in BranchmapX - Branchmap is used to store the rooted Branchmap
    ReDim BranchMapX(NextNo * 2, 2)
    For X = 0 To NextNo * 2
        For Y = 0 To 2
            BranchMapX(X, Y) = BranchMap(X, Y)
        Next Y
    Next X
    
    
    'Make an MRCA list - it must be remade later to take account of the reorganisd
    'branchmap
    Dim Path() As Long, DonePath() As Long
    Dim StartP As Long
    Dim CurPos As Long, CurPosB As Long
    ReDim Path(NextNo)
    ReDim DonePath(NextNo * 2)
    Outie = Outie
    'Work out the order of the read.
    CurPos = 0
    Dim TopNode() As Integer
    ReDim TopNode(NextNo * 2)
    'Initialise array
    For X = 0 To NextNo
        TopNode(X) = -1
        For Y = 0 To NextNo - 1
            Path(X) = -1
        Next Y
    Next X
    
    Dim backup() As Long
    
    ReDim backup(NextNo)
    CurPos = 0
    Dim MRCAMat() As Long
    ReDim MRCAMat(NextNo * 2, NextNo * 2)

    For X = NextNo To NextNo * 2
        
        'BranchMap(X, 0) = BranchMap(X, 0)
        If DonePath(X) = 0 And BranchMap(X, 1) > -1 And BranchMap(X, 2) > -1 Then
            If TopNode(BranchMap(X, 1)) = -1 And TopNode(BranchMap(X, 2)) = -1 Then
                MRCAMat(BranchMap(X, 1), BranchMap(X, 2)) = X
                MRCAMat(BranchMap(X, 2), BranchMap(X, 1)) = X
                Path(CurPos) = X
                CurPos = CurPos + 1
                TopNode(X) = -1
                DonePath(X) = -1
                X = NextNo
            End If
         End If
    Next X
    
    For X = NextNo + 1 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(X, Y) > 0 Then
                MRCAMat(BranchMap(X, 1), Y) = MRCAMat(X, Y)
                MRCAMat(Y, BranchMap(X, 1)) = MRCAMat(X, Y)
                MRCAMat(BranchMap(X, 2), Y) = MRCAMat(X, Y)
                MRCAMat(Y, BranchMap(X, 2)) = MRCAMat(X, Y)
                MRCAMat(X, Y) = 0
                MRCAMat(Y, X) = 0
                'BranchMap(X, 0) = BranchMap(X, 0)
                'X = Nextno
                If BranchMap(X, 2) < BranchMap(X, 1) And BranchMap(X, 2) > NextNo Then
                    If BranchMap(X, 2) < X Then
                        X = BranchMap(X, 2) - 1
                    Else
                        X = X - 1
                    End If
                ElseIf BranchMap(X, 1) > NextNo Then
                    If BranchMap(X, 1) < X Then
                        X = BranchMap(X, 1) - 1
                    Else
                        X = X - 1
                    End If
                Else
                    If BranchMap(X, 2) <= NextNo Or BranchMap(X, 1) <= NextNo Then
                        'X = Nextno
                        X = X - 1
                    Else
                        X = X - 1
                    End If
                End If
                'X = Nextno
                Exit For
                'mrcamat(branchmap(mrcamat(x,1)),y)=
            End If
        Next Y
        X = X
    Next X
    For X = 0 To NextNo
        If X <> Outie Then
            MRCAMat(Outie, X) = NextNo + 1
            MRCAMat(X, Outie) = NextNo + 1
        End If
    Next X
    'For X = 0 To Nextno * 2
    '    For Y = X + 1 To Nextno * 2
    '        MRCAMat(X, Y) = MRCAMat(X, Y)
    '    Next Y
    'Next X
    'find midpoint of the tree
    
    'Work out distances between seqs and nodes on the way to the provisional root (outie)
    For X = 0 To NextNo
        CPos = X
        TallyDist = 0
        Do
            TallyDist = TallyDist + NLen(CPos)
            TMat2(X, BranchMap(CPos, 0)) = TallyDist
            
            CPos = BranchMap(CPos, 0)
            If CPos <= NextNo Then Exit Do
        Loop
    Next X
    'calculate distances and find the max
    Dim HiDist As Double, WinPair(1) As Long, MiDDist As Double
    HiDist = 0
    For X = 0 To NextNo
        For Y = X + 1 To NextNo
            MRCA = MRCAMat(X, Y)
            TMat2(X, Y) = TMat2(X, MRCA) + TMat2(Y, MRCA)
            If TMat2(X, Y) > HiDist Then
                WinPair(0) = X
                WinPair(1) = Y
                HiDist = TMat2(X, Y)
            End If
            X = X
        Next Y
    Next X
    
    'find branch midway between the two most distant sequences
    MiDDist = HiDist / 2
    
    
    Dim WinBranch(1)
    
    GoOn = 1
    For X = 0 To 1
        
        CPos = BranchMap(WinPair(X), 0)
        LPos = WinPair(X)
        TallyDist = 0
        TallyDist = TallyDist + NLen(LPos)
        If GoOn = 1 Then
            Do
                If TallyDist > MiDDist Then
                    WinBranch(0) = LPos
                    WinBranch(1) = CPos
                    GoOn = 0
                    Exit Do
                End If
                If CPos = NextNo + 1 Then
                    GoOn = 1
                    Exit Do
                End If
                LPos = CPos
                CPos = BranchMap(CPos, 0)
                TallyDist = TallyDist + NLen(LPos)
            Loop
        End If
    Next X
    'WinBranch(1) = 13
    'WinBranch(0) = 14
    
    'reorder branchmap around the winbranch (ie midbranch)
    BranchMap(WinBranch(0), 0) = NextNo * 2
    
    For X = 0 To 2
        If BranchMap(WinBranch(1), X) = WinBranch(0) Then Exit For
    Next X
    
    ' BranchMap(WinBranch(1), 0)
    LPos = BranchMap(WinBranch(1), 0)
    BranchMap(WinBranch(1), 0) = NextNo * 2
    
    If X > 0 Then
        BranchMap(WinBranch(1), X) = LPos
    End If
    BranchMap(NextNo * 2, 1) = WinBranch(0)
    BranchMap(NextNo * 2, 2) = WinBranch(1)
    NPos = WinBranch(1)
    CPos = LPos
    Do While CPos > NextNo + 1
        For X = 1 To 2
            If BranchMap(CPos, X) = NPos Then Exit For
        Next X
        
        LPos = BranchMap(CPos, 0)
        BranchMap(CPos, 0) = NPos
        BranchMap(CPos, X) = LPos
        NPos = CPos
        CPos = LPos
    Loop
    
    'Change old root to just another node
    LPos = BranchMap(NextNo + 1, 0)
    
    For X = 1 To 2
        If BranchMap(CPos, X) = NPos Then Exit For
    Next X
    X = X
    If X < 3 Then
        BranchMap(NextNo + 1, 0) = NPos
        BranchMap(NextNo + 1, X) = LPos
    End If
    
    
    For X = 0 To NextNo * 2
        For Y = 0 To 2
            BranchMap(X, Y) = BranchMap(X, Y)
        Next Y
    Next X
    
    
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    ChDir ODir
    ChDrive ODir
    Form1.SSPanel6(1).Enabled = True
    Form1.Picture16.Enabled = True
    
    Form2.Command2.Enabled = False
End Sub
Public Sub StartTree()
    Form1.SSPanel1.Caption = "Drawing Tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    TreeTypeFlag = 0
    Form1.Picture16.Picture = LoadPicture()
    Form1.Label14 = "UPGMA Ignoring Recombination"

    If NJFlag = 0 Or X = X Then

        Call UPGMA(0, 0)
        
        NJFlag = 1
    End If

    Form1.ProgressBar1.Value = 90
    
    
    Call DrawTree
    If RelX > 0 Or RelY > 0 Then
        Call DoTreeColour(Form1.Picture16, 0, 0)
        Call DoTreeLegend(TreeBlocksL(), TBLLen, Form1.Picture16, 0, 14)
    End If
    
    Form1.ProgressBar1.Value = 100
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    NJDrawFlag = 1
End Sub
Public Sub GCDrawC()
    'This subroutine writes the GC option file used for displaying fragments for the GC check.
    'It also begins background GC execution for this check.

    Dim X As Long, Y As Long
    Dim ODir As String, LList As String

    'Make sure we're working in the RDP root Dir
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    If GENECONVFlag = 0 Then
        Open "tf" For Output As #1
        'output in FASTA format
    
        For X = 0 To NextNo
    
            If MaskSeq(X) <= 1 Then
    
                If MaskSeq(X) = 1 Then MaskFlag = 1
                Print #1, ">" & StraiName(X)
                Print #1, StrainSeq(X)
            End If
    
        Next 'X
    
        Close #1
    End If
    GCOFile = App.Path & "\pout.frags"
    GCPOutCfg = App.Path & "\pout.cfg"
    Open "pout.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=pout"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If GCSeqTypeFlag = 0 Then
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        Print #1, "-Use_individual_indels"
    End If

    If GCCodeFlag <> 0 Then Print #1, "-Mitcodes"

    If GCMonoSiteFlag <> 0 Then Print #1, "-Include_monosites"
    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then Print #1, "-Gscale=" & GCMissmatchPen
    Print #1, "-ListGlobal=0"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v10"
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    If GCNumPerms > 0 Then
        Print #1, "-Numsim=1000"
        Print #1, "-Nomaxsimpval"

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    Else
        Print #1, "-Numsim=0"
    End If

    Print #1, "-Maxkapairwisepval=0.99999"

    If MaskFlag = 1 Then
        LList$ = ""

        For X = 0 To NextNo

            If MaskSeq(X) = 0 Then

                For Y = X + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(X) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    Close #1
    'Execute GC
    gcProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(App.Path & "\geneconv pout.cfg", 0))
    'Exit Sub
    If GCFoundSitesFlag = 0 Then
        Call GCFindSites
    End If
    ChDir ODir
    ChDrive ODir
End Sub

Public Sub GCDraw()
    Form1.Picture7.ForeColor = 0
    ReDim MCPrintData(Len(StrainSeq(0)))
    ReDim MCPrintPos(Len(StrainSeq(0)), 1)

    Dim TW As Integer
    Dim Pict As Long, CurPPos As Long, X As Long, tmp As Long, NPos As Long
    Dim Zero As String, temp As String, TargetCompare As String, TempEnd As String
    Dim COff As Double, MinPA As Double
    MinPA = 1

    If Seq1 = Seq2 Then Seq1 = Seq3
    CurPPos = 0
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture7.Height = Form1.Picture10.ScaleHeight
    Form1.Picture1.Enabled = True
    Form1.Picture7.Enabled = True
    Form1.Command29.Enabled = False

    Dim GlobalAddj As Long
    Dim Unmasked As Long

    For X = 0 To NextNo

        If MaskSeq(X) < 2 Then
            Unmasked = Unmasked + 1
        End If

    Next 'X

    GlobalAddj = (Unmasked * (Unmasked - 1) / 2)

    Dim X1 As Integer
    Dim X2 As Integer
    Dim Y1 As Integer
    Dim Y2 As Integer
    Dim Prob As Double
    Dim Beginning As Long
    Dim Ending As Long
    Dim RetVal As Long

    'Dim hProcess As Long

    Dim YScaleFactor As Double

    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    NextGCImage = NextGCImage + 1

    If NextGCImage = 11 Then NextGCImage = 1

    If Seq1 > Seq2 Then
        tmp = Seq1
        Seq1 = Seq2
        Seq2 = tmp
    End If

    If Seq1 = NextNo + 1 Then Seq1 = Seq2

    If Seq2 = NextNo + 1 Then Seq2 = Seq1
    Seq1S$ = StraiName(Seq1)
    GCImageIndex(Seq1, Seq2) = 0

    If GCImageIndex(Seq1, Seq2) = 0 Then
        GCImageIndex(Seq1, Seq2) = NextGCImage
        GCImageIndex(RevGCIndex1(NextGCImage), RevGCIndex2(NextGCImage)) = 0
        RevGCIndex1(NextGCImage) = Seq1
        RevGCIndex2(NextGCImage) = Seq2
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = -1
        Form1.Picture7.Picture = Form1.Image2(GCImageIndex(Seq1, Seq2)).Picture
        NextGCImage = NextGCImage - 1

        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            Prob = XOverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        Else
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
            Prob = XOverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
            X1 = 30 + 0 * XFactor + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            'Prob = XOverList(RelX, RelY).Probability / globaladdj
            'Prob = -log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        End If

        Form1.Picture10.Picture = LoadPicture()
        Form1.Picture10.CurrentX = 5
        Form1.Picture10.FontSize = 6
        TW = Form1.Picture7.TextWidth("-Log(KA P-Value)")
        Form1.Picture10.CurrentY = 15 + ((PicHeight - 10 - 15) + TW) / 2

        Call DoText(Form1.Picture10, Form1.Picture10.Font, "-Log(KA P-Value)", 90)

        If ORFFlag = 1 Then
            Form1.Picture20.Picture = Form1.Picture19.Image
            Form1.Picture20.Visible = True
        End If

        Exit Sub
    End If

    Form1.SSPanel1.Caption = "Executing GENECONV"

    If gcProcess > 0 Then
        Const STILL_ACTIVE = &H103

        Do
            Sleep (100)
            GetExitCodeProcess gcProcess, RetVal
        Loop While RetVal = STILL_ACTIVE

        Dummy = CloseHandle(gcProcess)
        gcProcess = 0
    End If

    MinP(Seq1, Seq2) = -1
    Open GCOFile For Binary Access Read As #1
    'Close #1
    'Open GCOFile For Binary Access Read As #1

    Dim Results As String

    Results = String$(10000, " ")

    Dim FLen As Long

    FLen = LOF(1)

    If FLen < 10000 Then Results = String$(FLen, " ")

    Dim CurrentStart As Long

    CurrentStart = 1

    Dim TargetString As String

    Do

        If CurrentStart < 1 Then CurrentStart = 1
        Get #1, CurrentStart, Results

        If XOverList(RelX, RelY).OutsideFlag <> 1 Or (Seq1 <> Seq2 And Seq1 <> NextNo + 1 And Seq2 <> NextNo + 1) Or (Seq1 <> Seq3 And Seq3 <> NextNo + 1 And Seq1 <> NextNo + 1) Or XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
            TargetString = StraiName(Seq1) + ";" + StraiName(Seq2)
            NPos = InStr(1, Results, TargetString, vbBinaryCompare)

            If NPos = 0 Then
                TargetString = StraiName(Seq2) + ";" + StraiName(Seq1)
                NPos = InStr(1, Results, TargetString, vbBinaryCompare)
            End If

        Else
            TargetString = "  " + StraiName(Seq1) + "  "
            NPos = InStr(1, Results, TargetString, vbBinaryCompare)

            If FLen > 10000 And CurrentStart = 1 Then
                NPos = InStr(NPos + 1, Results, TargetString, vbBinaryCompare)
            End If

        End If

        If NPos > 0 Then Exit Do

        If NPos = 0 And CurrentStart = FLen - 10000 Then
            Close #1
            Exit Sub
        End If

        CurrentStart = CurrentStart + 10000

        If CurrentStart + 10000 > FLen And FLen > 0 And CurrentStart - 10000 > 0 Then CurrentStart = FLen - 10000

        If FLen = 0 Then
            Close #1
            Exit Sub
        End If

    Loop

    TargetString = Trim$(TargetString)

    If NPos = 0 Then Exit Sub

    If CurrentStart <> FLen - 10000 Then
        NPos = NPos + CurrentStart - 1
    Else
        NPos = FLen - 10000 + NPos
    End If

    Close #1

    If NPos > 0 Then
        Form1.Picture7.Picture = LoadPicture()
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = -1
        Open GCOFile For Binary Access Read As #1
        Get #1, NPos - 10, temp$

        Do
            Input #1, temp$

            If left$(temp$, 2) = "PI" Or left$(temp$, 2) = "PO" Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)
                TargetCompare$ = Mid$(temp$, 1, NPos - 1)

                If TargetCompare$ <> TargetString Then Exit Do
                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                If GCNumPerms > 0 Then
                    NPos = InStr(1, temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = Val(Mid$(temp$, 1, NPos - 1))
                        temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Prob = Val(Mid$(temp$, 1, NPos - 1))

                    If Prob = 1 Then Exit Do

                    If MinP(Seq1, Seq2) = -1 Then MinP(Seq1, Seq2) = -Log10(Prob)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Beginning = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Mid$(temp$, 1, NPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            Ending = Val(Mid$(temp$, 1, NPos - 1))
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                    Else
                        Ending = Val(TempEnd$)
                    End If

                End If
                If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                        ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XOverList(RelX, RelY).Ending
                    End If

                    BT2 = XOverList(RelX, RelY).Beginning
                If Beginning < Ending Then
                    If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                        BT1 = Beginning + Len(StrainSeq(0))
                        ET1 = Ending + Len(StrainSeq(0))
                    Else
                        BT1 = Beginning
                        ET1 = Ending
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then
                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Beginning * XFactor + XFactor
                    X2 = 30 + Ending * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                Else
                    BT1 = Beginning
                    ET1 = Ending + Len(StrainSeq(0))
                    If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                        BT2 = BT2 + Len(StrainSeq(0))
                        ET2 = ET2 + Len(StrainSeq(0))
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then

                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Beginning * XFactor + XFactor
                    X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Len(StrainSeq(0))
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = 1
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    X1 = 30 + 0 * XFactor + XFactor
                    X2 = 30 + Ending * XFactor + XFactor
                    'Prob = -log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                End If
                
            ElseIf left$(temp$, Len(TargetString)) = TargetString Then
                NPos = InStr(1, temp$, " ", vbBinaryCompare)
                temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Prob = Val(Mid$(temp$, 1, NPos - 1))
                    'If Prob = 0 Then

                    If MinP(Seq1, Seq2) = -1 Then MinP(Seq1, Seq2) = -Log10(Prob)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Beginning = Val(Mid$(temp$, 1, NPos - 1))
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                End If

                NPos = InStr(1, temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Mid$(temp$, 1, NPos - 1)
                    temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            Ending = Val(Mid$(temp$, 1, NPos - 1))
                            temp$ = Trim$(Mid$(temp$, NPos, Len(temp$) - NPos + 1))
                        End If

                    ElseIf left$(TempEnd$, 2) = "CA" Then
                        'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                        Ending = Val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                    Else
                        Ending = Val(TempEnd$)
                    End If

                End If
                If XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
                    ET2 = XOverList(RelX, RelY).Ending + Len(StrainSeq(0))
                Else
                    ET2 = XOverList(RelX, RelY).Ending
                End If

                BT2 = XOverList(RelX, RelY).Beginning
                If Beginning < Ending Then
                    If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                        BT1 = Beginning + Len(StrainSeq(0))
                        ET1 = Ending + Len(StrainSeq(0))
                    Else
                        BT1 = Beginning
                        ET1 = Ending
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then
                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Beginning * XFactor + XFactor
                    X2 = 30 + Ending * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                Else
                    BT1 = Beginning
                    ET1 = Ending + Len(StrainSeq(0))
                    If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                        BT2 = BT2 + Len(StrainSeq(0))
                        ET2 = ET2 + Len(StrainSeq(0))
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then

                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Beginning * XFactor + XFactor
                    X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Len(StrainSeq(0))
                    CurPPos = CurPPos + 1
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = 1
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    X1 = 30 + 0 * XFactor + XFactor
                    X2 = 30 + Ending * XFactor + XFactor
                    'Prob = -log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                End If

            Else

                If left$(temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

        Close #1
        Form1.Picture7.Line (25, 30)-(25, PicHeight), QBColor(0)
        Form1.Picture7.Line (25, PicHeight)-(Form1.Picture7.ScaleWidth - 5, PicHeight), QBColor(0)
        Pict = Form1.Picture7.hdc
        
        Dummy = DrawDiffs(Pict, Len(GCXOverSeq(0)), XFactor, GCXDiffPos(0))
        
        'Y-Axis tick marks
        Form1.Picture7.Line (25, 35)-(28, 35), QBColor(0)
        Form1.Picture7.Line (25, PicHeight)-(28, PicHeight), QBColor(0)
        Form1.Picture7.Line (25, 35 + (PicHeight - 35) / 2)-(28, 35 + (PicHeight - 35) / 2), QBColor(0)
        'X-Axis tick marks
        Form1.Picture7.Line (30, PicHeight)-(30, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, PicHeight)-(Form1.Picture7.ScaleWidth - 10, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight + 3), QBColor(0)
        'Form1.Picture7.Line (5, 20)-(Form1.Picture7.ScaleWidth - 10, 20), QBColor(0)

        Dim XVal As String

        'Form1.Picture7.FontSize = 7
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.CurrentY = 29
        Form1.Picture7.CurrentX = 5

        Dim Outnum As Double
        Dim DecPlace As Double

        If MinP(Seq1, Seq2) < 10 Then
            DecPlace = (Int(MinP(Seq1, Seq2) * 10)) / 10
            Zero$ = " 0.0"
        ElseIf MinP(Seq1, Seq2) < 100 Then
            DecPlace = Int(MinP(Seq1, Seq2))
            Zero$ = " 0"
        Else
            DecPlace = Int(MinP(Seq1, Seq2))
            Form1.Picture7.CurrentX = 0
            Zero$ = "  0"
        End If

        MinPVal = MinP(Seq1, Seq2)
        Outnum = DecPlace
        'OutNum = (Int(MCMinChiP * 10)) / 10

        If Outnum >= 1 Then

            If Int(Outnum) <> Outnum Then
                Form1.Picture7.Print Trim$(CStr(Outnum))
            Else
                Form1.Picture7.Print Trim$(CStr(Outnum)) & ".0"
            End If

        Else
            Form1.Picture7.Print Trim$(CStr(Outnum))
        End If

        'ctmp$ = cstr(decplace)
        'Form1.Picture7.Print ctmp$
        Form1.Picture7.CurrentY = (29 + (PicHeight - 6 - 29) / 2)
        Form1.Picture7.CurrentX = 5

        If MinP(Seq1, Seq2) < 20 Then
            DecPlace = (Int((MinP(Seq1, Seq2) / 2) * 10)) / 10
        ElseIf MinP(Seq1, Seq2) < 200 Then
            DecPlace = Int(MinP(Seq1, Seq2) / 2)
        Else
            DecPlace = Int(MinP(Seq1, Seq2) / 2)
            Form1.Picture7.CurrentX = 0
        End If

        Outnum = DecPlace
        'OutNum = (Int(MCMinChiP * 10)) / 10

        If Outnum >= 1 Then

            If Int(Outnum) <> Outnum Then
                Form1.Picture7.Print Trim$(CStr(Outnum))
            Else
                Form1.Picture7.Print Trim$(CStr(Outnum)) & ".0"
            End If

        Else
            Form1.Picture7.Print Trim$(CStr(Outnum))
        End If

        'ctmp$ = cstr(OutNum)
        'Form1.Picture7.Print ctmp$
        Form1.Picture7.CurrentY = PicHeight - 6
        Form1.Picture7.CurrentX = 5
        Form1.Picture7.Print Zero$
        Form1.Picture7.CurrentY = PicHeight + 6
        Form1.Picture7.CurrentX = 29
        Form1.Picture7.Print "1"
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 4)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4 - ((Len(XVal) + 1) / 2) * 5.5
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 4)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 2)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (((Len(XVal) + 1) / 2) * 5.5)
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 2)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 1.333)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (((Len(XVal) + 1) / 2) * 5.5)
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 1.3333)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)))
        Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
        Form1.Picture7.Print Len(StrainSeq(0))
        Form1.Picture7.CurrentY = PicHeight + 15
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 10) / 2 - (21 / 2) * 5
        Form1.Picture7.Print "Position in alignment"
        'Y-axis text
        'Form1.Picture10.Enabled = True
        Form1.Picture10.Picture = LoadPicture()
        Form1.Picture10.CurrentX = 5
        Form1.Picture10.FontSize = 6
        TW = Form1.Picture7.TextWidth("Pairwise identity")
        Form1.Picture10.CurrentY = 30 + ((PicHeight - 30) + TW) / 2

        Call DoText(Form1.Picture10, Form1.Picture10.Font, "-Log(KA P-Value)", 90)

        ' cutt-off line

        If ExeCheckFlag = 0 Then

            If MCFlag = 0 Then
                COff = -Log10(LowestProb / GlobalAddj)
            Else
                COff = -Log10(LowestProb)
            End If

            Y1 = PicHeight - (0 + (COff / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Form1.Picture7.DrawStyle = 2
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            Form1.Picture7.DrawStyle = 0
            Form1.Image2(NextGCImage).Picture = Form1.Picture7.Image
        Else
            Form1.Picture7.DrawStyle = 2
            COff = -Log10(LowestProb / GlobalAddj)
            Y1 = PicHeight - (0 + (COff / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            COff = -Log10(LowestProb)
            Y1 = PicHeight - (0 + (COff / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            Form1.Picture7.DrawStyle = 0
            Form1.Image2(NextGCImage).Picture = Form1.Picture7.Image
        End If

        If XOverList(RelX, RelY).Beginning < XOverList(RelX, RelY).Ending Then
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            Prob = XOverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        Else
            X1 = 30 + XOverList(RelX, RelY).Beginning * XFactor + XFactor
            X2 = 30 + Len(StrainSeq(0)) * XFactor + XFactor
            Prob = XOverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            X1 = 30 + 0 * XFactor + XFactor
            X2 = 30 + XOverList(RelX, RelY).Ending * XFactor + XFactor
            'Prob = XOverList(RelX, RelY).Probability / globaladdj
            'Prob = -log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP(Seq1, Seq2)) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        End If

        If ORFFlag = 1 Then
            Form1.Picture20.Picture = Form1.Picture19.Image
            Form1.Picture20.Visible = True
        End If

    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    PT = 10 ^ (-ConfirmP(EN, 1))
    
    If (Confirm(EN, 1) = 0 Or (Confirm(EN, 1) = 1 And MinPA < PT)) And MinPA < 1 And XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
        Confirm(EN, 1) = 1
        ConfirmP(EN, 1) = -Log10(MinPA)
        DoEvents

        If Form1.HScroll3.Value = 0 Then
            Form1.HScroll3.Value = 1
        Else
            Form1.HScroll3.Value = 0
        End If

    End If
    If MCFlag = 0 Then

        MinPA = MinPA * MCCorrect
    End If
    ProbTest = MinPA
    ProbY = 1

    If XOverList(RelX, RelY).Ending > XOverList(RelX, RelY).Beginning Then
        ProbX = XOverList(RelX, RelY).Beginning + (XOverList(RelX, RelY).Ending - XOverList(RelX, RelY).Beginning) / 2

        If SPF = 0 Then Call PrintProbability

    Else

        If Len(StrainSeq(0)) - XOverList(RelX, RelY).Beginning > XOverList(RelX, RelY).Ending Then
            ProbX = XOverList(RelX, RelY).Beginning + (Len(StrainSeq(0)) - XOverList(RelX, RelY).Beginning) / 2

            If SPF = 0 Then Call PrintProbability

        Else
            ProbX = XOverList(RelX, RelY).Ending / 2

            If SPF = 0 Then Call PrintProbability

        End If

    End If
    
    Form1.Picture7.Top = -1
End Sub

Public Sub LoadDNAMAN1()

    Dim CurrentShortest As Integer, LenSeg As Integer, NF As Integer
    Dim LPos As Long, PosN1 As Long, PosN2 As Long, X As Long, LastPos As Long, OriginPos As Long, MaxNameLenPos As Long
    Dim EndLine As Byte
    Dim MString As String, TempSeq As String

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading DNAMan 1.0 File"
    NF = FreeFile
    LastPos = 1
    NextNo = 0
    Finnish = 0
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    OriginPos = InStr(LastPos, VarString, "ORIGIN", vbBinaryCompare)
    MaxNameLenPos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)

    If MaxNameLenPos = 0 Then MaxNameLenPos = 50000
    Pos = InStr(LastPos, VarString, "NUMBER:", vbBinaryCompare)

    If Pos > 0 Then
        NextNo = Int(CDbl(Mid$(VarString, Pos + 7, 3)))

        Call SeqArrays

        'Read the names of the sequences in the alignment
        Pos = InStr(LastPos, VarString, "NAMES: ", vbBinaryCompare)

        For X = 0 To NextNo - 1
            PosN1 = InStr(Pos, VarString, " ", vbBinaryCompare)
            PosN2 = InStr(PosN1 + 1, VarString, " ", vbBinaryCompare)

            If PosN2 > OriginPos Or PosN2 > MaxNameLenPos Then
                PosN2 = InStr(PosN1 + 1, VarString, Chr$(10), vbBinaryCompare) - 1
            End If

            If X < NextNo - 1 Then
                StraiName(X) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1) - 1)
            Else
                StraiName(X) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1))
            End If

            EndLine = Asc(right$(StraiName(X), 1))
            Pos = PosN2 - 1

            If EndLine <= 33 Then
                StraiName(X) = left$(StraiName(X), Len(StraiName(X)))
                Pos = Pos + 7
            End If

            Form1.ProgressBar1.Value = (X / (NextNo + 2) * 100) / 4
        Next 'X

        For X = 0 To NextNo - 1

            Do

                If Asc(right$(StraiName(X), 1)) < 33 Then
                    StraiName(X) = Mid$(StraiName(X), 1, Len(StraiName(X)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        Form1.ProgressBar1.Value = 20
        'Find distance from start of line to start of sequences.
        LastPos = InStr(OriginPos + 6, VarString, StraiName(0), vbBinaryCompare)
        CurrentShortest = 50
        Pos = InStr(LastPos, VarString, " A", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " a", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " C", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " c", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " G", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " g", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " T", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " t", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " .", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        CurrentShortest = CurrentShortest + 1
        Pos = InStr(LastPos + CurrentShortest + 6, VarString, "  ", vbBinaryCompare)
        LenSeg = Pos - (LastPos + CurrentShortest)

        For X = 0 To NextNo - 1
            LastPos = OriginPos

            Do
                MString = StraiName(X) + " "
                Pos = InStr(LastPos, VarString, MString, vbBinaryCompare)

                If Pos > 0 Then
                    StrainSeq(X) = StrainSeq(X) + Mid$(VarString, Pos + CurrentShortest, LenSeg)
                    LastPos = Pos + 1
                Else
                    StrainSeq(X) = UCase$(StrainSeq(X))
                    Exit Do
                End If

            Loop

        Next 'X

        For X = 0 To NextNo

            Do
                Test$ = right$(StrainSeq(X), 20)

                If right$(StrainSeq(X), 1) = Chr$(32) Then
                    StrainSeq(X) = left$(StrainSeq(X), Len(StrainSeq(X)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        NextNo = NextNo - 1
    End If

    For X = 1 To NextNo
        TempSeq = StrainSeq(0)
        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(X), "A", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = left$(TempSeq, Pos - 1) + "A" + right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "A" + right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = left$(TempSeq, Pos - 1) + "A"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(X), "C", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = left$(TempSeq, Pos - 1) + "C" + right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "C" + right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = left$(TempSeq, Pos - 1) + "C"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(X), "G", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = left$(TempSeq, Pos - 1) + "G" + right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "G" + right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = left$(TempSeq, Pos - 1) + "G"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(X), "T", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = left$(TempSeq, Pos - 1) + "T" + right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "T" + right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = left$(TempSeq, Pos - 1) + "T"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(X), ".", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = left$(TempSeq, Pos - 1) + "." + right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "." + right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = left$(TempSeq, Pos - 1) + "."
            End If

        Loop

        StrainSeq(X) = TempSeq
        Form1.ProgressBar1.Value = 25 + ((X / NextNo) * 100) * 0.75
    Next 'X

    Form1.ProgressBar1.Value = 0
    Close #NF
End Sub

Public Sub FindSubSeqAncestor()
Dim SN As Integer, PC As Integer

ReDim TreeSeqMap(Len(StrainSeq(0)), NextNo)
ReDim TreeRLen(NextNo)
For X = 0 To NextNo
    SN = 0
    For Y = 0 To NextNo
        If TreeSeqs(X, Y) <> -1 Then
            SN = SN + 1
        Else
            Exit For
        End If
    Next Y
    If SN > 2 Then
        PC = 0
        For Z = 1 To Len(StrainSeq(0))
            For Y = 1 To SN - 1
                If SeqNum(Z, TreeSeqs(X, 0)) <> SeqNum(Z, TreeSeqs(X, Y)) Then
                    PC = PC + 1
                    TreeSeqMap(PC, X) = Z
                    Exit For
                End If
            Next Y
        Next Z
        TreeRLen(X) = PC
    End If
Next X
End Sub
Public Sub LoadALI()

    Dim X As Long, NF As Integer
    Dim PosN1 As Long, PosN2 As Long, Start As Long, Finnish As Long, Pos As Long, LastPos As Long

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading ALI File"
    NF = FreeFile
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    Close #NF
    Form1.Picture3.AutoRedraw = True
    LastPos = 1
    NextNo = 0
    ReDim StrainSeq(200)
    ReDim StraiName(200)
    Finnish = 0

    Do
        Pos = InStr(LastPos, VarString, "************", vbBinaryCompare)

        If Pos > 0 Then
            PosN1 = InStr(LastPos, VarString, "nnn ", vbBinaryCompare)
            PosN2 = InStr(LastPos, VarString, " nnn", vbBinaryCompare)
            StraiName(NextNo) = Mid$(VarString, PosN1 + 4, PosN2 - PosN1 - 4)
            PosV1 = InStr(LastPos, VarString, "vvv ", vbBinaryCompare)
            Start = Pos
            LastPos = Pos + 6
            Pos = InStr(LastPos, VarString, "************", vbBinaryCompare)

            If Pos > 0 Then
                Finnish = Pos + 12
                StrainSeq(NextNo) = Mid$(VarString, Start, Finnish - Start)
                Finnish = Finnish + 2
                NextNo = NextNo + 1

                Call SeqArrays

                LastPos = Pos + 6
            End If

        Else
            NextNo = NextNo - 1
            Exit Do
        End If

    Loop

    For X = 0 To NextNo
        StrainSeq(X) = Mid$(StrainSeq(X), 13, Len(StrainSeq(X)) - 24)
    Next

    For X = 0 To NextNo

        Do

            If right$(StrainSeq(X), 1) = Chr$(32) Then
                StrainSeq(X) = left$(StrainSeq(X), Len(StrainSeq(X)) - 1)
            Else
                Exit Do
            End If

        Loop

    Next 'X

End Sub


Public Sub EMFIgnorRecomb()
    'On Error GoTo errorhandler
    'Print button click event.
    'Declare variables.
    'Set variables
    NextnoB = NextNo
    scaleaddjust = 3
    ' Exit Sub

    Dim FontSizeT As Double

    FontSizeT = 16 - (NextNo / 10)

    If FontSizeT < 4 Then FontSizeT = 4
    Form1.Picture16.Refresh
   
    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextNo)
    ReDim YPos(NextNo)

    Dim FirstPos As Double
    Dim NodeAdjust As Long
    Dim VertAddjust As Double
    Dim HorAddjust As Long

    VertAddjust = 30
    HorAddjust = 700
    'Printer.DrawWidth = 4
    NodeAdjust = HorAddjust * (0.65 / NodeLength(NextNo - 1))
    FirstPos = 0.7 * HorAddjust - 100
    'Printer.ForeColor = QBColor(0)

    Dim rct As RECT

    'Dim MhDC As Long
    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")

    Dim OldFont As Long

    OldFont = SelectObject(MhDC, LoFnt)
    
    For X = 0 To NextnoB

        If TreeX(NextnoB - 1, X) = Seq3 And RunFlag = 1 Then
            SetTextColor MhDC, RGB(255, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, StraiName(TreeX(NextNo - 1, X)), Len(StraiName(TreeX(NextNo - 1, X)))
            XPos(TreeX(NextnoB - 1, X)) = FirstPos
            YPos(TreeX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeX(NextnoB - 1, X) = Seq1 And RunFlag = 1 Then

            If OutsideFlagX = 1 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, StraiName(TreeX(NextNo - 1, X)), Len(StraiName(TreeX(NextNo - 1, X)))
            XPos(TreeX(NextnoB - 1, X)) = FirstPos
            YPos(TreeX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeX(NextnoB - 1, X) = Seq2 And RunFlag = 1 Then

            If OutsideFlagX = 2 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, StraiName(TreeX(NextNo - 1, X)), Len(StraiName(TreeX(NextNo - 1, X)))
            XPos(TreeX(NextnoB - 1, X)) = FirstPos
            YPos(TreeX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        Else
            SetTextColor MhDC, RGB(0, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, StraiName(TreeX(NextNo - 1, X)), Len(StraiName(TreeX(NextNo - 1, X)))
            XPos(TreeX(NextnoB - 1, X)) = FirstPos
            YPos(TreeX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
        End If

        '    End If
    Next 'X

    Dim FormerXPos As Double

    '************************************************************************
    '                Printer.Line (100, (NextnoB + 2) * VertAddjust)-(100 + 0.1 * NodeAdjust, (NextnoB + 2) * VertAddjust + 3), QBColor(0), BF
    '                Printer.CurrentX = (100 + (100 + NodeAdjust * 0.1) / 2.5)
    '                Printer.CurrentY = (NextnoB + 2.2) * VertAddjust
    '                Printer.Print "0.1"
    ''If RecombineFlag = 1 Then
    '
    '              '  Printer.FontSize = 7
    '
    '             '   Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '            '   Printer.CurrentX = 350
    '            '   Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '             '   Printer.Print "Potential daughter "
    '
    '
    '             '   Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '             '   Printer.CurrentX = 350
    '             '   Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '             '   Printer.Print "Potential parent "
    '
    '                Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '                Printer.Print "Potential daughter "
    '
    '
    '                Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '                Printer.Print "Potential parent "
    '
    '                If OutsideFlagX > 0 Then
    '                    Printer.Line (100, (NextnoB + 5) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 5) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 128), BF
    '                    Printer.CurrentX = 350
    '                    Printer.CurrentY = (NextnoB + 5) * VertAddjust
    '                    Printer.Print "Sequence used to infer unknown parent "
    '                End If
    ''End If
    '******************************************************************************

    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = -20

    For X = 0 To NextnoB - 1

        If XPos(TreeX(X, 0)) <= XPos(TreeY(X)) Then
            MoveToEx MhDC, XOffset + XPos(TreeX(X, 0)), YOffset + YPos(TreeX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeX(X, 0)) - (NodeLength(X) * NodeAdjust - (FirstPos - XPos(TreeX(X, 0)))), YOffset + YPos(TreeX(X, 0))
            '        'Printer.Line (XPos(TreeY(X)), YPos(TreeY(X)))-(XPos(TreeY(X)) + 100, YPos(TreeY(X)))
            FormerXPos = XPos(TreeY(X))
            XPos(TreeY(X)) = XPos(TreeX(X, 0))
            ' Printer.Line (XPos(TreeY(X)) - 100, YPos(TreeY(X)))-(FormerXPos - (nodelengthb(X) * nodeadjust - (FirstPos - FormerXPos)), YPos(TreeY(X)))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeY(X)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLength(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeY(X))
        ElseIf XPos(TreeY(X)) <= XPos(TreeX(X, 0)) Then
            'Printer.Line (XPos(TreeX(X, 0)), YPos(TreeX(X, 0)))-(XPos(TreeX(X, 0)) + 100, YPos(TreeX(X, 0)))
            MoveToEx MhDC, XOffset + XPos(TreeY(X)), YOffset + YPos(TreeY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeY(X)) - (NodeLength(X) * NodeAdjust - (FirstPos - XPos(TreeY(X)))), YOffset + YPos(TreeY(X))
            FormerXPos = XPos(TreeX(X, 0))
            XPos(TreeX(X, 0)) = XPos(TreeY(X))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeX(X, 0)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLength(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeX(X, 0))
        Else
            MoveToEx MhDC, XOffset + XPos(TreeX(X, 0)), YOffset + YPos(TreeX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeX(X, 0)) - NodeLength(X) * NodeAdjust, YOffset + YPos(TreeX(X, 0))
            MoveToEx MhDC, XOffset + XPos(TreeY(X)), YOffset + YPos(TreeY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeY(X)) - NodeLength(X) * NodeAdjust, YOffset + YPos(TreeY(X))
        End If

        'base line
        MoveToEx MhDC, XOffset + FirstPos - NodeLength(X) * NodeAdjust, YOffset + YPos(TreeX(X, 0)), PntAPI
        LineTo MhDC, XOffset + FirstPos - NodeLength(X) * NodeAdjust, YOffset + YPos(TreeY(X))
        YPos(TreeX(X, 0)) = YPos(TreeX(X, 0)) + (YPos(TreeY(X)) - YPos(TreeX(X, 0))) / 2
        YPos(TreeY(X)) = YPos(TreeX(X, 0)) + (YPos(TreeY(X)) - YPos(TreeX(X, 0))) / 2
        XPos(TreeX(X, 0)) = FirstPos - NodeLength(X) * NodeAdjust
        XPos(TreeY(X)) = FirstPos - NodeLength(X) * NodeAdjust
    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 2) * VertAddjust, PntAPI
    LineTo MhDC, XOffset + (0.1) * NodeAdjust, YOffset + (NextNo + 2) * VertAddjust
    TextOut MhDC, XOffset + (0.1 / 2.1) * NodeAdjust, YOffset + (NextNo + 2.5) * VertAddjust, "0.1", 3
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    Exit Sub
errorhandler:
End Sub
Public Sub NJEMF(NHFlag As Integer)
    'Declare variables.
    'Set variables
    scaleaddjust = 3
    Form1.Picture16.Refresh
    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextNo)
    ReDim YPos(NextNo)

    Dim OldFont As Long

    'NodeAdjust = HorAddjust * (0.65 / NodeLength(Nextno - 1))

    Dim rct As RECT

    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)

    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = 20

    Dim XAdd As Integer
    Dim YAdd As Integer
    Dim LargestXPos As Double

    For X = 0 To NextNo

        If SSeqXPos(NHFlag, X) > LargestXPos Then LargestXPos = SSeqXPos(NHFlag, X)
    Next 'X

    XAdd = 400 / LargestXPos
    
    YAdd = 30

    For X = 0 To NextNo

        For Y = 0 To NextNo

            If SNodePath(NHFlag, X, Y + 1) > -1 Then
                MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodePath(NHFlag, X, Y)) * YAdd, PntAPI
                LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodePath(NHFlag, X, Y + 1)) * YAdd
                MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodePath(NHFlag, X, Y + 1)) * YAdd, PntAPI
                LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y + 1))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodePath(NHFlag, X, Y + 1)) * YAdd
            Else
                MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodePath(NHFlag, X, Y)) * YAdd, PntAPI
                LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd
                MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodePath(NHFlag, X, Y))) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd, PntAPI
                LineTo MhDC, XOffset + (SSeqXPos(NHFlag, X)) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd

                If X = Seq3 And Seq3 <> Seq1 Then
                    SetTextColor MhDC, RGB(255, 0, 0)
                ElseIf X = Seq1 And Seq1 <> Seq2 Then

                    If OutsideFlagX = 1 Then
                        SetTextColor MhDC, RGB(0, 0, 128)
                    Else
                        SetTextColor MhDC, RGB(0, 0, 255)
                    End If

                ElseIf X = Seq2 And Seq1 <> Seq2 Then

                    If OutsideFlagX = 2 Then
                        SetTextColor MhDC, RGB(0, 0, 128)
                    Else
                        SetTextColor MhDC, RGB(0, 0, 255)
                    End If

                Else
                    SetTextColor MhDC, RGB(0, 0, 0)
                End If

                TextOut MhDC, XOffset + 10 + SSeqXPos(NHFlag, X) * XAdd, YOffset - 10 + SSeqYPos(NHFlag, X) * YAdd, StraiName(X), Len(StraiName(X))
                Exit For
            End If

        Next 'Y

    Next 'X

    SetTextColor MhDC, RGB(0, 64, 0)

    For X = 1 To NextNo - 2

        If SDLen(NHFlag, X) > 0 Then
            TextOut MhDC, XOffset + 5 + SNodeXPos(NHFlag, X) * XAdd, YOffset - 10 + SNodeYPos(NHFlag, X) * YAdd, Trim$(CStr(SDLen(NHFlag, X))), Len(Trim$(CStr(SDLen(NHFlag, X))))
        End If

    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 2) * YAdd, PntAPI
    LineTo MhDC, XOffset + (0.1) * XAdd, YOffset + (NextNo + 2) * YAdd
    SetTextColor MhDC, RGB(0, 0, 0)
    TextOut MhDC, XOffset + (0.1 / 2.1) * XAdd, YOffset + (NextNo + 2.5) * YAdd, "0.1", 3
    'Clean up and close
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    Exit Sub
errorhandler:
End Sub



Public Sub EMFAllRecomb()
    'On Error GoTo errorhandler

    Dim OldFont As Long
    Dim NonSpacerSeqs() As Integer
    Dim NonSpacerNo As Integer
    Dim NonSpacerI() As Integer
    Dim NodeLengthB() As Double
    Dim RecombTreeSeqs() As Integer
    Dim RecombTreeName() As String

    Begin = GetTickCount()
    ReDim NewNo(NextNo + 2)
    ReDim RecombTreeSeqs(Len(StrainSeq(0)), NextNo + 2)
    ReDim RecombTreeName(NextNo + 2)
    ReDim NodeLengthB(NextNo + 2)

    Dim NoGood As Integer

    ReDim NonSpacerSeqs(NextNo + 2)
    ReDim NonSpacerI(NextNo + 2)
    'Make sub sequences
    'First make small recombinant section

    If XOverList(PRecSeq, PPAVal).Beginning < XOverList(PRecSeq, PPAVal).Ending Then
        'find beginning
        Y = XOverList(PRecSeq, PPAVal).Beginning
        RecombTreeName(0) = StraiName(Seq3) + "*"
        NewNo(0) = Seq3
        RecombTreeName(1) = StraiName(Seq3)
        NewNo(1) = Seq3
        RecombTreeName(2) = StraiName(Seq1)
        NewNo(2) = Seq1
        RecombTreeName(3) = StraiName(Seq2)
        NewNo(3) = Seq2

        If OutsideFlagX = 1 Then
            SpacerNo = 0

            For X = 0 To NextNo

                If X <> Seq3 And X <> Seq2 And X <> Seq1 Then

                    If TreeDistance(X, Seq3) > TreeDistance(Seq1, Seq2) Then 'And TreeDistance(X, Seq3) > TreeDistance(Seq1, Seq3) Then 'TreeDistance(X, Outlyer) < TreeDistance(InlyerA, InlyerB)
                        NonSpacerNo = NonSpacerNo + 1
                        NonSpacerSeqs(NonSpacerNo) = X
                        NonSpacerI(3 + NonSpacerNo) = 1
                    Else
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                    End If

                End If

            Next 'X

        Else

            For X = 0 To NextNo

                If X <> Seq1 And X <> Seq2 And X <> Seq3 Then
                    NoGood = 0

                    For Z = 1 To SpacerNo

                        If X = SpacerSeqs(Z) Then
                            NoGood = 1
                            Exit For
                        End If

                    Next 'Z

                    If NoGood = 0 Then
                        NonSpacerNo = NonSpacerNo + 1
                        NonSpacerSeqs(NonSpacerNo) = X
                        NonSpacerI(3 + NonSpacerNo) = 1
                    Else
                        NoGood = 0
                    End If

                End If

            Next 'X

        End If

        If NonSpacerNo > 0 Then

            For Z = 1 To NonSpacerNo
                RecombTreeName(Z + 3) = StraiName(NonSpacerSeqs(Z))
                NewNo(Z + 3) = NonSpacerSeqs(Z)
            Next 'Z

        End If

        For X = 1 To Y
            RecombTreeSeqs(X, 0) = 60
            RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
            RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(X, Z + 3) = SeqNum(X, NonSpacerSeqs(Z))
                Next 'Z

            End If

        Next 'X

        Y = Y + 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Ending Or Y = Len(StrainSeq(0))
            RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(Y, Z + 3) = 60
                Next 'Z

            End If

            Y = Y + 1
        Loop

        EndMark = Y - 1

        For X = Y To Len(StrainSeq(0))
            RecombTreeSeqs(X, 0) = 60
            RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
            RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(X, Z + 3) = SeqNum(X, NonSpacerSeqs(Z))
                Next 'Z

            End If

        Next 'X

    Else ' If recombination overlaps the end of the sequence
        Y = XOverList(PRecSeq, PPAVal).Beginning

        Do Until Y = XOverList(PRecSeq, PPAVal).Ending Or Y = 1
            Y = Y - 1
        Loop

        RecombTreeName(0) = StraiName(Seq3) + "*"
        NewNo(0) = Seq3
        RecombTreeName(1) = StraiName(Seq3)
        NewNo(1) = Seq3
        RecombTreeName(2) = StraiName(Seq1)
        NewNo(2) = Seq1
        RecombTreeName(3) = StraiName(Seq2)
        NewNo(3) = Seq2

        If OutsideFlagX = 1 Then
            SpacerNo = 0

            For X = 0 To NextNo

                If X <> Seq3 And X <> Seq2 And X <> Seq1 Then

                    If TreeDistance(X, Seq3) > TreeDistance(Seq1, Seq2) Then 'And TreeDistance(X, Seq3) > TreeDistance(Seq1, Seq3) Then 'TreeDistance(X, Outlyer) < TreeDistance(InlyerA, InlyerB)
                        NonSpacerNo = NonSpacerNo + 1
                        NonSpacerSeqs(NonSpacerNo) = X
                        NonSpacerI(3 + NonSpacerNo) = 1
                    Else
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                    End If

                End If

            Next 'X

        Else

            For X = 0 To NextNo

                If X <> Seq1 And X <> Seq2 And X <> Seq3 Then
                    NoGood = 0

                    For Z = 1 To SpacerNo

                        If X = SpacerSeqs(Z) Then
                            NoGood = 1
                            Exit For
                        End If

                    Next 'Z

                    If NoGood = 0 Then
                        NonSpacerNo = NonSpacerNo + 1
                        NonSpacerSeqs(NonSpacerNo) = X
                        NonSpacerI(3 + NonSpacerNo) = 1
                    Else
                        NoGood = 0
                    End If

                End If

            Next 'X

        End If

        If NonSpacerNo > 0 Then

            For Z = 1 To NonSpacerNo
                RecombTreeName(Z + 3) = StraiName(NonSpacerSeqs(Z))
                NewNo(Z + 3) = NonSpacerSeqs(Z)
            Next 'Z

        End If

        A = XOverList(PRecSeq, PPAVal).Ending

        For X = A To Y
            RecombTreeSeqs(X, 0) = 60
            RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
            RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(X, Z + 3) = SeqNum(X, NonSpacerSeqs(Z))
                Next 'Z

            End If

        Next 'X

        Y = Y + 1

        For X = Y To Len(StrainSeq(0)) 'Do Until Y = Len(strainseq(0)) 'SeqComponents(Seq3, Y) = Seq3
            RecombTreeSeqs(X, 0) = SeqNum(X, Seq3)
            RecombTreeSeqs(X, 1) = 60 'SeqNum(Y, Seq1) '60
            RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(X, Z + 3) = 60
                Next 'Z

            End If

            'Y = Y + 1
        Next 'X

        Y = 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Ending Or Y = Len(StrainSeq(0))
            'Exit Sub
            RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)

            If NonSpacerNo > 0 Then

                For Z = 1 To NonSpacerNo
                    RecombTreeSeqs(Y, Z + 3) = SeqNum(Y, NonSpacerSeqs(Z))
                Next 'Z

            End If

            Y = Y + 1
        Loop

        EndMark = Y - 1
    End If

    Begin = GetTickCount()
    Dummy = MakeSubSeqB(SpacerNo, Len(StrainSeq(0)), NonSpacerNo, SeqNum(0, 0), RecombTreeSeqs(0, 0), SpacerSeqs(0))
    '   For X = 0 To Len(strainseq(0))
    '       For Y = 1 To SpacerNo
    '           RecombTreeSeqs(X, Y + 3 + NonSpacerNo) = SeqNum(X, SpacerSeqs(Y))
    '       Next 'Y
    '   Next 'X

    For X = 1 To SpacerNo
        RecombTreeName(X + 3 + NonSpacerNo) = StraiName(SpacerSeqs(X))
        NewNo(X + 3 + NonSpacerNo) = SpacerSeqs(X)
        'Exit Sub
    Next 'X

    NextnoB = 3 + SpacerNo + NonSpacerNo

    Dim NJSubDistance() As Double

    ReDim NJSubDistance(NextnoB, NextnoB + 2)

    Dim ValidSite() As Double

    ReDim ValidSite(NextnoB, NextnoB + 2)
    ' For X = 2 To 3
    '     For Y = X + 1 To NextnoB
    '         NJSubDistance(X, Y) = 1 - Distance(NewNo(X), NewNo(Y))
    '         NJSubDistance(Y, X) = 1 - Distance(NewNo(X), NewNo(Y))
    '
    '    Next 'Y
    ' Next 'X
    Begin = GetTickCount()

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB
            NJSubDistance(X, Y) = 1 - Distance(NewNo(X), NewNo(Y))
            NJSubDistance(Y, X) = 1 - Distance(NewNo(X), NewNo(Y))
        Next 'Y

    Next 'X
    'This could be speeded up with better nesting
    Dummy = DistanceCalcB(NextnoB, Len(StrainSeq(0)) + 1, NonSpacerNo, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0))

    Dim LargestDist As Double

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB

            If X <= 3 + NonSpacerNo Or Y <= 3 + NonSpacerNo Then

                If ValidSite(X, Y) > 0 Then
                    NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                    NJSubDistance(Y, X) = NJSubDistance(X, Y)
                Else
                End If

            End If

        Next 'Y

    Next 'X

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB

            If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)
        Next 'Y

    Next 'X

    NJSubDistance(1, 0) = NJSubDistance(0, 2)
    NJSubDistance(0, 1) = NJSubDistance(1, 0)

    If NonSpacerNo > 0 Then

        For X = 1 To NonSpacerNo
            NJSubDistance(3 + X, 0) = NJSubDistance(0, 2)
            NJSubDistance(0, 3 + X) = NJSubDistance(3 + X, 0)
        Next 'X

    End If

    Begin = GetTickCount()

    Dim ShortestDistance As Double
    Dim SortedNo As Integer

    ReDim TreeRX(NextnoB + 2, NextnoB + 2)

    For X = 0 To NextnoB

        For Y = 0 To NextnoB
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    ReDim TreeRY(NextnoB + 2)

    Dim XInstance() As Integer

    ReDim XInstance(NextnoB + 2)

    Dim MultiInclude As Integer

    Do Until SortedNo = NextnoB
        ShortestDistance = ShortestDist(NextnoB, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100
            '

            For X = 0 To NextnoB

                For Y = X + 1 To NextnoB

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = ShortestDistance / 2

        For X = 0 To NextnoB

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                'NJSubDistance(TreeRY(SortedNo), x) = 1
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
                'NJSubDistance(x, TreeRY(SortedNo)) = 1
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        ' XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' if "sequence y" is actually a node
                    'finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    'adds sequences in node y to node x

                    For Z = 0 To XInstance(TreeRY(SortedNo))
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextnoB

            If X <> TreeRY(SortedNo) Then
                'NJSubDistance(TreeRX(SortedNo), x) = (NJSubDistance(TreeRX(SortedNo), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                NJSubDistance(TreeRY(SortedNo), X) = 100
                'NJSubDistance(x, TreeRX(SortedNo)) = (NJSubDistance(x, TreeRX(SortedNo)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    'Print button click event.
    'The subroutine works but just barely.
    Printer.Font = "Ariel"
    'Exit Sub
    'Declare variables.
    'Set variables
    vertoffset = 200
    scaleaddjust = 3

    Dim FontSizeT As Double

    FontSizeT = 16 - (NextnoB / 10)

    If FontSizeT < 4 Then FontSizeT = 4

    Dim FontAddjust As Double

    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextnoB + 2)
    ReDim YPos(NextnoB + 2)

    Dim FirstPos As Double
    Dim NodeAdjust As Long
    Dim VertAddjust As Double
    Dim HorAddjust As Long

    VertAddjust = 30
    HorAddjust = 700
    NodeAdjust = HorAddjust * (0.65 / NodeLengthB(NextnoB - 1))
    FirstPos = 0.7 * HorAddjust - 100

    Dim rct As RECT

    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    'MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, "", rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    'SetTextColor MhDC, RGB(0, 255, 0)
    OldFont = SelectObject(MhDC, LoFnt)
    

    For X = 0 To NextnoB

        If TreeRX(NextnoB - 1, X) = 0 Then
            SetTextColor MhDC, RGB(255, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = 1 Then
            SetTextColor MhDC, RGB(128, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = 2 Then

            If OutsideFlagX = 1 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = 3 Then

            If OutsideFlagX = 2 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        Else
            SetTextColor MhDC, RGB(0, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
        End If

        '    End If
    Next 'X

    Dim FormerXPos As Double

    '************************************************************************
    '                Printer.Line (100, (NextnoB + 2) * VertAddjust)-(100 + 0.1 * NodeAdjust, (NextnoB + 2) * VertAddjust + 3), QBColor(0), BF
    '                Printer.CurrentX = (100 + (100 + NodeAdjust * 0.1) / 2.5)
    '                Printer.CurrentY = (NextnoB + 2.2) * VertAddjust
    '                Printer.Print "0.1"
    ''If RecombineFlag = 1 Then
    '
    '              '  Printer.FontSize = 7
    '
    '             '   Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '            '   Printer.CurrentX = 350
    '            '   Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '             '   Printer.Print "Potential daughter "
    '
    '
    '             '   Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '             '   Printer.CurrentX = 350
    '             '   Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '             '   Printer.Print "Potential parent "
    '
    '                Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '                Printer.Print "Potential daughter "
    '
    '
    '                Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '                Printer.Print "Potential parent "
    '
    '                If OutsideFlagX > 0 Then
    '                    Printer.Line (100, (NextnoB + 5) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 5) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 128), BF
    '                    Printer.CurrentX = 350
    '                    Printer.CurrentY = (NextnoB + 5) * VertAddjust
    '                    Printer.Print "Sequence used to infer unknown parent "
    '                End If
    ''End If
    '******************************************************************************

    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = -20

    For X = 0 To NextnoB - 1

        If XPos(TreeRX(X, 0)) <= XPos(TreeRY(X)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YOffset + YPos(TreeRX(X, 0))
            '        'Printer.Line (XPos(TreeRy(X)), YPos(TreeRy(X)))-(XPos(TreeRy(X)) + 100, YPos(TreeRy(X)))
            FormerXPos = XPos(TreeRY(X))
            XPos(TreeRY(X)) = XPos(TreeRX(X, 0))
            ' Printer.Line (XPos(TreeRy(X)) - 100, YPos(TreeRy(X)))-(FormerXPos - (nodelengthb(X) * nodeadjust - (FirstPos - FormerXPos)), YPos(TreeRy(X)))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRY(X))
        ElseIf XPos(TreeRY(X)) <= XPos(TreeRX(X, 0)) Then
            'Printer.Line (XPos(TreeRx(X, 0)), YPos(TreeRx(X, 0)))-(XPos(TreeRx(X, 0)) + 100, YPos(TreeRx(X, 0)))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YOffset + YPos(TreeRY(X))
            FormerXPos = XPos(TreeRX(X, 0))
            XPos(TreeRX(X, 0)) = XPos(TreeRY(X))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRX(X, 0))
        Else
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        End If

        'base line
        MoveToEx MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0)), PntAPI
        LineTo MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        YPos(TreeRX(X, 0)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        YPos(TreeRY(X)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        XPos(TreeRX(X, 0)) = FirstPos - NodeLengthB(X) * NodeAdjust
        XPos(TreeRY(X)) = FirstPos - NodeLengthB(X) * NodeAdjust
    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 3) * VertAddjust, PntAPI
    LineTo MhDC, XOffset + (0.1) * NodeAdjust, YOffset + (NextNo + 3) * VertAddjust
    TextOut MhDC, XOffset + (0.1 / 2.1) * NodeAdjust, YOffset + (NextNo + 3.5) * VertAddjust, "0.1", 3
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    Exit Sub
errorhandler:
End Sub

Public Sub EMFOnlyRecomb()

    Dim NodeLengthB() As Double
    Dim RecombTreeSeqs() As Integer
    Dim RecombTreeName() As String

    ReDim RecombTreeSeqs(Len(StrainSeq(0)), NextNo + 1)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    'Make sub sequences
    'First make small recombinant section

    If XOverList(PRecSeq, PPAVal).Beginning < XOverList(PRecSeq, PPAVal).Ending Then
        'find beginning
        Y = XOverList(PRecSeq, PPAVal).Beginning
        BeginMark = Y
        RBegin = Y

        For X = 0 To NextNo
            RecombTreeName(X) = StraiName(X)
        Next 'X

        For X = 1 To Y

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = 60
            Next 'Z

        Next 'X

        Y = Y + 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Ending Or Y >= Len(StrainSeq(0))

            For Z = 0 To NextNo
                RecombTreeSeqs(Y, Z) = SeqNum(Y, Z)
            Next 'Z

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            'RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            Y = Y + 1
        Loop

        REnd = Y - 1
        EndMark = Y - 1

        If Y < Len(StrainSeq(0)) Then

            For X = Y To Len(StrainSeq(0))

                For Z = 0 To NextNo
                    RecombTreeSeqs(X, Z) = SeqNum(X, Z) = 60
                    'RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
                    'RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
                    ' RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)
                Next 'Z

            Next 'X

        End If

    Else ' If recombination overlaps the end of the sequence

        For X = 0 To NextNo
            RecombTreeName(X) = StraiName(X)
        Next 'X

        Y = XOverList(PRecSeq, PPAVal).Beginning
        BeginMark = Y
        A = XOverList(PRecSeq, PPAVal).Ending

        Do Until A = XOverList(PRecSeq, PPAVal).Beginning Or A = Len(StrainSeq(0))
            A = A + 1
        Loop

        REnd = A

        For X = A To Y

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = 60
            Next 'Z

            'RecombTreeSeqs(X, 0) = 60
            ' RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
            ' RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            ' RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)
        Next 'X

        Y = Y + 1
        RBegin = Y

        For X = Y To Len(StrainSeq(0)) 'Do Until Y = Len(strainseq(0)) 'SeqComponents(Seq3, Y) = Seq3

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = SeqNum(X, Z)
            Next 'Z

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            ' RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            'Y = Y + 1
        Next 'X

        Y = 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Ending

            For X = 0 To NextNo
                RecombTreeSeqs(Y, X) = SeqNum(Y, X)
            Next 'X

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            ' RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            Y = Y + 1
        Loop

        EndMark = Y - 1
    End If

    '  For X = 0 To Len(strainseq(0))
    '      For Y = 1 To SpacerNo
    '          RecombTreeSeqs(X, Y + 3) = SeqNum(X, SpacerSeqs(Y))
    '      Next 'Y
    '  Next 'X
    ' For X = 1 To SpacerNo
    '     RecombTreeName(X + 3) = strainame(SpacerSeqs(X))
    ' Next 'X
    Begin = GetTickCount()
    NextnoB = NextNo ' + 1

    Dim NJSubDistance() As Double

    ReDim NJSubDistance(NextnoB, NextnoB)

    Dim ValidSite() As Double

    ReDim ValidSite(NextnoB, NextnoB)
        'this coluld be speeded up with better nesting of if then's

    Dummy = DistanceCalcC(NextnoB, Len(StrainSeq(0)) + 1, RBegin, REnd, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0))

    Dim LargestDist As Double

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB

            If ValidSite(X, Y) > 0 Then
                NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                NJSubDistance(Y, X) = NJSubDistance(X, Y)

                If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)

                If NJSubDistance(X, Y) > 0 Then
                End If

            End If

        Next 'Y

    Next 'X

    ' NJSubDistance(1, 0) = NJSubDistance(0, 2)
    ' NJSubDistance(0, 1) = NJSubDistance(1, 0)

    Dim ShortestDistance As Double
    Dim SortedNo As Integer

    'Dim TreeRX() As Integer
    'Dim TreeRY() As Integer
    ReDim TreeRX(NextnoB + 1, NextnoB + 1)

    For X = 0 To NextnoB

        For Y = 0 To NextnoB
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    ReDim TreeRY(NextnoB)

    Dim XInstance() As Integer

    ReDim XInstance(NextnoB + 1)

    Dim MultiInclude As Integer

    Do Until SortedNo = NextnoB
        ShortestDistance = ShortestDist(NextnoB, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextnoB

                For Y = X + 1 To NextnoB

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = ShortestDistance / 2

        For X = 0 To NextnoB

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                'NJSubDistance(TreeRY(SortedNo), x) = 1
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
                'NJSubDistance(x, TreeRY(SortedNo)) = 1
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        ' XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' if "sequence y" is actually a node
                    'finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    'adds sequences in node y to node x

                    For Z = 0 To XInstance(TreeRY(SortedNo))
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextnoB

            If X <> TreeRY(SortedNo) Then
                'NJSubDistance(TreeRX(SortedNo), x) = (NJSubDistance(TreeRX(SortedNo), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                NJSubDistance(TreeRY(SortedNo), X) = 100
                'NJSubDistance(x, TreeRX(SortedNo)) = (NJSubDistance(x, TreeRX(SortedNo)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    'Print button click event.
    'Declare variables.
    'Set variables
    vertoffset = 200
    scaleaddjust = 3
    'Printer.Zoom = 50
    ' Exit Sub

    Dim FontSizeT As Double

    FontSizeT = 16 - (NextnoB / 10)

    If FontSizeT < 4 Then FontSizeT = 4

    Dim FontAddjust As Double


    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextnoB + 2)
    ReDim YPos(NextnoB + 2)

    Dim FirstPos As Double
    Dim NodeAdjust As Long
    Dim VertAddjust As Double
    Dim HorAddjust As Long

    VertAddjust = 30
    HorAddjust = 700
    NodeAdjust = HorAddjust * (0.65 / NodeLengthB(NextnoB - 1))
    FirstPos = 0.7 * HorAddjust - 100

    Dim rct As RECT
    Dim MhDC As Long, OldFont As Long

    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    'SetTextColor MhDC, RGB(0, 255, 0)
    OldFont = SelectObject(MhDC, LoFnt)
   

    For X = 0 To NextnoB

        If TreeRX(NextnoB - 1, X) = Seq3 Then
            SetTextColor MhDC, RGB(255, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq1 Then

            If OutsideFlagX = 1 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq2 Then

            If OutsideFlagX = 2 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        Else
            SetTextColor MhDC, RGB(0, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
        End If

        '    End If
    Next 'X

    Dim FormerXPos As Double
    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = -20

    For X = 0 To NextnoB - 1

        If XPos(TreeRX(X, 0)) <= XPos(TreeRY(X)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YOffset + YPos(TreeRX(X, 0))
            FormerXPos = XPos(TreeRY(X))
            XPos(TreeRY(X)) = XPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRY(X))
        ElseIf XPos(TreeRY(X)) <= XPos(TreeRX(X, 0)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YOffset + YPos(TreeRY(X))
            FormerXPos = XPos(TreeRX(X, 0))
            XPos(TreeRX(X, 0)) = XPos(TreeRY(X))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRX(X, 0))
        Else
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        End If

        'base line
        MoveToEx MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0)), PntAPI
        LineTo MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        YPos(TreeRX(X, 0)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        YPos(TreeRY(X)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        XPos(TreeRX(X, 0)) = FirstPos - NodeLengthB(X) * NodeAdjust
        XPos(TreeRY(X)) = FirstPos - NodeLengthB(X) * NodeAdjust
    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 2) * VertAddjust, PntAPI
    LineTo MhDC, XOffset + (0.1) * NodeAdjust, YOffset + (NextNo + 2) * VertAddjust
    TextOut MhDC, XOffset + (0.1 / 2.1) * NodeAdjust, YOffset + (NextNo + 2.5) * VertAddjust, "0.1", 3
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    'Printer.EndDoc  'Finish drawing page and print.
    Exit Sub
errorhandler:
End Sub
Public Sub EMFOnlyRecomb2()

    Dim NodeLengthB() As Double
    Dim RecombTreeSeqs() As Integer
    Dim RecombTreeName() As String

    ReDim RecombTreeSeqs(Len(StrainSeq(0)), NextNo + 1)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    'Make sub sequences
    'First make small recombinant section

    If XOverList(PRecSeq, PPAVal).Ending < XOverList(PRecSeq, PPAVal).Beginning Then
        'find beginning
        Y = XOverList(PRecSeq, PPAVal).Ending
        BeginMark = Y
        RBegin = Y

        For X = 0 To NextNo
            RecombTreeName(X) = StraiName(X)
        Next 'X

        For X = 1 To Y

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = 60
            Next 'Z

        Next 'X

        Y = Y + 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Beginning Or Y >= Len(StrainSeq(0))

            For Z = 0 To NextNo
                RecombTreeSeqs(Y, Z) = SeqNum(Y, Z)
            Next 'Z

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            'RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            Y = Y + 1
        Loop

        REnd = Y - 1
        EndMark = Y - 1

        If Y < Len(StrainSeq(0)) Then

            For X = Y To Len(StrainSeq(0))

                For Z = 0 To NextNo
                    RecombTreeSeqs(X, Z) = SeqNum(X, Z) = 60
                    'RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
                    'RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
                    ' RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)
                Next 'Z

            Next 'X

        End If

    Else ' If recombination overlaps the end of the sequence

        For X = 0 To NextNo
            RecombTreeName(X) = StraiName(X)
        Next 'X

        Y = XOverList(PRecSeq, PPAVal).Ending + 1
        BeginMark = Y
        A = XOverList(PRecSeq, PPAVal).Beginning - 1

        Do Until A = XOverList(PRecSeq, PPAVal).Ending Or A = Len(StrainSeq(0))
            A = A + 1
        Loop

        REnd = A

        For X = A To Y

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = 60
            Next 'Z

            'RecombTreeSeqs(X, 0) = 60
            ' RecombTreeSeqs(X, 1) = SeqNum(X, Seq3)
            ' RecombTreeSeqs(X, 2) = SeqNum(X, Seq1)
            ' RecombTreeSeqs(X, 3) = SeqNum(X, Seq2)
        Next 'X

        Y = Y + 1
        RBegin = Y

        For X = Y To Len(StrainSeq(0)) 'Do Until Y = Len(strainseq(0)) 'SeqComponents(Seq3, Y) = Seq3

            For Z = 0 To NextNo
                RecombTreeSeqs(X, Z) = SeqNum(X, Z)
            Next 'Z

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            ' RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            'Y = Y + 1
        Next 'X

        Y = 1

        Do Until Y = XOverList(PRecSeq, PPAVal).Beginning

            For X = 0 To NextNo
                RecombTreeSeqs(Y, X) = SeqNum(Y, X)
            Next 'X

            'RecombTreeSeqs(Y, 0) = SeqNum(Y, Seq3)
            ' RecombTreeSeqs(Y, 1) = 60 'SeqNum(Y, Seq1) '60
            ' RecombTreeSeqs(Y, 2) = SeqNum(Y, Seq1)
            ' RecombTreeSeqs(Y, 3) = SeqNum(Y, Seq2)
            Y = Y + 1
        Loop

        EndMark = Y - 1
    End If

    '  For X = 0 To Len(strainseq(0))
    '      For Y = 1 To SpacerNo
    '          RecombTreeSeqs(X, Y + 3) = SeqNum(X, SpacerSeqs(Y))
    '      Next 'Y
    '  Next 'X
    ' For X = 1 To SpacerNo
    '     RecombTreeName(X + 3) = strainame(SpacerSeqs(X))
    ' Next 'X
    Begin = GetTickCount()
    NextnoB = NextNo ' + 1

    Dim NJSubDistance() As Double

    ReDim NJSubDistance(NextnoB, NextnoB)

    Dim ValidSite() As Double

    ReDim ValidSite(NextnoB, NextnoB)
        'this coluld be speeded up with better nesting of if then's

    Dummy = DistanceCalcC(NextnoB, Len(StrainSeq(0)) + 1, RBegin, REnd, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0))

    Dim LargestDist As Double

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB

            If ValidSite(X, Y) > 0 Then
                NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                NJSubDistance(Y, X) = NJSubDistance(X, Y)

                If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)

                If NJSubDistance(X, Y) > 0 Then
                End If

            End If

        Next 'Y

    Next 'X

    ' NJSubDistance(1, 0) = NJSubDistance(0, 2)
    ' NJSubDistance(0, 1) = NJSubDistance(1, 0)

    Dim ShortestDistance As Double
    Dim SortedNo As Integer

    'Dim TreeRX() As Integer
    'Dim TreeRY() As Integer
    ReDim TreeRX(NextnoB + 1, NextnoB + 1)

    For X = 0 To NextnoB

        For Y = 0 To NextnoB
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    ReDim TreeRY(NextnoB)

    Dim XInstance() As Integer

    ReDim XInstance(NextnoB + 1)

    Dim MultiInclude As Integer

    Do Until SortedNo = NextnoB
        ShortestDistance = ShortestDist(NextnoB, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextnoB

                For Y = X + 1 To NextnoB

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = ShortestDistance / 2

        For X = 0 To NextnoB

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                'NJSubDistance(TreeRY(SortedNo), x) = 1
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
                'NJSubDistance(x, TreeRY(SortedNo)) = 1
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        ' XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' if "sequence y" is actually a node
                    'finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    'adds sequences in node y to node x

                    For Z = 0 To XInstance(TreeRY(SortedNo))
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextnoB

            If X <> TreeRY(SortedNo) Then
                'NJSubDistance(TreeRX(SortedNo), x) = (NJSubDistance(TreeRX(SortedNo), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                NJSubDistance(TreeRY(SortedNo), X) = 100
                'NJSubDistance(x, TreeRX(SortedNo)) = (NJSubDistance(x, TreeRX(SortedNo)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    'Print button click event.
    'Declare variables.
    'Set variables
    vertoffset = 200
    scaleaddjust = 3
    'Printer.Zoom = 50
    ' Exit Sub

    Dim FontSizeT As Double

    FontSizeT = 16 - (NextnoB / 10)

    If FontSizeT < 4 Then FontSizeT = 4

    Dim FontAddjust As Double


    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextnoB + 2)
    ReDim YPos(NextnoB + 2)

    Dim FirstPos As Double
    Dim NodeAdjust As Long
    Dim VertAddjust As Double
    Dim HorAddjust As Long

    VertAddjust = 30
    HorAddjust = 700
    NodeAdjust = HorAddjust * (0.65 / NodeLengthB(NextnoB - 1))
    FirstPos = 0.7 * HorAddjust - 100

    Dim rct As RECT
    Dim MhDC As Long, OldFont As Long

    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    'SetTextColor MhDC, RGB(0, 255, 0)
    OldFont = SelectObject(MhDC, LoFnt)
    

    For X = 0 To NextnoB

        If TreeRX(NextnoB - 1, X) = Seq3 Then
            SetTextColor MhDC, RGB(255, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq1 Then

            If OutsideFlagX = 1 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq2 Then

            If OutsideFlagX = 2 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        Else
            SetTextColor MhDC, RGB(0, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust - 8, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
        End If

        '    End If
    Next 'X

    Dim FormerXPos As Double
    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = -20

    For X = 0 To NextnoB - 1

        If XPos(TreeRX(X, 0)) <= XPos(TreeRY(X)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YOffset + YPos(TreeRX(X, 0))
            FormerXPos = XPos(TreeRY(X))
            XPos(TreeRY(X)) = XPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRY(X))
        ElseIf XPos(TreeRY(X)) <= XPos(TreeRX(X, 0)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YOffset + YPos(TreeRY(X))
            FormerXPos = XPos(TreeRX(X, 0))
            XPos(TreeRX(X, 0)) = XPos(TreeRY(X))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRX(X, 0))
        Else
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        End If

        'base line
        MoveToEx MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0)), PntAPI
        LineTo MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        YPos(TreeRX(X, 0)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        YPos(TreeRY(X)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        XPos(TreeRX(X, 0)) = FirstPos - NodeLengthB(X) * NodeAdjust
        XPos(TreeRY(X)) = FirstPos - NodeLengthB(X) * NodeAdjust
    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 2) * VertAddjust, PntAPI
    LineTo MhDC, XOffset + (0.1) * NodeAdjust, YOffset + (NextNo + 2) * VertAddjust
    TextOut MhDC, XOffset + (0.1 / 2.1) * NodeAdjust, YOffset + (NextNo + 2.5) * VertAddjust, "0.1", 3
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    'Printer.EndDoc  'Finish drawing page and print.
    Exit Sub
errorhandler:
End Sub
Public Sub EMFRecomb()
    'On Error GoTo errorhandler

    Dim OldFont As Long
    Dim NodeLengthB() As Double
    Dim RecombTreeSeqs() As Integer
    Dim RecombTreeName() As String

    'ReDim SeqComponents(Nextno, Len(strainseq(0)))
    ReDim RecombTreeSeqs(Len(StrainSeq(0)), NextNo)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)

    Dim Ending As Variant

    Begin = GetTickCount()
    'Make sub sequences
    'Dim SeqProb2() As Double
    'ReDim SeqProb2(Nextno, Len(StrainSeq(0)))
    Dummy = MakeSubSeqC(NextNo, Len(StrainSeq(0)), SeqNum(0, 0), RecombTreeSeqs(0, 0), SeqProb2(0, 0), CurrentXover(0))
    Ending = GetTickCount()
    Interval = Ending - Begin

    For X = 0 To NextNo
        RecombTreeName(X) = StraiName(X)
    Next 'X

    Begin = GetTickCount()
    NextnoB = NextNo ' + 1

    Dim NJSubDistance() As Double

    ReDim NJSubDistance(NextnoB, NextnoB)

    Dim ValidSite() As Double
    'this coluld be speeded up with better nesting of if then's
    ReDim ValidSite(NextnoB, NextnoB)
    Dummy = DistanceCalcD(NextnoB, Len(StrainSeq(0)) + 1, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0), CurrentXover(0), Distance(0, 0))
    endingb = GetTickCount()
    Interval = endingb - Begin
    Begin = GetTickCount()

    Dim LargestDist As Double

    For X = 0 To NextnoB

        For Y = X + 1 To NextnoB

            If CurrentXover(X) = 0 And CurrentXover(Y) = 0 Then

                If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)
            Else

                If ValidSite(X, Y) > 0 Then
                    NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                    NJSubDistance(Y, X) = NJSubDistance(X, Y)

                    If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)

                    If NJSubDistance(X, Y) > 0 Then
                    End If

                End If

                'NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                'NJSubDistance(Y, X) = NJSubDistance(X, Y)
            End If

        Next 'Y

    Next 'X

    endingb = GetTickCount()
    Interval = endingb - Begin
    ' NJSubDistance(1, 0) = NJSubDistance(0, 2)
    ' NJSubDistance(0, 1) = NJSubDistance(1, 0)
    Begin = GetTickCount()

    Dim ShortestDistance As Double
    Dim SortedNo As Integer

    '   Dim TreeRX() As Integer
    '   Dim TreeRY() As Integer
    ReDim TreeRX(NextnoB + 1, NextnoB + 1)

    For X = 0 To NextnoB

        For Y = 0 To NextnoB
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    ReDim TreeRY(NextnoB)

    Dim XInstance() As Integer

    ReDim XInstance(NextnoB + 1)

    Dim MultiInclude As Integer

    Do Until SortedNo = NextnoB
        ShortestDistance = ShortestDist(NextnoB, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextnoB

                For Y = X + 1 To NextnoB

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = ShortestDistance / 2

        For X = 0 To NextnoB

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                'NJSubDistance(TreeRY(SortedNo), x) = 1
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
                'NJSubDistance(x, TreeRY(SortedNo)) = 1
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        ' XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' if "sequence y" is actually a node
                    'finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    'adds sequences in node y to node x

                    For Z = 0 To XInstance(TreeRY(SortedNo))
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextnoB

            If X <> TreeRY(SortedNo) Then
                'NJSubDistance(TreeRX(SortedNo), x) = (NJSubDistance(TreeRX(SortedNo), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                NJSubDistance(TreeRY(SortedNo), X) = 100
                'NJSubDistance(x, TreeRX(SortedNo)) = (NJSubDistance(x, TreeRX(SortedNo)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    'Print button click event.
    'The subroutine works but just barely.

    Dim LoFnt As Long

    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    'Printer.Font = "Ariel"
    'Declare variables.
    'Set variables
    vertoffset = 200
    scaleaddjust = 3

    Dim FontSizeT As Double

    Printer.ScaleMode = 3
    FontSizeT = 16 - (NextnoB / 10)

    If FontSizeT < 4 Then FontSizeT = 4
    LoFnt = CreateFont(FontSizeT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    SelectObject MhDC, LoFnt
    Dim XPos() As Double
    Dim YPos() As Double

    ReDim XPos(NextnoB + 2)
    ReDim YPos(NextnoB + 2)
    'Printer.CurrentY = 0

    Dim FirstPos As Double
    Dim NodeAdjust As Long
    Dim VertAddjust As Double
    Dim HorAddjust As Long

    VertAddjust = 30
    HorAddjust = 700
    Printer.DrawWidth = 4
    NodeAdjust = HorAddjust * (0.65 / NodeLengthB(NextnoB - 1))
    FirstPos = 0.7 * HorAddjust - 100
    Printer.ForeColor = QBColor(0)

    Dim rct As RECT

    'Dim MhDC As Long
    rct.Bottom = (NextNo + 3) * 1000
    rct.left = 0
    rct.Top = 0
    rct.right = 18000
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    'SetTextColor MhDC, RGB(0, 255, 0)
    SelectObject MhDC, LoFnt
    

    For X = 0 To NextnoB

        If TreeRX(NextnoB - 1, X) = Seq3 Then
            SetTextColor MhDC, RGB(255, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq1 Then

            If OutsideFlagX = 1 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            Printer.CurrentX = 0.7 * HorAddjust
            Printer.CurrentY = (X + 1) * VertAddjust
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        ElseIf TreeRX(NextnoB - 1, X) = Seq2 Then

            If OutsideFlagX = 2 Then
                SetTextColor MhDC, RGB(0, 0, 128)
            Else
                SetTextColor MhDC, RGB(0, 0, 255)
            End If

            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
            SetTextColor MhDC, RGB(0, 0, 0)
        Else
            SetTextColor MhDC, RGB(0, 0, 0)
            TextOut MhDC, 0.7 * HorAddjust, (X + 1) * VertAddjust, RecombTreeName(TreeRX(NextnoB - 1, X)), Len(RecombTreeName(TreeRX(NextnoB - 1, X)))
            XPos(TreeRX(NextnoB - 1, X)) = FirstPos
            YPos(TreeRX(NextnoB - 1, X)) = VertAddjust + 20 + X * VertAddjust - (FontAddjust * 2)
        End If

        '    End If
    Next 'X

    Dim FormerXPos As Double

    '************************************************************************
    '                Printer.Line (100, (NextnoB + 2) * VertAddjust)-(100 + 0.1 * NodeAdjust, (NextnoB + 2) * VertAddjust + 3), QBColor(0), BF
    '                Printer.CurrentX = (100 + (100 + NodeAdjust * 0.1) / 2.5)
    '                Printer.CurrentY = (NextnoB + 2.2) * VertAddjust
    '                Printer.Print "0.1"
    ''If RecombineFlag = 1 Then
    '
    '              '  Printer.FontSize = 7
    '
    '             '   Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '            '   Printer.CurrentX = 350
    '            '   Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '             '   Printer.Print "Potential daughter "
    '
    '
    '             '   Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '             '   Printer.CurrentX = 350
    '             '   Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '             '   Printer.Print "Potential parent "
    '
    '                Printer.Line (100, (NextnoB + 3) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 3) * VertAddjust + (VertAddjust / 2)), RGB(255, 0, 0), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 3) * VertAddjust
    '                Printer.Print "Potential daughter "
    '
    '
    '                Printer.Line (100, (NextnoB + 4) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 4) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 255), BF
    '                Printer.CurrentX = 350
    '                Printer.CurrentY = (NextnoB + 4) * VertAddjust
    '                Printer.Print "Potential parent "
    '
    '                If OutsideFlagX > 0 Then
    '                    Printer.Line (100, (NextnoB + 5) * VertAddjust)-(100 + (VertAddjust / 2), (NextnoB + 5) * VertAddjust + (VertAddjust / 2)), RGB(0, 0, 128), BF
    '                    Printer.CurrentX = 350
    '                    Printer.CurrentY = (NextnoB + 5) * VertAddjust
    '                    Printer.Print "Sequence used to infer unknown parent "
    '                End If
    ''End If
    '******************************************************************************

    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = -10

    For X = 0 To NextnoB - 1

        If XPos(TreeRX(X, 0)) <= XPos(TreeRY(X)) Then
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YOffset + YPos(TreeRX(X, 0))
            '        'Printer.Line (XPos(TreeRy(X)), YPos(TreeRy(X)))-(XPos(TreeRy(X)) + 100, YPos(TreeRy(X)))
            FormerXPos = XPos(TreeRY(X))
            XPos(TreeRY(X)) = XPos(TreeRX(X, 0))
            ' Printer.Line (XPos(TreeRy(X)) - 100, YPos(TreeRy(X)))-(FormerXPos - (nodelengthb(X) * nodeadjust - (FirstPos - FormerXPos)), YPos(TreeRy(X)))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRY(X))
        ElseIf XPos(TreeRY(X)) <= XPos(TreeRX(X, 0)) Then
            'Printer.Line (XPos(TreeRx(X, 0)), YPos(TreeRx(X, 0)))-(XPos(TreeRx(X, 0)) + 100, YPos(TreeRx(X, 0)))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YOffset + YPos(TreeRY(X))
            FormerXPos = XPos(TreeRX(X, 0))
            XPos(TreeRX(X, 0)) = XPos(TreeRY(X))
            MoveToEx MhDC, XOffset + FormerXPos, YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YOffset + YPos(TreeRX(X, 0))
        Else
            MoveToEx MhDC, XOffset + XPos(TreeRX(X, 0)), YOffset + YPos(TreeRX(X, 0)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0))
            MoveToEx MhDC, XOffset + XPos(TreeRY(X)), YOffset + YPos(TreeRY(X)), PntAPI
            LineTo MhDC, XOffset + XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        End If

        'base line
        MoveToEx MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRX(X, 0)), PntAPI
        LineTo MhDC, XOffset + FirstPos - NodeLengthB(X) * NodeAdjust, YOffset + YPos(TreeRY(X))
        YPos(TreeRX(X, 0)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        YPos(TreeRY(X)) = YPos(TreeRX(X, 0)) + (YPos(TreeRY(X)) - YPos(TreeRX(X, 0))) / 2
        XPos(TreeRX(X, 0)) = FirstPos - NodeLengthB(X) * NodeAdjust
        XPos(TreeRY(X)) = FirstPos - NodeLengthB(X) * NodeAdjust
    Next 'X

    MoveToEx MhDC, XOffset, YOffset + (NextNo + 2) * VertAddjust, PntAPI
    LineTo MhDC, XOffset + (0.1) * NodeAdjust, YOffset + (NextNo + 2) * VertAddjust
    TextOut MhDC, XOffset + (0.1 / 2.1) * NodeAdjust, YOffset + (NextNo + 2.5) * VertAddjust, "0.1", 3
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    Exit Sub
errorhandler:
End Sub

Public Sub LoadPIR()

    Dim NF As Integer
    Dim tempstring As String

    NextNo = -1
    Form1.SSPanel1.Caption = "Loading PIR File"
    Form1.ProgressBar1.Value = 20
    NF = FreeFile
    Open FName$ For Input Access Read As #NF

    Do While Not EOF(NF)
        Input #NF, tempstring

        If Mid$(tempstring, 1, 4) = ">DL;" Then
            NextNo = NextNo + 1

            Call SeqArrays

            Form1.ProgressBar1.Value = 20 + ((Len(StrainSeq(0)) * NextNo) / LOF(NF)) * 100 * 0.75
            StraiName(NextNo) = Mid$(tempstring, 5, Len(tempstring) - 1)
            Line Input #NF, tempstring

            If tempstring = "" Then Line Input #NF, tempstring
        Else
            StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
        End If

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    Close #NF
End Sub
Public Sub LoadFASTA()

    Dim NF As Integer, tempstring As String
    Dim crPos As Long, lfPos As Long, NPos As Long, Pos As Long, LastPos As Long
    Dim FFlag As Byte
    FFlag = 0
    Form1.SSPanel1.Caption = "Loading FASTA File"
    

    If WholeFileFlag = 0 Then
        NF = FreeFile
        Open FName$ For Input Access Read As #NF
        XX = Len(StrainSeq(0))
        Form1.ProgressBar1.Value = 20

        Do While Not EOF(NF)
            Input #1, tempstring

            If left$(tempstring, 1) = ">" Then
                NextNo = NextNo + 1

                Call SeqArrays

                Form1.ProgressBar1.Value = 20 + ((Len(StrainSeq(0)) * NextNo) / LOF(NF)) * 100 * 0.75
                StraiName(NextNo) = Mid$(tempstring, 2, Len(tempstring) - 1)
            Else
                StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
            End If

            If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
        Loop

        Close #NF
    Else
        LastPos = InStr(1, SeqFile, ">", vbBinaryCompare)
        NextNo = NextNo + 1

        Dim Target As String

        crPos = InStr(LastPos, SeqFile, Chr$(13), vbBinaryCompare)
        
        lfPos = InStr(LastPos, SeqFile, Chr$(10), vbBinaryCompare)
        If crPos > 0 And lfPos > 0 Then
            If crPos < lfPos Then
                Target = Chr$(13)
            Else
                Target = Chr$(10)
            End If
        ElseIf crPos > 0 Then
            Target = Chr$(13)
        ElseIf lfPos > 0 Then
            Target = Chr$(10)
        End If

        LastPos = 0
        Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)

        Do

            If Pos = 0 Then Exit Do 'Pos = Len(SeqFile) - 1
            NPos = InStr(LastPos + 1, SeqFile, Target, vbBinaryCompare)
            
            'If NPos = 0 Then
            '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
            '    If NPos = 0 Then
            '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
            '    End If
            'End If
            If NPos = 0 Then Exit Sub
            If NPos <= Pos Then
                NPos = InStr(Pos + 1, SeqFile, Target, vbBinaryCompare)
            End If
            StraiName(NextNo) = Trim(Mid$(SeqFile, Pos + 1, NPos - Pos - 1))
            LastPos = NPos + 2
            NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
            Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)
            
            If Pos = 0 Then
                If InStr(1, SeqFile, "Recombination Data", vbBinaryCompare) = 0 Then
                    Pos = Len(SeqFile)
                Else
                    NPos = InStr(1, SeqFile, "GB Data", vbBinaryCompare)
                    XPos = InStr(1, SeqFile, "Recombination Data", vbBinaryCompare)
                    X = X
                    If XPos < NPos Or NPos = 0 Then
                        Pos = XPos
                    Else
                        Pos = NPos
                    End If
                End If
                FFlag = 1
            
            End If
            If NPos = 0 Then NPos = Len(SeqFile)
            Do While LastPos + 2 < Pos And NPos > 0
                StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(SeqFile, LastPos, NPos - LastPos)
                LastPos = NPos + 2
                'xx = Len(StrainSeq(10))
                NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                'If NPos = 0 Then
                '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                '    If NPos = 0 Then
                '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                '    End If
                'End If
                'If NPos = 0 Then Exit Sub
                zzz = right$(StrainSeq(NextNo), 20)
                XX = Len(StrainSeq(NextNo))
                XX = StraiName(NextNo)
                X = X
            Loop
            If FFlag = 1 Then Exit Do
            If Pos >= Len(SeqFile) - 2 Then Exit Do
            NextNo = NextNo + 1
            Call SeqArrays

            'Form1.SSPanel1.Caption = trim$(cstr(Nextno)) & " Sequences Loaded"

            If NextNo / 10 = Int(NextNo / 10) Then
                Form1.ProgressBar1.Value = 20 + (LastPos / Len(SeqFile)) * 100 * 0.75
            End If

        Loop

    End If
End Sub
Public Sub LoadNEXUS()

    Dim NF As Integer
    Dim lTempString As String, tempstring As String, Trimmed As String
    Dim X As Long, LastPos As Long, PosN1 As Long, StartFrom As Long, NumSpace As Long

    NF = FreeFile
    Form1.SSPanel1.Caption = "Loading NEXUS File"
    Open FName$ For Input Access Read As #NF
    Input #NF, tempstring

    If Len(tempstring) = LOF(NF) Then 'ie the whole file is read because there are no carriage returns
        Close #NF
        LastPos = 1

        Do
            Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 2
            Else
                Exit Do
            End If

        Loop

        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, tempstring
        Close #NF
        Open "tempfile" For Input Access Read As #NF
        Line Input #NF, tempstring
        Input #NF, tempstring
        Input #NF, tempstring
        Line Input #NF, tempstring
    Else
        Input #NF, tempstring
        Input #NF, tempstring
    End If

    NextNo = -1

    Do While Not EOF(NF)
        Input #NF, tempstring
        Pos = InStr(1, tempstring, "[", vbBinaryCompare)

        If Pos > 0 Then
            NextNo = NextNo + 1
            PosN1 = InStr(Pos + 1, tempstring, " ", vbBinaryCompare)
            StraiName(NextNo) = Mid$(tempstring, Pos + 1, PosN1 - (Pos + 1))
        End If

        If tempstring = "matrix" Or tempstring = "MATRIX" Or tempstring = "Matrix" Then Exit Do
    Loop

    Do
        Input #NF, tempstring

        If tempstring <> Empty Then Exit Do
    Loop

    If left$(tempstring, 1) = "[" Then 'ie file is interleaved
        Pos = InStr(1, tempstring, "10", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(1, tempstring, "1", vbBinaryCompare)
        StartFrom = Pos - CDbl(Mid$(tempstring, Pos, 3))
        X = 0
        Do
            If InStr(1, tempstring, "]", vbBinaryCompare) > 0 Then
                Exit Do
            End If
            Input #NF, tempstring
        Loop
        Do While Not EOF(NF)
            Input #NF, tempstring
            
            If tempstring = ";" Then
                If X > 0 Then
                    NextNo = X - 1
                End If
                Exit Do
            End If
            If Mid$(tempstring, 1, 1) = "[" Then
                X = 0
                Do
                    If InStr(1, tempstring, "]", vbBinaryCompare) > 0 Then
                        Input #NF, tempstring
                        Exit Do
                    End If
                    Input #NF, tempstring
                Loop
            End If
            If tempstring = "" Then
                lTempString = tempstring
                
            End If
            If Mid$(tempstring, 1, 1) <> "[" And tempstring <> Empty Then
                If lTempString = "" Then
                    X = 0
                    lTempString = "xx"
                    'xxx = 'Len(StrainSeq(3))
                    If Len(StrainSeq(0)) > 3100 Then
                        X = X
                    End If
                End If
                If InStr(1, Trim(tempstring), " ", vbBinaryCompare) = 0 Then ' ie very long lines involved
                    X = X - 1
                    Trimmed = Trim(tempstring)
                Else
                    Trimmed = Trim$(Mid$(tempstring, StartFrom, Len(tempstring) - StartFrom + 1))
                End If
                Pos = InStr(1, Trimmed, " ", vbBinaryCompare)
                'zz = Len(Trimmed)
                If Pos = 0 Then
                    StrainSeq(X) = StrainSeq(X) + Trimmed
                Else
                    StrainSeq(X) = StrainSeq(X) + Trim$(left$(Trimmed, Pos))
                End If

                If StraiName(X) = "" Then StraiName(X) = Trim$(left$(tempstring, StartFrom - 1))
                X = X + 1
                If X = 40 Then
                    X = X
                End If
            ElseIf Mid$(tempstring, 1, 1) = "[" Then
                X = 0
            End If

            Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
        Loop

        If NextNo > -1 Then

            If X > 0 And StraiName(NextNo) <> "" Then

                If StraiName(X - 1) <> "" Then NextNo = X - 1
            End If

        End If

    ElseIf left$(tempstring, 1) = "'" Then 'ie file is interleaved

        Do While Not EOF(NF)

            If tempstring <> Empty And tempstring <> ";" Then
                NextNo = NextNo + 1

                Call SeqArrays

                Pos = InStr(3, tempstring, "'", vbBinaryCompare)

                If Pos > 0 Then
                    StraiName(NextNo) = Trim$(Mid$(tempstring, 2, Pos - 2))
                    'find out if there are gaps or tabs between the end of the name
                    'and the start of the sequence
                    Post = InStr(Pos, tempstring, Chr(9), vbBinaryCompare)
                    If Post > 0 Then
                        Do
                            Post = Post + 1
                            If Mid$(tempstring, Post, 1) <> Chr(9) Then Exit Do
                        Loop
                        StrainSeq(NextNo) = Trim$(Mid$(tempstring, Post, Len(tempstring) - (Post - 1)))
                        X = X
                    Else
                        StrainSeq(NextNo) = Trim$(Mid$(tempstring, Pos + 1, Len(tempstring) - Pos))
                    End If
                Else
                    StraiName(NextNo) = Trim$(Mid$(tempstring, 2, 15))
                    StrainSeq(NextNo) = Trim$(Mid$(tempstring, 15, Len(tempstring) - 15))
                End If

            Else
                Exit Do
            End If

            Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
            Line Input #NF, tempstring
        Loop

    ElseIf tempstring <> Empty Then 'ie file is non interleaved

        Do

            If tempstring <> Empty And tempstring <> ";" Then
                NextNo = NextNo + 1

                Call SeqArrays

                PosN1 = InStr(1, tempstring, " ", vbBinaryCompare)

                If PosN1 = 0 Then
                    PosN1 = InStr(1, tempstring, Chr(9), vbBinaryCompare)
                    If PosN1 = 0 Then
                        StraiName(NextNo) = Trim$(tempstring)
                        Input #NF, tempstring
                        PosN1 = InStr(1, tempstring, " ", vbBinaryCompare)
                    Else
                        StraiName(NextNo) = Mid$(tempstring, 1, PosN1 - 1)
                        X = X
                    End If
                Else
                    StraiName(NextNo) = Mid$(tempstring, 1, PosN1 - 1)
                End If

                X = PosN1

                Do
                    X = X + 1

                    If Mid$(tempstring, X, 1) <> " " And Mid$(tempstring, X, 1) <> Chr(9) Then
                        NumSpace = X - 1
                        Exit Do
                    End If

                Loop

                StrainSeq(NextNo) = right$(tempstring, Len(tempstring) - NumSpace)

                Do
                    Input #NF, tempstring
                    Pos = InStr(1, tempstring, " ", vbBinaryCompare)
                    
                    If Pos = 0 Then
                        Pos = InStr(1, tempstring, Chr(9), vbBinaryCompare)
                    End If
                    
                    If Pos > 0 Then Exit Do

                    If tempstring = Empty Then Exit Do

                    If tempstring = ";" Then Exit Do

                    If Len(tempstring) < Len(StrainSeq(0)) Then
                        NextNo = NextNo + 1
                        StraiName(NextNo) = Trim$(tempstring)
                        Input #NF, tempstring
                        StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
                    Else
                        StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
                    End If

                Loop

                If left$(tempstring, 1) = ";" Then Exit Do
            Else

                If tempstring = ";" Then Exit Do
                Input #NF, tempstring
            End If

            Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
        Loop

    End If

    Close #1
End Sub
Public Sub DoInterface()

    Dim X As Long, Tempsize As Long, Pict As Long, Bak As Long
    
    
    For X = 0 To NextNo
        Form3.Combo2.AddItem StraiName(X)
    Next X
    Form3.Combo2.ListIndex = 0
    Pict = Form1.hdc
    Bak = GetBkColor(Pict)
    Form1.Timer1.Enabled = False

    With Form1.Picture9
        .ScaleMode = 3
        .BackColor = BackColours
    End With

    With Form1.Picture1 'Sequence display
        .ScaleMode = 3
        .Height = (NextNo + 2) * 13 * TYF
        .Font.Name = "Courier New"
        .FontSize = 9.75 * TYF
        .Picture = LoadPicture()
        .ForeColor = 0
        .BackColor = BackColours
        .Enabled = True
    End With

    With Form1.Picture2 'Recombination Info window
        .ScaleMode = 3
        .Picture = LoadPicture()
        .BackColor = Bak
        .ForeColor = 0
        .Refresh
    End With

    With Form4.Picture2 'Compatibility matrix window
        .Picture = LoadPicture()
        .Width = 0
        .Refresh
    End With

    With Form1.Picture8
        .ScaleMode = 3
        .BackColor = BackColours
    End With

    With Form1.Picture3 'Sequence names
        
        .ScaleMode = 3
        .Picture = LoadPicture()
        .Height = (NextNo + 1) * 15 * TYF
        .MousePointer = 0
        .CurrentX = 0
        .CurrentY = 0
        .BackColor = BackColours
        .ForeColor = 0
        .AutoRedraw = True
        .Enabled = True
        .FontSize = 7 * TYF
    End With

    Form1.Label21.Caption = "Show All Sequences"
    ReDim Preserve MaskSeq(NextNo)
    Form1.Picture3.ScaleMode = 3
    
   
    tTYF = Form1.Picture3.FontSize / 6.75
        
      '  If Form1.Picture3.FontSize = 9.75 Then
      '      tTYF = tTYF * 1 '0.999
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 9# Then
      '      tTYF = tTYF * 0.947
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 8.25 Then
      '      tTYF = tTYF * 1.033
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 7.5 Then
      '      tTYF = tTYF * 0.975
      '      TYFM = 1
      '  ElseIf Form1.Picture3.FontSize = 6.75 Then
      '      tTYF = tTYF * 0.903
      '      TYFM = 3
      '  ElseIf Form1.Picture3.FontSize = 6# Then
      '      tTYF = tTYF * 1.014
      '      TYFM = -1
      '  ElseIf Form1.Picture3.FontSize = 5.25 Then
      '      tTYF = tTYF * 0.928
      '      TYFM = 1
       ' ElseIf Form1.Picture3.FontSize = 4.5 Then
       '     tTYF = tTYF * 1.081
      '      TYFM = -1
      '  ElseIf Form1.Picture3.FontSize = 3.75 Then
      '      tTYF = tTYF * 0.974
      '      TYFM = 0
      '  End If
    Call PrintNames

    'Form1.Refresh

    With Form4.Picture3 'Hidden compatibility matrix window
        '.Picture = LoadPicture()
        .Height = 0
        .Width = 0
        .Height = 0
    End With

    With Form1.Picture4 'Homology display
        .Picture = LoadPicture()
        .Refresh
    End With

    Form1.Picture5.ScaleMode = 3
    Form1.Picture5.BackColor = Bak
    With Form1.Picture6 'Unique sequence schematic sequence display
        .ScaleMode = 3
        .ScaleHeight = Form1.Picture5.Height
        .Picture = LoadPicture()
        .BackColor = Bak
    End With

    With Form1.Picture7 'Plot display (inner)
        .Picture = LoadPicture()
        .Top = 0
        .Height = Form1.Picture10.ScaleHeight
        .Top = -1
        .Enabled = False
        .BackColor = Bak
    End With

    Form1.Picture9.BackColor = BackColours
    Form1.Picture10.ForeColor = 0

    With Form1.Picture10 'Plot display (outer)
        .Picture = LoadPicture()
        .BackColor = Bak
    End With

    

    With Form1.Picture11 'Homology display
        .Picture = LoadPicture()
        .BackColor = Rejected
    End With

    Form1.Picture12.BackColor = BackColours
    Form1.Picture13.BackColor = BackColours
    Form1.Picture13.ForeColor = 0

    With Form1.Picture14
        .ScaleMode = 3
        .BackColor = BackColours
    End With

    Form1.Picture16.ScaleMode = 3

    With Form1.Picture16 'Tree display
        .Picture = LoadPicture()
        .BackColor = Bak
        .ScaleMode = 3
        'Tempsize = (Nextno + 12) * 14

        'If Tempsize < 32767 Then
        '    .Height = (Nextno + 12) * 14
        'Else
        '    .Height = 32767
        'End If

        'TRegion = 0.8 * .Width
    End With

    If Form1.Picture16.ScaleHeight < ((NextNo + 6) * 15 * TYF2) Then
        Form1.VScroll1.Max = -Form1.Picture16.ScaleHeight + (NextNo + 10) * 14 * TYF2
        Form1.VScroll1.SmallChange = 5
        Form1.VScroll1.LargeChange = Form1.Picture16.ScaleHeight
        Form1.VScroll1.Enabled = True
    Else
        Form1.VScroll1.Value = 0
        Form1.VScroll1.Enabled = False
    End If


    For X = 0 To 3

        If (NextNo + 6) * 15 * TYF2 <= Form2.Picture2(X).ScaleHeight Then
            Form2.VScroll1(X).Enabled = False
        Else
            Form2.VScroll1(X).Max = -Form2.Picture2(X).ScaleHeight + (NextNo + 6) * 15
            Form2.VScroll1(X).LargeChange = Form2.Picture2(X).ScaleHeight
            Form2.VScroll1(X).SmallChange = 5
            Form2.VScroll1(X).Enabled = True
        End If

    Next 'X


    Form1.Picture19.Picture = LoadPicture() 'Hidden ORF picture
    Form1.Picture19.BackColor = BackColours

    With Form1.Picture20 'ORF picture
        .Picture = LoadPicture()
        .Visible = False
        .BackColor = BackColours
    End With

    With Form1.Picture21 'Background plot picture
        .AutoRedraw = True
        .ScaleMode = 3
        .AutoSize = False
        .Width = Form1.Picture10.ScaleWidth
        .Height = Form1.Picture10.ScaleHeight + 25
        .Visible = False
        .BackColor = BackColours
    End With

    
    If RETFlag < 3 Then
        Form1.Picture26.Picture = LoadPicture() 'Small compatibility matrix window

        With Form1.Picture27 'Large compatibility matrix window
            '.Picture = LoadPicture()
            .Width = 0
            .Height = 0
        End With

    End If

    For X = 0 To 3
        Form2.Picture2(X).ScaleMode = 3
    Next 'X

    With Form1.VScroll3 'Sequence display scrollbar
        .Max = -Form1.Picture9.ScaleHeight + Form1.Picture1.Height

        If .Max <= 0 Then
            .Enabled = False
        Else
            .LargeChange = Form1.Picture9.ScaleHeight
            .Enabled = True
        End If

    End With

    With Form1.SSPanel16
        .Caption = ""
        .BackColor = HalfColour
    End With

    With Form1.Combo1
        .Clear
        .BackColor = Bak
        .ForeColor = 0
        .Enabled = False
    End With

    ShowSeqFlag = 0
    FullWindowSize = Int(Len(StrainSeq(0)) / 100)
    'Enable Command Buttons

    With Form1.Command22
        .Enabled = True            'Enable "X-Over" button
        .left = 175 * Screen.TwipsPerPixelX
        .Width = 70 * Screen.TwipsPerPixelX
    End With
    
    With Form1.Command33
        .Enabled = True            'Enable "-" button
    End With
    With Form1.Command34
        .Enabled = True            'Enable "+" button
    End With
   
    
    Form1.Command35.Enabled = True
    Form1.Command36.Enabled = True
    Form1.Command16.Visible = True

    With Form1.Command7
        .Enabled = True              'Enable "Draw Tree" button
        .Width = 70 * Screen.TwipsPerPixelX
    End With
    With Form1.Command38
        .Enabled = True              'Enable "Draw Tree" button
        .Width = 70 * Screen.TwipsPerPixelX
    End With
    Form1.Command11.Visible = True
    Form1.Command37.Visible = True
    Form1.Command13(0).Enabled = True            'Enable "Show UPGMA Tree " buttons
    Form1.Command13(1).Enabled = True
    Form1.Command8(0).Enabled = True            'Enable "Show Recombination Info" buttons
    Form1.Command8(1).Enabled = True
    Form1.Command4(0).Enabled = True            'Enable "Show Compatibility Matrix" buttons
    Form1.Command4(1).Enabled = True
    'DIsable command buttons
    Form1.Command14.Enabled = False
    'Form1.Command35.Enabled = False
    'Form1.Command36.Enabled = False
    Form1.Command17.Enabled = False
    Form1.Command9.Enabled = False
    Form1.Command5.Enabled = False
    Form1.Command10.Enabled = False
    Form1.Command30.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Frame17.Visible = False

    With Form1.Command18
        .Enabled = False             'Disable "save" button
        .Width = 85 * Screen.TwipsPerPixelX
    End With

    Form1.Command23.Visible = False
    'Close forms
    Form4.Visible = False
    Form2.Visible = False
    'Enable/disable Panels
    Form1.SSPanel4.Enabled = True
    Form1.SSPanel5.Enabled = False
    Form1.SSPanel3.Enabled = True
    Form1.SSPanel4.Enabled = True
    Form1.SSPanel5.Enabled = True
    Form1.SSPanel6(0).Enabled = True
    Form1.SSPanel6(0).Visible = True
    Form1.SSPanel6(1).Visible = False
    Form1.SSPanel6(2).Visible = False
    Form1.SSPanel8.Enabled = True

    If RunFlag = 0 Then
        Form1.Label58.Caption = ""
        Form1.Command29.Enabled = False
        Form1.Frame7.Enabled = False
        Form1.SSPanel5.Enabled = False
        Form1.HScroll2.Enabled = False
        Form1.VScroll2.Enabled = False
    End If

    Form1.VScroll2.SmallChange = 13
    Form1.Caption = "Recombination Detection Program v. 1.0" & CStr(App.Revision) + ":  " + FName$
    ReDim SYPos(NextNo)
    ReDim UYPos(NextNo)
    ReDim Selected(NextNo)

    With Form5.Combo1
        .AddItem "None", 0

        For X = 0 To NextNo
            .AddItem StraiName(X), X + 1
        Next 'X

    End With

    For X = 0 To 3
        Form2.Picture2(X).BackColor = BackColours
    Next 'X
    For X = 0 To 3
        For Y = 0 To 3
            DoneTree(X, Y) = 0
        Next Y
    Next 'X
    Form5.Combo1.ListIndex = 0
    Form5.Picture1.Height = NextNo * 13 * Screen.TwipsPerPixelY
    Form5.Picture2.Height = NextNo * 13 * Screen.TwipsPerPixelY
    'Form1.Refresh
End Sub
Public Sub LoadAlignX()

    Dim tempstring As String
    Dim LastPos As Long, PosN As Long, Pos2 As Long, Pos3 As Long

    Form1.SSPanel1.Caption = "Loading AligntX File"
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, tempstring

    If Len(tempstring) > LOF(NF) * 0.5 Then
        Close #NF
        LastPos = 1

        Do
            Pos = InStr(LastPos, tempstring, "obj|I", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 2
            Else
                Exit Do
            End If

        Loop

        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, tempstring
        Close #NF
        Open "tempfile" For Input Access Read As #NF
    Else
        Close #NF
        Open FName$ For Input Access Read As #NF
    End If

    NextNo = -1
    Form1.ProgressBar1.Value = 20

    Do While Not EOF(NF)
        Line Input #NF, tempstring
        PosN = InStr(1, tempstring, "IxAlignment", vbBinaryCompare)

        If PosN > 0 Then
            NextNo = NextNo + 1

            Call SeqArrays

            Pos2 = InStr(PosN + 11, tempstring, ":", vbBinaryCompare)
            Pos3 = InStr(Pos2, tempstring, "|", vbBinaryCompare)
            StrainSeq(NextNo) = Mid$(tempstring, Pos2 + 1, Pos3 - 1 - Pos2)
            StraiName(NextNo) = Mid$(tempstring, Pos3 + 1, Len(tempstring) - Pos3)
        End If

    Loop

    Close #NF
End Sub
Public Sub LoadFormatX()

    Dim tempstring As String

    Open FName$ For Input Access Read As #1
    Form1.SSPanel1.Caption = "Loading Mega File"
    NextNo = -1
    Form1.ProgressBar1.Value = 20

    Do While Not EOF(1)
        Input #1, tempstring

        If Mid$(tempstring, 1, 4) = "name" Then
            NextNo = NextNo + 1

            Call SeqArrays

            Form1.ProgressBar1.Value = 20 + ((Len(StrainSeq(0)) * NextNo) / LOF(1)) * 100 * 0.75
            StraiName(NextNo) = Mid$(tempstring, 7, Len(tempstring) - 7)
        ElseIf Mid$(tempstring, 1, 8) = "sequence" And Mid$(tempstring, 1, 9) <> "sequence-" Then

            Do
                Input #1, tempstring

                If Mid$(tempstring, 1, 1) = "}" Then Exit Do
                StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
            Loop

            StrainSeq(NextNo) = Mid$(StrainSeq(NextNo), 1, Len(StrainSeq(NextNo)) - 1)
            posseqa = InStr(1, StrainSeq(NextNo), "a", vbBinaryCompare)
            posseqb = InStr(1, StrainSeq(NextNo), "A", vbBinaryCompare)

            If posseqa = 0 And posseqb = 0 Then
                StrainSeq(NextNo) = ""
                NextNo = NextNo - 1
            End If

        End If

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    Close #1
End Sub
Public Sub LoadGDE()

    Dim tempstring As String, FileLength As Long, LastPos As Long

    Form1.SSPanel1.Caption = "Loading GDE File"
    Open FName$ For Input Access Read As #1
    NextNo = -1
    Form1.ProgressBar1.Value = 20
    FileLength = LOF(1)

    Do While Not EOF(1)
        Input #1, tempstring

        If Len(tempstring) > LOF(1) * 0.5 Then
            Close #1
            LastPos = 1

            Do
                'Pos = InStr$(lastpos, TempString, chr$(10), vbBinaryCompare)
                'upyours = chr$(10)
                Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

                If Pos > 0 Then
                    Mid$(tempstring, Pos, 1) = Chr$(13)
                    LastPos = Pos + 2
                Else
                    Exit Do
                End If

            Loop

            Open "tempfile" For Output As #1
            SaveFlag = 1
            Print #1, tempstring
            Close #1
            Open "tempfile" For Input Access Read As #1
            Line Input #1, tempstring
            'GoTo Specialcase  'ie if no carriage returns are used you're screwed buddy
        End If

        If Mid$(tempstring, 1, 1) = "#" Then
            NextNo = NextNo + 1

            Call SeqArrays

            Form1.ProgressBar1.Value = 20 + ((Len(StrainSeq(0)) * NextNo) / FileLength) * 100 * 0.75
            StraiName(NextNo) = Mid$(tempstring, 2, Len(tempstring) - 1)
        Else
            StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
            'B = Len(StrainSeq(10))
        End If

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    Close #1
End Sub
Public Sub LoadMeg()

    Dim tempstring As String, FileLength As Long, LastPos As Long

    Form1.SSPanel1.Caption = "Loading GDE File"
    Open FName$ For Input Access Read As #1
    NextNo = -1
    Form1.ProgressBar1.Value = 20
    FileLength = LOF(1)

    Do While Not EOF(1)
        Input #1, tempstring

        If Len(tempstring) > LOF(1) * 0.5 Then
            Close #1
            LastPos = 1

            Do
                'Pos = InStr$(lastpos, TempString, chr$(10), vbBinaryCompare)
                'upyours = chr$(10)
                Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

                If Pos > 0 Then
                    Mid$(tempstring, Pos, 1) = Chr$(13)
                    LastPos = Pos + 2
                Else
                    Exit Do
                End If

            Loop

            Open "tempfile" For Output As #1
            SaveFlag = 1
            Print #1, tempstring
            Close #1
            Open "tempfile" For Input Access Read As #1
            Line Input #1, tempstring
            'GoTo Specialcase  'ie if no carriage returns are used you're screwed buddy
        End If
        If tempstring <> "#mega" And tempstring <> "#MEGA" Then
            If Mid$(tempstring, 1, 1) = "#" Then
                NextNo = NextNo + 1
                If Len(tempstring) < 14 Then
                    If StraiName(NextNo) = "" Then
                        Call SeqArrays
            
                        Form1.ProgressBar1.Value = 20 + ((Len(StrainSeq(0)) * NextNo) / FileLength) * 100 * 0.75
                        
                        StraiName(NextNo) = Mid$(tempstring, 2, Len(tempstring) - 1)
                        
                    End If
                Else
                    If StraiName(NextNo) = "" Then
                        StraiName(NextNo) = Trim$(Mid$(tempstring, 2, 14))
                    End If
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(Mid$(tempstring, 15, Len(tempstring) - 15))
                End If
            ElseIf NextNo > -1 And tempstring = "" Then
                oNextno = NextNo
                NextNo = -1
            ElseIf NextNo > -1 Then
                StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
                'B = Len(StrainSeq(10))
            End If
        
        End If
        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop
    NextNo = oNextno
    Close #1
End Sub
Public Sub LoadPhylip()

    Dim NF As Integer, NoSpaceInFileFlag As Integer, NoSpaceBetweenGroupsFlag As Integer, SequentialFlag As Integer, SpaceInFileFlag As Integer, IsSeq As Integer
    Dim LastPos As Long, PosN1 As Long, X As Long, Y As Long
    Dim tempstring As String, NameCheck As String

    'On Error GoTo UnknownFormat
    Form1.SSPanel1.Caption = "Loading Phylip File"
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, tempstring

    If Len(tempstring) > LOF(NF) * 0.5 Then
        Close #NF
        LastPos = 1
        Form1.SSPanel1.Caption = "Reformatting Sequence File"
        Do
            Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 1
            Else
                Exit Do
            End If

        Loop

        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, tempstring
        Close #NF
        Open "tempfile" For Input Access Read As #NF
        NoSpaceBetweenGroupsFlag = 1
    Else
        Close #NF
        Open FName$ For Input Access Read As #NF
    End If

    NextNo = -1
    SequentialFlag = 0
    SpaceInFileFlag = 0
    Line Input #NF, tempstring
    
    Dim tNextno As Long
    
    Dim Z As Long
    
    Z = 1
    Do While Z < Len(tempstring)
        If Mid(tempstring, Z, 1) <> " " Then
            Exit Do
        End If
        Z = Z + 1
    Loop
    Pos = InStr(Z, tempstring, " ", vbBinaryCompare)
    If Pos = 0 Then Exit Sub
    tNextno = CLng(Trim(left$(tempstring, Pos)))
    
    
    
    Do While Not EOF(NF)
        Line Input #NF, tempstring

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then
            Exit Do
        End If

        If tempstring <> Empty Then
            NextNo = NextNo + 1

            Call SeqArrays

            PosN1 = InStr(8, tempstring, " ", vbBinaryCompare)

            If PosN1 > 1 Then
                StraiName(NextNo) = Trim$(Mid$(tempstring, 1, PosN1 - 1))
                
            ElseIf left$(tempstring, 10) <> "          " Then
                NameCheck = left$(tempstring, 10)
                IsSeq = 0

                For X = 1 To 10

                    If Mid$(NameCheck, X, 1) = " " Or Mid$(NameCheck, X, 1) = "A" Or Mid$(NameCheck, X, 1) = "C" Or Mid$(NameCheck, X, 1) = "G" Or Mid$(NameCheck, X, 1) = "T" Or Mid$(NameCheck, X, 1) = "-" Or Mid$(NameCheck, X, 1) = "." Then
                        IsSeq = IsSeq + 1
                    End If

                Next 'X

                If IsSeq < 10 Then ' its a name!!!
                    StraiName(NextNo) = Trim$(NameCheck)
                    SequentialFlag = 1
                Else
                    NextNo = NextNo - 1
                    StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
                    Exit Do
                End If

            ElseIf left$(tempstring, 10) = "          " Then
                NextNo = NextNo - 1

                If NoSpaceBetweenGroupsFlag = 1 Then Exit Do
            Else
                NoSpaceInFileFlag = 1
                NextNo = NextNo - 1
                Exit Do
            End If

            If tempstring <> "" And Len(tempstring) < 15 Then
                SequentialFlag = 1
                StraiName(NextNo) = Trim$(tempstring)
            ElseIf Mid$(tempstring, 11 + 11, 1) = " " And SequentialFlag = 0 Then

                For Y = 0 To 4
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(tempstring, 12 + Y * 10 + Y, 10)
                Next 'Y

                SpaceInFileFlag = 1
            Else
                tempstring = right$(tempstring, Len(tempstring) - Len(StraiName(NextNo)))
                tempstring = Trim$(tempstring)
                StrainSeq(NextNo) = StrainSeq(NextNo) + tempstring
                StraiName(NextNo) = Trim$(StraiName(NextNo))
            End If

        ElseIf NextNo = tNextno - 1 Then
            Exit Do
        End If

    Loop

    Dim NewNameFlag As Integer

    NewNameFlag = 0
    X = -1
    Form1.ProgressBar1.Value = 20

    Do While Not EOF(NF)

        If NoSpaceInFileFlag = 0 And NoSpaceBetweenGroupsFlag = 0 Then
            Input #NF, tempstring
        Else
            NoSpaceInFileFlag = 0
            NoSpaceBetweenGroupsFlag = 0
        End If

        Pos = InStr(1, tempstring, " ", vbBinaryCompare)

        If SequentialFlag = 1 Or (Len(tempstring) < 11 And NextNo < 1) Then
            Pos = InStr(1, tempstring, " ", vbBinaryCompare)

            If SequentialFlag = 0 Then
                SequentialFlag = 1
                NextNo = NextNo + 1
                StraiName(NextNo) = Trim$(tempstring)
            ElseIf Pos > 0 Then

                If NewNameFlag = 1 Then

                    If NextNo > 0 Then
                        StrainSeq(NextNo - 1) = StrainSeq(NextNo - 1) + StraiName(NextNo)
                    End If

                    StraiName(NextNo) = Trim$(right$(tempstring, Len(tempstring) - Pos))
                Else
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(left$(tempstring, Pos))
                    NextNo = NextNo + 1
                    StraiName(NextNo) = Trim$(right$(tempstring, Len(tempstring) - Pos))
                    NewNameFlag = 1
                End If

            ElseIf Len(tempstring) < 11 And tempstring > "" Then

                If NewNameFlag = 1 Then

                    If NextNo > 0 Then
                        StrainSeq(NextNo - 1) = StrainSeq(NextNo - 1) + StraiName(NextNo)
                    End If

                    StraiName(NextNo) = Trim$(right$(tempstring, Len(tempstring) - Pos))
                Else
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(left$(tempstring, Pos))
                    NextNo = NextNo + 1
                    StraiName(NextNo) = Trim$(right$(tempstring, Len(tempstring) - Pos))
                    NewNameFlag = 1
                End If

            Else
                NewNameFlag = 0
                StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(tempstring)
            End If

        Else
            

            If tempstring <> Empty Then
                X = X + 1
                If SpaceInFileFlag = 1 Then
                    tempstring = Trim$(tempstring)

                    For Y = 0 To 4
                        StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, 1 + Y * 10 + Y, 10)
                    Next 'Y

                    If X = NextNo Then X = -1
                Else
                    tempstring = Trim$(tempstring)
                    StrainSeq(X) = StrainSeq(X) + tempstring

                    If X = NextNo Then X = -1
                End If

            Else
                Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
                If X = NextNo Then
                    X = -1
                End If
            End If

        End If

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    If StrainSeq(NextNo) = "" Then
        NextNo = NextNo - 1
        StrainSeq(NextNo) = StrainSeq(NextNo) + StraiName(NextNo + 1)
    End If

    Close #NF
    
    On Error GoTo 0
    'check to see if spaces have been included
    SLen = Len(StrainSeq(0))
    If Mid$(StrainSeq(0), 11, 1) = " " Then
        For Y = 0 To NextNo
            tempstring = ""
            For X = 2 To SLen
                Pos = InStr(X, StrainSeq(Y), " ", vbBinaryCompare)
                If Pos = 0 Then Exit For
                tempstring = tempstring + Mid$(StrainSeq(Y), X - 1, Pos - X + 1)
                X = Pos + 1
                LastPos = Pos
            Next 'X
            tempstring = tempstring + Trim$(right$(StrainSeq(Y), SLen - LastPos))
            StrainSeq(Y) = tempstring
        Next 'Y
    End If
    Exit Sub
UnknownFormat:
    '    MsgBox ("I could not recognise this DNA alignment file format" + chr$(13) + "Send it as an attatchment to darren@molbiol.uct.ac.za")
    ErrorFlag = 1
    Screen.MousePointer = 0
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Close #NF
End Sub
Public Sub LoadMSF()

    Dim NF As Integer, SeqStart As Integer, CLen As Integer
    Dim LastStartPos As Long, StartPos As Long, LastPos As Long, CHK As Long, X As Long
    Dim tempstring As String, CK As String

    NextNo = -1
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, tempstring

    If Len(tempstring) = LOF(NF) Then
        Close #NF
        LastPos = 1
        Form1.SSPanel1.Caption = "Reformatting Sequence File"

        Do
            Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 2
                Form1.ProgressBar1.Value = (LastPos / (Len(tempstring) + 2)) * 100
            Else
                Exit Do
            End If

        Loop

        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, tempstring
        Close #NF
        Open "tempfile" For Input Access Read As #NF
        Line Input #NF, tempstring
    End If

    Form1.SSPanel1.Caption = "Loading MSF File"

    Do Until tempstring = "//"
        Input #NF, tempstring
    Loop

    Do Until Val(tempstring) > 0
        Input #NF, tempstring
    Loop

    CLen = 4

    
    Do
        Input #NF, tempstring
        
        XX = Val(tempstring)
        If (Val(tempstring) = 0 Or Len(tempstring) > 6) And tempstring <> "" Then
            NextNo = NextNo + 1

            LastStartPos = Pos + 1
            StartPos = 0

            Do Until StartPos > 0
                StartPos = InStr(LastStartPos, tempstring, "  ", vbBinaryCompare)
                LastStartPos = LastStartPos + 1
            Loop
            
            Call SeqArrays

            StraiName(NextNo) = Trim(Mid$(tempstring, 1, StartPos - 1))
            tempstring = Trim(right$(tempstring, Len(tempstring) - (StartPos)))
            XPos = 1
                    Do
                        XPos = InStr(1, tempstring, " ", vbBinaryCompare)
                        If XPos > 0 Then
                            tempstring = left(tempstring, XPos - 1) + right(tempstring, Len(tempstring) - XPos)
                        Else
                        
                            Exit Do
                        End If
                    Loop
            StrainSeq(NextNo) = tempstring
            XX = X
        Else
            Exit Do
        End If

        
    Loop

    Form1.ProgressBar1.Value = 20

    Do While Not EOF(NF)
        Input #NF, tempstring

        If tempstring <> Empty And (Val(tempstring) = 0 Or Len(tempstring) > 6) Then
            X = -1

            Do
                Pos = InStr(1, tempstring, "  ", vbBinaryCompare)

                If (Val(left(tempstring, 2)) = 0 And Len(tempstring) > 6) And tempstring <> Empty Then
                    X = X + 1
                    XPos = 1
                    tempstring = Trim(right$(tempstring, Len(tempstring) - (Pos)))
                    Do
                        XPos = InStr(1, tempstring, " ", vbBinaryCompare)
                        If XPos > 0 Then
                            tempstring = left(tempstring, XPos - 1) + right(tempstring, Len(tempstring) - XPos)
                        Else
                        
                            Exit Do
                        End If
                    Loop
                    StrainSeq(X) = StrainSeq(X) + tempstring
                Else
                    If Val(left(tempstring, 2)) = 0 Then
                        Exit Do
                    End If
                End If
                

                Input #NF, tempstring
            Loop

        End If

        xxx = Loc(NF)
        
        Form1.ProgressBar1.Value = (xxx / LOF(NF)) * 100

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    If NextNo > -1 Then

        If StraiName(NextNo) = "" Then NextNo = NextNo - 1
    End If

    Close #NF
End Sub
Public Sub LoadRDP(Response, SNNextNo, AdjustAlign() As Long)

    Dim AddNumX As Long, oSEventNumber As Long, oEventNumber As Long, xFName As String, FF As Long, Hold As Byte, MaxList As Long, X As Long, Y As Long, PosGB As Long, DistLeft As Long, PosStart As Long
    Dim ODir As String, recomb As String, TString As String, Crap As String, PO As String, GO As String, MO As String
    If SNNextNo = -1 Then SNNextNo = 0
    SaveFlag = 1
    AddNumX = AddNum
    If Response <> 6 Then
        ReDim Preserve CurrentXover(NextNo + 1)
        ReDim Preserve XOverSeq(NextNo + 2)
    Else
        ReDim CurrentXover(NextNo + 1)
        ReDim XOverSeq(NextNo + 2)
    End If
    Close #1
    
    

    Open FName$ For Binary Access Read As #1
    If Response <> 6 Then
        Get #1, 1, Hold 'Len(StrainSeq(NextNo)) * (NextNo - SNNextNo), Hold
    Else
        Get #1, Len(StrainSeq(0)) * (NextNo), Hold
    End If
    Do
        Line Input #1, recomb$

        If recomb$ = "GB Data" Then
            
            SeqFile = ""
            xFName$ = "tGBFile"
            Open xFName$ For Output As #2
            TLen = 0
            Do While Not EOF(1)
                Line Input #1, recomb$
        
                If recomb$ = "Recombination Data" Or Mid(recomb$, 2, 18) = "Recombination Data" Or recomb$ = "//" Then
                    If Response <> 6 Then
                        Get #1, 1, Hold
                    Else
                        Get #1, Len(StrainSeq(0)) * (NextNo), Hold
                    End If
                    Exit Do
                End If
                Print #2, recomb$
                TLen = TLen + Len(recomb$)
            Loop
            Close #2
            
            
            If TLen > 200 Then
                Open xFName$ For Binary Access Read As #2
                SeqFile = String$(LOF(2), " ")
                Get #2, 1, SeqFile
                Close #2
                Call LoadGenBank
                GBFile = SeqFile
                
            End If
            Kill xFName$
            If recomb$ = "Recombination Data" Or Mid(recomb$, 2, 18) = "Recombination Data" Or recomb$ = "//" Then
                If Response <> 6 Then
                    Get #1, 1, Hold
                Else
                    Get #1, Len(StrainSeq(0)) * (NextNo), Hold
                End If
                Exit Do
            End If
        ElseIf EOF(1) = True Then
            If Response <> 6 Then
                Get #1, 1, Hold
            Else
                Get #1, Len(StrainSeq(0)) * (NextNo), Hold
            End If
            Exit Do
        End If
    Loop
    Do 'While recomb$ <> "Recombination Data" And Mid(recomb$, 2, 18) <> "Recombination Data"
        Input #1, recomb$

        If recomb$ = "Recombination Data" Then Exit Do
    Loop

    Input #1, TString
    If TString = "r13" Or TString = "r8" Or TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then
        AddNumX = 7
    ElseIf TString = "r14" Then
        
        AddNumX = 8
    End If
    If TString = "r14" Or TString = "r13" Or TString = "r8" Or TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then  ' is  revision 8 or 9 or 10
        Form1.SSPanel1.Caption = "Loading Recombination Data"
        Form1.ProgressBar1.Value = 5
        
        ReDim GCImageIndex(NextNo + 1, NextNo + 1)
        ReDim RevGCIndex1(10)
        ReDim RevGCIndex2(10)
        ReDim MinP(NextNo, NextNo)
        Dim F1(4) As String
        'Load settings
        Input #1, SpacerFlag, CircularFlag, ShowPlotFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
        Input #1, GCSeqTypeFlag, GCIndelFlag, GCCodeFlag, GCtripletflag
        Input #1, GCOutfileName
        Input #1, GCOutFlag, GCOutFlagII, GCSortFlag, GCEndLen, GCLogFlag
        Input #1, GCMissmatchPen, GCMaxGlobFrags, GCMaxPairFrags, GCMinFragLen, GCMinPolyInFrag
        Input #1, GCMinPairScore, GCMaxOverlapFrags, GCNumPerms, GCMaxPermPVal, GCPermPolyFlag
        Input #1, BSStepWin, BSStepSize, BSCutOff, BSBootReps, BSRndNumSeed, BSSubModelFlag
        Input #1, BSTTRatio, BSCStepWin, BSCStepSize, BSCBootReps, MatPermNo
        Input #1, BSCDecreaseStepFlag, BSCDStepSize, BSCDStepWin, MatWinSize, BSCDSpan
        Input #1, MCPerms, MCPermMaxP, MCSteplen, MCWinSize
        Input #1, RDPFlag, GENECONVFlag, BOOTSCANFlag, MaxChiFlag, ChimaeraFlag, SiScanFlag
        Input #1, F1(1), F1(2), F1(3), F1(4)
        Input #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
        Input #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
        Input #1, MCWinFract, MCProportionFlag, MCTripletFlag, MCStripGapsFlag, MCFullOR, MCFullOL
        Input #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
        Input #1, RetSiteFlag, RetNumMatrixFlag
        Input #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
        Input #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
        Input #1, TOTreeType, TOFreqFlag, TOModel
        Input #1, BSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
        Input #1, BSCTypeFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
        Input #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
        Input #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
        If TString = "r9" Then
            Input #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag
        Else
            Input #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, BSPValFlag, SSFastFlag, SSGapFlag, SSVarPFlag, SSOutlyerFlag, SSRndSeed, SSWinLen, SSStep, SSNumPerms, SSNumPerms2
            Input #1, ForcePhylE, PolishBPFlag, Realignflag, ConsensusProg, CWinFract, CProportionFlag, CWinSize, CPerms, CPermMaxP
            If TString = "r14" Or TString = "r10" Or TString = "r11" Or TString = "r12" Or TString = "r13" Then
                Input #1, PPWinLen, pPPStripGaps, IncSelf, PPSeed, PPPerms, PhylProFlag
            End If
        End If
        
        If MatPermNo = 0 Then
            MatPermNo = 100
            MatWinSize = 200
        End If
    
        BOOTSCANFlag = 0
        pChimaeraFlag = ChimaeraFlag
        pSiScanFlag = SiScanFlag
        pRDPFlag = RDPFlag
        pGENECONVFlag = GENECONVFlag
        pBOOTSCANFlag = BOOTSCANFlag
        pMaxChiFlag = MaxChiFlag
        pBSPValFlag = BSPValFlag
        
        
        
        ReDim Preserve ProgF(100)

        For X = 0 To 6 + AddNumX
            ProgF(X) = 1
        Next 'X

        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Dim oMCCorrection As Long, PVHold As Double
        oMCCorrection = MCCorrection
        Input #1, MCCorrection
        If Response <> 6 Then
            Dim PValCon As Double
            If MCCorrection < oMCCorrection Then
                PValCon = oMCCorrection / MCCorrection
                MCCorrection = oMCCorrection
            Else 'convert current p-vals
                For X = 0 To SNNextNo - 1
                    PValCon = MCCorrection / oMCCorrection
                    For Y = 1 To CurrentXover(X)
                        XOverList(X, Y).Probability = XOverList(X, Y).Probability * PValCon
                    Next Y
                    For Y = 1 To BCurrentXoverMi(X)
                        BestXOListMi(X, Y).Probability = BestXOListMi(X, Y).Probability * PValCon
                    Next Y
                    
                    For Y = 1 To BCurrentXoverMa(X)
                        BestXOListMa(X, Y).Probability = BestXOListMa(X, Y).Probability * PValCon
                    Next Y
                    
                Next X
                For X = 1 To SEventNumber
                    For Y = 0 To AddNumX - 1
                        If Confirm(X, Y) <> 0 Then
                            
                            PVHold = ConfirmP(X, Y) / Confirm(X, Y)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmP(X, Y) = -Log10(PVHold) * Confirm(X, Y)
                        End If
                        If ConfirmMi(X, Y) <> 0 Then
                            
                            PVHold = ConfirmPMi(X, Y) / ConfirmMi(X, Y)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMi(X, Y) = -Log10(PVHold) * ConfirmMi(X, Y)
                        End If
                        
                        If ConfirmMa(X, Y) <> 0 Then
                            
                            PVHold = ConfirmPMa(X, Y) / ConfirmMa(X, Y)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMa(X, Y) = -Log10(PVHold) * ConfirmMa(X, Y)
                        End If
                    Next Y
                Next X
                'BestXOListMi(X, Y).Probability = BestXOListMi(X, Y).Probability * PValCon
                PValCon = 1
            End If
        Else
            PValCon = 1
        End If
        NumberOfSeqs = -1
        
        For X = SNNextNo To NextNo
            Input #1, MaskSeq(X)
            If MaskSeq(X) = 0 Then
                NumberOfSeqs = NumberOfSeqs + 1
            End If
        Next 'X

        If GENECONVFlag = 1 And GCtripletflag = 0 Then

            Call GCFindSites

        End If
        If Response = 6 Then
            oMCCorrection = MCCorrection
            Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
            MCCorrection = oMCCorrection
        End If
        ReDim pMaskSeq(NextNo)

        For X = 0 To NextNo
            pMaskSeq(X) = MaskSeq(X)
        Next 'X
    
        'store variable states at start of analysis
        MCFullFile = App.Path & "\maxchiout"
        pMCTripletFlag = MCTripletFlag
        pMCProportionFlag = MCProportionFlag
        pMCPerms = MCPerms
        pMCPermMaxP = MCPermMaxP
        pMCStart = MCStart
        pMCEnd = MCEnd
        pMCMaxP = MCMaxP
        pMCSteplen = MCSteplen
        pMCWinSize = MCWinSize
        pMCWinFract = MCWinFract
        pMCStripGapsFlag = MCStripGapsFlag
        pMCFlag = MCFlag
        pXOverWindowX = XOverWindowX
        pCircularFlag = CircularFlag
        pSpacerFlag = SpacerFlag
        pLowestProb = LowestProb
        pBSTypeFlag = BSTypeFlag
        pBSStepSize = BSStepSize
        pBSStepWin = BSStepWin
        pBSBootReps = BSBootReps
        pBSCutoff = BSCutOff
        pSSGapFlag = SSGapFlag
        pSSVarPFlag = SSVarPFlag
        pSSOutlyerFlag = SSOutlyerFlag
        pSSRndSeed = SSRndSeed
        pSSWinLen = SSWinLen
        pSSStep = SSStep
        pSSNumPerms = SSNumPerms
        pSSNumPerms2 = SSNumPerms2
        pGCTripletflag = GCtripletflag
        pGCMissmatchPen = GCMissmatchPen
        pGCIndelFlag = GCIndelFlag
        pGCMinFragLen = GCMinFragLen
        pGCMinPolyInFrag = GCMinPolyInFrag
        pGCMinPairScore = GCMinPairScore
        pGCMaxOverlapFrags = GCMaxOverlapFrags
        pCWinFract = CWinFract
        pCProportionFlag = CProportionFlag
        pCWinSize = CWinSize
        pCPerms = CPerms
        pCPermMaxP = CPermMaxP
        pSSFastFlag = SSFastFlag
        pPPStripGaps = PPStripGaps
        ReDim ShowAllHits(NextNo)
        ReDim SubSetF(NextNo)
        ReDim SubSetR(NextNo + 1)
        ReDim SubMaskSeq(NextNo + 1)
        IncludeSeq = 0

        For X = 0 To NextNo

            If MaskSeq(X) < 2 Then
                SubSetF(X) = IncludeSeq
                SubSetR(IncludeSeq) = X
                SubMaskSeq(IncludeSeq) = X
                IncludeSeq = IncludeSeq + 1
            End If

        Next 'X

        Input #1, Crap
        

        For X = SNNextNo To NextNo
            Input #1, CurrentXover(X)
            
            X = X
        Next 'X
        MaxList = 0
        For X = 0 To NextNo
            If CurrentXover(X) > MaxList Then MaxList = CurrentXover(X)
        Next X
        GlobalMemoryStatus MemSit
        MaxXOListSize = MemSit.dwTotalPhys
        MaxXOListSize = CLng(MaxXOListSize / NextNo / 100 / 2)
        If MaxList + 10 > MaxXOListSize Then MaxXOListSize = MaxList + 10
        XOverListSize = MaxList + 10
        If Response <> 6 Then
            Dim tXOL() As XOverDefine, tC() As Integer, MSize As Long
            MSize = 0
            For X = 0 To NextNo
                If CurrentXover(X) > MSize Then
                    MSize = CurrentXover(X)
                End If
            Next X
            ReDim tXOL(NextNo, MSize)
            
            For X = 0 To SNNextNo - 1
                For Y = 1 To CurrentXover(X)
                    tXOL(X, Y) = XOverList(X, Y)
                    'XX = XOverList(X, Y).Probability
                Next Y
            Next X
            ReDim XOverList(NextNo, XOverListSize)
            For X = 0 To SNNextNo - 1
                For Y = 1 To CurrentXover(X)
                    XOverList(X, Y) = tXOL(X, Y)
                    'XX = XOverList(X, Y).Probability
                Next Y
            Next X
        Else
            ReDim XOverList(NextNo, XOverListSize)
        End If
        Input #1, Crap

        If TString = "r8" Then

            For X = SNNextNo To NextNo

                For Y = 1 To CurrentXover(X)
                    Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending
                    Input #1, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
                    Input #1, XX, XOverList(X, Y).PermPVal, XOverList(X, Y).ProgramFlag
                    Input #1, xxx, XX, XOverList(X, Y).LHolder, XOverList(X, Y).LHolder
                    Input #1, XOverList(X, Y).BeginP, XOverList(X, Y).EndP, XX, xxx
                    Input #1, XOverList(X, Y).SBPFlag
                    If XOverList(X, Y).ProgramFlag >= AddNumX Then
                        XOverList(X, Y).ProgramFlag = XOverList(X, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y

            Next 'X

        ElseIf TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then
            ReDim oRecombNo(100)
            
            For X = 0 To NextNo
                oRecombNo(100) = oRecombNo(100) + CurrentXover(X)
                For Y = 1 To CurrentXover(X)
                    Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending
                    Input #1, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
                    Input #1, XX, XOverList(X, Y).PermPVal, XOverList(X, Y).ProgramFlag
                    Input #1, xxx, XX, XOverList(X, Y).LHolder, XOverList(X, Y).LHolder
                    Input #1, XOverList(X, Y).BeginP, XOverList(X, Y).EndP, XX, xxx
                    
                    'On Error Resume Next
                    Input #1, XOverList(X, Y).SBPFlag, XOverList(X, Y).Accept
                    'On Error GoTo 0
                    If TString = "r12" Or TString = "r10" Or TString = "r11" Then
                        Input #1, XOverList(X, Y).Eventnumber
                    End If
                    If XOverList(X, Y).ProgramFlag >= AddNumX Then XOverList(X, Y).Accept = 2
                    If XOverList(X, Y).ProgramFlag >= AddNumX Then
                        XOverList(X, Y).ProgramFlag = XOverList(X, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y
                
                Form1.ProgressBar1.Value = (X / NextNo) * 100
                
            Next 'X
        ElseIf TString = "r14" Or TString = "r13" Then
            ST = GetTickCount()
            ReDim oRecombNo(100)
            For X = SNNextNo To NextNo
                oRecombNo(100) = oRecombNo(100) + CurrentXover(X) '6,1,2,2,0,0,5
                For Y = 1 To CurrentXover(X)
                    Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending
                    Input #1, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
                    Input #1, XOverList(X, Y).PermPVal, XOverList(X, Y).ProgramFlag
                    Input #1, XOverList(X, Y).LHolder, XOverList(X, Y).DHolder
                    Input #1, XOverList(X, Y).BeginP, XOverList(X, Y).EndP
                    Input #1, XOverList(X, Y).SBPFlag, XOverList(X, Y).Accept, XOverList(X, Y).Eventnumber
                    If XOverList(X, Y).ProgramFlag >= AddNumX Then XOverList(X, Y).Accept = 2
                    XOverList(X, Y).MajorP = XOverList(X, Y).MajorP + SNNextNo
                    XOverList(X, Y).MinorP = XOverList(X, Y).MinorP + SNNextNo
                    XOverList(X, Y).Daughter = XOverList(X, Y).Daughter + SNNextNo
                    XOverList(X, Y).Probability = XOverList(X, Y).Probability * PValCon
                    If XOverList(X, Y).DHolder >= 0 Then
                        XOverList(X, Y).DHolder = XOverList(X, Y).Daughter + SNNextNo
                    Else
                        XOverList(X, Y).DHolder = (Abs(XOverList(X, Y).Daughter) + SNNextNo) * -1
                    End If
                    If XOverList(X, Y).ProgramFlag >= AddNumX Then
                        XOverList(X, Y).ProgramFlag = XOverList(X, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y
                ET = GetTickCount
                If (ET - ST) > 100 Then
                    ST = ET
                    Form1.ProgressBar1.Value = 5 + X / NextNo * 28
                End If
            Next 'X
            
            Input #1, Crap
            
            ReDim Preserve BCurrentXoverMi(NextNo)
            
            For X = SNNextNo To NextNo
                Input #1, BCurrentXoverMi(X)
    
                
            Next 'X
            MaxList = 0
            For X = 0 To NextNo
                If BCurrentXoverMi(X) > MaxList Then MaxList = BCurrentXoverMi(X)
            Next 'X
            If Response <> 6 Then
                ReDim tXOL(NextNo, MaxList)
                
                For X = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMi(X)
                        tXOL(X, Y) = BestXOListMi(X, Y)
                    Next Y
                Next X
                ReDim BestXOListMi(NextNo, MaxList)
                For X = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMi(X)
                        BestXOListMi(X, Y) = tXOL(X, Y)
                    Next Y
                Next X
                
            Else
                ReDim BestXOListMi(NextNo, MaxList)
            End If
            Input #1, Crap
            For X = SNNextNo To NextNo
                
                For Y = 1 To BCurrentXoverMi(X)
                    Input #1, BestXOListMi(X, Y).Daughter, BestXOListMi(X, Y).MajorP, BestXOListMi(X, Y).MinorP, BestXOListMi(X, Y).Beginning, BestXOListMi(X, Y).Ending
                    Input #1, BestXOListMi(X, Y).Probability, BestXOListMi(X, Y).OutsideFlag, BestXOListMi(X, Y).MissIdentifyFlag
                    Input #1, BestXOListMi(X, Y).PermPVal, BestXOListMi(X, Y).ProgramFlag
                    Input #1, BestXOListMi(X, Y).LHolder, BestXOListMi(X, Y).DHolder
                    Input #1, BestXOListMi(X, Y).BeginP, BestXOListMi(X, Y).EndP
                    Input #1, BestXOListMi(X, Y).SBPFlag, BestXOListMi(X, Y).Accept, BestXOListMi(X, Y).Eventnumber
                    If BestXOListMi(X, Y).ProgramFlag >= AddNumX Then BestXOListMi(X, Y).Accept = 2
                    BestXOListMi(X, Y).MajorP = BestXOListMi(X, Y).MajorP + SNNextNo
                    BestXOListMi(X, Y).MinorP = BestXOListMi(X, Y).MinorP + SNNextNo
                    BestXOListMi(X, Y).Daughter = BestXOListMi(X, Y).Daughter + SNNextNo
                    BestXOListMi(X, Y).Probability = BestXOListMi(X, Y).Probability * PValCon
                    If BestXOListMi(X, Y).DHolder >= 0 Then
                        BestXOListMi(X, Y).DHolder = BestXOListMi(X, Y).Daughter + SNNextNo
                    Else
                        BestXOListMi(X, Y).DHolder = (Abs(BestXOListMi(X, Y).Daughter) + SNNextNo) * -1
                    End If
                    If BestXOListMi(X, Y).ProgramFlag >= AddNumX Then
                        BestXOListMi(X, Y).ProgramFlag = BestXOListMi(X, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y
                
                ET = GetTickCount
                If ET - ST > 100 Then
                    ST = ET
                    Form1.ProgressBar1.Value = 33 + ((X / 3) / NextNo) * 100
                End If
            Next 'X
            Input #1, Crap
            ReDim Preserve BCurrentXoverMa(NextNo)
            For X = SNNextNo To NextNo
                Input #1, BCurrentXoverMa(X)
    
                If BCurrentXoverMa(X) > MaxList Then MaxList = BCurrentXoverMa(X)
            Next 'X
            MaxList = 0
            For X = 0 To NextNo

                If BCurrentXoverMa(X) > MaxList Then MaxList = BCurrentXoverMa(X)
            Next 'X
            If Response <> 6 Then
                ReDim tXOL(NextNo, MaxList)
                
                For X = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMa(X)
                        tXOL(X, Y) = BestXOListMa(X, Y)
                    Next Y
                Next X
                ReDim BestXOListMa(NextNo, MaxList)
                For X = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMa(X)
                        BestXOListMa(X, Y) = tXOL(X, Y)
                    Next Y
                Next X
                
            Else
                ReDim BestXOListMa(NextNo, MaxList)
            End If
            Input #1, Crap
           
            For X = SNNextNo To NextNo
                
                For Y = 1 To BCurrentXoverMa(X)
                    Input #1, BestXOListMa(X, Y).Daughter, BestXOListMa(X, Y).MajorP, BestXOListMa(X, Y).MinorP, BestXOListMa(X, Y).Beginning, BestXOListMa(X, Y).Ending
                    Input #1, BestXOListMa(X, Y).Probability, BestXOListMa(X, Y).OutsideFlag, BestXOListMa(X, Y).MissIdentifyFlag
                    Input #1, BestXOListMa(X, Y).PermPVal, BestXOListMa(X, Y).ProgramFlag
                    Input #1, BestXOListMa(X, Y).LHolder, BestXOListMa(X, Y).DHolder
                    Input #1, BestXOListMa(X, Y).BeginP, BestXOListMa(X, Y).EndP
                    Input #1, BestXOListMa(X, Y).SBPFlag, BestXOListMa(X, Y).Accept, BestXOListMa(X, Y).Eventnumber
                    If BestXOListMa(X, Y).ProgramFlag >= AddNumX Then BestXOListMa(X, Y).Accept = 2
                    BestXOListMa(X, Y).MajorP = BestXOListMa(X, Y).MajorP + SNNextNo
                    BestXOListMa(X, Y).MinorP = BestXOListMa(X, Y).MinorP + SNNextNo
                    BestXOListMa(X, Y).Daughter = BestXOListMa(X, Y).Daughter + SNNextNo
                    BestXOListMa(X, Y).Probability = BestXOListMa(X, Y).Probability * PValCon
                    If BestXOListMa(X, Y).DHolder >= 0 Then
                        BestXOListMa(X, Y).DHolder = BestXOListMa(X, Y).Daughter + SNNextNo
                    Else
                        BestXOListMa(X, Y).DHolder = (Abs(BestXOListMa(X, Y).Daughter) + SNNextNo) * -1
                    End If
                    If BestXOListMa(X, Y).ProgramFlag >= AddNumX Then
                        BestXOListMa(X, Y).ProgramFlag = BestXOListMa(X, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y
                
                ET = GetTickCount
                If ET - ST > 100 Then
                    ST = ET
                    Form1.ProgressBar1.Value = 66 + ((X / 3) / NextNo) * 100
                End If
            Next 'X
           
        End If
        
        Form1.ProgressBar1 = 100
        
        If TString = "r11" Then
            Input #1, Eventnumber
            ReDim BestEvent(Eventnumber, 1)
            For X = 1 To Eventnumber
                Input #1, BestEvent(X, 0), BestEvent(X, 1)
                
            Next X
        ElseIf TString = "r12" Then
            Input #1, Eventnumber
            'Eventnumber = 42
            ReDim BestEvent(Eventnumber, 1)
            ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1)
            For X = 1 To Eventnumber
                Input #1, BestEvent(X, 0), BestEvent(X, 1)
                For Z = 0 To AddNumX - 1
                    Input #1, Confirm(X, Z), ConfirmP(X, Z)
                Next Z
            Next X
            
            
            ReDim Daught(Eventnumber, NextNo), MinorPar(Eventnumber, NextNo + 1), MajorPar(Eventnumber, NextNo + 1)

            For X = 0 To NextNo
                For Y = 1 To CurrentXover(X)
                    Eventholder = XOverList(X, Y).Eventnumber
                    Daught(Eventholder, X) = 1
                    MinorPar(Eventholder, XOverList(X, Y).MinorP) = 1
                    MajorPar(Eventholder, XOverList(X, Y).MajorP) = 1
                Next Y
            Next X
            
            'Call LoadConfirms
        ElseIf TString = "r14" Or TString = "r13" Then
            'Input #1, Crap
            
            LongWindedFlag = 1
            'If Response <> 6 Then
            If Response <> 6 Then
                oSEventNumber = SEventNumber
                oEventNumber = Eventnumber
            Else
                oSEventNumber = 1
                oEventNumber = 1
            End If
            
            
            Input #1, SEventNumber, Eventnumber
            
            If Response <> 6 Then
                SEventNumber = SEventNumber + oSEventNumber
                Eventnumber = Eventnumber + oEventNumber
                oSEventNumber = oSEventNumber + 1
                oEventNumber = oEventNumber + 1
                For X = SNNextNo To NextNo
                    For Y = 1 To CurrentXover(X)
                        XOverList(X, Y).Eventnumber = XOverList(X, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                    For Y = 1 To BCurrentXoverMi(X)
                        BestXOListMi(X, Y).Eventnumber = BestXOListMi(X, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                    For Y = 1 To BCurrentXoverMa(X)
                        BestXOListMa(X, Y).Eventnumber = BestXOListMa(X, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                Next X
            
            End If
            
            ReDim Preserve NOPINI(2, SEventNumber)
            If Response = 6 Then
                For X = oSEventNumber - 1 To SEventNumber
                
                    For Y = 0 To 2
                        Input #1, NOPINI(Y, X)
                        X = X
                    Next Y
                Next X
            Else
                For Y = 0 To 2
                    Input #1, Crap
                Next Y
                For X = oSEventNumber To SEventNumber
                    For Y = 0 To 2
                        Input #1, NOPINI(Y, X)
                    Next Y
                Next X
            End If
            ReDim Preserve DScores(20, 2, SEventNumber)
            If Response = 6 Then
                For X = 0 To 20
                    For Y = 0 To 2
                        For Z = oSEventNumber - 1 To SEventNumber
                            Input #1, DScores(X, Y, Z)
                           X = X
                        Next Z
                    Next Y
                Next X
            Else
                For X = 0 To 20
                    For Y = 0 To 2
                        Input #1, Crap
                        X = X
                        For Z = oSEventNumber To SEventNumber
                            Input #1, DScores(X, Y, Z)
                           X = X
                        Next Z
                    Next Y
                Next X
            End If
            ReDim Preserve SuperEventlist(Eventnumber)
            If Response = 6 Then
                For X = oEventNumber - 1 To Eventnumber
                    Input #1, SuperEventlist(X)
                    X = X
                Next X
            Else
                
                Input #1, Crap
                For X = oEventNumber To Eventnumber
                    Input #1, SuperEventlist(X)
                    SuperEventlist(X) = SuperEventlist(X) + oSEventNumber - 1
                Next X
            End If
            If Response <> 6 Then
                'get backups of arrays that can't be redim preserved.
                Dim TD() As Long, tMi() As Long, tMa() As Long, CD() As Long, CP() As Double, CMi() As Long, CPMi() As Double, CMa() As Long, CPMa() As Double
                ReDim TD(SEventNumber, NextNo), tMi(SEventNumber, NextNo), tMa(SEventNumber, NextNo)
                ReDim CD(SEventNumber, AddNum - 1), CP(SEventNumber, AddNum - 1), CMi(SEventNumber, AddNum - 1), CPMi(SEventNumber, AddNum - 1), CMa(SEventNumber, AddNum - 1), CPMa(SEventNumber, AddNum - 1)
                For Y = 1 To oSEventNumber - 1
                    For X = 0 To SNNextNo - 1
                        TD(Y, X) = Daught(Y, X)
                        tMi(Y, X) = MinorPar(Y, X)
                        tMa(Y, X) = MajorPar(Y, X)
                    Next X
                    For X = 0 To AddNumX - 1
                        CD(Y, X) = Confirm(Y, X)
                        CMi(Y, X) = ConfirmMi(Y, X)
                        CMa(Y, X) = ConfirmMa(Y, X)
                        CP(Y, X) = ConfirmP(Y, X)
                        CPMi(Y, X) = ConfirmPMi(Y, X)
                        CPMa(Y, X) = ConfirmPMa(Y, X)
                    Next X
                Next Y
                
            End If
            ReDim BestEvent(SEventNumber, 1)
            ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1), ConfirmMi(Eventnumber, AddNum - 1), ConfirmPMi(Eventnumber, AddNum - 1), ConfirmMa(Eventnumber, AddNum - 1), ConfirmPMa(Eventnumber, AddNum - 1)
            ReDim Daught(SEventNumber, NextNo), MinorPar(SEventNumber, NextNo + 1), MajorPar(SEventNumber, NextNo + 1)
            
            If Response <> 6 Then
                'Put backups back into the arrays
                          
                For Y = 1 To oSEventNumber - 1
                    For X = 0 To SNNextNo
                        Daught(Y, X) = TD(Y, X)
                        MinorPar(Y, X) = tMi(Y, X)
                        MajorPar(Y, X) = tMa(Y, X)
                    Next X
                    For X = 0 To AddNumX - 1
                        Confirm(Y, X) = CD(Y, X)
                        ConfirmMi(Y, X) = CMi(Y, X)
                        ConfirmMa(Y, X) = CMa(Y, X)
                        ConfirmP(Y, X) = CP(Y, X)
                        ConfirmPMi(Y, X) = CPMi(Y, X)
                        ConfirmPMa(Y, X) = CPMa(Y, X)
                    Next X
                Next Y
                
            End If
            
            
            For Y = oSEventNumber To SEventNumber
                For X = SNNextNo To NextNo
                    Input #1, Daught(Y, X), MinorPar(Y, X), MajorPar(Y, X)
                    
                Next X
            Next Y
            
            For X = oSEventNumber To SEventNumber
                Input #1, BestEvent(X, 0), BestEvent(X, 1)
                    'Write #1, BestEvent(X, 0), BestEvent(X, 1)
                For Z = 0 To AddNumX - 1
                        
                       
                        Input #1, Confirm(X, Z), ConfirmP(X, Z)
                        
                        If ConfirmP(X, Z) < 0.05 Then
                        OC = ConfirmP(X, Z)
                             If ConfirmP(X, Z) < 0 Then
                                'Do While ConfirmP(X, Z) < 0
                                '    ConfirmP(X, Z) = ConfirmP(X, Z) + 1
                                'Loop
                                ConfirmP(X, Z) = 10 ^ (ConfirmP(X, Z))
                                
                             ElseIf ConfirmP(X, Z) > 0 Then
                                ConfirmP(X, Z) = -Log10(ConfirmP(X, Z))
                                If ConfirmP(X, Z) < 0 Then
                                X = X
                                End If
                             End If
                        End If
                       
                                
                        If Confirm(X, Z) <> 0 Then
                            
                            PVHold = ConfirmP(X, Z) / Confirm(X, Z)
                            PVHold = 10 ^ (-PVHold)
                            PVHold = PVHold * PValCon
                            ConfirmP(X, Z) = -Log10(PVHold) * Confirm(X, Z)
                            X = X
                        End If
                Next Z
            Next X
            For X = oSEventNumber To SEventNumber
                For Z = 0 To AddNumX - 1
                    Input #1, ConfirmMi(X, Z), ConfirmPMi(X, Z)
                        If ConfirmPMi(X, Z) < 0.05 Then
                        
                             If ConfirmPMi(X, Z) < 0 Then
                                
                                ConfirmPMi(X, Z) = 10 ^ (ConfirmPMi(X, Z))
                                
                             ElseIf ConfirmPMi(X, Z) > 0 Then
                                ConfirmPMi(X, Z) = -Log10(ConfirmPMi(X, Z))
                                
                             End If
                        End If
                        If ConfirmMi(X, Z) <> 0 Then
                            
                            PVHold = ConfirmPMi(X, Z) / ConfirmMi(X, Z)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMi(X, Z) = -Log10(PVHold) * ConfirmMi(X, Z)
                        End If
                
                Next Z
            Next X
            For X = oSEventNumber To SEventNumber
                For Z = 0 To AddNumX - 1
                    Input #1, ConfirmMa(X, Z), ConfirmPMa(X, Z)
                        If ConfirmPMa(X, Z) < 0.05 Then
                        
                             If ConfirmPMa(X, Z) < 0 Then
                                
                                ConfirmPMa(X, Z) = 10 ^ (ConfirmPMa(X, Z))
                                
                             ElseIf ConfirmPMa(X, Z) > 0 Then
                                ConfirmPMa(X, Z) = -Log10(ConfirmPMa(X, Z))
                                
                             End If
                        End If
                        If ConfirmMa(X, Z) <> 0 Then
                            
                            PVHold = ConfirmPMa(X, Z) / ConfirmMa(X, Z)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMa(X, Z) = -Log10(PVHold) * ConfirmMa(X, Z)
                        End If
                Next Z
            Next X
            
        
            Dim AProg() As Byte
            ReDim AProg(AddNum * 2)
            
            If RDPFlag = 1 Then AProg(0) = 1: AProg(0 + AddNumX) = 1
            If GENECONVFlag = 1 Then AProg(1) = 1: AProg(1 + AddNumX) = 1
            If BOOTSCANFlag = 1 Then AProg(2) = 1: AProg(2 + AddNumX) = 1
            If MaxChiFlag = 1 Then AProg(3) = 1: AProg(3 + AddNumX) = 1
            If ChimaeraFlag = 1 Then AProg(4) = 1: AProg(4 + AddNumX) = 1
            If SiScanFlag = 1 Then AProg(5) = 1: AProg(5 + AddNumX) = 1
            
            ReDim BestEvent(Eventnumber, 1)
            Dim BestP() As Double, oStepNo As Long
            ReDim BestP(SEventNumber + 1)
            For X = 0 To NextNo
                For Y = 1 To CurrentXover(X)
                    If XOverList(X, Y).Probability > 0 And (XOverList(X, Y).Probability < BestP(SuperEventlist(XOverList(X, Y).Eventnumber)) Or BestP(SuperEventlist(XOverList(X, Y).Eventnumber)) = 0) Then
                        If AProg(XOverList(X, Y).ProgramFlag) = 1 Then
                            BestP(SuperEventlist(XOverList(X, Y).Eventnumber)) = XOverList(X, Y).Probability
                            BestEvent(SuperEventlist(XOverList(X, Y).Eventnumber), 0) = X
                            BestEvent(SuperEventlist(XOverList(X, Y).Eventnumber), 1) = Y
                        End If
                    End If
                Next Y
            Next X
            If Response <> 6 Then
                oStepNo = StepNo + 1
                StepNo = StepNo + 1
            Else
                oStepNo = 0
            End If
            Input #1, StepNo
            
            If Response <> 6 Then
                StepNo = StepNo + oStepNo
            End If
           ' XX = UBound(Steps, 2)
            ReDim Preserve Steps(4, StepNo)
            'For Y = 0 To 4
            '    Input #1, Crap
            '    XX = Steps(0, X)
            'Next Y
            For X = oStepNo To StepNo
                For Y = 0 To 4
                    Input #1, Steps(Y, X) '3527,11876
                   XX = Steps(0, X)
                Next Y
                
            Next X
            
            ReDim Preserve MultColour(NextNo), ColourSeq(NextNo)
            
            For X = SNNextNo To NextNo
                Input #1, MultColour(X), ColourSeq(X)
                X = X
            Next X
            
            If Response <> 6 Then
                Call DoAlnAddj(SNNextNo, AdjustAlign())
                For X = 0 To oStepNo - 1
                    If Steps(1, X) > SNNextNo - 1 Then
                        Steps(1, X) = NextNo + (Steps(1, X) - (SNNextNo - 1))
                    End If
                    
                    If Steps(0, X) = 1 Or Steps(0, X) = 2 Then
                        Steps(2, X) = AdjustAlign(Steps(2, X), 0)
                        Steps(3, X) = AdjustAlign(Steps(3, X), 0)
                    'ElseIf Steps(0, X) = 3 Or Steps(0, X) = 4 Then
                    '    Steps(1, X) = NextNo + (Steps(1, X) - SNNextNo - 1)
                    
                    End If
                Next X
                'work out how many sequences there actually are after the last sequence in the first dataset is considered
                Dim tNextno As Long
                tNextno = NextNo
                
                For X = 0 To oStepNo - 1
                    If Steps(0, X) = 1 Then
                    
                        tNextno = tNextno + 1
                    ElseIf Steps(0, X) = 3 Then
                    
                        tNextno = tNextno - 1
                    ElseIf Steps(0, X) = 4 Then
                    
                        tNextno = tNextno - 1
                    End If
                        
                Next X
                If tNextno < NextNo Then
                    tNextno = NextNo
                End If
                Dim Mint As Long
                Mint = NextNo - SNNextNo
                For X = oStepNo To StepNo
                    If Steps(1, X) <= Mint Then
                        Steps(1, X) = Steps(1, X) + SNNextNo
                    Else
                        Steps(1, X) = tNextno + (Steps(1, X) - Mint)
                    End If
                    If Steps(0, X) = 1 Or Steps(0, X) = 2 Then
                        
                        Steps(2, X) = AdjustAlign(Steps(2, X), 1)
                        Steps(3, X) = AdjustAlign(Steps(3, X), 1)
                        Steps(4, X) = Steps(4, X) + oSEventNumber - 1
                    'ElseIf Steps(0, X) = 3 Or Steps(0, X) = 4 Then
                    '    Steps(1, X) = tNextno + (Steps(1, X) - NextNo)
                    End If
                Next X
            End If
            
            On Error GoTo SkipThis
            Input #1, GPerms
            
            If GPerms > 0 Then
                
                For Z = 0 To GPerms
                    For X = 0 To NextNo
                        For Y = 0 To PermsCurrentXOver(Z, X)
                            Input #1, PermsXOverList(Z, X, Y).Daughter, PermsXOverList(Z, X, Y).MajorP, PermsXOverList(Z, X, Y).MinorP, PermsXOverList(Z, X, Y).Beginning, PermsXOverList(Z, X, Y).Ending
                            Input #1, PermsXOverList(Z, X, Y).Probability, PermsXOverList(Z, X, Y).OutsideFlag, PermsXOverList(Z, X, Y).MissIdentifyFlag
                            Input #1, PermsXOverList(Z, X, Y).PermPVal, PermsXOverList(Z, X, Y).ProgramFlag
                            Input #1, PermsXOverList(Z, X, Y).LHolder, PermsXOverList(Z, X, Y).DHolder
                            Input #1, PermsXOverList(Z, X, Y).BeginP, PermsXOverList(Z, X, Y).EndP
                            Input #1, PermsXOverList(Z, X, Y).SBPFlag, PermsXOverList(Z, X, Y).Accept, PermsXOverList(Z, X, Y).Eventnumber
                        Next Y
                    Next X
                Next Z
            End If
        End If
            
SkipThis:


        
            Form1.ProgressBar1.Value = 100

            If PosGB > 0 Then

                If NextNo > 0 Then
                    Form1.ProgressBar1.Value = 0
                    Form1.SSPanel1.Caption = "Loading ORF positions"
                    VarString = right$(VarString, Len(VarString) - PosGB)
                    Form1.ProgressBar1.Value = 10

                    Call LoadGenBankII
    
                    Form1.ProgressBar1.Value = 100
                Else
                    Response = MsgBox("You need to open an alignment file before opening a GenBank file.", 48)
                End If
    
            End If

            Form1.Command30.Enabled = True
            Form1.Label58.Caption = "Unique sequences"

            If TString = "r8" Then
    
                If GENECONVFlag = 1 Or (MaxChiFlag = 1 And MCTripletFlag = 1) Then
                    Form1.ProgressBar1.Value = 10
                    Form1.SSPanel1.Caption = "Loading GENECONV Data"
                    GCOFile = App.Path & "\pout.frags"
                    DistLeft = LOF(1) - Loc(1)
                    PosStart = Loc(1)
                    PO$ = String$(DistLeft, " ")
                    Form1.ProgressBar1.Value = 50
                    Get #1, PosStart, PO$
                    Form1.SSPanel1.Caption = "Loading MaxChi Data"
                    Pos = InStr(1, PO$, "MCData", vbBinaryCompare)
    
                    If Pos > 0 Then
                        GO$ = left$(PO$, Pos - 1)
                        MO$ = right$(PO$, Len(PO$) - Pos - 6)
                    End If
    
                    Close #1
                    Open GCOFile For Output As #1
                    Print #1, GO$
                    Close #1
                    GO$ = ""
                    ODir$ = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    Open "maxchiout" For Output As #1
                    Print #1, MO$
                    Close #1
                    MO$ = ""
                    ChDir ODir$
                    ChDrive ODir$
                    Form1.ProgressBar1.Value = 100
                Else
                    Close #1
                End If
    
            ElseIf TString = "r9" Then
                On Error Resume Next
    
                If GENECONVFlag = 1 Or (MaxChiFlag = 1 And MCTripletFlag = 1) Then
                    Kill App.Path & "\maxchiout"
                    GCOFile = App.Path & "\pout.frags"
                    MCFullFile = App.Path & "\maxchiout"
                    Kill GCOFile
                    Form1.SSPanel1.Caption = "Loading GENECONV Data"
                    FileCopy left$(FNameII, Len(FNameII) - 4) + ".gc", GCOFile
                    Form1.SSPanel1.Caption = "Loading MaxChi Data"
                    FileCopy left$(FNameII, Len(FNameII) - 4) + ".mc", MCFullFile
                End If
    
                If BOOTSCANFlag = 1 Then
                    Kill App.Path & "\BSScanData"
                    Form1.SSPanel1.Caption = "Loading Bootscan Data"
                    BSFileName = left$(FNameII, Len(FNameII) - 4) + ".bs"
                End If
    
                Form1.SSPanel1.Caption = ""
                On Error GoTo 0
                Close #1
            End If

    ElseIf TString = "r7" Then
        Input #1, SpacerFlag, CircularFlag, WeightedFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Input #1, MCCorrection

        For X = 0 To NextNo
            Input #1, MaskSeq(X)
        Next 'X

        For X = 0 To NextNo
            Input #1, CurrentXover(X)
        Next 'X

        For X = 0 To NextNo

            For Y = 0 To CurrentXover(X)
                Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
            Next 'Y

        Next 'X

        If PosGB > 0 Then

            If NextNo > 0 Then

                Call LoadGenBank

            Else
                Response = MsgBox("You need to open an alignment file before opening a GenBank file.", 48)
            End If

        End If

        Close #1
    Else ' versions befor revision7
        SpacerFlag = CDbl(TString)
        Input #1, CircularFlag, WeightedFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Input #1, MCCorrection

        For X = 0 To NextNo
            Input #1, MaskSeq(X)
        Next 'X

        For X = 0 To NextNo
            Input #1, CurrentXover(X)
        Next 'X

        For X = 0 To NextNo

            For Y = 0 To CurrentXover(X)
                Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending, XOverList(X, Y).Probability
            Next 'Y

        Next 'X

        Close #1
    End If
    
    
    
    Form1.SSPanel1.Caption = "Integrating Data"
    
    
    'I NEED TO FIGURE OUT HOW TO HANDLE THE STEPDOWN CORRECTION FOLLOWING A SAVE
    If MCFlag = 2 And X = 1234567 Then
        ReDim PValCat(AddNum, 100)
        ReDim MaxPValCat(AddNum, 100)
        For Z = 0 To NextNo
            For A = 1 To CurrentXover(X)
                CurrentCorrect = XOverList(Z, A).ProgramFlag
                If CurrentCorrect >= AddNumX Then CurrentCorrect = CurrentCorrect - AddNumX
                ProbabilityXOver = XOverList(Z, A).Probability
                If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                    PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                    PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                End If
            Next A
            
        Next Z
    ElseIf MCFlag = 2 Then
        MCFlag = 0
    End If
    'rather than redoing this I should simply save the bestevent array and load it up again here
    Call FORDPLoad
    
   
End Sub
Public Sub FORDPLoad()
Call IntegrateXOvers(1)
    
    ReDim StartPlt(AddNum - 1)
    ReDim PDistPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
    ReDim ProbPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
    ReDim HitPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
    ReDim Hitnumber(Len(StrainSeq(0)) + 10)
    
    Form1.Picture6.Refresh
    Form1.Picture6.MousePointer = 0
    Form1.ProgressBar1.Value = 100
    ReDim XOverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XOverSeqNumW(Len(StrainSeq(0)) + XOverWindow * 2, 2)
    Form1.Command18.Enabled = True                'Enable "save" button
    'Form1.Command18.Width = 70 * Screen.TwipsPerPixelX
    'Form1.Command23.Visible = True
    Form1.Picture7.ScaleMode = 3
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Picture3.AutoRedraw = True

    Call PrintNames
    
    Close #1
    
    RunFlag = 1
    Form1.Picture3.Refresh
    LastY3 = -1
    Form1.Picture3.MousePointer = 0
    Form1.Picture3.AutoRedraw = False
    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.ScaleMode = 3
    Form1.UnmaskAllMnu.Visible = False
    Form1.DisableAllMnu.Visible = True
    Form1.MaskAllMnu.Visible = True
    Form1.InvertMaskMnu.Visible = False
    pMCTripletFlag = MCTripletFlag
    pMCProportionFlag = MCProportionFlag
    pMCPerms = MCPerms
    pMCPermMaxP = MCPermMaxP
    pMCStart = MCStart
    pMCEnd = MCEnd
    pMCMaxP = MCMaxP
    pMCSteplen = MCSteplen
    pMCWinSize = MCWinSize
    pMCWinFract = MCWinFract
    pMCStripGapsFlag = MCStripGapsFlag
    pMCFlag = MCFlag
    pXOverWindowX = XOverWindowX
    pCircularFlag = CircularFlag
    pSpacerFlag = SpacerFlag
    pLowestProb = LowestProb
    pChimaeraFlag = ChimaeraFlag
    pSiScanFlag = SiScanFlag
    pRDPFlag = RDPFlag
    pGENECONVFlag = GENECONVFlag
    pBOOTSCANFlag = BOOTSCANFlag
    pMaxChiFlag = MaxChiFlag
    PerMaxPval = 0
    PPMax = 0
    Form1.Picture5.Enabled = True
    Form1.Picture6.Enabled = True
    Form1.Picture6.SetFocus
End Sub
Public Sub LoadCLUSTAL()

    Dim NF As Integer, SeqStart As Integer, CLen As Integer
    Dim LastStartPos As Long, StartPos As Long, LastPos As Long, CHK As Long, X As Long
    Dim tempstring As String, CK As String

    NextNo = -1
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, tempstring

    If Len(tempstring) = LOF(NF) Then
        Close #NF
        LastPos = 1
        Form1.SSPanel1.Caption = "Reformatting Sequence File"

        Do
            Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

            If Pos > 0 Then
                Mid$(tempstring, Pos, 1) = Chr$(13)
                LastPos = Pos + 1
                Form1.ProgressBar1.Value = (LastPos / (Len(tempstring) + 2)) * 100
            Else
                Exit Do
            End If

        Loop
        XX = CurDir
        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, tempstring
        Close #NF
        Open "tempfile" For Input Access Read As #NF
        Line Input #NF, tempstring
    End If

    Form1.SSPanel1.Caption = "Loading CLUSTAL File"

    Do Until tempstring = Empty
        Input #NF, tempstring
    Loop

    Do Until tempstring <> Empty
        Input #NF, tempstring
    Loop

    CLen = 4

    Do While CLen > 0
        CK$ = String$(CLen, " ")
        CHK = InStr(1, tempstring, CK$, vbBinaryCompare)

        If CHK > 0 Then Exit Do
        CLen = CLen - 1
    Loop

    If CLen = 0 Then
        Close #NF
        Exit Sub
    End If

    Do Until Mid$(tempstring, 1, CLen) = CK$
        Pos = InStr(1, tempstring, CK$, vbBinaryCompare)

        If Pos > 1 And right$(tempstring, 1) <> "*" Then
            NextNo = NextNo + 1

            If SeqStart = 0 Then
                LastStartPos = Pos + 1
                StartPos = 1

                Do Until StartPos = 0
                    StartPos = InStr(LastStartPos, tempstring, "  ", vbBinaryCompare)
                    LastStartPos = LastStartPos + 1
                Loop

                SeqStart = LastStartPos
            End If

            Call SeqArrays

            StraiName(NextNo) = Mid$(tempstring, 1, Pos - 1)
            spacepos = InStr(SeqStart, tempstring, " ", vbBinaryCompare)
            If spacepos = 0 Then
                StrainSeq(NextNo) = Mid$(tempstring, SeqStart, Len(tempstring) - (SeqStart - 1))
            Else
                If spacepos - SeqStart = 10 Then
                    Pos = SeqStart
                    Do While spacepos > 0
                        StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(tempstring, Pos, spacepos - (Pos))
                        Pos = spacepos + 1
                        spacepos = InStr(Pos, tempstring, " ", vbBinaryCompare)
                    Loop
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(tempstring, Pos, Len(tempstring) - (Pos) + 1)
                Else
                    StrainSeq(NextNo) = Mid$(tempstring, SeqStart, spacepos - (SeqStart))
                End If
            End If
            
            X = X
        Else
            Exit Do
        End If

        Input #NF, tempstring
    Loop

    Form1.ProgressBar1.Value = 20

    Do While Not EOF(NF)
        Input #NF, tempstring

        If tempstring <> Empty Then
            X = -1

            Do
                Pos = InStr(1, tempstring, "  ", vbBinaryCompare)

                If Mid$(tempstring, 1, 1) = Mid$(StraiName(X + 1), 1, 1) And Mid$(tempstring, 1, 1) <> "*" And tempstring <> Empty Then
                    X = X + 1
                    spacepos = InStr(SeqStart, tempstring, " ", vbBinaryCompare)
                    If spacepos = 0 Then
                        StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, SeqStart, Len(tempstring) - (SeqStart - 1))
                    Else
                        If spacepos - SeqStart = 10 Then
                            Pos = SeqStart
                            Do While spacepos > 0
                                StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, Pos, spacepos - (Pos))
                                Pos = spacepos + 1
                                spacepos = InStr(Pos, tempstring, " ", vbBinaryCompare)
                            Loop
                       
                            StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, Pos, Len(tempstring) - (Pos) + 1)
                        
                        Else
                            StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, SeqStart, spacepos - (SeqStart))
                        End If
                    End If
                Else
                    Exit Do
                End If

                Input #NF, tempstring
            Loop

        End If

        xxx = Loc(NF)
        
        Form1.ProgressBar1.Value = (xxx / LOF(NF)) * 100

        If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
    Loop

    If NextNo > -1 Then

        If StraiName(NextNo) = "" Then NextNo = NextNo - 1
    End If

    Close #NF
End Sub
Public Sub LoadGCG()

    Dim OddFormat As Integer, Y As Integer, NF As Integer
    Dim LastPos As Long, PosN1 As Long, X As Long, Displacement As Long
    Dim TempSeq As String, tempstring As String

    NF = FreeFile
    OddFormat = 0
    Form1.SSPanel1.Caption = "Loading GCG File"
    Form1.ProgressBar1.Value = 20
    NextNo = -1
    Open FName$ For Input Access Read As #NF

    Do While Not EOF(NF)
        Line Input #NF, tempstring

        If Len(tempstring) > LOF(NF) * 0.5 Then
            OddFormat = 1
            Close #NF
            LastPos = 1

            Do
                Pos = InStr(LastPos, tempstring, Chr$(10), vbBinaryCompare)

                If Pos > 0 Then
                    Mid$(tempstring, Pos, 1) = Chr$(13)
                    LastPos = Pos + 2
                    Variab = Asc(Mid$(tempstring, 7, 1))
                Else
                    Exit Do
                End If

            Loop

            Open "tempfile" For Output As #NF
            SaveFlag = 1
            Print #NF, tempstring
            Close #NF
            Open "tempfile" For Input Access Read As #NF
            Line Input #NF, tempstring
        End If

        Pos = InStr(1, tempstring, "Name:", vbBinaryCompare)

        If Pos > 0 Then
            NextNo = NextNo + 1

            Call SeqArrays

            PosN1 = InStr(Pos + 6, tempstring, " ", vbBinaryCompare)
            StraiName(NextNo) = Mid$(tempstring, Pos + 6, PosN1 - (Pos + 6))
        End If

        If tempstring = "//" Then Exit Do
    Loop

    OddFormat = 0
    X = 0

    If OddFormat = 0 Then

        Do While Not EOF(NF)
            Line Input #NF, tempstring
            Pos = InStr(1, tempstring, StraiName(0), vbBinaryCompare)

            If Pos > 0 Then

                If Displacement = 0 Then

                    Do

                        If Mid$(tempstring, Len(StraiName(0)) + Pos + Displacement, 1) <> " " Then
                            Displacement = Displacement + Pos + Len(StraiName(0))
                            Exit Do
                        Else
                            Displacement = Displacement + 1
                        End If

                    Loop

                End If

                For X = 0 To NextNo

                    For Y = 0 To 4
                        StrainSeq(X) = StrainSeq(X) + Mid$(tempstring, Displacement + Y * 10 + Y, 10)
                    Next 'Y

                    If X < NextNo Then Line Input #NF, tempstring
                Next 'X

                X = X + 1
            Else
                X = 0
            End If

            If tempstring = "Recombination Data" Or tempstring = "GB Data" Then Exit Do
            Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
        Loop

    Else

        Do While Not EOF(NF)
            Pos = InStr(1, tempstring, StraiName(0), vbBinaryCompare)

            If Pos > 0 Then
                Displacement = Pos + (Len(StraiName(0))) + 2

                For X = 0 To NextNo

                    For Y = 1 To 4
                        TempSeq = Mid$(tempstring, Displacement + Y * 10 + Y, 10)
                        StrainSeq(X) = StrainSeq(X) + TempSeq
                    Next 'Y

                Next 'X

            End If

            Form1.ProgressBar1.Value = 20 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.75
        Loop

    End If

    Close #NF
    Exit Sub
Specialcase:
    Close #NF
    'this is where the routine ends up if you've tried to load a file without any carriage returns.
End Sub
Public Sub SeqArrays()

    If NextNo = 200 Then
        ReDim Preserve StrainSeq(300)
        ReDim Preserve StraiName(300)
    ElseIf NextNo = 300 Then
        ReDim Preserve StrainSeq(1000)
        ReDim Preserve StraiName(1000)
    ElseIf NextNo = 1000 Then
        ReDim Preserve StrainSeq(10000)
        ReDim Preserve StraiName(10000)
    ElseIf NextNo = 10000 Then
        ReDim Preserve StrainSeq(100000)
        ReDim Preserve StraiName(100000)
    End If

End Sub

Public Sub LoadMSD()

    Dim LenSeg As Integer, CurrentShortest As Integer, NF As Integer
    Dim X As Long, PosN1 As Long, PosN2 As Long, LastPos As Long, OriginPos As Long, MaxNameLenPos As Long
    Dim EndLine As Byte

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading DNAMan File"
    NF = FreeFile
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    Close #NF
    LastPos = 1
    NextNo = 0
    'put number of sequences info into the file and read it in here dickhead
    Finnish = 0
    OriginPos = InStr(LastPos, VarString, "ORIGIN", vbBinaryCompare)
    MaxNameLenPos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)

    If MaxNameLenPos = 0 Then
        MaxNameLenPos = 50000
    End If

    Pos = InStr(LastPos, VarString, "NUMBER:", vbBinaryCompare)

    If Pos > 0 Then
        NextNo = Int(CDbl(Mid$(VarString, Pos + 7, 3)))

        Call SeqArrays

        'Read the names of the sequences in the alignment
        Pos = InStr(LastPos, VarString, "NAMES: ", vbBinaryCompare)
        Form1.ProgressBar1.Value = 20

        For X = 0 To NextNo - 1
            PosN1 = InStr(Pos, VarString, " ", vbBinaryCompare)
            PosN2 = InStr(PosN1 + 1, VarString, " ", vbBinaryCompare)

            If PosN2 > OriginPos Or PosN2 > MaxNameLenPos Then
                PosN2 = InStr(PosN1 + 1, VarString, Chr$(10), vbBinaryCompare) - 1
            End If

            StraiName(X) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1) - 1)
            EndLine = Asc(right$(StraiName(X), 1))
            Pos = PosN2 - 1

            If EndLine = 10 Then
                StraiName(X) = left$(StraiName(X), Len(StraiName(X)) - 2)
                Pos = Pos + 7
            End If

            Form1.ProgressBar1.Value = 20 + X / (NextNo + 2) * 100 * 0.4
        Next 'X

        'Is maxnamelen given
        
        Pos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)
        If Pos = 0 Then Pos = InStr(LastPos, VarString, "maxnamelen:", vbBinaryCompare)
            zz = Mid(VarString, Pos + 11, 4)
            
            
            CurrentShortest = Val(Mid(VarString, Pos + 11, 4)) + 1
            X = X
            LenSeg = 60
        If Pos > 0 Then
        
        
        Else
        
            
            
            
            'Find distance from start of line to start of sequences.
            LastPos = InStr(OriginPos + 6, VarString, StraiName(0), vbBinaryCompare)
            CurrentShortest = 50
            Pos = InStr(LastPos, VarString, " A", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " a", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " C", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " c", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " G", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " g", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " T", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " t", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " .", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            CurrentShortest = CurrentShortest + 1
            Pos = InStr(LastPos + CurrentShortest + 5, VarString, "   ", vbBinaryCompare)
            LenSeg = Pos - (LastPos + CurrentShortest)
        End If
        
        For X = 0 To NextNo - 1
            LastPos = OriginPos

            Do
                If StraiName(X) = "TbLCZV" Then
                    X = X
                End If
                Pos = InStr(LastPos, VarString, StraiName(X) + " ", vbBinaryCompare)

                If Pos > 0 Then
                    StrainSeq(X) = StrainSeq(X) + Mid$(VarString, Pos + CurrentShortest, LenSeg)
                    B = Len(StrainSeq(X))
                    LastPos = Pos + (CurrentShortest + LenSeg) * NextNo
                Else
                    StrainSeq(X) = UCase$(StrainSeq(X))
                    Exit Do
                End If

            Loop

            Form1.ProgressBar1.Value = 20 + (NextNo / (NextNo + 2) + (X / NextNo) * (2 / (NextNo + 2))) * 100 * 0.75
        Next 'X

        For X = 0 To NextNo
            zz = Len(StrainSeq(X))
            If StraiName(X) = "TbLCZV" Then
                    X = X
                End If
            
            Do

                If right$(StrainSeq(X), 1) = Chr$(32) Then
                    StrainSeq(X) = left$(StrainSeq(X), Len(StrainSeq(X)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        NextNo = NextNo - 1
        Form1.ProgressBar1.Value = 0
    End If

End Sub
Public Sub DoTreeLegend(TreeBlocksL() As Long, TBLLen As Long, PBox As PictureBox, ExtraDx, AdjYD)

Dim HCg As Long, QCg As Long, ECg As Long
Dim HCb As Long, QCb As Long, ECb As Long
Dim HCr As Long, QCr As Long, ECr As Long
                
'Define Colours
HCg = BkG + (255 - BkG) / 2
QCg = BkG + (255 - BkG) / 4
ECg = BkG - (BkG) / 4
                
HCb = BkB + (255 - BkB) / 2
QCb = BkB + (255 - BkB) / 4
ECb = BkB - (BkB) / 4
                
HCr = BkR + (255 - BkR) / 2
QCr = BkR + (255 - BkR) / 4
ECr = BkR - (BkR) / 4
TBLLen = -1
'Draw Key
   AdjYD = 14
    'PBox.FontSize = 7
    'PBox.ScaleMode = 3
    'PBox.DrawMode = 9
    'PBox.Line (5, (Nextno + 4) * AdjYD)-(5 + AdjYD - 2, 1 * AdjYD - 2), RGB(255, 0, 0), BF
    TBLLen = TBLLen + 1
    TreeBlocksL(0, TBLLen) = 5
    TreeBlocksL(1, TBLLen) = 0
    TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
    TreeBlocksL(3, TBLLen) = 1 * AdjYD - 2
    TreeBlocksL(4, TBLLen) = -RGB(255, 0, 0)
    
    'PBox.DrawMode = 13
    'PBox.CurrentX = 20
    'PBox.CurrentY = (Nextno + 4) * AdjYD + 1
    'PBox.Print "Potential daughter "
    TBLLen = TBLLen + 1
    TreeBlocksL(0, TBLLen) = 20
    TreeBlocksL(1, TBLLen) = 0 * AdjYD + 1
    TreeBlocksL(2, TBLLen) = 0
    TreeBlocksL(3, TBLLen) = -1
    TreeBlocksL(4, TBLLen) = -1
    
    If ExtraD(0) > 0 Then
        'PBox.DrawMode = 9
        'PBox.Line (5, 1 * AdjYD)-(5 + AdjYD - 2, 2 * AdjYD - 2), RGB(255, 128, 128), BF
        
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = 1 * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = 2 * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(255, 128, 128)
        'PBox.DrawMode = 9
        'PBox.CurrentX = 20
        'PBox.CurrentY = 1 * AdjYD + 1
        
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = 1 * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        
        If ExtraD(0) = 1 Then
            'PBox.Print "Sequence with evidence of the same event "
            TreeBlocksL(2, TBLLen) = 1
        Else
            'PBox.Print "Sequences with evidence of the same event "
            TreeBlocksL(2, TBLLen) = 2
        End If
        ExtraD(0) = 1
        
       
    End If
    If ExtraD(1) > 0 Then
        'PBox.DrawMode = 9
        'PBox.Line (5, (1 + ExtraD(0)) * AdjYD)-(5 + AdjYD - 2, (2 + ExtraD(0)) * AdjYD - 2), RGB(255, 128, 192), BF
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (2 + ExtraD(0)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(255, 128, 192)
        
        'PBox.DrawMode = 9
        'PBox.CurrentX = 20
        'PBox.CurrentY = (1 + ExtraD(0)) * AdjYD + 1
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        
        If ExtraD(1) = 1 Then
            'PBox.Print "Sequence with partial evidence of the same event "
            TreeBlocksL(2, TBLLen) = 3
        Else
            'PBox.Print "Sequences with partial evidence of the same event "
            TreeBlocksL(2, TBLLen) = 4
        End If
        ExtraD(1) = 1
    End If
    If ExtraD(2) > 0 Then
        'PBox.DrawMode = 9
        'PBox.Line (5, (1 + ExtraD(0) + ExtraD(1)) * AdjYD)-(5 + AdjYD - 2, (2 + ExtraD(0) + ExtraD(1)) * AdjYD - 2), RGB(255, 192, 192), BF
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (2 + ExtraD(0) + ExtraD(1)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(255, 192, 192)
        'PBox.DrawMode = 9
        'PBox.CurrentX = 20
        'PBox.CurrentY = (1 + ExtraD(0) + ExtraD(1)) * AdjYD + 1
        
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        
        If ExtraD(2) = 1 Then
            'PBox.Print "Sequence with trace evidence of the same event "
             TreeBlocksL(2, TBLLen) = 5
        Else
            'PBox.Print "Sequences with trace evidence of the same event "
            TreeBlocksL(2, TBLLen) = 6
        End If
        ExtraD(2) = 1
    End If
    'PBox.DrawMode = 9
    'PBox.Line (5, (1 + ExtraD) * AdjYD)-(5 + AdjYD - 2, (2 + ExtraD) * AdjYD - 2), RGB(0, 0, 255), BF
    'PBox.DrawMode = 13
    'PBox.CurrentX = 20
    'PBox.CurrentY = (1 + ExtraD) * AdjYD + 1
    'PBox.Print "Potential parent "
    
    If OutsideFlagX <> 2 Then
        'PBox.DrawMode = 9
        'PBox.Line (5, (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD)-(5 + AdjYD - 2, (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2), RGB(64, 64, 255), BF
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(64, 64, 255)
        'PBox.DrawMode = 13
        'PBox.CurrentX = 20
        'PBox.CurrentY = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        TreeBlocksL(2, TBLLen) = 7
        'PBox.Print "Potential minor parent "
    Else
        'PBox.DrawMode = 9
        'PBox.Line (5, (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD)-(5 + AdjYD - 2, (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2), RGB(ECr, ECg, QCb), BF
        
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(ECr, ECg, QCb)
        'PBox.DrawMode = 13
        'PBox.CurrentX = 20
        'PBox.CurrentY = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (1 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        TreeBlocksL(2, TBLLen) = 8
        'PBox.Print "Sequence used to infer unknown parent "
    End If
    If OutsideFlagX <> 1 Then
        'PBox.DrawMode = 9
        'PBox.Line (5, (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD)-(5 + AdjYD - 2, (3 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2), RGB(0, 255, 0), BF
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (3 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(0, 255, 0)
        TBLLen = TBLLen + 1
        XX = UBound(TreeBlocksL, 2)
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        TreeBlocksL(2, TBLLen) = 9
    Else
        'PBox.DrawMode = 9
        'PBox.Line (5, (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD)-(5 + AdjYD - 2, (3 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2), RGB(ECr, QCg, ECb), BF
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 5
        TreeBlocksL(1, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD
        TreeBlocksL(2, TBLLen) = 5 + AdjYD - 2
        TreeBlocksL(3, TBLLen) = (3 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD - 2
        TreeBlocksL(4, TBLLen) = -RGB(ECr, QCg, ECb)
        'PBox.DrawMode = 13
        'PBox.CurrentX = 20
        'PBox.CurrentY = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TBLLen = TBLLen + 1
        TreeBlocksL(0, TBLLen) = 20
        TreeBlocksL(1, TBLLen) = (2 + ExtraD(0) + ExtraD(1) + ExtraD(2)) * AdjYD + 1
        TreeBlocksL(3, TBLLen) = -1
        TreeBlocksL(4, TBLLen) = -1
        TreeBlocksL(2, TBLLen) = 8
        'PBox.Print "Sequence used to infer unknown parent "
    End If
End Sub
Public Function DoTreeColour(PBox As PictureBox, TType, TNum)
Dim EN As Long
Dim TH As Double, HCg As Long, QCg As Long, ECg As Long, EECg As Long
Dim HCb As Long, QCb As Long, ECb As Long, EECb As Long
Dim HCr As Long, QCr As Long, ECr As Long, EECr As Long
                
'Define Colours
HCg = BkG + (255 - BkG) / 2
QCg = BkG + (255 - BkG) / 4
ECg = (BkG - (BkG) / 4)
EECg = (BkG - (BkG) / 8)

HCb = BkB + (255 - BkB) / 2
QCb = BkB + (255 - BkB) / 4
ECb = BkB - (BkB) / 4
EECb = (BkB - (BkB) / 8)

HCr = (BkR + (255 - BkR) / 2)
QCr = (BkR + (255 - BkR) / 4)
EECr = (BkR + (255 - BkR) / 8)
ECr = BkR - (BkR) / 4

If LongWindedFlag = 0 Then
    EN = XOverList(RelX, RelY).Eventnumber
Else
    EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
End If
ReDim ExtraD(4)
PBox.ForeColor = 0

PBox.FontSize = 8.25

Dim BB As Long
BB = -1
If TNum <> 0 Then
  On Error Resume Next
    For A = 0 To NextNo '- 1
        X = A
        
        TL = PBox.TextWidth(StraiName(X)) + 2
        TH = PBox.TextHeight(StraiName(X))
        
        'PBox.DrawMode = 13
        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), BackColours, BF
        'PBox.DrawMode = 9
        
        If TreeTraceSeqs(1, X) = Seq1 Then
            
                If OutsideFlagX = 1 Then
                    BB = BB + 1
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, QCg, ECb), BF
                Else
                    BB = BB + 1
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(0, 255, 0)
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(0, 255, 0), BF
                End If
            'X = X
        ElseIf TreeTraceSeqs(1, X) = Seq2 Then
            If OutsideFlagX = 2 Then
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
                TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, ECg, QCb), BF
            Else
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
                TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 255)
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(64, 64, 255), BF
            End If
        ElseIf TreeTraceSeqs(1, X) = Seq3 Then
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 0, 0)
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
            
        ElseIf Daught(EN, TreeTraceSeqs(1, X)) = 1 Then
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 128)
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 128), BF
            ExtraD(0) = ExtraD(0) + 1
        ElseIf Daught(EN, TreeTraceSeqs(1, X)) > 1 And Daught(EN, TreeTraceSeqs(1, X)) < 5 Then
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 192)
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
            ExtraD(1) = ExtraD(1) + 1
        ElseIf Daught(EN, TreeTraceSeqs(1, X)) = 5 Then
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, X) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, X) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, X)
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 192, 192)
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
            ExtraD(2) = ExtraD(2) + 1
        End If
        
        'PBox.DrawMode = 13
        'PBox.CurrentX = XCord(TType, TNum, X)
        'PBox.CurrentY = YCord(TType, TNum, X)
        'PBox.ForeColor = MultColour(TreeTrace(TreeTraceSeqs(1, X)))
        'PBox.ForeColor = RGB(255, 0, 0)
        'On Error Resume Next
        'PBox.Print StraiName(X)
        'On Error GoTo 0
         PBox.ForeColor = 0
        'If StraiName(TreeTrace(TreeTraceSeqs(1, X))) <> StraiName(X) Then
        '    X = X
        'End If
    Next 'X
    TBLen(TNum, TType) = BB
    On Error GoTo 0
Else
    For X = 0 To PermNextNo '- 1
        'PBox.DrawMode = 13
        TL = PBox.TextWidth(PermStraiName(TreeTrace(X))) + 2
        'Exit Function
        'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), BackColours, BF
        'PBox.DrawMode = 9
        If X = TreeTrace(Seq1) Then
            If OutsideFlagX = 1 Then
                'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(ECr, QCg, ECb), BF
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
            Else
                'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(0, 255, 0), BF
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 4, BB) = RGB(0, 255, 0)
            End If
        ElseIf X = TreeTrace(Seq2) Then
            If OutsideFlagX = 2 Then
                'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(ECr, ECg, QCb), BF
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
            Else
                'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(64, 64, 255), BF
                BB = BB + 1
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
                TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
                TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 255)
            End If
        ElseIf X = TreeTrace(Seq3) Then
            'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 0, 0), BF
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 0, 0)
        ElseIf Daught(EN, TreeTrace(X)) = 1 Then
            'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 128, 128), BF
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 128)
            ExtraD(0) = ExtraD(0) + 1
        ElseIf Daught(EN, TreeTrace(X)) > 1 And Daught(EN, X) < 5 Then
            'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 128, 192), BF
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 192)
            ExtraD(1) = ExtraD(1) + 1
        ElseIf Daught(EN, TreeTrace(X)) = 5 Then
            'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 13 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 192, 192), BF
            BB = BB + 1
            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(X)) - 2
            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(X)) + TL
            TreeBlocks(TNum, TType, 3, BB) = 13 + YCord(TType, TNum, TreeTrace(X))
            TreeBlocks(TNum, TType, 4, BB) = RGB(255, 192, 192)
            ExtraD(2) = ExtraD(2) + 1
        End If
        
        'PBox.DrawMode = 13
        'PBox.CurrentX = XCord(TType, TNum, TreeTrace(X))
        'PBox.CurrentY = YCord(TType, TNum, TreeTrace(X))
        'PBox.ForeColor = MultColour(TreeTrace(X))
        'PBox.Print PermStraiName(TreeTrace(X))
        
    Next 'X
End If
TBLen(TNum, TType) = BB
PBox.ForeColor = QBColor(0)

extradz = ExtraD(0)
DoTreeColour = extradz
End Function
Public Sub RecUPGMAII()

    Dim XInstance() As Integer, RecombTreeSeqs() As Integer
    Dim AdjYD As Integer, SortedNo As Integer, MultiInclude As Integer
    Dim cXi As Long, LSeq As Long, X As Long, Z As Long, Y As Long, NodeAdjust As Long
    Dim NodeLengthB() As Double, ValidSite() As Double, NJSubDistance() As Double, CurLen() As Double
    Dim OldFontSize As Double, FirstPos As Double, FormerXPos As Double, LargestDist As Double, ShortestDistance As Double
    Dim TempName() As String, RecombTreeName() As String

    If NextNo <= 0 Then Exit Sub
    ReDim RecombTreeSeqs(LSeq, NextNo + 1)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    ReDim NodeYPos(NextNo), TreeX(NextNo, NextNo), TreeY(NextNo), DistanceBak(NextNo, NextNo)
    If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    
    For X = 0 To NextNo
        RecombTreeName(X) = StraiName(X)
    Next 'X

    Form1.Picture16.FontSize = 8.25
    'Make sub sequences
    'First make small recombinant section
    'PPAVal = 1
    
    ReDim NJSubDistance(NextNo, NextNo)
    For X = 0 To NextNo
        For Y = 0 To NextNo
            NJSubDistance(X, Y) = TreeSMat(X, Y)
        Next Y
    Next X
    
    ReDim TreeRX(NextNo + 1, NextNo + 1)
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)
    'Initialise the tree array

    For X = 0 To NextNo

        For Y = 0 To NextNo
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    For X = 0 To NextNo
        TempName(X) = RecombTreeName(X)
    Next 'X

    'Draw the tree in memory

    Do Until SortedNo = NextNo
        ShortestDistance = ShortestDist(NextNo, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextNo

                For Y = X + 1 To NextNo

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0)))) + "," + TempName(TreeRY(SortedNo)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo)))) + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)

        For X = 0 To NextNo

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'Find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRX(SortedNo, 0))

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
                    'Finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRY(SortedNo))
                    'Adds sequences in node y to node x

                    For Z = 0 To cXi
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextNo

            If X <> TreeRY(SortedNo) Then
                NJSubDistance(TreeRY(SortedNo), X) = 100
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    NHString(TreeTypeFlag) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    'Draw tree
    
    AdjYD = 14
    Form1.Picture16.FontSize = 8.25
    OldFontSize = Form1.Picture16.FontSize

    Call TreeFont(2)

    If NodeLengthB(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLengthB(NextNo - 1)
    Else
        NodeAdjust = (TRegion - 10) / 0.00001
    End If

    FirstPos = CInt(TRegion) - 5
    'Write sequence names
    Dim EN As Long
    Dim ExtraDx As Long
    
    ExtraDx = 0
    
    
    

    'Draw the tree to the screen
    
    Call UPGMADraw(2, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ExtraDx = DoTreeColour(Form1.Picture16, 0, 2)
    DoTreeLegend TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDx, AdjYD
    
End Sub
Public Sub RecUPGMAIV()

    Dim XInstance() As Integer, RecombTreeSeqs() As Integer
    Dim AdjYD As Integer, SortedNo As Integer, MultiInclude As Integer
    Dim cXi As Long, LSeq As Long, X As Long, Z As Long, Y As Long, NodeAdjust As Long
    Dim NodeLengthB() As Double, ValidSite() As Double, NJSubDistance() As Double, CurLen() As Double
    Dim OldFontSize As Double, FirstPos As Double, FormerXPos As Double, LargestDist As Double, ShortestDistance As Double
    Dim TempName() As String, RecombTreeName() As String
If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    ReDim RecombTreeSeqs(LSeq, NextNo + 1)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    ReDim NodeYPos(NextNo), TreeX(NextNo, NextNo), TreeY(NextNo), DistanceBak(NextNo, NextNo)
    
    For X = 0 To NextNo
        RecombTreeName(X) = StraiName(X)
    Next 'X

    Form1.Picture16.FontSize = 8.25
    
    If X = X Then
        ReDim NJSubDistance(NextNo, NextNo)
        For X = 0 To NextNo
            For Y = 0 To NextNo
                NJSubDistance(X, Y) = TreeFMat(X, Y)
                'XX = SMat(X, Y)
            Next Y
        Next X
    Else
        'Make sub sequences
        'First make small recombinant section
        
        
            
        If XOverList(PRecSeq, PPAVal).Ending < XOverList(PRecSeq, PPAVal).Beginning Then
            'Exit Sub
            'find beginning
            BeginMark = XOverList(PRecSeq, PPAVal).Ending + 1
    
            For X = 1 To BeginMark - 1
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(X, Z) = 60
                Next 'Z
    
            Next 'X
    
            Y = BeginMark
    
            Do Until Y = XOverList(PRecSeq, PPAVal).Beginning Or Y >= LSeq
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(Y, Z) = SeqNum(Y, Z)
                Next 'Z
    
                Y = Y + 1
            Loop
    
            EndMark = Y - 1
    
            'Call DrawBlueColumn
    
            If Y < LSeq Then
    
                For X = Y To LSeq
    
                    For Z = 0 To NextNo
                        RecombTreeSeqs(X, Z) = SeqNum(X, Z) = 60
                    Next 'Z
    
                Next 'X
    
            End If
    
        Else ' If recombination overlaps the end of the sequence
            BeginMark = XOverList(PRecSeq, PPAVal).Ending + 1
    
            For X = XOverList(PRecSeq, PPAVal).Beginning To BeginMark - 1
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(X, Z) = 60
                Next 'Z
    
            Next 'X
    
            Y = BeginMark
    
            For X = Y To LSeq
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(X, Z) = SeqNum(X, Z)
                Next 'Z
    
            Next 'X
    
            Y = 1
            
            Do Until Y = XOverList(PRecSeq, PPAVal).Beginning Or Y > LSeq
                For X = 0 To NextNo
                    RecombTreeSeqs(Y, X) = SeqNum(Y, X)
                Next 'X
                Y = Y + 1
            Loop
    
            
    
            'Call DrawBlueColumn
    
            EndMark = Y - 1
        End If
    
        NextnoB = NextNo
        'Calculate distances in recombinant section of the alignment
        ReDim NJSubDistance(NextNo, NextNo)
        ReDim ValidSite(NextNo, NextNo)
            'this coluld be speeded up with better nesting of if then's
    
        DistanceCalcC NextNo, LSeq + 1, BeginMark, EndMark, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0)
        
   
    
        For X = 0 To NextNo
    
            For Y = X + 1 To NextNo
    
                If ValidSite(X, Y) > 0 Then
                    NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                    NJSubDistance(Y, X) = NJSubDistance(X, Y)
    
                    If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)
                End If
    
            Next 'Y
    
        Next 'X
    End If
    ReDim TreeRX(NextNo + 1, NextNo + 1)
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)
    'Initialise the tree array

    For X = 0 To NextNo

        For Y = 0 To NextNo
            TreeRX(X, Y) = -1
        Next 'Y

    Next 'X

    For X = 0 To NextNo
        TempName(X) = RecombTreeName(X)
    Next 'X

    'Draw the tree in memory

    Do Until SortedNo = NextNo
        ShortestDistance = ShortestDist(NextNo, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextNo

                For Y = X + 1 To NextNo

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0)))) + "," + TempName(TreeRY(SortedNo)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo)))) + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)

        For X = 0 To NextNo

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'Find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRX(SortedNo, 0))

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
                    'Finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRY(SortedNo))
                    'Adds sequences in node y to node x

                    For Z = 0 To cXi
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextNo

            If X <> TreeRY(SortedNo) Then
                NJSubDistance(TreeRY(SortedNo), X) = 100
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    NHString(TreeTypeFlag) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    'Draw tree
    
    
    
    Dim ExtraDx As Long
    
    ExtraDx = 0
    
    
    Call UPGMADraw(1, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ExtraDx = DoTreeColour(Form1.Picture16, 0, 1)
    DoTreeLegend TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDx, AdjYD
    'Form1.Picture16.Refresh
End Sub

Public Sub DrawBlueColumn()

    If BeginMark > EndMark Then

        Form1.Picture6.DrawMode = 12 '7 and 15 ok too
        Form1.Picture6.Line (5 + (BeginMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), 0)-(5 + (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.Line (5, 0)-(5 + (EndMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.DrawMode = 13

    Else

        Form1.Picture6.DrawMode = 12 '7 and 15 ok too
        Form1.Picture6.Line (5 + (BeginMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), 0)-(5 + (EndMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.DrawMode = 13

    End If

End Sub

Public Sub RecUPGMAIII()

    Dim XInstance() As Integer, RecombTreeSeqs() As Integer
    Dim YAdjD As Integer, MultiInclude As Integer, SortedNo As Integer
    Dim LSeq As Long, cXi As Long, NodeAdjust As Long
    Dim CurLen() As Double, NJSubDistance() As Double, ValidSite() As Double, NodeLengthB() As Double
    Dim OldFontSize As Double, LargestDist As Double, ShortestDistance As Double
    Dim RecombTreeName() As String, TempName() As String
    Dim X As Long, Y As Long, Z As Long
    If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    ReDim RecombTreeSeqs(LSeq, NextNo)
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    ReDim NodeYPos(NextNo), TreeX(NextNo, NextNo), TreeY(NextNo), DistanceBak(NextNo, NextNo)
    
    Form1.Picture16.FontSize = 8.25
    
    
    If X = X Then
        ReDim NJSubDistance(NextNo, NextNo)
        For X = 0 To NextNo
            For Y = 0 To TreeNextno
                NJSubDistance(X, Y) = TreeMatrix(X, Y)
                
            Next Y
        Next X
    Else
    
        'Make sub sequences
        MakeSubSeqC NextNo, LSeq, SeqNum(0, 0), RecombTreeSeqs(0, 0), SeqProb2(0, 0), CurrentXover(0)
    
        
    
        For X = 0 To NextNo
            RecombTreeName(X) = StraiName(X)
        Next 'X
    
        NextnoB = NextNo
        'Calculate distances
        
        ReDim ValidSite(NextNo, NextNo)
            'this coluld be speeded up with better nesting of if then's
    
        DistanceCalcD NextNo, LSeq + 1, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0), CurrentXover(0), Distance(0, 0)
    
        For X = 0 To NextNo
    
            For Y = X + 1 To NextNo
    
                If CurrentXover(X) = 0 And CurrentXover(Y) = 0 Then
    
                    If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)
                Else
    
                    If ValidSite(X, Y) > 0 Then
                        NJSubDistance(X, Y) = 1 - ((ValidSite(X, Y) - NJSubDistance(X, Y)) / ValidSite(X, Y))
                        NJSubDistance(Y, X) = NJSubDistance(X, Y)
    
                        If NJSubDistance(X, Y) > LargestDist Then LargestDist = NJSubDistance(X, Y)
                    End If
    
                End If
    
            Next 'Y
    
        Next 'X
    End If
    'Draw tree in memory
    ReDim TreeRX(NextNo + 1, NextNo + 1)
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)

    For X = 0 To NextNo

        For Y = 0 To NextNo
            TreeRX(X, Y) = -1
        Next 'Y

        TempName(X) = RecombTreeName(X)
    Next 'X

    Do Until SortedNo = NextNo
        ShortestDistance = ShortestDist(NextNo, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For X = 0 To NextNo

                For Y = X + 1 To NextNo

                    If NJSubDistance(X, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(X, Y)
                        TreeRX(SortedNo, 0) = X
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0)))) + "," + TempName(TreeRY(SortedNo)) + ":" + Trim$(CStr(NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo)))) + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)

        For X = 0 To NextNo

            If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
                NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
                NJSubDistance(X, TreeRX(SortedNo, 0)) = (NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
            ElseIf X = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'Find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRX(SortedNo, 0))

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
                    'Finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRY(SortedNo))
                    'Adds sequences in node y to node x

                    For Z = 0 To cXi
                        XInstance(X) = XInstance(X) + 1
                        TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(X) = XInstance(X) + 1
                    TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For X = 0 To NextNo

            If X <> TreeRY(SortedNo) Then
                NJSubDistance(TreeRY(SortedNo), X) = 100
                NJSubDistance(X, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    NHString(TreeTypeFlag) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    'Draw tree
    
    'Actually draw the tree
    Call UPGMADraw(3, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ExtraDx = DoTreeColour(Form1.Picture16, 0, 3)
    DoTreeLegend TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDx, AdjYD
    
End Sub


Public Sub FindSubSeqX()

    Dim Z As Long, X As Long, Y As Long, G As Long, A As Long, LSeq As Long

    If ExeCheckFlag = 0 Then
        ReDim XOverSeq(NextNo + 2)
    End If
    LSeq = Len(StrainSeq(0))

    If SpacerFlag > 0 And SpacerNo > 0 Then
        Y = 0

        For X = 1 To LSeq

            If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Or SeqNum(X, Seq3) <> SeqNum(X, Seq2) Then

                If SeqNum(X, Seq1) <> SeqNum(X, Seq2) And SeqNum(X, Seq1) <> SeqNum(X, Seq3) And SeqNum(X, Seq3) <> SeqNum(X, Seq2) Then
                ElseIf SeqNum(X, Seq1) > 65 And SeqNum(X, Seq2) > 65 And SeqNum(X, Seq3) > 65 Then

                    If SeqNum(X, Seq1) <> SeqNum(X, Seq2) And SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
                        'If seq1 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo

                            If SeqNum(X, Seq1) = SeqNum(X, SpacerSeqs(Z)) Or (Outlyer = Seq1 And SpacerFlag = 1) Then
                                'If difference is legitimate
                                G = 1
                                If ExeCheckFlag = 0 Then
                                    XOverSeqNum(Y, 0) = SeqNum(X, Seq1)
                                    XOverSeqNum(Y, 1) = SeqNum(X, Seq2)
                                    XOverSeqNum(Y, 2) = SeqNum(X, Seq3) '
                                    
                                    XOverSeqNumW(Y + XOverWindow, 0) = SeqNum(X, Seq1)
                                    XOverSeqNumW(Y + XOverWindow, 1) = SeqNum(X, Seq2)
                                    XOverSeqNumW(Y + XOverWindow, 2) = SeqNum(X, Seq3)
                                    
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(X, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(X, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(X, Seq3) - 1)
                                
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(X, SpacerSeqs(A)) - 1)
                                    Next 'A
                                
                                End If
                                
                                XDiffpos(Y) = X
                                XPosdiff(X) = Y
                                
                                Exit For
                            Else

                                If SeqNum(X, Seq2) = SeqNum(X, SpacerSeqs(Z)) Then
                                    
                                End If

                            End If

                        Next 'Z

                        If XPosdiff(X) = 0 Then
                            
                            Y = Y - 1
                        End If

                    ElseIf SeqNum(X, Seq2) <> SeqNum(X, Seq1) And SeqNum(X, Seq2) <> SeqNum(X, Seq3) Then
                        'If seq2 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo ''

                            If SeqNum(X, Seq2) = SeqNum(X, SpacerSeqs(Z)) Or (Outlyer = Seq2 And SpacerFlag = 1) Then
                                'If difference is legitimate
                                G = 2
                                If ExeCheckFlag = 0 Then
                                    XOverSeqNum(Y, 0) = SeqNum(X, Seq1)
                                    XOverSeqNum(Y, 1) = SeqNum(X, Seq2)
                                    XOverSeqNum(Y, 2) = SeqNum(X, Seq3)
                                    XOverSeqNumW(Y + XOverWindow, 0) = SeqNum(X, Seq1)
                                    XOverSeqNumW(Y + XOverWindow, 1) = SeqNum(X, Seq2)
                                    XOverSeqNumW(Y + XOverWindow, 2) = SeqNum(X, Seq3) '
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(X, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(X, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(X, Seq3) - 1)
    
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(X, SpacerSeqs(A)) - 1)
                                    Next 'A
                                
                                End If
                                
                                XDiffpos(Y) = X
                                XPosdiff(X) = Y
                                
                                Exit For
                            Else

                                

                            End If

                        Next 'Z

                        If XPosdiff(X) = 0 Then
                           
                            Y = Y - 1
                        End If

                    ElseIf SeqNum(X, Seq3) <> SeqNum(X, Seq1) And SeqNum(X, Seq3) <> SeqNum(X, Seq2) Then
                        'If seq3 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo '

                            If SeqNum(X, Seq3) = SeqNum(X, SpacerSeqs(Z)) Or (Outlyer = Seq3 And SpacerFlag = 1) Then  '
                                'If difference is legitimate
                                G = 3
                                If ExeCheckFlag = 0 Then
                                    XOverSeqNum(Y, 0) = SeqNum(X, Seq1)
                                    XOverSeqNum(Y, 1) = SeqNum(X, Seq2)
                                    XOverSeqNum(Y, 2) = SeqNum(X, Seq3) '
                                    XOverSeqNumW(Y + XOverWindow, 0) = SeqNum(X, Seq1)
                                    XOverSeqNumW(Y + XOverWindow, 1) = SeqNum(X, Seq2)
                                    XOverSeqNumW(Y + XOverWindow, 2) = SeqNum(X, Seq3) '
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(X, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(X, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(X, Seq3) - 1)
    
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(X, SpacerSeqs(A)) - 1)
                                    Next 'A
                                End If

                                XDiffpos(Y) = X
                                XPosdiff(X) = Y
                                
                                Exit For
                            Else

                               

                            End If

                        Next 'Z ''

                        If XPosdiff(X) = 0 Then
                            
                            Y = Y - 1
                        End If

                    End If ''

                End If

            End If

        Next 'X

        LenXOverSeq = Y
    Else

        For X = 1 To LSeq

            If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Or SeqNum(X, Seq3) <> SeqNum(X, Seq2) Then

                If SeqNum(X, Seq1) <> SeqNum(X, Seq2) And SeqNum(X, Seq1) <> SeqNum(X, Seq3) And SeqNum(X, Seq3) <> SeqNum(X, Seq2) Then
                    G = G + 1
                ElseIf SeqNum(X, Seq1) > 65 And SeqNum(X, Seq2) > 65 And SeqNum(X, Seq3) > 65 Then
                    Y = Y + 1
                    If ExeCheckFlag = 0 Then
                        XOverSeqNum(Y, 0) = SeqNum(X, Seq1)
                        XOverSeqNum(Y, 1) = SeqNum(X, Seq2)
                        XOverSeqNum(Y, 2) = SeqNum(X, Seq3)
                        XOverSeqNumW(Y + XOverWindow, 0) = SeqNum(X, Seq1)
                        XOverSeqNumW(Y + XOverWindow, 1) = SeqNum(X, Seq2)
                        XOverSeqNumW(Y + XOverWindow, 2) = SeqNum(X, Seq3)
                        XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(X, Seq1) - 1)
                        XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(X, Seq2) - 1)
                        XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(X, Seq3) - 1)
                    End If
                    
                    XDiffpos(Y) = X
                    XPosdiff(X) = Y
                End If

            End If

        Next 'X

        LenXOverSeq = Y
    End If

    If LenXOverSeq < XOverWindow * 2 Then
        Exit Sub
    End If
    
    If ExeCheckFlag = 0 Then
        For X = 1 To XOverWindow
            XOverSeqNumW(X, 0) = XOverSeqNum(LenXOverSeq - XOverWindow + X, 0)
            XOverSeqNumW(LenXOverSeq + XOverWindow + X, 0) = XOverSeqNum(X, 0)
            XOverSeqNumW(X, 1) = XOverSeqNum(LenXOverSeq - XOverWindow + X, 1)
            XOverSeqNumW(LenXOverSeq + XOverWindow + X, 1) = XOverSeqNum(X, 1)
            XOverSeqNumW(X, 2) = XOverSeqNum(LenXOverSeq - XOverWindow + X, 2)
            XOverSeqNumW(LenXOverSeq + XOverWindow + X, 2) = XOverSeqNum(X, 2)
        Next 'X
    End If

End Sub
Public Sub MakeXOverSeq()

    Dim X As Long

    ReDim XOverSeq(2)

    For X = 1 To LenXOverSeq
        XOverSeq(0) = XOverSeq(0) + Chr(SeqNum(XDiffpos(X), Seq1) - 1) 'Mid$(StrainSeq(Seq1), XDiffPos(X), 1)
        XOverSeq(1) = XOverSeq(1) + Chr(SeqNum(XDiffpos(X), Seq2) - 1)
        XOverSeq(2) = XOverSeq(2) + Chr(SeqNum(XDiffpos(X), Seq3) - 1)
    Next 'X

End Sub
Public Sub FindsubseqChiII()
ReDim XDiffpos(Len(StrainSeq(0)) + 200, 2)
ReDim XPosdiff(Len(StrainSeq(0)) + 200, 2)

ReDim xLenXoverSeq(2)

TSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
        
For Z = 0 To 2
    If Z = 0 Then
        Seq1 = TSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Z = 1 Then
        Seq1 = tSeq3
        Seq2 = TSeq1
        Seq3 = tSeq2
    Else
        Seq1 = tSeq2
        Seq2 = tSeq3
        Seq3 = TSeq1
    End If
    'This could be speeded up with better nesting
    xLenXoverSeq(Z) = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0, Z), XPosdiff(0, Z))
    If xLenXoverSeq(Z) > LenXOverSeq Then LenXOverSeq = xLenXoverSeq(Z)
'End If
Next Z
Seq1 = TSeq1
Seq2 = tSeq2
Seq3 = tSeq3
End Sub
Public Sub FindSubSeqChi()
    
    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    
    LenXOverSeq = 0
    
    TSeq1 = Seq1
    tSeq2 = Seq2
    tSeq3 = Seq3
    
    Seq1 = Abs(CLng(XOverList(RelX, RelY).DHolder))
    
    If Seq1 = TSeq1 Then
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq2 Then
        Seq2 = TSeq1
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq3 Then
        Seq2 = TSeq1
        Seq3 = tSeq2
    End If
    'This could be speeded up with better nesting
    LenXOverSeq = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))
    
    Seq1 = TSeq1
    Seq2 = tSeq2
    Seq3 = tSeq3
End Sub
Public Sub GetXOSMC()
ReDim XDiffpos(Len(StrainSeq(0)) + 200)
ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    
LenXOverSeq = 0
'This could be speeded up with better nesting
LenXOverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffpos(0), XPosdiff(0))

End Sub
    

    

Public Sub FindSubSeqMC()
    
    Call GetXOSMC
    If ExeCheckFlag = 1 And OptFlag <> 4 Then
        BE = XOverList(RelX, RelY).Beginning
        EN = XOverList(RelX, RelY).Ending
        If BE < EN Then
            MCWinSize = XPosdiff(EN) - XPosdiff(BE)
        Else
            MCWinSize = XPosdiff(EN) + (LenXOverSeq - XPosdiff(BE))
        End If
        
        MCWinSize = MCWinSize * 2
        MCWinFract = MCWinSize / LenXOverSeq
    End If
    
    If MCProportionFlag = 0 Then
        
        If MCWinSize < LenXOverSeq / 1.5 Then
            If ExeCheckFlag = 1 Then
                MCOverlapR = XDiffpos(MCWinSize)
            Else
                MCOverlapR = XDiffpos(MCWinSize / 2)
            End If
            MCOverlapL = MCOverlapR
        Else
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 1.5))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXOverSeq >= 20 And MCWinFract * LenXOverSeq < LenXOverSeq / 1.5 Then
            MCOverlapR = XDiffpos(Int(MCWinFract * LenXOverSeq / 2) + 1)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXOverSeq < 20 Then
            MCOverlapR = XDiffpos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXOverSeq <= LenXOverSeq / 1.5 Then
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 1.5))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub

Public Sub FindSubSeqRDP()

    Dim StringX As String
    'ReDim AvHomol(3)
    XOverWindow = Int(XOverWindowX / 2)
    ReDim XOverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XOverSeqNumW(Len(StrainSeq(0)) + XOverWindow * 2, 2)
    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    Dim AH(2) As Long
    For X = 0 To SpacerNo
        XX = SpacerSeqs(X)
    Next X
    LenStrainSeq = Len(StrainSeq(0)) + 1
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'Call FindSubSeqX
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
        
        LenXOverSeq = Abs(LenXOverSeq)
        
        If ExeCheckFlag = 0 Then
            ReDim XOverSeq(NextNo + 1)
            StringX = String$(LenXOverSeq, "1")
            
            'For X = 0 To 2
                'Dummy = CopyStringC(LenXOverSeq, XOverSeqNum(0, X), StringX)
                Dummy = CopyStringD(LenXOverSeq, SeqNum(0, Seq1), XDiffpos(0), StringX)
                XOverSeq(0) = right$(StringX, LenXOverSeq - 1)
                Dummy = CopyStringD(LenXOverSeq, SeqNum(0, Seq2), XDiffpos(0), StringX)
                XOverSeq(1) = right$(StringX, LenXOverSeq - 1)
                Dummy = CopyStringD(LenXOverSeq, SeqNum(0, Seq3), XDiffpos(0), StringX)
                XOverSeq(2) = right$(StringX, LenXOverSeq - 1)
            'Next 'X
    
            For X = 1 To SpacerNo
                Dummy = CopyStringD(LenXOverSeq, SeqNum(0, SpacerSeqs(X)), XDiffpos(0), StringX)
                XOverSeq(2 + X) = right$(StringX, LenXOverSeq - 1)
            Next 'X
        End If
        
    Else
        SpacerFlag = 0
        ReDim ValidSpacer(0)
        ReDim SpacerSeqs(0)
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
        
        If ExeCheckFlag = 0 Then
            ReDim XOverSeq(NextNo + 1)
            StringX = String$(LenXOverSeq, "1")
    
            For X = 0 To 2
                If X = 0 Then
                    CS = Seq1
                ElseIf X = 1 Then
                    CS = Seq2
                Else
                    CS = Seq3
                End If
                XOverSeq(X) = ""
                For Y = 1 To LenXOverSeq
                    XOverSeq(X) = XOverSeq(X) + Chr(SeqNum(XDiffpos(Y), CS) - 1)
                    X = X
                Next Y
                
            Next 'X
        End If
        
        SpacerNo = 0
    End If
    If LenXOverSeq = 0 Then Exit Sub
    AvHomol(1) = (AH(0) / LenXOverSeq)
    AvHomol(2) = (AH(1) / LenXOverSeq)
    AvHomol(3) = (AH(2) / LenXOverSeq)
    LenXOverSeq = Abs(LenXOverSeq) - 1
    
End Sub
Public Sub FindSubSeqBS()

    Dim Y As Long, X As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffpos(LSeq + 200)
    ReDim XPosdiff(LSeq + 200)
    
    
    Y = 0
    
    For X = 1 To LSeq
        XPosdiff(X) = Y
       
        If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
             If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                Y = Y + 1
                XDiffpos(Y) = X
                XPosdiff(X) = Y
            
            End If
        End If

    Next 'X
    LenXOverSeq = Y
    'End If
End Sub
Public Sub FindSubSeqGC()

    Dim Y As Long, X As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffpos(LSeq + 200)
    ReDim XPosdiff(LSeq + 200)
    
    Y = 0
    
    For X = 1 To LSeq
        XPosdiff(X) = Y

        If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Or SeqNum(X, Seq2) <> SeqNum(X, Seq3) Then
            If (SeqNum(X, Seq1) = 46 Or SeqNum(X, Seq2) = 46 Or SeqNum(X, Seq2) = 46) And (GCIndelFlag = 0 Or GCIndelFlag = 1) Then
            Else
                Y = Y + 1
                XDiffpos(Y) = X
                XPosdiff(X) = Y
            
            End If
        End If

    Next 'X
    LenXOverSeq = Y
    'End If
End Sub
Public Sub FindSubSeqBSII()

    Dim Y As Long, X As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffpos(LSeq + 200)
    ReDim XPosdiff(LSeq + 200)
    
    If Seq1 <> Seq2 Then
        S1 = Seq1
        S2 = Seq2
    Else
        S1 = Seq1
        S2 = Seq3
    End If
    Y = 0
    For X = 1 To LSeq
        XPosdiff(X) = Y
        If SeqNum(X, S1) <> SeqNum(X, S2) And SeqNum(X, S1) <> 46 And SeqNum(X, S2) <> 46 Then
            Y = Y + 1
            XDiffpos(Y) = X
            XPosdiff(X) = Y
        End If
    Next 'X
    LenXOverSeq = Y
End Sub
Public Sub FindSubSeqMCII()

    Dim Y As Long, X As Long, Z As Long, LSeq As Long

    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    LSeq = Len(StrainSeq(0))
    ReDim MCXDiffPos(Len(StrainSeq(0)))
    ReDim MCXPosDiff(LSeq)
    ReDim MCXoverSeq(NextNo)
    
    
    'Exit Sub
    If UBound(MCIdentical) = 0 Then
        ReDim MCIdentical(Len(StrainSeq(0)) + 200)
        'If NumEnabledSeqs < Nextno Then 'Or MCStripGapsFlag = 1 Then
        ReDim MCIDCount(Len(StrainSeq(0)), 4)
        For X = 1 To Len(StrainSeq(0))
    
            If Identical(X) = 0 Then
    
                For Y = 0 To NumEnabledSeqs
    
                    If SeqNum(X, GCEnabledNo(Y)) = 66 Then
                        MCIDCount(X, 0) = MCIDCount(X, 0) + 1
                    ElseIf SeqNum(X, GCEnabledNo(Y)) = 68 Then
                        MCIDCount(X, 1) = MCIDCount(X, 1) + 1
                    ElseIf SeqNum(X, GCEnabledNo(Y)) = 72 Then
                        MCIDCount(X, 2) = MCIDCount(X, 2) + 1
                    ElseIf SeqNum(X, GCEnabledNo(Y)) = 85 Then
                        MCIDCount(X, 3) = MCIDCount(X, 3) + 1
                    ElseIf SeqNum(X, GCEnabledNo(Y)) = 46 Or SeqNum(X, GCEnabledNo(Y)) = 47 Then
                        MCIDCount(X, 4) = MCIDCount(X, 4) + 1
                    End If
    
                Next 'Y
    
                If MCIDCount(X, 0) = NumEnabledSeqs + 1 Or MCIDCount(X, 1) = NumEnabledSeqs + 1 Or MCIDCount(X, 2) = NumEnabledSeqs + 1 Or MCIDCount(X, 3) = NumEnabledSeqs + 1 Or MCIDCount(X, 4) = NumEnabledSeqs + 1 Then
                    MCIdentical(X) = 1
                ElseIf MCIDCount(X, 4) > 0 And MCStripGapsFlag = 1 Then
                    MCIdentical(X) = 1
                ElseIf MCIDCount(X, 0) + MCIDCount(X, 4) < NumEnabledSeqs + 1 And MCIDCount(X, 1) + MCIDCount(X, 4) < NumEnabledSeqs + 1 And MCIDCount(X, 2) + MCIDCount(X, 4) < NumEnabledSeqs + 1 And MCIDCount(X, 3) + MCIDCount(X, 4) < NumEnabledSeqs + 1 Then
                    MCIdentical(X) = 0
                Else
                    MCIdentical(X) = 2
                End If
    
            Else
                MCIdentical(X) = 1
            End If
    
        Next 'X
    End If
    
    If NumEnabledSeqs <> NextNo Then
        Y = 0

        For X = 1 To LSeq
            XPosdiff(X) = Y
            MCXPosDiff(X) = Y

            If MCIdentical(X) = 0 Then
                Y = Y + 1
                XDiffpos(Y) = X
                MCXDiffPos(Y) = X
                XPosdiff(X) = Y

                For Z = 0 To NextNo

                    If MaskSeq(Z) < 2 Then
                        MCXoverSeq(Z) = MCXoverSeq(Z) + Mid$(StrainSeq(Z), X, 1)
                    End If

                Next 'Z

            End If

        Next 'X

    Else
        Y = 0

        For X = 1 To LSeq
            XPosdiff(X) = Y

            If MCIdentical(X) = 0 Then
                Y = Y + 1
                XDiffpos(Y) = X
                MCXDiffPos(Y) = X
                XPosdiff(X) = Y

                For Z = 0 To NextNo
                    MCXoverSeq(Z) = MCXoverSeq(Z) + Mid$(StrainSeq(Z), X, 1)
                Next 'Z

            End If

        Next 'X

    End If

    LenXOverSeq = Y

    If MCProportionFlag = 0 Then

        If MCWinSize < LenXOverSeq / 1.5 Then
            MCOverlapL = XDiffpos(Int(MCWinSize / 2) + 1)
            MCOverlapR = (LSeq - XDiffpos(LenXOverSeq - (Int(MCWinSize / 2) + 1)))
        Else
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXOverSeq >= 20 And MCWinFract * LenXOverSeq < LenXOverSeq / 1.5 Then
            MCOverlapL = XDiffpos(Int(MCWinFract * LenXOverSeq / 2) + 1)
            MCOverlapR = (LSeq - XDiffpos(LenXOverSeq - (Int(MCWinFract * LenXOverSeq / 2) + 1)))
        ElseIf MCWinFract * LenXOverSeq < 20 Then
            MCOverlapR = XDiffpos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXOverSeq <= LenXOverSeq / 1.5 Then
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub
Public Sub FindSubSeqMCIII()

    Dim Y As Long, X As Long

    ReDim XDiffpos(Len(StrainSeq(0)) + 200)
    ReDim XPosdiff(Len(StrainSeq(0)) + 200)
    ReDim MCXDiffPos(Len(StrainSeq(0)))
    ReDim MCXPosDiff(Len(StrainSeq(0)))
    ReDim MCXoverSeq(NextNo)

    Dim Z As Long, ATot As Long, CTot As Long, GTot As Long, TTot As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    Y = 0

    For X = 1 To LSeq
        XPosdiff(X) = Y

        If Identical(X) = 0 Then
            ATot = 0
            CTot = 0
            GTot = 0
            TTot = 0

            For Z = 0 To NumberOfSeqs

                If Mid$(TempSeq(Z), X, 1) = "A" Then
                    ATot = ATot + 1
                ElseIf Mid$(TempSeq(Z), X, 1) = "C" Then
                    CTot = CTot + 1
                ElseIf Mid$(TempSeq(Z), X, 1) = "G" Then
                    GTot = GTot + 1
                ElseIf Mid$(TempSeq(Z), X, 1) = "T" Then
                    TTot = TTot + 1
                End If

            Next 'Z

            If (ATot > 0 And CTot > 0) Or (ATot > 0 And GTot > 0) Or (ATot > 0 And TTot > 0) Or (CTot > 0 And GTot > 0) Or (CTot > 0 And TTot > 0) Or (GTot > 0 And TTot > 0) Then
                Y = Y + 1
                XDiffpos(Y) = X
                MCXDiffPos(Y) = X
                XPosdiff(X) = Y
            End If

        End If

    Next 'X

    LenXOverSeq = Y

    If MCProportionFlag = 0 Then

        If MCWinSize < LenXOverSeq / 1.5 Then
            MCOverlapL = XDiffpos(Int(MCWinSize / 2) + 1)
            MCOverlapR = (LSeq - XDiffpos(LenXOverSeq - (Int(MCWinSize / 2) + 1)))
        Else
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXOverSeq >= 20 And MCWinFract * LenXOverSeq < LenXOverSeq / 1.5 Then
            MCOverlapL = XDiffpos(Int(MCWinFract * LenXOverSeq / 2) + 1)
            MCOverlapR = (LSeq - XDiffpos(LenXOverSeq - (Int(MCWinFract * LenXOverSeq / 2) + 1)))
        ElseIf MCWinFract * LenXOverSeq < 20 Then
            MCOverlapR = XDiffpos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXOverSeq <= LenXOverSeq / 1.5 Then
            MCOverlapR = XDiffpos(Int(1 + LenXOverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub

Public Sub ProbCalcX()
    'ProbabilityXOver = 0.000000000001
    
    Dim Y As Long, Z As Long, NMFactorial As Double, AddjustFactor As Double, XOL As Long, NIC As Long

    On Error GoTo Rescue

   ' If XOverLength < 600 Then
   '     AddjustFactor = XOverLength / ((XOverLength / 171) + 1)
   ' ElseIf XOverLength < 1000 Then
   '     AddjustFactor = XOverLength / 3
   ' ElseIf XOverLength < 2000 Then
   '     AddjustFactor = XOverLength / 1.8
   ' Else
   '     AddjustFactor = 1
   ' End If
   
    AddjustFactor = (XOverLength / 170)
   
    XOL = 170
    NIC = CLng((ntInCommon / XOverLength) * 170)
    
    ProbabilityXOver = 0
    'NFactorial = 1
    'For Y = 1 To XOverLength
    '         NFactorial = NFactorial * (Y / AddjustFactor)
    ' Next 'Y
    'AddjustFactor = 135.5
    NFactorial = Fact(XOL)

    

    For Z = NIC To XOL
        MFactorial = Fact(Z)
        NMFactorial = Fact(XOL - Z)

        'For Y = 1 To Z
        '    MFactorial = MFactorial * (Y / AddjustFactor)
        'Next 'Y

        'For Y = 1 To XOverLength - Z
        '    NMFactorial = NMFactorial * (Y / AddjustFactor)
        'Next 'Y

        ProbabilityXOver = ProbabilityXOver + ((indprob ^ Z) * ((1 - indprob) ^ (XOverLength - Z)) * (NFactorial / (MFactorial * NMFactorial)))
        X = X
    Next 'Z
    
    Exit Sub
Rescue:
    ProbabilityXOver = -1
End Sub
Public Sub CorrectProb()
    'This is used during the RDP analysis to properly record very small P-values

    If 1 - ProbabilityXOver = 1 Then
        If ProbabilityXOver < 1 Then ProbabilityXOver = ProbabilityXOver * (LenXOverSeq / XOverLength)
    Else
        If ProbabilityXOver < 0 Then
            ProbabilityXOver = -1
        ElseIf ProbabilityXOver < 1 Then
            ProbabilityXOver = 1 - ((1 - ProbabilityXOver) ^ ((LenXOverSeq / XOverLength)))
        End If

    End If

End Sub
Public Sub UPGMA(SPF, LF)
      
 ssx = GetTickCount
    Dim ValidSiteNo() As Double, OldCaption As String, Check() As Long, ShortestDistance As Double, X As Long, Y As Long, cXi As Long, SortedNo As Integer, DistanceBak() As Double
    Dim CurLen() As Double, TempName() As String
    Dim CJNode As Integer, XInstance() As Integer, MultiInclude As Integer, Z As Long
    Dim TS As String, nt As Long, NS As Long
    ssx = GetTickCount
    ReDim Check(NextNo)
    ReDim NodeYPos(NextNo), TreeX(NextNo, NextNo), TreeY(NextNo), DistanceBak(NextNo, NextNo)

    If LF = 0 Then
        
        ReDim TempName(NextNo), CurLen(NextNo)
        For X = 0 To NextNo
            If StraiName(X) = "" Then StraiName(X) = Str(SEventNumber) + Str(X)
            TempName(X) = StraiName(X)
        Next 'X
        OldCaption$ = Form1.SSPanel1.Caption
        If SPF = 0 Then Form1.SSPanel1.Caption = "Drawing UPGMA Dendrogram"
    End If

    For X = 0 To NextNo

        For Y = 0 To NextNo
            TreeX(X, Y) = -1
        Next 'Y
        
    Next 'X


'0.046
    If DistanceFlag = 0 Then

        Call CalcDistances(SPF, 0)

    End If
eex = GetTickCount
TT = eex - ssx
    LargestDist = 0
 '4.937
 '4.266 -better arguements in calcdist

    For X = 0 To NextNo

        For Y = X + 1 To NextNo
            If Distance(X, Y) > 0 Then
            
                DistanceBak(X, Y) = (1 - Distance(X, Y))
                DistanceBak(Y, X) = DistanceBak(X, Y)
                If DistanceBak(X, Y) > LargestDist Then LargestDist = DistanceBak(X, Y)
            Else
                DistanceBak(X, Y) = 0.999
                DistanceBak(Y, X) = 0.999
                LargestDist = 0.999
            End If
        Next 'Y

    Next 'X

    ReDim XInstance(NextNo + 1), NodeLength(NextNo)
    If TreeDistFlag = 0 Then
        ReDim TreeDistance(NextNo, NextNo)
    End If
    CJNode = 0
      
'5.078
    Do Until SortedNo = NextNo
        
        ShortestDistance = ShortestDist(NextNo, SortedNo, DistanceBak(0, 0), TreeX(0, 0), TreeY(0))
        
        If ShortestDistance = 1 Then
            
            For X = 0 To NextNo

                For Y = X + 1 To NextNo

                    If DistanceBak(X, Y) < ShortestDistance Then
                        ShortestDistance = DistanceBak(X, Y)
                        TreeX(SortedNo, 0) = X
                        TreeY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If
        
        If ShortestDistance = 1 Then
            'find the sequence missing from the tree
            
            For X = 0 To NextNo
                GoOn = 0
                For Y = 0 To NextNo
                    For Z = 0 To NextNo
                        If TreeX(Y, Z) = X Then
                            GoOn = 1
                            Exit For
                        ElseIf TreeX(Y, Z) = -1 Then
                            Exit For
                        End If
                    Next Z
                    If GoOn = 1 Then Exit For
                Next Y
                If GoOn = 0 Then
                    If X > 0 Then
                        TreeX(SortedNo, 0) = 0
                        TreeY(SortedNo) = X
                    Else
                        TreeX(SortedNo, 0) = 0
                        TreeY(SortedNo) = 1
                    End If
                    Exit For
                End If
            Next X
        
        End If
        
        NodeLength(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        
        If LF = 0 Then
            TempName(TreeX(SortedNo, 0)) = "(" + TempName(TreeX(SortedNo, 0)) + ":" + Trim$(CStr(NodeLength(SortedNo) - CurLen(TreeX(SortedNo, 0)))) + "," + TempName(TreeY(SortedNo)) + ":" + Trim$(CStr(NodeLength(SortedNo) - CurLen(TreeY(SortedNo)))) + ")"
            CurLen(TreeX(SortedNo, 0)) = NodeLength(SortedNo)
        End If
        If TreeDistFlag = 0 Then
            If ShortestDistance < 0.999999 Then
                TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
                TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
                
            End If
        End If
        
        Dummy = AddSeqToUPGMA(NextNo, SortedNo, XInstance(0), DistanceBak(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
        
        SortedNo = SortedNo + 1
    Loop
    
    If TreeDistFlag = 0 Then
        
        Dummy = TreeDist2(NextNo, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
        
       
        TreeDistFlag = 1
        For X = 0 To NextNo
            TreeDistance(X, X) = 1
        Next X
    End If
    '6.234 seconds
    
    ee2 = GetTickCount
    tt2 = ee2 - ss2
    '7.4
    '4.765 using ints in for loops instead of short ints
    '5.609 using a,x,y offsets
    '4.765 using x,y offsets
    '4.562 using brackets in pointers
    '4.546 using breaks instead of x=nextno etc.
    '4.532 using elses
    '0.047 using new algorithm in VB
    
    If LF = 0 Then
        
        If X = 12345 Then
            NHString(0) = TempName(TreeX(SortedNo - 1, 0)) + ";"
            Open "testfc" & Str(SEventNumber) & ".tre" For Output As #16
            Print #16, NHString(0)
            Close #16
        End If
        ReDim GCGroups(NextNo)
        
        nt = 0
        For X = 0 To NextNo
            TS = "-Group G" & Trim(nt)
            NS = 0
            For Y = 0 To NextNo
                If TreeX(X, Y) = -1 Then Exit For
                TS = TS & " " & StraiName(TreeX(X, Y))
                NS = NS + 1
            Next Y
            If NS > 2 Then
                GCGroups(nt) = TS
                nt = nt + 1
            End If
        Next X
        Form1.SSPanel6(1).Enabled = True
        NHString(0) = TempName(TreeX(SortedNo - 1, 0)) + ";"
        Form1.SSPanel1.Caption = OldCaption$
    End If
  EE = GetTickCount
  TT = EE - SS
  '8.110 seconds
  '5.219 win nextno = short int
  '5.234 with ints instead of short ints in shortestdist
  '5.032 using xoff in shortestdist
  '5.000 using brackets in pointers in shortestdist
  X = X
    
End Sub
Public Sub DrawTree()

    Dim NameWidth() As Integer, YAdjD As Integer
    Dim NodeAdjust As Long, X As Long
    Dim XPos() As Double, YPos() As Double
    Dim FormerXPos As Double, ScaleSize As Double, FirstPos As Double, OldFontSize As Double

    ReDim XPos(NextNo), TreeSeqs(NextNo, NextNo)
    ReDim YPos(NextNo)
   
    ReDim NameWidth(NextNo)
    Form1.Picture16.Picture = LoadPicture()
    
    Form1.Picture16.ScaleMode = 3
    Form1.Picture16.BackColor = BackColours
    Form1.Picture16.BackColor = BackColours
    Form1.Picture16.CurrentY = 0
    Form1.Picture16.ForeColor = QBColor(0)
    Form1.Picture16.FontSize = 8.25
    YAdjD = 14
    Form1.Picture16.FontSize = 8.25
    OldFontSize = Form1.Picture16.FontSize

    Call TreeFont(0)

    
    If NodeLength(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLength(NextNo - 1)
    Else
        NodeAdjust = 1000
    End If
    
    'Calculate tree distances
    
    
    FirstPos = CInt(TRegion) - 5
    
    

Dim ColPos() As Double, ExtraMod As Byte
ReDim ColPos(NextNo)
'go from last partition to first and average the colpos of each partition
'go from first partition to last and adjust colpos around average pos
    
Dim ColEvol() As Double, RC As Long, GC As Long, BC As Long, MaxCol(2), ZOK(2, 1) As Byte, Round As Byte
ReDim ColEvol(NextNo, 2)


ZOK(0, 0) = 1
ZOK(0, 1) = 2
ZOK(1, 0) = 2
ZOK(1, 1) = 0
ZOK(2, 0) = 0
ZOK(2, 1) = 1


If DoneColFlag = 0 Then
        Rnd (-NextNo)
        Z = -1
    
        For Y = NextNo - 1 To 0 Step -1
            Z = Z + 1
            If Z = 3 Then
                Z = 0
            End If
            ColEvol(TreeY(Y), Z) = ColEvol(TreeY(Y), Z) + NodeLength(Y)
            If ColEvol(TreeY(Y), Z) > MaxCol(Z) Then MaxCol(Z) = ColEvol(TreeY(Y), Z)
                    
            Z = Z + 1
            If Z = 3 Then
                Z = 0
            End If
            For X = 0 To NextNo
                If TreeX(Y, X) = TreeY(Y) Then
                    Exit For
                End If
                If TreeX(Y, X) <> -1 Then
                    ColEvol(TreeX(Y, X), Z) = ColEvol(TreeX(Y, X), Z) + NodeLength(Y)
                    If ColEvol(TreeX(Y, X), Z) > MaxCol(Z) Then MaxCol(Z) = ColEvol(TreeX(Y, X), Z)
                Else
                    Exit For
                End If
            Next X
        Next Y


    
        For X = 0 To NextNo
            
            If MaxCol(0) > 0 Then
                RC = (ColEvol(X, 0) / MaxCol(0)) * 200
            Else
                RC = 0
            End If
            If MaxCol(1) > 0 Then
                GC = (ColEvol(X, 1) / MaxCol(1)) * 200
            Else
                GC = 0
            End If
            'GC = (ColEvol(X, 1) / MaxCol(1)) * 200
            If MaxCol(2) > 0 Then
                BC = (ColEvol(X, 2) / MaxCol(2)) * 200
            End If
            If RC <= GC And RC <= BC Then
                RC = RC / 2
            ElseIf BC <= GC And BC <= RC Then
                BC = BC / 2
            ElseIf GC <= RC And GC <= BC Then
                GC = GC / 2
            End If
            SeqCol(X) = RGB(RC, GC, BC) '163,174,77
            
            FFillCol(X) = RGB(RC + (BkR - RC) / 1.25, GC + (BkG - GC) / 1.25, BC + (BkB - BC) / 1.25)
        Next X
        DoneColFlag = 1
        'XX = SeqCol(3) '3445930
    End If
   
    Call UPGMADraw(0, NextNo, NodeLength(), TreeX(), TreeY())
    
    Form1.Picture16.Refresh
End Sub

Public Sub SpacerFind()

    Dim InlyerA As Integer, InlyerB As Integer
    Dim X As Long

    If TreeDistance(Seq1, Seq2) < TreeDistance(Seq2, Seq3) And TreeDistance(Seq1, Seq3) < TreeDistance(Seq2, Seq3) Then
        InlyerA = Seq2
        InlyerB = Seq3
        Outlyer = Seq1
    ElseIf TreeDistance(Seq1, Seq2) < TreeDistance(Seq1, Seq3) And TreeDistance(Seq2, Seq3) < TreeDistance(Seq1, Seq3) Then
        InlyerA = Seq1
        InlyerB = Seq3
        Outlyer = Seq2
    Else
        InlyerA = Seq1
        InlyerB = Seq2
        Outlyer = Seq3
    End If
    
    InRangeFlag = 1
    
    If MiDistance > 0 Or MaDistance < 1 Then
        If (Distance(Outlyer, InlyerA) > MiDistance Or Distance(Outlyer, InlyerB) > MiDistance) And (Distance(Outlyer, InlyerA) < MaDistance Or Distance(Outlyer, InlyerB) < MaDistance) Then
            InRangeFlag = 1
        Else
            InRangeFlag = 0
            Exit Sub
        End If
    End If
    
    SpacerNo = 0
    
    If SpacerFlag = 1 Then

        For X = 0 To NextNo

            If MaskSeq(X) < 2 Then
                If X <> InlyerA And X <> InlyerB And X <> Outlyer Then
                    If TreeDistance(X, InlyerA) < TreeDistance(InlyerA, InlyerB) Then
    
                        If TreeDistance(X, InlyerA) > TreeDistance(InlyerA, Outlyer) Then
    
                                SpacerNo = SpacerNo + 1
                                SpacerSeqs(SpacerNo) = X
                                ValidSpacer(SpacerNo) = 1
    
                        ElseIf TreeDistance(X, InlyerA) = TreeDistance(InlyerA, Outlyer) And TreeDistance(X, Outlyer) < TreeDistance(InlyerA, InlyerB) Then
    
                                SpacerNo = SpacerNo + 1
                                SpacerSeqs(SpacerNo) = X
                        
                        End If
                    End If
                End If
            End If

        Next 'X
        'Exit Sub
    ElseIf SpacerFlag = 2 Then

        For X = 0 To NextNo

            If MaskSeq(X) < 2 Then

                If TreeDistance(X, InlyerA) < TreeDistance(InlyerA, InlyerB) Then

                    If X <> InlyerA And X <> InlyerB And X <> Outlyer Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                    End If

                End If

            End If

        Next 'X

    ElseIf SpacerFlag = 3 Then

        For X = 0 To NextNo

            If MaskSeq(X) < 2 Then

                If TreeDistance(X, Outlyer) < TreeDistance(InlyerA, Outlyer) Then

                    If X <> InlyerA And X <> InlyerB And X <> Outlyer Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = X
                    End If

                End If

            End If

        Next 'X

    End If

End Sub
Public Sub RTSpacerFind()

    Dim X As Long, Y As Long, A As Long, B As Long, BNMO As Long

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated and if a "spacer" is required

        Call CalcDistances(0, 0)

    End If

    If NJFlag = 0 Then
        Form1.ProgressBar1.Value = 47

        Call UPGMA(0, 0)

        Form1.ProgressBar1.Value = 66

        Call DrawTree

        Form1.ProgressBar1.Value = 71
        Form1.Label14.Caption = "UPGMA Ignoring Recombination"
        TreeImage(0) = 1
        DoneTree(0, 0) = 1
        NJFlag = 1
        'Calculate tree distances
        ReDim TreeDistance(NextNo, NextNo)
        TreeDist NextNo, TreeDistance(0, 0), NodeLength(0), TreeX(0, 0)
        Form1.ProgressBar1.Value = 100
    End If

    'Exit Sub
    ReDim SpacerSeqs(NextNo)

    Dim BeginNode As Integer
    Dim LastNode As Integer
    Dim Z As Long

    BeginNode = -1

    For X = 0 To oNextno

        For Y = 0 To oNextno

            If TreeX(X, Y) = InlyerA Then

                For Z = 0 To oNextno

                    If TreeX(X, Z) = InlyerB Then
                        BeginNode = X

                        For A = 0 To NextNo

                            If TreeX(X, A) = Outlyer Then
                                SpacerNo = 0
                                Exit Sub
                            End If

                            Exit For
                        Next 'A

                    ElseIf TreeX(X, Z) = 0 And Z > 0 Then
                        Exit For
                    End If

                Next 'Z

            ElseIf TreeX(X, Y) = 0 And Y > 0 Then
                Exit For
            End If

        Next 'Y

        If BeginNode > -1 Then Exit For
    Next 'X

    SpacerNo = 0
    BNMO = BeginNode + 1
    LastNode = -1

    Dim WrongNode As Integer

    WrongNode = 0

    For X = BNMO To 0 Step -1

        For Y = 0 To oNextno

            If TreeX(X, Y) = InlyerA Then
                WrongNode = 1
                Exit For
            Else
            End If

        Next 'Y

        If WrongNode = 1 Then
            WrongNode = 0
        Else

            For Z = 0 To oNextno

                If TreeX(X, Z) = InlyerB Then
                    WrongNode = 2
                    Exit For
                End If

            Next 'Z

            If WrongNode = 2 Then

                For Z = 0 To oNextno

                    If TreeX(X, Z) <> InlyerB And TreeX(X, Z) > -1 Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = TreeX(X, Z)
                    End If

                Next 'Z

            Else
                WrongNode = 0
            End If

        End If

        If SpacerNo > 0 Then Exit For
    Next 'X

    'End If

    For X = BNMO To oNextno

        For Y = 0 To oNextno

            If TreeX(X, Y) = InlyerA Then

                For Z = 0 To NextNo

                    If TreeX(X, Z) = Outlyer Then
                        LastNode = X
                        Exit For
                    End If

                Next 'Z

            End If

            If LastNode > -1 Then Exit For
        Next 'Y

        If LastNode > -1 Then Exit For
    Next 'X

    'check to see differences between this node and the beginnode
    'If BeginNode = LastNode - 1 Then Exit Sub

    Dim SpacerAddFlag As Integer

    SpacerAddFlag = 0

    For X = oNextno To BNMO Step -1

        For Y = 0 To oNextno

            If TreeX(X, Y) = InlyerA Then

                For A = 0 To oNextno

                    For B = 0 To oNextno

                        If TreeX(BeginNode, B) = TreeX(X, A) And TreeX(X, A) > -1 Then ' Or TreeX(BeginNode, B) > -1) Then
                            Exit For
                        End If

                    Next 'B

                    If B = NextNo + 1 Then

                        If TreeX(X, A) <> -1 Then

                            If TreeX(X, A) <> Outlyer Then
                                SpacerNo = SpacerNo + 1
                                SpacerSeqs(SpacerNo) = TreeX(X, A)
                                SpacerAddFlag = 1
                            End If

                        Else
                            Exit For
                        End If

                    End If

                Next 'A

                If SpacerAddFlag = 1 Then
                    Exit Sub
                End If

                Exit For
            End If

        Next 'Y

    Next 'X

    If LastNode = -1 Then
        Exit Sub
    End If

    For X = oNextno To BNMO Step -1

        If X <> LastNode Then

            For Y = 0 To oNextno

                For A = 0 To oNextno

                    For B = 0 To oNextno

                        If TreeX(LastNode, A) = TreeX(X, B) And (TreeX(X, B) > -1 Or TreeX(LastNode, A) > -1) Then
                            Exit For
                        End If

                        If TreeX(X, A) = TreeX(LastNode, B) And (TreeX(X, A) > -1 Or TreeX(LastNode, B) > -1) Then
                            Exit For
                        End If

                    Next 'B

                    If B = NextNo + 1 Then

                        If TreeX(X, A) <> -1 Then
                            SpacerNo = SpacerNo + 1
                            SpacerSeqs(SpacerNo) = TreeX(X, A)
                        Else
                            Exit For
                        End If

                    End If

                Next 'A

                If SpacerNo > 0 Then
                    Exit Sub
                End If

                Exit For
                ' End If
            Next 'Y

        End If

    Next 'X

End Sub
Public Sub DrawPlots(Seq1 As Long, Seq2 As Long, Seq3 As Long)

    Dim X As Long, Y As Long
    Dim YScaleFactor As Double

    Form1.Picture7.Picture = LoadPicture()
    
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Form1.Picture7.Cls
    'Draw homology plot in picturebox 7

    Dim PntAPI As POINTAPI
    Dim Pict As Long

    Pict = Form1.Picture7.hdc
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))

    

    RDPUD = 0
    RDPLD = 1

    For Y = 0 To 2

        For X = 1 To LenXOverSeq

            If XOverHomologyNum(X, Y) > RDPUD Then
                RDPUD = XOverHomologyNum(X, Y)
            ElseIf XOverHomologyNum(X, Y) < RDPLD Then
                RDPLD = XOverHomologyNum(X, Y)
            End If

        Next 'X

    Next 'Y

    Call DoAxes(Len(StrainSeq(0)), -1, RDPUD / (Int(XOverWindowX / 2) * 2 + 1), RDPLD / (Int(XOverWindowX / 2) * 2 + 1), 1, "Pairwise identity")

    Form1.Picture7.DrawWidth = 3

    For Y = 0 To 2
        Pict = Form1.Picture7.hdc

        If Y = 0 Then
            Form1.Picture7.ForeColor = mYellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LPurple
        End If

        MoveToEx Pict, 30 + XDiffpos(1) * XFactor, PicHeight - (15 + (((XOverHomologyNum(LenXOverSeq, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35)), PntAPI

        For X = 1 To LenXOverSeq
            LineTo Pict, 30 + XDiffpos(X) * XFactor + XFactor, PicHeight - (15 + (((XOverHomologyNum(X, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35))
        Next 'X

    Next 'Y

    If RelX > 0 Or RelY > 0 Then

        Call Highlight

    End If

    'Form1.Picture7.Refresh
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = QBColor(0)
    X = LenXOverSeq

    For Y = 0 To 2
        Pict = Form1.Picture7.hdc

        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If

        MoveToEx Pict, 30 + XDiffpos(1) * XFactor, PicHeight - (15 + (((XOverHomologyNum(LenXOverSeq, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35)), PntAPI

        For X = 1 To LenXOverSeq
            LineTo Pict, 30 + XDiffpos(X) * XFactor + XFactor, PicHeight - (15 + (((XOverHomologyNum(X, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35))
        Next 'X

    Next 'Y

    'For some odd reason this C-routine is slower than its VB eqvalent
    '    For Y = 0 To 2
    '
    '        If Y = 0 Then
    '            Form1.Picture7.ForeColor = Yellow
    '        ElseIf Y = 1 Then
    '            Form1.Picture7.ForeColor = Green
    '        Else
    '            Form1.Picture7.ForeColor = Purple
    '        End If
    '        Pict = Form1.Picture7.hdc
    '        Dummy = PlotDraw(Pict, LenXoverSeq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, Y))
    '
    '    Next 'Y

    Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    RDPUD = RDPUD / (Int(XOverWindowX / 2) * 2 + 1)
    RDPLD = RDPLD / (Int(XOverWindowX / 2) * 2 + 1)
End Sub

Public Sub PrintHomolPlots()
    On Error GoTo errorhandler
    'Print button click event.
    'The subroutine works but just barely.
    Printer.Font = "Ariel"
    'Declare variables.
    'Set variables
    scaleaddjust = 3
    PrinterDefault = True
    Printer.ScaleMode = 1
    Printer.FontTransparent = True
    Printer.Zoom = 50
    ' Exit Sub

    Dim FontSizeT As Double

    Printer.ScaleMode = 3
    FontSizeT = 16 - (NextNo / 10)

    If FontSizeT < 4 Then FontSizeT = 4
    Printer.FontSize = 10
    Printer.DrawMode = 13 'Set drawmode to "copy pen"
    Printer.DrawStyle = 0
    Printer.DrawWidth = 1
    Printer.ForeColor = 0
    Printer.Orientation = 1
    'offset = (((Printer.Width - Picture2.ScaleWidth) / 2) / Screen.TwipsPerPixelX) * 3
    'Picture2.ScaleMode = 3

    Dim XMove As Integer
    Dim YMove As Integer

    XMove = 600
    YMove = 400
    Printer.DrawMode = 13
    'call UPGMA
    XFactor = (Printer.ScaleWidth - 800) / Len(StrainSeq(0))
    PicHeight = Printer.ScaleHeight / 4
    Printer.Font = "Ariel"
    'Dim XFactor As Double

    Dim TotalLen As Integer
    Dim YAdd As Integer

    'Inform user of the sequences being compared

    If RunFlag = 0 Then
        Printer.ForeColor = QBColor(0)

        If SpacerFlag > 0 Then

            If SpacerNo > 0 Then
                Printer.CurrentX = 0
                Printer.CurrentY = 70
                Printer.Print "REFERENCE SEQUENCES:"

                For X = 1 To SpacerNo
                    Printer.CurrentX = 0
                    Printer.CurrentY = 80 + 10 * X
                    Printer.Print StraiName(SpacerSeqs(X))
                Next 'X

            End If

        Else
            Printer.CurrentX = 0
            Printer.CurrentY = 70
            Printer.ForeColor = RGB(255, 0, 0)
            Printer.Print "NO REFERENCE SEQUENCES:"
            Printer.ForeColor = RGB(0, 0, 0)
        End If

        'Printer.Refresh
    Else
        Printer.CurrentX = 0
        Printer.ForeColor = QBColor(0)

        If SpacerFlag > 0 Then

            If SpacerNo > 0 Then
                Printer.CurrentX = XMove - 100
                Printer.CurrentY = YMove + 300 + PicHeight
                Printer.Print "REFERENCE SEQUENCES:"
                YAdd = 0
                TotalLen = 0

                For X = 1 To SpacerNo
                    Printer.CurrentX = XMove - 100 + TotalLen
                    Printer.CurrentY = YMove + 340 + PicHeight + YAdd '+ 10 * X
                    Printer.Print StraiName(SpacerSeqs(X))
                    TotalLen = TotalLen + 400

                    If TotalLen > Printer.ScaleWidth - 50 Then TotalLen = 0: YAdd = YAdd + 40
                Next 'X

            End If

        Else
            Printer.CurrentX = XMove - 100
            Printer.CurrentY = YMove + 300 + PicHeight
            Printer.ForeColor = RGB(255, 0, 0)
            Printer.Print "NO REFERENCE SEQUENCES"
            Printer.ForeColor = RGB(0, 0, 0)
        End If

    End If

    'Draw homology plot in picturebox 7
    'Form1.Picture7.Picture = Printer.Picture
    'Form1.Picture7.Top = 0
    'Form1.Picture7.Left = 0
    'Pict = Form1.Picture7.hdc
    '    Form1.Picture7.ForeColor = QBColor(0)
    '    dummy = DrawDiffs(Pict, lenxoverseq, XFactor, XDiffPos(0))
    '
    '    Form1.Picture7.ForeColor = QBColor(8)
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 0))
    '
    '    Form1.Picture7.ForeColor = green
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 1))
    '
    '    Form1.Picture7.ForeColor = purple
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 2))
    Printer.DrawWidth = 2

    For X = 1 To LenXOverSeq - 1
        'z = z + 1
        'Form1.Picture7.ForeColor = QBColor(0)
        'dummy = MoveToEx(pict, 10 + XDiffPos(X) * XFactor, 10, pntapi)
        'dummy = LineTo(pict, 10 + XDiffPos(X) * XFactor, 15)
        'Printer.ForeColor = QBColor(8)
        Printer.Line (XMove + XDiffpos(X + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X + 1, 0) * (PicHeight - 35)))-(XMove + XDiffpos(X) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X, 0) * (PicHeight - 35))), Yellow
        Printer.Line (XMove + XDiffpos(X + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X + 1, 1) * (PicHeight - 35)))-(XMove + XDiffpos(X) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X, 1) * (PicHeight - 35))), RGB(255, 0, 255)
        Printer.Line (XMove + XDiffpos(X + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X + 1, 2) * (PicHeight - 35)))-(XMove + XDiffpos(X) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(X, 2) * (PicHeight - 35))), RGB(0, 255, 255)
        '               Form1.Picture7.Line (25, 15)-(25, PicHeight - 10), QBColor(0)
        '               Form1.Picture7.Line (25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5, PicHeight - 10), QBColor(0)
        '
        '
        '        dummy = MoveToEx(10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 0) * (PicHeight - 35)))
        '        dummy = LineTo(10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 0) * (PicHeight - 35)))
        '   Printer.ForeColor = green
        '   dummy = MoveToEx(Pict, 10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 1) * (PicHeight - 35)), pntapi)
        '   dummy = LineTo(Pict, 10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 1) * (PicHeight - 35)))
        '  Printer.ForeColor = purple
        '  dummy = MoveToEx(Pict, 10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 2) * (PicHeight - 35)), pntapi)
        '  dummy = LineTo(Pict, 10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 2) * (PicHeight - 35)))
    Next 'X

    Printer.Line (XMove - 25, YMove)-(575, PicHeight + YMove + 25), QBColor(0)
    Printer.Line (XMove - 25, PicHeight + YMove + 25)-(25 + (XFactor * Len(StrainSeq(0)) + XMove), PicHeight + YMove + 25), QBColor(0)
    'Y-Axis tick marks
    Printer.Line (XMove - 25, YMove + 15)-(XMove - 10, YMove + 15), RGB(0, 0, 0)
    Printer.Line (XMove - 25, YMove - 15 + PicHeight)-(XMove - 10, YMove - 15 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove - 25, YMove - 15 + (PicHeight) / 2)-(XMove - 10, YMove - 15 + (PicHeight) / 2), RGB(0, 0, 0)
    '               'X-Axis tick marks
    Printer.Line (XMove, YMove + 25 + PicHeight)-(XMove, YMove + 5 + PicHeight), RGB(0, 0, 0)
    Printer.Line ((XFactor * Len(StrainSeq(0)) + XMove), YMove + 5 + PicHeight)-((XFactor * Len(StrainSeq(0)) + 600), YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 2, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 2, YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 4, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 4, YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333, YMove + 25 + PicHeight), RGB(0, 0, 0)
    '               Printer.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, 425 + PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, 405 + PicHeight), RGB(255, 0, 0)
    '               Printer.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, 425 + PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, 405 + PicHeight), RGB(255, 0, 0)
    Printer.ForeColor = RGB(0, 0, 0)

    For X = 1 To LenXOverSeq
        'XDiffPos(0) = X
        Printer.Line (XMove + XFactor * XDiffpos(X), YMove - 10)-(XMove + XFactor * XDiffpos(X), YMove - 30)
    Next 'X

    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 10
    Printer.Print "1.0"
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 40 + PicHeight / 2
    Printer.Print "0.5"
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 40 + PicHeight
    Printer.Print "0.0"
    Printer.CurrentX = XMove - 10
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print "1"

    Dim Addjust As Integer

    Addjust = 0

    If (Len(StrainSeq(0))) / 10 < 1 Then
        Addjust = 10
    ElseIf (Len(StrainSeq(0))) / 100 < 1 Then
        Addjust = 25
    ElseIf (Len(StrainSeq(0))) / 1000 < 1 Then
        Addjust = 40
    ElseIf (Len(StrainSeq(0))) / 10000 < 1 Then
        Addjust = 55
    ElseIf (Len(StrainSeq(0))) / 100000 < 1 Then
        Addjust = 70
    ElseIf (Len(StrainSeq(0))) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XFactor * Len(StrainSeq(0)) + XMove - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Len(StrainSeq(0))
    Addjust = 0

    If ((Len(StrainSeq(0))) / 2) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 2) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 2) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 2) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 2) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 2) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 2 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 2)
    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 2 - 200
    Printer.CurrentY = YMove + 100 + PicHeight
    Printer.Print "Position in alignment"
    Addjust = 0

    If ((Len(StrainSeq(0))) / 1.333) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 1.333)
    Addjust = 0

    If ((Len(StrainSeq(0))) / 4) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 4) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 4) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 4) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 4) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 4) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 4 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 4)
    Printer.ForeColor = Yellow
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 140 + PicHeight
    Printer.Print StraiName(Seq1) & "-" & StraiName(Seq2)
    Printer.ForeColor = RGB(255, 0, 255)
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 180 + PicHeight
    Printer.Print StraiName(Seq1) & "-" & StraiName(Seq3)
    Printer.ForeColor = RGB(0, 255, 255)
    Printer.Print ""
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 220 + PicHeight
    Printer.Print StraiName(Seq2) & "-" & StraiName(Seq3)
    'Printer.ForeColor = RGB(255, 0, 0)
    Printer.Line (XMove + RecStart * XFactor, YMove - 95)-(XMove + RecEnd * XFactor, YMove - 95)
    Printer.Line (XMove + RecStart * XFactor, YMove - 85)-(XMove + RecStart * XFactor, YMove - 105)
    Printer.Line (XMove + RecEnd * XFactor, YMove - 85)-(XMove + RecEnd * XFactor, YMove - 105)
    Printer.CurrentX = XMove - 20 + RecStart * XFactor
    Printer.CurrentY = YMove - 160
    Printer.Print RecStart
    Printer.CurrentX = XMove - 20 + RecEnd * XFactor
    Printer.CurrentY = YMove - 80
    Printer.Print RecEnd
    Printer.CurrentX = XMove + RecEnd * XFactor + 70
    Printer.CurrentY = YMove - 120
    Printer.Print RecProb
    Printer.CurrentX = XMove + RecEnd * XFactor + 40
    Printer.CurrentY = YMove - 120
    Printer.Font.Italic = True
    Printer.Print "P ="
    Printer.Font.Italic = False
    'Print probability
    '                        Form1.Picture7.CurrentX = 1 + ProbX '10 + XDiffPos(XOverList(CurrentXOver).Beginning) * XFactor
    '
    '                        Form1.Picture7.CurrentY = 1 + ProbY 'PicHeight - (15 + XHomology((XOverList(CurrentXOver).Beginning + ((XOverList(CurrentXOver).Ending - XOverList(CurrentXOver).Beginning) / 2)), Seq2, Seq3) * (PicHeight - 35))
    '
    '                        out$ = left$(ProbTest$, 4)
    '                        power$ = right$(ProbTest$, Len(ProbTest$) - (Pos + 1))
    '
    '                        Form1.Picture7.FontSize = 7
    '                        Form1.Picture7.ForeColor = QBColor(15)
    '                        Form1.Picture7.Print out$ + " X 10 "
    '                        Form1.Picture7.FontSize = 5
    Form1.Picture7.Enabled = True
    Form1.Picture7.Refresh
    Printer.EndDoc
    Exit Sub
errorhandler:
End Sub

Public Sub XOverIII(SPF)

    Dim EndFlag As Long, temp As Integer
    Dim X As Long, ET1 As Long, ET2 As Long, BT1 As Long, BT2 As Long
    Dim StringX As String
    Dim MinPA As Double
    Dim ActiveSeq As Integer
    Dim ActiveMajorP As Integer
    Dim ActiveMinorP As Integer
    Dim SeqDaughter As Integer
    Dim SeqMinorP As Integer
    oSeq1 = Seq1
    oSeq2 = Seq2
    oSeq3 = Seq3
   'Seq1 = 3
   ' Seq2 = 19
   ' Seq3 = 0
    MinPA = 1
    FirstDrawFlag = 0
    'SpacerFlag = 4

    'Dim AvHomol() As Double

   
    ReDim ValidSpacer(NextNo)
    'ReDim SpacerSeqs(Nextno)

    Dim HighHomol As Integer
    Dim MedHomol As Integer
    Dim LowHomol As Integer

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated and if a "spacer" is required

        Call CalcDistances(0, 0)

    End If

    'Find "spacer sequences"
    'NJFlag = 0

    If NJFlag = 0 Then

        Call UPGMA(0, 0)

        NJFlag = 1
    End If
    
    If SpacerFlag < 4 Then
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        
        'If UBound(TreeDistance, 1) <> Nextno Then
        '
       '
        'End If
        InRangeFlag = SpacerFindB(NextNo, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNo, TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqs(0), ValidSpacer(0))
        'Call SpacerFind

    Else
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        SpacerNo = 1
        SpacerSeqs(1) = Spacer4No
        'strainame(14) = x
    End If

    'If SpacerNo = 0 And SpacerFlag > 0 And ExeCheckFlag = 0 Then Exit Sub
    
    LenStrainSeq = Len(StrainSeq(0)) + 1
    
    If ExeCheckFlag = 0 Then
        XOverSeq(0) = ""
        XOverSeq(1) = ""
        XOverSeq(2) = ""
    End If
    
    'Find Information Rich Subsequences
    'SpacerFlag = 0
    ' If SpacerFlag > 0 And SpacerNo > 0 Then
    'C routine for finding information rich subsequences (it does the same thing as the
    'VB routine FindSubSeqX)
    'Call FindSubSeqX
    '      lenxoverseq = FindSubSeq(SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0))
    
    Call FindSubSeqRDP
    If LenXOverSeq = 0 Then Exit Sub
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000
    
    'If ExeCheckFlag = 1 And OptFlag <> 0 Then
    '    Be = XOverList(RelX, RelY).Beginning
    '    En = XOverList(RelX, RelY).Ending
    '    If Be < En Then
    '        XOverWindow = Int(XPosDiff(En) - XPosDiff(Be)) / 2
    '   Else
    '        XOverWindow = Int((XPosDiff(En) + (LenXoverSeq - XPosDiff(Be))) / 2)
    '    End If
    'Else
    '    XOverWindow = Int(XOverWindowX / 2)
    'End If
    
    XOverWindow = Int(XOverWindowX / 2)
    
    
    'Work out homologies
    ReDim Preserve XDiffpos(LenXOverSeq)
    ReDim XOverHomologyNum(LenXOverSeq + XOverWindow * 2, 2)
    'C Routine to work out moving homology averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    Dummy = XOHomology(1, LenStrainSeq, LenXOverSeq, XOverWindow, XOverSeqNumW(0, 0), XOverHomologyNum(0, 0))
    'Find Xovers
    
    
    
    If X = 12345 Then
        HighHomol = 1
    
         MedHomol = 2
                LowHomol = 3
                ActiveSeq = Seq1
                ActiveMajorP = Seq2
                ActiveMinorP = Seq3
                SeqDaughter = 0
                SeqMinorP = 2
    Else
        If TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) And TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) >= TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) Then
            HighHomol = 1
    
            If AvHomol(2) > AvHomol(3) Then
                MedHomol = 2: LowHomol = 3
                ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
                SeqDaughter = 0: SeqMinorP = 2
            Else
                MedHomol = 3: LowHomol = 2
                ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
                SeqDaughter = 1: SeqMinorP = 2
            End If
    
        ElseIf TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) And TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) Then
            HighHomol = 2
    
            If AvHomol(1) > AvHomol(3) Then
                MedHomol = 1: LowHomol = 3
                ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
                SeqDaughter = 0: SeqMinorP = 1
            Else
                MedHomol = 3: LowHomol = 1
                ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
                SeqDaughter = 2: SeqMinorP = 1
            End If
    
        ElseIf TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) And TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) Then
            HighHomol = 3
    
            If AvHomol(1) > AvHomol(2) Then
                MedHomol = 1: LowHomol = 2
                ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
                SeqDaughter = 1: SeqMinorP = 0
            Else
                MedHomol = 2: LowHomol = 1
                ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
                SeqDaughter = 2: SeqMinorP = 0
            End If
    
        End If
    End If
    'Check for medium line being higher than higher line
    'Dim NumDifferent As Integer
    ReDim Preserve XDiffpos(Len(StrainSeq(0)))
    
    On Error Resume Next
    LowestProb = Val(Form1.Text1.Text)
    LowestProb = CDbl(Form1.Text1.Text)
    On Error GoTo 0
    
    Dim FindCycle As Integer

    FindCycle = 0

    Dim Store As Integer
    Dim Storex As Integer
    Dim NumDifferent As Long
    Dim TempCurrent As Long, BE As Long, EN As Long, NC As Long

    ProbY = 1

    Do
        Storex = 0
        NextPosX = StartPosX
        For X = 1 To LenXOverSeq

            If XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, LowHomol - 1) And XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, HighHomol - 1) Then

                If CircularFlag = 1 And XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, HighHomol - 1) And X = 1 Then

                    Do Until XOverHomologyNum(X, MedHomol - 1) <= XOverHomologyNum(X, HighHomol - 1)
                        X = X + 1
                    Loop

                    If XOverHomologyNum(LenXOverSeq, MedHomol - 1) <= XOverHomologyNum(LenXOverSeq, HighHomol - 1) Then
                        XOverHomologyNum(LenXOverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
                        XOverHomologyNum(LenXOverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
                    End If

                Else
                    If X = X Then
                        NCommon = 0
                        'LowHomol = 2
                        'HighHomol = 1
                        XOverLength = 0
                        Dummy = DefineEvent(ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, X, XOverWindow, Len(StrainSeq(0)), LenXOverSeq, SeqDaughter, SeqMinorP, EndFlag, BE, EN, NCommon, XOverLength, XOverSeqNumW(0, 0), XDiffpos(0), XOverHomologyNum(0, 0))
                        'If Be = 5629 Then
                        '    X = X
                        '    En = En
                        '    For Z = 0 To LenXoverSeq
                        '        If testpa(Z, MedHomol - 1) <> XOverSeqNum(Z, MedHomol - 1) Then
                        '            X = X
                        '        End If
                        '        If testpa(Z, HighHomol - 1) <> XOverSeqNum(Z, HighHomol - 1) Then
                        '            X = X
                        '        End If
                        '        If testpa(Z, LowHomol - 1) <> XOverSeqNum(Z, LowHomol - 1) Then
                        '            X = X
                        '        End If
                        '    Next Z
                        '    XX = SEventNumber
                        '    XX = Seq1
                        '    XX = Seq2
                        '    XX = Seq3
                        'End If
                        X = Dummy
                        '5.469 1K perms
                        
                        indprob = AvHomol(MedHomol)
                        NumDifferent = XOverLength - NCommon
                    Else
                        If X > 1 Then
    
                            Do Until X = 1
                                X = X - 1
    
                                If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) Then
                                    X = X + 1
                                    Exit Do
                                End If
    
                            Loop
    
                        End If
    
                        If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) Then
    
                            Do Until X = LenXOverSeq
                                X = X + 1
    
                                If XOverSeqNum(X, SeqDaughter) = XOverSeqNum(X, SeqMinorP) Then
                                    'X = X - 1
                                    Exit Do
                                End If
    
                            Loop
    
                        End If
    
                        
                        
                        If CircularFlag = 0 And X = 1 Then
                            BE = 1
                        Else
                            BE = XDiffpos(X)
                            'Exit Sub
                        End If
                        
                        XOverLength = 0
                        NC = 0
                        Do Until XOverHomologyNum(X, MedHomol - 1) < XOverHomologyNum(X, HighHomol - 1) And XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP)
    
                            If XOverSeqNum(X, SeqDaughter) = XOverSeqNum(X, SeqMinorP) Then
                                NC = NC + 1
                            End If
    
                            XOverLength = XOverLength + 1: If XOverLength >= LenXOverSeq Then Exit Do
                            X = X + 1
    
                            If X > LenXOverSeq Then
    
                                If CircularFlag = 1 Then
                                    X = 1
                                    EndFlag = 1
                                Else
                                    X = LenXOverSeq + 2 * XOverWindow + 1
                                    Exit Do
                                End If
    
                            End If
    
                        Loop
    
                        Storex = X
                        X = X - 1
                        Store = 0
    
                        Do
    
                            If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) And X < LenXOverSeq And X > 1 Then
                                X = X - 1
                                Store = Store + 1
                                XOverLength = XOverLength - 1
    
                                If XOverLength = 1 Then Exit Do
                            Else
                                Exit Do
                            End If
    
                        Loop
    
                        'X = X + 1
    
                        If X = LenXOverSeq + 2 * XOverWindow + 1 And CircularFlag = 0 Then
                            EN = Len(StrainSeq(0))
                        Else
    
                            If NC > 1 Then
                                EN = XDiffpos(X)
                            Else
                                EN = XDiffpos(X)
                            End If
    
                        End If
                        
                        'X = X + 1 + Store
                        X = Storex + 1
    
                        If EN = 0 Then EN = Len(StrainSeq(0)) - 1
                        indprob = AvHomol(MedHomol)
                        NumDifferent = XOverLength - NC
                    End If
                    
                    If XOverLength > 2 Then
                                        If XOverLength >= 170 Then
                            AFact = XOverLength / 169
                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                            XOverLength = 169
                        Else
                            AFact = 1
                        End If
                        'C routine that calculates the probability of the "recomination" having occured by chance.
                        ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                        ProbabilityXOver = ProbabilityXOver ^ AFact
                        'Call CorrectProb

                    
                    End If

                    If MCFlag = 0 Then
                        ProbabilityXOver = ProbabilityXOver * MCCorrection
                    ElseIf MCFlag = 2 Then
                        ProbabilityXOver = StepDown2(0, ProbabilityXOver)
                    End If
                    

                    If EN = BE Then
                       ProbabilityXOver = 1
                    ElseIf EN < BE And CircularFlag = 0 Then
                        ProbabilityXOver = 1
                    End If
                    BT2 = XOverList(RelX, RelY).Beginning
                    ET2 = XOverList(RelX, RelY).Ending
                    If ET2 < BT2 Then ET2 = ET2 + Len(StrainSeq(0))
                    
                    
                    If BE <= EN Then
                        BT1 = BE
                        ET1 = EN
                        

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                        End If

                    Else
                        BT1 = BE
                        ET1 = EN + Len(StrainSeq(0))

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                        End If
                        If MinPA = 1 Then
                            BT1 = BE - Len(StrainSeq(0))
                            ET1 = EN
    
                            If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap
    
                                If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                            End If
                            X = X
                        End If
                    End If

                    If ProbabilityXOver > -1 And (ProbabilityXOver < 1 Or ExeCheckFlag = 1) Then
                        ' oRecombNo(100)  = oRecombNo(100) + 1
                        'ProbTest$ = XOverList(ActiveSeq, TempCurrent).Probability

                        If FirstDrawFlag = 0 And SPF = 0 Then
                            Form1.Picture7.ForeColor = QBColor(12)
                            Form1.Picture7.FontBold = True
                            Call DrawPlots(Seq1, Seq2, Seq3)
                            'XX = StraiName(33)
                            'XX = TreeTrace(33)
                            FirstDrawFlag = 1
                        End If
                        If ProbabilityXOver < 0.1 Or CurrentCheck = 0 Then
                            If BT2 < ET2 Then
                                ProbX = BT2 + (ET2 - BT2) / 2
                            Else
    
                                If ET2 > Len(StrainSeq(0)) - BT2 Then
                                    ProbX = ET2 / 2
                                Else
                                    ProbX = BT2 + (Len(StrainSeq(0)) - BT2) / 2
                                End If
    
                            End If
                            ProbTest$ = ProbabilityXOver
                            Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
    'if spf = 0 then call printprobability
                            If BT1 < ET2 And ET1 > BT2 Then
                                If Pos > 0 Then
        
                                    If SPF = 0 Then Call PrintProbability
        
                                ElseIf ProbabilityXOver > 0 And ProbabilityXOver < 1 Then
        
                                    If SPF = 0 Then Call PrintProbabilityII
        
                                End If
                            End If
                        End If
                    ElseIf ProbabilityXOver >= LowestProb Then
                        ProbabilityXOver = 0
                    End If

                End If

            End If

            If EndFlag = 1 Then
                EndFlag = 0
                X = LenXOverSeq
            End If

        Next 'X

        If FindCycle = 0 Then
            temp = MedHomol
            MedHomol = LowHomol
            LowHomol = temp
        ElseIf FindCycle = 1 Then
            'Exit Do
            If AvHomol(HighHomol) < 1# Then
                temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = temp
            Else
                Exit Do
            End If
        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq2
            ActiveMinorP = Seq3
            SeqDaughter = 0
            SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq1
            ActiveMinorP = Seq3
            SeqDaughter = 1
            SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq3
            ActiveMinorP = Seq2
            SeqDaughter = 0
            SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            SeqDaughter = 2
            SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq3
            ActiveMinorP = Seq1
            SeqDaughter = 1
            SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq2
            ActiveMinorP = Seq1
            SeqDaughter = 2
            SeqMinorP = 0
        End If


        FindCycle = FindCycle + 1
    Loop

    If FirstDrawFlag = 0 And SPF = 0 Then
        Form1.Picture7.ForeColor = QBColor(12)
        Form1.Picture7.FontBold = True
        Call DrawPlots(Seq1, Seq2, Seq3)

    End If
    If LongWindedFlag = 0 Then
        EN = XOverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventlist(XOverList(RelX, RelY).Eventnumber)
    End If
    '
    PT = 10 ^ (-ConfirmP(EN, 0))
    
    If Confirm(EN, 0) = 1 Or (XOverList(RelX, RelY).ProgramFlag <> 0 And XOverList(RelX, RelY).ProgramFlag <> 0 + AddNum) Then

        If ((Confirm(EN, 0) = 0 Or (Confirm(EN, 0) = 1) And MinPA < PT)) And MinPA < 1 And MinPA > 0 Then
            Confirm(EN, 0) = 1
            ConfirmP(EN, 0) = -Log10(MinPA)
            DoEvents

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

    End If
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
End Sub
Public Sub UpdatePlot(DA As Long, Ma As Long, Mi As Long)

    Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    ReDim NJSubDistance(NextNo, NextNo)
    ReDim ValidSite(NextNo, NextNo)
    StartY = 15
    PVal = -Log10(XOverList(DA, CurrentXover(DA)).Probability)
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    LSeq = Len(StrainSeq(0))

    If PVal > PerMaxPval Then
        PVal = PerMaxPval
    End If

    'Form1.Picture7.ScaleMode = 3

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, X As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double

    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10
    'this coluld be speeded up with better nesting of if then's

    For Z = 0 To NextNo
        Dummy = DistanceCalcE(Z, NextNo, LSeq + 1, XOverList(DA, CurrentXover(DA)).Beginning, XOverList(DA, CurrentXover(DA)).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
    Next 'Z

    Dim TotCompare As Long

    TotCompare = 0

    For X = 0 To NextNo

        For Y = X + 1 To NextNo

            If NJSubDistance(X, Y) <> 0 Then
                AvSDst = AvSDst + (1 - NJSubDistance(X, Y))
                TotCompare = TotCompare + 1
            End If

        Next 'Y

    Next 'X

    If TotCompare > 0 Then
        AvSDst = AvSDst / TotCompare
    Else
        Exit Sub
    End If

    Dim MFactor As Integer, Partnumber As Integer
    Dim DistMod As Double

    DistMod = AvSDst / AvDst

    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String

    'If ValidSite(Da, Mi) = 0 Then ValidSite(Da, Mi) = 1
    'If ValidSite(Da, Ma) = 0 Then ValidSite(Da, Ma) = 1
    'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).

    If DA <> Ma Then

        If ((1 - Distance(DA, Ma)) * DistMod) < 1 - NJSubDistance(DA, Mi) Then
            Dst = (1 - NJSubDistance(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
        Else
            Dst = (1 - NJSubDistance(DA, Ma)) - (1 - NJSubDistance(DA, Mi))
        End If

    Else
        Dst = (1 - Distance(DA, Mi)) * DistMod
    End If

    If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod

    If oDMax < Dst Then oDMax = Dst

    If XOverList(DA, CurrentXover(DA)).Beginning < XOverList(DA, CurrentXover(DA)).Ending Then
        X1 = 30 + XOverList(DA, CurrentXover(DA)).Beginning * XFactor + XFactor
        X2 = 30 + XOverList(DA, CurrentXover(DA)).Ending * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
    Else
        X1 = 30 + XOverList(DA, CurrentXover(DA)).Beginning * XFactor + XFactor
        X2 = 30 + LSeq * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
        X1 = 30 + 1 * XFactor + XFactor
        X2 = 30 + XOverList(DA, CurrentXover(DA)).Ending * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
    End If

    If oPMax < PVal Then oPMax = PVal

    If XOverList(DA, CurrentXover(DA)).Beginning < XOverList(DA, CurrentXover(DA)).Ending Then
        X1 = 30 + XOverList(DA, CurrentXover(DA)).Beginning * XFactor + XFactor
        X2 = 30 + XOverList(DA, CurrentXover(DA)).Ending * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
    Else
        X1 = 30 + XOverList(DA, CurrentXover(DA)).Beginning * XFactor + XFactor
        X2 = 30 + LSeq * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
        X1 = 30 + 1 * XFactor + XFactor
        X2 = 30 + XOverList(DA, CurrentXover(DA)).Ending * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, CurrentXover(DA)).ProgramFlag), BF
    End If

    Form1.Picture7.Line (30 + 1 * XFactor + XFactor, P4 - 5 - 1 * (P4 - P3 - 10))-(30 + LSeq * XFactor + XFactor, P4 - 5 - 0 * (P4 - P3 - 10)), BackColours, BF
    Pict = Form1.Picture7.hdc
    'Form1.Picture7.AutoRedraw = False

    If XOverList(DA, CurrentXover(DA)).Beginning < XOverList(DA, CurrentXover(DA)).Ending Then

        If XOverList(DA, CurrentXover(DA)).Ending > LSeq Then
            XOverList(DA, CurrentXover(DA)).Ending = LSeq
        End If

        If XOverList(DA, CurrentXover(DA)).Beginning > LSeq - 10 Then
            XOverList(DA, CurrentXover(DA)).Beginning = LSeq - 10
            XOverList(DA, CurrentXover(DA)).Ending = LSeq
        End If

        For X = XOverList(DA, CurrentXover(DA)).Beginning To XOverList(DA, CurrentXover(DA)).Ending
            Hitnumber(X) = Hitnumber(X) + 1

            If Hitnumber(X) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

    Else

        For X = 1 To XOverList(DA, CurrentXover(DA)).Ending
            Hitnumber(X) = Hitnumber(X) + 1

            If Hitnumber(X) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

        For X = XOverList(DA, CurrentXover(DA)).Beginning To LSeq
            Hitnumber(X) = Hitnumber(X) + 1

            If Hitnumber(X) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

    End If

    If RedoLabelFlag = 1 Then
        RedoLabelFlag = 0
        LVal = 0
        UVal = MaxHits
        Z = 2
        MFactor = 1
        Partnumber = (PicHeight / 3 - 35) / (Form1.Picture7.TextHeight("0") * 3)

        If Partnumber < 3 Then Partnumber = 3
        YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (Partnumber - 1))
        X = 0
        EY = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        SY = CLng(EY + YIncriment * (Partnumber - 1))

        For Y = SY To EY Step -(YIncriment)
            Outnum = (LVal + (UVal - LVal) * (X / (Partnumber - 1))) * MFactor

            If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then

                If LVal * 1000 > UVal Then
                    MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                    XLegendA = XLegendA + " (x " & Trim$(CStr(MFactor)) & ")"
                    Outnum = Outnum * MFactor
                Else
                    Outnum = 0
                End If

            End If

            SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
            'Exit Sub

            If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = "0" & SOutNum

            If CDbl(SOutNum) = Int(CDbl(SOutNum)) Then SOutNum = SOutNum + ".0"

            If CDbl(SOutNum) >= 100 And CDbl(SOutNum) < 1000 Then
                SOutNum = " " & Trim$(CStr(Int(CDbl(SOutNum))))
            End If

            If Len(SOutNum) < 4 Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 Then
                SOutNum = left$(SOutNum, 4)
            End If

            Form1.Picture7.Line (0, CLng(Y - Form1.Picture7.TextHeight("0") / 2))-(20, Y + Form1.Picture7.TextHeight("0") / 2), BackColours, BF
            Form1.Picture7.CurrentY = CLng(Y - Form1.Picture7.TextHeight("0") / 2)
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            X = X + 1
        Next 'Y

    End If

    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (Hitnumber(1) / MaxHits) * (P4 - P3 - 10), Pnt

    For X = 2 To LSeq
        LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (Hitnumber(X) / MaxHits) * (P4 - P3 - 10)
    Next 'X

    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotE(BPos As Long, EPos As Long, PVal As Double, oPMax As Double, oPMin As Double, DistX As Double, Mi, MaxBP() As Double, BPlots() As Double)
    
    Dim NJSubDistance() As Double, ValidSite() As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim PValx As Double, StartY As Integer
    If DistX > 0.5 Then DistX = 0.5
    PValx = -Log10(PVal)
    Form1.Picture7.ScaleMode = 3
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    LSeq = Len(StrainSeq(0))

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, X As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10


    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    Partnumber = (PicHeight / 3 - 35) / (TH * 3)

    If Partnumber < 3 Then Partnumber = 3

    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (Partnumber - 1))

    'Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P2 - 5 - (P2 - P1 - 10)))-(30 + lseq * XFactor + XFactor, (P2 - 5)), BackColours, BF
    Form1.Picture7.Line ((30 + 1 * XFactor + XFactor), (P3 - 5 - (P3 - P2 - 10)))-(30 + LSeq * XFactor + XFactor, P3 - 5), BackColours, BF
    Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P4 - 5 - (P4 - P3 - 10)))-(30 + LSeq * XFactor + XFactor, P4 - 5), BackColours, BF

    Form1.Picture7.ForeColor = 0
    X = 0
    
    For Z = 0 To 2
        
        If RedoPltL(Z) = 1 Then
            Pict = Form1.Picture7.hdc
            RedoPltL(Z) = 0
            X = 0
    
            If Z = 1 Then
                UVal = MaxBP(0)
                LVal = 0
            ElseIf Z = 0 Then
                UVal = oPMax
                LVal = 0
            Else
                UVal = MaxBP(1)
                LVal = 0
            End If
    
            MFactor = 1
            YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
            YS = CLng(YE + YIncriment * (Partnumber - 1))
    
            For Y = YS To YE Step -(YIncriment)
                Outnum = (LVal + (UVal - LVal) * (X / (Partnumber - 1))) * MFactor
    
                If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then
    
                    If LVal * 1000 > UVal Then
                        MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                        Outnum = Outnum * MFactor
                    Else
                        Outnum = 0
                    End If
    
                End If
    
                SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
                'Exit Sub
                Outnum = (CLng(Outnum * 100)) / 100
                If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = SOutNum
    
                If Outnum = Int(SOutNum) Then
                    
                    SOutNum = SOutNum + ".0"
                End If
                If Outnum >= 100 And Outnum < 1000 Then
                    SOutNum = " " & Trim$(CStr(Int(Outnum)))
                End If
    
                If Len(SOutNum) < 4 Then
                    SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
                ElseIf Len(SOutNum) > 4 Then
                    SOutNum = left$(SOutNum, 4)
                End If
                Form1.Picture7.Line (0, CLng(Y - TH / 2))-(20, Y + TH / 2), BackColours, BF
                Form1.Picture7.CurrentY = CLng(Y - TH / 2)
                Form1.Picture7.CurrentX = 0
                'TextOut Pict, 0, CLng(Y - TH / 2), SOutNum, Len(SOutNum)
                Form1.Picture7.Print SOutNum
                X = X + 1
            
            Next 'Y
        Else
        
        End If

    Next 'Z
    Dim DistXX As Long
    'For Y = 0 To AddNum - 1
    '    If StartPlt(Y) = 1 Then
            If Mi = 0 Then
                DistXX = ((DistX - 0.5) / (-0.5) * 768)
                Call DistColour(DistXX)
            Else
                DistXX = RGB(128, 128, 128)
            End If
            Form1.Picture7.ForeColor = DistXX
            'Form1.Picture7.ForeColor = QBColor(3)
            'Form1.Picture7.DrawWidth = 4
            Pict = Form1.Picture7.hdc
            
            'top plot
            
            MoveToEx Pict, 30 + BPos * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
            If BPos < EPos Then
                LineTo Pict, 30 + BPos * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + EPos * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + EPos * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + BPos * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                X = X
            Else
                LineTo Pict, 30 + BPos * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Len(StrainSeq(0)) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                MoveToEx Pict, 30 + BPos * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
                LineTo Pict, 30 + Len(StrainSeq(0)) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                
                MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
                LineTo Pict, 30 + EPos * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + EPos * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
            End If
            
            Form1.Picture7.ForeColor = 0
           
            'middle plot
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - (BPlots(0, 1) / MaxBP(0)) * (P3 - P2 - 10), Pnt
            For X = 2 To LSeq
            
                LineTo Pict, 30 + X * XFactor + XFactor, P3 - 5 - (BPlots(0, X) / MaxBP(0)) * (P3 - P2 - 10)
            Next 'X
            
            'Bottom plot
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (BPlots(1, 1) / MaxBP(1)) * (P4 - P3 - 10), Pnt
            For X = 2 To LSeq
                
                LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (BPlots(1, X) / MaxBP(1)) * (P4 - P3 - 10)
            Next 'X
            'Form1.Picture7.ForeColor = BackColours
            'MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5, Pnt
            'LineTo Pict, 30 + LSeq * XFactor + XFactor, P2 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5, Pnt
            LineTo Pict, 30 + LSeq * XFactor + XFactor, P3 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5, Pnt
            LineTo Pict, 30 + LSeq * XFactor + XFactor, P4 - 5

     '   End If
    'Next 'Y
    Dim SP As Long
    'For Y = AddNum - 1 To 0 Step -1 'AddNum - 1
        'If StartPlt(Y) = 1 Then
        For Y = 0 To 1
            X = 1
            Do
                Form1.Picture7.ForeColor = 0
                If BPlots(Y, X) > 0 Then
                    SP = X
                    
                    X = X + 1
                    Do While X <= LSeq
                        If BPlots(Y, X) = 0 Then
                            X = X + 2
                            Exit Do
                        End If
                        X = X + 1
                    Loop
                    Pict = Form1.Picture7.hdc
                    If Y = 0 Then
                        MoveToEx Pict, 30 + SP * XFactor + XFactor, P3 - 5, Pnt
                        LineTo Pict, 30 + X * XFactor + XFactor + 1, P3 - 5
                    Else
                        MoveToEx Pict, 30 + SP * XFactor + XFactor, P4 - 5, Pnt
                        LineTo Pict, 30 + X * XFactor + XFactor + 1, P4 - 5
                    End If
                    
                End If
                X = X + 1
            Loop While X <= LSeq
            If CircularFlag = 0 Then
                If BPlots(0, 1) > 0 Then
                    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - (BPlots(0, 1) / MaxBP(0)) * (P3 - P2 - 10), Pnt
                    LineTo Pict, 30 + 1 * XFactor + XFactor, P3 - 5
                End If
                If BPlots(1, 1) > 0 Then
                    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (BPlots(1, 1) / MaxBP(1)) * (P4 - P3 - 10), Pnt
                    LineTo Pict, 30 + 1 * XFactor + XFactor, P4 - 5
                End If
           
            End If
            X = X
            
        Next Y
        'End If
    'Next 'Y
    
    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotC()
AddTimes = AddTimes + 1
    Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    LSeq = Len(StrainSeq(0))

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, X As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10


    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    Partnumber = (PicHeight / 3 - 35) / (TH * 3)

    If Partnumber < 3 Then Partnumber = 3

    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (Partnumber - 1))

    Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P2 - 5 - (P2 - P1 - 10)))-(30 + LSeq * XFactor + XFactor, (P2 - 5)), BackColours, BF
    Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P3 - 5 - (P3 - P2 - 10)))-(30 + LSeq * XFactor + XFactor, P3 - 5), BackColours, BF
    Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P4 - 5 - (P4 - P3 - 10)))-(30 + LSeq * XFactor + XFactor, P4 - 5), BackColours, BF

    Form1.Picture7.ForeColor = 0
    X = 0
    
    For Z = 0 To 2
        
        If RedoPltL(Z) = 1 Then
            Pict = Form1.Picture7.hdc
            RedoPltL(Z) = 0
            X = 0
    
            If Z = 0 Then
                UVal = oDMax
                LVal = 0
            ElseIf Z = 1 Then
                UVal = oPMax
                LVal = 0
            Else
                UVal = MaxHits
                LVal = 0
            End If
    
            MFactor = 1
            YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
            YS = CLng(YE + YIncriment * (Partnumber - 1))
    
            For Y = YS To YE Step -(YIncriment)
                Outnum = (LVal + (UVal - LVal) * (X / (Partnumber - 1))) * MFactor
    
                If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then
    
                    If LVal * 1000 > UVal Then
                        MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                        Outnum = Outnum * MFactor
                    Else
                        Outnum = 0
                    End If
    
                End If
    
                SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
                'Exit Sub
                Outnum = (CLng(Outnum * 100)) / 100
                If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = SOutNum
    
                If Outnum = Int(SOutNum) Then
                    
                    SOutNum = SOutNum + ".0"
                End If
                If Outnum >= 100 And Outnum < 1000 Then
                    SOutNum = " " & Trim$(CStr(Int(Outnum)))
                End If
    
                If Len(SOutNum) < 4 Then
                    SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
                ElseIf Len(SOutNum) > 4 Then
                    SOutNum = left$(SOutNum, 4)
                End If
                Form1.Picture7.Line (0, CLng(Y - TH / 2))-(20, Y + TH / 2), BackColours, BF
                Form1.Picture7.CurrentY = CLng(Y - TH / 2)
                Form1.Picture7.CurrentX = 0
                'TextOut Pict, 0, CLng(Y - TH / 2), SOutNum, Len(SOutNum)
                Form1.Picture7.Print SOutNum
                X = X + 1
            
            Next 'Y
        Else
        
        End If

    Next 'Z
    
    For Y = 0 To AddNum - 1
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgColour(Y)
            'Form1.Picture7.ForeColor = QBColor(3)
            'Form1.Picture7.DrawWidth = 4
            Pict = Form1.Picture7.hdc
            
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - (PDistPlt(1, Y) / oDMax) * (P2 - P1 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P2 - 5 - (PDistPlt(X, Y) / oDMax) * (P2 - P1 - 10)
            Next 'X
            
           
            
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - (ProbPlt(1, Y) / oPMax) * (P3 - P2 - 10), Pnt
            For X = 2 To LSeq
            If ProbPlt(X, Y) > 2 Then
                    X = X
                End If
                LineTo Pict, 30 + X * XFactor + XFactor, P3 - 5 - (ProbPlt(X, Y) / oPMax) * (P3 - P2 - 10)
            Next 'X
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (HitPlt(1, Y) / MaxHits) * (P4 - P3 - 10), Pnt
            For X = 2 To LSeq
                
                LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (HitPlt(X, Y) / MaxHits) * (P4 - P3 - 10)
            Next 'X
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5, Pnt
            LineTo Pict, 30 + LSeq * XFactor + XFactor + 1, P2 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5, Pnt
            LineTo Pict, 30 + LSeq * XFactor + XFactor + 1, P3 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5, Pnt
            LineTo Pict, 30 + LSeq * XFactor + XFactor + 1, P4 - 5

        End If
    Next 'Y
    Dim SP As Long
    For Y = AddNum - 1 To 0 Step -1 'AddNum - 1
        If StartPlt(Y) = 1 Then
            X = 1
            Do
                Form1.Picture7.ForeColor = ProgColour(Y)
                If HitPlt(X, Y) > 0 Then
                    SP = X
                    
                    X = X + 1
                    Do While X <= LSeq
                        If HitPlt(X, Y) = 0 Then
                            X = X + 2
                            Exit Do
                        End If
                        X = X + 1
                    Loop
                    Pict = Form1.Picture7.hdc
                    MoveToEx Pict, 30 + SP * XFactor + XFactor, P2 - 5, Pnt
                    LineTo Pict, 30 + X * XFactor + XFactor + 1, P2 - 5
                    MoveToEx Pict, 30 + SP * XFactor + XFactor, P3 - 5, Pnt
                    LineTo Pict, 30 + X * XFactor + XFactor + 1, P3 - 5
                    MoveToEx Pict, 30 + SP * XFactor + XFactor, P4 - 5, Pnt
                    LineTo Pict, 30 + X * XFactor + XFactor + 1, P4 - 5
                End If
                X = X + 1
            Loop While X <= LSeq
            If CircularFlag = 0 Then
                'PDistPlt(1, Y) / oDMax
                If PDistPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - PDistPlt(1, Y) / oDMax * (P2 - P1 - 10), Pnt
                    LineTo Pict, 30 + 1 * XFactor + XFactor, P2 - 5
                End If
                If HitPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - HitPlt(1, Y) / MaxHits * (P4 - P3 - 10), Pnt
                    LineTo Pict, 30 + 1 * XFactor + XFactor, P4 - 5
                End If
                If ProbPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - ProbPlt(1, Y) / oPMax * (P3 - P2 - 10), Pnt
                    LineTo Pict, 30 + 1 * XFactor + XFactor, P3 - 5
                End If
           
            End If
            X = X
        End If
    Next 'Y
    'ReDim StartPlt(AddNum)
    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotD()

Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
Dim Pnt As POINTAPI
Dim XOLen As Long, LSeq As Long, Pict As Long, SY As Long, EY As Long
Dim RedoLabelFlag As Integer
Dim StartY As Integer
Dim Dst As Double
Dst = 0
oDMax = 0
oPMax = 0
MaxHits = 0
ReDim PDistPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
ReDim ProbPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
ReDim HitPlt(Len(StrainSeq(0)) + 10, AddNum - 1)
ReDim Hitnumber(Len(StrainSeq(0)) + 10)
            
PDistPlt(0, 0) = PDistPlt(0, 0)

Form1.SSPanel1.Caption = "Plotting " & StraiName(0) & " Regions"
Form1.Refresh
For Z = 0 To NextNo
    For Y = 1 To CurrentXover(Z)
        If XOverList(Z, Y).Accept <> 2 Then
            DA = Z
            Ma = XOverList(Z, Y).MajorP
            Mi = XOverList(Z, Y).MinorP
            ReDim NJSubDistance(NextNo, NextNo)
            ReDim ValidSite(NextNo, NextNo)
            StartY = 15
            PVal = -Log10(XOverList(Z, Y).Probability)
            Form1.Picture7.AutoRedraw = True
            XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
            LSeq = Len(StrainSeq(0))
        
            If PVal > PerMaxPval Then
                PerMaxPval = PVal
            End If
        
            'Form1.Picture7.ScaleMode = 3
        
            Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
            Dim YIncriment As Long
            Dim AvSDst As Double, LVal As Double, UVal As Double
        
            P1 = StartY
            P2 = StartY + (PicHeight - 10 - StartY) / 3
            P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
            P4 = PicHeight - 10
            AvSDst = 0
            'Calculate parental distances at approx time of recombination event
            If XOverList(DA, Y).Beginning < XOverList(DA, Y).Ending Then
                XOLen = XOverList(DA, Y).Ending - XOverList(DA, Y).Beginning
                For A = XOverList(DA, Y).Beginning To XOverList(DA, Y).Ending
                    AvSDst = AvSDst + TBkgHomol(A)
                Next A
            Else
                XOLen = XOverList(DA, Y).Ending + Len(StrainSeq(0)) - XOverList(DA, Y).Beginning
                For A = 1 To XOverList(DA, Y).Ending
                    AvSDst = AvSDst + TBkgHomol(A)
                Next A
                For A = XOverList(DA, Y).Beginning To Len(StrainSeq(0))
                    AvSDst = AvSDst + TBkgHomol(A)
                Next A
            End If
            
            AvSDst = 1 - AvSDst / XOLen
                'this coluld be speeded up with better nesting of if then's

            'For Z = 0 To Nextno
            Dummy = DistanceCalcE(DA, NextNo, LSeq + 1, XOverList(DA, Y).Beginning, XOverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(Ma, NextNo, LSeq + 1, XOverList(DA, Y).Beginning, XOverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(Mi, NextNo, LSeq + 1, XOverList(DA, Y).Beginning, XOverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            'Next 'Z
        
            Dim TotCompare As Long
        
            TotCompare = 0
            
            Dim MFactor As Integer, Partnumber As Integer
            Dim DistMod As Double
        
            DistMod = AvSDst / AvDst
        
            Dim Outnum As Double
            Dim SOutNum As String
            Dim XLegendA As String
        
            'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).
        
            If DA <> Ma Then
        
                If ((1 - Distance(DA, Ma)) * DistMod) < 1 - NJSubDistance(DA, Mi) Then
                    Dst = (1 - NJSubDistance(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
                Else
                    Dst = (1 - NJSubDistance(DA, Ma)) - (1 - NJSubDistance(DA, Mi))
                End If
        
            Else
                Dst = (1 - Distance(DA, Mi)) * DistMod
            End If
        
            If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod
        'XXXZZZ    XOverlist(Da, Y).EndPermP = Dst
            
            If oDMax < Dst Then
                RedoPltL(0) = 1
                oDMax = Dst + 0.1
            End If
            
            If oPMax < PVal Then
                oPMax = PVal * 1.5
                RedoPltL(1) = 1
            End If
        
            If XOverList(DA, Y).Beginning < XOverList(DA, Y).Ending Then
        
                If XOverList(DA, Y).Ending > LSeq Then
                    XOverList(DA, Y).Ending = LSeq
                End If
        
                If XOverList(DA, Y).Beginning > LSeq - 10 Then
                    XOverList(DA, Y).Beginning = LSeq - 10
                    XOverList(DA, Y).Ending = LSeq
                End If
        
                For X = XOverList(DA, Y).Beginning To XOverList(DA, Y).Ending
                    HitPlt(X, XOverList(DA, Y).ProgramFlag) = HitPlt(X, XOverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(X, XOverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(X, XOverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(X, XOverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(X, XOverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(X, XOverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
                Next 'X
        
            Else
        
                For X = 1 To XOverList(DA, Y).Ending
                    Hitnumber(X) = Hitnumber(X) + 1
                    
                    HitPlt(X, XOverList(DA, Y).ProgramFlag) = HitPlt(X, XOverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(X, XOverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(X, XOverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(X, XOverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(X, XOverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(X, XOverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
        
                Next 'X
        
                For X = XOverList(DA, Y).Beginning To LSeq
                    Hitnumber(X) = Hitnumber(X) + 1
                    
                    HitPlt(X, XOverList(DA, Y).ProgramFlag) = HitPlt(X, XOverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(X, XOverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(X, XOverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(X, XOverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(X, XOverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(X, XOverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
                    
                Next 'X
        
            End If
        End If
    Next Y
    Form1.ProgressBar1.Value = (Z / NextNo) * 100
    If Z < NextNo Then
        Form1.SSPanel1.Caption = "Plotting " & StraiName(Z + 1) & " Regions"
    End If
    'Form1.Refresh
    
Next Z

For Z = 0 To 2
    
    RedoPltL(Z) = 1
    'Exit Sub
Next Z
ReDim StartPlt(AddNum - 1)
For Z = 0 To AddNum - 1
    
   StartPlt(Z) = 1
    'Exit Sub
Next Z
'oDMax = oPMax

Form1.ProgressBar1.Value = 0
Form1.SSPanel1.Caption = ""
End Sub

Public Sub UpdatePlotB(DA, Ma, Mi, SIP)

    Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
    Dim Pnt As POINTAPI
    Dim VDiffs(2) As Double, LenR As Double, EPos As Long, BPos As Long, XOLen As Long, LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    ReDim NJSubDistance(NextNo, NextNo)
    ReDim ValidSite(NextNo, NextNo)
    StartY = 15
    PVal = -Log10(XOverList(DA, CurrentXover(DA)).Probability)
    Form1.Picture7.AutoRedraw = True
    
    LSeq = Len(StrainSeq(0))
    
    XFactor = ((Form1.Picture7.Width - 40) / LSeq)
    

    If PVal > PerMaxPval Then
        PerMaxPval = PVal
    End If

    'Form1.Picture7.ScaleMode = 3

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, X As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    BPos = XOverList(DA, SIP).Beginning
    EPos = XOverList(DA, SIP).Ending
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10
    
        If X = X Then
            Dst = MakeDst(Len(StrainSeq(0)), DA, Mi, Ma, BPos, EPos, VDiffs(0), SeqNum(0, 0))
        Else
            
            LenR = 0: VDiffs(0) = 0: VDiffs(1) = 0: VDiffs(2) = 0
            If BPos < EPos Then
               For X = BPos To EPos
                    If SeqNum(X, DA) <> 46 Then
                        If SeqNum(X, Mi) <> 46 Then
                            If SeqNum(X, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(X, DA) <> SeqNum(X, Mi) Or SeqNum(X, DA) <> SeqNum(X, Ma) Then
                                    If SeqNum(X, DA) <> SeqNum(X, Mi) And SeqNum(X, DA) = SeqNum(X, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, DA) = SeqNum(X, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, Mi) = SeqNum(X, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next X
            Else
                For X = BPos To LSeq
                    If SeqNum(X, DA) <> 46 Then
                        If SeqNum(X, Mi) <> 46 Then
                            If SeqNum(X, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(X, DA) <> SeqNum(X, Mi) Or SeqNum(X, DA) <> SeqNum(X, Ma) Then
                                    If SeqNum(X, DA) <> SeqNum(X, Mi) And SeqNum(X, DA) = SeqNum(X, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, DA) = SeqNum(X, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, Mi) = SeqNum(X, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next X
               For X = 1 To EPos
                    If SeqNum(X, DA) <> 46 Then
                        If SeqNum(X, Mi) <> 46 Then
                            If SeqNum(X, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(X, DA) <> SeqNum(X, Mi) Or SeqNum(X, DA) <> SeqNum(X, Ma) Then
                                    If SeqNum(X, DA) <> SeqNum(X, Mi) And SeqNum(X, DA) = SeqNum(X, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, DA) = SeqNum(X, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(X, DA) <> SeqNum(X, Ma) And SeqNum(X, Mi) = SeqNum(X, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next X
                
            End If
            
            If VDiffs(0) >= VDiffs(1) And VDiffs(0) >= VDiffs(2) Then
                Dst = VDiffs(0) / LenR
            ElseIf VDiffs(1) >= VDiffs(0) And VDiffs(1) >= VDiffs(2) Then
                Dst = VDiffs(1) / LenR
            ElseIf VDiffs(2) >= VDiffs(1) And VDiffs(2) >= VDiffs(0) Then
                Dst = VDiffs(2) / LenR
            End If
        End If
    
'XXXZZZ    XOverlist(Da, CurrentXOver(Da)).EndPermP = Dst
    'Exit Sub
    If oDMax < Dst Then
        RedoPltL(0) = 1
        oDMax = Dst + 0.1
    End If
    If PPMax < PVal Then
        PPMax = PVal
    End If
    If oPMax < PVal Then
        oPMax = PVal * 1.5
        RedoPltL(1) = 1
    End If
    Dummy = UpdatePlotInfo(PVal, XOverList(DA, SIP).ProgramFlag, LSeq, BPos, EPos, Dst, MaxHits, PDistPlt(0, 0), ProbPlt(0, 0), HitPlt(0, 0), RedoPltL(0))
    If MaxHits > PHMax Then PHMax = MaxHits
End Sub
Public Sub RecOverview()

    Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, Y As Long, Z As Long, Mi As Long, Ma As Long, P1 As Long, P2 As Long, P3 As Long, P4 As Long, Pict As Long, DA As Long, G As Long, X As Long, StartY As Long
    Dim AvSDst As Double
    
    Form1.Command29.Enabled = False
    
    ReDim NJSubDistance(NextNo, NextNo)
    ReDim ValidSite(NextNo, NextNo)
    LSeq = Len(StrainSeq(0))

    Dim tmpDMax As Double

    ReDim Hitnumber(LSeq + 10)
    oPMax = 0
    MaxHits = 10

    For DA = 0 To NextNo

        For G = 1 To CurrentXover(DA)

            If XOverList(DA, G).Accept < 2 Then

                If oPMax < -Log10(XOverList(DA, G).Probability) Then
                    oPMax = -Log10(XOverList(DA, G).Probability)
                End If

                If XOverList(DA, G).Beginning < XOverList(DA, G).Ending Then

                    For X = XOverList(DA, G).Beginning To XOverList(DA, G).Ending
                        Hitnumber(X) = Hitnumber(X) + 1

                        If Hitnumber(X) > MaxHits Then
                            MaxHits = MaxHits + 10
                        End If

                    Next 'X

                Else

                    For X = 1 To XOverList(DA, G).Ending
                        Hitnumber(X) = Hitnumber(X) + 1

                        If Hitnumber(X) > MaxHits Then
                            MaxHits = MaxHits + 10
                        End If

                    Next 'X

                    For X = XOverList(DA, G).Beginning To LSeq
                        Hitnumber(X) = Hitnumber(X) + 1

                        If Hitnumber(X) > MaxHits Then
                            MaxHits = MaxHits + 10
                            RedoLabelFlag = 1
                        End If

                    Next 'X

                End If

            End If

        Next 'G

    Next 'Da

    If oDMax = 0 Then oDMax = 1
    oPMax = Int(oPMax) + 1

    Call DoAxes2(oDMax, 0, oPMax, 0, MaxHits, 0, 1, "PDist", "P-Val", "# Hits")

    StartY = 15
    Form1.Picture7.AutoRedraw = True
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10

    If AvDst = 0 Then Call CalcDistances(0, 0)

    If PVal > PerMaxPval Then
        PerMaxPval = PVal
    End If

    Dim TotCompare As Long
    Dim Dst As Double
    Dim DistMod As Double

    tmpDMax = 0

    For DA = 0 To NextNo

        For G = 1 To CurrentXover(DA)

            If XOverList(DA, G).Accept < 2 Then
                PVal = -Log10(XOverList(DA, G).Probability)
                Mi = XOverList(DA, G).MinorP
                Ma = XOverList(DA, G).MajorP

                If Mi <= NextNo Then
    'this coluld be speeded up with better nesting of if then's

                    For Z = 0 To NextNo
                        Dummy = DistanceCalcE(Z, NextNo, LSeq + 1, XOverList(DA, G).Beginning, XOverList(DA, G).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                    Next 'Z

                    AvSDist = 0
                    TotCompare = 0

                    For X = 0 To NextNo - 1

                        For Y = X + 1 To NextNo
                            AvSDst = AvSDst + (1 - NJSubDistance(X, Y))
                        Next 'Y

                    Next 'X

                    If ((NextNo * (NextNo + 1) / 2) - TotCompare) > 0 Then
                        AvSDst = AvSDst / ((NextNo * (NextNo + 1) / 2) - TotCompare)
                    Else
                        Exit Sub
                    End If

                    DistMod = AvSDst / AvDst

                    If ValidSite(DA, Mi) = 0 Then ValidSite(DA, Mi) = 1

                    If ValidSite(DA, Ma) = 0 Then ValidSite(DA, Ma) = 1
                    'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).

                    If DA <> Ma Then

                        If ((1 - Distance(DA, Ma)) * DistMod) < (1 - (ValidSite(DA, Mi) - NJSubDistance(DA, Mi)) / ValidSite(DA, Mi)) Then
                            Dst = (1 - (ValidSite(DA, Ma) - NJSubDistance(DA, Ma)) / ValidSite(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
                        Else
                            Dst = (1 - (ValidSite(DA, Ma) - NJSubDistance(DA, Ma)) / ValidSite(DA, Ma)) - (1 - (ValidSite(DA, Mi) - NJSubDistance(DA, Mi)) / ValidSite(DA, Mi))
                        End If

                    Else
                        Dst = (1 - Distance(DA, Mi)) * DistMod
                    End If

                    If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod

                    If Dst > tmpDMax Then tmpDMax = Dst

                    If XOverList(DA, G).Beginning < XOverList(DA, G).Ending Then
                        X1 = 30 + XOverList(DA, G).Beginning * XFactor + XFactor
                        X2 = 30 + XOverList(DA, G).Ending * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                    Else
                        X1 = 30 + XOverList(DA, G).Beginning * XFactor + XFactor
                        X2 = 30 + LSeq * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                        X1 = 30 + 1 * XFactor + XFactor
                        X2 = 30 + XOverList(DA, G).Ending * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                    End If

                End If

                If XOverList(DA, G).Beginning < XOverList(DA, G).Ending Then
                    X1 = 30 + XOverList(DA, G).Beginning * XFactor + XFactor
                    X2 = 30 + XOverList(DA, G).Ending * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                Else
                    X1 = 30 + XOverList(DA, G).Beginning * XFactor + XFactor
                    X2 = 30 + LSeq * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                    X1 = 30 + 1 * XFactor + XFactor
                    X2 = 30 + XOverList(DA, G).Ending * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XOverList(DA, G).ProgramFlag), BF
                End If

            End If

        Next 'G

    Next 'Da

    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (Hitnumber(1) / MaxHits) * (P4 - P3 - 10), Pnt

    For X = 2 To LSeq
        LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (Hitnumber(X) / MaxHits) * (P4 - P3 - 10)
    Next 'X

    oDMax = Int(tmpDMax * 10 + 1) / 10
    Form1.Picture7.Refresh
End Sub
Public Sub RecOverview2()

    
    Dim NJSubDistance() As Double, ValidSite() As Double, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    LSeq = Len(StrainSeq(0))

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, X As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10


    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    Partnumber = (PicHeight / 3 - 35) / (TH * 3)

    If Partnumber < 3 Then Partnumber = 3

    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (Partnumber - 1))


    Call DoAxes2(oDMax, 0, oPMax, 0, MaxHits, 0, 0, "PDist", "P-Val", "# Hits")
    
    Form1.Picture7.ForeColor = 0
    Call UpdatePlotD
    Call UpdatePlotC
    
    Exit Sub
    X = 0
    
    Dim ProgColourB() As Long
    ReDim ProgColourB(AddNum - 1)
    
    ProgColourB(0) = RGB(206, 165, 165)
    ProgColourB(1) = RGB(179, 179, 206)
    ProgColourB(2) = RGB(155, 184, 171)
    ProgColourB(3) = RGB(206, 179, 155)
    
    Form1.Picture7.DrawWidth = 2
    For Y = 0 To AddNum - 1
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgColourB(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - (PDistPlt(1, Y) / oDMax) * (P2 - P1 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P2 - 5 - (PDistPlt(X, Y) / oDMax) * (P2 - P1 - 10)
            Next 'X
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - (ProbPlt(1, Y) / oPMax) * (P3 - P2 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P3 - 5 - (ProbPlt(X, Y) / oPMax) * (P3 - P2 - 10)
            Next 'X
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (HitPlt(1, Y) / MaxHits) * (P4 - P3 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (HitPlt(X, Y) / MaxHits) * (P4 - P3 - 10)
            Next 'X
        End If
    Next 'Y
    
    Form1.Picture7.DrawWidth = 1
    
    Call Highlight
    
    For Y = 0 To AddNum - 1
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgColour(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5 - (PDistPlt(1, Y) / oDMax) * (P2 - P1 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P2 - 5 - (PDistPlt(X, Y) / oDMax) * (P2 - P1 - 10)
            Next 'X
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P3 - 5 - (ProbPlt(1, Y) / oPMax) * (P3 - P2 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P3 - 5 - (ProbPlt(X, Y) / oPMax) * (P3 - P2 - 10)
            Next 'X
            MoveToEx Pict, 30 + 1 * XFactor + XFactor, P4 - 5 - (HitPlt(1, Y) / MaxHits) * (P4 - P3 - 10), Pnt
            For X = 2 To LSeq
                LineTo Pict, 30 + X * XFactor + XFactor, P4 - 5 - (HitPlt(X, Y) / MaxHits) * (P4 - P3 - 10)
            Next 'X
        End If
    Next 'Y
    
    Form1.Picture7.Refresh
End Sub
Public Sub StepDown()
Dim LPV As Integer, On1 As Byte
On1 = 0
'ReDim PValCat(AddNum, 100)
'ReDim MaxPValCat(AddNum, 100)
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If
For X = 99 To 0 Step -1
    PValCat(CurrentCorrect, X) = PValCat(CurrentCorrect, X) + PValCat(CurrentCorrect, X + 1)
Next X

For X = 0 To 99
    PValCat(CurrentCorrect, X) = MC - PValCat(CurrentCorrect, X)
    If PValCat(CurrentCorrect, X) < 0 Then
        PValCat(CurrentCorrect, X) = 0
    End If
Next X

For X = 0 To NextNo
    For Y = CurrentXover(X) To 1 Step -1
        If XOverList(X, Y).ProgramFlag = CurrentCorrect Then
            LPV = CInt(-Log10(XOverList(X, Y).Probability) * 2)
            If LPV < 100 And LPV > 0 Then
                If XOverList(X, Y).Probability > MaxPValCat(CurrentCorrect, LPV) Then
                    MaxPValCat(CurrentCorrect, LPV) = XOverList(X, Y).Probability
                End If
            End If
        Else
            Exit For
        End If
    Next Y

Next X

For X = 99 To 0 Step -1
    If MaxPValCat(CurrentCorrect, X) = 0 Then
        MaxPValCat(CurrentCorrect, X) = MaxPValCat(CurrentCorrect, X + 1)
    Else
        X = X
    End If
Next X

For X = 0 To NextNo
    Y = CurrentXover(X)
    Do While Y > 0
        If XOverList(X, Y).ProgramFlag = CurrentCorrect Then
            LPV = CInt(-Log10(XOverList(X, Y).Probability) * 2)
            If LPV > 0 Then
                
                If LPV < 100 Then
                    If PValCat(CurrentCorrect, LPV + 1) > 0 Then
                        If (XOverList(X, Y).Probability * PValCat(CurrentCorrect, LPV)) > (MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)) Then
                            XOverList(X, Y).Probability = XOverList(X, Y).Probability * PValCat(CurrentCorrect, LPV)
                        Else
                            XOverList(X, Y).Probability = MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)
                        End If
                    Else
                        XOverList(X, Y).Probability = XOverList(X, Y).Probability * MC
                    End If
                Else
                   XOverList(X, Y).Probability = XOverList(X, Y).Probability * MC
                End If
            End If
            
            If XOverList(X, Y).Probability > LowestProb Then
                
                
                If Y = CurrentXover(X) Then
                    CurrentXover(X) = CurrentXover(X) - 1
                Else
                    XOverList(X, Y) = XOverList(X, CurrentXover(X))
                    CurrentXover(X) = CurrentXover(X) - 1
                    
                End If
                If CurrentCorrect <> 1 Or (CurrentCheck = 1 And GCtripletflag = 1) Then
                    oRecombNo(100) = oRecombNo(100) - 1
                End If
                If CurrentCorrect = 1 Then
                    If GCtripletflag = 0 Then
                        If XOverList(X, Y).OutsideFlag = 1 Then
                            'Keep track of signal numbers
                            oRecombNo(100) = oRecombNo(100) - 1
                            oRecombNo(1) = oRecombNo(1) - 1
                        Else
                            On1 = On1 + 1
                            If On1 > 1 Then
                                On1 = 0
                                'Keep track of signal numbers
                                oRecombNo(100) = oRecombNo(100) - 1
                                oRecombNo(1) = oRecombNo(1) - 1
                            End If
                        End If
                    Else
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) - 1
                        oRecombNo(1) = oRecombNo(1) - 1
                    End If
                Else
                 
                    oRecombNo(CurrentCorrect) = oRecombNo(CurrentCorrect) - 1
                
                End If
            End If
        Else
            Exit Do
        End If
        Y = Y - 1
    Loop
    
Next X

End Sub

Public Sub xover(SeqNum() As Integer, Seq1 As Long, Seq2 As Long, Seq3 As Long, DoAllFlag)

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) = 0 And GrpMaskSeq(Seq2) = 0 And GrpMaskSeq(Seq3) = 0 Then
        Exit Sub
    End If
End If
    '0.343 - 1K perms
    Dim AFact As Double, BWarn As Byte, EWarn As Byte, DoneRedo As Byte, B As Long, BTarget As Long, ETarget As Long, Split As Long, AD As Long, AMi As Long, AMa As Long, BE As Long, EN As Long, NCommon As Long, StartPosX As Long
    Dim NextPosX As Long
    Dim oProbXOver As Double, Inlyer As Integer
    Dim FindCycle As Integer, Store As Long, Storex As Long, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, SeqDaughter As Long, SeqMinorP As Long, temp As Integer, EndFlag As Long, HighHomol As Long, MedHomol As Long, LowHomol As Long
    Dim DA As Long, Ma As Long, Mi  As Long, X As Long, NumDifferent As Long, Z As Long
    Dim NJSubDistance() As Double
    Dim SLen As Long, AmaTot As Double, AmiTot As Double, ATot As Double
    Dim AH(2) As Long
    DoneRedo = 0
    
    
    SLen = Len(StrainSeq(0))
    
'If Seq1 = 44 And Seq2 = 48 And Seq3 = 53 Then
'    X = X
'End If
'If UBound(XOverList, 2) >= 328 Then
'                                     If XOverList(62, 328).Beginning = 5252 Then
'                                        X = X
'                                    End If
'                                End If
'If Seq1 = 44 And Seq2 = 59 And Seq3 = 128 Then
'    X = X
'End If
    Dim RDProportionflag As Byte
    'RDProportionflag = 1
    'If RDProportionflag = 1 Then
    '    If PermDiffs(Seq1, Seq2) > PermDiffs(Seq1, Seq3) And PermDiffs(Seq1, Seq2) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq2) * 0.66)
    '    ElseIf PermDiffs(Seq1, Seq3) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq3) * 0.66)
    '    Else
    '        XOverWindow = CLng(PermDiffs(Seq2, Seq3) * 0.66)
    '    End If
    'Else
    '    XOverWindow = Int(XOverWindowX / 2)
    'End If
    FirstDrawFlag = 0
    
    If (PermDiffs(Seq1, Seq2) < XOverWindow Or PermDiffs(Seq1, Seq3)) < XOverWindow Or PermDiffs(Seq2, Seq3) < XOverWindow Then Exit Sub
    'Find reference sequences (takes 0.3/21)
    If SpacerFlag > 0 Then
        If SpacerFlag < 4 Then
            InRangeFlag = SpacerFindB(NextNo, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNo, TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqs(0), ValidSpacer(0))
            If InRangeFlag = 0 Then Exit Sub
        ElseIf SpacerFlag = 4 Then
            SpacerNo = 1
            SpacerSeqs(1) = Spacer4No
        End If
    
    
    
        'Find Information rich subsequences (takes 11/21)
    
        If SpacerNo = 0 Then
            Exit Sub
        End If
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
    Else
        ReDim ValidSpacer(0), SpacerSeqs(0)
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
    End If
    
    
    
    '1.492
    
    If LenXOverSeq < XOverWindow * 2 Then
        Exit Sub
    End If
    
    If AH(0) < XOverWindow Or AH(1) < XOverWindow Or AH(2) < XOverWindow Then
        Exit Sub
    End If
    
    AvHomol(1) = (AH(0) / LenXOverSeq)
    AvHomol(2) = (AH(1) / LenXOverSeq)
    AvHomol(3) = (AH(2) / LenXOverSeq)
    
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000 '0.3088
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000 '0.4847
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000 '0.2065
    
    If MCFlag = 0 Then
        mcc = MCCorrection
    Else
        mcc = 1
    End If
    
    If AH(0) < 170 Then
        If BinTable(Int(AH(0) / 5) + 1, Int(AH(0) / 5) + 1, Int(AvHomol(1) * 10) / 10) * LenXOverSeq / AH(0) * mcc >= 0.05 Then ' ProbabilityXOver And ProbabilityXOver < 0.05 Then
            Exit Sub
        End If
    End If
    If AH(1) < 170 Then
        If BinTable(Int(AH(1) / 5) + 1, Int(AH(1) / 5) + 1, Int(AvHomol(2) * 10) / 10) * LenXOverSeq / AH(1) * mcc >= 0.05 Then ' ProbabilityXOver And ProbabilityXOver < 0.05 Then
            Exit Sub
        End If
    End If
    If AH(2) < 170 Then
        If BinTable(Int(AH(2) / 5) + 1, Int(AH(2) / 5) + 1, Int(AvHomol(3) * 10) / 10) * LenXOverSeq / AH(2) * mcc >= 0.05 Then ' ProbabilityXOver And ProbabilityXOver < 0.05 Then
            Exit Sub
        End If
    End If
    '1.542
    
    'If SEventNumber = 2 Then
    '    If Seq1 = 20 Or Seq1 = 9 Or Seq1 = 4 Then
    '    If Seq2 = 20 Or Seq2 = 9 Or Seq2 = 4 Then
    '    If Seq3 = 20 Or Seq3 = 9 Or Seq3 = 4 Then
    '        X = X '152,28,0.3088,1045
    '        '152,18,0.3088,1045
    '        '150,17,0.3088,1045
    '    End If
    '    End If
    '    End If
    'End If
    
    
    
    
    
    
    LenXOverSeq = Abs(LenXOverSeq) - 1 '875
    
    
    
    'Work out identities (7.1/21)
    
    If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 1
    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2
    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3
    End If
    
    
    
    ReDim XOverHomologyNum(LenXOverSeq + XOverWindow * 2, 2)
    
    
    
    'C Routine to work out moving identity averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    
    StartPosX = XOHomology(HighHomol, LenStrainSeq, LenXOverSeq, XOverWindow, XOverSeqNumW(0, 0), XOverHomologyNum(0, 0))
    
    If StartPosX = 0 And ShortOutFlag <> 3 Then Exit Sub
    
    '1.883
    
    
    If AvHomol(1) = AvHomol(2) And AvHomol(1) = AvHomol(3) Then
        If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
            If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                AvHomol(2) = AvHomol(2) - 0.00001
                AvHomol(3) = AvHomol(3) - 0.00002
            Else
                AvHomol(2) = AvHomol(2) - 0.00002
                AvHomol(3) = AvHomol(3) - 0.00001
            End If
        ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
            If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                AvHomol(1) = AvHomol(1) - 0.00001
                AvHomol(3) = AvHomol(3) - 0.00002
            Else
                AvHomol(1) = AvHomol(1) - 0.00002
                AvHomol(3) = AvHomol(3) - 0.00001
            End If
        Else
            If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                AvHomol(1) = AvHomol(1) - 0.00001
                AvHomol(2) = AvHomol(2) - 0.00002
            Else
                AvHomol(1) = AvHomol(1) - 0.00002
                AvHomol(2) = AvHomol(2) - 0.00001
            End If
        End If
    ElseIf AvHomol(1) = AvHomol(2) Then
        If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
            AvHomol(2) = AvHomol(2) - 0.00001
        Else
            AvHomol(1) = AvHomol(1) - 0.00001
        End If
    ElseIf AvHomol(1) = AvHomol(3) Then
        If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
            AvHomol(3) = AvHomol(3) - 0.00001
        Else
            AvHomol(1) = AvHomol(1) - 0.00001
        End If
    ElseIf AvHomol(2) = AvHomol(3) Then
        If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
            AvHomol(3) = AvHomol(3) - 0.00001
        Else
            AvHomol(2) = AvHomol(2) - 0.00001
        End If
    End If
    
    
    '2.142
    
    
    
    If AvHomol(1) >= AvHomol(2) And AvHomol(1) >= AvHomol(3) Then
        HighHomol = 1

        If AvHomol(2) >= AvHomol(3) Then
            MedHomol = 2: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        
        Else 'If AvHomol(3) > AvHomol(2) Then
            MedHomol = 3: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(3) Then
        HighHomol = 2

        If AvHomol(1) >= AvHomol(3) Then
            MedHomol = 1: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        Else 'If AvHomol(3) > AvHomol(1) Then
            MedHomol = 3: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(3) >= AvHomol(1) And AvHomol(3) >= AvHomol(2) Then
        HighHomol = 3

        If AvHomol(1) >= AvHomol(2) Then
            MedHomol = 1: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        Else 'If AvHomol(2) > AvHomol(1) Then
            MedHomol = 2: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        'Else
        '    Exit Sub
        End If

    End If
 
 

   
   '1.823
    FindCycle = 0
    
    
    'Exit Sub
    Do
        NextPosX = 1 'StartPosX
        Storex = 0
        Do
            'This could be speeded up a bit
            X = FindNext(NextPosX, HighHomol, MedHomol, LowHomol, LenXOverSeq, XOverWindow, XOverHomologyNum(0, 0))
            '1.793
            
            
            If X > -1 Then
                '5.078 - 1K perms
                
                If CircularFlag = 1 And XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, HighHomol - 1) And X = 1 Then
                    Do Until XOverHomologyNum(X, MedHomol - 1) <= XOverHomologyNum(X, HighHomol - 1)
                        X = X + 1
                    Loop
                    If XOverHomologyNum(LenXOverSeq, MedHomol - 1) <= XOverHomologyNum(LenXOverSeq, HighHomol - 1) Then
                        XOverHomologyNum(LenXOverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
                        XOverHomologyNum(LenXOverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
                    End If
                Else
                    NCommon = 0
                    XOverLength = 0
                    Dummy = DefineEvent(ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, X, XOverWindow, SLen, LenXOverSeq, SeqMinorP, SeqDaughter, EndFlag, BE, EN, NCommon, XOverLength, XOverSeqNumW(0, 0), XDiffpos(0), XOverHomologyNum(0, 0))
                    
                    
                    X = Dummy
                    indprob = AvHomol(MedHomol)
                    
                    NumDifferent = XOverLength - NCommon
                    
                    '2.183
                 
                    If XOverLength > 2 Then
                        If XOverLength >= 170 Then
                            AFact = XOverLength / 169
                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                            XOverLength = 169
                        Else
                            AFact = 1
                        End If
                        'C routine that calculates the "probability" of the "recomination" having occured by chance.
                        'ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)

                        'If BinTable(Int(XOverLength / 5) + 1, Int(NCommon / 5) + 1, Int(indprob * 10) / 10) * LenXOverSeq / XOverLength < 0.05 Then ' ProbabilityXOver And ProbabilityXOver < 0.05 Then
                        
                        ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                        ProbabilityXOver = ProbabilityXOver ^ AFact
                        'End If
                    
                    Else
                        ProbabilityXOver = 1
                    End If
                    
                    If APermFlag = 1 Then
                        If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                            BestPermP(CPermNo, 0) = ProbabilityXOver
                        End If
                    Else
                        oProbXOver = ProbabilityXOver
                        If MCFlag = 0 Then
                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                        End If
                                              
                        
                                
                        If EN = BE Then
                            ProbabilityXOver = 1
                        ElseIf EN < BE And CircularFlag = 0 Then
                            ProbabilityXOver = 1
                        End If
                               
                        
                               
                        If ShortOutFlag = 3 Then
                            If ProbabilityXOver <= mtP(0) Then
                                mtP(0) = ProbabilityXOver
                            End If
                        End If
                        
                        '2.323
                        If ShowPlotFlag = 1 Then 'Draw plots if necessary
                            If (ProbabilityXOver < LowestProb Or oProbXOver < CritPVals(0)) And ProbabilityXOver > 0 Then
            
                                If FirstDrawFlag = 0 Then
                
                                    Call DrawPlots(Seq1, Seq2, Seq3)
                
                                    FirstDrawFlag = 1
                                End If
                
                                If BE < EN Then
                                    ProbX = 10 + BE * XFactor
                                Else
                                    ProbX = 10
                                End If
                
                                ProbY = PicHeight - (15 + XOverHomologyNum((XPosdiff(BE) + ((XPosdiff(EN) - XPosdiff(BE)) / 2)), MedHomol - 1) * (PicHeight - 35))
                                ProbTest$ = ProbabilityXOver
                                Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
                
                                If Pos > 0 Then
                                    If SPF = 0 Then Call PrintProbability
                                Else
                                    If SPF = 0 Then Call PrintProbabilityII
                                End If
                            End If
                        End If
                        
                        '2.033
                        
                        If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 And ProbabilityXOver <> 1 Then
                            '73.295
                           ' XX = XOverHomologyNum(XPosDiff(BE + 50), MedHomol - 1)
                           ' XX = XOverHomologyNum(XPosDiff(BE + 50), HighHomol - 1)
                           ' XX = XOverHomologyNum(XPosDiff(BE + 50), LowHomol - 1)
                            Split = 0
                            If LongWindedFlag = 1 Then
                                If CurrentXover(Seq1) <= CurrentXover(Seq2) And CurrentXover(Seq1) <= CurrentXover(Seq3) Then
                                    AD = Seq1
                                    AMi = Seq2
                                    AMa = Seq3
                                ElseIf CurrentXover(Seq2) <= CurrentXover(Seq1) And CurrentXover(Seq2) <= CurrentXover(Seq3) Then
                                    AD = Seq2
                                    AMi = Seq1
                                    AMa = Seq3
                                Else
                                    AD = Seq3
                                    AMi = Seq1
                                    AMa = Seq2
                                End If
                                'check to see if an event has been extended accross a tract of
                                'missing data
                                
                                'If BE = 5445 And EN = 9712 And Seq1 = 12 And Seq2 = 9 And Seq3 = 21 Then
                                '    X = X
                                'End If
                                If XPosdiff(BE) > 0 Then
                                    bee = XDiffpos(XPosdiff(BE) - 1)
                                Else
                                    bee = BE
                                End If
                                
                                
                                If XDiffpos(EN) < SLen Then
                                    enn = XDiffpos(XPosdiff(EN) + 1)
                                Else
                                    enn = EN
                                End If
                                If enn < EN Then enn = EN
                                If bee < 1 Then bee = SLen
                                If enn > SLen Then enn = 1
                                
                                If SEventNumber > 0 Then
                                    BWarn = 0: EWarn = 0
                                    Split = 0
                                    Z = CheckSplit(SLen, bee, BE, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                    If Split = 1 Then BWarn = 1
                                    Split = 0
                                    Z = CheckSplit(SLen, EN, enn, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                    If Split = 1 Then EWarn = 1
                                    Split = 0
                                    Z = CheckSplit(SLen, BE, EN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                   
                                End If
                                
                            End If
                            
                            
                            If Split = 1 Then
                                'go back and recalculate the p-value between be and Z
                                For A = 0 To 1
                                    NCommon = 0
                                    XOverLen = 0
                                    If A = 0 Then
                                        BTarget = BE
                                        If BE = Z Then Z = Z + 1
                                        If XPosdiff(Z) > 0 Then
                                            ETarget = XDiffpos(XPosdiff(Z) - 1)
                                        Else
                                            ETarget = SLen
                                        End If
                                    Else
                                        B = FindMissing(SLen, Seq1, Seq2, Seq3, Z, EN, MissingData(0, 0))
                                        If EN = B Then
                                            BTarget = EN - 1
                                            ETarget = EN
                                        Else
                                    '        XX = LenXoverSeq
                                            If XPosdiff(B) + 1 < LenXOverSeq And (XDiffpos(XPosdiff(B) + 1) > B Or XDiffpos(XPosdiff(B) + 1) < EN) Then
                                                BTarget = XDiffpos(XPosdiff(B) + 1)
                                            Else
                                                
                                                Do
                                                    If SeqNum(B, Seq1) <> 46 And SeqNum(B, Seq2) <> 46 And SeqNum(B, Seq3) <> 46 Then
                                                        If SeqNum(B, Seq1) <> SeqNum(B, Seq2) Or SeqNum(B, Seq1) <> SeqNum(B, Seq3) Then
                                                            Exit Do
                                                        End If
                                                    End If
                                                    B = B + 1
                                                    If B = EN Then B = B + 1: Exit Do
                                                    If B > SLen Then B = 1
                                                Loop
                                                If B > SLen Then
                                                    B = 1
                                                End If
                                                BTarget = B
                                            End If
                                            ETarget = EN
                                        End If
                                    End If
                                    
                                    NumDifferent = SplitEvent(XOverWindow, SLen, LenXOverSeq, SeqDaughter, SeqMinorP, BTarget, ETarget, XOverLength, NCommon, XPosdiff(0), XOverSeqNumW(0, 0))
                                    
                                    X = XPosdiff(ETarget) + 1
                                    
                                    If XOverLength > 2 Then
                                        If XOverLength >= 170 Then
                                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                            XOverLength = 169
                                        End If
                                        'C routine that calculates the probability of the "recomination" having occured by chance.
                                        ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                                    
                                    Else
                                        ProbabilityXOver = 1
                                    End If
                                    If MCFlag = 0 Then
                                        ProbabilityXOver = ProbabilityXOver * MCCorrection
                                    End If
                                    If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                        
                                        'Keep track of signal numbers
                                        oRecombNo(100) = oRecombNo(100) + 1
                                        oRecombNo(0) = oRecombNo(0) + 1
                                        If APermFlag = 0 Then
                                            Call UpdateXOList3(AD, CurrentXover(), XOverList(), 0, ProbabilityXOver, SIP)
                                        Else
                                            SIP = 1
                                        End If
                                        
                                            
                                        If MCFlag = 2 Then
                                            If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                                PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                            ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                            End If
                                        End If
                                        'if p high eough then add it to list, if not discard then repeat from Z to en.
                                        If SIP > 0 Then
                                            Call CentreBP(BTarget, ETarget, XPosdiff(), XDiffpos(), BWarn, EWarn, XOverWindow, LenXOverSeq)
                                            XOverList(AD, SIP).Beginning = BTarget
                                            XOverList(AD, SIP).Ending = ETarget
                                            
                                   '         If UBound(XOverList, 2) >= 328 Then
                                   '  If XOverList(62, 328).Beginning = 5252 Then
                                   '     X = X
                                   ' End If
                                'End If
                                            XOverList(AD, SIP).MajorP = AMa
                                            XOverList(AD, SIP).MinorP = AMi
                                            XOverList(AD, SIP).Daughter = AD
                                            XOverList(AD, SIP).ProgramFlag = 0
                                            XOverList(AD, SIP).Probability = ProbabilityXOver
                                            
                                            
                                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                                 StartPlt(0) = 1
                                                 Call UpdatePlotB(AD, AMa, AMi, SIP)
                                            
                                            End If
                                            'Make a reminder that one of the berakpoints went undetected
                                            If SEventNumber > 0 Then
                                                If EWarn = 0 Then Call CheckEndsVB(XOverWindow, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosdiff(), XDiffpos())
                                                If BWarn = 0 Then Call CheckEndsVB(XOverWindow, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosdiff(), XDiffpos())
                                            End If
                                            If BWarn = 1 And EWarn = 1 Then
                                                XOverList(AD, SIP).SBPFlag = 3
                                            ElseIf BWarn = 1 Then
                                                XOverList(AD, SIP).SBPFlag = 1
                                            ElseIf EWarn = 1 Then
                                                XOverList(AD, SIP).SBPFlag = 2
                                            End If
                                    
                                            
                                     '       If ETarget < BTarget Then
                                     '           For X = 1 To ETarget
                                     '               If MissingData(X, Seq1) = 1 Or MissingData(X, Seq2) = 1 Or MissingData(X, Seq3) = 1 Then
                                     '                   X = X
                                     '               End If
                                     '           Next X
                                     '           For X = BTarget To SLen
                                     '               If MissingData(X, Seq1) = 1 Or MissingData(X, Seq2) = 1 Or MissingData(X, Seq3) = 1 Then
                                     '                   X = X
                                     '               End If
                                     '           Next X
                                     '       Else
                                     '           For X = BTarget To ETarget
                                     '               If MissingData(X, Seq1) = 1 Or MissingData(X, Seq2) = 1 Or MissingData(X, Seq3) = 1 Then
                                     '                   X = X
                                     '               End If
                                     '           Next X
                                     '       End If
                                            '86.304
                                            
                                        ElseIf DoneRedo = 0 Then
                                            DoneRedo = 1
                                            Call AddToRedoList(0, Seq1, Seq2, Seq3)
                                        End If
                                        
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(0) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                    End If
                                Next A
                            Else
                                'If BE = 8129 And EN = 8440 Then
                                '        XX = SEventNumber
                                '        XX = Seq1 '21,1,9
                                '        XX = Seq2
                                '        XX = Seq3
                                '        '0,19,23,25
                                '    End If
                                'If Seq2 = 3 And Seq3 = 6 Then
                                '    X = X
                                'End If
                            
                                If APermFlag = 0 Then
                                    Call UpdateXOList3(AD, CurrentXover(), XOverList(), 0, ProbabilityXOver, SIP)
                                Else
                                    SIP = 1
                                End If
                                
                                
                                If MCFlag = 2 Then
                                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                    End If
                                End If
                                
                                oRecombNo(100) = oRecombNo(100) + 1
                                oRecombNo(0) = oRecombNo(0) + 1
                                
                                If SIP > 0 Then
                                    'XOverlist(AD, CurrentXOver(AD)).lholder = NCommon
                                    Call CentreBP(BE, EN, XPosdiff(), XDiffpos(), BWarn, EWarn, XOverWindow, LenXOverSeq)
                                    
                                    
                                    XOverList(AD, SIP).Beginning = BE
                                    XOverList(AD, SIP).Ending = EN
                                    XOverList(AD, SIP).MajorP = AMa
                                    XOverList(AD, SIP).MinorP = AMi
                                    XOverList(AD, SIP).Daughter = AD
                                    XOverList(AD, SIP).ProgramFlag = 0
                                    XOverList(AD, SIP).Probability = ProbabilityXOver
                                    
                                    'If BE = 1 And EN > 2500 Then
                                    '    X = X
                                    'End If
                                    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(0) = 1
                                        Call UpdatePlotB(AD, AMa, AMi, SIP)
                                            
                                    End If
                                    If SEventNumber > 0 Then
                                        If EWarn = 0 Then Call CheckEndsVB(XOverWindow, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                                        If BWarn = 0 Then Call CheckEndsVB(XOverWindow, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosdiff(), XDiffpos())
                                    End If
                                    If BWarn = 1 And EWarn = 1 Then
                                        XOverList(AD, SIP).SBPFlag = 3
                                    ElseIf BWarn = 1 Then
                                        XOverList(AD, SIP).SBPFlag = 1
                                    ElseIf EWarn = 1 Then
                                        XOverList(AD, SIP).SBPFlag = 2
                                    End If
                                    
                                            
                                    If ShortOutFlag = 1 Then
                                        ShortOutput(0) = 1
                                        AbortFlag = 1
                                        Exit Sub
                                    End If
                                    'Do shortend distance calculation here?
                                            
                                    
                                ElseIf DoneRedo = 0 Then
                                    DoneRedo = 1
                                    Call AddToRedoList(0, Seq1, Seq2, Seq3)
                                    
                                    
                                End If
                            End If
                        End If
                        
                        
                        
                    End If
                End If
                
                '1.923
                        
                If EndFlag = 1 Then
                    EndFlag = 0
                    X = LenXOverSeq
                End If
                
                If X < LenXOverSeq Then
                    NextPosX = X + 1
                Else
                    Exit Do
                End If
                
                '5.719 1K perms
                
            Else
                Exit Do
            End If
        Loop
        '3.895
        
        
        
        If FindCycle = 0 Then
            temp = MedHomol
            MedHomol = LowHomol
            LowHomol = temp
        ElseIf FindCycle = 1 Then
            'Exit Sub
            '5.027
            
            If AvHomol(HighHomol) < 0.7 Or DoAllFlag = 1 Then
                temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        End If
        
        FindCycle = FindCycle + 1
        
        
    Loop
    'Exit Sub
        '10.359 1K perms
End Sub
Public Sub XOverII()
BB = GetTickCount

    Dim FindCycle As Integer, Store As Integer, Storex As Integer, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, SeqDaughter As Integer, SeqMinorP As Integer, temp As Integer, EndFlag As Integer, HighHomol As Integer, MedHomol As Integer, LowHomol As Integer
    Dim DA As Long, Ma As Long, Mi  As Long, X As Long, NumDifferent As Long, Z As Long
    
    Dim SH As Double, AmaTot As Double, AmiTot As Double, ATot As Double
    Dim DH() As Double
    SLen = Len(StrainSeq(0))
     
    For X = 0 To 3
       AvHomol(X) = 0
    Next 'X
    
    FirstDrawFlag = 0
    
    'Find reference sequences (takes 3/65)
    If SpacerFlag < 4 And SpacerFlag > 0 Then

        Call SpacerFind

        If InRangeFlag = 0 Then Exit Sub
    ElseIf SpacerFlag = 4 Then
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        SpacerNo = 1
        SpacerSeqs(1) = Spacer4No
    End If
    
    
    If SpacerNo = 0 And SpacerFlag > 0 Then
        Exit Sub
    End If

    XOverWindow = Int(XOverWindowX / 2)
    
    LenStrainSeq = SLen + 1
    
    
    
    'Find Information rich subsequences (takes 16/65)
    
    ReDim XOverSeqNumW(SLen + XOverWindow * 2, 2)
    'Exit Sub
    Dim AH(2) As Long
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))
        
        If LenXOverSeq < XOverWindow * 2 Then
            Exit Sub
        End If

    Else
        ReDim ValidSpacer(0)
        ReDim SpacerSeqs(0)
        'This could be speeded up with better nesting
        LenXOverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffpos(0), XPosdiff(0), ValidSpacer(0))

        If LenXOverSeq < XOverWindow * 2 Then
            Exit Sub
        End If

    End If
    
    LenXOverSeq = Abs(LenXOverSeq)
    
    '
    
    
    If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 1
    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2
    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3
    End If
    
     'Work out homologies (11/65)
    'ReDim Preserve XDiffPos(LenXoverSeq)
    ReDim XOverHomologyNum(LenXOverSeq + XOverWindow * 2, 2)
    Dim StartPosX As Long
    'C Routine to work out moving homology averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    StartPosX = XOHomology(HighHomol, LenStrainSeq, LenXOverSeq, XOverWindow, XOverSeqNumW(0, 0), XOverHomologyNum(0, 0))
    'Call XOHomologyX
    'Find Xovers
    
    If StartPosX = 0 Then Exit Sub
    
   ' Dim loh As Double
   '
   ' For X = 1 To 3
   '     If AvHomol(X) < loh Then
   '         loh = AvHomol(X)
   '     End If
   ' Next X

                        'C routine that calculates the probability of the "recomination" having occured by chance.
                        
    
    'Exit Sub
    
    If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 1

        If AvHomol(2) > AvHomol(3) Then
            MedHomol = 2
            LowHomol = 3
            ActiveSeq = Seq1
            ActiveMajorP = Seq2
            ActiveMinorP = Seq3
            SeqDaughter = 0
            SeqMinorP = 2
        Else
            MedHomol = 3
            LowHomol = 2
            ActiveSeq = Seq2
            ActiveMajorP = Seq1
            ActiveMinorP = Seq3
            SeqDaughter = 1
            SeqMinorP = 2
        End If

    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2

        If AvHomol(1) > AvHomol(3) Then
            MedHomol = 1
            LowHomol = 3
            ActiveSeq = Seq1
            ActiveMajorP = Seq3
            ActiveMinorP = Seq2
            SeqDaughter = 0
            SeqMinorP = 1
        Else
            MedHomol = 3
            LowHomol = 1
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            SeqDaughter = 2
            SeqMinorP = 1
        End If

    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3

        If AvHomol(1) > AvHomol(2) Then
            MedHomol = 1
            LowHomol = 2
            ActiveSeq = Seq2
            ActiveMajorP = Seq3
            ActiveMinorP = Seq1
            SeqDaughter = 1
            SeqMinorP = 0
        Else
            MedHomol = 2
            LowHomol = 1
            ActiveSeq = Seq3
            ActiveMajorP = Seq2
            ActiveMinorP = Seq1
            SeqDaughter = 2
            SeqMinorP = 0
        End If

    End If

    'Check for the "medium" line being higher than the "higher" line
    FindCycle = 0
    
    
    
    Do
        Storex = 0

        For X = StartPosX To LenXOverSeq

            If XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, LowHomol - 1) And XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, HighHomol - 1) Then

                If CircularFlag = 1 And XOverHomologyNum(X, MedHomol - 1) > XOverHomologyNum(X, HighHomol - 1) And X = 1 Then

                    Do Until XOverHomologyNum(X, MedHomol - 1) <= XOverHomologyNum(X, HighHomol - 1)
                        X = X + 1
                    Loop

                    If XOverHomologyNum(LenXOverSeq, MedHomol - 1) <= XOverHomologyNum(LenXOverSeq, HighHomol - 1) Then
                        XOverHomologyNum(LenXOverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
                        XOverHomologyNum(LenXOverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
                    End If

                Else

                    If X > 1 Then

                        Do Until X = 1
                            X = X - 1

                            If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) Then
                                X = X + 1
                                Exit Do
                            End If

                        Loop

                    End If

                    If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) Then

                        Do Until X = LenXOverSeq Or XOverSeqNum(X, SeqDaughter) = XOverSeqNum(X, SeqMinorP)
                            X = X + 1
                        Loop

                    End If
                    Call UpdateXOList(ActiveSeq, CurrentXover(), XOverList())
                    

                    If CircularFlag = 0 And X = 1 Then
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning = 1
                    Else
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning = XDiffpos(X)
                    End If

                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder = 0
                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MajorP = ActiveMajorP
                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MinorP = ActiveMinorP
                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Daughter = ActiveSeq
                    XOverLength = 0

                    Do Until XOverHomologyNum(X, MedHomol - 1) < XOverHomologyNum(X, HighHomol - 1) And XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP)

                        If XOverSeqNum(X, SeqDaughter) = XOverSeqNum(X, SeqMinorP) Then
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder + 1
                        End If

                        XOverLength = XOverLength + 1
                        
                        If XOverLength >= LenXOverSeq Then Exit Do
                        
                        X = X + 1

                        If X > LenXOverSeq Then

                            If CircularFlag = 1 Then
                                X = 1
                                EndFlag = 1
                            Else
                                X = LenXOverSeq + 2 * XOverWindow + 1
                                Exit Do
                            End If

                        End If

                    Loop

                    Storex = X
                    X = X - 1
                    Store = 0

                    Do

                        If XOverSeqNum(X, SeqDaughter) <> XOverSeqNum(X, SeqMinorP) And X < LenXOverSeq And X > 1 Then
                            X = X - 1
                            Store = Store + 1
                            XOverLength = XOverLength - 1

                            If XOverLength = 1 Then Exit Do
                        Else
                            Exit Do
                        End If

                    Loop

                    If X = LenXOverSeq = 2 * XOverWindow + 1 And CircularFlag = 0 Then
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = SLen
                    Else

                        If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder > 1 Then
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = XDiffpos(X)
                        Else
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = XDiffpos(X)
                        End If

                    End If

                    X = Storex + 1

                    If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = 0 Then XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = SLen - 1
                    indprob = AvHomol(MedHomol)
                    NumDifferent = XOverLength - XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder

                    If XOverLength > 2 Then
                                        If XOverLength >= 170 Then
                                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                            XOverLength = 169
                                        End If
                        'C routine that calculates the probability of the "recomination" having occured by chance.
                        ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)

                        

                    

                    Else
                        ProbabilityXOver = 1
                    End If
                    
                    If MCFlag = 0 Then ProbabilityXOver = ProbabilityXOver * MCCorrection
                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = ProbabilityXOver

                    If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning Then
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = 1
                    ElseIf XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending < XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning And CircularFlag = 0 Then
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = 1
                    End If

                    If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability < LowestProb And ShowPlotFlag = 1 Then

                        If FirstDrawFlag = 0 Then

                            Call DrawPlots(Seq1, Seq2, Seq3)

                            FirstDrawFlag = 1
                        End If

                        If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning < XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending Then
                            ProbX = 10 + XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning * XFactor
                        Else
                            ProbX = 10
                        End If

                        ProbY = PicHeight - (15 + XOverHomologyNum((XPosdiff(XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning) + ((XPosdiff(XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending) - XPosdiff(XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning)) / 2)), MedHomol - 1) * (PicHeight - 35))
                        ProbTest$ = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability
                        Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)

                        If Pos > 0 Then

                            If SPF = 0 Then Call PrintProbability

                        Else

                            If SPF = 0 Then Call PrintProbabilityII

                        End If

                    End If

                    If XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability >= LowestProb Then
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = 0
                        XOverList(ActiveSeq, CurrentXover(ActiveSeq)).OutsideFlag = 0
                        CurrentXover(ActiveSeq) = CurrentXover(ActiveSeq) - 1
                    Else
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(0) = oRecombNo(0) + 1
                        
                        'Do shortend distance calculation here
                        
                        DA = ActiveSeq
                        Ma = ActiveMajorP
                        Mi = ActiveMinorP
                        AmaTot = 0
                        AmiTot = 0
                        ATot = 0
                        'Calculate average homology in recombinant region relative to rest of alignment.

                        ReDim DH(2)
                        'Calculate distance between the three sequences in thsi region and adjust
                        'distance for diversity in recomb region relative to the rest of the
                        'alignment.
                            'this coluld be speeded up with better nesting of if then's

                        SH = DistanceCalcF(ActiveSeq, ActiveMajorP, ActiveMinorP, NextNo, SLen + 1, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending, AvBkgHomology, SeqNum(0, 0), DH(0), BkgHomology(0))
                        'DistanceCalcE ActiveMajorP, Nextno, SLen + 1, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending, SeqNum(0, 0), NJSubDistance(0, 0)
                        'DistanceCalcE ActiveMinorP, Nextno, SLen + 1, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending, SeqNum(0, 0), NJSubDistance(0, 0)
                        'DistanceCalcE ActiveSeq, Nextno, SLen + 1, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning, XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending, SeqNum(0, 0), NJSubDistance(0, 0)

                        ATot = Abs(DH(0) - Distance(ActiveSeq, ActiveMajorP)) + Abs(DH(1) - Distance(ActiveSeq, ActiveMinorP))
                        AmaTot = Abs(DH(0) - Distance(ActiveSeq, ActiveMajorP)) + Abs(DH(2) - Distance(ActiveMajorP, ActiveMinorP))
                        AmiTot = Abs(DH(2) - Distance(ActiveMinorP, ActiveMajorP)) + Abs(DH(1) - Distance(ActiveSeq, ActiveMinorP))
                        
                        If ATot < AmaTot And ATot < AmiTot And (DH(1) > Distance(ActiveMajorP, ActiveMinorP) Or DH(1) > Distance(ActiveSeq, ActiveMajorP)) Then
                            'Both of the parents have probably recombined with a sequence
                            'more divergent than the outlyer in the triplet.
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MissIdentifyFlag = 1
                        ElseIf ATot < AmaTot And (DH(2) < Distance(ActiveMajorP, ActiveMinorP) Or DH(1) < Distance(ActiveSeq, ActiveMajorP)) Then
                            'One of the parents has probably recombined with a sequence
                            'more divergent than the outlyer in the triplet.

                            If DH(1) > (Distance(ActiveSeq, ActiveMajorP) * 1.1) And DH(2) < Distance(ActiveSeq, ActiveMinorP) Then
                                XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MissIdentifyFlag = 1
                            Else

                                If (AmaTot * 0.9) < ATot Then
                                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MissIdentifyFlag = 1

                                    If RFlag(ActiveSeq) = 0 Then RFlag(ActiveSeq) = 2
                                Else
                                    Call UpdateXOList(ActiveMajorP, CurrentXover(), XOverList())

                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).MissIdentifyFlag = 1
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).Beginning = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).Ending = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).Daughter = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MajorP
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).MinorP = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MinorP
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).MajorP = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Daughter
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).LHolder = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).Probability = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability
                                    XOverList(ActiveMajorP, CurrentXover(ActiveMajorP)).OutsideFlag = 2
                                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = 0
                                    XOverList(ActiveSeq, CurrentXover(ActiveSeq)).OutsideFlag = 0
                                    CurrentXover(ActiveSeq) = CurrentXover(ActiveSeq) - 1
                                    DA = ActiveMajorP
                                    Ma = ActiveSeq
                                End If

                            End If

                        ElseIf ATot < AmiTot And (DH(1) > Distance(ActiveSeq, ActiveMinorP) Or DH(0) > Distance(ActiveSeq, ActiveMajorP)) Then
                            Call UpdateXOList(ActiveMinorP, CurrentXover(), XOverList())

                            If (ATot * 1.5) > AmiTot Then
                                XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).MissIdentifyFlag = 1

                                If RFlag(ActiveMinorP) = 0 Then RFlag(ActiveMinorP) = 2
                            End If

                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).Beginning = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Beginning
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).Ending = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Ending
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).MajorP = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MajorP
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).Daughter = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MinorP
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).MinorP = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Daughter
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).LHolder = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).LHolder
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).Probability = XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability
                            XOverList(ActiveMinorP, CurrentXover(ActiveMinorP)).OutsideFlag = 1
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).Probability = 0
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).OutsideFlag = 0
                            CurrentXover(ActiveSeq) = CurrentXover(ActiveSeq) - 1
                            DA = ActiveMinorP
                            Mi = ActiveSeq
                        ElseIf ATot < AmaTot Then
                            XOverList(ActiveSeq, CurrentXover(ActiveSeq)).MissIdentifyFlag = 1
                        End If

                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then

                            Call UpdatePlotB(DA, Ma, Mi, CurrentXover(ActiveSeq))

                        End If

                    End If

                End If

            End If

            If EndFlag = 1 Then
                EndFlag = 0
                X = LenXOverSeq
            End If

        Next 'X

        If FindCycle = 0 Then
            temp = MedHomol
            MedHomol = LowHomol
            LowHomol = temp
        ElseIf FindCycle = 1 Then

            If AvHomol(HighHomol) < 0.4 Then
                temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq2
            ActiveMinorP = Seq3
            SeqDaughter = 0
            SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq1
            ActiveMinorP = Seq3
            SeqDaughter = 1
            SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq3
            ActiveMinorP = Seq2
            SeqDaughter = 0
            SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            SeqDaughter = 2
            SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq3
            ActiveMinorP = Seq1
            SeqDaughter = 1
            SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq2
            ActiveMinorP = Seq1
            SeqDaughter = 2
            SeqMinorP = 0
        End If

        FindCycle = FindCycle + 1
    Loop
    EE = GetTickCount
    TT = EE - BB
End Sub


Public Sub GCFindSites()
    'This routine attempts to determine which sites are looked at during a GC scan

    Dim X As Long, B As Long, Y As Long, A As Long, LSeq As Long

    ReDim GCSeq(NextNo)
    ReDim GCEnabledNo(NextNo)
    LSeq = Len(StrainSeq(0))
    'Work out how many sequences are not disabled
    NumEnabledSeqs = 0

    For X = 0 To NextNo

        If MaskSeq(X) < 2 Then
            GCSeq(NumEnabledSeqs) = StrainSeq(X)
            GCEnabledNo(NumEnabledSeqs) = X
            NumEnabledSeqs = NumEnabledSeqs + 1
        End If

    Next 'X

    NumEnabledSeqs = NumEnabledSeqs - 1
    ReDim GCIdentical(LSeq + 200)
    ReDim GCXOverSeq(NextNo)
    ReDim GCXPosDiff(LSeq + 200)
    ReDim GCXDiffPos(LSeq + 200)
    B = 0

    If NumEnabledSeqs < NextNo Or GCIndelFlag = 0 Or GCIndelFlag = 1 Then
        ReDim GCIDCount(LSeq, 4)

        For X = 1 To LSeq
            If X = 1000 Then
                X = X
            End If
            LastX = X
            
            GCXPosDiff(X) = B

            For Y = 0 To NumEnabledSeqs

                If SeqNum(X, GCEnabledNo(Y)) = 66 Then
                    GCIDCount(X, 0) = GCIDCount(X, 0) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 68 Then
                    GCIDCount(X, 1) = GCIDCount(X, 1) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 72 Then
                    GCIDCount(X, 2) = GCIDCount(X, 2) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 85 Then
                    GCIDCount(X, 3) = GCIDCount(X, 3) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 46 Or SeqNum(X, GCEnabledNo(Y)) = 47 Then
                    GCIDCount(X, 4) = GCIDCount(X, 4) + 1
                End If

            Next 'Y

            If GCIDCount(X, 0) = NumEnabledSeqs + 1 Or GCIDCount(X, 1) = NumEnabledSeqs + 1 Or GCIDCount(X, 2) = NumEnabledSeqs + 1 Or GCIDCount(X, 3) = NumEnabledSeqs + 1 Or GCIDCount(X, 4) = NumEnabledSeqs + 1 Then
                GCIdentical(X) = 1

                If GCMonoSiteFlag = 1 And GCIDCount(X, 4) = 0 Then
                    B = B + 1
                    GCXPosDiff(X) = B
                    GCXDiffPos(B) = X

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                        End If

                    Next 'A

                End If

            ElseIf GCIDCount(X, 4) > 0 Then
                GCIdentical(X) = 2

                If GCIndelFlag > 0 Then
                    B = B + 1
                    GCXPosDiff(X) = B
                    GCXDiffPos(B) = X

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                        End If

                    Next 'A

                End If

            Else
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                    End If

                Next 'A

            End If
             DoEvents
            If AbortFlag = 1 Then Exit Sub
        Next 'X

    Else

        For X = 1 To LSeq
            GCXPosDiff(X) = B
            GCIdentical(X) = Identical(X)

            If Identical(X) = 0 Then
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo
                    GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                Next 'A

            ElseIf GCMonoSiteFlag = 1 And Mid$(StrainSeq(A), X, 1) <> "-" Then
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                    End If

                Next 'A

            End If
            DoEvents
            If AbortFlag = 1 Then Exit Sub
        Next 'X
        
    End If

End Sub
Public Sub GCFindSitesII()
    'This routine attempts to determine which sites are looked at during a GC scan

    Dim X As Long, B As Long, Y As Long, A As Long, LSeq As Long

    ReDim GCSeq(NextNo)
    ReDim GCEnabledNo(NextNo)
    LSeq = Len(StrainSeq(0))
    'Work out how many sequences are not disabled
    NumEnabledSeqs = 0

    For X = 0 To NextNo

        If MaskSeq(X) < 2 Then
            GCSeq(NumEnabledSeqs) = StrainSeq(X)
            GCEnabledNo(NumEnabledSeqs) = X
            NumEnabledSeqs = NumEnabledSeqs + 1
        End If

    Next 'X

    NumEnabledSeqs = 2
    ReDim GCIdentical(LSeq + 200)
    ReDim GCXOverSeq(NextNo)
    ReDim GCXPosDiff(LSeq + 200)
    ReDim GCXDiffPos(LSeq + 200)
    B = 0

    If NumEnabledSeqs < NextNo Or GCIndelFlag = 0 Or GCIndelFlag = 1 Then
        ReDim GCIDCount(LSeq, 4)

        For X = 1 To LSeq
            GCXPosDiff(X) = B

            For Y = 0 To NumEnabledSeqs

                If SeqNum(X, GCEnabledNo(Y)) = 66 Then
                    GCIDCount(X, 0) = GCIDCount(X, 0) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 68 Then
                    GCIDCount(X, 1) = GCIDCount(X, 1) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 72 Then
                    GCIDCount(X, 2) = GCIDCount(X, 2) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 85 Then
                    GCIDCount(X, 3) = GCIDCount(X, 3) + 1
                ElseIf SeqNum(X, GCEnabledNo(Y)) = 46 Or SeqNum(X, GCEnabledNo(Y)) = 47 Then
                    GCIDCount(X, 4) = GCIDCount(X, 4) + 1
                End If

            Next 'Y

            If GCIDCount(X, 0) = NumEnabledSeqs + 1 Or GCIDCount(X, 1) = NumEnabledSeqs + 1 Or GCIDCount(X, 2) = NumEnabledSeqs + 1 Or GCIDCount(X, 3) = NumEnabledSeqs + 1 Or GCIDCount(X, 4) = NumEnabledSeqs + 1 Then
                GCIdentical(X) = 1

                If GCMonoSiteFlag = 1 And GCIDCount(X, 4) = 0 Then
                    B = B + 1
                    GCXPosDiff(X) = B
                    GCXDiffPos(B) = X

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                        End If

                    Next 'A

                End If

            ElseIf GCIDCount(X, 4) > 0 Then
                GCIdentical(X) = 2

                If GCIndelFlag > 0 Then
                    B = B + 1
                    GCXPosDiff(X) = B
                    GCXDiffPos(B) = X

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                        End If

                    Next 'A

                End If

            Else
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                    End If

                Next 'A

            End If

        Next 'X

    Else

        For X = 1 To LSeq
            GCXPosDiff(X) = B
            GCIdentical(X) = Identical(X)

            If Identical(X) = 0 Then
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo
                    GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                Next 'A

            ElseIf GCMonoSiteFlag = 1 And Mid$(StrainSeq(A), X, 1) <> "-" Then
                B = B + 1
                GCXPosDiff(X) = B
                GCXDiffPos(B) = X

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), X, 1)
                    End If

                Next 'A

            End If

        Next 'X

    End If

End Sub

Public Sub IntegrateXOvers(SPF)

    Dim APR() As Byte, ProgDo() As Byte, UB As Long, EHold As Long, XNHold As Long, SCol(3) As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, iMaskSeq() As Integer, iRevseq() As Integer, MaxSPos() As Integer, MaxXONo() As Integer, XOverNoComponent() As Integer
    Dim iMask As Integer, PNum As Integer, CurSeq As Long, Extend As Integer, G As Integer
    Dim DoneList() As Long, TempArray() As Integer
    Dim B As Long, Z As Long, OldY As Long, OLastDim As Long, LastDim As Long, UltimateMax As Long, TSPos As Long, SPos As Long, LSeq As Long, ProbCol As Long, DistCol As Long, X As Long, Y As Long
    Dim TDistance() As Double
    Dim DoneThisOne As Byte, CNum As Byte
    Form1.Picture5.FontSize = 6.75
    PNum = 12
    ReDim Preserve ProgF(100)
    ReDim APR(AddNum * 2)
    If RDPFlag = 1 Then
        APR(0) = 1
        APR(0 + AddNum) = 1
    End If
    If GENECONVFlag = 1 Then
        APR(1) = 1
        APR(1 + AddNum) = 1
    End If
    If BOOTSCANFlag = 1 Then
        APR(2) = 1
        APR(2 + AddNum) = 1
    End If
    If MaxChiFlag = 1 Then
        APR(3) = 1
        APR(3 + AddNum) = 1
    End If
    If ChimaeraFlag = 1 Then
        APR(4) = 1
        APR(4 + AddNum) = 1
    End If
    If SiScanFlag = 1 Then
        APR(5) = 1
        APR(5 + AddNum) = 1
    End If
    
    For X = 0 To AddNum
        If ProgF(X) = 1 Then ProgF(X + AddNum) = 1
    Next X
    ReDim ProgDo(14, NextNo)
    'Form1.ProgressBar1.Value = 2
    Form1.Picture6.AutoRedraw = True
    'Call DoConfirm
    Form1.SSPanel1.Caption = "Integrating Data"
    Dim Frm1Pic5ScaleWidth As Long

    Frm1Pic5ScaleWidth = Form1.Picture5.ScaleWidth - 10
    LSeq = Len(StrainSeq(0))
    ReDim PermArray(Frm1Pic5ScaleWidth, 100)
    AdjArrayPos = (Frm1Pic5ScaleWidth) / LSeq
    ReDim iMaskSeq(NextNo)
    ReDim iRevseq(NextNo)
    Y = 0

    For X = 0 To NextNo

        If CurrentXover(X) > 0 Then
            iMaskSeq(Y) = X
            iRevseq(X) = Y
            Y = Y + 1
        End If

    Next 'X

    iMask = Y - 1
    If iMask < 0 Then iMask = 0
    ReDim XOverNoComponent(PNum + 1, iMask, LSeq + 10)
    
    ReDim MaxXONo(NextNo)
    'Initialise arrays (use C for this?)

    For X = 0 To iMask
        XOverList(iMaskSeq(X), 0).Probability = 1
    Next 'X

    Form1.ProgressBar1.Value = 2
    MinLogPValSch = 1
    MaxLogPValSch = 0
    ST = GetTickCount
    Dim XoNoX As Long
    Dim BProg As Byte, FProg As Byte, StartP As Byte, StartE As Long, BestEg() As Byte, BestP As Double, BestNum As Double, DoneNum() As Byte
    For X = 0 To iMask
    
            XoNoX = CurrentXover(iMaskSeq(X))
            ReDim BestEg(XoNoX)
            ReDim DoneNum(XoNoX)
            For Y = 1 To XoNoX
                If DoneNum(Y) = 0 Then
                    
                    'DoneNum(Y) = 1
                    StartE = SuperEventlist(XOverList(iMaskSeq(X), Y).Eventnumber)
                    
                    StartP = XOverList(iMaskSeq(X), Y).ProgramFlag
                    BestP = XOverList(iMaskSeq(X), Y).Probability
                    
                    If ShowAllHits(iMaskSeq(X)) = 0 Then
                        If iMaskSeq(X) = BestEvent(StartE, 0) And Y = BestEvent(StartE, 1) Then
                            FProg = 1
                            BestNum = Y
                            DoneNum(Y) = 1
                            For A = 0 To XoNoX
                                If SuperEventlist(XOverList(iMaskSeq(X), A).Eventnumber) = StartE Then
                                    DoneNum(A) = 1
                                End If
                            Next A
                                        
                                        
                            
                        
                        Else
                            BProg = XOverList(BestEvent(StartE, 0), BestEvent(StartE, 1)).ProgramFlag
                            FProg = 0
                            For Z = Y To XoNoX
                                'If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = 54 Then
                                '    X = X
                                '    XX = XOverList(iMaskSeq(X), A).ProgramFlag
                                'End If
                                If DoneNum(Z) = 0 Then
                                    If XOverList(iMaskSeq(X), Z).Accept <> 2 And SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = StartE And APR(XOverList(iMaskSeq(X), Z).ProgramFlag) = 1 Then 'And XOverList(iMaskSeq(X), Z).ProgramFlag = BProg Then
                                        FProg = 1
                                        BestNum = Z
                                        DoneNum(Z) = 1
                                        For A = 0 To XoNoX
                                            If SuperEventlist(XOverList(iMaskSeq(X), A).Eventnumber) = StartE Then
                                                DoneNum(A) = 1
                                                If XOverList(iMaskSeq(X), A).Probability < BestP And APR(XOverList(iMaskSeq(X), A).ProgramFlag) = 1 And XOverList(iMaskSeq(X), A).Accept <> 2 Then
                                                    FProg = 1
                                                    BestNum = A
                                                    BestP = XOverList(iMaskSeq(X), A).Probability
                                                End If
                                            End If
                                        Next A
                                        Exit For
                                    End If
                                End If
                            Next Z
                            If FProg = 0 Then
                                For Z = Y To XoNoX
                                    'If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = 54 Then
                                    '    X = X
                                    '    XX = XOverList(iMaskSeq(X), A).ProgramFlag
                                    'End If
                                    If DoneNum(Z) = 0 Then
                                        If XOverList(iMaskSeq(X), Z).Accept <> 2 And SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = StartE Then  'And XOverList(iMaskSeq(X), Z).ProgramFlag = BProg Then
                                            FProg = 1
                                            BestNum = Z
                                            DoneNum(Z) = 1
                                            For A = 0 To XoNoX
                                                If SuperEventlist(XOverList(iMaskSeq(X), A).Eventnumber) = StartE Then
                                                    DoneNum(A) = 1
                                                    If XOverList(iMaskSeq(X), A).Probability < BestP And XOverList(iMaskSeq(X), A).Accept <> 2 Then
                                                        FProg = 1
                                                        BestNum = A
                                                        BestP = XOverList(iMaskSeq(X), A).Probability
                                                    End If
                                                End If
                                            Next A
                                            Exit For
                                        End If
                                    End If
                                Next Z
                            End If
                            XX = XOverList(iMaskSeq(X), Z).Beginning
                            If FProg = 0 Then
                                For Z = Y To XoNoX
                                    'If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = 54 Then
                                    '    X = X
                                    '    XX = XOverList(iMaskSeq(X), A).ProgramFlag
                                    'End If
                                    If DoneNum(Z) = 0 Then
                                        If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = StartE Then  'And XOverList(iMaskSeq(X), Z).ProgramFlag = BProg Then
                                            FProg = 1
                                            BestNum = Z
                                            DoneNum(Z) = 1
                                            For A = 0 To XoNoX
                                                If SuperEventlist(XOverList(iMaskSeq(X), A).Eventnumber) = StartE Then
                                                    DoneNum(A) = 1
                                                    If XOverList(iMaskSeq(X), A).Probability < BestP Then
                                                        FProg = 1
                                                        BestNum = A
                                                        BestP = XOverList(iMaskSeq(X), A).Probability
                                                    End If
                                                End If
                                            Next A
                                            Exit For
                                        End If
                                    End If
                                Next Z
                            End If
                        End If
                        If FProg = 0 Then
                            BestP = 1
                            For Z = Y To XoNoX
                                If DoneNum(Z) = 0 Then
                                    If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = StartE And XOverList(iMaskSeq(X), Z).Probability > 0 And XOverList(iMaskSeq(X), Z).Probability < BestP Then
                                        DoneNum(Z) = 1
                                        FProg = 1
                                        BestNum = Z
                                        BestP = XOverList(iMaskSeq(X), Z).Probability
                                    End If
                                    
                                End If
                            Next Z
                            For A = 0 To XoNoX
                                If SuperEventlist(XOverList(iMaskSeq(X), A).Eventnumber) = StartE Then
                                    DoneNum(A) = 1
                                End If
                            Next A
                        End If
                        BestEg(BestNum) = 1
                    Else
                        DoneNum(Y) = 1
                        BestNum = Y
                        For Z = Y + 1 To XoNoX
                            If DoneNum(Z) = 0 Then
                                If SuperEventlist(XOverList(iMaskSeq(X), Z).Eventnumber) = StartE And XOverList(iMaskSeq(X), Z).ProgramFlag = StartP Then
                                    DoneNum(Z) = 1
                                    If BestP > XOverList(iMaskSeq(X), Z).Probability Then
                                        BestP = XOverList(iMaskSeq(X), Z).Probability
                                        BestNum = Z
                                    End If
                                End If
                            End If
                        Next Z
                        BestEg(BestNum) = 1
                    End If
                End If
                X = X
            Next Y
            For Y = 1 To XoNoX
                If BestEg(Y) = 1 Then
                    GoOn = 0
                    If ConsensusProg > 0 Then
                        CNum = 1
                        For Z = 0 To AddNum - 1
                            If XOverList(iMaskSeq(X), Y).ProgramFlag <> Z And XOverList(iMaskSeq(X), Y).ProgramFlag <> Z + AddNum And Confirm(SuperEventlist(XOverList(iMaskSeq(X), Y).Eventnumber), Z) > 0 Then
                                CNum = CNum + 1
                            End If
                        Next
                        If CNum > ConsensusProg Then GoOn = 1
                    Else
                        GoOn = 1
                    End If
                    
                    If GoOn = 1 Then
                        If XOverList(iMaskSeq(X), Y).Probability < MinLogPValSch And XOverList(iMaskSeq(X), Y).Probability > 0 Then
                            MinLogPValSch = XOverList(iMaskSeq(X), Y).Probability
                        End If
            
                        If XOverList(iMaskSeq(X), Y).Probability > MaxLogPValSch And XOverList(iMaskSeq(X), Y).Probability > 0 Then
                            MaxLogPValSch = XOverList(iMaskSeq(X), Y).Probability
                        End If
            
                        DoneThisOne = 0
                        
                        If XOverList(iMaskSeq(X), Y).Beginning < XOverList(iMaskSeq(X), Y).Ending Then 'if region internal
            
                            If XOverList(iMaskSeq(X), Y).Ending > LSeq Then
            
                                If CircularFlag = 0 Then
                                    XOverList(iMaskSeq(X), Y).Ending = LSeq
                                Else
                                    XOverList(iMaskSeq(X), Y).Ending = LSeq - XOverList(iMaskSeq(X), Y).Ending
                                End If
            
                            End If
            
                            For Z = XOverList(iMaskSeq(X), Y).Beginning To XOverList(iMaskSeq(X), Y).Ending
            
                                If XOverList(iMaskSeq(X), Y).Probability > 0 Then
                                    
                                    
                                    'Exit Sub
                                    If XOverList(iMaskSeq(X), XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z)).Probability > XOverList(iMaskSeq(X), Y).Probability Or X = X Then
                                        
                                        XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z) = Y
                                        ProgDo(XOverList(iMaskSeq(X), Y).ProgramFlag, iMaskSeq(X)) = 1
                                        If DoneThisOne = 0 Then
                                            MaxXONo(iMaskSeq(X)) = MaxXONo(iMaskSeq(X)) + 1
                                            DoneThisOne = 1
                                        End If
            
                                    End If
            
                                End If
            
                            Next 'Z
            
                        Else 'If end of region overlaps the end of the sequence
            
                            For Z = 1 To XOverList(iMaskSeq(X), Y).Ending
            
                                If XOverList(iMaskSeq(X), Y).Probability > 0 Then
                                    
                                    If XOverList(iMaskSeq(X), XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z)).Probability > XOverList(iMaskSeq(X), Y).Probability Or X = X Then
                                        XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z) = Y
                                        ProgDo(XOverList(iMaskSeq(X), Y).ProgramFlag, iMaskSeq(X)) = 1
                                        If DoneThisOne = 0 Then
                                            MaxXONo(iMaskSeq(X)) = MaxXONo(iMaskSeq(X)) + 1
                                            DoneThisOne = 1
                                        End If
            
                                    End If
            
                                End If
            
                            Next 'Z
            
                            For Z = XOverList(iMaskSeq(X), Y).Beginning To LSeq
            
                                If XOverList(iMaskSeq(X), Y).Probability > 0 Then
            
                                    If XOverList(iMaskSeq(X), XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z)).Probability > XOverList(iMaskSeq(X), Y).Probability Or X = X Then
                                        XOverNoComponent(XOverList(iMaskSeq(X), Y).ProgramFlag, X, Z) = Y
                                        ProgDo(XOverList(iMaskSeq(X), Y).ProgramFlag, iMaskSeq(X)) = 1
                                        If DoneThisOne = 0 Then
                                            MaxXONo(iMaskSeq(X)) = MaxXONo(iMaskSeq(X)) + 1
                                            DoneThisOne = 1
                                        End If
            
                                    End If
            
                                End If
            
                            Next 'Z
            
                        End If 'divides internal and sequences overlapping ends
                    End If
                End If
            Next 'Y
            ET = GetTickCount
            If ET - ST > 100 Then
                ST = ET
                Form1.ProgressBar1 = X / NextNo * 40
            End If
    Next 'X

    Form1.ProgressBar1.Value = 40
    LastDim = 0
    X = -1
    ReDim TempArray(Frm1Pic5ScaleWidth, MaxXONo(B))
    For B = 0 To NextNo
        SPos = 0
        UltimateMax = 0
        '
       ' If iRevseq(B) = 7 Then
       '             X = X
       '     End If
        If CurrentXover(B) > 0 Then
            ReDim TempArray(Frm1Pic5ScaleWidth, MaxXONo(B)), DoneList(CurrentXover(B)), MaxSPos(LSeq)

            For G = 0 To PNum

                If ProgDo(G, B) = 1 Then

                    For Y = 0 To LSeq
                        XNHold = XOverNoComponent(G, iRevseq(B), Y)
                        If XNHold > 0 Then
                            If DoneList(XNHold) = 0 Then
                                DoneList(XNHold) = 1
                                
                                If XOverList(B, XNHold).OutsideFlag < 2 And Len(StraiName(XOverList(B, XNHold).MinorP)) > 0 Then
                                    Extend = CInt(LSeq * (((Form1.Picture5.TextWidth("O" & StraiName(XOverList(B, XNHold).MinorP)))) / (Frm1Pic5ScaleWidth)))
                                Else
                                    Extend = CInt(LSeq * (Form1.Picture5.TextWidth("OUnknown") / (Frm1Pic5ScaleWidth)))
                                End If
                                
                                RBegin = XOverList(B, XNHold).Beginning
                                REnd = XOverList(B, XNHold).Ending
                                
                                If RBegin = 0 Then XOverList(B, XNHold).Beginning = 1
    
                                If REnd = 0 Then XOverList(B, XNHold).Ending = LSeq
                                
                                If REnd + Extend <= LSeq Then
                                    UTarget = REnd + Extend
                                Else
                                    UTarget = LSeq
                                End If
                                
                                If RBegin < REnd Then
                                    'Find a slot
                                    SPos = FindSlot(RBegin, UTarget + 1, SPos, MaxSPos(0))
                                    
                                    If SPos > UltimateMax Then
                                        
                                        SPos = ReFindSlot(AdjArrayPos, Frm1Pic5ScaleWidth, LSeq + 1, RBegin, UTarget + 1, 0, TempArray(0, 0), MaxSPos(0))
                                        
                                    End If
    
                                    If UltimateMax < SPos Then UltimateMax = SPos
                                    'Fill it
                                    FillArray2 AdjArrayPos, XNHold, RBegin, UTarget + 1, LSeq + 1, SPos, TempArray(0, SPos), MaxSPos(0)
    
                                Else
                                    'Find a slot
                                   ' Z = XOverList(B, XOverNoComponent(G, iRevseq(B), Y)).Beginning
    
                                   ' Do
    
                                   '     If MaxSPos(Z) > SPos Then SPos = MaxSPos(Z)
                                   '     Z = Z + 1
                                   ' Loop While Z <= LSeq - 10
    
    
                                    
                                    For Z = RBegin To LSeq
    
                                        If MaxSPos(Z) > SPos Then SPos = MaxSPos(Z)
                                    Next 'Z
            
                                    For Z = 1 To UTarget
            
                                        If MaxSPos(Z) > SPos Then SPos = MaxSPos(Z)
                                        Z = Z + 10
                                    Next 'Z
                                    
                                  '  Z = 1
                                  '
                                  '  Do'
    
                                  '      If MaxSPos(Z) > SPos Then SPos = MaxSPos(Z)
                                  '      Z = Z + 1
                                  '  Loop While Z <= XOverList(B, XOverNoComponent(G, iRevseq(B), Y)).Ending + Extend - 10 And Z <= LSeq - 10
    
    
    
                                    If SPos > UltimateMax Then
                                        
                                        If XOverList(B, XNHold).Beginning > LSeq Then
                                            XOverList(B, XNHold).Beginning = 1
                                        End If
                                        Z = XOverList(B, XNHold).Beginning
                                        TSPos = 0
                                        XX = Len(StrainSeq(0))
                                        Do
                                            XX = UBound(TempArray, 2)
                                            If TempArray(CInt(Z * AdjArrayPos), TSPos) <> 0 Then
                                                TSPos = TSPos + 1
                                                Z = RBegin
                                            End If
    
                                            Z = Z + 1
                                        Loop While Z <= LSeq - 10
    
                                        Z = 1
                                        EHold = XOverList(B, XNHold).Ending - 10 + Extend
                                        Do
    
                                            If TempArray(CInt(Z * AdjArrayPos), TSPos) <> 0 Then
                                                TSPos = TSPos + 1
                                                Z = 1
                                            End If
    
                                            Z = Z + 1
                                            If Z > EHold Then
                                                Exit Do
                                            ElseIf Z > LSeq - 10 Then
                                                Exit Do
                                            End If
                                            
                                        Loop
    
                                        SPos = TSPos
                                    End If
    
                                    If UltimateMax < SPos Then UltimateMax = SPos
                                    
                                    Z = XOverList(B, XNHold).Beginning
    
                                    Do
                                        
                                        TempArray(CInt(Z * AdjArrayPos), SPos) = XNHold
    
                                        If SPos >= MaxSPos(Z) Then MaxSPos(Z) = SPos + 1
                                        Z = Z + 1
                                        If Z > LSeq Then Exit Do
                                    Loop
    
                                    Z = 1
                                    EHold = XOverList(B, XNHold).Ending + Extend
                                    Do
                                        If Z > EHold Then
                                            Exit Do
                                        ElseIf Z > LSeq Then
                                            Exit Do
                                        End If
                                        
                                        TempArray(CInt(Z * AdjArrayPos), SPos) = XNHold
    
                                        If SPos >= MaxSPos(Z) Then MaxSPos(Z) = SPos + 1
                                        
                                        Z = Z + 1
                                        
                                    Loop
    
                                End If
                            End If

                        End If

                    Next 'Y

                End If

            Next 'G

            For Z = 0 To LSeq Step 20

                If MaxSPos(Z) > SPos Then SPos = MaxSPos(Z)
            Next 'Z

        End If

        'Copies Temparray data into Permarray
        UB = UBound(PermArray, 2)
        If LastDim + SPos + 3 > UB Then
            ReDim Preserve PermArray(Frm1Pic5ScaleWidth, LastDim + SPos + 3 + 200)
        End If
        'Encode the first y column with sequence info
        ModPermArray Frm1Pic5ScaleWidth, UB, LastDim, SPos, B, PermArray(0, 0), TempArray(0, 0)
        
        LastDim = LastDim + SPos + 2
        ET = GetTickCount
        If ET - ST > 400 Then
            ST = ET
            Form1.ProgressBar1 = 40 + B / NextNo * 50
        End If
        
    Next 'B
    
    '3.445,3.555,3.465
    '3.365 with modpermarray
    '541 with prodo
    LastDim = LastDim - 1
    Form1.ProgressBar1.Value = 90
    Form1.SSPanel1.Caption = "Plotting Recombination Data"
    'Do Calcs for colour Schemes
    'Do Calcs for Prob colour schemes

    If MaxLogPValSch < LowestProb Then MaxLogPValSch = -Log10(LowestProb)

    If MinLogPValSch > 0 Then
        MinLogPValSch = -Log10(MinLogPValSch)
    Else
        MinLogPValSch = 999
    End If

    'Do Calcs for ID colour schemes
    MaxDistSch = -10
    MinDistSch = 10
    'If necessary work out distances between sequences

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated and if a "spacer" is required

        Call CalcDistances(0, 0)

    End If

    ReDim TDistance(NextNo, NextNo)

    For X = 0 To NextNo

        For Y = X + 1 To NextNo
            TDistance(X, Y) = Distance(X, Y)
            TDistance(Y, X) = TDistance(X, Y)

            If TDistance(X, Y) > MaxDistSch Then
                MaxDistSch = TDistance(X, Y)
            ElseIf TDistance(X, Y) < MinDistSch Then
                MinDistSch = TDistance(X, Y)
            End If

        Next 'Y

    Next 'X

    OLastDim = LastDim
    Form1.SSPanel5.Enabled = True
    SpaceAdjust = 1
    

    
    
    Form1.Picture5.ScaleMode = 3
    Form1.Picture6.DrawMode = 13
    
    'Try to get the picturebox to the correvt size

    If CurrentXover(NextNo) = 0 Then
        LastDim = LastDim + 2
    Else
        LastDim = LastDim + 2
    End If

    Form1.Picture6.Height = Form1.Picture5.ScaleHeight
    
    'ReDim Preserve StraiName(NextNo + 1)
    'StraiName(NextNo + 1) = "Unknown"
    ReDim SchemBlocks(3, 4, 100), SchemString(3, 3, 100)
    SBlocksLen = -1: SStringLen = -1
    LastDim = OLastDim
    Form1.Picture5.BackColor = BackColours
    Form1.Picture6.BackColor = BackColours
    Form1.Picture6.left = 0
    'Test to make sure pictureboxes can be drawn onto
    X1 = 5: Y1 = 3 * SpaceAdjust
    SCol(0) = ThreeQuaterColour: SCol(1) = ThreeQuaterColour: SCol(2) = ThreeQuaterColour: SCol(3) = ThreeQuaterColour
    Call AddString(X1, Y1, 0, SCol(), SStringLen, SchemString())
    X1 = 5 + 1: Y1 = 3 * SpaceAdjust + 1
    SCol(0) = 0: SCol(1) = 0: SCol(2) = 0: SCol(3) = 0
    Call AddString(X1, Y1, 0, SCol(), SStringLen, SchemString())
    
    X1 = 5: X2 = 5 + LSeq * (Frm1Pic5ScaleWidth) / LSeq
    Y1 = 15 * SpaceAdjust: Y2 = 25 * SpaceAdjust
    SCol(0) = SeqCol(0)
    SCol(1) = QuaterColour
    SCol(2) = QuaterColour
    SCol(3) = QuaterColour
    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
RedoSizing:

    Dim YAdj As Double, YAdj2 As Double
    Dim XAdj As Double
    Dim TBegin As Long, TEnd As Long
    Dim BeginAdj As Integer, EndAdj As Integer

    XAdj = (Frm1Pic5ScaleWidth) / LSeq
    CurSeq = 0
    OldY = 1
    
    For Y = 2 To LastDim
        YAdj = (Y * 12 + 3) * SpaceAdjust
        YAdj2 = (Y * 12 + 13) * SpaceAdjust

        If PermArray(0, Y) > 0 Then

            CurSeq = PermArray(0, Y)
                
            X1 = 5: Y1 = YAdj
            SCol(0) = ThreeQuaterColour: SCol(1) = ThreeQuaterColour: SCol(2) = ThreeQuaterColour: SCol(3) = ThreeQuaterColour
            Call AddString(X1, Y1, CurSeq, SCol(), SStringLen, SchemString())
            X1 = 5 + 1: Y1 = YAdj + 1
            SCol(0) = 0: SCol(1) = 0: SCol(2) = 0: SCol(3) = 0
            Call AddString(X1, Y1, CurSeq, SCol(), SStringLen, SchemString())
                
        ElseIf PermArray(0, Y) < 0 Then
            X1 = 5: X2 = 5 + LSeq * XAdj
            Y1 = YAdj: Y2 = ((Y + 1) * 12 + 1)
            SCol(0) = SeqCol(CurSeq): SCol(1) = QuaterColour: SCol(2) = QuaterColour: SCol(3) = QuaterColour
            Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())

            OldY = Y
        Else

            For X = 1 To Frm1Pic5ScaleWidth

                If PermArray(X, Y) > 0 Then
                    TBegin = XOverList(CurSeq, PermArray(X, Y)).Beginning
                    BeginAdj = TBegin * XAdj
                    TEnd = XOverList(CurSeq, PermArray(X, Y)).Ending
                    EndAdj = TEnd * XAdj
                    ProbCol = ((-Log10(XOverList(CurSeq, PermArray(X, Y)).Probability) - MaxLogPValSch) / (MinLogPValSch - MaxLogPValSch) * 768)

                    Call ProbColour(ProbCol)

                    If XOverList(CurSeq, PermArray(X, Y)).MinorP <= NextNo Then
                        DistCol = Int(((TDistance(XOverList(CurSeq, PermArray(X, Y)).MinorP, XOverList(CurSeq, PermArray(X, Y)).MajorP) - MinDistSch) / (MaxDistSch - MinDistSch)) * 768)
                        
                        
                        Call DistColour(DistCol)

                    Else
                        DistCol = 0
                    End If

                    If TBegin < TEnd Then
                        'Draw the recombinant regions

                        If XOverList(CurSeq, PermArray(X, Y)).Accept = 2 Then
                            X1 = 5 + BeginAdj: X2 = 5 + EndAdj
                            Y1 = YAdj: Y2 = YAdj2
                            SCol(0) = Rejected: SCol(1) = Rejected: SCol(2) = Rejected: SCol(3) = Rejected
                            Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())

                        Else
                            X1 = 5 + BeginAdj: X2 = 5 + EndAdj
                            Y1 = YAdj: Y2 = YAdj2
                            SCol(0) = SeqCol(XOverList(CurSeq, PermArray(X, Y)).MinorP)
                            SCol(1) = ProgColour(XOverList(CurSeq, PermArray(X, Y)).ProgramFlag)
                            SCol(2) = ProbCol
                            SCol(3) = DistCol
                            Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())

                            If XOverList(CurSeq, PermArray(X, Y)).Accept = 1 Then
                                X1 = 4 + BeginAdj: X2 = 6 + EndAdj
                                Y1 = YAdj: Y2 = YAdj2
                                SCol(0) = -1: SCol(1) = -1: SCol(2) = -1: SCol(3) = -1
                                Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                            End If
                            
                            X1 = 5 + BeginAdj: X2 = 5 + EndAdj
                            Y1 = ((OldY) * 12 + 3) * SpaceAdjust: Y2 = (OldY * 12 + 13) * SpaceAdjust
                            SCol(0) = FFillCol(CurSeq)
                            SCol(1) = FillColour
                            SCol(2) = FillColour
                            SCol(3) = FillColour
                            Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                        End If

                    Else

                        If Int((X + 1) / AdjArrayPos) < TBegin Then

                            With Form1
                                'Draw the recombinant regions

                                If XOverList(CurSeq, PermArray(X, Y)).Accept = 2 Then
                                    X1 = 5 + 1 * XAdj: X2 = 5 + EndAdj
                                    Y1 = YAdj: Y2 = YAdj2
                                    SCol(0) = Rejected
                                    SCol(1) = Rejected
                                    SCol(2) = Rejected
                                    SCol(3) = Rejected
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                    
                                    
                                    X1 = 5 + BeginAdj: X2 = 5 + LSeq * XAdj
                                    Y1 = YAdj: Y2 = YAdj2
                                    SCol(0) = Rejected
                                    SCol(1) = Rejected
                                    SCol(2) = Rejected
                                    SCol(3) = Rejected
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                Else
                                    X1 = (5 + 1 * XAdj): X2 = 5 + EndAdj
                                    Y1 = YAdj: Y2 = YAdj2
                                    SCol(0) = SeqCol(XOverList(CurSeq, PermArray(X, Y)).MinorP)
                                    SCol(1) = ProgColour(XOverList(CurSeq, PermArray(X, Y)).ProgramFlag)
                                    SCol(2) = ProbCol
                                    SCol(3) = DistCol
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                    
                                    X1 = 5 + BeginAdj: X2 = 5 + LSeq * XAdj
                                    Y1 = YAdj: Y2 = YAdj2
                                    SCol(0) = SeqCol(XOverList(CurSeq, PermArray(X, Y)).MinorP)
                                    SCol(1) = ProgColour(XOverList(CurSeq, PermArray(X, Y)).ProgramFlag)
                                    SCol(2) = ProbCol
                                    SCol(3) = DistCol
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())

                                    If XOverList(CurSeq, PermArray(X, Y)).Accept = 1 Then
                                        X1 = 4 + 1 * XAdj: X2 = 6 + EndAdj
                                        Y1 = YAdj: Y2 = YAdj2
                                        SCol(0) = -1: SCol(1) = -1: SCol(2) = -1: SCol(3) = -1
                                        Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                        
                                        X1 = 4 + BeginAdj: X2 = 6 + LSeq * XAdj
                                        Y1 = YAdj: Y2 = YAdj2
                                        SCol(0) = -1: SCol(1) = -1: SCol(2) = -1: SCol(3) = -1
                                        Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                        
                                    End If

                                    '"Delete" the corresponding portion of the background sequence plot
                                    X1 = 5 + 1 * XAdj: X2 = 5 + EndAdj
                                    Y1 = ((OldY) * 12 + 3) * SpaceAdjust: Y2 = (OldY * 12 + 13) * SpaceAdjust
                                    SCol(0) = FFillCol(CurSeq)
                                    SCol(1) = FillColour
                                    SCol(2) = FillColour
                                    SCol(3) = FillColour
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                    
                                    X1 = 5 + BeginAdj: X2 = 5 + LSeq * XAdj
                                    Y1 = ((OldY) * 12 + 3) * SpaceAdjust: Y2 = (OldY * 12 + 13) * SpaceAdjust
                                    SCol(0) = FFillCol(CurSeq)
                                    SCol(1) = FillColour
                                    SCol(2) = FillColour
                                    SCol(3) = FillColour
                                    Call AddBlock(X1, Y1, X2, Y2, SCol(), SBlocksLen, SchemBlocks())
                                End If

                            End With

                        End If

                    End If

                    'Print names

                    If TBegin < TEnd Or Int((X + 1) / AdjArrayPos) < TBegin Then

                        If XOverList(CurSeq, PermArray(X, Y)).MinorP <= NextNo And XOverList(CurSeq, PermArray(X, Y)).OutsideFlag < 2 And Len(StraiName(XOverList(CurSeq, PermArray(X, Y)).MinorP)) > 0 Then
                            
                            Extend = CInt(LSeq * (((Form1.Picture5.TextWidth("O" & StraiName(XOverList(CurSeq, PermArray(X, Y)).MinorP)))) / (Frm1Pic5ScaleWidth)))
                            'Print shadows
                            X1 = 3 + Int(1 + (5 + EndAdj)): Y1 = 1 + YAdj
                            SCol(0) = QuaterColour: SCol(1) = HalfColour: SCol(2) = HalfColour: SCol(3) = HalfColour
                            Call AddString(X1, Y1, XOverList(CurSeq, PermArray(X, Y)).MinorP, SCol(), SStringLen, SchemString())
                            
                            
                            
                            
                            'Print Names in colour
                                
                            If XOverList(CurSeq, PermArray(X, Y)).Accept <> 2 Then
                                X1 = 2 + Int(1 + (5 + EndAdj)): Y1 = YAdj
                                SCol(0) = SeqCol(XOverList(CurSeq, PermArray(X, Y)).MinorP): SCol(1) = 0: SCol(2) = 0: SCol(3) = 0
                                Call AddString(X1, Y1, XOverList(CurSeq, PermArray(X, Y)).MinorP, SCol(), SStringLen, SchemString())
                                
                            End If

                        Else
                            Extend = CInt(LSeq * (Form1.Picture5.TextWidth("OUnknown") / (Frm1Pic5ScaleWidth)))
                            
                            X1 = 3 + Int(1 + (5 + EndAdj)): Y1 = YAdj
                            SCol(0) = HalfColour: SCol(1) = HalfColour: SCol(2) = HalfColour: SCol(3) = HalfColour
                            Call AddString(X1, Y1, NextNo + 1, SCol(), SStringLen, SchemString())
                            

                            If XOverList(CurSeq, PermArray(X, Y)).Accept <> 2 Then
                                'Print recombinant names in grey
                                X1 = 2 + Int(1 + (5 + EndAdj)): Y1 = YAdj
                                SCol(0) = SeqCol(XOverList(CurSeq, PermArray(X, Y)).MinorP): SCol(1) = 0: SCol(2) = 0: SCol(3) = 0
                                Call AddString(X1, Y1, NextNo + 1, SCol(), SStringLen, SchemString())
                                
                            End If

                        End If

                        X = CInt((TEnd + Extend) * AdjArrayPos) + 2
                    Else
                        X = Frm1Pic5ScaleWidth
                    End If

                End If

            Next 'X

        End If
        ET = GetTickCount
        If ET - ST > 500 Then
            ST = ET
            Form1.ProgressBar1 = 90 + 10 * (Y / LastDim)
        End If
        
    Next 'Y
    Form1.ProgressBar1 = 100
    Form1.Picture6.Enabled = True
    Form1.VScroll2.Max = (((LastDim) * 12 + 20) * SpaceAdjust) - Form1.Picture5.ScaleHeight
    Form1.HScroll2.Max = (Form1.Picture6.Width - Form1.Picture5.ScaleWidth)
    Form1.HScroll2.LargeChange = Form1.Picture5.ScaleWidth

    If Form1.VScroll2.Max > 0 Then
        Form1.VScroll2.Enabled = True
    Else
        Form1.VScroll2.Enabled = False
    End If

    Form1.HScroll2.Enabled = True
    Form1.VScroll2.LargeChange = (Form1.Picture5.Height / Screen.TwipsPerPixelY)
    Form1.VScroll2.SmallChange = 12
    
    Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, StraiName(), -Form1.VScroll2.Value, Form1.Picture6)
    
    'Exit Sub
    
    If SPF = 1 Then
    
        ReDim SeqProb2(NextNo, LSeq)
    
        
        For X = 0 To NextNo
    
            For Y = 1 To LSeq
                SeqProb2(X, Y) = 1
            Next 'Y
    
        Next 'X
    
        Dim PMA As Integer
    
        PMA = PNum - AddNum
    
        For X = 0 To NextNo
            If CurrentXover(X) > 0 Then
                For G = 0 To PMA
        
                    If ProgF(G) = 1 Then
        
                        For Y = 1 To LSeq
        
                            If XOverNoComponent(G, iRevseq(X), Y) > 0 Then
                                SeqProb2(X, Y) = 0
                                'Exit For
                            End If
        
                        Next 'Y
        
                    End If
        
                Next 'G
            End If
        Next 'X
    End If
    Form1.Timer1.Enabled = False
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    

    Exit Sub
Ending:
    Exit Sub
RedoReDim:
    Response = MsgBox("Your computer does not have enough available memory to integrate the recombination data.  Please save your results in .rdp format.  You could attempt to view the saved file by restarting your computer and try reloading the analysis results from the saved file", 48)
    Form1.Picture7.Enabled = False
    Form1.SSPanel5.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False

    Call EmergencySave

    Exit Sub
OutOfMemoryError:
    Exit Sub
ResizePictures:
    Response = MsgBox("Your computer does not have enough available memory to fully display the recombination data.  This error is occasionally fatal so I recommend that you save your results before continuing", 48)
    LastDim = LastDim * 0.5
    Form1.Picture6.ScaleHeight = Form1.Picture5.Height

    Call EmergencySave

    GoTo RedoSizing
PictureResize:
    Return
End Sub
Public Sub DistColour(DistCol As Long)
    'Translates a distance into a colour somewhere between white through red/purple to black

    Dim RCol As Integer, GCol As Integer, BCol As Integer

    If DistCol > 510 Then
        RCol = 255
        GCol = 255
        BCol = DistCol - 510
    ElseIf DistCol > 255 Then
        RCol = 255
        GCol = DistCol - 255
        BCol = 0
    ElseIf DistCol > 0 Then
        RCol = DistCol
        GCol = 0
        BCol = 0
    Else
        RCol = 0
        GCol = 0
        BCol = 0
    End If

    DistCol = RGB(RCol, BCol, GCol)
End Sub
Public Sub ProbColour(ProbCol As Long)
    'Translates a probability value into a colour somewhere between white through red/purple to black

    Dim RCol As Integer, GCol As Integer, BCol As Integer

    If ProbCol < 0 Then ProbCol = 0

    If ProbCol > 765 Then ProbCol = 765

    If ProbCol > 510 Then
        RCol = 255
        GCol = 255
        BCol = Int(ProbCol) - 510
    ElseIf ProbCol > 255 Then
        RCol = 255
        GCol = Int(ProbCol) - 255
        BCol = 0
    Else
        RCol = Int(ProbCol)
        GCol = 0
        BCol = 0
    End If

    If RCol < 0 Then RCol = 0
    xxx = RGB(RCol, BCol, GCol)
    ProbCol = RGB(RCol, BCol, GCol)
End Sub

Public Sub EmergencySave()

    Dim MissF As String

    If CLine = "" Then
        'Dim SFName As String

        With Form1.CommonDialog1
            .filename = ""
            '.InitDir = currentdir
            .DefaultExt = ".rdp"   'Specify the default extension.
            'Specify which file extensions will be preferred.
            '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
            .Filter = "RDP Project File (*.rdp)|*.rdp|Recombination Data in Text File (*.txt)|*.txt"
            '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
            .Action = 2 'Specify that the "open file" action is required.
            SFName$ = .filename  'Stores selected file name in the
            'string, fname$.
        End With

        If SFName$ = "" Then Exit Sub
        Screen.MousePointer = 11

        If right$(SFName$, 4) = ".rdp" Or right$(SFName$, 4) = ".RDP" Then

            If GENECONVFlag = 1 Then
                Open GCOFile For Binary Access Read As #1
                gcout$ = String$(LOF(1), " ")
                Get #1, 1, gcout$
                Close #1
            End If

            Open SFName$ For Output As #1
            SaveFlag = 1
            'Print #1, SeqFile

            For X = 0 To NextNo
                Print #1, ">" & StraiName(X)
                Print #1, StrainSeq(X)
            Next 'X

            Print #1, "GB Data"
            Print #1, GBFile
            Write #1, "Recombination Data"
            Write #1, "r10"
            Write #1, SpacerFlag, CircularFlag, ShowPlotFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
            Write #1, GCSeqTypeFlag, GCIndelFlag, GCCodeFlag, GCtripletflag
            Write #1, GCOutfileName
            Write #1, GCOutFlag, GCOutFlagII, GCSortFlag, GCEndLen, GCLogFlag
            Write #1, GCMissmatchPen, GCMaxGlobFrags, GCMaxPairFrags, GCMinFragLen, GCMinPolyInFrag
            Write #1, GCMinPairScore, GCMaxOverlapFrags, GCNumPerms, GCMaxPermPVal, GCPermPolyFlag
            Write #1, BSStepWin, BSStepSize, BSCutOff, BSBootReps, BSRndNumSeed, BSSubModelFlag
            Write #1, BSTTRatio, BSCStepWin, BSCStepSize, BSCBootReps, MatPermNo
            Write #1, BSCDecreaseStepFlag, BSCDStepSize, BSCDStepWin, MatWinSize, BSCDSpan
            Write #1, MCPerms, MCPermMaxP, MCSteplen, MCWinSize
            Write #1, RDPFlag, GENECONVFlag, BOOTSCANFlag, MaxChiFlag, ChimaeraFlag, SiScanFlag
            Write #1, FileList(1), FileList(2), FileList(3), FileList(4)
            Write #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
            Write #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
            Write #1, MCWinFract, MCProportionFlag, MCTripletFlag, MCStripGapsFlag
            Write #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
            Write #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
            Write #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
            Write #1, TOTreeType, TOFreqFlag, TOModel
            Write #1, BSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
            Write #1, BSCTypeFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
            Write #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
            Write #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
            Write #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, BSPValFlag, SSFastFlag, SSGapFlag, SSVarPFlag, SSOutlyerFlag, SSRndSeed, SSWinLen, SSStep, SSNumPerms, SSNumPerms2
            Write #1, ForcePhylE, PolishBPFlag, Realignflag, ConsensusProg, CWinFract, CProportionFlag, CWinSize, CPerms, CPermMaxP
            Write #1, PPWinLen, PPStripGaps, IncSelf, PPSeed, PPPerms, PhylProFlag
            Write #1, MCCorrection

            For X = 0 To NextNo
                Write #1, MaskSeq(X)
            Next 'X

            Write #1, ""

            For X = 0 To NextNo
                Write #1, CurrentXover(X)
            Next 'X

            Write #1, ""

            For X = 0 To NextNo

                For Y = 1 To CurrentXover(X)
                    Write #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending
                    Write #1, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
                    Write #1, XX, XOverList(X, Y).PermPVal, XOverList(X, Y).ProgramFlag
                    Write #1, xxx, XX, XOverList(X, Y).LHolder, XOverList(X, Y).LHolder
                    Write #1, XOverList(X, Y).BeginP, XOverList(X, Y).EndP, XX, xxx
                    Write #1, XOverList(X, Y).SBPFlag
                    'Input #1, XOverList(X, Y).Daughter, XOverList(X, Y).MajorP, XOverList(X, Y).MinorP, XOverList(X, Y).Beginning, XOverList(X, Y).Ending, XOverList(X, Y).Probability, XOverList(X, Y).OutsideFlag, XOverList(X, Y).MissIdentifyFlag
                    'Input #1, XOverList(X, Y).MisPen, XOverList(X, Y).PermPVal, XOverList(X, Y).ProgramFlag, XOverList(X, Y).TotDiffs, XOverList(X, Y).NumDiffs, XOverList(X, Y).lholder, XOverList(X, Y).lholder
                Next 'Y

            Next 'X

            Write #1, gcout$
        ElseIf right$(SFName$, 4) = ".txt" Or right$(SFName$, 4) = ".TXT" Then
            'Print #1, SeqFile
            Open SFName$ For Output As #1
            ' Exit Sub
            Print #1, "Recombination Data for:", FName$
            Print #1, Chr$(9), "IncorrectDaughter?", Chr$(9), "DaughterSequence", Chr$(9), "MajorParent", Chr$(9), "MinorParent", Chr$(9), "BeginningInAlignment", Chr$(9), "EndingInAlignment", Chr$(9), "BeginningInSequence", Chr$(9), "EndingInSequence", Chr$(9), "UncorrectedProbability", Chr$(9), "MCCorrectedProbability"

            If MCFlag = 0 Then

                For X = 0 To NextNo

                    For Y = 0 To CurrentXover(X)

                        If XOverList(X, Y).Probability > 0 Then

                            If XOverList(X, Y).OutsideFlag = 0 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            ElseIf XOverList(X, Y).OutsideFlag = 1 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MajorP) + ")", Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            ElseIf XOverList(X, Y).OutsideFlag = 2 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MinorP) + ")", Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            End If

                        Else
                            'Exit For
                        End If

                    Next 'Y

                Next 'X

            Else

                For X = 0 To NextNo

                    For Y = 0 To CurrentXover(X)

                        If XOverList(X, Y).Probability > 0 Then

                            If XOverList(X, Y).OutsideFlag = 0 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability, Chr$(9), XOverList(X, Y).Probability * MCCorrection
                            ElseIf XOverList(X, Y).OutsideFlag = 1 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MajorP) + ")", Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability, Chr$(9), XOverList(X, Y).Probability * MCCorrection
                            ElseIf XOverList(X, Y).OutsideFlag = 2 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MinorP) + ")", Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability, Chr$(9), XOverList(X, Y).Probability * MCCorrection
                            End If

                        Else
                            'Exit For
                        End If

                    Next 'Y

                Next 'X

            End If

        End If

        Close #1
        Screen.MousePointer = 0
    Else
        Open OutFileX For Append As #1

        If ShortOutFlag = 0 Then
            Print #1, "Start"
            Print #1, "Recombination Data for:", InFileX
            Print #1, "Possible recombination events:", oRecombNo(100)
            Print #1, Chr$(9), "IncorrectDaughter?", Chr$(9), "DaughterSequence", Chr$(9), "MajorParent", Chr$(9), "MinorParent", Chr$(9), "BeginningInAlignment", Chr$(9), "EndingInAlignment", Chr$(9), "BeginningInSequence", Chr$(9), "EndingInSequence", Chr$(9), "UncorrectedProbability", Chr$(9), "MCCorrectedProbability"

            If MCFlag = 0 Then

                For X = 0 To NextNo

                    For Y = 0 To CurrentXover(X)

                        If XOverList(X, Y).Probability > 0 Then

                            If XOverList(X, Y).OutsideFlag = 0 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            ElseIf XOverList(X, Y).OutsideFlag = 1 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MajorP) + ")", Chr$(9), StraiName(XOverList(X, Y).MinorP), Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            ElseIf XOverList(X, Y).OutsideFlag = 2 Then

                                If XOverList(X, Y).MissIdentifyFlag = 1 Then
                                    MissF = "+"
                                Else
                                    MissF = "-"
                                End If

                                Print #1, Chr$(9), MissF, Chr$(9), StraiName(XOverList(X, Y).Daughter), Chr$(9), StraiName(XOverList(X, Y).MajorP), Chr$(9), "Unknown (" + StraiName(XOverList(X, Y).MinorP) + ")", Chr$(9), XOverList(X, Y).Beginning, Chr$(9), XOverList(X, Y).Ending, Chr$(9), XOverList(X, Y).Beginning - SeqSpaces(XOverList(X, Y).Beginning, X), Chr$(9), XOverList(X, Y).Ending - SeqSpaces(XOverList(X, Y).Ending, X), Chr$(9), XOverList(X, Y).Probability / MCCorrection, Chr$(9), XOverList(X, Y).Probability
                            End If

                        Else
                            'Exit For
                        End If

                    Next 'Y

                Next 'X

            Else

                For X = 0 To NextNo

                    For Y = 0 To CurrentXover(X)
                        Print #1, StraiName(XOverList(X, Y).Daughter), StraiName(XOverList(X, Y).MajorP), StraiName(XOverList(X, Y).MinorP), XOverList(X, Y).Beginning, XOverList(X, Y).Ending, XOverList(X, Y).Beginning - SeqSpaces(X, XOverList(X, Y).Beginning), XOverList(X, Y).Ending - SeqSpaces(X, XOverList(X, Y).Ending), XOverList(X, Y).Probability, XOverList(X, Y).Probability * MCCorrection
                    Next 'Y

                Next 'X

            End If

            Print #1, "Finish"
        ElseIf ShortOutFlag = 1 Then

            For X = 0 To NextNo

                If RFlag(X) > 0 Then
                    Print #1, "1"
                Else
                    Print #1, "0"
                End If

            Next 'X

        ElseIf ShortOutFlag = 2 Then

            For X = 0 To NextNo
                Print #1, RFlag(X)
            Next 'X

        End If

        Close #1
        Screen.MousePointer = 0
    End If

End Sub

Public Sub CalcHomology2(DF)
    'This calculates the values displayed in the "Homology display"
    Dim Y As Long, X As Long, SX As Long, EX As Long
    Dim LSeq As Long, DivBy As Long, Pict As Long
    Dim StepSizeB As Double, Interval As Double, temp As Double
    Dim WindowSize As Integer, HWindowSize As Integer, ShortColourB As Integer, ShortColourG As Integer, ShortColourR As Integer, HeightOfWindow As Integer
    Dim Pnt As POINTAPI
    
    If DF = 1 Then
        ofull = FullWindowSize
        FullWindowSize = 20
    End If
    
    Form1.SSPanel1.Caption = "Calculating Identity"
    LSeq = Len(StrainSeq(0))
    ReDim BkgHomology(LSeq)
    'If distance matrix not calculated yet then calculate it

    If DistanceFlag = 0 Then
        
        Call CalcDistances(0, 0)
        ReDim PPermValid(NextNo, NextNo), PPermDiffs(NextNo, NextNo)
        PermUDst = UDst: PermAvDst = AvDst
        For X = 0 To NextNo
            For Y = 0 To NextNo
                PPermValid(X, Y) = PermValid(X, Y)
                PPermDiffs(X, Y) = PermDiffs(X, Y)
            Next Y
        Next X
        
        

    End If

    '"Evenise" windowsize

    If FullWindowSize > 2 Then
        WindowSize = Int(FullWindowSize / 2) * 2
    Else
        WindowSize = 2
        FullWindowSize = 2
    End If

    HWindowSize = WindowSize / 2
    'Do first window

    

    Y = 1
    SX = Y - HWindowSize
    EX = Y + HWindowSize

    For X = SX To EX

        If X >= 0 And X <= LSeq Then
            BkgHomology(Y) = BkgHomology(Y) + SiteHomol(X)
        ElseIf X < 1 Then
            BkgHomology(Y) = BkgHomology(Y) + SiteHomol(LSeq + X)
        Else
            BkgHomology(Y) = BkgHomology(Y) + SiteHomol(X - LSeq)
        End If

    Next 'X

    'Do the rest
    
    For Y = 2 To LSeq

        If Y - HWindowSize > 0 Then
            BkgHomology(Y) = BkgHomology(Y - 1) - SiteHomol(Y - HWindowSize)
        Else
            BkgHomology(Y) = BkgHomology(Y - 1) - SiteHomol(LSeq + (Y - HWindowSize))
        End If

        If Y + HWindowSize <= LSeq Then
            BkgHomology(Y) = BkgHomology(Y) + SiteHomol(Y + HWindowSize)
        Else
            BkgHomology(Y) = BkgHomology(Y) + SiteHomol((Y + HWindowSize) - LSeq)
        End If
        
    Next 'Y
   
    MaxHomology = 0
    MinHomology = 1
    DivBy = NextNo * (NextNo + 1)

    For X = 1 To LSeq
        BkgHomology(X) = BkgHomology(X) / (DivBy * WindowSize)
        AvBkgHomology = AvBkgHomology + BkgHomology(X)
        If BkgHomology(X) > MaxHomology Then
            MaxHomology = BkgHomology(X)
        ElseIf BkgHomology(X) < MinHomology Then
            MinHomology = BkgHomology(X)
        End If

    Next 'X
     AvBkgHomology = AvBkgHomology / LSeq
    Form1.ProgressBar1.Value = 60
    'Make sure that the scalemode is in pixels
    Form1.Picture4.ScaleMode = 3
    Form1.Picture11.ScaleMode = 3
    StepSizeB = LSeq / Form1.Picture4.ScaleWidth

    If StepSizeB < 1 Then

        If StepSizeB <> 0 Then
            Chunk = Int(1 / StepSizeB) + 1
        Else
            Chunk = 1
        End If

        StepSizeB = 1
    Else
        Chunk = 1
    End If

    HeightOfWindow = Form1.Picture4.ScaleHeight
    Interval = MaxHomology - MinHomology
    'Enable "Homology Window Toggle" Button
    Form1.Command21.Enabled = True
    'Clear and prepare windows for drawing
    Form1.Picture11.DrawMode = 13
    Form1.Picture11.Picture = LoadPicture()
    Form1.Picture11.ForeColor = 0
    Form1.Picture11.AutoRedraw = True

    If HomologyIndicator = 2 Then
        Form1.Picture11.Visible = True
    Else
        Form1.Picture11.Visible = False
    End If

    Form1.Picture4.AutoRedraw = True
    Form1.Picture4.DrawMode = 13
    Form1.Picture4.Picture = LoadPicture()
    Form1.Picture4.DrawWidth = Chunk

    Dim SSB As Long

    SSB = CLng(StepSizeB - 0.5)
    If SSB = 0 Then SSB = 1
    Pict = Form1.Picture4.hdc

    For X = 1 To LSeq Step SSB
        temp = (BkgHomology(X) - MinHomology) / Interval
        ShortColourR = Int(temp * 765)

        If ShortColourR > 255 Then
            ShortColourR = 255
            ShortColourG = Int(temp * 765) - 255

            If ShortColourG > 255 Then
                ShortColourB = Int(temp * 765) - 510
                ShortColourG = 255
            Else
                ShortColourB = 0
            End If

        Else
            ShortColourB = 0
            ShortColourG = 0
        End If

        
        If ShortColourR < 0 Then ShortColourR = 0
        Form1.Picture4.ForeColor = RGB(ShortColourR, ShortColourB, ShortColourG)
        Dummy = MoveToEx(Pict, (X * Chunk / StepSizeB) - Chunk, 0, Pnt)
        Dummy = LineTo(Pict, (X * Chunk / StepSizeB) - Chunk, HeightOfWindow)
    Next 'X

    If Chunk = 1 Then
        Form1.Picture11.DrawWidth = 1
        Form1.Picture11.DrawMode = 13
        Form1.Picture11.ForeColor = 0
        Pict = Form1.Picture11.hdc

        For X = 1 To LSeq Step SSB
            Dummy = MoveToEx(Pict, Int((X * Chunk / StepSizeB) - Chunk), (1 - ((BkgHomology(X) - MinHomology) / Interval)) * HeightOfWindow, Pnt)
            Dummy = LineTo(Pict, Int((X * Chunk / StepSizeB) - Chunk), HeightOfWindow)
        Next 'X

    Else
        Form1.Picture11.DrawWidth = 1
        'Pict = Form1.Picture11.hdc

        For X = 1 To LSeq Step SSB
            'Dummy = MoveToEx(Pict, Int((X * Chunk / StepSizeB) - Chunk), (1 - ((BkgHomology(X) - MinHomology) / Interval)) * HeightOfWindow, Pnt)
            ' Dummy = LineTo(Pict, Int((X * Chunk / StepSizeB) - Chunk), HeightOfWindow)
            Form1.Picture11.Line (Int((X * Chunk / StepSizeB) - Chunk) - Chunk / 2, (1 - ((BkgHomology(X) - MinHomology) / Interval)) * HeightOfWindow)-(Int((X * Chunk / StepSizeB) - Chunk) + Chunk / 2, HeightOfWindow), , BF
        Next 'X

    End If
    
    
    'Calculate distmods
    Dim Max As Double, Min As Double, Av As Double
    
    If DF = 1 Then
        ReDim DistMod(Len(StrainSeq(0)))
        FullWindowSize = ofull
        Max = -10
        Min = 100
        Av = 0
        For X = 1 To Len(StrainSeq(0))
            Av = Av + BkgHomology(X)
            If Max < BkgHomology(X) Then
                Max = BkgHomology(X)
            End If
            If Min > BkgHomology(X) Then
                Min = BkgHomology(X)
            End If
        Next X
        Av = Av / Len(StrainSeq(0))
        For X = 1 To Len(StrainSeq(0))
            If BkgHomology(X) > 0 Then
                DistMod(X) = Av / BkgHomology(X)
            Else
                DistMod(X) = Av / 0.0000001
            End If
        Next X
    End If
    Pic4Flag = 1
    Pic11Flag = 1
    Form1.Picture4.Refresh
    Form1.Picture4.DrawWidth = 1
    Form1.Picture4.Enabled = True
    Form1.Picture11.DrawWidth = 1
    Form1.Picture11.Refresh
    Form1.Picture11.Enabled = True
    Form1.SSPanel1.Caption = ""
End Sub
Public Sub HomologyWindow()

    Dim Pnt As POINTAPI
    Dim StepSizeB As Long

    Y = Form1.Picture4.ScaleWidth
    StepSizeB = CLng(Len(StrainSeq(0)) / Y)

    If StepSizeB < 1 Then
        'stepsize = 1
        Chunk = Int(1 / StepSizeB) + 1
        StepSizeB = 1
        'addfactor = 2
    Else
        Chunk = 1
    End If

    Form1.Picture4.DrawWidth = Chunk
    Form1.Picture4.AutoRedraw = True
    Form1.Picture4.PSet (0, 0), QBColor(0)
    Form1.Picture4.Refresh
    Form1.Picture11.DrawWidth = Chunk
    Form1.Picture11.AutoRedraw = True
    Form1.Picture11.PSet (0, 0), QBColor(0)
    Form1.Picture11.Refresh
    DoEvents
    BASE = RGB(255, 255, 255)

    Dim ShortColourB As Integer
    Dim ShortColourG As Integer
    Dim ShortColourR As Integer
    Dim HeightOfWindow As Integer

    HeightOfWindow = Form1.Picture4.ScaleHeight
    MaxHomology = 0
    MinHomology = 1

    For X = Beginning + 1 To Ending

        If BkgHomology(X) > MaxHomology Then MaxHomology = BkgHomology(X)

        If BkgHomology(X) < MinHomology Then MinHomology = BkgHomology(X)
    Next 'X

    Interval = MaxHomology - MinHomology
    Pict = Form1.Picture4.hdc

    For X = Beginning To Ending Step StepSizeB
        temp = (BkgHomology(X) - MinHomology) / Interval
        ShortColourR = Int(temp * 765)

        If ShortColourR > 255 Then
            ShortColourR = 255
            ShortColourG = Int(temp * 765) - 255

            If ShortColourG > 255 Then
                ShortColourB = Int(temp * 765) - 510
                ShortColourG = 255
            Else
                ShortColourB = 0
            End If

        Else
            ShortColourB = 0
            ShortColourG = 0
        End If

        Form1.Picture4.ForeColor = RGB(ShortColourR, ShortColourB, ShortColourG)
        'Form1.Picture4.ForeColor = 0
        Dummy = MoveToEx(Pict, ((X - Beginning) * Chunk / StepSizeB) - Chunk, 0, Pnt)
        Dummy = LineTo(Pict, ((X - Beginning) * Chunk / StepSizeB) - Chunk, HeightOfWindow)
    Next 'X

    Form1.Picture11.Visible = False
    Form1.Picture11.Cls
    Form1.Picture11.ForeColor = 0
    Pict = Form1.Picture11.hdc

    For X = Beginning + 1 To Ending Step StepSizeB
        Dummy = MoveToEx(Pict, Int(((X - Beginning) * Chunk / StepSizeB) - Chunk), (1 - ((BkgHomology(X) - MinHomology) / Interval)) * HeightOfWindow, Pnt)
        Dummy = LineTo(Pict, Int(((X - Beginning) * Chunk / StepSizeB) - Chunk), HeightOfWindow)
        Form1.Picture11.Visible = True
    Next 'X

    Form1.Picture4.DrawWidth = 1
    Form1.Picture4.Refresh
    Form1.Picture11.DrawWidth = 1
    Form1.Picture11.Refresh
End Sub

Public Sub PrintProbabilityII()
    'If ExeCheckFlag = 0 Then

    Dim Out As String

    ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.00") / 2 + XFactor
    Form1.Picture7.CurrentX = 1 + ProbX
    Form1.Picture7.CurrentY = 1 + 18 + (1 - ProbY) * (PicHeight - 35)
    Out$ = left$(ProbTest$, 5)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.Print Out$
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = ProbX
    Form1.Picture7.CurrentY = 18 + (1 - ProbY) * (PicHeight - 35)
    Form1.Picture7.Print Out$
    Form1.Picture7.Refresh
    'End If
    ProbY = ProbY - 0.1

    If ProbY < 0.5 Then ProbY = 1
End Sub

Public Sub PrintProbability()

    Dim Out As String, Power As String
    Dim OFSize As Integer, PY As Long
    Dim SP As Integer

    PY = 18 + (1 - ProbY) * (PicHeight - 35)
    Form1.Picture7.CurrentY = PY + 1
    OFSize = Form1.Picture7.FontSize

    Dim PV As String, EX As String

    PV = Trim(ProbTest$)
    If left(PV, 1) = "." Then PV = "0" + PV
    If Len(PV) > 3 Then

        If Mid$(PV, Len(PV) - 3, 1) = "E" Then
            EX = right$(PV, 2)
        ElseIf Len(PV) > 4 Then

            If Mid$(PV, Len(PV) - 4, 1) = "E" Then
                EX = right$(PV, 3)
            ElseIf Len(PV) > 5 Then

                If Mid$(PV, Len(PV) - 5, 1) = "E" Then
                    EX = right$(PV, 4)
                End If

            End If

        End If

    End If
    
    If Len(PV) >= 5 And Len(EX) = 0 Then
        If left$(PV, 1) = "0" Then
            SP = 3
            Do
                If Mid$(PV, SP, 1) <> "0" Then
                    PV = Mid$(PV, SP, 1) & "." & Mid$(PV, SP + 1, 3)
                    EX = Trim$(CStr(SP - 2))
    
                    If SP - 2 < 10 Then
                        EX = "0" + EX
                    End If
    
                        Exit Do
                End If
    
                SP = SP + 1
            Loop
        End If
    End If
    
    If left$(PV, 1) = "." Then
        PV = "0" + PV
    End If

    If Len(PV) >= 5 Then

        If Val(left$(PV, 5)) > 0 Then
            PV = left$(PV, 5)
        Else
            SP = 3

            Do

                If Mid$(PV, SP, 1) <> "0" Then
                    PV = Mid$(PV, SP, 1) & "." & Mid$(PV, SP + 1, 3)
                    EX = Trim$(CStr(SP - 2))

                    If SP - 2 < 10 Then
                        EX = "0" + EX
                    End If

                    Exit Do
                End If

                SP = SP + 1
            Loop

        End If

    End If

    If Len(PV) < 5 Then
        Pos = InStr(1, PV, ".", vbBinaryCompare)
        If Val(PV) <= 2 And Pos = 0 Then
            PV = PV + "."
            PV = PV + String$(5 - Len(PV), "0")
        Else
            PV = PV + String$(5 - Len(PV), "0")
        End If
    End If

    If Len(EX) > 0 Then
        PV = PV & " X 10"
        OS = Form1.Picture2.TextWidth(PV)
        PV = PV + String$(Len(EX) + 1, " ")
    End If

    Out = PV
    Power = EX

    If Len(EX) > 0 Then
        ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.00 x 1000") / 2 + XFactor
        If Form1.Picture7.TextWidth("0.00 x 100000") + ProbX > Form1.Picture7.ScaleWidth Then
            ProbX = Form1.Picture7.ScaleWidth - Form1.Picture7.TextWidth("0.00 x 100000")
        End If
    Else
        ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.000") / 2 + XFactor
        If Form1.Picture7.TextWidth("0.00000") + ProbX > Form1.Picture7.ScaleWidth Then
            ProbX = Form1.Picture7.ScaleWidth - Form1.Picture7.TextWidth("0.00000")
        End If
    End If
     
    Form1.Picture7.CurrentX = ProbX + 1
    'Do the shadow
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.Print Out$

    If Len(EX) > 0 Then

        If TwipPerPix = 12 Then
            Form1.Picture7.CurrentX = 1 + 55 + ProbX
        Else
            Form1.Picture7.CurrentX = 1 + 45 + ProbX
        End If

        Form1.Picture7.CurrentY = 1 + PY - 4
        Form1.Picture7.FontSize = CInt(Form1.Picture7.FontSize / 1.2)
        Form1.Picture7.Print "-" + Power
    End If

    'Do the number
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.FontSize = OFSize
    Form1.Picture7.CurrentX = ProbX
    Form1.Picture7.CurrentY = PY
    Form1.Picture7.Print Out$
    Form1.Picture7.FontSize = CInt(Form1.Picture7.FontSize / 1.2)

    If Len(EX) > 0 Then

        If TwipPerPix = 12 Then
            Form1.Picture7.CurrentX = 55 + ProbX
        Else
            Form1.Picture7.CurrentX = 45 + ProbX
        End If

        Form1.Picture7.CurrentY = PY - 4
        Form1.Picture7.Print "-" + Power$
    End If

    Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFSize
    ProbY = ProbY - 0.1

    If ProbY < 0.5 Then ProbY = 1
End Sub

Public Sub LoadGenBank()

    Dim FF As Long, Genes As Integer, OMode As Integer
    Dim LSeq As Long, LastPos As Long, X As Long, Z As Long, Y As Long, F As Long, A As Long
    Dim tempstring As String
    FF = FreeFile
    Form1.Picture11.ForeColor = 0
    Form1.Picture11.DrawMode = 13
    Genes = 0
    LastPos = 1
    LSeq = Len(StrainSeq(0))
    VarString$ = SeqFile

    Dim UnitLengthII As Double

    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    'StraiName(101) = StraiName(100)

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
        Else
            Exit Do
        End If

    Loop

    LastPos = 1
    ReDim GeneList(Genes * 10)

    Dim GeneNumber As Integer

    GeneNumber = Genes
    Genes = 0

    Dim PosNextGene As Long
    Dim PosDot As Long
    Dim PosComplement As Long
    Dim PosJoin As Long
    Dim PosBracket As Long
    Dim PosComma As Long
    Dim PosGene As Long
    Dim PosPar As Long
    Dim PosProd As Long
    Dim IntronNo As Integer
    Dim ExonNo As Integer

    If ORFFlag = 1 Then
        Form1.Picture19.Cls
        Form1.Picture20.Cls
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        'Form1.Picture7.Width = Form1.Picture10.ScaleWidth
        Form1.Picture7.Top = -1
        'Form1.Picture7.Left = 0
    End If

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
            PosDot = InStr(Pos, VarString$, "..", vbBinaryCompare)
            PosComplement = InStr(Pos, VarString$, "complement", vbBinaryCompare)
            PosJoin = InStr(Pos, VarString$, "join", vbBinaryCompare)
            PosNextGene = InStr(PosDot, VarString$, "CDS", vbBinaryCompare)
            PosGene = InStr(Pos, VarString$, "/gene=", vbBinaryCompare)
            
       '     If PosComplement = 0 And PosJoin = 0 Then
       '         GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
       '         GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
       '
       '         If GeneList(Genes).Start < GeneList(Genes).End Then
       '             GeneList(Genes).Orientation = 1
       '         Else
       '             GeneList(Genes).Orientation = 2
       '         End If
       '     End If
            
            If PosGene = 0 Then
                PosGene = InStr(Pos, VarString$, "/note=", vbBinaryCompare)
            End If

            If PosGene > 0 And ((PosGene < PosNextGene And PosNextGene > 0) Or PosNextGene = 0) Then
                PosNextGene = InStr(PosGene, VarString$, "CDS", vbBinaryCompare)
                PosPar = InStr(PosGene + 8, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Name = Mid$(VarString$, PosGene + 7, PosPar - PosGene - 7)
            End If

            PosProd = InStr(Pos, VarString$, "/product=", vbBinaryCompare)

            If PosProd > 0 And (PosProd < PosNextGene Or PosNextGene = 0) Then
                PosPar = InStr(PosProd + 10, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Product = Mid$(VarString$, PosProd + 10, PosPar - PosProd - 10)
            End If

            If (PosComplement > 0 And PosComplement < PosDot) Or (PosJoin > 0 And PosJoin < PosDot) Then

                If PosComplement > PosDot And PosJoin > PosDot Then
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                    GeneList(Genes).Orientation = 1
                ElseIf PosComplement > 0 And PosComplement < PosDot And (PosJoin > PosDot Or PosJoin = 0) Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosComplement + 11, PosDot - PosComplement - 11))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                ElseIf PosJoin > 0 And (PosComplement > PosDot Or PosComplement = 0) And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 1
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For X = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 1
                        GeneList(Genes).Start = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If X = IntronNo Then
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo

                        If GeneList(Genes).Start < GeneList(Genes - 1).Start Then
                            Genes = Genes - 1
                            GeneList(Genes).End = GeneList(Genes + 1).End
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            IntronNo = IntronNo - 1
                            ExonNo = ExonNo - 1
                        End If

                    Next 'X

                ElseIf PosComplement > 0 And PosJoin > 0 And PosComplement < PosDot And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, "))", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For X = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 2
                        GeneList(Genes).End = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If GeneList(Genes).End < GeneList(Genes - 1).End Then
                            GeneList(Genes).End = GeneList(Genes - 1).End
                            Genes = Genes - 1
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            ExonNo = ExonNo - 1
                            IntronNo = IntronNo - 1
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        End If

                        If X = IntronNo Then
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                            If PosComma > 0 Then
                                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                            End If

                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo
                    Next 'X

                End If

            Else
                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                xxxx = Mid$(VarString$, PosDot + 2, 6)
                GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                GeneList(Genes).Orientation = 1
            End If

        Else
            Exit Do
        End If

    Loop

    GeneNumber = Genes

    If ORFFlag = 1 Then Call HomologyWindow

    For Z = 1 To GeneNumber

        If ((GeneList(Z).Start - 1) / 3) = Int((GeneList(Z).Start - 1) / 3) Then
            GeneList(Z).Frame = 1
        ElseIf ((GeneList(Z).Start - 2) / 3) = Int((GeneList(Z).Start - 2) / 3) Then
            GeneList(Z).Frame = 2
        Else
            GeneList(Z).Frame = 3
        End If

    Next 'Z

    Pos = InStr(LastPos, VarString$, "BASE COUNT", vbBinaryCompare)

    If Pos > 0 Then
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    Else
        'Give a message if the file is not a DNA file
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    End If

    Open FName$ For Input Access Read As #FF

    Do While Not EOF(FF)
        Line Input #FF, tempstring

        If Trim$(Mid$(tempstring, 1, 12)) = "BASE COUNT" Then
            Line Input #FF, tempstring

            If Trim$(tempstring) = "ORIGIN" Then
                Exit Do
            End If
        ElseIf Trim$(tempstring) = "ORIGIN" Or Trim$(tempstring) = "origin" Or Trim$(tempstring) = "Origin" Then
                Exit Do
            
        End If

    Loop

    'Line Input #1, TempString

    Dim RefSeq As String

    RefSeq = ""

    Do While Not EOF(FF)
        Line Input #FF, tempstring

        If Trim$(tempstring) = "//" Then
            Exit Do
        End If

        For X = 1 To 6
            RefSeq = RefSeq + Mid$(tempstring, X * 10 + X, 10)
        Next 'X

    Loop

    Dim ORFSeq() As String
    Dim WinSeq As Integer

    X = Int(Len(RefSeq) / 10)

    Do While X < Len(RefSeq)
        ReDim ORFSeq(NextNo)

        For Z = 0 To NextNo
            Y = X

            Do Until Len(ORFSeq(Z)) = 40

                If SeqNum(Y, Z) > 64 And SeqNum(Y, Z) < 86 Then
                    ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqNum(Y, Z) - 1))
                End If

                Y = Y + 1

                If Y = LSeq Then
                    Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
                    ORFFlag = 0
                    Form1.Picture20.Visible = False
                    Close #FF
                    Exit Sub
                End If

            Loop

        Next 'Z

        WinSeq = -1
        RefSeq = UCase$(RefSeq)

        For Y = 0 To NextNo
            'PosMarker = Mid$(RefSeq, X, 40)
            Pos = 0

            If Len(ORFSeq(Y)) > 20 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)

            If Pos > 0 Then
                WinSeq = Y
                Exit Do
            End If

        Next 'Y

        X = X + 30
    Loop

    Dim UnitLength As Double
    Dim UnitHeight As Double
    Dim ORFHeight As Double
    Dim ORFRef As String

    If WinSeq = -1 Then
        Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
        ORFFlag = 0
        Form1.Picture20.Visible = False
        Close #FF
        Exit Sub
    End If

    For Z = 0 To LSeq

        If SeqNum(Z, WinSeq) > 64 And SeqNum(Z, WinSeq) < 86 Then
            ORFRef = ORFRef + Chr$((SeqNum(Z, WinSeq) - 1))
        End If

    Next 'Z

    X = Int(LSeq / 10)
    Y = 0

    Do While X < LSeq
        Pos = InStr(1, ORFRef, Mid$(RefSeq, X, 40), vbBinaryCompare)

        If Pos > 0 Then
            Exit Do
        End If

        X = X + 20
    Loop

    ReDim ORFWin(3, LSeq)

    Dim FrameRef As Integer

    For Z = 1 To GeneNumber
        GeneList(Z).StartInAlign = GeneList(Z).Start + Pos - X

        If GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) >= (Len(RefSeq) * 0.95) Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign - Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = 1
        End If

        Y = 0

        Do
            Y = Y + 1

            If Y - SeqSpaces(Y, WinSeq) = GeneList(Z).StartInAlign Then
                GeneList(Z).StartInAlign = Y
                Exit Do
            End If

        Loop

        GeneList(Z).EndInAlign = GeneList(Z).End + Pos - X

        If GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign - Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = 1
        End If

        Y = 0

        Do
            Y = Y + 1

            If Y - SeqSpaces(Y, WinSeq) = GeneList(Z).EndInAlign Then
                GeneList(Z).EndInAlign = Y
                Exit Do
            End If

        Loop

        Form1.Picture4.ScaleMode = 3
        Form1.Picture11.ScaleMode = 3
        UnitLength = Form1.Picture4.ScaleWidth / LSeq
        UnitHeight = Int(Form1.Picture4.ScaleHeight / 6)

        If GeneList(Z).Frame = 3 Then
            ORFHeight = UnitHeight
            FrameRef = 0
        ElseIf GeneList(Z).Frame = 2 Then
            ORFHeight = UnitHeight * 3
            FrameRef = 1
        Else
            FrameRef = 2
            ORFHeight = UnitHeight * 5
        End If

        Form1.Picture4.AutoRedraw = True
        Form1.Picture4.ForeColor = 0
        Form1.Picture4.DrawMode = 13
        Form1.Picture4.DrawWidth = 1
        Form1.Picture11.AutoRedraw = True
        Form1.Picture11.ForeColor = RGB(0, 96, 96)
        Form1.Picture11.DrawMode = 12
        Form1.Picture11.DrawWidth = 1
        Form1.Picture19.AutoRedraw = True
        Form1.Picture19.ForeColor = 0
        Form1.Picture19.DrawMode = 13
        Form1.Picture19.DrawWidth = 1
        Form1.Picture19.ScaleMode = 3
        OMode = Form1.Picture10.ScaleMode
        Form1.Picture10.ScaleMode = 3
        Form1.Picture19.Height = Form1.Picture4.ScaleHeight + 1
        Form1.Picture20.Height = Form1.Picture4.ScaleHeight + 1
        Form1.Picture10.ScaleMode = OMode

        If GeneList(Z).Orientation = 1 Then

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1) Then

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 96, 96)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 96, 96)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                Else

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    'Form1.Picture4.Line (UnitLength * (GeneList(z).StartInAlign - 10), ORFHeight - UnitHeight + 1)-(UnitLength * (GeneList(z).StartInAlign - 100), ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 96, 96)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 96, 96)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                End If

            Else

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    '        If GeneList(z + 1).Frame = 3 Then
                    '            ORFHeightII = UnitHeight
                    '        ElseIf GeneList(z + 1).Frame = 2 Then
                    '            ORFHeightII = UnitHeight * 3
                    '        Else
                    '            ORFHeightII = UnitHeight * 5
                    '        End If
                    'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                Else
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF

                    For F = GeneList(Z).StartInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        Else

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = 1) Then

                If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * GeneList(z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1),RGB(0, 32, 32), BF
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 96, 96)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 96, 96)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                Else
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * lseq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1),RGB(0, 32, 32), BF

                    For F = GeneList(Z).EndInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 96, 96)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 96, 96)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                End If

            Else

                If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    '   If GeneList(z + 1).Frame = 3 Then
                    '       ORFHeightII = UnitHeight
                    '   ElseIf GeneList(z + 1).Frame = 2 Then
                    '       ORFHeightII = UnitHeight * 3
                    '   Else
                    '       ORFHeightII = UnitHeight * 5
                    '   End If
                    'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                Else

                    For F = 1 To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = GeneList(Z).EndInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        End If

        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight - 3)-(UnitLength * GeneList(z).End, ORFHeight)
        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight + 3)-(UnitLength * GeneList(z).End, ORFHeight)
    Next 'Z

    Form1.Picture4.ScaleMode = 3
    Form1.Picture4.DrawMode = 13
    Picture11ScaleMode = 3
    Form1.Picture19.DrawMode = 13
    Form1.Picture4.Refresh
    Form1.Picture11.Refresh

    If (RunFlag = 1 Or ManFlag) And (RelX > 0 Or RelY > 0) > 0 Then

        If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
            Form1.Picture7.Height = Form1.Picture7.Height - Form1.Picture20.ScaleHeight + 5
        End If

    End If

    Form1.Picture19.Refresh
    Form1.Picture20.Picture = Form1.Picture19.Image

    If RunFlag = 1 Or ManFlag > 0 Then
        Form1.Picture20.Visible = True
    End If

    'Form1.Picture20.Visible = True
    ORFFlag = 1
    'Form1.Picture20.ScaleHeight = Form1.Picture4.ScaleHeight
    Close #FF
End Sub

Public Sub LoadGenBankII()

    Dim LSeq As Long, GLS As Long, GLE As Long

    LSeq = Len(StrainSeq(0))
    Position = 1    'Sets the position to the start.
    Buffer = 0
    Genes = 0
    LastPos = 1
    '  Get #1, position, VarString$
    'VarString$ = SeqFile
    B = Len(VarString$)

    Dim UnitLengthII As Double

    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    'StraiName(101) = StraiName(100)

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
        Else
            Exit Do
        End If

    Loop

    LastPos = 1
    ReDim GeneList(Genes * 10)

    Dim GeneNumber As Integer

    GeneNumber = Genes
    Genes = 0

    Dim PosDot As Long
    Dim PosComplement As Long
    Dim PosJoin As Long
    Dim PosBracket As Long
    Dim PosComma As Long
    Dim PosGene As Long
    Dim PosPar As Long
    Dim PosProd As Long
    Dim IntronNo As Integer
    Dim ExonNo As Integer

    If ORFFlag = 1 Then
        Form1.Picture19.Cls
        Form1.Picture20.Cls
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        'Form1.Picture7.Width = Form1.Picture10.ScaleWidth
        Form1.Picture7.Top = -1
        'Form1.Picture7.Left = 0
    End If

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
            PosDot = InStr(Pos, VarString$, "..", vbBinaryCompare)
            PosComplement = InStr(Pos, VarString$, "complement", vbBinaryCompare)
            PosJoin = InStr(Pos, VarString$, "join", vbBinaryCompare)
            PosNextGene = InStr(PosDot, VarString$, "CDS", vbBinaryCompare)
            PosGene = InStr(Pos, VarString$, "/gene=", vbBinaryCompare)

            If PosGene = 0 Then
                PosGene = InStr(Pos, VarString$, "/note=", vbBinaryCompare)
            End If

            If PosGene > 0 And PosGene < PosNextGene Then
                PosNextGene = InStr(PosGene, VarString$, "CDS", vbBinaryCompare)
                PosPar = InStr(PosGene + 8, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Name = Mid$(VarString$, PosGene + 7, PosPar - PosGene - 7)
            End If

            PosProd = InStr(Pos, VarString$, "/product=", vbBinaryCompare)

            If PosProd > 0 And (PosProd < PosNextGene Or PosNextGene = 0) Then
                PosPar = InStr(PosProd + 10, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Product = Mid$(VarString$, PosProd + 10, PosPar - PosProd - 10)
            End If

            If (PosComplement > 0 And PosComplement < PosDot) Or (PosJoin > 0 And PosJoin < PosDot) Then

                If PosComplement > PosDot And PosJoin > PosDot Then
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                    GeneList(Genes).Orientation = 1
                ElseIf PosComplement > 0 And PosComplement < PosDot And (PosJoin > PosDot Or PosJoin = 0) Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosComplement + 11, PosDot - PosComplement - 11))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                ElseIf PosJoin > 0 And (PosComplement > PosDot Or PosComplement = 0) And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 1
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For X = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 1
                        GeneList(Genes).Start = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If X = IntronNo Then
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo

                        If GeneList(Genes).Start < GeneList(Genes - 1).Start Then
                            Genes = Genes - 1
                            GeneList(Genes).End = GeneList(Genes + 1).End
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            IntronNo = IntronNo - 1
                            ExonNo = ExonNo - 1
                        End If

                    Next 'X

                ElseIf PosComplement > 0 And PosJoin > 0 And PosComplement < PosDot And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, "))", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For X = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 2
                        GeneList(Genes).End = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If GeneList(Genes).End < GeneList(Genes - 1).End Then
                            GeneList(Genes).End = GeneList(Genes - 1).End
                            Genes = Genes - 1
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            ExonNo = ExonNo - 1
                            IntronNo = IntronNo - 1
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        End If

                        If X = IntronNo Then
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                            If PosComma > 0 Then
                                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                            End If

                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo
                    Next 'X

                End If

            Else
                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                GeneList(Genes).Orientation = 1
            End If

        Else
            Exit Do
        End If

    Loop

    GeneNumber = Genes

    If ORFFlag = 1 Then Call HomologyWindow

    For Z = 1 To GeneNumber

        If ((GeneList(Z).Start - 1) / 3) = Int((GeneList(Z).Start - 1) / 3) Then
            GeneList(Z).Frame = 1
        ElseIf ((GeneList(Z).Start - 2) / 3) = Int((GeneList(Z).Start - 2) / 3) Then
            GeneList(Z).Frame = 2
        Else
            GeneList(Z).Frame = 3
        End If

    Next 'Z

    Pos = InStr(LastPos, VarString$, "BASE COUNT", vbBinaryCompare)

    If Pos > 0 Then
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    Else
        'Give a message if the file is not a DNA file
    End If

    'Close #1
    'Close #2
    'Open FName$ For Input Access Read As #2

    Do While Not EOF(1)
        Line Input #1, tempstring

        If Trim$(Mid$(tempstring, 1, 12)) = "BASE COUNT" Then
            Line Input #1, tempstring

            If Trim$(tempstring) = "ORIGIN" Then
                Exit Do
            End If

        End If

    Loop

    'Line Input #2, TempString

    Dim RefSeq As String

    RefSeq = ""

    Do
        Line Input #1, tempstring

        If Trim$(tempstring) = "//" Then
            Exit Do
        End If

        For X = 1 To 6
            RefSeq = RefSeq + Mid$(tempstring, X * 10 + X, 10)
        Next 'X

    Loop

    Dim ORFSeq() As String
    Dim WinSeq As Integer

    X = Int(Len(RefSeq) / 10)

    Do While X < Len(RefSeq)
        ReDim ORFSeq(NextNo)

        For Z = 0 To NextNo
            Y = X

            Do Until Len(ORFSeq(Z)) = 40

                If SeqNum(Y, Z) > 64 And SeqNum(Y, Z) < 86 Then
                    ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqNum(Y, Z) - 1))
                End If

                Y = Y + 1

                If Y = LSeq Then
                    Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
                    ORFFlag = 0
                    Form1.Picture20.Visible = False
                    Exit Sub
                End If

            Loop

        Next 'Z

        WinSeq = -1
        RefSeq = UCase$(RefSeq)

        For Y = 0 To NextNo
            'PosMarker = Mid$(RefSeq, X, 40)
            Pos = 0

            If Len(ORFSeq(Y)) > 20 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)

            If Pos > 0 Then
                WinSeq = Y
                Exit Do
            End If

        Next 'Y

        X = X + 30
    Loop

    Dim UnitLength As Double
    Dim UnitHeight As Double
    Dim ORFHeight As Double
    Dim ORFRef As String

    If WinSeq = -1 Then
        Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
        ORFFlag = 0
        Form1.Picture20.Visible = False
        Exit Sub
    End If

    For Z = 0 To LSeq

        If SeqNum(Z, WinSeq) > 64 And SeqNum(Z, WinSeq) < 86 Then
            ORFRef = ORFRef + Chr$((SeqNum(Z, WinSeq) - 1))
        End If

    Next 'Z

    X = Int(LSeq / 10)
    Y = 0

    Do While X < LSeq
        Pos = InStr(1, ORFRef, Mid$(RefSeq, X, 40), vbBinaryCompare)

        If Pos > 0 Then
            Exit Do
        End If

        X = X + 20
    Loop

    ReDim ORFWin(3, LSeq)

    Dim FrameRef As Integer

    For Z = 1 To GeneNumber
        GeneList(Z).StartInAlign = GeneList(Z).Start + Pos - X

        If GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) >= (Len(RefSeq) * 0.95) Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign - Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = 1
        End If

        Y = 0

        Do
            Y = Y + 1

            If Y - SeqSpaces(Y, WinSeq) = GeneList(Z).StartInAlign Then
                GeneList(Z).StartInAlign = Y
                Exit Do
            End If

        Loop

        GeneList(Z).EndInAlign = GeneList(Z).End + Pos - X

        If GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign - Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = 1
        End If

        Y = 0

        Do
            Y = Y + 1

            If Y - SeqSpaces(Y, WinSeq) = GeneList(Z).EndInAlign Then
                GeneList(Z).EndInAlign = Y
                Exit Do
            End If

        Loop

        Form1.Picture4.ScaleMode = 3
        Form1.Picture11.ScaleMode = 3
        UnitLength = Form1.Picture4.ScaleWidth / LSeq
        UnitHeight = Int(Form1.Picture4.ScaleHeight / 6)

        If GeneList(Z).Frame = 3 Then
            ORFHeight = UnitHeight
            FrameRef = 0
        ElseIf GeneList(Z).Frame = 2 Then
            ORFHeight = UnitHeight * 3
            FrameRef = 1
        Else
            FrameRef = 2
            ORFHeight = UnitHeight * 5
        End If

        Form1.Picture4.AutoRedraw = True
        Form1.Picture4.ForeColor = 0
        Form1.Picture4.DrawMode = 13
        Form1.Picture4.DrawWidth = 1
        Form1.Picture11.AutoRedraw = True
        Form1.Picture11.ForeColor = RGB(0, 64, 64)
        Form1.Picture11.DrawWidth = 1
        Form1.Picture19.AutoRedraw = True
        Form1.Picture19.ForeColor = 0
        Form1.Picture19.DrawMode = 13
        Form1.Picture19.DrawWidth = 1
        Form1.Picture19.ScaleMode = 3
        Form1.Picture19.Height = Form1.Picture4.ScaleHeight + 1
        Form1.Picture20.Height = Form1.Picture4.ScaleHeight + 1

        If GeneList(Z).Orientation = 1 Then

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1) Then

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 2 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 2 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 3 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 3 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 4 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 4 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                Else

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    'Form1.Picture4.Line (UnitLength * (GeneList(z).StartInAlign - 10), ORFHeight - UnitHeight + 1)-(UnitLength * (GeneList(z).StartInAlign - 100), ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                End If

            Else

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                Else
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF

                    For F = GeneList(Z).StartInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        Else

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = 1) Then

                If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * GeneList(z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                Else
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * lseq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF

                    For F = GeneList(Z).EndInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                End If

            Else
                GLE = GeneList(Z).EndInAlign
                GLS = GeneList(Z).StartInAlign

                If GLS > GLE Then

                    For F = GLE To GLS
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight + UnitHeight - 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLS, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GLS, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GLE, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1)
                Else

                    For F = 1 To GLS
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = GLE To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight + UnitHeight - 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLS, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GLS, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GLE, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        End If

    Next 'Z

    Form1.Picture4.ScaleMode = 3
    Form1.Picture4.DrawMode = 13
    Picture11ScaleMode = 3
    Form1.Picture19.DrawMode = 13
    Form1.Picture4.Refresh
    Form1.Picture11.Refresh

    If RunFlag = 1 Then

        If XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
            Form1.Picture7.Height = Form1.Picture7.Height - Form1.Picture20.ScaleHeight + 5
        End If

    End If

    Form1.Picture19.Refresh
    Form1.Picture20.Picture = Form1.Picture19.Image

    If RunFlag = 1 Then
        Form1.Picture20.Visible = True
    End If

    'Form1.Picture20.Visible = True
    ORFFlag = 1
    Form1.Picture20.Height = Form1.Picture4.ScaleHeight
End Sub
Public Function ShellAndClose(ByVal JobToDo As String, Optional ExecMode As Integer) As Long
    ' Most of this code was written by Carl E. Peterson
    ' Shells a new process and waits for it to complete.
    ' Calling application is responsive while new process
    ' executes. It will react to new events, though execution
    ' of the current thread will not continue.
    ' Will close a DOS box when Win95 doesn't. More overhead
    ' than ShellAndLoop but useful when needed.

    Dim FL As Long, StartT As Long, EndT As Long, SleepInterval As Long, NumLines As Long, PID As Long, hProcess As Long, hWndJob As Long, nRet As Long, LOF1 As Long, ProcessID As Long, AddS As Long, LPos As Long, LastAdd As Long, OneTree As Long
    Dim Counter As Integer, DoneThis As Integer, FF As Integer
    Dim GetString As String, TitleTmp As String
    Dim Hold As Double

    Const fdwAccess = PROCESS_QUERY_INFORMATION
    'This code checks to see whether the execution of a shelled program started earlier
    'was aborted - If it was then it either closes the "Finished" window or shuts
    'the program down the hard/bad way using TerminateProcess.

    If scProcess > 0 Then
        TitleTmp = Space$(256)
        nRet = GetWindowText(scWndJob, TitleTmp, Len(TitleTmp))

        If nRet Then
            TitleTmp = UCase$(left$(TitleTmp, nRet))

            If InStr(TitleTmp, "FINISHED") = 1 Then

                Call SendMessage(scWndJob, WM_CLOSE, 0, 0)

            End If

        End If

        GetExitCodeProcess scProcess, nRet

        If nRet = STILL_ACTIVE Then
            TerminateProcess scProcess, nRet
        End If

        CloseHandle scProcess
        scProcess = 0
    End If

    'This checks whether any Phylip component is currently executing from
    'the  RDP directory - If they are it gives a warning message and quits.
    On Error Resume Next
    Kill "outfile"
    On Error GoTo 0
    On Error Resume Next
    FF = FreeFile
    Open "outfile" For Append As #FF
    FL = LOF(FF)

    If FL > 0 Then
        AbortFlag = 1
        Response = MsgBox("I have detected a Phylip/Phylip derived component (either Seqboot, NeighborRDP, Dnadist, FastDNAML, Fitch or Consense) is currently busy running from the RDP directory.  You may:" + Chr$(13) + "  (1) Wait for this program to finish execution before you try again. " + Chr$(13) + "  (2) Terminate it yourself and then try again.", vbInformation)
    End If

    Print #FF, "xx"
    Close #FF
    'GetString = Err
    Err = 0
    Kill "outfile"

    If Err And AbortFlag = 0 Then
        AbortFlag = 1
        Response = MsgBox("I have detected a Phylip/Phylip derived component (either Seqboot, NeighborRDP, Dnadist, FastDNAML, Fitch or Consense) is currently busy running from the RDP directory.  You may:" + Chr$(13) + "  (1) Wait for this program to finish execution before you try again. " + Chr$(13) + "  (2) Terminate it yourself and then try again.", vbInformation)
    End If

    On Error GoTo 0

    If AbortFlag = 1 Then Exit Function

    If IsMissing(ExecMode) Then
        ExecMode = vbMinimizedNoFocus
    Else

        If ExecMode < vbHide Or ExecMode > vbMinimizedNoFocus Then
            ExecMode = vbMinimizedNoFocus
        End If

    End If

    On Error Resume Next
    ProcessID = Shell(JobToDo, CLng(ExecMode))

    If Err Then
        ShellAndClose = vbObjectError + Err.Number
        Exit Function
    End If

    On Error GoTo 0
    hWndJob = FindWindow(vbNullString, vbNullString)

    Do Until hWndJob = 0

        If GetParent(hWndJob) = 0 Then

            Call GetWindowThreadProcessId(hWndJob, PID)

            If PID = ProcessID Then Exit Do
        End If

        hWndJob = GetWindow(hWndJob, GW_HWNDNEXT)
    Loop

    hProcess = OpenProcess(fdwAccess, False, ProcessID)
    StartT = GetTickCount

    If BatIndex = 1 Then
        Counter = 0

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 100
            'AbortFlag = 1

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scProcess = hProcess
                scWndJob = hWndJob
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)
                Close #1
                On Error GoTo 0
                Form1.SSPanel1.Caption = Int(Hold * BSBootReps) & " of " & Int(BSBootReps) & " replicates completed"
                EndT = GetTickCount

                If Hold > 0 And Hold < 1 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((((EndT - StartT) / Hold) - (EndT - StartT))) & " remaining"
                End If

                BSEnd = GetTickCount()
                Form1.Label66(0).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                Form1.Label57(0).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(BSBootReps) & " of " & Int(BSBootReps) & " replicates completed"
    ElseIf BatIndex = 2 Then
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep SleepInterval

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Close #1
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)

                If Int(Hold * Len(StrainSeq(0)) / BSStepSize) <= Int(Len(StrainSeq(0)) / BSStepSize) + 1 Then
                    Form1.SSPanel1.Caption = Int(Hold * Len(StrainSeq(0)) / BSStepSize) & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
                End If

                EndT = GetTickCount

                If Hold > 0 And Hold < 1 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((((EndT - StartT) / Hold) - (EndT - StartT))) & " remaining"
                End If

                BSEnd = GetTickCount()
                Form1.Label66(0).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                Form1.Label57(0).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)

                If Hold < 0.9 Then
                    SleepInterval = 500
                ElseIf Hold < 0.95 Then
                    SleepInterval = 500
                Else
                    SleepInterval = 100
                End If

                On Error GoTo 0
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
    ElseIf BatIndex = 4 Then 'fastDNAml
        Counter = 0
        On Error Resume Next
        Kill "checkpoint.0"
        On Error GoTo 0
        Form1.SSPanel13 = ""
        SleepInterval = 100
        AddS = 2

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 500

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                On Error Resume Next
                Open "checkpoint.0" For Binary Access Read As #1
                GetString = String$(LOF(1), " ")
                Get #1, 1, GetString
                Close #1
                Pos = 0
                NumLines = 0

                Do
                    Pos = InStr(Pos + 1, GetString, "ntaxa =", vbBinaryCompare)

                    If Pos > 0 Then
                        LPos = Pos
                    End If

                    NumLines = NumLines + 1
                Loop While Pos > 0

                If LPos > 0 Then
                    Pos = InStr(LPos, GetString, ",", vbBinaryCompare)
                    Hold = CDbl(Mid$(GetString, LPos + 7, Pos - (LPos + 7)))

                    If Hold > NextNo Then Hold = NextNo
                    Form1.SSPanel1.Caption = "Adding " + left(StraiName(Hold), 17) + " to ML tree"
                    Form2.SSPanel3.Caption = Form1.SSPanel1.Caption

                    If LastAdd <> Hold Then
                        AddS = AddS + 1

                        If AddS > NextNo Then AddS = NextNo
                        Form1.ProgressBar1.Value = ((AddS ^ 3) / (NextNo ^ 3)) * 90
                        Form2.ProgressBar1.Value = Form1.ProgressBar1.Value
                        LastAdd = Hold
                    End If

                End If

                On Error GoTo 0
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

    ElseIf BatIndex = 5 Then
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep SleepInterval

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)
                Form2.ProgressBar1.Value = Form1.ProgressBar1.Value

                If Int(Hold * Len(StrainSeq(0)) / BSStepSize) <= Int(Len(StrainSeq(0)) / BSStepSize) + 1 Then
                    Form1.SSPanel1.Caption = "Calculated for " & Int(Hold * TBSReps) & " of " & TBSReps & "  Replicates"
                    Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
                End If

                EndT = GetTickCount
                BSEnd = GetTickCount()

                If Hold < 0.9 Then
                    SleepInterval = 2000
                ElseIf Hold < 0.95 Then
                    SleepInterval = 500
                Else
                    SleepInterval = 100
                End If

                Close #1
                On Error GoTo 0
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    ElseIf BatIndex = 6 Then 'neighbor/fitch
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 100

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 And DoneThis <> 1 Then
                On Error Resume Next
                Open "outtree" For Binary Access Read As #1
                GetString = String$(LOF(1), " ")
                Get #1, 1, GetString
                Close #1
                On Error GoTo 0
                Pos = 0
                Pos = InStr(1, GetString, ";", vbBinaryCompare)

                If Pos > 0 Then
                    OneTree = Pos
                    DoneThis = 1
                End If

                Counter = 0
            ElseIf Counter = 2 And DoneThis = 1 Then
                On Error Resume Next
                Open "outtree" For Binary Access Read As #1
                LOF1 = LOF(1)
                Close #1
                On Error GoTo 0
                Hold = (LOF1 / OneTree) / TBSReps

                If Hold > 1 Then Hold = 1
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)
                Form2.ProgressBar1.Value = Form1.ProgressBar1.Value
                Form1.SSPanel1.Caption = "Trees Drawn for " & CInt(Hold * TBSReps) & " of " & TBSReps & "  Replicates"
                Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 7 Then 'phyml
        
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            sizetarget = ((23 * (NextNo + 1)) * TBSReps)
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 1000

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If

            fle = FileLen("infile_phyml_boot_trees.txt")
            'Open "infile_phyml_boot_trees.txt" For Binary Access Read As #1
            'fle = LOF(1)
            'Close #1
            If fle > 0 Then
                If fle < sizetarget Then
                    Form1.ProgressBar1 = 5 + (fle / sizetarget) * 95
                    Form1.SSPanel1.Caption = "Trees Drawn for " & Trim(Str(CInt((fle / sizetarget) * TBSReps))) & " of " & TBSReps & "  Replicates"
                Else
                    Form1.ProgressBar1 = 100
                    Form1.SSPanel1.Caption = "Trees Drawn for " & CInt(TBSReps) & " of " & TBSReps & "  Replicates"
                End If
                Form2.ProgressBar1.Value = Form1.ProgressBar1.Value
                
                Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
             
            End If
        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 8 Then

        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Form1.Picture16.ScaleHeight = NextNo * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If
            Sleep 50
            
            'Open "infile_phyml_boot_trees.txt" For Binary Access Read As #1
            'fle = LOF(1)
            'Close #1
            SS = Abs(GetTickCount)
            If SS > LL + 1000 Then
                LL = SS
                fle = FileLen("rates.txt")
            
            
                If fle > 0 Then
                XX = fle / TargetFileSize
                    If fle < TargetFileSize Then
                        Form1.ProgressBar1 = 5 + (fle / TargetFileSize) * 95
                        Form1.SSPanel1.Caption = Trim(Str(CLng((fle / TargetFileSize) * FullSize))) + " of " & Trim(Str(FullSize)) & "  MCMC Updates Completed"
                    Else
                        Form1.ProgressBar1 = 100
                        Form1.SSPanel1.Caption = Trim(Str(FullSize)) + " of " & Trim(Str(FullSize)) & "  MCMC Updates Completed"
                    End If
                    
                End If
            End If
        Loop While nRet = STILL_ACTIVE
X = X
   
    ElseIf BatIndex = 9 Then
        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Form1.Picture16.ScaleHeight = NextNo * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If
            Sleep 50
            SSS = GetTickCount
            If Abs(SSS - eee) > 500 Then
                eee = SSS
                FFX = FreeFile
                Open "outfile" For Binary Access Read As #FFX
                    fle = LOF(FFX)
                Close #FFX
                Form1.ProgressBar1.Value = StartProgress + (EndProgress - StartProgress) * fle / ExpectFL
                If EndProgress = 90 Then
                    Form1.SSPanel1.Caption = "Calculted " + CStr(CLng((fle / ExpectFL) * (ExpectFL / 30))) + " of " + CStr(CLng(ExpectFL / 30)) + " SS Scores"
                Else
                    Form1.SSPanel1.Caption = "Recalculted " + CStr(CLng((fle / ExpectFL) * (ExpectFL / 30))) + " of " + CStr(CLng(ExpectFL / 30)) + " SS Scores"
                End If
            End If
        Loop While nRet = STILL_ACTIVE

    
    Else

        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Form1.Picture16.ScaleHeight = NextNo * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                ShellAndClose = 0
                Exit Function
            End If
            Sleep 50
        Loop While nRet = STILL_ACTIVE

    End If

    Call CloseHandle(hProcess)

    BatIndex = 0
    ShellAndClose = nRet
End Function
Public Sub TreeFont(TNo As Integer)

    Dim NameWidth() As Integer
    Dim MaxNPos As Integer
    Dim X As Long

    ReDim NameWidth(NextNo)
    TRegion = 0.8 * Form1.Picture16.ScaleWidth

    Do
        MaxNPos = 0

        For X = 0 To NextNo
            If Len(StraiName(X)) > 50 Then
                StraiName(X) = left(StraiName(X), 50)
            End If
            NameWidth(X) = Form1.Picture16.TextWidth(StraiName(X))

            If MaxNPos < NameWidth(X) Then MaxNPos = NameWidth(X)
        Next 'X

        If MaxNPos <= Form1.Picture16.ScaleWidth - TRegion Then
            Exit Do
        Else
            TRegion = TRegion * 0.9
        End If

        For X = 0 To NextNo
            NameWidth(X) = Form1.Picture16.TextWidth(StraiName(X))

            If MaxNPos < NameWidth(X) Then MaxNPos = NameWidth(X)
        Next 'X

        If MaxNPos <= Form1.Picture16.ScaleWidth - TRegion Then
            Exit Do
        Else
            Form1.Picture16.FontSize = Form1.Picture16.FontSize - 0.5
        End If

    Loop


    If CurTree(TNo) = 0 Then

        For X = 0 To NextNo
            XCord(0, TNo, X) = TRegion
        Next 'X

    End If

End Sub
Public Sub GetOutie()
    'Determines which sequence in an alignment
    'is likely to make the best outlyer

    Dim TD() As Double, X As Long, Y As Long, MD As Long

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated

        Call CalcDistances(0, 0)

    End If

    ReDim TempSeq(NextNo + 2)

    For X = 0 To NextNo
        TempSeq(X) = StrainSeq(X)
    Next 'X

    ReDim TD(NextNo)

    For X = 0 To NextNo

        For Y = 0 To NextNo
            TD(X) = TD(X) + Distance(X, Y)
        Next 'Y

    Next 'X

    MD = NextNo

    For X = 0 To NextNo

        If TD(X) < MD Then
            MD = TD(X)
            Outie = X
        End If

    Next 'X

End Sub
Public Sub CalcBPFreqs(AFreq As Double, CFreq As Double, GFreq As Double, TFreq As Double)
    'Calculates the frequency of different nucleotides in an alignment

    Dim X As Integer, Y As Integer
    Dim A As Long, C As Long, G As Long, T As Long, SeqLen As Long

    SeqLen = Len(StrainSeq(0))

    For X = 1 To SeqLen

        For Y = 0 To ToNumSeqs

            If SeqNum(X, Y) = 66 Then
                A = A + 1
            ElseIf SeqNum(X, Y) = 68 Then
                C = C + 1
            ElseIf SeqNum(X, Y) = 72 Then
                G = G + 1
            ElseIf SeqNum(X, Y) = 85 Then
                T = T + 1
            End If

        Next 'Y

    Next 'X

    AFreq = A / (A + C + G + T)
    CFreq = C / (A + C + G + T)
    GFreq = G / (A + C + G + T)
    TFreq = T / (A + C + G + T)
End Sub

Public Sub ReadDistMatrix(SeqNumber As Long, MatrixFileName As String)

    Dim MatrixByte() As Byte
    Dim GetString As String
    Dim MatrixLen As Long
    Dim X As Integer, A As Integer, B As Integer

    'Open the phylip dnadist "outfile" and read data into a string and a byte array
    Open MatrixFileName For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component DNADIST.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    MatrixLen = LOF(1)
    GetString = String$(MatrixLen, " ")
    ReDim MatrixByte(MatrixLen)
    Get #1, 1, MatrixByte()
    Get #1, 1, GetString
    Close #1
    'Scan through the matrix for "." and read the number associated
    'into a double array with dimentions SeqNumber*SeqNumber
    A = 0
    B = 0

    Dim NoPeaces As Integer

    NoPeaces = (Len(TOSeq(0)) / 32000) + 1
    NewLen = Len(TOSeq(0)) / NoPeaces

    Dim MLenMO As Long

    If NoPeaces = 0 Then NoPeaces = 1
    MLenMO = MatrixLen - 1
    ReDim DistMatrix((SeqNumber + 1) * NoPeaces - 1, (SeqNumber + 1) * NoPeaces - 1)

    For X = 0 To MLenMO

        If MatrixByte(X) = 46 Then '"."
            DistMatrix(A, B) = CDbl(Mid$(GetString, X - 1, 7))
            A = A + 1

            If A = (SeqNumber + 1) * NoPeaces Then
                A = 0
                B = B + 1
            End If

        End If

    Next 'X

End Sub

Public Function ChiPVal(X As Double)
Dim PValHolder As Double, Dummy As Double
    If X = 0 Then
        ChiPVal = 1
    Else
        
        PValHolder = (NormalZ(-Sqr(X)))
        
        If PValHolder = 0 Then
            PValHolder = 10 ^ -9 / (X - 35)
        End If
        ChiPVal = PValHolder
    End If
    
End Function
Public Function NormalZ(Z As Double)
Dim Y As Variant, X As Variant, w As Variant
Dim Z_MAX As Double
Z_MAX = 6
    
If Abs(Z) < 6 Then
    If Z = 0# Then
        X = 0#
    Else
        Y = 0.5 * Abs(Z)
        If Y >= (Z_MAX * 0.5) Then
            X = 1#
        ElseIf Y < 1# Then
            
            w = Y * Y
            X = ((((((((0.000124818987 * w - 0.001075204047) * w + 0.005198775019) * w - 0.019198292004) * w + 0.059054035642) * w - 0.151968751364) * w + 0.319152932694) * w - 0.5319230073) * w + 0.797884560593) * Y * 2#
            
        Else
            
            Y = Y - 2#
            X = (((((((((((((-0.000045255659 * Y _
                + 0.00015252929) * Y - 0.000019538132) * Y _
                - 0.000676904986) * Y + 0.001390604284) * Y _
                - 0.00079462082) * Y - 0.002034254874) * Y _
                + 0.006549791214) * Y - 0.010557625006) * Y _
                + 0.011630447319) * Y - 0.009279453341) * Y _
                + 0.005353579108) * Y - 0.002141268741) * Y _
                    + 0.000535310849) * Y + 0.999936657524
        End If
           
        If ((X + 1#)) < ((1# - X)) Then
            NormalZ = (X + 1#)
        Else
            NormalZ = (1# - X)
        End If
    End If
Else
    temp = ((Abs(Z) - 6) * 10)
    
    On Error GoTo finishup
    Temp2 = 1.6 ^ temp
    WinP = (10 ^ -9) / Temp2
    NormalZ = WinP
    On Error GoTo 0
End If
Exit Function
finishup:
NormalZ = 10 ^ -30
End Function

Public Sub DoTreeMask()
Form1.AutoRedraw = True
Pict = 0
                        On Error Resume Next
                        Pict = Form1.Picture16.hdc
                        On Error GoTo 0
                        
                        If Pict = 0 Then Form1.Picture16.AutoRedraw = False
                        
F2TreeIndex = 0

If TwipPerPix = 12 Then AddjNum = 14 Else AddjNum = 14
            OldFontSize = Form1.Picture16.FontSize
            For CurrentSeq = 0 To NextNo
                Form1.Picture16.CurrentY = YCord(CTF, F2TreeIndex, CurrentSeq)
                Form1.Picture16.CurrentX = XCord(CTF, F2TreeIndex, CurrentSeq)
                'th and tw
                If ((CurrentSeq <> Seq1 And CurrentSeq <> Seq2 And CurrentSeq <> Seq3) Or (RelX = 0 And RelY = 0)) And TreeTypeFlag = 0 Then 'And MultColour(CurrentSeq) > 0 Then
                        
                        A = Form1.Picture16.CurrentX
                        B = Form1.Picture16.CurrentY
                        
                        ob = B
                        
                        Form1.Picture16.Line (A, B + 3)-(A + 1500, B + AddjNum + 1), BackColours, BF
                        Form1.Picture16.CurrentX = A
                        Form1.Picture16.CurrentY = B
                        'form1.picture16.Print StraiName(CurrentSeq)
                        If MaskSeq(CurrentSeq) = 0 Then
                            Form1.Picture16.ForeColor = 0
                        ElseIf MaskSeq(CurrentSeq) = 1 Then
                            Form1.Picture16.ForeColor = QBColor(8)
                        ElseIf MaskSeq(CurrentSeq) = 2 Then
                            Form1.Picture16.ForeColor = ThreeQuaterColour
                        End If
                        'Form1.Picture16.ForeColor = SeqCol(CurrentSeq)
                        Form1.Picture16.Print StraiName(CurrentSeq)
                        
                    
                    'On Error GoTo 0
                ElseIf RelX > 0 And RelY > 0 And TreeTypeFlag = 0 Then
                    A = Form1.Picture16.CurrentX
                    B = Form1.Picture16.CurrentY
                    Form1.Picture16.Line (A, B + 3)-(A + 1500, B + AddjNum + 1), BackColours, BF
                    Form1.Picture16.CurrentX = A
                    Form1.Picture16.CurrentY = B
                    If CurrentSeq = Seq2 Then
                        
                        'form1.picture16.Print StraiName(CurrentSeq)
                        
                        If OutsideFlagX = 2 Then
                            Form1.Picture16.ForeColor = RGB(0, 0, 128)
                        Else
                            Form1.Picture16.ForeColor = RGB(0, 0, 255)
                        End If
                        Form1.Picture16.Print StraiName(Seq2)
                    ElseIf CurrentSeq = Seq1 Then
                        
                        If OutsideFlagX = 1 Then
                            Form1.Picture16.ForeColor = RGB(0, 0, 128)
                        Else
                            Form1.Picture16.ForeColor = RGB(0, 0, 255)
                        End If
                        Form1.Picture16.Print StraiName(Seq1)
                        
                    Else
                        
                    
                        Form1.Picture16.ForeColor = RGB(255, 0, 0)
                        
                        Form1.Picture16.Print StraiName(Seq3)
                        
                    End If
                End If
        
        Next 'CurrentSeq
        Form1.Picture16.FontSize = OldFontSize
        Form1.Picture16.ForeColor = 0
End Sub
Public Sub AverageMatrix(SeqNum As Long, AverageMatrix As Double)

    Dim X As Long, Y As Long, Z As Long
    Dim MatrixSum As Double

    'Sum matrix and divide by elements

    If Len(TOSeq(0)) < 32000 Then

        For X = 0 To SeqNum

            For Y = 0 To SeqNum
                MatrixSum = MatrixSum + TotMat(X, Y)
            Next 'Y

        Next 'X

        AverageMatrix = MatrixSum / ((SeqNum + 1) * (SeqNum + 1))
        X = X
    Else

        Dim NoPeaces As Long, NoPMO As Long

        NoPeaces = (Len(TOSeq(0)) / 32000) + 1
        NoPMO = NoPeaces - 1
        NewLen = Len(TOSeq(0)) / NoPeaces

        If NoPeaces = 0 Then NoPeaces = 1

        For Z = 0 To NoPMO

            For X = 0 To SeqNum

                For Y = 0 To SeqNum
                    MatrixSum = MatrixSum + TotMat(X + Z * (SeqNum + 1), Y + Z * (SeqNum + 1))
                Next 'Y

            Next 'X

        Next 'Z

        AverageMatrix = MatrixSum / ((((SeqNum + 1) * (SeqNum + 1))) * NoPeaces)
    End If

End Sub
Public Sub DoSelectInterface()

    Dim Current1 As Long, Current2 As Long

    Form5.Picture2.AutoRedraw = True
    Form5.Picture1.AutoRedraw = True
    Form5.Picture1.CurrentY = 0
    Form5.Picture2.CurrentY = 0
    Form5.Picture1.Picture = LoadPicture()
    Form5.Picture2.Picture = LoadPicture()

    Dim X As Integer

    For X = 0 To NextNo
        UYPos(X) = -1
        SYPos(X) = -1
    Next 'X

    For X = 0 To NextNo

        If Selected(X) = 0 And X <> Form5.Combo1.ListIndex - 1 Then
            UYPos(Current1) = X
            Form5.Picture1.Print (StraiName(X))
            Current1 = Current1 + 1
        ElseIf Selected(X) = 1 And X <> Form5.Combo1.ListIndex - 1 Then
            SYPos(Current2) = X
            Form5.Picture2.Print (StraiName(X))
            Current2 = Current2 + 1
        ElseIf X = Form5.Combo1.ListIndex - 1 Then
            Selected(X) = 0
        End If

    Next 'X

    Dim TextHi As Long

    TextHi = Form5.Picture1.TextHeight(StraiName(0)) / Screen.TwipsPerPixelY
    Current1 = (Current1 + 1) * Screen.TwipsPerPixelY * TextHi
    Current2 = (Current2 + 1) * Screen.TwipsPerPixelY * TextHi
    Form5.Picture1.Height = Current1
    Form5.Picture2.Height = Current2

    If Form5.Picture1.Height > Form5.Picture3.Height Then
        Form5.VScroll1.Enabled = True
        Form5.VScroll1.Max = (Form5.Picture1.Height - Form5.Picture3.Height) / Screen.TwipsPerPixelY
        Form5.VScroll1.SmallChange = TextHi
        Form5.VScroll1.LargeChange = TextHi * 5
    Else

        If Form5.VScroll1.Enabled = True Then Form5.VScroll1.Enabled = False
    End If

    If Form5.Picture2.Height > Form5.Picture4.Height Then
        Form5.VScroll2.Enabled = True
        Form5.VScroll2.Max = (Form5.Picture2.Height - Form5.Picture4.Height) / Screen.TwipsPerPixelY
        Form5.VScroll2.SmallChange = TextHi
        Form5.VScroll2.LargeChange = TextHi * 5
    Else

        If Form5.VScroll2.Enabled = True Then Form5.VScroll2.Enabled = False
    End If

    Form5.Picture2.Refresh
    Form5.Picture1.Refresh
End Sub
Public Sub MatrixMultiply(SeqNum As Long, MultFactor As Double)

    Dim X As Integer, Y As Integer

    'Multiply every element of the matrix by "Multfactor"

    If MultFactor > -1 Then

        For X = 0 To SeqNum

            For Y = 0 To SeqNum
                TotMat(X, Y) = CLng((TotMat(X, Y) * MultFactor) * 10000) / 10000
                'X = X
            Next 'Y

        Next 'X

    End If

End Sub
Public Sub WriteDistMatrix(SeqNumber As Long)

    Dim OutString As String
    Dim X As Integer, Y As Integer

    Open "infile" For Output As #1
    Print #1, "  " & CStr(SeqNumber + 1)

    For X = 0 To SeqNumber
        OutString = "S" & Trim$(CStr(X)) & String$(9 - Len(Trim$(CStr(X))), " ")

        For Y = 0 To SeqNumber

            If DistMatrix(X, Y) = 0 Then
                OutString = OutString & "  0.0000"
            ElseIf DistMatrix(X, Y) = 1 Then
                OutString = OutString & "  1.0000"
            ElseIf DistMatrix(X, Y) > 1 Then
                OutString = OutString & "  " & DistMatrix(X, Y) & String$((6 - Len(Trim$(CStr(DistMatrix(X, Y))))), "0")
            Else
                OutString = OutString & "  " & DistMatrix(X, Y) & String$((5 - Len(Trim$(CStr(DistMatrix(X, Y))))), "0")
            End If

        Next 'Y

        Print #1, OutString
    Next 'X

    Close #1
End Sub
Public Sub TopalRunPerms2(MatAveragex As Double, CPos As Long)
    'This code will take a sequence (in TOSeq), split it into window
    'size chunks, calculate SS scores for chunks and return
    'an array containing the SS data
    Dim TreeArray() As Double
    Dim FF As Integer, FF2 As Integer
    Dim Target As String, OutString As String, GetString As String, GetStringA As String, GetStringB As String, GetStringC As String, GetStringD As String, GetStringE As String, GetStringF As String, BootName As String, Header As String
    Dim StartPos  As Long, SeqLen As Long, NumDatasets As Long, Pos As Long, ReadposA As Long, Len1 As Long, LastPos As Long, LenString As Long, MatrixLen As Long
    Dim NewAverage As Double, MultFactorx As Double, BB As Double, EE As Double
    Dim X As Integer, Y  As Integer, Z  As Integer, A  As Integer, B As Integer
    Dim Boots() As String
    Dim MatrixByte() As Byte
    Dim LTree As Long, StartT As Long, NumWins As Long
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    Dim TOTMat3()  As Double
    ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
    Dim NumDone() As Double
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(Int(TOWinLen / 2))
    ReDim Prod2(Int(TOWinLen / 2))
    ReDim Prod3(Int(TOWinLen / 2))
    ReDim Alias(Int(TOWinLen / 2))
    ReDim Ally(Int(TOWinLen / 2))
    ReDim Location(Int(TOWinLen / 2))
    ReDim Px(ToNumSeqs, Int(TOWinLen / 2))
    ReDim TTempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim Num(1)
    ReDim WeightMod(0, Int(TOWinLen / 2))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim TOTMat3(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Int(TOWinLen / 2))
    ReDim Boots(ToNumSeqs + 1)
    SeqLen = Len(StrainSeq(0))
    ReDim SSScore(3, (((Len(StrainSeq(0)) / TOStepSize) + 1) * TOPerms))
    If SeqLen > 32000 Then SeqLen = 32000
    Form1.ProgressBar1.Value = 5
    FF = 0
    Dim TempSeq2() As Integer
    ReDim TempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    Dim TS As String
    CPos = 0
    
    For X = 1 To TOPerms
        Form1.SSPanel1.Caption = "Simulating " & X & " of " & TOPerms & " Alignments"
        BB = GetTickCount
        'Generate a simulated dataset using seqgen
        On Error Resume Next
            Kill "outfilex"
            Kill "out"
        On Error GoTo 0
        Call MakeSeqGenBat2(X)
        
        ShellAndClose "seqgen.bat", 0

        If AbortFlag = 1 Then
            Exit Sub
        End If

        'Load simulated datasets into a string array (ToSeq)
        FF2 = FreeFile
        Open "outfilex" For Input As #FF2

        If LOF(FF2) = 0 Then
            MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be SEQGEN.")
            AbortFlag = 1
            Close #FF2
            Close FF
            Exit Sub
        End If

        Line Input #FF2, Header

        If Len(Header) = LOF(FF2) Then 'some systems will not simply read lines - they go for the entire file
            Close #FF2
            Target = Chr$(10)
            LastPos = 1

            Do
                Pos = InStr(LastPos, Header, Target, vbBinaryCompare)

                If Pos > 0 Then
                    Header = left$(Header, Pos - 1) + Chr$(13) + right$(Header, Len(Header) - (Pos - 1))
                    LastPos = Pos + 3
                Else
                    Exit Do
                End If

            Loop

            Open "outfilex" For Output As #FF2
            Print #FF2, Header
            Close #FF2
            Open "outfilex" For Input As #FF2
            Line Input #FF2, Header
        End If

        For Y = 0 To ToNumSeqs
            Header = ""

            Do Until Len(Header) > 0
                Line Input #FF2, Header
            Loop

            TOSeq(Y) = right$(Header, Len(Header) - 10)
        Next 'Y

        Close #FF2
        otoseq = TOSeq(0)
        'convert toseq to integer array
        
        Dim TSeqSpaces() As Integer
        ReDim TSeqSpaces(Len(TOSeq(0)), ToNumSeqs)
        For Z = 0 To ToNumSeqs
            Dummy = CopyString(Len(TOSeq(0)), TOTSeqNum(0, Z), TOSeq(Z), TSeqSpaces(0, Z))
        Next 'Z
        
        'Do the windows

        
        
        StartPos = 1
        
        
        Do While StartPos + TOWinLen < SeqLen
            
            'Do the first half of the window.
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos, 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            'TOTMat(0, 1) = TOTMat(0, 1)
            'TOTMat(0, 2) = TOTMat(0, 2) '
            'TOTMat(0, 3) = TOTMat(0, 3)
            Call AverageMatrix(ToNumSeqs, NewAverage)
            
            
            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            Dim TotMat2() As Double
            ReDim TotMat2(ToNumSeqs, ToNumSeqs)
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                    TotMat2(Z, Y) = TotMat(Z, Y)
                    TotMat2(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            
            Pos = 0
            
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            ReDim ColTotals(ToNumSeqs)
            
            ReDim TreeArray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 2, TORndNum, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
            LTree = LTree + 1
            
             
            Dim Tmat3() As Double
             
            MaxCurPos = ToNumSeqs * 3
            NameLen = Len(Trim$(CStr(ToNumSeqs + 1)))
            If NameLen = 1 Then NameLen = 2
           
            ReDim TMat2(ToNumSeqs, ToNumSeqs), Tmat3(ToNumSeqs, ToNumSeqs)
            ReDim TempNodeOrder(MaxCurPos)
            ReDim NodeLen(MaxCurPos)
             ReDim NodeOrder(MaxCurPos)
            ReDim DoneNode(MaxCurPos)
            ReDim RootNode(MaxCurPos, MaxCurPos)
            
            ReDim NumDone(MaxCurPos)
            'Make a matrix of distances within the tree
            TreeToArray NameLen, ToNumSeqs, LTree, SHolder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
            
            For Z = 0 To 3
                For Y = Z + 1 To 3
                    TotMat2(Z, Y) = TotMat2(Z, Y)
                    TMat2(Y, Z) = TMat2(Y, Z)
                    
                Next Y
            Next
            
            'Do second half of window
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 2), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                    TOTMat3(Z, Y) = TotMat(Z, Y)
                     TOTMat3(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            
            
            ReDim ColTotals(ToNumSeqs)
            
            ReDim TreeArray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 2, TORndNum, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
            
            
            
            LTree = LTree + 1
            'ssstr = ""
            'For Z = 0 To LTree
            '    ssstrr = ssstrr + Chr(SHolder(Z))
            'Next Z
            
            ReDim TempNodeOrder(MaxCurPos)
            ReDim NodeLen(MaxCurPos)
             ReDim NodeOrder(MaxCurPos)
            ReDim DoneNode(MaxCurPos)
            ReDim RootNode(MaxCurPos, MaxCurPos)
            
            ReDim NumDone(MaxCurPos)
            'Make a matrix of distances within the tree
            TreeToArray NameLen, ToNumSeqs, LTree, SHolder(0), Tmat3(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
            
            For Z = 0 To 3
                For Y = Z + 1 To 3
                    Tmat3(Y, Z) = Tmat3(Y, Z)
                Next Y
            Next
            
            'Dim SSHold() As doubkl
            'ReDim SSHold(3)
            'Calculate SS
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    If TotMat2(Z, Y) > 0 Then
                        SSScore(0, CPos) = SSScore(0, CPos) + (((TotMat2(Z, Y) - TMat2(Z, Y)) ^ 2) / (TotMat2(Z, Y) ^ TOPower)) '* 2
                        SSScore(3, CPos) = SSScore(3, CPos) + (((TotMat2(Z, Y) - Tmat3(Z, Y)) ^ 2) / (TotMat2(Z, Y) ^ TOPower)) '* 2
                    End If
                    If TOTMat3(Z, Y) > 0 Then
                        SSScore(2, CPos) = SSScore(2, CPos) + (((TOTMat3(Z, Y) - Tmat3(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                        SSScore(1, CPos) = SSScore(1, CPos) + (((TOTMat3(Z, Y) - TMat2(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                    End If
                Next Y
            Next Z
            SSScore(0, CPos) = SSScore(0, CPos) * 2
            SSScore(1, CPos) = SSScore(1, CPos) * 2
            SSScore(2, CPos) = SSScore(2, CPos) * 2
            SSScore(3, CPos) = SSScore(3, CPos) * 2
            'SSScore(0, CPos) = Val(Mid$(GetStringA, Pos + 21, 7))
            
            'This is where the writing to file thing used to go.
            

            CPos = CPos + 1
            StartPos = StartPos + TOStepSize
        Loop

        '3.6 seconds per perm
        Form1.ProgressBar1.Value = 10 + (X / TOPerms) * 42
    Next 'X
    'Close #FF
    
    

    '0.2 seconds
   
   ' TOPower = 2
End Sub
Public Sub TopalRun2(MatAveragex As Double, CPos As Long)
    'This code will take a sequence (in TOSeq), split it into window
    'size chunks, calculate SS scores for chunks and return
    'an array containing the SS data
Dim TreeArray() As Double
    Dim OutString As String
    Dim NumDatasets As Long, C As Long, D As Long
    Dim NewAverage As Double, MultFactorx As Double
    Dim StartPos As Long, X As Long, Y As Long, Z As Long, A As Long, B As Long
    Dim BootName As String
    Dim GetString As String
    Dim GetStringA As String
    Dim GetStringB As String
    Dim GetStringC As String
    Dim GetStringD As String
    Dim GetStringE As String
    Dim GetStringF As String
    Dim Boots() As String
    Dim MatrixByte() As Byte
    Dim Pos As Long
    Dim MatrixLen As Long, SeqNumber As Long
    Dim Len1 As Long
    Dim LastPos As Long
    Dim ReadposA As Long
    Dim LenString As Long
     Dim LTree As Long, StartT As Long, NumWins As Long
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
     Dim NumDone() As Double
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(TOWinLen)
    ReDim Prod2(TOWinLen)
    ReDim Prod3(TOWinLen)
    ReDim Alias(TOWinLen)
    ReDim Ally(TOWinLen)
    ReDim Location(TOWinLen)
    ReDim Px(ToNumSeqs, TOWinLen)
    ReDim TTempSeq2(TOWinLen, ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim Num(1)
    ReDim WeightMod(0, Int(TOWinLen / 2))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Int(TOWinLen / 2))
     SeqLen = Len(StrainSeq(0))

    ReDim Boots(ToNumSeqs + 1)
    Form1.SSPanel1.Caption = "Partitioning Sequences"
    StartPos = 1
    CPos = 0
   
    Form1.ProgressBar1.Value = 20
    '0.05 seconds
    NumDatasets = (CPos) * 2
    'Now can sort out the optfiles

    

    Form1.SSPanel1.Caption = "Calculating Distances"

    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 40
    StartPos = 1
    CPos = 0
    StartPos = 0
     Dim TempSeq2() As Integer
    ReDim TempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    Dim TS As String
    FF = FreeFile
    NumDatasets = 0
    Dim TotMat2() As Double, TOTMat3() As Double
    ReDim TotMat2(ToNumSeqs, ToNumSeqs)
    ReDim TOTMat3(ToNumSeqs, ToNumSeqs)
    Open "infile" For Output As #FF
        Do While StartPos + TOWinLen < SeqLen
            
            'Do the first half of the window.
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos, 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            'TOTMat(0, 1) = TOTMat(0, 1)
            'TOTMat(0, 2) = TOTMat(0, 2) '
            'TOTMat(0, 3) = TOTMat(0, 3)
            Call AverageMatrix(ToNumSeqs, NewAverage)
            
            'If TOSeq(0) = TOSeq(3) Then
            '    X = X
            'End If
            
            'For Z = 0 To TOWinLen / 2
            '    'TempSeq2(Z, 0) = TempSeq2(Z, 0)
            '    'TempSeq2(Z, 1) = TempSeq2(Z, 1)
            '    'TempSeq2(Z, 2) = TempSeq2(Z, 2)
            '    'TempSeq2(Z, 3) = TempSeq2(Z, 3)
            '    If TempSeq2(Z, 3) <> TempSeq2(Z, 0) Then
            '        X = X
            '    End If
            'Next Z
            
            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            
            ReDim TotMat2(ToNumSeqs, ToNumSeqs)
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    'If TOTMat(Z, Y) = 0 Then TOTMat(Z, Y) = 0.00005
                    TotMat2(Z, Y) = TotMat(Z, Y)
                    TotMat2(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            
            Pos = 0
            
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            ReDim ColTotals(ToNumSeqs)
            'Do NJ tree
            
            ReDim TreeArray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 0, TORndNum, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
            LTree = LTree + 1
             
            Dim Tmat3() As Double
             
            MaxCurPos = ToNumSeqs * 3
            NameLen = Len(Trim$(CStr(ToNumSeqs + 1)))
            If NameLen = 1 Then NameLen = 2
           
            ReDim TMat2(ToNumSeqs, ToNumSeqs), Tmat3(ToNumSeqs, ToNumSeqs)
            ReDim TempNodeOrder(MaxCurPos)
            ReDim NodeLen(MaxCurPos)
             ReDim NodeOrder(MaxCurPos)
            ReDim DoneNode(MaxCurPos)
            ReDim RootNode(MaxCurPos, MaxCurPos)
           
           
            ReDim NumDone(MaxCurPos)
            'Make a matrix of distances within the tree
            TreeToArray NameLen, ToNumSeqs, LTree, SHolder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
            
            For Z = 0 To 3
                For Y = Z + 1 To 3
                    TotMat2(Z, Y) = TotMat2(Z, Y)
                    TMat2(Y, Z) = TMat2(Y, Z)
                    
                Next Y
            Next
            
            'Do second half of window
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 2), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    'If TOTMat(Z, Y) = 0 Then TOTMat(Z, Y) = 0.00005
                    TOTMat3(Z, Y) = TotMat(Z, Y)
                     TOTMat3(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            
            
            ReDim ColTotals(ToNumSeqs)
            
            ReDim TreeArray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 0, TORndNum, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), TreeArray(0, 0))
            
            LTree = LTree + 1
            'ssstr = ""
            'For Z = 0 To LTree
            '    ssstrr = ssstrr + Chr(SHolder(Z))
            'Next Z
            
            ReDim TempNodeOrder(MaxCurPos)
            ReDim NodeLen(MaxCurPos)
             ReDim NodeOrder(MaxCurPos)
            ReDim DoneNode(MaxCurPos)
            ReDim RootNode(MaxCurPos, MaxCurPos)
            
            ReDim NumDone(MaxCurPos)
            'Make a matrix of distances within the tree
            TreeToArray NameLen, ToNumSeqs, LTree, SHolder(0), Tmat3(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
            
            
            'TOTMat2(0, 1) = 0.1
            'TOTMat2(0, 2) = 0.064
            'TOTMat2(0, 3) = 0.065
            'TOTMat2(1, 2) = 0.065
            'TOTMat2(1, 3) = 0.066
            'TOTMat2(2, 3) = 0.065
            
            'TMat2(0, 1) = 0.08813
            'TMat2(0, 2) = 0.07159
            'TMat2(0, 3) = 0.065
            'TMat2(1, 2) = 0.065
            'TMat2(1, 3) = 0.07383
            'TMat2(2, 3) = 0.05729

            'Dim SSHold() As doubkl
            'ReDim SSHold(3)
            'Calculate SS
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    'If TOTMat2(Z, Y) > 0 Then
                    '    SSScore(0, CPos) = SSScore(0, CPos) + (((TOTMat2(Z, Y) - TMat2(Z, Y)) ^ 2) / (TOTMat2(Z, Y) ^ TOPower)) '* 2
                    '    SSScore(3, CPos) = SSScore(3, CPos) + (((TOTMat2(Z, Y) - TMat3(Z, Y)) ^ 2) / (TOTMat2(Z, Y) ^ TOPower)) '* 2
                    'End If
                    'If TOTMat3(Z, Y) > 0 Then
                    '    SSScore(2, CPos) = SSScore(2, CPos) + (((TOTMat3(Z, Y) - TMat3(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                    '    SSScore(1, CPos) = SSScore(1, CPos) + (((TOTMat3(Z, Y) - TMat2(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                    'End If
                    If TotMat2(Z, Y) > 0 Then
                        SSScore(0, CPos) = SSScore(0, CPos) + (((TotMat2(Z, Y) - TMat2(Z, Y)) ^ 2) / (TotMat2(Z, Y) ^ TOPower)) '* 2
                        SSScore(3, CPos) = SSScore(3, CPos) + (((TotMat2(Z, Y) - Tmat3(Z, Y)) ^ 2) / (TotMat2(Z, Y) ^ TOPower)) '* 2
                    End If
                    If TOTMat3(Z, Y) > 0 Then
                        SSScore(2, CPos) = SSScore(2, CPos) + (((TOTMat3(Z, Y) - Tmat3(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                        SSScore(1, CPos) = SSScore(1, CPos) + (((TOTMat3(Z, Y) - TMat2(Z, Y)) ^ 2) / (TOTMat3(Z, Y) ^ TOPower)) '* 2
                    End If
                Next Y
            Next Z
            SSScore(0, CPos) = SSScore(0, CPos) * 2
            SSScore(1, CPos) = SSScore(1, CPos) * 2
            SSScore(2, CPos) = SSScore(2, CPos) * 2
            SSScore(3, CPos) = SSScore(3, CPos) * 2
            
            'This is where the writing to file thing used to go.
            

            CPos = CPos + 1
            StartPos = StartPos + TOStepSize
        Loop

    

    Close #FF
    StartPos = 1
    Form1.ProgressBar1.Value = 44
    '3.7 seconds
    CPos = (CPos - 1) * 2
    Form1.SSPanel1.Caption = "Calculating SS Scores"
    BB = GetTickCount

    Form1.ProgressBar1.Value = 78
    '4.9 seconds (NJ)
    '2.4 seconds (LS)
    

    

    
    'SSScore(3, 15) = X
End Sub

Public Sub TXover()
    SS = GetTickCount
    Dim PosCount As Long, CurrentPos As Long, X As Long, Y As Long
    Dim Z As Long, B As Long, A As Long, OWinLen As Long, OStepSize As Long, MoveOver As Long
    Dim AF As Double, CF As Double, GF As Double, TF As Double, SumFirstDiff As Double, MeanFirstDiff As Double
    Dim ODir As String, BootName As String, Header As String, GetStringA As String, GetStringB As String
    Dim Boots() As String
    Dim SumVal As Double
    Dim DSS() As Double
    Dim FirstDiff() As Double
    Dim PlotPos As Long
    Dim Pict As Long
    Dim XFactor As Double, YScaleFactor As Double, PicHeight As Double
    Dim PntAPI As POINTAPI
    Dim LSeqs As Long
    Dim LTree As Long, StartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    Dim PTOMat() As Double
'TOPower = 0
    LSeqs = Len(StrainSeq(0))
    Screen.MousePointer = 11
    Form1.Picture8.Enabled = False
    'Form1.SSPanel8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6.Enabled = False
    Form1.Command25.Enabled = True
    Form1.Picture7.Enabled = False
    TOPFlag = 0

    Dim TOSSFlag As Integer

    TOSSFlag = 0

    Dim TOXOSeq() As String

    ReDim TOXOSeq(NextNo)
    
    
    Dim TOXDiffPos() As Long, TOXPosDiff() As Long
    
    
    'Set up copies of sequences
    ReDim TOXDiffPos(LSeqs + 200)
    ReDim TOXPosDiff(LSeqs + 200)

    If TManFlag = 8 Then 'if it is a manual scan
        ReDim RevSeq(NextNo + 1)
        ReDim TOSeq(NextNo)
        ToNumSeqs = 0

        For X = 0 To NextNo

            If Selected(X) = 1 Then
                TOSeq(ToNumSeqs) = StrainSeq(X)
                RevSeq(ToNumSeqs) = X
                ToNumSeqs = ToNumSeqs + 1
            End If

        Next 'X

        ToNumSeqs = ToNumSeqs - 1
        ToNumSeqs = ToNumSeqs
        
    Else ' If it is a checking scan
        Dim TSeq(2) As String ', X As Long
        For X = 1 To Len(StrainSeq(0))
            'If X > 2050 Then
            '    X = X
            'End If
            If SeqNum(X, Seq1) <> 46 And SeqNum(X, Seq2) <> 46 And SeqNum(X, Seq3) <> 46 Then
                TSeq(0) = TSeq(0) + Chr(SeqNum(X, Seq1) - 1)
                TSeq(1) = TSeq(1) + Chr(SeqNum(X, Seq2) - 1)
                TSeq(2) = TSeq(2) + Chr(SeqNum(X, Seq3) - 1)
            Else
                TSeq(0) = TSeq(0) + "-"
                TSeq(1) = TSeq(1) + "-"
                TSeq(2) = TSeq(2) + "-"
            End If
        Next X
        If Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3 Then
            ToNumSeqs = NextNo
            ReDim TOSeq(ToNumSeqs + 1)

            For X = 0 To ToNumSeqs
                TOSeq(X) = StrainSeq(X)
            Next 'X

        Else
            Form1.SSPanel1.Caption = "Constructing an Outlyer Sequence"
            ToNumSeqs = 3
            ReDim TOSeq(ToNumSeqs + 1)
            TOSeq(0) = TSeq(0)
            TOSeq(1) = TSeq(1)
            TOSeq(2) = TSeq(2)
            Count = 0
            Count2 = 0
            Y = 0

            For X = 1 To LSeqs
                TOXPosDiff(X) = Y

                If SeqNum(X, Seq1) = SeqNum(X, Seq2) And SeqNum(X, Seq1) = SeqNum(X, Seq3) Then
                    TOSeq(3) = TOSeq(3) + Mid$(StrainSeq(Seq1), X, 1)
                Else
                    OddOne = -1
                    GoodOne = -1

                    If SeqNum(X, Seq1) = 46 Or SeqNum(X, Seq2) = 46 Or SeqNum(X, Seq3) = 46 Then
                        TOSeq(3) = TOSeq(3) + "-"
                        Mid$(TOSeq(0), X, 1) = "-"
                        Mid$(TOSeq(1), X, 1) = "-"
                        Mid$(TOSeq(2), X, 1) = "-"
                    ElseIf SeqNum(X, Seq1) <> SeqNum(X, Seq2) And SeqNum(X, Seq1) <> SeqNum(X, Seq3) And SeqNum(X, Seq2) <> SeqNum(X, Seq3) Then
                        TOSeq(3) = TOSeq(3) + "-"
                        Mid$(TOSeq(0), X, 1) = "-"
                        Mid$(TOSeq(1), X, 1) = "-"
                        Mid$(TOSeq(2), X, 1) = "-"
                    Else
                        Y = Y + 1
                        TOXDiffPos(Y) = X
                        TOXPosDiff(X) = Y
                        Y = Y + 1
                        TOXDiffPos(Y) = X
                        TOXPosDiff(X) = Y

                        If SeqNum(X, Seq1) = SeqNum(X, Seq2) Then
                            Mid$(TOSeq(0), X, 1) = "C"
                            Mid$(TOSeq(1), X, 1) = "C"
                            Mid$(TOSeq(2), X, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(0) = TOXOSeq(0) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "CA"
                            TOXOSeq(2) = TOXOSeq(2) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        ElseIf SeqNum(X, Seq1) = SeqNum(X, Seq3) Then
                            Mid$(TOSeq(0), X, 1) = "C"
                            Mid$(TOSeq(2), X, 1) = "C"
                            Mid$(TOSeq(1), X, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(0) = TOXOSeq(0) + "CA"
                            TOXOSeq(2) = TOXOSeq(2) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        ElseIf SeqNum(X, Seq2) = SeqNum(X, Seq3) Then
                            Mid$(TOSeq(2), X, 1) = "C"
                            Mid$(TOSeq(1), X, 1) = "C"
                            Mid$(TOSeq(0), X, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(2) = TOXOSeq(2) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "CA"
                            TOXOSeq(0) = TOXOSeq(0) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        End If

                    End If

                End If

                If X / 100 = CLng(X / 100) Then Form1.ProgressBar1.Value = (X / LSeqs) * 100
            Next 'X

        End If

    End If


    ReDim TOTSeqNum(Len(TOSeq(0)), ToNumSeqs)
    Dim TSeqSpaces() As Integer
    ReDim TSeqSpaces(Len(TOSeq(0)), ToNumSeqs)
    
    For X = 0 To ToNumSeqs
        Dummy = CopyString(Len(TOSeq(0)), TOTSeqNum(0, X), TOSeq(X), TSeqSpaces(0, X))
    Next X
    
    For X = 0 To Len(TOSeq(0))
        If TOTSeqNum(X, 0) = 46 Or TOTSeqNum(X, 1) = 46 Or TOTSeqNum(X, 2) = 46 Then
            TOTSeqNum(X, 0) = 46
            TOTSeqNum(X, 1) = 46
            TOTSeqNum(X, 2) = 46
            TOTSeqNum(X, 3) = 46
        End If
    Next X
    If TOSSFlag = 1 Then
        OWinLen = TOWinLen
        OStepSize = TOStepSize
        TOWinLen = 100
        TOStepSize = 10
        TOSeq(0) = TOXOSeq(0)
        TOSeq(1) = TOXOSeq(1)
        TOSeq(2) = TOXOSeq(2)
        TOSeq(3) = TOXOSeq(3)
    End If
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(Len(TOSeq(0)))
    ReDim Prod2(Len(TOSeq(0)))
    ReDim Prod3(Len(TOSeq(0)))
    ReDim Alias(Len(TOSeq(0)))
    ReDim Ally(Len(TOSeq(0)))
    ReDim Location(Len(TOSeq(0)))
    ReDim Px(ToNumSeqs, Len(TOSeq(0)))
    ReDim TTempSeq2(Len(TOSeq(0)), ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim Num(1)
    ReDim WeightMod(0, Len(TOSeq(0)))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Len(TOSeq(0)))
    
    Form1.ProgressBar1.Value = 5
    Form1.SSPanel1.Caption = "Calculating Average Distance"
    
    ReDim LastMatrix(ToNumSeqs, ToNumSeqs)
    ReDim Boots(ToNumSeqs + 1)
    
    ODir = CurDir
    ChDir App.Path
    ChDrive App.Path
    'TOSeq(1) = X
    'Do Batch Files
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfiled"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
Close #1
    
    Open "neighbor1.bat" For Output As #1
    Print #1, "neighborrdp <optfilen1"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    
    Open "neighbor2.bat" For Output As #1
    Print #1, "neighborrdp <optfilen2"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch1.bat" For Output As #1
    Print #1, "fitch <optfilef1"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch2.bat" For Output As #1
    Print #1, "fitch <optfilef2"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch3.bat" For Output As #1
    Print #1, "fitch <optfilef3"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch4.bat" For Output As #1
    Print #1, "fitch <optfilef4"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    
    
    

    
    'Do Optionfiles
    
    'Neighbor option file - used during DSS calculations.
    Open "optfilen1" For Output As #1
    Print #1, "j"
    Print #1, TORndNum
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Neighbor2 option file - used for parametric bootstrap
    Open "optfilen2" For Output As #1
    Print #1, "j"
    Print #1, TORndNum
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch1 option file
    Open "optfilef1" For Output As #1
    Print #1, "g"
    Print #1, "j"
    Print #1, TORndNum
    Print #1, "1"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch2 option file - used fo SS genration with "user"
    'defined tree
    Open "optfilef2" For Output As #1
    Print #1, "u"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch3 option file - used for parametric Bootstrap (LS)
    Open "optfilef3" For Output As #1
    Print #1, "g"
    Print #1, "j"
    Print #1, TORndNum
    Print #1, "3"
    Print #1, "p"
    Print #1, TOPower
    'Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch4 option file - used with NJ generated tree.
    Open "optfilef4" For Output As #1
    Print #1, "u"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Clean up files
    On Error Resume Next
    Kill "outfile"
    Kill "outfilex"
    Kill "infile"
    Kill "dist.mat"
    Kill "distmatrix"
    Kill "simtree"
    Kill "infilebak"
    On Error GoTo 0
    Sleep (5)
    'STEP1 Work out average distances

    'MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), B, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
    DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Len(TOSeq(0)), TOTSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
    
    
    
    DoEvents
    
    If AbortFlag = 1 Then
        OldAbort = 1
        Form1.Command25.Enabled = False
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command6.Enabled = True
        On Error Resume Next
        Close #1
        Close #2
        On Error GoTo 0
        Exit Sub
    End If

    'Exit Sub

    'Call ReadDistMatrix(TONumSeqs, "outfilex")
    ReDim PTOMat(ToNumSeqs, ToNumSeqs)
    For A = 0 To ToNumSeqs
        For B = 0 To ToNumSeqs
            LastMatrix(A, B) = TotMat(A, B)
            PTOMat(A, B) = TotMat(A, B)
        Next 'B
    Next 'A

    Call AverageMatrix(ToNumSeqs, MatAverage)

    TAv = MatAverage
    'Name "outfilex" As "distmatrix"
    Sleep (5)
    ReDim SSScore(3, LSeqs)
    '2.5 seconds
    Form1.ProgressBar1 = 18
    'Get forward and backwards SSScores.

    Call TopalRun3(MatAverage, CurrentPos)

    If AbortFlag = 1 Then
        OldAbort = 1
        Form1.Command25.Enabled = False
        'ChDir (olddir$)
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        'Form1.SSPanel8.Enabled = True
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command6.Enabled = True
        On Error Resume Next
        Close #1
        Close #2
        On Error GoTo 0
        Exit Sub
    End If
    Dim TPo As Long
    Dim TSm As Long

    TSm = TOSmooth - 1
    
    '14 seconds
    'Calculate DSS and Firstdiff
    Form1.ProgressBar1.Value = 100
    ReDim FirstDiff(CurrentPos)
    ReDim DSS(TOPerms, CurrentPos * 3)

    For X = 0 To CurrentPos - 1

        If Abs(SSScore(0, X) - SSScore(1, X)) > Abs(SSScore(2, X) - SSScore(3, X)) Then
            DSS(0, X) = Abs(SSScore(0, X) - SSScore(1, X))
        Else
            DSS(0, X) = Abs(SSScore(2, X) - SSScore(3, X))
        End If

        If X > 0 Then
            FirstDiff(X - 1) = DSS(0, X - 1) - DSS(0, X)
            SumFirstDiff = SumFirstDiff + FirstDiff(X - 1)
        End If

    Next 'X

    MeanFirstDiff = SumFirstDiff / (CurrentPos - 1)
    SumFirstDiff = 0

    For X = 0 To PosCount - 1
        SumFirstDiff = SumFirstDiff + (FirstDiff(X) - MeanFirstDiff) * (FirstDiff(X) - MeanFirstDiff)
    Next 'X

    VarFirstDiff = SumFirstDiff / (PosCount - 2)

    For X = 0 To CurrentPos - 1
        SumFirstDiff = SumFirstDiff + (FirstDiff(X) - MeanFirstDiff) * (FirstDiff(X) - MeanFirstDiff)
    Next 'X

    VarFirstDiff = SumFirstDiff / (CurrentPos - 2)
    'Look at "choosebig" to see the calculation of lower and upperbound
    '95% and 99% CIsI may need to write these to a file
    ' 95%CI = 1.96*(sqrt(varfirstdiff))
    ' 95%CI = 2.58*(sqrt(varfirstdiff))
    'Parametric bootstrapping bit
    '4.8 seconds
    TOEndPlot = CurrentPos / 2

    If TOPerms > 0 Then 'make simtree
        Form1.ProgressBar1.Value = 2
        Form1.SSPanel1.Caption = "Drawing LS Tree"
        'Draw the plot to show that something is happening

        If Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3 Then
        Else
            Form1.Picture7.Top = 0
            Form1.Picture7.ScaleMode = 3
            Form1.Picture10.BackColor = BackColours
            Form1.Picture7.BackColor = BackColours
            Form1.Picture10.ScaleMode = 3
            YScaleFactor = 0.85
            PicHeight = Form1.Picture7.Height * YScaleFactor
            XFactor = ((Form1.Picture7.Width - 40) / LSeqs)
            ReDim HighestDSS(TOPerms)

            For Y = 0 To CurrentPos
                'For X = 0 To TOPerms

                If DSS(0, Y) >= HighestDSS(0) Then
                    HighestDSS(0) = DSS(0, Y)
                End If

                'Next 'X
            Next 'Y

            TOHigh = HighestDSS(0)
            Form1.Picture10.BackColor = BackColours
            Form1.Picture7.BackColor = BackColours
            Form1.Picture10.ScaleMode = 3
            Form1.Picture7.ScaleMode = 3
            If ManFlag = -1 And TManFlag = -1 Then
            
                Call DoAxes(Len(StrainSeq(0)), -1, TOHigh, 0, 1, "DSS")
            Else
                Call DoAxes(Len(StrainSeq(0)), -1, TOHigh, 0, 0, "DSS")
            End If

            Form1.Picture7.Enabled = False
            PlotPos = Int((TOWinLen + TOStepSize * TSm) / 2)
            Form1.Picture7.DrawWidth = 3
            Form1.Picture7.ForeColor = RGB(180, 180, 180)
            Pict = Form1.Picture7.hdc
            
            SumVal = 0

            For Z = 0 To TSm
                SumVal = SumVal + DSS(0, Z)
            Next 'Z
            ReDim SmoothDSS(0, TOEndPlot * 2)
            SmoothDSS(0, 0) = SumVal / TOSmooth
            'Exit Sub
            For X = 1 To TOEndPlot 'CurrentPos - (TOSmooth - 1)
                SumVal = SumVal - DSS(0, X - 1) + DSS(0, X + TOSmooth - 1)
                SmoothDSS(0, X) = SumVal / TOSmooth
            Next 'X
            
            If TOSSFlag = 0 Then
                Dummy = MoveToEx(Pict, 30 + (PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                'Exit Sub
                PlotPos = PlotPos + TOStepSize

                For X = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + PlotPos * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                Next 'X

            Else
                Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize
                X = 1

                For X = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                Next 'X

            End If

            Dim EXCurrentPos As Long

            EXCurrentPos = CurrentPos
            Form1.Picture7.DrawWidth = 1
            Form1.Picture7.ForeColor = RGB(0, 0, 0)
            'Exit Sub
            Pict = Form1.Picture7.hdc
            PlotPos = Int((TOWinLen + TOStepSize * TSm) / 2)
            Form1.Picture7.ForeColor = RGB(0, 0, 0)

            If TOSSFlag = 0 Then
                Dummy = MoveToEx(Pict, 30 + (PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize

                For X = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + PlotPos * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                Next 'X

            Else
                Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize

                For X = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                Next 'X

            End If

            If ManFlag = -1 And RunFlag >= 1 Then

                Call Highlight

            End If

            Form1.Picture7.Refresh
        End If

        On Error Resume Next
        Kill "infile"
        On Error GoTo 0
        
        Open "infile" For Output As #1
    Pos = 0
            Dim TS As String
            Print #1, "  " & CStr(ToNumSeqs + 1)

            For X = 0 To ToNumSeqs
                OutString = "S0" & Trim$(CStr(X)) & String$(9 - Len(Trim$(CStr(X))), " ")

                For Y = 0 To ToNumSeqs
                    
                    If PTOMat(X, Y) = 0 Then
                        OutString = OutString & "  0.00000"
                    ElseIf PTOMat(X, Y) = 1 Then
                        OutString = OutString & "  1.00000"
                    ElseIf PTOMat(X, Y) >= 10 Then
                        TS = left(Trim$(CStr(PTOMat(X, Y))), 7)
                        OutString = OutString & " " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    ElseIf PTOMat(X, Y) > 1 Then
                        TS = left(Trim$(CStr(PTOMat(X, Y))), 7)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    Else
                        TS = PTOMat(X, Y) * 10000
                        
                        
                        TS = CLng(PTOMat(X, Y) * 100000)
                        If Len(TS) <= 5 Then
                            TS = "0." & String(5 - Len(TS), "0") & TS
                        End If
                        'TS = "0." & String(5 - Len(TS), "0") & TS
                        TS = left(Trim$(TS), 7)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    End If
                Next 'Y
                Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Do While Pos > 0
                    Mid(OutString, Pos, 1) = "."
                    Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Loop
               
                Print #1, OutString
            Next 'x

        Close #1
        
        If TOTreeType = 1 Or ToNumSeqs = 2 Then
            ShellAndClose "neighbor2.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6.Enabled = True
                On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                Exit Sub
            End If
            On Error Resume Next
            Kill "intree"
            On Error GoTo 0
            Name "treefile" As "intree"
            
        
    
            ShellAndClose "fitch4.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6.Enabled = True
                On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                Exit Sub
            End If
            Name "outtree" As "simtree"
        Else
            On Error Resume Next
            Kill "outfile"
            Kill "outtree"
            On Error GoTo 0
            ShellAndClose "fitch3.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6.Enabled = True
                On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                Exit Sub
            End If
            Name "outtree" As "simtree"
        End If

        On Error Resume Next
        Kill "distmatrix"
        On Error GoTo 0
        Name "infile" As "distmatrix"
        
        Sleep (5)
        TOPFlag = 1
        SS = GetTickCount
        Call TopalRunPerms3(MatAverage, CurrentPos)
        EE = GetTickCount
        TT = EE - SS '37
        '68 seconds

        If AbortFlag = 1 Then
            OldAbort = 1
            Form1.Command25.Enabled = False
            'ChDir (olddir$)
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            'Form1.SSPanel8.Enabled = True
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6.Enabled = True
            On Error Resume Next
            Close #1
            Close #2
            On Error GoTo 0
            Exit Sub
        End If

        Form1.ProgressBar1.Value = 100
        X = 1
        Y = 0
        ttCPos = CurrentPos
        CurrentPos = TOEndPlot 'CLng((CurrentPos / 2)) ' / TOPerms)

        Do

            If Abs(SSScore(0, MoveOver + Y) - SSScore(1, MoveOver + Y)) > Abs(SSScore(2, MoveOver + Y) - SSScore(3, MoveOver + Y)) Then
                DSS(X, Y) = Abs(SSScore(0, MoveOver + Y) - SSScore(1, MoveOver + Y))
            Else
                DSS(X, Y) = Abs(SSScore(2, MoveOver + Y) - SSScore(3, MoveOver + Y))
                'GoTo FinishAndCleanUp
            End If

            Y = Y + 1

            If Y >= CurrentPos Or Y > UBound(DSS, 2) Or Y + MoveOver > UBound(SSScore, 2) Then
                MoveOver = MoveOver + Y
                Y = 0
                X = X + 1
                'MoveOver = (X - 1) * CurrentPos

                If X > TOPerms Or Y + MoveOver > UBound(SSScore, 2) Then Exit Do
            End If

        Loop

    Else
        CurrentPos = CLng(CurrentPos / 2)
    End If

    If EXCurrentPos > 0 Then EXCurrentPos = CLng(EXCurrentPos / 2)

    If EXCurrentPos < CurrentPos Then
        ReDim SmoothDSS(TOPerms, TOEndPlot * 2)
    Else
        ReDim SmoothDSS(TOPerms, TOEndPlot * 2)
    End If

    ReDim HighestDSS(TOPerms)
    'Smooth DSS values

    Dim TCurrentPos As Long
    

    TPo = TOEndPlot - (TOSmooth - 1)

    
    'If TOSmooth > 1 Then

    For Y = 0 To TOPerms

        If Y = 0 And EXCurrentPos > 0 Then
            TCurrentPos = CurrentPos
            CurrentPos = EXCurrentPos
        End If

        SumVal = 0

        For Z = 0 To TSm
            SumVal = SumVal + DSS(Y, Z)
        Next 'Z

        SmoothDSS(Y, 0) = SumVal / TOSmooth

        For X = 1 To TOEndPlot 'CurrentPos - (TOSmooth - 1)
            SumVal = SumVal - DSS(Y, X - 1) + DSS(Y, X + TOSmooth - 1)
            SmoothDSS(Y, X) = SumVal / TOSmooth
        Next 'X

        If TCurrentPos > 0 Then CurrentPos = TCurrentPos
    Next 'Y

    'End If
    'For X = 0 To CurrentPos
    '    If SmoothDSS(0, X) <> DSS(0, X) Then
    '
    '    End If
    'Next 'X
    ReDim HighestDSS(TOPerms)

    For X = 0 To TOPerms

        If X = 0 And EXCurrentPos > 0 Then
            TCurrentPos = CurrentPos
            CurrentPos = EXCurrentPos
        End If

        For Y = 0 To TPo 'CurrentPos - (TOSmooth - 1)

            If SmoothDSS(X, Y) >= HighestDSS(X) Then
                HighestDSS(X) = SmoothDSS(X, Y)
            End If

        Next 'Y

        If TCurrentPos > 0 Then CurrentPos = TCurrentPos
    Next 'X

    TOHigh = HighestDSS(0)

    For X = 1 To TOPerms

        If HighestDSS(X) > TOHigh Then TOHigh = HighestDSS(X)
    Next 'X

    '(2)for every permutation take dss values and calculate
    'moving average along the sequence (with a set window length)
    'write highest average to an array(x).
    '(3) sort the set of highest values from lowest to highest.
    '(4)from actual dataset .dss values smooth the values (moving
    'average etc etc.)
    '(5) significance = proportion of simulated .dss values that are
    'higher than the calculated values. eg-pvalue cutoff =0.5 then the
    '0.05 dss cutoff = the 5th percentile of simulated .dss values
    ChDir ODir
    ChDrive ODir

    If TOHigh = 0 Then
        GoTo FinishAndCleanUp:
    End If

    Form1.ProgressBar1.Value = 100

    If (Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3) And ManFlag = -1 And TManFlag <> 8 Then
    Else
        Form1.Picture7.Top = 0
        Form1.Picture7.ScaleMode = 3
        Form1.Picture10.BackColor = BackColours
        Form1.Picture7.BackColor = BackColours
        Form1.Picture10.ScaleMode = 3
        XFactor = ((Form1.Picture7.Width - 40) / LSeqs)
        YScaleFactor = 0.85
        PicHeight = Form1.Picture7.Height * YScaleFactor

        If ManFlag = -1 And TManFlag = -1 Then
            
                Call DoAxes(Len(StrainSeq(0)), -1, TOHigh, 0, 1, "DSS")
            Else
                Call DoAxes(Len(StrainSeq(0)), -1, TOHigh, 0, 0, "DSS")
            End If

        If EXCurrentPos > 0 Then CurrentPos = EXCurrentPos
        Form1.Picture7.DrawWidth = 3
        Form1.Picture7.ForeColor = RGB(180, 180, 180)
        Pict = Form1.Picture7.hdc
        PlotPos = Int((TOWinLen + TOStepSize * TSm) / 2)
        If TOSSFlag = 0 Then
            Dummy = MoveToEx(Pict, (30 + PlotPos * XFactor), PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
            'Exit Sub
            PlotPos = PlotPos + TOStepSize
            Form1.Picture7.AutoRedraw = True

            For X = 1 To TPo
                Dummy = LineTo(Pict, 30 + PlotPos * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
                PlotPos = PlotPos + TOStepSize
            Next 'X

        Else
            Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
            PlotPos = PlotPos + TOStepSize

            For X = 1 To TPo
                Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
                PlotPos = PlotPos + TOStepSize
            Next 'X

        End If

        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.ForeColor = RGB(0, 0, 0)

        If TCurrentPos > 0 And TCurrentPos >= CurrentPos * 2 Then
            CurrentPos = TCurrentPos / 2
        ElseIf TCurrentPos > 0 Then
            CurrentPos = TCurrentPos
        End If

        Form1.Picture7.ForeColor = QuaterColour

        Dim PFactor As Double

        If LSeqs < 32000 Then
            PFactor = XFactor
        Else
            PFactor = ((Form1.Picture7.Width - 40) / 32000)
        End If

        For Y = 1 To TOPerms
            PlotPos = Int((TOWinLen + TOStepSize * TSm) / 2)
            

            If TOSSFlag = 0 Then
                'Form1.Picture7.ForeColor = QBColor(4)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + PlotPos * PFactor, PicHeight - (15 + (SmoothDSS(Y, 0) / TOHigh) * (PicHeight - 35)), PntAPI)

                For X = 1 To TPo
                    PlotPos = PlotPos + TOStepSize
                    Dummy = LineTo(Pict, 30 + PlotPos * PFactor, PicHeight - (15 + (SmoothDSS(Y, X) / TOHigh) * (PicHeight - 35)))
                Next 'X

            Else
                Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * PFactor, PicHeight - (15 + (SmoothDSS(Y, 0) / TOHigh) * (PicHeight - 35)), PntAPI)

                For X = 1 To TPo
                    PlotPos = PlotPos + TOStepSize
                    Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * PFactor, PicHeight - (15 + (SmoothDSS(Y, X) / TOHigh) * (PicHeight - 35)))
                Next

            End If

        Next

        PlotPos = Int((TOWinLen + TOStepSize * TSm) / 2)

        If EXCurrentPos > 0 Then CurrentPos = TCurrentPos
        Form1.Picture7.ForeColor = RGB(0, 0, 0)

        If TOSSFlag = 0 Then
            Dummy = MoveToEx(Pict, 30 + PlotPos * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
            PlotPos = PlotPos + TOStepSize

            For X = 1 To TPo
                Dummy = LineTo(Pict, 30 + PlotPos * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
                PlotPos = PlotPos + TOStepSize
            Next

        Else
            Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
            PlotPos = PlotPos + TOStepSize

            For X = 1 To TPo
                Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
                PlotPos = PlotPos + TOStepSize
            Next

        End If

        'Next 'X

        If ManFlag = -1 And RunFlag >= 1 Then

            Call Highlight

        End If

        Form1.Picture7.Refresh
    End If

EE = GetTickCount
TT = EE - SS
'46.6 -50 reps, kom, ns ,reu ,tas
'13.532
    'If TOEndPlot <= 2 Then TOEndPlot = PlotPos - TOStepSize
FinishAndCleanUp:
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.Combo1.Enabled = True
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6.Enabled = True
    Form1.Command25.Enabled = False
    Form1.Picture7.Enabled = True
    Form1.Command29.Enabled = True
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.left, Form1.Picture7.Top + 5

    If TOSSFlag = 1 Then
        TOWinLen = OWinLen
        TOStepSize = OStepSize
    End If

End Sub
Public Function DoTime(TimeS As Variant) As String

    Dim StringT As String, HourR As Long, MinR As Long, SecR As Double

    TimeS = TimeS / 1000
    If TimeS < 10 ^ 9 Then
        TimeS = CLng(TimeS)
    Else
        TimeS = 10 ^ 9
    End If
    If TimeS >= 3600 Then

        If TimeS / 3600 < 32000 Then
            HourR = Int(TimeS / 3600)
        Else
            HourR = TimeS / 3600 - 1
        End If

        If HourR < 10 Then StringT = "0"
        StringT = StringT + Trim$(CStr(HourR)) + "h:"
        thourr = HourR
    End If

    If TimeS >= 60 Then
        
        thourr = HourR
        tMinR = (TimeS - thourr * 3600) / 60
        MinR = CLng(tMinR - 0.5)
        If MinR < 10 And HourR > 0 Then StringT = StringT + "0"

        If MinR > 0 Then
            StringT = StringT + Trim$(CStr(MinR)) + "m:"
        Else
            StringT = StringT + "0m:"
        End If

    End If

    SecR = TimeS - (thourr * 3600) - (MinR * 60)

    If SecR < 10 And (MinR > 0 Or HourR > 0) Then
        StringT = StringT + "0"
    End If

    If SecR > 1 Then
        StringT = StringT + Trim$(CStr(SecR)) + "s"
    Else
        StringT = StringT + "0s"
    End If

    DoTime = StringT
End Function
Public Function DoTimeII(TimeS As Long) As String

    Dim StringT As String, HourR As Long, MinR As Long, SecR As Double, SecD As String

    SecD = Trim$(CStr(CInt((TimeS / 1000 - Int(TimeS / 1000)) * 100)))
    'SecD = CInt(SecD * 100)
    TimeS = CLng((TimeS / 1000) - 0.5)

    If TimeS >= 3600 Then

        If TimeS / 3600 < 32000 Then
            HourR = Int(TimeS / 3600)
        Else
            HourR = TimeS / 3600 - 1
        End If

        If HourR < 10 Then StringT = "0"
        StringT = StringT + Trim$(CStr(HourR)) + "h:"
    End If

    If TimeS >= 60 Then
        MinR = Int((TimeS - HourR * 3600) / 60)

        If MinR < 10 And HourR > 0 Then StringT = StringT + "0"

        If MinR > 0 Then
            StringT = StringT + Trim$(CStr(MinR)) + "m:"
        Else
            StringT = StringT + "0m:"
        End If

    End If

    SecR = TimeS - CLng(HourR * 3600) - CLng(MinR * 60)

    If SecR < 10 And (MinR > 0 Or HourR > 0) Then
        StringT = StringT + "0"
    End If

    If SecR >= 1 Then
        StringT = StringT + Trim$(CStr(SecR))
    Else
        StringT = StringT + "0"
    End If

    If MinR = 0 And HourR = 0 Then

        If Len(SecD) = 0 Then
            SecD = "00"
        ElseIf Len(SecD) = 1 Then
            SecD = SecD + "0"
        ElseIf Len(SecD) >= 3 Then
            SecD = "00"
        End If

        StringT = StringT + "." + SecD
    End If

    StringT = StringT + "s"
    DoTimeII = StringT
End Function
Public Sub TopalRun(MatAveragex As Double, CPos As Long)

Dim OutString As String
    Dim NumDatasets As Long, C As Long, D As Long
    Dim NewAverage As Double, MultFactorx As Double
    Dim StartPos As Long, X As Long, Y As Long, Z As Long, A As Long, B As Long
    Dim BootName As String
    Dim GetString As String
    Dim GetStringA As String
    Dim GetStringB As String
    Dim GetStringC As String
    Dim GetStringD As String
    Dim GetStringE As String
    Dim GetStringF As String
    Dim Boots() As String
    Dim MatrixByte() As Byte
    Dim Pos As Long
    Dim MatrixLen As Long, SeqNumber As Long
    Dim Len1 As Long
    Dim LastPos As Long
    Dim ReadposA As Long
    Dim LenString As Long
     Dim LTree As Long, StartT As Long, NumWins As Long
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, xx1() As Integer, xx2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Double, Num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqNum() As Integer
    Dim RootNode() As Long
    
    
    ReDim xx1(3)
    ReDim xx2(3)
    ReDim Prod1(TOWinLen)
    ReDim Prod2(TOWinLen)
    ReDim Prod3(TOWinLen)
    ReDim Alias(TOWinLen)
    ReDim Ally(TOWinLen)
    ReDim Location(TOWinLen)
    ReDim Px(ToNumSeqs, TOWinLen)
    ReDim TTempSeq2(TOWinLen, ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim Num(1)
    ReDim WeightMod(0, Int(TOWinLen / 2))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Int(TOWinLen / 2))
     SeqLen = Len(StrainSeq(0))

    ReDim Boots(ToNumSeqs + 1)
    
    StartPos = 1
    CPos = 0
   
    Form1.ProgressBar1.Value = 20

    'Now can sort out the optfiles

    

    Form1.SSPanel1.Caption = "Calculating Distances"

    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 40
    StartPos = 1
    CPos = 0
    StartPos = 0
     Dim TempSeq2() As Integer
    ReDim TempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    Dim TS As String
    FF = FreeFile
    NumDatasets = 0
    Open "infile" For Output As #FF
        Do While StartPos + TOWinLen < SeqLen
            
            'Do the first half of the window.
            
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            'For X = 0 To TOWinLen / 2
            '    TOTSeqNum(X, 0) = TOTSeqNum(X, 0)
            '    TOTSeqNum(X, 1) = TOTSeqNum(X, 1)
            '    TOTSeqNum(X, 2) = TOTSeqNum(X, 2)
            '    TOTSeqNum(X, 3) = TOTSeqNum(X, 3)
            '    TempSeq2(X, 0) = TempSeq2(X, 0)
            '    TempSeq2(X, 1) = TempSeq2(X, 1)
            '    TempSeq2(X, 2) = TempSeq2(X, 2)
            '    TempSeq2(X, 3) = TempSeq2(X, 3)
            'Next X
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)
            
            If NewAverage > 0 Then
                MultFactorx = MatAveragex / NewAverage

                Call MatrixMultiply(ToNumSeqs, MultFactorx)

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        LastMatrix(C, D) = TotMat(C, D)
                    Next 'd

                Next 'C

            Else
                MultFactorx = 1

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        TotMat(C, D) = LastMatrix(C, D)
                    Next 'd

                Next 'C

            End If
            
            Pos = 0
            Print #FF, ""
            Print #FF, "  " & CStr(ToNumSeqs + 1)
            For Z = 0 To ToNumSeqs
                OutString = "S" & Trim$(CStr(Z)) & String$(9 - Len(Trim$(CStr(Z))), " ")
        
                For Y = 0 To ToNumSeqs
                    If TotMat(Z, Y) = 0 Then
                        OutString = OutString & "  0.0000"
                    ElseIf TotMat(Z, Y) = 1 Then
                        OutString = OutString & "  1.0000"
                    ElseIf TotMat(Z, Y) >= 10 Then
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 6)
                        OutString = OutString & " " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    ElseIf TotMat(Z, Y) > 1 Then
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 5)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 6 Then
                            OutString = OutString & String$((6 - Len(TS)), "0")
                        End If
                    Else
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 5)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 6 Then
                            OutString = OutString & String$((6 - Len(TS)), "0")
                        End If
                    End If
                Next 'Y
                Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Do While Pos > 0
                    Mid(OutString, Pos, 1) = "."
                    Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Loop
                Print #FF, OutString
            Next 'z
            
            'Do second half of window
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 2) + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            For X = 0 To TOWinLen / 2
                TOTSeqNum(X + 100, 0) = TOTSeqNum(X + 100, 0)
                TempSeq2(X, 0) = TempSeq2(X, 0)
                TempSeq2(X, 1) = TempSeq2(X, 1)
                TempSeq2(X, 2) = TempSeq2(X, 2)
                TempSeq2(X, 3) = TempSeq2(X, 3)
            Next X
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage > 0 Then
                MultFactorx = MatAveragex / NewAverage

                Call MatrixMultiply(ToNumSeqs, MultFactorx)

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        LastMatrix(C, D) = TotMat(C, D)
                    Next 'd

                Next 'C

            Else
                MultFactorx = 1

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        TotMat(C, D) = LastMatrix(C, D)
                    Next 'd

                Next 'C

            End If
            
            Pos = 0
            Print #FF, ""
            Print #FF, "  " & CStr(ToNumSeqs + 1)
            For Z = 0 To ToNumSeqs
                OutString = "S" & Trim$(CStr(Z)) & String$(9 - Len(Trim$(CStr(Z))), " ")
        
                For Y = 0 To ToNumSeqs
                    If TotMat(Z, Y) = 0 Then
                        OutString = OutString & "  0.0000"
                    ElseIf TotMat(Z, Y) = 1 Then
                        OutString = OutString & "  1.0000"
                    ElseIf TotMat(Z, Y) >= 10 Then
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 6)
                        OutString = OutString & " " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    ElseIf TotMat(Z, Y) > 1 Then
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 5)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 6 Then
                            OutString = OutString & String$((6 - Len(TS)), "0")
                        End If
                    Else
                        TS = left(Trim$(CStr(TotMat(Z, Y))), 5)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 6 Then
                            OutString = OutString & String$((6 - Len(TS)), "0")
                        End If
                    End If
                Next 'Y
                Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Do While Pos > 0
                    Mid(OutString, Pos, 1) = "."
                    Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Loop
                Print #FF, OutString
            Next 'z

            CPos = CPos + 1
            StartPos = StartPos + TOStepSize
            NumDatasets = NumDatasets + 2
        Loop

    

    Close #FF
    StartPos = 1
    Form1.ProgressBar1.Value = 44
    '3.7 seconds
    CPos = 0
    Form1.SSPanel1.Caption = "Calculating SS Scores"
    BB = GetTickCount
    
    If TOPFlag = 0 Then
        
        'Fitch1 option file
        Open "optfilef1" For Output As #1
        Print #1, "g"
        Print #1, "j"
        Print #1, TORndNum
        Print #1, "1"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "2"
        Print #1, "3"
        Print #1, "y"
        Close #1
        'Fitch2 option file - used with NJ generated tree
        'and SS genration with "user" defined tree
        Open "optfilef2" For Output As #1
        Print #1, "u"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "2"
        Print #1, "3"
        Print #1, "y"
        Close #1
        Open "optfilen1" For Output As #1
        Print #1, "j"
        Print #1, TORndNum
        Print #1, "2"
        Print #1, "m"
        Print #1, NumDatasets
        'Print #1, "2"
        'Print #1, "3"
        Print #1, "3"
        Print #1, "y"
        Close #1
    End If
    
    If TOTreeType = 1 Or TOPFlag = 1 Then 'do NJ if it is either set or you're working with permutations.
       ' Do
        ShellAndClose "neighbor1.bat", 0
        
        'Loop
        If AbortFlag = 1 Then
            AbortFlag = 1
            Exit Sub
        End If

        Open "infile" For Binary Access Read As #1
        XX = LOF(1)
        If LOF(1) = 0 Then
        
            MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component NeighborRDP.")
            AbortFlag = 1
            Close #1
            Exit Sub
        End If

        GetStringA = String$(LOF(1), " ")
        Get #1, 1, GetStringA
        Close #1
        Name "infile" As "infilebak"
        Open "treefile" For Binary Access Read As #1

        If LOF(1) = 0 Then
            MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component NeighborRDP.")
            AbortFlag = 1
            Close #1
            Exit Sub
        End If

        GetStringB = String$(LOF(1), " ")
        Get #1, 1, GetStringB
        Close #1
        XX = Len(GetStringB)
        'Work out distance matrix spacing
        Pos = InStr(1, GetStringA, "S0", vbBinaryCompare)
        HeaderLen = Pos - 1
        LastPos = Pos
        Pos = InStr(LastPos + 1, GetStringA, "S0", vbBinaryCompare)
        Len1 = Pos - LastPos
        LenString = Len(GetStringA)
        Pos = 1
        LastPos = 1
        RndSeqFlag = 1
        Pos = 1
        LastPos = -2
        ReadposA = 1
        Open "infile" For Output As #1
        Open "intree" For Output As #2
        NumDatasets = 0
        Do While (ReadposA + Len1 * 2) - 1 <= LenString
        
            GetStringC = Mid$(GetStringA, ReadposA, Len1)
            ReadposA = ReadposA + Len1
            GetStringE = Mid$(GetStringA, ReadposA, Len1)
            ReadposA = ReadposA + Len1
            Pos = InStr(LastPos + 3, GetStringB, ";", vbBinaryCompare)

            If Pos > 0 Then
                GetStringF = Mid$(GetStringB, LastPos + 3, Pos - LastPos)
            Else
                Exit Do
            End If

            LastPos = Pos
            XX = CurDir
            Pos = InStr(LastPos + 3, GetStringB, ";", vbBinaryCompare)

            If Pos > 0 Then
                GetStringD = Mid$(GetStringB, LastPos + 3, Pos - LastPos)
            Else
                Exit Do
            End If

            LastPos = Pos
            Print #1, GetStringC
            'Print #1, "1"
            Print #2, GetStringF
            Print #1, GetStringE
            'Print #1, "1"
            Print #2, GetStringD
            NumDatasets = NumDatasets + 2
        Loop
        Close #2
        Close #1
        
        Open "optfilef2" For Output As #1
        Print #1, "u"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "3"
        Print #1, "2"
        Print #1, "y"
        Close #1
        
        On Error Resume Next
        Kill "outfile"
        Kill "outtree"
        On Error GoTo 0
        SS = GetTickCount
        
        ShellAndClose "fitch2.bat", 0
        EE = GetTickCount
        TT = EE - SS '782
        If AbortFlag = 1 Then
            Exit Sub
        End If

        Kill "infile"
        Name "infilebak" As "infile"
    Else
        On Error Resume Next
        Kill "outfile"
        Kill "outtree"
        On Error GoTo 0
        ShellAndClose "fitch1.bat", 0

        If AbortFlag = 1 Then
            Exit Sub
        End If

    End If

    Form1.ProgressBar1.Value = 78
    '4.9 seconds (NJ)
    '2.4 seconds (LS)
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If
    XX = LOF(1)
    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    'get ssscores
    ReDim SSScore(3, NumDatasets)
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            On Error Resume Next
            SSScore(0, CPos) = Val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(0, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            On Error Resume Next
            SSScore(2, CPos) = Val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(2, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop

    Form1.SSPanel1.Caption = "Recalculating SS Scores"
    Open "infile" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    Open "outtree" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringB = String$(LOF(1), " ")
    Get #1, 1, GetStringB
    Close #1
    'If rndseqflag = 1 Then
    '
    '
    '            Do
    '                Pos = InStr$(1, GetStringB, "S3:", vbBinaryCompare)
    '                If Pos > 0 Then
    '                    GetStringB = left$(GetStringB, Pos + 1) & right$(GetStringB, Len(GetStringB) - (Pos + 9))
    '
    '                    'Exit Sub
    '                    'LastPos = Pos + 1
    '                Else
    '
    '                    Exit Do
    '                End If
    '            Loop
    '    End If
    'Work out distance matrix spacing
    Pos = InStr(1, GetStringA, "S0", vbBinaryCompare)
    Form1.Refresh
    HeaderLen = Pos - 1
    LastPos = Pos
    Pos = InStr(LastPos + 1, GetStringA, "S0", vbBinaryCompare)
    Len1 = Pos - LastPos
    'GetStringC = string$(Len1, " ")
    'GetStringE = string$(Len1, " ")
    LenString = Len(GetStringA)
    Pos = 1
    LastPos = -2
    ReadposA = 1
    Open "infile" For Output As #1
    Open "intree" For Output As #2
    NumDatasets = 0
    Do While (ReadposA + Len1 * 2) - 1 <= LenString
        GetStringC = Mid$(GetStringA, ReadposA, Len1)
        ReadposA = ReadposA + Len1
        GetStringE = Mid$(GetStringA, ReadposA, Len1)
        ReadposA = ReadposA + Len1
        Pos = InStr(LastPos + 3, GetStringB, ";", vbBinaryCompare)

        If Pos > 0 Then
            GetStringF = Mid$(GetStringB, LastPos + 3, Pos - LastPos)
        Else
            Exit Do
        End If

        LastPos = Pos
        Pos = InStr(LastPos + 3, GetStringB, ";", vbBinaryCompare)

        If Pos > 0 Then
            GetStringD = Mid$(GetStringB, LastPos + 3, Pos - LastPos)
        Else
            Exit Do
        End If

        LastPos = Pos
        Print #1, GetStringE
        'Print #1, "1"
        Print #2, GetStringF
        Print #1, GetStringC
        'Print #1, "1"
        Print #2, GetStringD
        NumDatasets = NumDatasets + 2
    Loop
    Close #2
    Close #1
    On Error Resume Next
        Kill "outfile"
        Kill "outtree"
        On Error GoTo 0
        SS = GetTickCount
    ShellAndClose "fitch2.bat", 0
    EE = GetTickCount
    TT = EE - SS '0.844
    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 95
    '3 seconds
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component NeighborRDP.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    'get ssscores
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            On Error Resume Next
            SSScore(1, CPos) = Val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(1, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            On Error Resume Next
            SSScore(3, CPos) = Val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(3, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop

    CPos = NumDatasets
    'SSScore(3, 15) = X
End Sub


