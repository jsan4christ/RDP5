Attribute VB_Name = "Module4"
Public Sub TripletCheck()
Dim SeqnumV() As Byte, LSeq As Long
LSeq = Len(StrainSeq(0))

Dim NumCoverter()
ReDim NumCoverter(255)
NumCoverter(66) = 0
NumCoverter(68) = 1
NumCoverter(72) = 2
NumCoverter(85) = 3
NumCoverter(46) = 4

Dim SiteCount() As Long, Site As Byte
ReDim SiteCount(LSeq, 4)

ReDim SeqnumV(NextNo, LSeq + 20)

For Y = 0 To NextNo
    For x = 1 To LSeq
'        If SeqNum(X, Y) <> 68 And SeqNum(X, Y) <> 72 And SeqNum(X, Y) <> 66 And SeqNum(X, Y) <> 46 And SeqNum(X, Y) <> 85 Then
'            X = X
'        End If
        Site = NumCoverter(SeqNum(x, Y))
        SeqnumV(Y, x) = Site
        SiteCount(x, Site) = SiteCount(x, Site) + 1
    Next x
Next Y



'Make a sortArrray so that I can quickly sort sitecounts - want to have all the most common nts = 0, the next = 1 etc
'also need to remember where the gaps end up in the list and how many different nts there are at each site.



Dim Ordernts() As Byte, WinCount As Long, WinNT As Byte, SiteMap() As Byte, CycleX As Long
ReDim Ordernts(4), SiteMap(LSeq, 4)

For x = 1 To LSeq
    SiteMap(x, 4) = 4
    For CycleX = 0 To 3
        WinCount = 0
        For Y = 0 To 3
            If SiteCount(x, Y) >= WinCount Then
                WinCount = SiteCount(x, Y)
                WinNT = Y
            End If
        Next Y
        If SiteCount(x, WinNT) = 0 Then Exit For
        SiteMap(x, WinNT) = CycleX
        SiteCount(x, WinNT) = -SiteCount(x, WinNT)
    Next CycleX
Next x


For Y = 0 To NextNo
    For x = 1 To LSeq
        SeqnumV(Y, x) = SiteMap(x, SeqnumV(Y, x))
        If SeqnumV(Y, x) <> 0 Then
            x = x
        End If
    Next x
Next Y


For x = 0 To NextNo
    For Y = 1 To LSeq
        If SeqnumV(x, Y) = 0 Then
            Mid(StrainSeq(x), Y, 1) = "A"
        ElseIf SeqnumV(x, Y) = 1 Then
            Mid(StrainSeq(x), Y, 1) = "C"
        ElseIf SeqnumV(x, Y) = 2 Then
            Mid(StrainSeq(x), Y, 1) = "G"
        ElseIf SeqnumV(x, Y) = 3 Then
            Mid(StrainSeq(x), Y, 1) = "T"
        End If
        
    Next Y

Next x


Dim SitePattern(4, 4, 4, 4) ', 4, 4, 4, 4)
Dim PatternNumber(4, 4, 4, 4), PatternCount As Long
PatternCount = -1
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            For D = 0 To 4
                PatternCount = PatternCount + 1
                PatternNumber(A, b, C, D) = PatternCount
            Next D
        Next C
    Next b
Next A
            
Dim PatternMat() As Byte
ReDim PatternMat(PatternCount, PatternCount)


Dim CSeq() As Long, Pos As Long, PatternList() As Long, PCount As Long
ReDim CSeq((LSeq / 4) + 4, NextNo)
Pos = -1
For x = 1 To LSeq Step 4
    Pos = Pos + 1
    ReDim PatternList(NextNo)
    PCount = 0
    For Y = 0 To NextNo
        'SitePattern(SeqnumV(Y, X), SeqnumV(Y, X + 1), SeqnumV(Y, X + 2), SeqnumV(Y, X + 3), SeqnumV(Y, X + 4), SeqnumV(Y, X + 5), SeqnumV(Y, X + 6), SeqnumV(Y, X + 7)) = SitePattern(SeqnumV(Y, X), SeqnumV(Y, X + 1), SeqnumV(Y, X + 2), SeqnumV(Y, X + 3), SeqnumV(Y, X + 4), SeqnumV(Y, X + 5), SeqnumV(Y, X + 6), SeqnumV(Y, X + 7)) + 1
        SitePattern(SeqnumV(Y, x), SeqnumV(Y, x + 1), SeqnumV(Y, x + 2), SeqnumV(Y, x + 3)) = SitePattern(SeqnumV(Y, x), SeqnumV(Y, x + 1), SeqnumV(Y, x + 2), SeqnumV(Y, x + 3)) + 1
        CSeq(Pos, Y) = PatternNumber(SeqnumV(Y, x), SeqnumV(Y, x + 1), SeqnumV(Y, x + 2), SeqnumV(Y, x + 3))
        For Z = 0 To PCount - 1
            If CSeq(Pos, Y) = PatternList(Z) Then
                Exit For
            End If
        Next Z
        If Z >= PCount Then
            PatternList(PCount) = CSeq(Pos, Y)
            PCount = PCount + 1
        End If
        
    Next Y
    x = x
    For Y = 0 To PCount - 2
        For Z = Y + 1 To PCount - 1
            PatternMat(PatternList(Y), PatternList(Z)) = 1
            PatternMat(PatternList(Z), PatternList(Y)) = 1
        Next Z
    Next Y
Next x

Dim Numfull As Long
Dim NumEmpty As Long
Numfull = 0 '808
NumEmpty = 0

For x = 0 To PatternCount
    For Y = x + 1 To PatternCount
        If PatternMat(x, Y) = 1 Then
            Numfull = Numfull + 1 '40835
        Else
            NumEmpty = NumEmpty + 1 '154165
        End If
    Next Y
Next x

Numfull = 0 '808
NumEmpty = 0
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            For D = 0 To 4
'                For E = 0 To 4
'                    For F = 0 To 4
'                        For g = 0 To 4
'                            For H = 0 To 4
                                If SitePattern(A, b, C, D) > 0 Then ', E, F, g, H) > 0 Then ', E, F) > 0 Then
                                    Numfull = Numfull + 1 '6-2705 '4-459 '8 - 6326
                                Else
                                    NumEmpty = NumEmpty + 1 '6-12920, 4-166, 8 384299
                                End If
'                            Next H
'                        Next g
'                    Next F
'                Next E
            Next D
        Next C
    Next b
    
Next A
x = x




'01,10,02,20,03,30,04,40,12,21,13,31,14,41,23,32,24,42,34,43

'01234
'01243
'01324
'01342
'01432
'01423

'10234
'10243
'10324
'10342
'10432
'10423

'02134
'02314
'02341

'10234
'12034
'12304
'12340




'000,111,222,333,444 = 0
'001,002,003,110,112,113....332 = 1
'010,020,030,101,121....323 = 2
'011,022,033,100........322 = 3

'004,114,224,334 = 4
'040,141,242,343 = 5
'400,411,422,433 = 6
'012,013,102.......321 = 7
'014,024,034,104.....432 = 8



x = x




End Sub
Public Sub PhilippeMap()
Dim Reference As String, FF As Long, TestSeq As String, TestPos() As Long, RefPos() As Long, KMerLen As Long, Test As String, Pos As Long, CurPos As Long
Dim x As Long, Y As Long, Insertion As Long, Deletion As Long, MissMatch As Long, Match As Long, MapRefToTest() As Long, MapTestToRef() As Long
KMerLen = 8
FF = FreeFile
ChDir "C:\RDP Project\Philippe\Maculavirus"
Open "reference.txt" For Input As #FF
Line Input #FF, Reference
Line Input #FF, Reference

Close #FF


Open "Macluravirus_Diamond_19252.txt" For Input As #FF
Dim CurHit As Long, LastX As Long, Z As Long
Dim SizeIns() As Long
Dim SizeDel() As Long

ReDim SizeIns(Len(Reference))
ReDim SizeDel(Len(Reference))

Dim MatchPercent() As Single, MatchPercent2() As Single, InsPerNt() As Single, DelPerNt() As Single, TotalNts As Long
ReDim MatchPercent(1000), MatchPercent2(1000), InsPerNt(1000), DelPerNt(1000)

Dim SeqCount As Long
SeqCount = 0
Do While Not EOF(FF)

    ReDim RefPos(Len(Reference))
    Line Input #FF, TestSeq
    
    Line Input #FF, TestSeq
    If Left$(TestSeq, 1) <> "A" And Left$(TestSeq, 1) <> "C" And Left$(TestSeq, 1) <> "G" And Left$(TestSeq, 1) <> "T" Then
        x = x
        On Error Resume Next
        Line Input #FF, TestSeq
        On Error GoTo 0
        If TestSeq = "" Then Exit Do
        x = x
    End If
    
    SeqCount = SeqCount + 1
    If SeqCount > UBound(MatchPercent, 1) Then
        ReDim Preserve MatchPercent(SeqCount + 1000)
        ReDim Preserve MatchPercent2(SeqCount + 1000)
        ReDim Preserve InsPerNt(SeqCount + 1000)
        ReDim Preserve DelPerNt(SeqCount + 1000)
        
    End If
    TotalNts = TotalNts + Len(TestSeq)
    ReDim TestPos(Len(TestSeq))
    ReDim MapTestToRef(Len(TestSeq), 5)
    ReDim MapRefToTest(Len(Reference), 5)
    Insertion = 0: Deletion = 0: MissMatch = 0: Match = 0
    LastX = 0
    For x = 1 To Len(TestSeq) - KMerLen
'        If X = 70 Then
'            X = X
'        End If
        Test = Mid(TestSeq, x, KMerLen)
        CurPos = 1
        CurHit = 0
        Do
            If UBound(MapTestToRef, 2) > CurHit Then
                ReDim Preserve MapTestToRef(Len(TestSeq), CurHit + 5)
                ReDim Preserve MapRefToTest(Len(Reference), CurHit + 5)
            End If
            Pos = InStr(CurPos, Reference, Test, vbBinaryCompare)
            If Pos = 0 Then
                Exit Do
                
            Else
                For Y = Pos To Pos + KMerLen - 1
                    RefPos(Y) = RefPos(Y) + 1
                
                Next Y
                For Y = x To x + KMerLen - 1
                    TestPos(Y) = TestPos(Y) + 1
                Next Y
                For Y = 0 To KMerLen - 1
                   MapTestToRef(x + Y, CurHit) = Pos + Y
                   MapRefToTest(Pos + Y, CurHit) = x + Y
                Next Y
                
            End If
            CurPos = Pos + 1
            CurHit = CurHit + 1
        Loop
        x = x
    Next x
'    For X = 1 To Len(Reference)
'        If RefPos(X) > 0 Then
'            Match = Match + 1
'        Else
'            Deletion = Deletion + 1
'            For Y = X To Len(Reference)
'                If RefPos(X) > 0 Then
'                    X = Y - 1
'                    Exit For
'                End If
'            Next Y
'        End If
'    Next X
    For x = 1 To Len(TestSeq)
'        If X = 70 Then
'            X = X
'        End If
        If TestPos(x) = 0 Then
            If LastX > 0 Then
            
                'work out which of the sites in this "window" are mutations and which are deletion
                'get the previous offset
                For Y = x + 1 To Len(TestSeq)
                    If TestPos(Y) > 0 Then
                        Y = Y - 1
                        Exit For
                    End If
                Next Y
                If Y < Len(TestSeq) Then
                    Dim A As Long, b As Long, WinA As Long, WinB As Long, SDist As Long, TDist As Long, TRef As String, TTest As String
                    SDist = Len(Reference)
                    For A = 0 To UBound(MapRefToTest, 2)
                        If MapTestToRef(LastX, A) > 0 Then
                            For b = 0 To UBound(MapRefToTest, 2)
                                If MapTestToRef(Y + 1, b) > 0 Then
                                    TDist = Abs(MapTestToRef(LastX, A) - MapTestToRef(Y + 1, b))
                                    If TDist > 0 And TDist < SDist Then
                                        WinA = A
                                        WinB = b
                                        SDist = TDist
                                    End If
                                End If
                            Next b
                        End If
                    Next A
                    If (Y - LastX + 1) = (MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA)) Then
                        TRef = Mid$(Reference, MapTestToRef(LastX, WinA) + 1, Y - LastX + 1)
                        TTest = Mid$(TestSeq, LastX + 1, Y - LastX + 1)
                        x = x
                        'if they are the same length calculate the matches and mismatches between the ref and the test
                        For A = T To Len(TTest)
                            If Mid$(TTest, x, 1) = Mid$(TRef, x, 1) Then
                                Match = Match + 1
                            Else
                                MissMatch = MissMatch + 1
                            End If
                        Next A
                    Else
                        If (Abs(MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA))) > (Y - LastX + 1) Then
                            Deletion = Deletion + 1
                            SizeDel(Abs((MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA))) - (Y - LastX + 1)) = SizeDel(Abs((MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA))) - (Y - LastX + 1)) + 1
                        Else
                            Insertion = Insertion + 1
                            SizeIns((Y - LastX + 1) - Abs((MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA)))) = SizeIns((Y - LastX + 1) - (Abs(MapTestToRef(Y + 1, WinB) - MapTestToRef(LastX, WinA)))) + 1
                        End If
                        If (Y - LastX + 1) > 1 Then
                        
                        End If
                        'Deletion = Deletion + 1
                    End If
                    x = Y
                End If
            Else
                Insertion = Insertion + 1
                
                For Y = x To Len(TestSeq)
                    If TestPos(Y) > 0 Then
                        SizeIns(Y - 1) = SizeIns(Y - 1) + 1
                        x = Y - 1
                        Exit For
                    End If
                Next Y
            End If
            
        Else
            LastX = x
            Match = Match + 1
'            Deletion = Deletion + 1
'            For Y = X To Len(refernce)
'                If RefPos(X) > 0 Then
'                    X = Y - 1
'                    Exit For
'                End If
'            Next Y
        End If
    Next x
    x = x
'    ReDim Preserve MatchPercent(SeqCount + 1000)
'    ReDim Preserve MatchPercent2(SeqCount + 1000)
'    ReDim Preserve InsPerNt(SeqCount + 1000)
'    ReDim Preserve DelPerNt(SeqCount + 1000)
    If Match = 0 Then
        MatchPercent(SeqCount) = Match / Len(TestSeq)
        MatchPercent2(SeqCount) = 0 'Match / (Match + MissMatch)
        InsPerNt(SeqCount) = Insertion / (Len(TestSeq))
        DelPerNt(SeqCount) = Deletion / Len(TestSeq)
    Else
        MatchPercent(SeqCount) = Match / Len(TestSeq)
        MatchPercent2(SeqCount) = Match / (Match + MissMatch)
        InsPerNt(SeqCount) = Insertion / (Len(TestSeq))
        DelPerNt(SeqCount) = Deletion / Len(TestSeq)
    End If
    x = x
    Form1.SSPanel1.Caption = Str(SeqCount)
Loop

Dim tMatch As Single
Dim tMatch2 As Single, tIns As Single, tDel As Single
For x = 1 To SeqCount
    tMatch = tMatch + MatchPercent(x)
    tMatch2 = tMatch2 + MatchPercent2(x)
    tIns = tIns + InsPerNt(x)
    tDel = tDel + DelPerNt(x)
    
    
Next x
tMatch = tMatch / SeqCount
tMatch2 = tMatch2 / SeqCount
tIns = tIns / SeqCount
tDel = tDel / SeqCount
Close #FF
XX = CurDir
Open "Macluravirus_Diamond_19252.csv" For Output As #FF
Print #1, "Match%," & Str(tMatch * 100)
Print #1, "Insertions per nt," & Str(tIns)
Print #1, "Deletions per nt," & Str(tDel)
Print #1, ""
Print #1, "Size distribution of insertions and deletions"
Print #1, "size, Insertions, Deletions"
For x = 1 To Len(Reference)
    Print #1, Str(x) & "," & Str(SizeIns(x)) & "," & Str(SizeDel(x))
Next x
Close #FF
x = x



End Sub
Public Sub AderitoFold()
Dim oDir As String, LargeArray() As Single, LenS As Long, SpaceP() As Integer, x As Long, Y As Long, Z As Long, LenSeqs() As Long, FileName As String, FF As Long
LenS = Len(StrainSeq(0))
ReDim LargeArray(LenS, LenS)
ReDim SpaceP(LenS, NextNo)
ReDim LenSeqs(NextNo)
'redim largearray(
For x = 0 To NextNo
    Z = 0
    For Y = 1 To LenS
        If SeqNum(Y, x) <> 46 Then
            Z = Z + 1
        End If
        SpaceP(Z, x) = Y
    Next Y
    LenSeqs(x) = Z
Next x

oDir = CurDir
ChDir App.Path
ChDrive App.Path
FF = FreeFile
Dim Temp As String, A As Long, b As Long, Pos As Long, Pos2 As Long, Temp2 As String, C As Long, Temp3 As String
For x = 0 To NextNo
    ReDim LargeArray(LenS, LenS)
    
    FileName = OriginalName(x) + ".csv"
    'Close #FF
    Open FileName For Binary As #FF
    Temp2 = String(LOF(FF), " ")
    Pos2 = 1
    'For Y = 0 To LenS
    'XX = Len(Temp)
    Get #FF, , Temp2
    SS = Abs(GetTickCount)
    For Z = 0 To LenSeqs(x)
'        If Z = 2682 Then
'            X = X
'        End If
        If Pos2 <= Len(Temp2) Then
        Pos = InStr(Pos2, Temp2, Chr(10), vbBinaryCompare)
        If Pos = 0 Then Pos = Len(Temp2) + 1
        Y = 0
        If Z > 0 And Pos > 0 Then
            Temp = Mid$(Temp2, Pos2 - 1, Pos - Pos2 + 2)
            'XX = Right$(Temp, 10)
            C = 0
            For A = 1 To Len(Temp)
                If Mid$(Temp, A, 1) = "," Then
                    For b = A + 1 To Len(Temp)
                        If Mid$(Temp, b, 1) = "," Or b = Len(Temp) Then
                            Temp3 = Mid$(Temp, A + 1, b - A - 1)
                            Y = Y + 1
                            LargeArray(SpaceP(Y, x), SpaceP(Z, x)) = CSng(Temp3)
'
                            A = b - 1
                            Exit For
                        End If
                    Next b
                End If
            Next A
        
        End If
        Pos2 = Pos + 2
        Else
            x = x
        End If
    Next Z
   EE = Abs(GetTickCount)
   TT = EE - SS
    'Next Y
    For A = 0 To LenS
        For Y = 0 To LenS
            If LargeArray(A, Y) <> LargeArray(Y, A) Then
                XX = LargeArray(Y, A)
            End If
        Next Y
    Next A
    Close #FF
    Open Trim(Str(x)) + ".str" For Binary As #FF
    Put #FF, , LargeArray()
    Close #FF
    Form1.SSPanel1.Caption = Str(x + 1) + " of " + Trim(Str(NextNo + 1)) + " structures reformatted"
    Form1.WindowState = Form1.WindowState
Next x

Dim LargeArray2() As Single, Refernces() As Long

ReDim ReferenceS(5)

ReferenceS(0) = 0 'mat
ReferenceS(1) = 1 'vw
ReferenceS(2) = 2 'Q1
ReferenceS(3) = 3 'Q2
ReferenceS(4) = 39 'Q2
ReferenceS(5) = 40 'Q2

ReDim LargeArray2(5, LenS, LenS)

For x = 0 To 5
    ReDim LargeArray(LenS, LenS)
    Open Trim(Str(ReferenceS(x))) + ".str" For Binary As #FF
    Get #FF, , LargeArray()
    Close #FF
    For Z = 0 To LenS
        For Y = 0 To LenS
            LargeArray2(x, Z, Y) = LargeArray(Z, Y)
        Next Y
    Next Z
Next x


Dim DifferencesA() As Long, DifferencesB() As Long, DifferencesC() As Long, DifferencesD() As Long
ReDim DifferencesA(5, NextNo), DifferencesB(5, NextNo), DifferencesC(NextNo), DifferencesD(NextNo)

For x = 0 To 5
    For Y = 0 To NextNo
        ReDim LargeArray(LenS, LenS)
        Open Trim(Str(Y)) + ".str" For Binary As #FF
        Get #FF, , LargeArray()
        Close #FF
        For A = 0 To LenS
            For b = 0 To LenS
                If LargeArray2(x, A, b) > 0 And LargeArray(A, b) = 0 Then 'if the test sequence has no base pairing and the reference does
                    DifferencesA(x, Y) = DifferencesA(x, Y) + 1
                End If
                If LargeArray2(x, A, b) = 0 And LargeArray(A, b) > 0 Then 'if the test sequence has a base pairing and the reference does not
                    DifferencesB(x, Y) = DifferencesB(x, Y) + 1
                End If
            Next b
        Next A
    Next Y
Next x



For Y = 0 To NextNo
    ReDim LargeArray(LenS, LenS)
    Open Trim(Str(Y)) + ".str" For Binary As #FF
    Get #FF, , LargeArray()
    Close #FF
    For A = 0 To LenS
        For b = 0 To LenS
            If LargeArray2(0, A, b) = 0 And LargeArray2(1, A, b) = 0 And LargeArray(A, b) > 0 Then  'if mat and vw do not have a base pairing and the test sequence does
                DifferencesC(Y) = DifferencesC(Y) + 1
            End If
            If LargeArray2(0, A, b) > 0 And LargeArray2(1, A, b) > 0 And LargeArray(A, b) = 0 Then  'if mat and vw  have a base pairing and the test sequence does not
                DifferencesD(Y) = DifferencesD(Y) + 1
            End If
        Next b
    Next A
Next Y
Open "DiffA.csv" For Output As #FF
Print #FF, "Sequence,Diffs from Mat, Diffs from VW, Diffs From Q1, Diffs From Q2, Diffs From P1, Diffs From P2"
For x = 0 To NextNo
    Print #FF, OriginalName(x) + "," + Str(DifferencesA(0, x)) + "," + Str(DifferencesA(1, x)) + "," + Str(DifferencesA(2, x)) + "," + Str(DifferencesA(3, x)) + "," + Str(DifferencesA(4, x)) + "," + Str(DifferencesA(5, x))
Next x

Close #FF

Open "DiffB.csv" For Output As #FF
Print #FF, "Sequence,Diffs from Mat, Diffs from VW, Diffs From Q1, Diffs From Q2, Diffs From P1, Diffs From P2"
For x = 0 To NextNo
    Print #FF, OriginalName(x) + "," + Str(DifferencesB(0, x)) + "," + Str(DifferencesB(1, x)) + "," + Str(DifferencesB(2, x)) + "," + Str(DifferencesB(3, x)) + "," + Str(DifferencesB(4, x)) + "," + Str(DifferencesB(5, x))
Next x


Close #FF

Open "DiffC.csv" For Output As #FF
Print #FF, "Sequence,Diffs from Mat, Diffs from VW, Diffs From Q1, Diffs From Q2, Diffs From P1, Diffs From P2"
For x = 0 To NextNo
    Print #FF, OriginalName(x) + "," + Str(DifferencesC(x)) + "," + Str(DifferencesC(x)) + "," + Str(DifferencesC(x)) + "," + Str(DifferencesC(x)) + "," + Str(DifferencesC(x)) + "," + Str(DifferencesC(x))
Next x


Close #FF

Open "DiffD.csv" For Output As #FF
Print #FF, "Sequence,Diffs from Mat, Diffs from VW, Diffs From Q1, Diffs From Q2, Diffs From P1, Diffs From P2"
For x = 0 To NextNo
    Print #FF, OriginalName(x) + "," + Str(DifferencesD(x)) + "," + Str(DifferencesD(x)) + "," + Str(DifferencesD(x)) + "," + Str(DifferencesD(x)) + "," + Str(DifferencesD(x)) + "," + Str(DifferencesD(x))
Next x


Close #FF


ChDir oDir
ChDrive oDir

End Sub
Public Function CountSeqsInNWK(Tree As String)
Dim Pos As Long, BracketCount As Long, SeqCount As Long, ColonCount As Long

'count the number of branches
SeqCount = 0
BracketCount = 0
Pos = 1
Do
    Pos = InStr(Pos, Tree, ">", vbBinaryCompare)
    If Pos = 0 Then
        Exit Do
    End If
    BracketCount = BracketCount + 1
    Pos = Pos + 1
    
Loop
CountSeqsInNWK = BracketCount

End Function
Public Sub TreeRootingTest()

Dim x As Long
Dim oDir As String, FileString As String, InString1 As String, InString2 As String, FF As Long, FF2 As Long, SeqString1 As String, SeqString2 As String
oDir$ = CurDir
ChDir App.Path
ChDrive App.Path

Open "TreeComparison.csv" For Output As #10
Print #10, "TreeNumber, TotalBranches, AverageDistance, LowerDistance, LogLikelihoodDiff, HigherDistance, LogLikelihoodDiff, Score"
For x = 1 To 195 Step 2
    FileString = Trim(Str(x))
    FileString = String(4 - Len(FileString), "0") + FileString + ".nwk"
    FF = FreeFile
    Open FileString For Binary As #FF
    InString1 = String(LOF(FF), " ")
    Get #FF, , InString1
    Close #FF
    
    FileString = Trim(Str(x))
    FileString = String(4 - Len(FileString), "0") + FileString + ".fas"
    FF = FreeFile
    Open FileString For Binary As #FF
    SeqString1 = String(LOF(FF), " ")
    Get #FF, , SeqString1
    Close #FF
    
    FileString = Trim(Str(x + 1))
    FileString = String(4 - Len(FileString), "0") + FileString + ".nwk"
    FF = FreeFile
    Open FileString For Binary As #FF
    InString2 = String(LOF(FF), " ")
    Get #FF, , InString2
    Close #FF
    
    
    FileString = Trim(Str(x + 1))
    FileString = String(4 - Len(FileString), "0") + FileString + ".fas"
    FF = FreeFile
    Open FileString For Binary As #FF
    SeqString2 = String(LOF(FF), " ")
    Get #FF, , SeqString2
    Close #FF
    
    XX = InString1
    XX = InString2
    'Count number of sequences in first file
    Dim NSeq1 As Long, NSeq2 As Long
    NSeq1 = CountSeqsInNWK(SeqString1)
    
    'count number of sequences in seocnd file
    NSeq2 = CountSeqsInNWK(SeqString2)
    Dim InvTree1() As Long, InvTree2() As Long, BracketPair1() As Long, BracketPair2() As Long, Branch As Long, Tree1() As Long, Treenames1() As String, Tree2() As Long, Treenames2() As String
    If NSeq1 = NSeq2 And NSeq1 > 0 Then '5,7, 9, 11, 13, 15, 17,19, 45,47, 49,51, 55, 57, 125, 177, 181, 183, 193, 195
        ReDim InvTree1(NSeq1 * 2, NSeq1 * 2), InvTree2(NSeq1 * 2, NSeq1 * 2), Tree1(NSeq1 * 2, NSeq1 * 2), Treenames1(NSeq1), Tree2(NSeq1 * 2, NSeq1 * 2), Treenames2(NSeq1)
        Call GetNames(SeqString1, Treenames1())
        Call GetNames(SeqString2, Treenames2())
        'find positions of bracket pairs
        ReDim BracketPair1(NSeq1 * 2, 1), BracketPair2(NSeq1 * 2, 1)
        
        Call MakeBracketPairs(InString1, BracketPair1())
        Call MakeBracketPairs(InString2, BracketPair2())
        
        Call MakeTree(NSeq1, InString1, Treenames1(), BracketPair1(), Tree1())
        Call MakeTree(NSeq1, InString2, Treenames2(), BracketPair2(), Tree2())
        Dim BranchLen() As Double
        ReDim BranchLen(NSeq1 * 2)
        Call GetBranchLengths(NSeq1, BracketPair1(), InString1, BranchLen())
        'find position of "outgroup" clade in tree2 - it should be bracnch 1 - in tree 1
        For Z = 1 To NSeq1 * 2
            For Y = 1 To NSeq * 2
                If Tree1(Z, Y) = 1 Then
                    InvTree1(Z, Y) = 0
                Else
                    InvTree1(Z, Y) = 1
                End If
                If Tree2(Z, Y) = 1 Then
                    InvTree2(Z, Y) = 0
                Else
                    InvTree2(Z, Y) = 1
                End If
            Next Y
        Next Z
        'find sets off 2nd branch of tree2
        Dim Set1() As Long, Set2() As Long, Set1Len As Long, Set2Len As Long
        ReDim Set1(NSeq1), Set2(NSeq1)
        Set1Len = 0
        Set2Len = 0
        For Z = 1 To NSeq1
            If Tree2(2, Z) = 0 Then
                Set1Len = Set1Len + 1
                Set1(Set1Len) = Z
            ElseIf Tree2(2, Z) = 1 Then
                Set2Len = Set2Len + 1
                Set2(Set2Len) = Z '8,9,10,11,12,13,14,15,16,17,18
            End If
        Next Z
        
        XX = InString1
        'Work out distances of each branch from the root in tree 1
        Dim BNum As Long, BDist As Long, BranchDistance() As Long
        ReDim BranchDistance(NSeq1 * 2)
        For Z = 2 To NSeq1 * 2
            If BracketPair1(Z, 1) = 0 Then Exit For
            BDist = 0
            For A = BracketPair1(1, 0) + 1 To BracketPair1(Z, 0)
                If Mid(InString1, A, 1) = "(" Then
                    BDist = BDist + 1
                ElseIf Mid(InString1, A, 1) = ")" Then
                    BDist = BDist - 1
                End If
            Next A
            BranchDistance(Z) = BDist '1,2,3,4,5,6,5,4
            
        Next Z
        BNum = Z - 1
        
        
        Dim AvDist As Single
        'work out average distance of branches from the root
        For Z = 1 To BNum
            AvDist = AvDist + BranchDistance(Z)
        Next Z
        AvDist = AvDist / BNum
        
        'find the lowest and highest MRCA branches in tree 1 for pairs of sequences in Set1 and Set2
        
        
        Dim CurBranch As Long, Lowest As Long, Highest As Long, LBL() As Double
        Lowest = NSeq1 * 2
        Highest = 0
        ReDim LBL(2)
        For Z = 1 To Set1Len
            For Y = 1 To Set2Len
                For A = NSeq1 * 2 To 1 Step -1
                    If Tree1(A, Set1(Z)) = 1 And Tree1(A, Set2(Y)) = 1 Then
                        If BranchDistance(A) < Lowest Then
                            Lowest = BranchDistance(A)
                            LBL(0) = BranchLen(A)
                        End If
                        If BranchDistance(A) > Highest Then
                            Highest = BranchDistance(A)
                            LBL(1) = BranchLen(A)
                        End If
                        Exit For
                    End If
                Next A
                
            Next Y
        Next Z
        
        x = x
    
        Dim OutString As String
        OutString = Str(x) + "," + Str(BNum) + "," + Str(AvDist) + "," + Str(Lowest) + "," + Str(LBL(0)) + "," + Str(Highest) + "," + Str(LBL(1)) + "," + Str((Highest / AvDist) * 100)
        Print #10, OutString
        x = x
    End If
    x = x
    Form1.SSPanel1.Caption = Str(x)
    Form1.WindowState = Form1.WindowState
    x = x
Next x

Close #10
ChDir oDir
ChDrive oDir

End Sub

Public Sub GetBranchLengths(NSeq, BracketPair() As Long, InString As String, BranchLen() As Double)
Dim x As Long, Pos1 As Long, Pos2 As Long, Pos3 As Long
For x = 1 To NSeq * 2
    If BracketPair(x, 0) > 0 And BracketPair(x, 1) > 0 Then
        Pos1 = InStr(BracketPair(x, 1) + 1, InString, ":", vbBinaryCompare)
        Pos2 = InStr(BracketPair(x, 1) + 1, InString, ")", vbBinaryCompare)
        Pos3 = InStr(BracketPair(x, 1) + 1, InString, ",", vbBinaryCompare)
        If Pos2 > 0 And Pos3 > 0 Then
            If Pos3 < Pos2 Then
                Pos2 = Pos3
            End If
        ElseIf Pos3 > 0 Then
            Pos2 = Pos3
        
        End If
        If Pos2 > Pos1 + 1 Then
            XX = Mid$(InString, Pos1 + 1, Pos2 - Pos1 - 1)
            x = x
            BranchLen(x) = CDbl(val(Mid$(InString, Pos1 + 1, Pos2 - Pos1 - 1)))
            x = x
        Else
            BranchLen(x) = 0
        End If
        
        
    End If
Next x
If BranchLen(2) = -1 Then BranchLen(2) = 0
For x = 3 To NSeq * 2
    If BranchLen(x) = -1 Then
        BranchLen(x) = 0
    Else
        BranchLen(x) = BranchLen(x) - BranchLen(2)
    End If
Next x
End Sub
Public Sub MakeTree(NSeq As Long, InString As String, Treenames() As String, BracketPair() As Long, Tree() As Long)
Dim A As Long, b As Long, Pos As Long

For A = 1 To NSeq
    Pos = InStr(1, InString, Treenames(A), vbBinaryCompare)
    If Pos > 0 Then
        For b = 1 To NSeq * 2
            If Pos > BracketPair(b, 0) And Pos < BracketPair(b, 1) Then
                Tree(b, A) = 1
            End If
            
        Next b
    End If
Next A

x = x
End Sub
Public Sub MakeBracketPairs(InString As String, BracketPair() As Long)
Dim x As Long, Pairnum As Long, Y As Long, StartPairnum As Long
Pairnum = 0
For x = 1 To Len(InString)
    If Mid(InString, x, 1) = "(" Then
        
        Pairnum = Pairnum + 1
        StartPairnum = Pairnum
        For Y = x + 1 To Len(InString)
            If Mid(InString, Y, 1) = ")" Then
                
                StartPairnum = StartPairnum - 1
                If StartPairnum < Pairnum Then
                    Exit For
                End If
            ElseIf Mid(InString, Y, 1) = "(" Then
                StartPairnum = StartPairnum + 1
            End If
        Next Y
        XX = UBound(BracketPair, 1)
        BracketPair(Pairnum, 0) = x
        BracketPair(Pairnum, 1) = Y
    End If
Next x
x = x
End Sub
Public Function CountOpen(InString1 As String, x As Long, Target As String)
Dim Pos As Long, NumChars As Long
NumChars = 0
Pos = 1
Do
    Pos = InStr(Pos, InString, Target, vbBinaryCompare)
    If Pos = 0 Or Pos > x Then
        Exit Do
    End If
    NumChars = NumChars + 1
    Pos = Pos + 1
Loop
CountOpen = NumChars

End Function
Public Sub GetExonStats(Curgene As Long, StartExon As Long, EndExon As Long)
    Dim A As Long, b As Long
    For A = Curgene - 1 To 0 Step -1
        If GeneList(A + 1).ExonNumber <= GeneList(A).ExonNumber Or GeneList(A).ExonNumber = 0 Then
            A = A + 1
            Exit For
        End If
    Next A
    If A < 1 Then A = 1
    StartExon = A
    For b = Curgene + 1 To GeneNumber
        If GeneList(b).ExonNumber <= GeneList(b - 1).ExonNumber Then
            b = b - 1
            Exit For
        End If
    Next b
    If b > GeneNumber Then b = GeneNumber
    
    EndExon = b

End Sub
Public Sub GetNames(SeqString As String, Treenames() As String)
    Dim Pos As Long, Pos2 As Long, Target As String, SeqNumber As Long
    Pos = InStr(1, SeqString, Chr(10), vbBinaryCompare)
    Pos2 = InStr(1, SeqString, Chr(13), vbBinaryCompare)
    Target = ""
    If Pos > 0 And Pos2 > 0 Then
        If Pos < Pos2 Then
            Target = Chr(10)
        ElseIf Pos2 < Pos Then
            Target = Chr(13)
        End If
    ElseIf Pos > 0 Then
        Target = Chr(10)
    ElseIf Pos2 > 0 Then
        Target = Chr(13)
    End If
    If Target = "" Then Exit Sub
    Pos = 1
    Pos2 = 1
    SeqNumber = 0
    Do
      Pos = InStr(Pos, SeqString, ">", vbBinaryCompare)
      If Pos = 0 Then
        Exit Do
      End If
      SeqNumber = SeqNumber + 1
      Pos2 = InStr(Pos + 1, SeqString, Target, vbBinaryCompare)
      
      Treenames(SeqNumber) = Mid$(SeqString, Pos + 1, Pos2 - Pos - 1)
      XX = XX
      
      
      Pos = Pos + 1
    
    Loop
    
    
End Sub
Public Sub FillGeneSEPos()
Dim TS As String, x As Long, Y As Long, Z As Long, A As Long, b As Long
ReDim GeneSEPos(PermNextno, GeneNumber, 8)


'0 - startnt in align of start codon
'1 - endnt in align of start codon
'2 - startnt in align of stop codon
'3 - endnt in align of stop codon
'val = -1 means no codon
Dim PolyProtCheck, EndWarn As Byte, StartWarn As Byte
'222
For x = 1 To GeneNumber
    If GeneList(x).StartInAlign > 0 Or (GeneList(x).EndInAlign > 0 And GeneList(x).EndInAlign < Len(StrainSeq(0))) Then
        If GeneList(x).StartInAlign = 0 Then
            StartWarn = 1
        Else
            StartWarn = 0
        End If
        If GeneList(x).EndInAlign > 0 And GeneList(x).EndInAlign <= Len(StrainSeq(0)) Then
            EndWarn = 0
        Else
            EndWarn = 1
        End If
        If Right$(GeneList(x).Product, 1) = "*" Or (Right$(GeneList(x).Name, 1) = "*" And GeneList(x).Product = "") Then
            PolyProtCheck = 1
        Else
            PolyProtCheck = 0
        End If
        If GeneList(x).Orientation = 1 Then
            
            For Y = 0 To PermNextno
'                If Y = 222 And X = 27 Then
'                    X = X
'                End If
                If PolyProtCheck = 1 Then
                    If StartWarn = 0 Then
                        GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign
                        GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                    End If
                    If EndWarn = 0 Then
                        GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign - 2
                        GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                    End If
                Else
                    'XX = Mid$(StrainSeq(Y), GeneList(X).StartInAlign, 3)
                    If StartWarn = 0 Then
                        If Mid$(StrainSeq(Y), GeneList(x).StartInAlign, 3) = "ATG" Then
                            GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign
                            GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                        Else
                            If GeneList(x).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
                                If GeneList(x).StartInAlign > 2 Then
                                    TS = Mid$(StrainSeq(Y), GeneList(x).StartInAlign - 2, 2)
                                
                                    If TS = "AG" Then
                                        GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign
                                        GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                                        GeneSEPos(Y, x, 4) = GeneList(x).StartInAlign - 2
                                        GeneSEPos(Y, x, 5) = GeneSEPos(Y, x, 4) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
                    'TAA, TAG, or TGA
                    'XX = Mid$(StrainSeq(Y), GeneList(X).EndInAlign - 2, 3)
                    
                    If EndWarn = 0 Then
                        If GeneList(x).EndInAlign > 2 Then
                            TS = Mid$(StrainSeq(Y), GeneList(x).EndInAlign - 2, 3)
                        
                            If TS = "TAA" Or TS = "TAG" Or TS = "TGA" Then
                                GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign - 2
                                GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                            Else
                                If GeneList(x).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
                                    If GeneList(x).EndInAlign + 1 <= Len(StrainSeq(0)) Then
                                        TS = Mid$(StrainSeq(Y), GeneList(x).EndInAlign + 1, 2)
                                        If TS = "GT" Then
                                            GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign - 2
                                            GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                                            GeneSEPos(Y, x, 6) = GeneSEPos(Y, x, 3) + 1
                                            GeneSEPos(Y, x, 7) = GeneSEPos(Y, x, 6) + 1
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Next Y
        ElseIf GeneList(x).Orientation = 2 Then
            For Y = 0 To PermNextno
                If PolyProtCheck = 1 Then
                    If StartWarn = 0 Then
                        GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign - 2
                        GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                    End If
                    If EndWarn = 1 Then
                        GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign
                        GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                    End If
                Else
                    'XX = Mid$(StrainSeq(Y), GeneList(X).StartInAlign - 2, 3)
                    If StartWarn = 0 Then
                        If Mid$(StrainSeq(Y), GeneList(x).StartInAlign - 2, 3) = "CAT" Then
                            GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign - 2
                            GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                        Else
                            If GeneList(x).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
                                
                                If GeneList(x).StartInAlign + 1 <= Len(StrainSeq(0)) Then
                                    TS = Mid$(StrainSeq(Y), GeneList(x).StartInAlign + 1, 2)
                                    If TS = "CT" Then
                                        GeneSEPos(Y, x, 0) = GeneList(x).StartInAlign - 2
                                        GeneSEPos(Y, x, 1) = GeneSEPos(Y, x, 0) + 2
                                        GeneSEPos(Y, x, 4) = GeneList(x).StartInAlign + 1
                                        GeneSEPos(Y, x, 5) = GeneSEPos(Y, x, 4) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
                    If EndWarn = 0 Then
                        'TAA, TAG, or TGA
                        'XX = Mid$(StrainSeq(Y), GeneList(X).EndInAlign, 18)
                        TS = Mid$(StrainSeq(Y), GeneList(x).EndInAlign, 3)
                        If TS = "TTA" Or TS = "CTA" Or TS = "TCA" Then
                            GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign
                            GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                        Else
                            If GeneList(x).IntronFlag = 1 And GeneList(x).ExonNumber > 1 Then 'this is an exon that may stop before a donor site
                                If GeneList(x).EndInAlign > 2 Then
                                    TS = Mid$(StrainSeq(Y), GeneList(x).EndInAlign - 2, 2)
                                    If TS = "AC" Then
                                        GeneSEPos(Y, x, 2) = GeneList(x).EndInAlign
                                        GeneSEPos(Y, x, 3) = GeneSEPos(Y, x, 2) + 2
                                        GeneSEPos(Y, x, 6) = GeneList(x).EndInAlign - 2
                                        GeneSEPos(Y, x, 7) = GeneSEPos(Y, x, 6) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Next Y
        End If
    End If
Next x


Dim StopPos() As Long, BackToAlign() As Long, M As Long, n As Long, GeneString As String, TestTrip(3), DistFrom As Long, ActualStart As Long, ActualEnd As Long, StopExpected As Long, StartExpected As Long, StartExon As Long, EndExon As Long
Dim SizeGene As Long, PosInGene As Long
For x = 1 To GeneNumber
    ActualStart = GeneList(x).StartInAlign
    ActualEnd = GeneList(x).EndInAlign - 2
    If GeneList(x).IntronFlag = 1 Then
        Call GetExonStats(x, StartExon, EndExon)
        If GeneList(x).Orientation = 1 Then
            If x = StartExon Then
                StopExpected = 0
                StartExpected = 1
            
            ElseIf x = EndExon Then
                StopExpected = 1
                StartExpected = 0
            Else
                StopExpected = 0
                StartExpected = 0
            End If
        ElseIf GeneList(x).Orientation = 2 Then
            If x = StartExon Then
                StopExpected = 1
                StartExpected = 0
            
            ElseIf x = EndExon Then
                StopExpected = 0
                StartExpected = 1
            Else
                StopExpected = 0
                StartExpected = 0
            End If
        End If
        
    Else
        StartExpected = 1
        StopExpected = 1
    End If
    Dim AddBit As Long, EndTestPos As Long, CurDist As Long, CurDist2 As Long, CycleNum As Long, SubSeq As String, LastStop As Long, MaxLenORF As Long, OrfFrame As Long, ORFend As Long, LenORF As Long
    If GeneList(x).Orientation = 1 Then
        'XX = Nextno
        For Y = 0 To PermNextno
'            If Y = 222 And X = 27 Then
'                X = X
'            End If
'
            If GeneSEPos(Y, x, 2) = 0 And GeneSEPos(Y, x, 0) = 0 And StopExpected = 1 And StartExpected = 1 Then
                'find the biggest correctly oriented ORF between the expected stops and starts
                If GeneList(x).StartInAlign < GeneList(x).EndInAlign Then
                    SizeGene = GeneList(x).EndInAlign - GeneList(x).StartInAlign
                Else
                    SizeGene = GeneList(x).EndInAlign + Len(StrainSeq(0)) - GeneList(x).StartInAlign
                End If
                
                'extract sequence from egen region
                If Len(StrainSeq(0)) > 2000 Then
                    AddBit = 1000
                Else
                    AddBit = Len(StrainSeq(0)) / 2
                End If
                If GeneList(x).EndInAlign + AddBit <= Len(StrainSeq(0)) Then
                    EndTestPos = GeneList(x).EndInAlign + AddBit
                Else
                    If CircularFlag = 1 Then
                        EndTestPos = GeneList(x).EndInAlign + AddBit
                        EndTestPos = EndTestPos - Len(StrainSeq(0))
                    Else
                        EndTestPos = Len(StrainSeq(0))
                    End If
                End If
                
                SizeGene = SizeGene + AddBit
                GeneString = String(SizeGene, " ")
                ReDim BackToAlign(SizeGene + 2)
                
                If GeneList(x).StartInAlign < EndTestPos Then
                    PosInGene = 0
                    
                    For M = GeneList(x).StartInAlign To EndTestPos
                        If M > -1 Then
                            If SeqNum(M, Y) > 46 Then
                                PosInGene = PosInGene + 1
                                If PosInGene <= Len(GeneString) Then
                                
                                    Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                                Else
                                    Exit For
                                End If
                                BackToAlign(PosInGene) = M
                            End If
                        End If
                    Next M
                    x = x
                Else
                    PosInGene = 0
                    For M = GeneList(x).StartInAlign To Len(StrainSeq(0))
                        If M > -1 Then
                            If SeqNum(M, Y) > 46 Then
                                PosInGene = PosInGene + 1
                                Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                                BackToAlign(PosInGene) = M
                            End If
                        End If
                    Next M
                    
                    For M = 1 To EndTestPos
                        If SeqNum(M, Y) > 46 Then
                            PosInGene = PosInGene + 1
                            If PosInGene > Len(GeneString) Then Exit For
                            'XX = Len(GeneString)
                            Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                            BackToAlign(PosInGene) = M
                        End If
                        
                    Next M
                End If
                If PosInGene > 3 Then ' i.e if the gene is even there
                    Trim (GeneString)
                    ReDim StopPos(PosInGene)
                    Pos = 0
                    Do
                        Pos = InStr(Pos + 1, GeneString, "TAA", vbBinaryCompare)
                        If Pos > 0 Then
                            StopPos(Pos) = 1
                        Else
                            Exit Do
                        End If
                        
                    Loop
                    
                    Pos = 0
                    Do
                        Pos = InStr(Pos + 1, GeneString, "TAG", vbBinaryCompare)
                        If Pos > 0 Then
                            StopPos(Pos) = 1
                        Else
                            Exit Do
                        End If
                        
                    Loop
                    Pos = 0
                    Do
                        Pos = InStr(Pos + 1, GeneString, "TGA", vbBinaryCompare)
                        If Pos > 0 Then
                            StopPos(Pos) = 1
                        Else
                            Exit Do
                        End If
                        
                    Loop
                    MaxLenORF = 0
                    OrfFrame = -1
                    ORFend = -1
                    For M = 0 To 2
                        LastStop = 0
                        For n = 1 + M To PosInGene Step 3
                            If StopPos(n) = 1 Then
                                LenORF = n - LastStop
                                If LenORF > MaxLenORF Then
                                    OrfFrame = M
                                    ORFend = n
                                    MaxLenORF = LenORF
                                End If
    '                            If N - LastStop > 500 Then
    '                                X = X
    '                            End If
                                LastStop = n
                            End If
                        Next n
                        If LastStop = 0 Then
                            n = n - 3
                            'need to look beyond the end of the gene until a stop codon is found
                            LenORF = n
                            If LenORF > MaxLenORF Then
                                OrfFrame = M
                                ORFend = n
                                MaxLenORF = LenORF
                            End If
                        End If
                    Next M
                    'ORFend = BackToAlign(ORFend)
                    If ORFend > -1 Then
                        GeneSEPos(Y, x, 2) = BackToAlign(ORFend) '7759,7761
                            If ORFend + 2 <= UBound(BackToAlign) Then
                                GeneSEPos(Y, x, 3) = BackToAlign(ORFend + 2)
                            Else
                                GeneSEPos(Y, x, 3) = UBound(BackToAlign)
                            End If
                    Else
                        GeneSEPos(Y, x, 2) = 1
                        GeneSEPos(Y, x, 3) = Len(StrainSeq(0))
                    End If
                End If
            End If
            
            If GeneSEPos(Y, x, 0) = 0 And GeneSEPos(Y, x, 2) > 0 And StartExpected = 1 Then
                'check if intron found
                A = 3
                DistFrom = Len(StrainSeq(0))
                Z = GeneSEPos(Y, x, 2) - 1
                CycleNum = 0
                'this currently the only iteration that will look back beyond the start of the sequence (i.e. it wraps)
                'XX = UBound(SeqNum, 2)
                Do
                    If Y > UBound(SeqNum, 2) Then Exit Do
                    If SeqNum(Z, Y) > 46 Then
                        If A = 3 Then b = Z
                        TestTrip(A) = SeqNum(Z, Y)
                        A = A - 1
                        If A = 0 Then
                            x = x
                            If TestTrip(1) = 66 Then
                                If TestTrip(2) = 85 Then
                                    If TestTrip(3) = 72 Then
                                        CurDist = Abs(Z - ActualStart)
                                        If CircularFlag = 1 Then
                                            CurDist2 = (Z - Len(StrainSeq(0)))
                                            CurDist2 = Abs(CurDist2 - ActualStart)
                                            If CurDist2 < CurDist Then CurDist = CurDist2
                                        End If
                                        If DistFrom > CurDist Then
                                            DistFrom = CurDist
                                            GeneSEPos(Y, x, 0) = Z
                                            GeneSEPos(Y, x, 1) = b
                                        Else
                                            Exit Do
                                        End If
                                    End If
                                End If
                            End If
                            A = 3
                        End If
                    End If
                    Z = Z - 1
                    If Z < 1 Then
                        If CircularFlag = 1 And CycleNum = 0 Then
                            Z = Len(StrainSeq(0))
                            CycleNum = 1
                        Else
                            Exit Do
                        End If
                    End If
                Loop
'                XX = Mid$(StrainSeq(Y), GeneList(X).StartInAlign, 3)
'                If Mid$(StrainSeq(Y), GeneList(X).StartInAlign, 3) = "ATG" Then
'                    GeneSEPos(Y, X, 0) = GeneList(X).StartInAlign
'                    GeneSEPos(Y, X, 1) = GeneSEPos(Y, X, 0) + 2
'                Else
'                    If GeneList(X).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
'
'                        TS = Mid$(StrainSeq(Y), GeneList(X).StartInAlign + 1, 2)
'                        If TS = "AG" Then
'                            GeneSEPos(Y, X, 0) = GeneList(X).StartInAlign
'                            GeneSEPos(Y, X, 1) = GeneSEPos(Y, X, 0) + 2
'                            GeneSEPos(Y, X, 4) = GeneList(X).StartInAlign + 1
'                            GeneSEPos(Y, X, 5) = GeneSEPos(Y, X, 4) + 1
'                        End If
'                    End If
'                End If
            End If
            'TAA, TAG, or TGA
            'XX = Mid$(StrainSeq(Y), GeneList(X).EndInAlign - 2, 3)
            
            If GeneSEPos(Y, x, 2) = 0 And GeneSEPos(Y, x, 0) > 0 And StopExpected = 1 Then
                
                A = 1
                DistFrom = Len(StrainSeq(0))
                For Z = GeneSEPos(Y, x, 1) + 1 To Len(StrainSeq(0))
                    If SeqNum(Z, Y) > 46 Then
                        If A = 1 Then b = Z
                        TestTrip(A) = SeqNum(Z, Y)
                        A = A + 1
                        If A = 4 Then
                            x = x
                            If TestTrip(1) = 85 Then
                                If TestTrip(2) = 66 Then
                                    If TestTrip(3) = 66 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = b
                                            GeneSEPos(Y, x, 3) = Z
                                        Else
                                            Exit For
                                        End If
                                    ElseIf TestTrip(3) = 72 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = b
                                            GeneSEPos(Y, x, 3) = Z
                                        Else
                                            Exit For
                                        End If
                                    End If
                                ElseIf TestTrip(3) = 72 Then
                                    If TestTrip(3) = 66 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = b
                                            GeneSEPos(Y, x, 3) = Z
                                        Else
                                            Exit For
                                        End If
                                    
                                    End If
                                End If
                            End If
                            A = 1
                        End If
                    End If
                Next Z
'                TS = Mid$(StrainSeq(Y), GeneList(X).EndInAlign - 2, 3)
'                If TS = "TAA" Or TS = "TAG" Or TS = "TGA" Then
'                    GeneSEPos(Y, X, 2) = GeneList(X).EndInAlign - 2
'                    GeneSEPos(Y, X, 3) = GeneSEPos(Y, X, 2) + 2
'                Else
'                    If GeneList(X).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
'                        TS = Mid$(StrainSeq(Y), GeneList(X).EndInAlign + 1, 2)
'                        If TS = "GT" Then
'                            GeneSEPos(Y, X, 2) = GeneList(X).EndInAlign - 2
'                            GeneSEPos(Y, X, 3) = GeneSEPos(Y, X, 2) + 2
'                            GeneSEPos(Y, X, 6) = GeneList(X).EndInAlign + 1
'                            GeneSEPos(Y, X, 7) = GeneSEPos(Y, X, 6) + 1
'                        End If
'                    End If
'                End If
            End If
            
            
        Next Y
    ElseIf GeneList(x).Orientation = 2 Then
        For Y = 0 To PermNextno
            'XX = Mid$(StrainSeq(Y), GeneList(X).StartInAlign - 2, 3)
            If GeneSEPos(Y, x, 2) = 0 And GeneSEPos(Y, x, 0) = 0 And StopExpected = 1 And StartExpected = 1 Then
                'find the biggest correctly oriented ORF between the expected stops and starts
                If GeneList(x).EndInAlign < GeneList(x).StartInAlign Then
                    SizeGene = (GeneList(x).StartInAlign - GeneList(x).EndInAlign)
                Else
                    SizeGene = GeneList(x).StartInAlign + Len(StrainSeq(0)) - GeneList(x).EndInAlign
                End If
                
                'extract sequence from gene region
                If Len(StrainSeq(0)) > 2000 Then
                    AddBit = 1000
                Else
                    AddBit = Len(StrainSeq(0)) / 2
                End If
                If AddBit > (SizeGene / 1.25) Then AddBit = SizeGene / 1.25
                
                
                If GeneList(x).EndInAlign - AddBit >= 1 Then
                    EndTestPos = GeneList(x).EndInAlign - AddBit
                Else
                    If CircularFlag = 1 Then
                        EndTestPos = GeneList(x).EndInAlign - AddBit
                        EndTestPos = EndTestPos + Len(StrainSeq(0))
                    Else
                        EndTestPos = 1
                    End If
                End If
                
                SizeGene = SizeGene + AddBit
                GeneString = String(SizeGene, " ")
                ReDim BackToAlign(SizeGene + 2)
                'XX = UBound(BackToAlign, 1)
                If EndTestPos < GeneList(x).StartInAlign Then
                    PosInGene = 0
                    For M = EndTestPos To GeneList(x).StartInAlign
                        If SeqNum(M, Y) > 46 Then
                            PosInGene = PosInGene + 1
                            If PosInGene <= Len(GeneString) Then
                                Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                            End If
                            BackToAlign(PosInGene) = M
                        End If
                        
                    Next M
                    x = x
                Else
                    PosInGene = 0
                    For M = EndTestPos To Len(StrainSeq(0))
                        If SeqNum(M, Y) > 46 Then
                            PosInGene = PosInGene + 1
                            Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                            BackToAlign(PosInGene) = M
                        End If
                        
                    Next M
                    
                    For M = 1 To GeneList(x).StartInAlign
                        If SeqNum(M, Y) > 46 Then
                            PosInGene = PosInGene + 1
                            Mid$(GeneString, PosInGene, 1) = Chr(SeqNum(M, Y) - 1)
                            BackToAlign(PosInGene) = M
                        End If
                        
                    Next M
                End If
                Trim (GeneString)
                ReDim StopPos(PosInGene)
                Pos = 0
                Do
                    Pos = InStr(Pos + 1, GeneString, "TTA", vbBinaryCompare)
                    If Pos > 0 Then
                        StopPos(Pos) = 1
                    Else
                        Exit Do
                    End If
                    
                Loop
                
                Pos = 0
                Do
                    Pos = InStr(Pos + 1, GeneString, "CTA", vbBinaryCompare)
                    If Pos > 0 Then
                        StopPos(Pos) = 1
                    Else
                        Exit Do
                    End If
                    
                Loop
                Pos = 0
                Do
                    Pos = InStr(Pos + 1, GeneString, "TCA", vbBinaryCompare)
                    If Pos > 0 Then
                        StopPos(Pos) = 1
                    Else
                        Exit Do
                    End If
                    
                Loop
                MaxLenORF = 0
                OrfFrame = -1
                ORFend = -1
                For M = 0 To 2
                    LastStop = PosInGene
                    For n = PosInGene - M To 1 Step -3
                        If StopPos(n) = 1 Then
                            LenORF = LastStop - n
                            If LenORF > MaxLenORF Then
                                OrfFrame = M
                                ORFend = n
                                MaxLenORF = LenORF
                            End If
'                            If N - LastStop > 500 Then
'                                X = X
'                            End If
                            LastStop = n
                        End If
                    Next n
                    If LastStop = 0 Then
                        n = n - 3
                        'need to look beyond the end of the gene until a stop codon is found
                        LenORF = n
                        If LenORF > MaxLenORF Then
                            OrfFrame = M
                            ORFend = 1
                            MaxLenORF = LenORF
                        End If
                    End If
                Next M
                'ORFend = BackToAlign(ORFend)
                If ORFend > -1 Then
                    GeneSEPos(Y, x, 2) = BackToAlign(ORFend) '7232,7234
                    GeneSEPos(Y, x, 3) = BackToAlign(ORFend + 2)
                Else
                    GeneSEPos(Y, x, 2) = 1
                    GeneSEPos(Y, x, 3) = Len(StrainSeq(0))
                End If
                'GeneSEPos(Y, X, 0) = 0
            End If
            
            
            
            If GeneSEPos(Y, x, 0) = 0 And GeneSEPos(Y, x, 2) > 0 And StartExpected = 1 Then
                
                
                A = 1
                DistFrom = Len(StrainSeq(0))
                For Z = GeneSEPos(Y, x, 3) + 1 To Len(StrainSeq(0))
                    If SeqNum(Z, Y) > 46 Then
                        If A = 1 Then b = Z
                        TestTrip(A) = SeqNum(Z, Y)
                        A = A + 1
                        If A = 4 Then
                            x = x
                            If TestTrip(1) = 68 Then
                                If TestTrip(2) = 66 Then
                                    If TestTrip(3) = 85 Then
                                        If DistFrom >= Abs(Z - ActualStart) Then
                                            DistFrom = Abs(Z - ActualStart)
                                            GeneSEPos(Y, x, 0) = b
                                            GeneSEPos(Y, x, 1) = Z
                                        Else
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                            A = 1
                        End If
                    End If
                Next Z
                
                
                
'                If Mid$(StrainSeq(Y), GeneList(X).StartInAlign - 2, 3) = "CAT" Then
'                    GeneSEPos(Y, X, 0) = GeneList(X).StartInAlign - 2
'                    GeneSEPos(Y, X, 1) = GeneSEPos(Y, X, 0) + 2
'                Else
'                    If GeneList(X).IntronFlag = 1 Then  'this is an exon that may start after an acceptor site
'
'
'                        TS = Mid$(StrainSeq(Y), GeneList(X).StartInAlign + 1, 2)
'                        If TS = "CT" Then
'                            GeneSEPos(Y, X, 0) = GeneList(X).StartInAlign - 2
'                            GeneSEPos(Y, X, 1) = GeneSEPos(Y, X, 0) + 2
'                            GeneSEPos(Y, X, 4) = GeneList(X).StartInAlign + 1
'                            GeneSEPos(Y, X, 5) = GeneSEPos(Y, X, 4) + 1
'                        End If
'                    End If
'                End If
            End If
            'TAA, TAG, or TGA
            If GeneSEPos(Y, x, 2) = 0 And GeneSEPos(Y, x, 0) > 0 And StopExpected = 1 Then
                A = 3
                DistFrom = Len(StrainSeq(0))
                For Z = GeneSEPos(Y, x, 0) - 1 To 0 Step -1
                    If SeqNum(Z, Y) > 46 Then
                        If A = 3 Then b = Z
                        TestTrip(A) = SeqNum(Z, Y)
                        A = A - 1
                        If A = 0 Then
                            x = x
                            If TestTrip(1) = 85 Then
                                If TestTrip(2) = 85 Then
                                    If TestTrip(3) = 66 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = Z
                                            GeneSEPos(Y, x, 3) = b
                                        Else
                                            Exit For
                                        End If
                                    End If
                                ElseIf TestTrip(2) = 68 Then
                                    If TestTrip(3) = 66 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = Z
                                            GeneSEPos(Y, x, 3) = b
                                        Else
                                            Exit For
                                        End If
                                    End If
                                End If
                            ElseIf TestTrip(1) = 68 Then
                                If TestTrip(2) = 85 Then
                                    If TestTrip(3) = 66 Then
                                        If DistFrom > Abs(Z - ActualEnd) Then
                                            DistFrom = Abs(Z - ActualEnd)
                                            GeneSEPos(Y, x, 2) = Z
                                            GeneSEPos(Y, x, 3) = b
                                        Else
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                            A = 3
                        End If
                    End If
                Next Z
'                TS = Mid$(StrainSeq(Y), GeneList(X).EndInAlign, 3)
'                If TS = "TTA" Or TS = "CTA" Or TS = "TCA" Then
'                    GeneSEPos(Y, X, 2) = GeneList(X).EndInAlign
'                    GeneSEPos(Y, X, 3) = GeneSEPos(Y, X, 2) + 2
'                Else
'                    If GeneList(X).IntronFlag = 1 And GeneList(X).ExonNumber > 1 Then 'this is an exon that may stop before a donor site
'
'                        TS = Mid$(StrainSeq(Y), GeneList(X).EndInAlign - 2, 2)
'                        If TS = "AC" Then
'                            GeneSEPos(Y, X, 2) = GeneList(X).EndInAlign
'                            GeneSEPos(Y, X, 3) = GeneSEPos(Y, X, 2) + 2
'                            GeneSEPos(Y, X, 6) = GeneList(X).EndInAlign - 2
'                            GeneSEPos(Y, X, 7) = GeneSEPos(Y, X, 6) + 1
'                        End If
'                    End If
'                End If
            End If
        Next Y
    End If
Next x

Call MakeOverlapList

'Intron structure
'forward
'GG!GT(A/G)AGT.........(C/T)T(A/G)A..20-50..(A/G Rich)NCAG!G
'    donor                            branch          acceptor

'reverse
'C!CTGN(C/T Rich)..20-50..T(C/T)A(G/A).......ACT(C/T)AC!CC
'    acceptor       branch                      donor
End Sub
Public Sub MakeOverlapList()
Dim x As Long, Y As Long, Z As Long, MaxCoord As Long, MinCoord As Long, Compatible() As Long, OL As Long
ReDim OverlapList(Len(StrainSeq(0))), Compatible(-1 To GeneNumber, -1 To GeneNumber)
ReDim GenesWithOverlaps(GeneNumber)
For x = 1 To GeneNumber
    Compatible(-1, x) = -1
    Compatible(x, -1) = -1
    For Y = x + 1 To GeneNumber
        If GeneList(x).Frame <> GeneList(Y).Frame Or GeneList(x).Orientation <> GeneList(Y).Orientation Then
            Compatible(x, Y) = -1
            Compatible(Y, x) = -1
        End If
    Next Y
Next x
For A = 0 To 1
    For x = 1 To GeneNumber - 1
        If GeneList(x).Orientation = 1 Then
            For Z = 0 To PermNextno
                If GeneSEPos(Z, x, 0) > 0 And GeneSEPos(Z, x, 3) > 0 Then
                    If GeneSEPos(Z, x, 0) < GeneSEPos(Z, x, 3) Then
                        For Y = GeneSEPos(Z, x, 0) To GeneSEPos(Z, x, 3)
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                    Else
                        For Y = GeneSEPos(Z, x, 0) To Len(StrainSeq(0))
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                        For Y = 1 To GeneSEPos(Z, x, 3)
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                    End If
                End If
            Next Z
        Else
            For Z = 0 To PermNextno
                If GeneSEPos(Z, x, 2) > 0 And GeneSEPos(Z, x, 1) > 0 Then
                    If GeneSEPos(Z, x, 2) < GeneSEPos(Z, x, 1) Then
                        For Y = GeneSEPos(Z, x, 2) To GeneSEPos(Z, x, 1)
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                    Else
                        For Y = GeneSEPos(Z, x, 2) To Len(StrainSeq(0))
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                        For Y = 1 To GeneSEPos(Z, x, 1)
                            OL = OverlapList(Y)
                            If OL = 0 Then
                                OverlapList(Y) = x
                            ElseIf OL <> x Then
                                If Compatible(OL, x) = -1 Then
                                    OverlapList(Y) = Compatible(OL, x)
                                    GenesWithOverlaps(x) = 1
                                End If
                            End If
                        Next Y
                    End If
                End If
            Next Z
        End If
    Next x
Next A
End Sub
Public Sub FillchiResult(LSub As Long, ChiResult() As Single, VSitesMat() As Long)


Dim x As Long, Y As Long, ExpV(3) As Single, GTot As Single, M As Long, n As Long, O As Long, P As Long


'@
For x = 1 To LSub
    For Y = x + 1 To LSub
        
        M = VSitesMat(x, Y, 0) '79,6,4,79: 85,0,0,83
        n = VSitesMat(x, Y, 1)
        O = VSitesMat(x, Y, 2)
        P = VSitesMat(x, Y, 3)
        GTot = M + n + O + P
        If GTot > 0 Then
            If M + n > 0 And O + P > 0 And n + P > 0 And M + O > 0 Then
                ExpV(0) = (M + n) * (M + O) / GTot
                ExpV(1) = (M + n) * (n + P) / GTot
                ExpV(2) = (M + O) * (O + P) / GTot
                ExpV(3) = (n + P) * (O + P) / GTot
                
                ChiResult(x, Y) = ((M - ExpV(0)) ^ 2) / ExpV(0) + ((n - ExpV(1)) ^ 2) / ExpV(1) + ((O - ExpV(2)) ^ 2) / ExpV(2) + ((P - ExpV(3)) ^ 2) / ExpV(3)
                x = x
            Else
                ChiResult(x, Y) = 0
            End If
        Else
            ChiResult(x, Y) = 0
        End If
    Next Y
Next x

End Sub

Public Sub FillVSiteMat(SList() As Long, PermPlantNum() As Long, VSitesMat() As Long, OffsetPerm() As Long, DiffPos() As Long, LSub As Long, SeqNum() As Integer, WorthDoing() As Byte)
Dim x As Long, Y As Long, Z As Long, PN As Long, PO As Long, A As Long, b As Long, DPZ As Long, DPY As Long, PS1 As Long, PS2 As Long, TempSeq As String

'make simulated dataset
If x = 12345 Then
    FF = FreeFile
    Open "simD.fas" For Output As #FF
    For x = 0 To 3
        Print #FF, ">" + OriginalName(x)
        Print #FF, StrainSeq(x)
    Next x
    For x = 4 To NextNo
        PS1 = ChimaeraSeqs(RefChimaera(x), 0)
        PS2 = ChimaeraSeqs(RefChimaera(x), 1)
        TempSeq = StrainSeq(0)
        PN = PermPlantNum(x)
        PO = OffsetPerm(PN)
        For A = 1 To LSub
            Z = A + PO
            If Z > LSub Then
                Z = Z - LSub
            End If
            DPZ = DiffPos(Z)
            
            
            DPY = DiffPos(A)
            If DPZ = 1091 Then
                x = x
            End If
            If SeqNum(DPZ, x) = SeqNum(DPZ, PS1) Then '2693(25),1039(1137):16,1039
                Mid$(TempSeq, DPY, 1) = Mid$(StrainSeq(PS1), DPY, 1)
            ElseIf SeqNum(DPZ, x) = SeqNum(DPZ, PS2) Then 'dpz(dpy),2658(16),16(26):991,2559
                Mid$(TempSeq, DPY, 1) = Mid$(StrainSeq(PS2), DPY, 1)
            Else
                x = x
            End If
        Next A
        Print #FF, ">" + OriginalName(x)
        Print #FF, TempSeq
    Next x
    
    Close #FF
End If
PS1 = ParentSeqs(0)
PS2 = ParentSeqs(1)

If x = x Then
    Dummy = FillVSiteMatC(NextNo, PS1, PS2, UBound(SeqNum, 1), UBound(SList, 1), UBound(VSitesMat, 1), SList(0, 0), PermPlantNum(0), VSitesMat(0, 0, 0), OffsetPerm(0), DiffPos(0), LSub, SeqNum(0, 0), WorthDoing(0))
Else


    For x = 0 To NextNo
        If WorthDoing(x) = 1 Then
            PN = PermPlantNum(x)
            PO = OffsetPerm(PN)
            For A = 1 To LSub
                Z = A + PO
                If Z > LSub Then
                    Z = Z - LSub
                End If
                DPZ = DiffPos(Z)
                If SeqNum(DPZ, x) = SeqNum(DPZ, PS1) Then
                    SList(A, 0) = SList(A, 0) + 1
                    For b = A + 1 To LSub
                        Y = b + PO
                         If Y > LSub Then
                            Y = Y - LSub
                        End If
                        DPY = DiffPos(Y)
                        If SeqNum(DPY, x) = SeqNum(DPY, PS1) Then
                            VSitesMat(A, b, 0) = VSitesMat(A, b, 0) + 1
                            'VSitesMat(Y, Z, 0) = VSitesMat(Z, Y, 0)
                        ElseIf SeqNum(DPY, x) = SeqNum(DPY, PS2) Then
                            VSitesMat(A, b, 1) = VSitesMat(A, b, 1) + 1
                            'VSitesMat(Y, Z, 1) = VSitesMat(Z, Y, 1)
                        End If
                    Next b
                ElseIf SeqNum(DPZ, x) = SeqNum(DPZ, PS2) Then
                    SList(A, 1) = SList(A, 1) + 1
                    For b = A + 1 To LSub
                        Y = b + PO
                         If Y > LSub Then
                            Y = Y - LSub
                        End If
                        DPY = DiffPos(Y)
                        If SeqNum(DPY, x) = SeqNum(DPY, PS1) Then
                            VSitesMat(A, b, 2) = VSitesMat(A, b, 2) + 1
                        ElseIf SeqNum(DPY, x) = SeqNum(DPY, PS2) Then
                            VSitesMat(A, b, 3) = VSitesMat(A, b, 3) + 1
                        End If
                        
                    Next b
                End If
                
            Next A
        
        End If
    
    Next x
    'Fill empty part of the matrix
    For x = 1 To LSub - 1
        For Y = x + 1 To LSub
            VSitesMat(Y, x, 0) = VSitesMat(x, Y, 0)
            VSitesMat(Y, x, 1) = VSitesMat(x, Y, 1)
            VSitesMat(Y, x, 2) = VSitesMat(x, Y, 2)
            VSitesMat(Y, x, 3) = VSitesMat(x, Y, 3)
        Next Y
    Next x
End If

End Sub
Public Sub ExRecAssociationTest()
Dim DiffPos() As Long, DiffPosRev() As Long, VSitesMat() As Long, NumConstSites() As Long, A As Long, b As Long, StartX As Long, OffsetPerm() As Long
ReDim DiffPos(Len(StrainSeq(0))), DiffPosRev(Len(StrainSeq(0))), NumConstSites(Len(StrainSeq(0)))



ReDim OffsetPerm(PermPlantCount)

''Get the positions of the informative sites
'
If CircularFlag = 1 Then
    'track back to last variable site
    For x = Len(StrainSeq(0)) To 1 Step -1
        If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
            Exit For
        End If
    Next x
    StartX = x + 1
    StartX = -(Len(StrainSeq(0)) - StartX)
Else
    StartX = 1
End If


Z = 0
For Y = StartX To Len(StrainSeq(0))
    If Y > 0 Then
        x = Y
    Else
        x = Len(StrainSeq(0)) + Y
    End If
    
    
    If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
        
        
        For A = x - 1 To -Len(StrainSeq(0)) Step -1
            If A > 0 Then
                b = A
            Else
                b = Len(StrainSeq(0)) + A
            End If
            If SeqNum(b, ParentSeqs(0)) = SeqNum(b, ParentSeqs(1)) Then
                NumConstSites(b) = Z
            Else
                Exit For
            End If
        Next A
        
        Z = 0
    Else
        Z = Z + 1
    End If
Next Y


Y = 1
For x = 1 To Len(StrainSeq(0))
    DiffPosRev(x) = Y
    DiffPos(Y) = x
    If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
        NumConstSites(x) = 0
        DiffPos(Y) = x
        DiffPosRev(x) = Y
         Y = Y + 1
        x = x
    End If
Next x

Dim LSub As Long
Y = Y - 1
LSub = Y
Y = 1
If CircularFlag = 1 Then
    For x = Len(StrainSeq(0)) To 1 Step -1
        
        
        If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
            Exit For
        End If
        DiffPosRev(x) = Y
    Next x
End If


'Map out the unique recombinant genomes on each diffreent plant
Dim WorthDoing() As Byte
ReDim WorthDoing(NextNo)
For x = 1 To SEventNumber
    A = BestEvent(x, 0): b = BestEvent(x, 1)
    If XoverList(A, b).SBPFlag < 3 Then
        WorthDoing(A) = 1
    End If

Next x

Dim SList() As Long
ReDim SList(LSub, 1)
ReDim VSitesMat(LSub, LSub, 3) '  0 = 1000; 1 = 0100; 2 = 0010; 3 = 0001
Call FillVSiteMat(SList(), PermPlantNum(), VSitesMat(), OffsetPerm(), DiffPos(), LSub, SeqNum(), WorthDoing())

Dim ShortEvent() As Long
ReDim ShortEvent(SEventNumber)

'Work out distribution of xoversitelens
Dim XoverSiteLen() As Single
ReDim XoverSiteLen(Len(StrainSeq(0)))
For x = 1 To SEventNumber
    If x > 390 Then
        x = x '5:466
    End If
    A = BestEvent(x, 0): b = BestEvent(x, 1)
    ST = XoverList(A, b).Beginning
    If XoverList(A, b).LHolder < 2 Then
        ShortEvent(x) = 1
    
    
    End If
    If ShortEvent(x) = 0 Then
        For C = 1 To CurrentXOver(A)
            If C <> b Then
                'XX = XOverlist(A, C).Beginning
                If XoverList(A, C).Ending = ST Or XoverList(A, C).Ending = ST - 1 Or XoverList(A, C).Ending = ST + 1 Then
                    If XoverList(A, C).LHolder < 2 Then
                        ShortEvent(x) = 1
                    End If
                End If
            End If
        Next C
    End If
'    If b > 1 Then
'        If XOverlist(A, b - 1).LHolder < 2 Then
'           ShortEvent(X) = 1
'        End If
'    Else
'        If XOverlist(A, CurrentXOver(A)).LHolder < 2 Then
'           ShortEvent(X) = 1
'        End If
'    End If
'    D = XOverlist(A, B).Daughter
'    If PermPlantNum(D) > 0 Then
        If XoverList(A, b).SBPFlag <> 3 And XoverList(A, b).SBPFlag <> 1 And ShortEvent(x) = 0 Then
            XoverSiteLen(NumConstSites(ST)) = XoverSiteLen(NumConstSites(ST)) + 1
            
'            If NumConstSites(ST) < 2 Then
'                'EN = XOverlist(A, b - 1).Beginning
'                X = X
'                XX = XOverlist(A, b).Daughter '132:1111, 147:2566 148:1320, 166:2439 168:265: 171 2061, 175: 2145 175:2150 180:1111 197:2150
'
'                ' 0:  28:1374, 57:2641, 90:272, 98:1310, 101:2210, 110:2596, 110:2597: 131:2173 131:2174, 132
'            End If
            
        End If
'    End If
Next x

Dim total As Single, SmoothBPProb() As Single
ReDim SmoothBPProb(Len(StrainSeq(0)))
For x = 0 To Len(StrainSeq(0))
    total = total + XoverSiteLen(x)
Next x

Dim oDir As String, OutString As String, FF As Long, FF2 As Long
oDir$ = CurDir
ChDir App.Path
ChDrive App.Path


Dim SiteLenList() As Long
ReDim SiteLenList(Len(StrainSeq(0)))
For x = 1 To Len(StrainSeq(0))
    SiteLenList(NumConstSites(x)) = SiteLenList(NumConstSites(x)) + 1
Next x
For x = 0 To Len(StrainSeq(0))
    If x > 0 Then
        SiteLenList(x) = SiteLenList(x) / x
    End If
Next x

FF = FreeFile
Open "testBPs.csv" For Output As #FF

Print #FF, "BP region length, Number this size, Observed number breakpoints"

For x = 0 To Len(StrainSeq(0))
    Print #FF, Str(x) + "," + Str(SiteLenList(x)) + "," + Str(XoverSiteLen(x))
    XoverSiteLen(x) = XoverSiteLen(x) / total
    x = x
Next x
Close #FF
Dim SmoothWin As Long, StartW As Long, EndW As Long, LenSeq As Long
LenSeq = Len(StrainSeq(0))
SmoothWin = 0
For x = 0 To LenSeq
    StartW = x - SmoothWin
    EndW = x + SmoothWin
    If StartW < 0 Then StartW = 0
    If EndW > LenSeq Then EndW = LenSeq
    For Y = StartW To EndW
        SmoothBPProb(x) = SmoothBPProb(x) + XoverSiteLen(x)
    Next Y
    SmoothBPProb(x) = SmoothBPProb(x) / (EndW - StartW + 1)
    x = x
Next x


'work out the "Likelihoods" of the actual recombinants

Dim LowestProb As Double
LowestProb = 1
For x = 1 To Len(StrainSeq(0))
    If SmoothBPProb(x) > 0 Then
        If SmoothBPProb(x) < LowestProb Then
            LowestProb = SmoothBPProb(x)
        End If
    End If
Next x

For x = 1 To Len(StrainSeq(0))
    If SmoothBPProb(x) = 0 Then
        SmoothBPProb(x) = LowestProb
    End If
Next x

Dim PlantProb() As Double, D As Long, CS As Long, SiteOffset As Long, STSub As Long
ReDim PlantProb(PermPlantCount, LSub)
counted = 0
notcounted = 0
For SiteOffset = 0 To LSub - 1
    For x = 1 To SEventNumber
        A = BestEvent(x, 0): b = BestEvent(x, 1)
        If A = 6 Then
            x = x
        End If
        ST = XoverList(A, b).Beginning '61,68,449
        STSub = DiffPosRev(ST)
        STSub = STSub + SiteOffset
        If STSub > LSub Then STSub = STSub - LSub
        STSub = DiffPos(STSub) - 1
        D = PermPlantNum(XoverList(A, b).Daughter)
        If D > 0 Then
            If XoverList(A, b).SBPFlag <> 3 And XoverList(A, b).SBPFlag <> 1 And ShortEvent(x) = 0 Then
                CS = NumConstSites(STSub)
                If CS > LSub Then CS = CS - LSub
                If SmoothBPProb(CS) > 0 Then
                    PlantProb(D, SiteOffset) = PlantProb(D, SiteOffset) + Log(SmoothBPProb(CS))
                   x = x
                   ' counted = counted + 1
                Else
                    PlantProb(D, SiteOffset) = PlantProb(D, SiteOffset) - 10000
                End If
            Else
                x = x
                'notcounted = notcounted + 1
            End If
        End If
    Next x
    x = x
Next SiteOffset
Dim RealProb As Single, BannedOffset() As Byte, ValDiff As Double, RNum As Double
ReDim BannedOffset(PermPlantCount, LSub)
Dim BanOffsetFlag As Long
BanOffsetFlag = 1
If BanOffsetFlag = 1 Then
    For x = 1 To PermPlantCount
        'XX = PlantProb(X)
        RealProb = PlantProb(x, 0)
        For Y = 1 To LSub
            If RealProb > PlantProb(x, Y) Then
                ValDiff = PlantProb(x, Y) - RealProb
                If ValDiff < 10 Then
                    ValDiff = 2.718 ^ ValDiff
                Else
                    ValDiff = 2.718 ^ 10
                End If
                RNum = Rnd
                If RNum >= ValDiff Then
                    BannedOffset(x, Y) = 1
                Else
                    x = x
                End If
            Else
                x = x
            End If
        Next Y
    Next x
End If
'Total = 0
'For X = 1 To Len(StrainSeq(0))
'    XoverSiteLen(X) = XoverSiteLen(X) / X
'    Total = Total + XoverSiteLen(X)
'Next X
'XoverSiteLen(0) = 0
'For X = 1 To Len(StrainSeq(0))
'    XoverSiteLen(X) = XoverSiteLen(X) / Total
'    X = X
'Next X
Dim ChiResult() As Single, ChiResultP() As Single
ReDim ChiResult(LSub, LSub), ChiResultP(LSub, LSub)

'Call FillchiResult(LSub, ChiResult(), VSitesMat())

Dim TN() As Single, TotNucs As Single, TV1 As Single, TV2 As Single
ReDim TN(LSub, LSub, 1)
For x = 1 To LSub - 1
    For Y = x + 1 To LSub
        
        TotNucs = (VSitesMat(x, Y, 0) + VSitesMat(x, Y, 1) + VSitesMat(x, Y, 2) + VSitesMat(x, Y, 3)) / 2
        TN(x, Y, 0) = Abs(VSitesMat(x, Y, 0) - TotNucs) + Abs(VSitesMat(x, Y, 3) - TotNucs)
        TN(x, Y, 1) = Abs(VSitesMat(x, Y, 1) - TotNucs) + Abs(VSitesMat(x, Y, 2) - TotNucs)
    Next Y
    
Next x

'Now go through, make 100 perms per plant and select the perm for each plant with the closest pattren of xoversitelens to the over-all pattern
Dim SListP() As Long
Rnd (-BSRndNumSeed)
Dim Perm As Long, NumPerms As Long, PVSiteMap() As Long, VSitesMatP() As Long, HigherMat() As Single, LowerMat() As Single, HigherSite() As Single, LowerSite() As Single
NumPerms = 500000
ReDim HigherMat(LSub, LSub, 5), LowerMat(LSub, LSub, 5)
ReDim HigherSite(LSub, 1), LowerSite(LSub, 1)
Dim ChiHigher() As Long
ReDim ChiHigher(LSub, LSub)
For Perm = 1 To NumPerms
    ReDim SListP(LSub, 1)
    ReDim OffsetPerm(PermPlantCount)
    For x = 0 To PermPlantCount
        Do
            OffsetPerm(x) = CLng(((LSub - 1) * Rnd))
            If BannedOffset(x, OffsetPerm(x)) = 0 Then
                Exit Do
            
            End If
            'Exit Do
        Loop
        'X = X
'        If OffsetPerm(X) = 1 Then
'            X = X
'        End If
'        If OffsetPerm(X) = LSub Then
'            X = X
'        End If
    Next x
    
    Dim ExpectV As Single
    ReDim VSitesMatP(LSub, LSub, 3) '  0 = 1000; 1 = 0100; 2 = 0010; 3 = 0001
    Call FillVSiteMat(SListP(), PermPlantNum(), VSitesMatP(), OffsetPerm(), DiffPos, LSub, SeqNum(), WorthDoing())
    'Call FillchiResult(LSub, ChiResultP(), VSitesMatP())
    
    
    If x = x Then
    
        Dummy = TestPerms2(LSub, UBound(ChiResult, 1), UBound(ChiResult, 2), UBound(ChiResult, 1), UBound(VSitesMatP, 1), UBound(VSitesMatP, 2), HigherMat(0, 0, 0), LowerMat(0, 0, 0), VSitesMatP(0, 0, 0), VSitesMat(0, 0, 0), ChiResult(0, 0), ChiResultP(0, 0), ChiHigher(0, 0), TN(0, 0, 0))
    Else
    
        For x = 1 To LSub
            
    '        If SListP(X, 0) >= SList(X, 0) Then
    '            HigherSite(X, 0) = HigherSite(X, 0) + 1
    '        End If
    '        If SListP(X, 0) <= SList(X, 0) Then
    '            LowerSite(X, 0) = LowerSite(X, 0) + 1
    '        End If
    '        If SListP(X, 1) >= SList(X, 1) Then
    '            HigherSite(X, 1) = HigherSite(X, 1) + 1
    '        End If
    '        If SListP(X, 1) <= SList(X, 1) Then
    '            LowerSite(X, 1) = LowerSite(X, 1) + 1
    '        End If
            For Y = x + 1 To LSub
'                If ChiResultP(X, Y) >= ChiResult(X, Y) Then
'                    ChiHigher(X, Y) = ChiHigher(X, Y) + 1
'                End If
                
                    
                If VSitesMatP(x, Y, 0) >= VSitesMat(x, Y, 0) Then
                    HigherMat(x, Y, 0) = HigherMat(x, Y, 0) + 1
                End If
                
                If VSitesMatP(x, Y, 3) >= VSitesMat(x, Y, 3) Then
                    HigherMat(x, Y, 3) = HigherMat(x, Y, 3) + 1
                End If
                
'                    If VSitesMatP(X, Y, Z) <= VSitesMat(X, Y, Z) Then
'                        LowerMat(X, Y, Z) = LowerMat(X, Y, Z) + 1
'                    End If
                
                TotNucs = (VSitesMatP(x, Y, 0) + VSitesMatP(x, Y, 1) + VSitesMatP(x, Y, 2) + VSitesMatP(x, Y, 3)) / 2
                TV1 = Abs(VSitesMatP(x, Y, 0) - TotNucs) + Abs(VSitesMatP(x, Y, 3) - TotNucs)
                TV2 = Abs(VSitesMatP(x, Y, 1) - TotNucs) + Abs(VSitesMatP(x, Y, 2) - TotNucs)
                If TV1 <= TN(x, Y, 0) Then
                    HigherMat(x, Y, 4) = HigherMat(x, Y, 4) + 1
                End If
'                If TV2 <= TN(X, Y, 1) Then
'                    HigherMat(X, Y, 5) = HigherMat(X, Y, 5) + 1
'                End If
'                If TV1 >= TN(X, Y, 0) Then
'                    LowerMat(X, Y, 4) = LowerMat(X, Y, 4) + 1
'                End If
'                If TV2 >= TN(X, Y, 1) Then
'                    LowerMat(X, Y, 5) = LowerMat(X, Y, 5) + 1
'                End If
            Next Y
        Next x
    End If
    SS = Abs(GetTickCount)
    If Abs(SS - LSS) > 500 Then
        LSS = SS
        Form1.SSPanel1.Caption = Trim(Str(Perm)) + " of " + Trim(Str(NumPerms)) + " permutations completed"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
Next Perm




FF = FreeFile
Open "testSites.csv" For Output As #FF
FF2 = FreeFile
Open "testMat.csv" For Output As #FF2
Print #FF, "Site No, AlignPos, PosInP1,  P1 H, P1 L, P2 H, P2 L"
Print #FF2, "Site1, Site2, AlignPos1, AlignPos2, PosSite1InP1,PosSite2InP1, II, IO, OI, OO, 1000 H, 0001 H,  1001 H,"
Dim PVCutoff As Single, Outstring2 As String
PVCutoff = 0.05
Dim P1Pos() As Long, NGP As Long
ReDim P1Pos(Len(StrainSeq(0)))
P1 = ParentSeqs(0)
NGP = 0
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, P1) <> 46 Then
        NGP = NGP + 1
    End If
    P1Pos(x) = NGP
Next x

For x = 1 To LSub
'    If X = 291 Then
'        X = X
'    End If
    ExpectV = (SList(x, 0) + SList(x, 1)) / 2
    HigherSite(x, 0) = ((SList(x, 0) - ExpectV) ^ 2) / ExpectV
    HigherSite(x, 0) = ChiPVal(CDbl(HigherSite(x, 0)))
    XX = chi2(CDbl(HigherSite(x, 0)), 1)
    XX = chi2(3.8, 1)
    HigherSite(x, 1) = ((SList(x, 1) - ExpectV) ^ 2) / ExpectV
    HigherSite(x, 1) = ChiPVal(CDbl(HigherSite(x, 1)))
    If SList(x, 0) > SList(x, 1) Then
        HigherSite(x, 1) = 1 - HigherSite(x, 1)
    ElseIf SList(x, 0) < SList(x, 1) Then
        HigherSite(x, 0) = 1 - HigherSite(x, 0)
    End If
    LowerSite(x, 1) = 1 - HigherSite(x, 1)
    LowerSite(x, 0) = 1 - HigherSite(x, 0)
    
    OutString = Trim(Str(x)) + "," + Trim(Str(DiffPos(x))) + "," + Trim(Str(P1Pos(DiffPos(x)))) + ","
    For Z = 0 To 1
       ' HigherSite(X, Z) = HigherSite(X, Z) '/ NumPerms
       ' LowerSite(X, Z) = LowerSite(X, Z) ' / NumPerms
        OutString = OutString + Trim(Str(HigherSite(x, Z))) + "," + Trim(Str(LowerSite(x, Z))) + ","
    Next Z
    Outstring2 = OutString
    'Print #FF, OutString
    Dim DoneSitePrint() As Long
    ReDim DoneSitePrint(LSub)
    For Y = x + 1 To LSub
        OutString = Trim(Str(x)) + "," + Trim(Str(Y)) + "," + Trim(Str(DiffPos(x))) + "," + Trim(Str(DiffPos(Y))) + "," + Trim(Str(P1Pos(DiffPos(x)))) + "," + Trim(Str(P1Pos(DiffPos(Y)))) + ","
        'OutString = OutString + Trim(Str(ChiHigher(X, Y) / NumPerms)) + ","
'        If ChiHigher(X, Y) / NumPerms < PVCutoff And LowerMat(X, Y, 5) < PVCutoff Then
            If (HigherMat(x, Y, 4) / NumPerms) < PVCutoff Then
                If (HigherMat(x, Y, 3) / NumPerms) < PVCutoff Then
                    If (HigherMat(x, Y, 0) / NumPerms) < PVCutoff Then
                        OutString = OutString + Str(VSitesMat(x, Y, 0)) + "," + Str(VSitesMat(x, Y, 1)) + "," + Str(VSitesMat(x, Y, 2)) + "," + Str(VSitesMat(x, Y, 3)) + ","
                        For Z = 0 To 5
                            If Z = 0 Or Z = 3 Or Z = 4 Then
                                HigherMat(x, Y, Z) = HigherMat(x, Y, Z) / NumPerms
                                'LowerMat(X, Y, Z) = LowerMat(X, Y, Z) / NumPerms
                                OutString = OutString + Trim(Str(HigherMat(x, Y, Z))) + ","
                                HigherMat(Y, x, Z) = HigherMat(x, Y, Z)
                            End If
                            'LowerMat(Y, X, Z) = LowerMat(X, Y, Z)
                        Next Z
                        Print #FF2, OutString
'            Else
'                DoneSitePrint(X) = 1: DoneSitePrint(Y) = 1
'            End If
                    End If
                End If
            End If
    Next Y
    'If DoneSitePrint(X) = 1 And (HigherSite(X, 0) < 0.05 Or HigherSite(X, 1) < 0.05) Then
    Print #FF, Outstring2
    'End If
Next x

Close #FF
Close #FF2



ChDir oDir
ChDrive oDir

End Sub

Public Sub ExRecAssociationTest2()
Dim DiffPos() As Long, DiffPosRev() As Long, VSitesMat() As Long, NumConstSites() As Long, A As Long, b As Long, StartX As Long, OffsetPerm() As Long
ReDim DiffPos(Len(StrainSeq(0))), DiffPosRev(Len(StrainSeq(0))), NumConstSites(Len(StrainSeq(0)))



ReDim OffsetPerm(PermPlantCount)

''Get the positions of the informative sites
'
If CircularFlag = 1 Then
    'track back to last variable site
    For x = Len(StrainSeq(0)) To 1 Step -1
        If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
            Exit For
        End If
    Next x
    StartX = x + 1
    StartX = -(Len(StrainSeq(0)) - StartX)
Else
    StartX = 1
End If


Z = 0
For Y = StartX To Len(StrainSeq(0))
    If Y > 0 Then
        x = Y
    Else
        x = Len(StrainSeq(0)) + Y
    End If
    
    
    If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
        
        
        For A = x - 1 To -Len(StrainSeq(0)) Step -1
            If A > 0 Then
                b = A
            Else
                b = Len(StrainSeq(0)) + A
            End If
            If SeqNum(b, ParentSeqs(0)) = SeqNum(b, ParentSeqs(1)) Then
                NumConstSites(b) = Z
            Else
                Exit For
            End If
        Next A
        
        Z = 0
    Else
        Z = Z + 1
    End If
Next Y


Y = 1
For x = 1 To Len(StrainSeq(0))
    DiffPosRev(x) = Y
    DiffPos(Y) = x
    If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
        NumConstSites(x) = 0
        DiffPos(Y) = x
        DiffPosRev(x) = Y
         Y = Y + 1
        x = x
    End If
Next x

Dim LSub As Long
Y = Y - 1
LSub = Y
Y = 1
If CircularFlag = 1 Then
    For x = Len(StrainSeq(0)) To 1 Step -1
        
        
        If SeqNum(x, ParentSeqs(0)) <> SeqNum(x, ParentSeqs(1)) Then
            Exit For
        End If
        DiffPosRev(x) = Y
    Next x
End If


'Map out the unique recombinant genomes on each diffreent plant
Dim WorthDoing() As Byte
ReDim WorthDoing(NextNo)
For x = 1 To SEventNumber
    A = BestEvent(x, 0): b = BestEvent(x, 1)
    If XoverList(A, b).SBPFlag < 3 Then
        WorthDoing(A) = 1
    End If

Next x

Dim SList() As Long
ReDim SList(LSub, 1)
ReDim VSitesMat(LSub, LSub, 3) '  0 = 1000; 1 = 0100; 2 = 0010; 3 = 0001
Call FillVSiteMat(SList(), PermPlantNum(), VSitesMat(), OffsetPerm(), DiffPos(), LSub, SeqNum(), WorthDoing())



'Work out distribution of xoversitelens
Dim XoverSiteLen() As Single
ReDim XoverSiteLen(Len(StrainSeq(0)))
For x = 1 To SEventNumber
    
    A = BestEvent(x, 0): b = BestEvent(x, 1)
    ST = XoverList(A, b).Beginning
'    D = XOverlist(A, B).Daughter
'    If PermPlantNum(D) > 0 Then
        If XoverList(A, b).SBPFlag <> 3 And XoverList(A, b).SBPFlag <> 1 Then
            XoverSiteLen(NumConstSites(ST)) = XoverSiteLen(NumConstSites(ST)) + 1
        End If
'    End If
Next x

Dim total As Single, SmoothBPProb() As Single
ReDim SmoothBPProb(Len(StrainSeq(0)))
For x = 0 To Len(StrainSeq(0))
    total = total + XoverSiteLen(x)
Next x
For x = 0 To Len(StrainSeq(0))
    XoverSiteLen(x) = XoverSiteLen(x) / total
    x = x
Next x

Dim SmoothWin As Long, StartW As Long, EndW As Long, LenSeq As Long
LenSeq = Len(StrainSeq(0))
SmoothWin = 1
For x = 0 To LenSeq
    StartW = x - SmoothWin
    EndW = x + SmoothWin
    If StartW < 0 Then StartW = 0
    If EndW > LenSeq Then EndW = LenSeq
    For Y = StartW To EndW
        SmoothBPProb(x) = SmoothBPProb(x) + XoverSiteLen(x)
    Next Y
    SmoothBPProb(x) = SmoothBPProb(x) / (EndW - StartW + 1)
    x = x
Next x


'work out the "Likelihoods" of the actual recombinants

Dim LowestProb As Double
LowestProb = 1
For x = 1 To Len(StrainSeq(0))
    If SmoothBPProb(x) > 0 Then
        If SmoothBPProb(x) < LowestProb Then
            LowestProb = SmoothBPProb(x)
        End If
    End If
Next x

For x = 1 To Len(StrainSeq(0))
    If SmoothBPProb(x) = 0 Then
        SmoothBPProb(x) = LowestProb
    End If
Next x

Dim PlantProb() As Double, D As Long, CS As Long, SiteOffset As Long, STSub As Long
ReDim PlantProb(PermPlantCount, LSub)
For SiteOffset = 0 To LSub - 1
    For x = 1 To SEventNumber
        A = BestEvent(x, 0): b = BestEvent(x, 1)
        ST = XoverList(A, b).Beginning
        STSub = DiffPosRev(ST)
        STSub = STSub + SiteOffset
        If STSub > LSub Then STSub = STSub - LSub
        STSub = DiffPos(STSub) - 1
        D = PermPlantNum(XoverList(A, b).Daughter)
        If D > 0 Then
            If XoverList(A, b).SBPFlag <> 3 And XoverList(A, b).SBPFlag <> 1 Then
                CS = NumConstSites(STSub)
                If CS > LSub Then CS = CS - LSub
                If SmoothBPProb(CS) > 0 Then
                    PlantProb(D, SiteOffset) = PlantProb(D, SiteOffset) + Log(SmoothBPProb(CS))
                Else
                    PlantProb(D, SiteOffset) = PlantProb(D, SiteOffset) - 10000
                End If
            End If
        End If
    Next x
Next SiteOffset
Dim RealProb As Single, BannedOffset() As Byte, ValDiff As Double, RNum As Double
ReDim BannedOffset(PermPlantCount, LSub)
For x = 1 To PermPlantCount
    'XX = PlantProb(X)
    RealProb = PlantProb(x, 0)
    For Y = 1 To LSub
        If RealProb > PlantProb(x, Y) Then
            ValDiff = PlantProb(x, Y) - RealProb
            If ValDiff < 10 Then
                ValDiff = 2.718 ^ ValDiff
            Else
                ValDiff = 2.718 ^ 10
            End If
            RNum = Rnd
            If RNum >= ValDiff Then
                BannedOffset(x, Y) = 1
            Else
                x = x
            End If
        Else
            x = x
        End If
    Next Y
Next x

'Total = 0
'For X = 1 To Len(StrainSeq(0))
'    XoverSiteLen(X) = XoverSiteLen(X) / X
'    Total = Total + XoverSiteLen(X)
'Next X
'XoverSiteLen(0) = 0
'For X = 1 To Len(StrainSeq(0))
'    XoverSiteLen(X) = XoverSiteLen(X) / Total
'    X = X
'Next X
Dim ChiResult() As Single, ChiResultP() As Single
ReDim ChiResult(LSub, LSub), ChiResultP(LSub, LSub)

Call FillchiResult(LSub, ChiResult(), VSitesMat())


'Now go through, make 100 perms per plant and select the perm for each plant with the closest pattren of xoversitelens to the over-all pattern
Dim SListP() As Long
Rnd (-BSRndNumSeed)
Dim Perm As Long, NumPerms As Long, PVSiteMap() As Long, VSitesMatP() As Long, HigherMat() As Single, LowerMat() As Single, HigherSite() As Single, LowerSite() As Single
NumPerms = 10000
ReDim HigherMat(LSub, LSub, 5), LowerMat(LSub, LSub, 5)
ReDim HigherSite(LSub, 1), LowerSite(LSub, 1)
Dim ChiHigher() As Long
ReDim ChiHigher(LSub, LSub)
For Perm = 1 To NumPerms
    ReDim SListP(LSub, 1)
    ReDim OffsetPerm(PermPlantCount)
    For x = 0 To PermPlantCount
        Do
            OffsetPerm(x) = CLng(((LSub - 1) * Rnd))
            If BannedOffset(x, OffsetPerm(x)) = 0 Then Exit Do
            Exit Do
        Loop
        'X = X
'        If OffsetPerm(X) = 1 Then
'            X = X
'        End If
'        If OffsetPerm(X) = LSub Then
'            X = X
'        End If
    Next x
    
    Dim ExpectV As Single
    ReDim VSitesMatP(LSub, LSub, 3) '  0 = 1000; 1 = 0100; 2 = 0010; 3 = 0001
    Call FillVSiteMat(SListP(), PermPlantNum(), VSitesMatP(), OffsetPerm(), DiffPos, LSub, SeqNum(), WorthDoing())
    Call FillchiResult(LSub, ChiResultP(), VSitesMatP())
    
    
    If x = x Then
    
        Dummy = TestPerms(LSub, UBound(ChiResult, 1), UBound(ChiResult, 2), UBound(ChiResult, 1), UBound(VSitesMatP, 1), UBound(VSitesMatP, 2), HigherMat(0, 0, 0), LowerMat(0, 0, 0), VSitesMatP(0, 0, 0), VSitesMat(0, 0, 0), ChiResult(0, 0), ChiResultP(0, 0), ChiHigher(0, 0))
    Else
    
        For x = 1 To LSub
            
    '        If SListP(X, 0) >= SList(X, 0) Then
    '            HigherSite(X, 0) = HigherSite(X, 0) + 1
    '        End If
    '        If SListP(X, 0) <= SList(X, 0) Then
    '            LowerSite(X, 0) = LowerSite(X, 0) + 1
    '        End If
    '        If SListP(X, 1) >= SList(X, 1) Then
    '            HigherSite(X, 1) = HigherSite(X, 1) + 1
    '        End If
    '        If SListP(X, 1) <= SList(X, 1) Then
    '            LowerSite(X, 1) = LowerSite(X, 1) + 1
    '        End If
            For Y = x + 1 To LSub
                If ChiResultP(x, Y) >= ChiResult(x, Y) Then
                    ChiHigher(x, Y) = ChiHigher(x, Y) + 1
                End If
                For Z = 0 To 3
                    
                    If VSitesMatP(x, Y, Z) >= VSitesMat(x, Y, Z) Then
                        HigherMat(x, Y, Z) = HigherMat(x, Y, Z) + 1
                    End If
                    If VSitesMatP(x, Y, Z) <= VSitesMat(x, Y, Z) Then
                        LowerMat(x, Y, Z) = LowerMat(x, Y, Z) + 1
                    End If
                Next Z
                If VSitesMatP(x, Y, 0) + VSitesMatP(x, Y, 3) >= VSitesMat(x, Y, 0) + VSitesMat(x, Y, 3) Then
                    HigherMat(x, Y, 4) = HigherMat(x, Y, 4) + 1
                End If
                If VSitesMatP(x, Y, 1) + VSitesMatP(x, Y, 2) >= VSitesMat(x, Y, 1) + VSitesMat(x, Y, 2) Then
                    HigherMat(x, Y, 5) = HigherMat(x, Y, 5) + 1
                End If
                If VSitesMatP(x, Y, 0) + VSitesMatP(x, Y, 3) <= VSitesMat(x, Y, 0) + VSitesMat(x, Y, 3) Then
                    LowerMat(x, Y, 4) = LowerMat(x, Y, 4) + 1
                End If
                If VSitesMatP(x, Y, 1) + VSitesMatP(x, Y, 2) <= VSitesMat(x, Y, 1) + VSitesMat(x, Y, 2) Then
                    LowerMat(x, Y, 5) = LowerMat(x, Y, 5) + 1
                End If
            Next Y
        Next x
    End If
    SS = Abs(GetTickCount)
    If Abs(SS - LSS) > 500 Then
        LSS = SS
        Form1.SSPanel1.Caption = Trim(Str(Perm)) + " of " + Trim(Str(NumPerms)) + " permutations completed"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
Next Perm



Dim oDir As String, OutString As String, FF As Long, FF2 As Long
oDir$ = CurDir
ChDir App.Path
ChDrive App.Path
FF = FreeFile
Open "testSites.csv" For Output As #FF
FF2 = FreeFile
Open "testMat.csv" For Output As #FF2
Print #FF, "Site No, AlignPos, PosInP1,  P1 H, P1 L, P2 H, P2 L"
Print #FF2, "Site1, Site2, AlignPos1, AlignPos2, PosSite1InP1,PosSite2InP1, ChiP, 1000 H, 1000 L, 0100 H, 0100 L,0010 H, 0010 L,0001 H, 0001 L, 1001 H, 1001 L, 0110 H, 0110 L,"
Dim PVCutoff As Single, Outstring2 As String
PVCutoff = 0.05
Dim P1Pos() As Long, NGP As Long
ReDim P1Pos(Len(StrainSeq(0)))
P1 = ParentSeqs(0)
NGP = 0
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, P1) <> 46 Then
        NGP = NGP + 1
    End If
    P1Pos(x) = NGP
Next x

For x = 1 To LSub
'    If X = 291 Then
'        X = X
'    End If
    ExpectV = (SList(x, 0) + SList(x, 1)) / 2
    HigherSite(x, 0) = ((SList(x, 0) - ExpectV) ^ 2) / ExpectV
    HigherSite(x, 0) = ChiPVal(CDbl(HigherSite(x, 0)))
    XX = chi2(CDbl(HigherSite(x, 0)), 1)
    XX = chi2(3.8, 1)
    HigherSite(x, 1) = ((SList(x, 1) - ExpectV) ^ 2) / ExpectV
    HigherSite(x, 1) = ChiPVal(CDbl(HigherSite(x, 1)))
    If SList(x, 0) > SList(x, 1) Then
        HigherSite(x, 1) = 1 - HigherSite(x, 1)
    ElseIf SList(x, 0) < SList(x, 1) Then
        HigherSite(x, 0) = 1 - HigherSite(x, 0)
    End If
    LowerSite(x, 1) = 1 - HigherSite(x, 1)
    LowerSite(x, 0) = 1 - HigherSite(x, 0)
    
    OutString = Trim(Str(x)) + "," + Trim(Str(DiffPos(x))) + "," + Trim(Str(P1Pos(DiffPos(x)))) + ","
    For Z = 0 To 1
       ' HigherSite(X, Z) = HigherSite(X, Z) '/ NumPerms
       ' LowerSite(X, Z) = LowerSite(X, Z) ' / NumPerms
        OutString = OutString + Trim(Str(HigherSite(x, Z))) + "," + Trim(Str(LowerSite(x, Z))) + ","
    Next Z
    Outstring2 = OutString
    'Print #FF, OutString
    Dim DoneSitePrint() As Long
    ReDim DoneSitePrint(LSub)
    For Y = x + 1 To LSub
        OutString = Trim(Str(x)) + "," + Trim(Str(Y)) + "," + Trim(Str(DiffPos(x))) + "," + Trim(Str(DiffPos(Y))) + "," + Trim(Str(P1Pos(DiffPos(x)))) + "," + Trim(Str(P1Pos(DiffPos(Y)))) + ","
        OutString = OutString + Trim(Str(ChiHigher(x, Y) / NumPerms)) + ","
        If ChiHigher(x, Y) / NumPerms < PVCutoff And LowerMat(x, Y, 5) < PVCutoff Then
            If HigherMat(x, Y, 3) / NumPerms < PVCutoff Then
                For Z = 0 To 5
                    HigherMat(x, Y, Z) = HigherMat(x, Y, Z) / NumPerms
                    LowerMat(x, Y, Z) = LowerMat(x, Y, Z) / NumPerms
                    OutString = OutString + Trim(Str(HigherMat(x, Y, Z))) + "," + Trim(Str(LowerMat(x, Y, Z))) + ","
                    HigherMat(Y, x, Z) = HigherMat(x, Y, Z)
                    LowerMat(Y, x, Z) = LowerMat(x, Y, Z)
                Next Z
                Print #FF2, OutString
            Else
                DoneSitePrint(x) = 1: DoneSitePrint(Y) = 1
            End If
        End If
    Next Y
    If DoneSitePrint(x) = 1 And (HigherSite(x, 0) < 0.05 Or HigherSite(x, 1) < 0.05) Then
        Print #FF, Outstring2
    End If
Next x

Close #FF
Close #FF2



ChDir oDir
ChDrive oDir

End Sub



Public Sub Fade( _
  ByRef cTo As cDibSection, _
  ByVal lAmount As Long _
  )
Dim bDib() As Byte
Dim x As Long, Y As Long
Dim xMax As Long, yMax As Long
Dim LB As Long, lG As Long, lR As Long
Dim lA As Long, lA2 As Long
Dim lTIme As Long
Dim tSA As SAFEARRAY2D
 
  ' have the local matrix point to bitmap pixels
  With tSA
    .cbElements = 1
    .cDims = 2
    .Bounds(0).lLbound = 0
    .Bounds(0).cElements = cTo.Height
    .Bounds(1).lLbound = 0
    .Bounds(1).cElements = cTo.BytesPerScanLine
    .pvData = cTo.DIBSectionBitsPtr
  End With
  CopyMemory ByVal VarPtrArray(bDib), VarPtr(tSA), 4
   
  yMax = cTo.Height - 1
  xMax = cTo.Width - 1
 
  For x = 0 To (xMax * 3) Step 3
    For Y = 0 To yMax
      LB = lAmount * bDib(x, Y) \ 255
      lG = lAmount * bDib(x + 1, Y) \ 255
      lR = lAmount * bDib(x + 2, Y) \ 255
      bDib(x, Y) = LB
      bDib(x + 1, Y) = lG
      bDib(x + 2, Y) = lR
    Next Y
  Next x

  CopyMemory ByVal VarPtrArray(bDib), 0&, 4
 


End Sub

Public Sub DrawDIB(ByRef cTo As cDibSection)

Dim bDib() As Byte
Dim x As Long, Y As Long
Dim xMax As Long, yMax As Long
Dim LB As Long, lG As Long, lR As Long
Dim lA As Long, lA2 As Long
Dim lTIme As Long
Dim tSA As SAFEARRAY2D
 
  ' have the local matrix point to bitmap pixels
  With tSA
    .cbElements = 1
    .cDims = 2
    .Bounds(0).lLbound = 0
    .Bounds(0).cElements = cTo.Height
    .Bounds(1).lLbound = 0
    .Bounds(1).cElements = cTo.BytesPerScanLine
    .pvData = cTo.DIBSectionBitsPtr
  End With
  CopyMemory ByVal VarPtrArray(bDib), VarPtr(tSA), 4
   
  yMax = cTo.Height - 1
  xMax = cTo.Width - 1
 
  For x = 0 To (xMax * 3) Step 3
    For Y = 0 To yMax
      LB = lAmount * bDib(x, Y) \ 255
      lG = lAmount * bDib(x + 1, Y) \ 255
      lR = lAmount * bDib(x + 2, Y) \ 255
      bDib(x, Y) = LB
      bDib(x + 1, Y) = lG
      bDib(x + 2, Y) = lR
    Next Y
  Next x

  CopyMemory ByVal VarPtrArray(bDib), 0&, 4
 


End Sub


Public Sub CheckGenes(GeneList() As GenomeFeatureDefine, GeneNumber As Long)
Dim DoneTruncation() As Long, StartFrame() As Long, StartFrameRC() As Long, RCStart As Long, ForEnd As Long, MaxLen As Long, CurLen As Long, Curstart As Long, WinFrame As Long, StartNum As Long, StartNumRC As Long, StartPosX() As Long, StartPosRC(), GeneCoords() As Long, ORFSupport() As Long, MapBack() As Long, MapBackRC() As Long, CurFrame As Single, Frame() As Long, FrameRC() As Long, LSeq As Long, Seq As String, SeqRC As String, x As Long, Y As Long, Z As Long, A As Long, b As Long, CurChar As Long, RevMat() As Byte, StopPos() As Long, StopNum As Long, StopNumRC As Long, StopPosRC() As Long
Dim MapAlign() As Long, MapAlignRC() As Long
LSeq = Len(StrainSeq(0))
ReDim RevMat(128)
RevMat(65) = 84
RevMat(67) = 71
RevMat(71) = 67
RevMat(84) = 65

Dim ORI(2) As Byte
If GeneNumber = 0 Then
    ORI(1) = 1
    ORI(2) = 1
Else
    For x = 0 To GeneNumber
        ORI(GeneList(x).Orientation) = 1
    Next x
End If


ReDim ORFSupport(GeneNumber, PermNextno) 'this is a count of the stopcodons in the best frame
ReDim GeneCoords(GeneNumber, PermNextno, 2) 'bounds of the stopcodons and of the "best" inframe ATG
Dim StartPos As Long, EndPos As Long, FrameCount() As Long

For Z = 0 To PermNextno
    If ORI(1) = 1 And ORI(2) = 1 Or x = x Then
        'make gap free sequence and reverse complement
        
        ReDim MapBack(LSeq), MapBackRC(LSeq)
        ReDim MapAlign(LSeq), MapAlignRC(LSeq)
        Seq = String(LSeq, " ")
        SeqRC = Seq
        A = 0
        b = LSeq + 1
        For x = 1 To LSeq
            CurChar = SeqNum(x, Z) - 1
            If SeqNum(x, Z) <> 46 Then
                A = A + 1
                b = b - 1
                Mid(Seq, A, 1) = Chr(CurChar)
                Mid(SeqRC, b, 1) = Chr(RevMat(CurChar))
                MapBack(x) = A
                MapAlign(A) = x
                MapBackRC(x) = b
                MapAlignRC(b) = x
                
                x = x
            End If
        
        Next x
        RCStart = b
        ForEnd = A
        
        'get stop codon positions(TAG, TAA, TGA)
        'SeqRC = Trim(SeqRC)'trimming messes up the mapback
        'Seq = Trim(Seq)
        'tag
        'XX = Right$(SeqRC, 10)
        ReDim StopPos(LSeq), StartPosX(LSeq)
        StopNum = 0
        StartNum = 0
        
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, Seq, "ATG", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StartNum = StartNum + 1
            StartPosX(StartNum) = Pos
        
        Loop
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, Seq, "TAG", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNum = StopNum + 1
            StopPos(StopNum) = Pos
        
        Loop
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, Seq, "TAA", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNum = StopNum + 1
            StopPos(StopNum) = Pos
        
        Loop
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, Seq, "TGA", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNum = StopNum + 1
            StopPos(StopNum) = Pos
        
        Loop
        
        
        ReDim Frame(LSeq)
        For x = 1 To StopNum
            CurFrame = StopPos(x) / 3
            CurFrame = (CurFrame - Int(CurFrame)) * 3 + 1
            Frame(StopPos(x)) = CLng(CurFrame)
        Next x
        
        ReDim StartFrame(LSeq)
        For x = 1 To StartNum
            CurFrame = StartPosX(x) / 3
            CurFrame = (CurFrame - Int(CurFrame)) * 3 + 1
            StartFrame(StartPosX(x)) = CLng(CurFrame)
        Next x
        
        ReDim StopPosRC(LSeq), StartPosRC(LSeq)
        StopNumRC = 0
        StartNumRC = 0
        
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, SeqRC, "ATG", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StartNumRC = StartNumRC + 1
            StartPosRC(StartNumRC) = Pos
        
        Loop
        
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, SeqRC, "TAG", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNumRC = StopNumRC + 1
            StopPosRC(StopNumRC) = Pos
        
        Loop
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, SeqRC, "TAA", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNumRC = StopNumRC + 1
            StopPosRC(StopNumRC) = Pos
        
        Loop
        
        Pos = 0
        Do
            Pos = InStr(Pos + 1, SeqRC, "TGA", vbBinaryCompare)
            If Pos = 0 Then Exit Do
            StopNumRC = StopNumRC + 1
            StopPosRC(StopNumRC) = Pos
        
        Loop
        
        
        ReDim FrameRC(LSeq)
        For x = 1 To StopNumRC
            CurFrame = StopPosRC(x) / 3
            CurFrame = (CurFrame - Int(CurFrame)) * 3 + 1
            FrameRC(StopPosRC(x)) = CLng(CurFrame)
            
        Next x
        
        ReDim StartFrameRC(LSeq)
        For x = 1 To StartNumRC
            CurFrame = StartPosRC(x) / 3
            CurFrame = (CurFrame - Int(CurFrame)) * 3 + 1
            StartFrameRC(StartPosRC(x)) = CLng(CurFrame)
        Next x
        
        
        
        For x = 1 To GeneNumber
            ReDim FrameCount(3)
            If GeneList(x).StartInAlign > -1 Then
                If GeneList(x).Orientation = 1 Then
                    StartPos = MapBack(GeneList(x).StartInAlign)
                    EndPos = MapBack(GeneList(x).EndInAlign)
                    If StartPos < EndPos Then
                        For Y = StartPos To EndPos
                            FrameCount(Frame(Y)) = FrameCount(Frame(Y)) + 1
                        Next Y
                    Else
                        For Y = StartPos To ForEnd
                            FrameCount(Frame(Y)) = FrameCount(Frame(Y)) + 1
                        Next Y
                        For Y = 1 To EndPos
                            FrameCount(Frame(Y)) = FrameCount(Frame(Y)) + 1
                        Next Y
                    End If
                    
                    
                ElseIf GeneList(x).Orientation = 2 Then
                    StartPos = MapBackRC(GeneList(x).StartInAlign)
                    EndPos = MapBackRC(GeneList(x).EndInAlign)
                    If StartPos < EndPos Then
                        For Y = StartPos To EndPos
                            FrameCount(FrameRC(Y)) = FrameCount(FrameRC(Y)) + 1
                        Next Y
                    Else
                        For Y = StartPos To LSeq
                            FrameCount(FrameRC(Y)) = FrameCount(FrameRC(Y)) + 1
                        Next Y
                        For Y = RCStart To EndPos
                            FrameCount(FrameRC(Y)) = FrameCount(FrameRC(Y)) + 1
                        Next Y
                    End If
                End If
                If FrameCount(1) <= FrameCount(2) Then
                    If FrameCount(1) <= FrameCount(3) Then
                        WinFrame = 1
                    Else
                        WinFrame = 3
                    End If
                ElseIf FrameCount(2) <= FrameCount(3) Then
                    WinFrame = 2
                Else
                    WinFrame = 3
                End If
            End If
            ORFSupport(x, Z) = FrameCount(WinFrame)
            'find the bounds of the biggest winframe and find the start codon closest to the start
            
            MaxLen = 0
            CurLen = 0
'            Startpos = 1
'            EndPos = 842
            GeneCoords(x, Z, 0) = StartPos
            GeneCoords(x, Z, 1) = EndPos
            If GeneList(x).Orientation = 1 Then
                If ORFSupport(x, Z) > 0 Then
                    Curstart = StartPos
                    
                
                    If StartPos < EndPos Then
                        
                        For Y = StartPos To EndPos
                            If Frame(Y) = WinFrame Then
                                If CurLen > MaxLen Then
                                    MaxLen = CurLen
                                    GeneCoords(x, Z, 0) = Curstart
                                    GeneCoords(x, Z, 1) = Y
                                    Curstart = Y + 1
                                    CurLen = 0
                                End If
                            Else
                              CurLen = CurLen + 1
                            End If
                        Next Y
                    Else
                        
                        For Y = StartPos To ForEnd
                            If Frame(Y) = WinFrame Then
                                If CurLen > MaxLen Then
                                    MaxLen = CurLen
                                    GeneCoords(x, Z, 0) = Curstart
                                    GeneCoords(x, Z, 1) = Y
                                    Curstart = Y + 1
                                    CurLen = 0
                                End If
                            Else
                              CurLen = CurLen + 1
                            End If
                        Next Y
                        For Y = 1 To EndPos
                            If Frame(Y) = WinFrame Then
                                If CurLen > MaxLen Then
                                    MaxLen = CurLen
                                    GeneCoords(x, Z, 0) = Curstart
                                    GeneCoords(x, Z, 1) = Y
                                    Curstart = Y + 1
                                    CurLen = 0
                                End If
                            Else
                              CurLen = CurLen + 1
                            End If
                        Next Y
                    End If
                End If
                'find first in-frame start
                StartPos = GeneCoords(x, Z, 0)
                EndPos = GeneCoords(x, Z, 1)
                If StartPos < EndPos Then
                    For Y = StartPos To EndPos
                        If StartFrame(Y) = WinFrame Then
                            GeneCoords(x, Z, 2) = Y
                            Exit For
                        End If
                    Next Y
                    x = x
                Else
                    GoOn = 1
                    For Y = StartPos To ForEnd
                        If StartFrame(Y) = WinFrame Then
                            GeneCoords(x, Z, 2) = Y
                            GoOn = 0
                            Exit For
                        End If
                    Next Y
                    If GoOn = 1 Then
                        For Y = 1 To EndPos
                            If StartFrame(Y) = WinFrame Then
                                GeneCoords(x, Z, 2) = Y
                                Exit For
                            End If
                        Next Y
                    End If
                End If
                'convert genecoords to alignment coordinates
                GeneCoords(x, Z, 0) = MapAlign(GeneCoords(x, Z, 0))
                GeneCoords(x, Z, 1) = MapAlign(GeneCoords(x, Z, 1))
                GeneCoords(x, Z, 2) = MapAlign(GeneCoords(x, Z, 2))
            ElseIf GeneList(x).Orientation = 2 Then
                Curstart = StartPos
                If StartPos < EndPos Then
                    For Y = StartPos To EndPos
                        If FrameRC(Y) = WinFrame Then
                            If CurLen > MaxLen Then
                                MaxLen = CurLen
                                GeneCoords(x, Z, 0) = Curstart
                                GeneCoords(x, Z, 1) = Y
                                Curstart = Y + 1
                                CurLen = 0
                            End If
                        Else
                          CurLen = CurLen + 1
                        End If
                    Next Y
                Else
                    For Y = StartPos To LSeq
                        If FrameRC(Y) = WinFrame Then
                            If CurLen > MaxLen Then
                                MaxLen = CurLen
                                GeneCoords(x, Z, 0) = Curstart
                                GeneCoords(x, Z, 1) = Y + 2
                                Curstart = Y + 1
                                CurLen = 0
                            End If
                        Else
                          CurLen = CurLen + 1
                        End If
                    Next Y
                    For Y = RCStart To EndPos
                        If FrameRC(Y) = WinFrame Then
                            If CurLen > MaxLen Then
                                MaxLen = CurLen
                                GeneCoords(x, Z, 0) = Curstart
                                GeneCoords(x, Z, 1) = Y
                                Curstart = Y + 1
                                CurLen = 0
                            End If
                        Else
                          CurLen = CurLen + 1
                        End If
                    Next Y
                End If
                StartPos = GeneCoords(x, Z, 0)
                EndPos = GeneCoords(x, Z, 1)
                If StartPos < EndPos Then
                    For Y = StartPos To EndPos
                        If StartFrameRC(Y) = WinFrame Then
                            GeneCoords(x, Z, 2) = Y
                            Exit For
                        End If
                    Next Y
                Else
                    GoOn = 1
                    For Y = StartPos To LSeq
                        If StartFrameRC(Y) = WinFrame Then
                            GeneCoords(x, Z, 2) = Y
                            GoOn = 0
                            Exit For
                        End If
                    Next Y
                    If GoOn = 1 Then
                        For Y = RCStart To EndPos
                            If StartFrameRC(Y) = WinFrame Then
                                GeneCoords(x, Z, 2) = Y
                                Exit For
                            End If
                        Next Y
                    End If
                End If
                'XX = 'FrameRC(300)
                'XX = Mid$(SeqRC, GeneCoords(X, Z, 0), 20)
                GeneCoords(x, Z, 0) = MapAlignRC(GeneCoords(x, Z, 0))
                GeneCoords(x, Z, 1) = MapAlignRC(GeneCoords(x, Z, 1))
                GeneCoords(x, Z, 2) = MapAlignRC(GeneCoords(x, Z, 2))
            End If
        Next x
    End If
Next Z


'use genecoords and orsupport to identify actual conserved genes and sequences with incomplete orfs
Dim NumStopsInGene() As Long, LenGene As Long, LenORF As Long, PropORF As Single, ConservedTruncation() As Long, SIA As Long, EIA As Long, TruncationWarn() As Long

ReDim NumStopsInGene(GeneNumber), ConservedTruncation(GeneNumber, PermNextno, 1), TruncationWarn(GeneNumber)
For x = 1 To GeneNumber
'If X = 11 Then
'    X = X
'End If
    SIA = GeneList(x).StartInAlign
    EIA = GeneList(x).EndInAlign
    If GeneList(x).Orientation = 2 Then
        'EIA = EIA
        If EIA < SIA Then
            LenGene = SIA - EIA
        Else
            LenGene = SIA + LSeq - EIA
        End If
    ElseIf GeneList(x).Orientation = 1 Then
        If SIA < EIA Then
            LenGene = EIA - SIA
        Else
            LenGene = EIA + LSeq - SIA
        End If
    End If
    For Z = 1 To PermNextno
        If GeneList(x).Orientation = 1 Then
            If GeneCoords(x, Z, 0) < GeneCoords(x, Z, 1) Then
                LenORF = GeneCoords(x, Z, 1) - GeneCoords(x, Z, 0) + 2 'the plus two is for the extra two nts after the first nt of the stop codon (only needed in forward direction)
            Else
                LenORF = GeneCoords(x, Z, 1) + LSeq - GeneCoords(x, Z, 0) + 2
            End If
        ElseIf GeneList(x).Orientation = 2 Then
            If GeneCoords(x, Z, 1) < GeneCoords(x, Z, 0) Then
                LenORF = GeneCoords(x, Z, 0) - GeneCoords(x, Z, 1)
            Else
                LenORF = GeneCoords(x, Z, 0) + LSeq - GeneCoords(x, Z, 1)
            End If
        End If
        PropORF = LenORF / LenGene
        If PropORF < 0.8 Then
            NumStopsInGene(x) = NumStopsInGene(x) + (ORFSupport(x, Z) - 1)
            'if (genelist(x).StartInAlign - genecoords(x,z,0))
            ConservedTruncation(x, Z, 0) = GeneCoords(x, Z, 0) - SIA
            ConservedTruncation(x, Z, 1) = (EIA - (GeneCoords(x, Z, 1) + 2))
        End If
    Next Z
    ReDim DoneTruncation(-LSeq To LSeq, 1)

    For Z = 0 To PermNextno
        For Y = 0 To 1
            If ConservedTruncation(x, Z, Y) > LSeq Then
                ConservedTruncation(x, Z, Y) = LSeq
            ElseIf ConservedTruncation(x, Z, Y) < -LSeq Then
                ConservedTruncation(x, Z, Y) = -LSeq
            End If
            If Abs(ConservedTruncation(x, Z, Y)) > 30 And DoneTruncation(ConservedTruncation(x, Z, Y), Y) = 0 Then 'i.e. involves more than 10 amino acids
                DoneTruncation(ConservedTruncation(x, Z, Y), Y) = 1
                For A = Z + 1 To PermNextno
                    If ConservedTruncation(x, Z, Y) = ConservedTruncation(x, A, Y) And Distance(Z, A) < 1 Then 'if the two sequences have exactly the same truncation and the sequences are not identical
                        TruncationWarn(x) = TruncationWarn(x) + 1
                    End If
                Next A
                x = x
            End If
        Next Y
    Next Z
    GeneNumber = GeneNumber
Next x

Dim tGeneList() As GenomeFeatureDefine, tGeneNumber As Long
ReDim tGeneList(GeneNumber)
tGeneNumber = 0
For x = 1 To GeneNumber
'If X = 28 Then
'    X = X
'End If



    If TruncationWarn(x) < PermNextno / 3 Or (GeneList(x).IntronFlag > 0 And GeneList(x).ExonNumber > 0) Or x = x Then 'for now ths lets everything through but I should keep stats
                                                                                                                        'on the support for the genes in different taxa
        
        tGeneNumber = tGeneNumber + 1
        tGeneList(tGeneNumber) = GeneList(x)
        
     Else
        x = x '11,12,14
    End If

Next x
GeneNumber = tGeneNumber
ReDim GeneList(tGeneNumber), ColBump(tGeneNumber)
For x = 1 To GeneNumber
        GeneList(x) = tGeneList(x)
        XX = GeneList(x).StartInAlign
        XX = GeneList(x).EndInAlign
        XX = GeneList(x).Name
        XX = GeneList(x).Product

Next x

x = x
End Sub




Public Sub MakeTreeDrawB(TreeDraw() As Single, TreeDrawB() As Single)
Dim Dummy As Long, UBA As Long, UBB As Long, UBC As Long, UBD As Long, UBE As Long, A As Long, b As Long, C As Long, D As Long, e As Long
UBA = UBound(TreeDraw, 1)
UBB = UBound(TreeDraw, 2)
UBC = UBound(TreeDraw, 3)
UBD = UBound(TreeDraw, 4)
UBE = UBound(TreeDraw, 5)
ReDim TreeDrawB(UBD, UBE, UBA, UBB, UBC)
If NextNo < 1 Then Exit Sub
''''''
'SS = abs(gettickcount)
'If X = X Then
'@
    Dummy = MakeTreeDrawB2(UBA, UBB, UBC, UBD, UBE, TreeDraw(0, 0, 0, 0, 0), TreeDrawB(0, 0, 0, 0, 0))
'Else
'    For A = 0 To UBA
'        For B = 0 To UBB
'            For C = 0 To UBC
'                For D = 0 To UBD
'                    For E = 0 To UBE
'                        TreeDrawB(D, E, A, B, C) = TreeDraw(A, B, C, D, E)
'                    Next E
'                Next D
'            Next C
'        Next B
'    Next A
'End If
'EE = abs(gettickcount)
'TT = EE - SS '0.344+0.313
'X = X
'
'For A = 0 To UBA
'        For B = 0 To UBB
'            For C = 0 To UBC
'                For D = 0 To UBD
'                    For E = 0 To UBE
'                        If TreeDrawB(D, E, A, B, C) <> TreeDraw(A, B, C, D, E) Then
'                            X = X
'                        End If
'                    Next E
'                Next D
'            Next C
'        Next B
'    Next A

End Sub
Public Sub FindSequences()
    'put everything back the way it was
Form7.Caption = "Find Sequence"
OP = Screen.MousePointer
Screen.MousePointer = 1
SelectedSeqNumber = -1
OX = Form7.Left
OY = Form7.Top
Form7.Left = Screen.Width / 2 - Form7.Width / 2
Form7.Top = Screen.Height / 2 - Form7.Height / 2
Form7.ScaleMode = 3
NoTypeSeqFlag = 1
Form7.Caption = "Find Sequence"
Form7.Label1(0) = "Which sequence?"
Form7.Label1(0).Top = 20
Form7.Label1(0).Left = 5
Form7.Text1(0).Visible = False
Form7.Text1(1).Visible = False
Form7.Label1(1).Visible = False
Form7.Command1(0).Visible = False
Form7.Command1(1).Visible = False
Form7.Label1(0).Visible = True
Form7.Combo1.Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
Form7.Combo1.Top = Form7.Label1(0).Top - 4
Form7.Combo1.Width = 200
Form7.Combo1.Clear
Z = 0
Dim TraceZ() As Long
ReDim TraceZ(PermNextno * 2)

For x = 0 To PermNextno
    'If Decompress(Len(StrainSeq(0))) - SeqSpaces(Len(StrainSeq(0)), X) = Pos Then
        Form7.Combo1.AddItem OriginalName(x)
        TraceZ(Z) = x
        Z = Z + 1
    'End If
Next x




Form7.Combo1.ListIndex = 0
Form7.Combo1.Visible = True

'Form1.Enabled = False
'Form2.Enabled = False

OTypeSeq = TypeSeqNumber

Form7.Visible = True
SelectedSeqNumber = -1
Do
    'Form7.Refresh
    
    Form7.Combo1.Width = 200
    
    
    DoEvents
    If SelectedSeqNumber <> -1 Then Exit Do
    'Sleep (500)
    Form7.ZOrder
    If Form7.Visible = False Then
        'Close #1
        Exit Sub
    End If
Loop

Form7.Visible = False
'Form1.Enabled = True
'Form2.Enabled = True

If F2ZO = 1 Then
    Form2.ZOrder
End If
If Form1.VScroll3.Enabled = True Then
    TargetVal = (SelectedSeqNumber / PermNextno) * Form1.VScroll3.Max
    If TargetVal < 0 Then TargetVal = 0
    
    Form1.VScroll3.Value = TargetVal
End If

BusyFlashing(SelectedSeqNumber) = 1
Call PrintNames
Form1.Timer4.Enabled = True

If F2ZO = 1 Then
    Form2.ZOrder
End If

'If SEventNumber > 0 Then
If SelectedSeqNumber > -1 Then
    GTCS = SelectedSeqNumber
        'Call Picture2_Click
        'FindSeqMnu_Click
    'End If
    If Form2.Visible = True Then
        Dim otTYF As Double, TYFM As Integer
        Call ModOffsets(8.25, Form2.Picture2(1), otTYF, TYFM)
        tTYF = otTYF
        If F2ZO = 1 Then
            Form2.ZOrder
        End If
        'UnModSeqNum
        XX = NextNo
        Call UnModNextno
        For Index = 0 To 3
              Offset = (Form2.Picture2(Index).ScaleHeight / 2) - 7
              If Index > 0 Then
                 Call ModNextno
                 If (YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) > (Form2.VScroll1(Index).Max) Then
                    TargetPos = Form2.VScroll1(Index).Max
                ElseIf (YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) < 0 Then
                    TargetPos = 0
                ElseIf YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset <= Form2.VScroll1(Index).Max Then
                    TargetPos = YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset
                End If
              Else
                    Call UnModNextno
                    If (YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset) > (Form2.VScroll1(Index).Max) Then
                        TargetPos = Form2.VScroll1(Index).Max
                    ElseIf (YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset) < 0 Then
                        TargetPos = 0
                    ElseIf YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF * ttyfAdjust - Offset <= Form2.VScroll1(Index).Max Then
                        TargetPos = YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset
                    End If
              End If
              
              'Targetpos = MiddlePos(CurTree(Index), Index) - Offset
              OVy = 0
              NV = -1
              
              
              Call DoTreeColour(Form2.Picture2(Index), CurTree(Index), Index)
              If TargetPos <> 0 Then
                    If Form2.VScroll1(Index).Value <> TargetPos Then
                          If ButtonRepress = BRP Then
                              Do While OVy <> NV
                              'XX = Form2.Picture2(Index).ScaleHeight
                                  OVy = NV
                                  NV = CLng(OVy + (TargetPos - OVy) / 2)
                                  If NV < 0 Then NV = 0
                                  If NV > Form2.VScroll1(Index).Max Then NV = Form2.VScroll1(Index).Max
                                  Form2.VScroll1(Index).Value = NV / F2VSScaleFactor(Index)
                                  'XX = Form2.VScroll1(Index).Max
                                  If OVy = NV Then
                                      Exit Do
                                  End If
                                  DoEvents
                              Loop
                          Else
                              Form2.VScroll1(Index).Value = TargetPos
                          End If
                    End If
                Else
                    XX = Form2.VScroll1(Index).Value
                    Form2.VScroll1(Index).Value = TargetPos
                End If
                
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                
                'Call treedrawing(0,0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, Index, CurTree(Index), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                
        Next Index
    End If
    If Form1.SSPanel6(1).Visible = True Then
        'Dim otTYF As Double, TYFM As Integer
        Call ModOffsets(8.25, Form1.Picture16, otTYF, TYFM)
        tTYF = otTYF
        
        'UnModSeqNum
        
        Call UnModNextno
        'For Index = 0 To 3
              Index = TreeTypeFlag
              Offset = (Form1.Picture16.ScaleHeight / 2) - 7
              If Index > 0 Then
                 Call ModNextno
                 If (YCord(CTF, Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) > (Form1.VScroll1.Max) Then
                    TargetPos = Form1.VScroll1.Max
                ElseIf (YCord(CTF, Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) < 0 Then
                    TargetPos = 0
                ElseIf YCord(CTF, Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset <= Form1.VScroll1.Max Then
                    TargetPos = YCord(CTF, Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset
                End If
              Else
                    Call UnModNextno
                    If (YCord(CTF, Index, SelectedSeqNumber) * tTYF - Offset) > (Form1.VScroll1.Max) Then
                        TargetPos = Form1.VScroll1.Max
                    ElseIf (YCord(CTF, Index, SelectedSeqNumber) * tTYF - Offset) < 0 Then
                        TargetPos = 0
                    ElseIf YCord(CTF, Index, SelectedSeqNumber) * tTYF - Offset <= Form1.VScroll1.Max Then
                        TargetPos = YCord(CTF, Index, SelectedSeqNumber) * tTYF - Offset
                    End If
              End If
              
              'Targetpos = MiddlePos(CurTree(Index), Index) - Offset
              OVy = 0
              NV = -1
              If F2VSScaleFactor(Index) = 0 Then
                    F2VSScaleFactor(Index) = 1
              End If
              
              Call DoTreeColour(Form1.Picture16, CTF, Index)
              If TargetPos <> 0 Then
                    If Form1.VScroll1.Value <> TargetPos Then
                          If ButtonRepress = BRP Then
                              Do While OVy <> NV
                              'XX = Form2.Picture2(Index).ScaleHeight
                                  OVy = NV
                                  NV = CLng(OVy + (TargetPos - OVy) / 2)
                                  If NV < 0 Then NV = 0
                                  If NV > Form1.VScroll1.Max Then NV = Form1.VScroll1.Max
                                  Form1.VScroll1.Value = NV / F2VSScaleFactor(Index)
                                  'XX = Form2.VScroll1(Index).Max
                                  If OVy = NV Then
                                      Exit Do
                                  End If
                                  DoEvents
                              Loop
                          Else
                              Form1.VScroll1.Value = TargetPos
                          End If
                    End If
                Else
                    
                    Form1.VScroll1.Value = TargetPos
                End If
                
                'Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, TreeTypeFlag, CTF, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
          
                'Call treedrawing(0,0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, Index, CurTree(Index), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                
        'Next Index
    End If
End If
UnModNextno
Screen.MousePointer = 0
F2ZO = 0
End Sub

Public Sub FindSequencesb()



'put everything back the way it was
Form7.Caption = "Find Sequence"
OP = Screen.MousePointer
Screen.MousePointer = 1
SelectedSeqNumber = -1
OX = Form7.Left
OY = Form7.Top
Form7.Left = Screen.Width / 2 - Form7.Width / 2
Form7.Top = Screen.Height / 2 - Form7.Height / 2
Form7.ScaleMode = 3
NoTypeSeqFlag = 1
Form7.Caption = "Find Sequence"
Form7.Label1(0) = "Which sequence?"
Form7.Label1(0).Top = 20
Form7.Label1(0).Left = 5
Form7.Text1(0).Visible = False
Form7.Text1(1).Visible = False
Form7.Label1(1).Visible = False
Form7.Command1(0).Visible = False
Form7.Command1(1).Visible = False
Form7.Label1(0).Visible = True
Form7.Combo1.Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
Form7.Combo1.Top = Form7.Label1(0).Top - 4
Form7.Combo1.Width = 200
Form7.Combo1.Clear
Z = 0
Dim TraceZ() As Long
ReDim TraceZ(PermNextno * 2)
For x = 0 To PermNextno
    'If Decompress(Len(StrainSeq(0))) - SeqSpaces(Len(StrainSeq(0)), X) = Pos Then
        Form7.Combo1.AddItem OriginalName(x)
        TraceZ(Z) = x
        Z = Z + 1
    'End If
Next x



Form7.Combo1.ListIndex = 0
Form7.Combo1.Visible = True

'Form1.Enabled = False
'Form2.Enabled = False

OTypeSeq = TypeSeqNumber

Form7.Visible = True
SelectedSeqNumber = -1
Do
    'Form7.Refresh
    
    Form7.Combo1.Width = 200
    
    
    DoEvents
    If SelectedSeqNumber <> -1 Then Exit Do
    Sleep (500)
    Form7.ZOrder
    If Form7.Visible = False Then
        'Close #1
        Exit Sub
    End If
Loop

Form7.Visible = False
'Form1.Enabled = True
'Form2.Enabled = True

If F2ZO = 1 Then
    Form2.ZOrder
End If
If Form1.VScroll3.Enabled = True Then
    TargetVal = (SelectedSeqNumber / PermNextno) * Form1.VScroll3.Max
    If TargetVal < 0 Then TargetVal = 0
    
    Form1.VScroll3.Value = TargetVal
End If

BusyFlashing(SelectedSeqNumber) = 1
Call PrintNames
Form1.Timer4.Enabled = True

If F2ZO = 1 Then
    Form2.ZOrder
End If

If SEventNumber > 0 Then
    If SelectedSeqNumber > -1 Then
        GTCS = SelectedSeqNumber
        'Call Picture2_Click
        'FindSeqMnu_Click
    End If
    If Form2.Visible = True And SelectedSeqNumber > -1 Then
        Dim otTYF As Double, TYFM As Integer
        Call ModOffsets(8.25, Form2.Picture2(1), otTYF, TYFM)
        tTYF = otTYF
        If F2ZO = 1 Then
            Form2.ZOrder
        End If
        'UnModSeqNum
        XX = NextNo
        Call UnModNextno
        For Index = 0 To 3
              Offset = (Form2.Picture2(Index).ScaleHeight / 2) - 7
              If Index > 0 Then
                 Call ModNextno
                 If (YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) > (Form2.VScroll1(Index).Max) Then
                    TargetPos = Form2.VScroll1(Index).Max
                ElseIf (YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset) < 0 Then
                    TargetPos = 0
                ElseIf YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset <= Form2.VScroll1(Index).Max Then
                    TargetPos = YCord(CurTree(Index), Index, TreeTrace(TreeTraceSeqs(0, SelectedSeqNumber))) * tTYF - Offset
                End If
              Else
                    Call UnModNextno
                    If (YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset) > (Form2.VScroll1(Index).Max) Then
                        TargetPos = Form2.VScroll1(Index).Max
                    ElseIf (YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset) < 0 Then
                        TargetPos = 0
                    ElseIf YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset <= Form2.VScroll1(Index).Max Then
                        TargetPos = YCord(CurTree(Index), Index, SelectedSeqNumber) * tTYF - Offset
                    End If
              End If
              
              'Targetpos = MiddlePos(CurTree(Index), Index) - Offset
              OVy = 0
              NV = -1
              
              
              Call DoTreeColour(Form2.Picture2(Index), CurTree(Index), Index)
              If TargetPos <> 0 Then
                    If Form2.VScroll1(Index).Value <> TargetPos Then
                          If ButtonRepress = BRP Then
                              Do While OVy <> NV
                              'XX = Form2.Picture2(Index).ScaleHeight
                                  OVy = NV
                                  NV = CLng(OVy + (TargetPos - OVy) / 2)
                                  If NV < 0 Then NV = 0
                                  If NV > Form2.VScroll1(Index).Max Then NV = Form2.VScroll1(Index).Max
                                  Form2.VScroll1(Index).Value = NV / F2VSScaleFactor(Index)
                                  'XX = Form2.VScroll1(Index).Max
                                  If OVy = NV Then
                                      Exit Do
                                  End If
                                  DoEvents
                              Loop
                          Else
                              Form2.VScroll1(Index).Value = TargetPos
                          End If
                    End If
                Else
                    XX = Form2.VScroll1(Index).Value
                    Form2.VScroll1(Index).Value = TargetPos
                End If
                
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
                
                'Call treedrawing(0,0, TreeBlocksL(), TBLLen, 0, OriginalName(), -Form1.VScroll1.Value, Index, CurTree(Index), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)
                
        Next Index
    End If
End If
UnModNextno
Screen.MousePointer = 0
F2ZO = 0

End Sub

Public Sub MakeTB()

Dim RVseq As String, RVSeq2 As String

'for x =
Open "RvNCBI.fasta" For Input As #1
RVseq = String(LOF(1), " ")
'RVSeq2 = String(LOF(1), " ")
Input #1, RVseq
Close #1
LastPos = InStr(1, RVseq, Chr(10), vbBinaryCompare)
LastPos = LastPos + 1
RVSeq2 = String(Len(RVseq), " ")
Dim CurLen As Long
CurLen = 1
Do
    Pos = InStr(LastPos, RVseq, Chr(10), vbBinaryCompare)
    
    If Pos > 0 Then
        Mid(RVSeq2, CurLen, Pos - LastPos) = Mid$(RVseq, LastPos, Pos - LastPos)
        'XX = Right(RVSeq2, 10)
        CurLen = CurLen + (Pos - LastPos)
        LastPos = Pos + 1
        
        x = x
    Else
        Exit Do
    End If
    SS = Abs(GetTickCount)
    If SS - EE > 500 Then
    EE = SS
        Form1.SSPanel1 = Str(CurLen)
    End If
Loop
RVSeq2 = Trim(RVSeq2)

XX = Len(RVSeq2)
x = x

Dim GStartPos As Long, GeneStart2() As Long, GeneStart3() As Long, NucMap() As Long, NumNucs, NucMapCoding() As Long, NumNucsCoding, NucMap2() As Long, NumNucs2, NucMap3() As Long, NumNucs3, Temp As String
ReDim NucMap(Len(StrainSeq(0)))
ReDim NucMapCoding(Len(StrainSeq(0)))

ReDim NucMap2(Len(StrainSeq(0)))

ReDim NucMap3(Len(StrainSeq(0)))

ReDim GeneStart2(Len(StrainSeq(0))), GeneStart3(Len(StrainSeq(0)))



Open "TB192_SG_variants_NODUP_annovar_in_final.finalout" For Binary As #1
Temp = String(LOF(1), " ")
Get #1, , Temp

Close #1
LastPos = 1: NumNucs = 0
XX = Len(Temp)

Dim ItsNonCoding As Byte, ItsSense As Byte, GeneName() As String, Info() As String, GeneName2() As String, Info2() As String, GeneName3() As String, Info3() As String

ReDim GeneName(Len(StrainSeq(0))), Info(Len(StrainSeq(0)))
ReDim GeneName2(Len(StrainSeq(0))), Info2(Len(StrainSeq(0)))
ReDim GeneName3(Len(StrainSeq(0))), Info3(Len(StrainSeq(0)))

Do
    'If NumNucs = 2291 Then
    '    X = X
    'End If
    Pos = InStr(LastPos, Temp, "MTB_anc", vbBinaryCompare)
    
    'XX = Mid(Temp, Pos, 50)
    
    If Pos = 0 Then Exit Do
    Pos = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    Pos = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    Pos = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    XX = Mid(Temp, Pos + 2, 50)
    If Mid(Temp, Pos + 2, 1) = "I" Then
        ItsNonCoding = 1
    Else
        ItsNonCoding = 0
    End If
    Pos = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    
    Pos2 = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    XX = Mid(Temp, Pos, Pos2 - Pos)
    
    GeneName(NumNucs) = Trim(Mid(Temp, Pos + 1, Pos2 - Pos - 1))
   If Right(GeneName(NumNucs), 1) <> "c" Then
        ItsSense = 1
    Else
        ItsSense = 0
    End If
    Pos2 = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    Pos = Pos2
    Pos2 = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    XX = Mid(Temp, Pos, Pos2 - Pos)
    Info(NumNucs) = Trim(Mid(Temp, Pos + 1, Pos2 - Pos - 1))
    
    Pos = Pos2
    Pos2 = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    XX = Mid(Temp, Pos, Pos2 - Pos)
    
    NucMap(NumNucs) = val(Trim(Mid(Temp, Pos, Pos2 - Pos)))
    Pos = Pos2
    Pos = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
    Pos2 = InStr(Pos + 1, Temp, "..", vbBinaryCompare)
    XX = Mid(Temp, Pos, Pos2 - Pos)
    If NucMap(NumNucs) <> 0 Then
        
        GStartPos = val(Trim(Mid(Temp, Pos, (Pos2 - Pos))))
        
        If ItsNonCoding = 0 Then
            NucMapCoding(NumNucsCoding) = NucMap(NumNucs)
            NumNucsCoding = NumNucsCoding + 1
            If ItsSense = 1 Then
                NucMap2(NumNucs2) = NucMap(NumNucs)
                GeneStart2(NumNucs2) = GStartPos
                GeneName2(NumNucs2) = GeneName(NumNucs)
                Info2(NumNucs2) = Info(NumNucs)
                NumNucs2 = NumNucs2 + 1
            Else
                NucMap3(NumNucs3) = NucMap(NumNucs)
                GeneStart3(NumNucs3) = GStartPos
                GeneName3(NumNucs3) = GeneName(NumNucs)
                Info3(NumNucs3) = Info(NumNucs)
                NumNucs3 = NumNucs3 + 1
            End If
        End If
    End If
    
    
    x = x
    '[XX = (NumNucs - (NumNucs2 + NumNucs3))
    
    'uncomment to read nucleotides within overlapping ORFs
'    If NucMap(NumNucs) = 0 Then
'     Pos = Pos2
'     Pos2 = InStr(Pos + 1, Temp, Chr(9), vbBinaryCompare)
'        NucMap(NumNucs) = Val(Trim(Mid(Temp, Pos, Pos2 - Pos)))
'    End If
'
    NumNucs = NumNucs + 1
    'End If
    
    LastPos = Pos2 + 1
Loop

If x = 123456 Then 'this will output the full alignment
    Open "fixedalign.fas" For Output As #1
    For x = 0 To NextNo
        RVseq = RVSeq2
        For Y = 0 To NumNucs - 1
            If NucMap(Y) > 0 Then 'it'll be 0 if the nucleotide is in an overlapping ORF
                Mid(RVseq, NucMap(Y), 1) = Mid(StrainSeq(x), Y + 1, 1)
            End If
        Next Y
        Form1.SSPanel1.Caption = Trim(Str(x + 1)) + " of " + Trim(Str(NextNo + 1)) + " completed"
        Print #1, ">" + OriginalName(x)
        Print #1, RVseq
    Next x
    
    Form1.SSPanel1.Caption = x
End If
Dim RVSeq3 As String, DistFromStart As Long, Codon As String, LastCodonStart As Long, CodonsWithMultipleHits As Long



Dim CodonNo As Long, TempOut As String, LastCodonNo

If x = x Then 'this will output an alignment for FUBAR in sense
    LastCodonNo = -1
    Open "FUBARSenseAlign.csv" For Output As #2
    Print #2, "Sense codon no, Mutation position, Gene start nt, Gene name, Mutation info"
    Open "FUBARSenseAlign.fas" For Output As #1
    CodonNo = 0
    For x = 0 To NextNo
        RVSeq3 = String(NumNucs2 * 3, " ")
        RVseq = RVSeq2
        For Y = 0 To NumNucs - 1
            If NucMap(Y) > 0 Then 'it'll be 0 if the nucleotide is in an overlapping ORF
                Mid(RVseq, NucMap(Y), 1) = Mid(StrainSeq(x), Y + 1, 1)
            End If
        Next Y
        'figure out codon position
        For Y = 0 To NumNucs2 - 1
            DistFromStart = GeneStart2(Y) - NucMap2(Y)
            CodonNo = CodonNo + 1
            If DistFromStart / 3 = CLng(DistFromStart / 3) Then 'position1
                If NucMap2(Y) <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap2(Y), 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "TAG" Or Codon = "TAA" Or Codon = "TGA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap2(Y)
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo - 1
                End If
            ElseIf (DistFromStart - 1) / 3 = CLng((DistFromStart - 1) / 3) Then 'position2
                If NucMap2(Y) - 2 <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap2(Y) - 2, 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "TAG" Or Codon = "TAA" Or Codon = "TGA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap2(Y) - 2
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo - 1
                End If
            ElseIf (DistFromStart - 2) / 3 = CLng((DistFromStart - 2) / 3) Then 'position3
                If NucMap2(Y) - 1 <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap2(Y) - 1, 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "TAG" Or Codon = "TAA" Or Codon = "TGA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap2(Y) - 1
                    
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo - 1
                End If
            End If
            If x = 0 Then
                TempOut = Str(CodonNo) + "," + Str(NucMap2(Y)) + "," + Str(GeneStart2(Y)) + "," + GeneName2(Y) + "," + Info2(Y)
                If LastCodonNo <> CodonNo Then
                    Print #2, TempOut
                End If
                LastCodonNo = CodonNo
            End If
        Next Y
        
        
        Form1.SSPanel1.Caption = Trim(Str(x + 1)) + " of " + Trim(Str(NextNo + 1)) + " completed"
        Print #1, ">" + OriginalName(x)
        Print #1, Trim(RVSeq3)
    Next x
    
    Close #1
End If
Close #2

If x = x Then 'this will output an alignment for FUBAR in sense
    LastCodonNo = -1
    Open "FUBARComplementaryAlign.csv" For Output As #2
    Print #2, "Complementary codon no, Mutation position, Gene start nt, Gene name, Mutation info"
    Open "FUBARComplementAlign.fas" For Output As #1
    CodonNo = NumNucs3 + 1
    For x = 0 To NextNo
        RVSeq3 = String(NumNucs3 * 3, " ")
        RVseq = RVSeq2
        For Y = 0 To NumNucs - 1
            If NucMap(Y) > 0 Then 'it'll be 0 if the nucleotide is in an overlapping ORF
                Mid(RVseq, NucMap(Y), 1) = Mid(StrainSeq(x), Y + 1, 1)
            End If
        Next Y
        'figure out codon position
        For Y = 0 To NumNucs3 - 1
            DistFromStart = NucMap3(Y) - GeneStart3(Y)
            CodonNo = CodonNo - 1
            'XX = Mid(RVseq, NucMap3(Y) - 5, 10)
            If DistFromStart / 3 = CLng(DistFromStart / 3) Then 'position1
                
                If NucMap3(Y) <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap3(Y), 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "CTA" Or Codon = "TTA" Or Codon = "TCA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap3(Y)
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo + 1
                End If
            ElseIf (DistFromStart - 1) / 3 = CLng((DistFromStart - 1) / 3) Then 'position2
                If NucMap3(Y) - 1 <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap3(Y) - 1, 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "CTA" Or Codon = "TTA" Or Codon = "TCA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap3(Y) - 1
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo + 1
                End If
            ElseIf (DistFromStart - 2) / 3 = CLng((DistFromStart - 2) / 3) Then 'position3
                If NucMap3(Y) - 2 <> LastCodonStart Then
                    Codon = Mid(RVseq, NucMap3(Y) - 2, 3)
                    If Mid(Codon, 1, 1) = "-" Or Mid(Codon, 2, 1) = "-" Or Mid(Codon, 3, 1) = "-" Then Codon = "---"
                    If Codon = "CTA" Or Codon = "TTA" Or Codon = "TCA" Then Codon = "---"
                    Mid(RVSeq3, (Y * 3) + 1, 3) = Codon
                    LastCodonStart = NucMap3(Y) - 2
                Else
                    CodonsWithMultipleHits = CodonsWithMultipleHits + 1
                    CodonNo = CodonNo + 1
                End If
            End If
            If x = 1 Then
                TempOut = Str(CodonNo) + "," + Str(NucMap3(Y)) + "," + Str(GeneStart3(Y)) + "," + GeneName3(Y) + "," + Info3(Y)
                If LastCodonNo <> CodonNo Then
                    Print #2, TempOut
                End If
                LastCodonNo = CodonNo
                'TempOut = Str(CodonNo) + "," + Str(NucMap3(Y)) + "," + Str(GeneStart3(Y)) + "," + GeneName3(Y) + "," + Info3(Y)
            End If
        x = x
        Next Y
        If x = x Then
            CodonNo = NumNucs3 - CodonNo + 1
        End If
        Form1.SSPanel1.Caption = Trim(Str(x + 1)) + " of " + Trim(Str(NextNo + 1)) + " completed"
        Print #1, ">" + OriginalName(x)
        Print #1, Trim(RVSeq3)
    Next x
    
    Close #1
End If

CodonsWithMultipleHits = CodonsWithMultipleHits / (NextNo + 1)

Close #1
Close #2
x = x


End Sub

Public Sub MakeDMatS(NextNo As Long, SP() As Long, EP() As Long, SeqNum() As Integer, DMatS() As Single, ISeqs() As Long)
Dim Z As Long, Y As Long, Dummy As Long, UB As Long, x As Long, SubValidx() As Single, SubDiffsx() As Single, DumMatB() As Single, OS As Long, OE As Long


OS = 0: OE = 0
ReDim DMatS(3, 2, NextNo)

For x = 0 To 3
        
        If OS <> SP(x) Or OE <> EP(x) Then
            UB = UBound(PermValid, 1)
            ReDim SubValidx(2, NextNo), SubDiffsx(2, NextNo)
            ReDim DumMatB(2, NextNo)
            
            'change this to only look at distances between all and iseqs(x)? done
            'Dummy = QuickDist2(Len(StrainSeq(0)), NextNo, UB, SP, EP, SubValidx(0, 0), SubDiffsx(0, 0), SeqNum(0, 0), ISeqs(0))
            '@'@
            Dummy = QuickDist6(Len(StrainSeq(0)), NextNo, UB, SP(x), EP(x), ISeqs(0), DumMatB(0, 0), SubValidx(0, 0), SubDiffsx(0, 0), SeqNum(0, 0))
            
        End If
       
        For Y = 0 To 2
            For Z = 0 To NextNo
                If SubValidx(Y, Z) > 10 Then
                    DMatS(x, Y, Z) = CLng(DumMatB(Y, Z) * 10000) / 10000
'                    DMatS(X, Y, Z) = DMatS(X, Z, Y)
'                    SubValidY(X, Y, Z) = SubValidx(Y, Z)
'                    SubValidY(X, Z, Y) = SubValidx(Y, Z)
'                    SubDiffsY(X, Y, Z) = SubDiffsx(Y, Z)
'                    SubDiffsY(X, Z, Y) = SubDiffsx(Y, Z)
                Else
                    DMatS(x, Y, Z) = 3
'                    DMatS(X, Y, Z) = 3
'                    SubValidY(X, Y, Z) = 0
'                    SubValidY(X, Z, Y) = 0
'                    SubDiffsY(X, Y, Z) = 0
'                    SubDiffsY(X, Z, Y) = 0
                End If
            Next Z
        Next Y
        
        OS = SP(x): OE = EP(x)
        
    Next x

End Sub
Public Sub MakeDMatS2(NextNo As Long, SP() As Long, EP() As Long, SeqNum() As Integer, DMatS() As Single)
Dim SubValidx() As Single, SubDiffsx() As Single, DumMatB() As Single
 Dim SubDiffsY() As Single, SubValidY() As Single
OS = 0: OE = 0

ReDim DMatS(3, NextNo, NextNo)
For x = 0 To 3
        
        If OS <> SP(x) Or OE <> EP(x) Then
            UB = UBound(PermValid, 1)
            ReDim SubValidx(NextNo, NextNo), SubDiffsx(NextNo, NextNo)
            ReDim DumMatB(NextNo, NextNo)
            
            'change this to only look at distances between all and iseqs(x)? done
            'Dummy = QuickDist2(Len(StrainSeq(0)), NextNo, UB, SP, EP, SubValidx(0, 0), SubDiffsx(0, 0), SeqNum(0, 0), ISeqs(0))
            'Dummy = QuickDist5(Len(StrainSeq(0)), Nextno, UB, SP(X), EP(X), DumMatB(0, 0), SubValidx(0, 0), SubDiffsx(0, 0), SeqNum(0, 0))
            Dummy = QuickDist5(Len(StrainSeq(0)), NextNo, UB, SP(x), EP(x), DumMatB(0, 0), SubValidx(0, 0), SubDiffsx(0, 0), SeqNum(0, 0))
            
        End If
       
        For Y = 0 To NextNo
            For Z = Y + 1 To NextNo
                If SubValidx(Y, Z) > 10 Then
                    DMatS(x, Z, Y) = CLng(DumMatB(Z, Y) * 10000) / 10000
                    DMatS(x, Y, Z) = DMatS(x, Z, Y)
                  
                    
                Else
                    DMatS(x, Z, Y) = 3
                    DMatS(x, Y, Z) = 3
                    
                End If
            Next Z
        Next Y
        
        OS = SP(x): OE = EP(x)
        
    Next x

End Sub
Public Sub MakeAnalysisList()


Dim NTX As Variant
NTX = NumSeqs * (NumSeqs + 1)

NTX = NTX * (NumSeqs - 1)
NTX = NTX / 6
NumTrips = NTX



NumTrips = 0
If SelGrpFlag > 0 Then
    For x = 0 To NextNo
            For Y = x + 1 To NextNo
                    For Z = Y + 1 To NextNo
                        If GrpMaskSeq(x) + GrpMaskSeq(Y) + GrpMaskSeq(Z) > 1 Then
                           NumTrips = NumTrips + 1
                        End If
                    Next Z
            Next Y
    Next x
    x = x
Else
    NumTrips = 0
    For x = 0 To NextNo
        If MaskSeq(x) = 0 Then
            NumTrips = NumTrips + 1
        End If
    Next x
    bval = NumTrips
    NumTrips = NumTrips * (NumTrips - 1)
    NumTrips = NumTrips * (bval - 2)
    NumTrips = NumTrips / 6 '544691070
                            'vs 544691070

End If
x = x

'Exit Sub
'If NumTrips > MaxAnalNo And MCCorrection > MaxAnalNo Then
    Dim PropTrips As Long, CurPos As Long, CP As Long, SubTrps As Long, Analno As Long
    If SelGrpFlag = 0 Then
    'need to subtract the first and last triplets fro each ordered pair
        SubTrps = NextNo * (NextNo + 1)
    
    '    If (SubTrps * 2) < MaxAnalNo And x = 1234567 Then
    '        Analno = MaxAnalNo - SubTrps
    '    Else
    '        Analno = MaxAnalNo
    '    End If
        'If Analno < SubTrps Then Analno = SubTrps
    
        Dim PT As Variant, PTS As Single
        If NumTrips > Analno Then
            'PropTrips = CLng(NumTrips / MaxAnalNo)
            
            Analno = MaxAnalNo + 2000
        Else
            'PropTrips = 1
            Analno = NumTrips + 2000
        End If
    Else
        Analno = NumTrips + 2000
    End If
    PT = Analno / NumTrips
    PTS = PT
    If PTS > 1 Then PTS = 1
    
    CP = -1
    Dim RestartPos() As Long
    ReDim Analysislist(2, Analno + 10000)
    ReDim RestartPos(2)
    
    
    CurPos = 1
    If SelGrpFlag > 0 Then
        For x = 0 To NextNo
                For Y = x + 1 To NextNo
                        For Z = Y + 1 To NextNo
                            If GrpMaskSeq(x) + GrpMaskSeq(Y) + GrpMaskSeq(Z) > 1 Then
                               CurPos = CurPos - 1
                               If CurPos < 0 Then
                                   CurPos = PropTrips
                                   CP = CP + 1
                                   Analysislist(0, CP) = x
                                   Analysislist(1, CP) = Y
                                   Analysislist(2, CP) = Z
                               End If
                            End If
                        Next Z
                Next Y
        Next x
        x = x
    Else
        
        If x = x Then
            'CP = MakeAListP(PropTrips, NextNo, MaskSeq(0), UBound(Analysislist, 1), Analysislist(0, 0))
            CP = MakeAListP2(PTS, NextNo, MaskSeq(0), UBound(Analysislist, 1), Analysislist(0, 0))
            
            x = x
        Else
            'CurPos = 0
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    For Y = x + 1 To NextNo
                        If MaskSeq(Y) = 0 Then
                            'CurPos = PropTrips - 1
                            For Z = Y + 1 To NextNo
                                If MaskSeq(Z) = 0 Then
                                    CurPos = CurPos + 1
                                    If CurPos = PropTrips Then 'Or Z = Nextno Then
                                        CurPos = 0 'CLng(PropTrips ^ ((NumTrips - CP) / NumTrips))
                                        CP = CP + 1
                                        Analysislist(0, CP) = x
                                        Analysislist(1, CP) = Y
                                        Analysislist(2, CP) = Z
                                    End If
                                End If
                            Next Z
                            DoEvents
                        End If
                    Next Y
                End If
            Next x
        End If
        If CP > 2000000 Then
            For x = 0 To NextNo - 2
                If MaskSeq(x) = 0 Then
                    For Y = x + 1 To NextNo - 1
                        If MaskSeq(Y) = 0 Then
                            For Z = Y + 1 To NextNo
                                If MaskSeq(Z) = 0 Then
                                    Analysislist(0, 0) = x
                                    Analysislist(1, 0) = Y
                                    Analysislist(2, 0) = Z
                                End If
                            Next Z
                        End If
                    Next Y
                End If
            Next x
        End If
        
        
        For x = 1 To CP - 1
    
           If Analysislist(1, x) <> Analysislist(1, x - 1) And Analysislist(1, x) < NextNo Then
                Analysislist(2, x) = Analysislist(1, x) + 1
           End If
        Next x
    End If
    ReDim Preserve Analysislist(2, CP)
    'Force first entry for every sequence pair to be at the lowest possible position
    
    
'the commented out stuff below used to test how balanced the screen is per sequence pair.
'    x = x
'    Dim PC() As Long
'    ReDim PC(Nextno, Nextno)
'    For x = 0 To CP
'        PC(Analysislist(0, x), Analysislist(1, x)) = PC(Analysislist(0, x), Analysislist(1, x)) + 1
'        PC(Analysislist(0, x), Analysislist(2, x)) = PC(Analysislist(0, x), Analysislist(2, x)) + 1
'        PC(Analysislist(1, x), Analysislist(2, x)) = PC(Analysislist(1, x), Analysislist(2, x)) + 1
'        PC(Analysislist(1, x), Analysislist(0, x)) = PC(Analysislist(0, x), Analysislist(1, x))
'        PC(Analysislist(2, x), Analysislist(0, x)) = PC(Analysislist(0, x), Analysislist(2, x))
'        PC(Analysislist(2, x), Analysislist(1, x)) = PC(Analysislist(1, x), Analysislist(2, x))
'
'    Next x
'    Highest = 0
'    Lowest = 100000
'    'XX = MaskSeq(955)
'    For x = 1 To Nextno - 3
'        If MaskSeq(x) = 0 Then
'            For Y = x + 1 To Nextno - 2
'                If MaskSeq(Y) = 0 Then
'                    If Lowest > PC(x, Y) Then
'                        Lowest = PC(x, Y)
'                        winnerl1 = x
'                        winnerl2 = Y
'                    End If
'                    If Highest < PC(x, Y) Then
'                        Highest = PC(x, Y)
'                        winnerh1 = x
'                        winnerh2 = Y
'                    End If
'                End If
'            Next Y
'        End If
'    Next x
    
'
'    'XX = PC(1000, 1001)
'    If x = 1234567 Then
'    ReDim Preserve Analysislist(2, nt) '58156 urmillas dataset
'    End If
'    x = x
'

TripListLen = CP
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If Form2.Visible = True Then
    Form2.Visible = False
End If
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Form1.Refresh
End Sub
Public Sub MakeAnalysisList5()
Dim NumSeqs As Long, SeqList() As Long, SeqListBak() As Long, NumTrips As Variant, nt As Long, TDist() As Integer, A As Integer, b As Integer
Dim TDCat() As Integer, testx As Double
'XX = TreeDistance(0, 6)
SS = Abs(GetTickCount)

If NJFlag = 0 Then
    Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Erase TreeX
    End If
        
End If


ReDim SeqList(NextNo), SeqListBak(NextNo)
NumSeqs = 0
Dim GrpTest As Long, GrpM() As Byte

Form1.SSPanel1.Caption = "Re-making list of triplets to analyse"
If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 5
Call UpdateF2Prog

For x = 0 To NextNo
    If MaskSeq(x) = 0 Then
        SeqList(NumSeqs) = x
        SeqListBak(x) = NumSeqs
        NumSeqs = NumSeqs + 1
    Else
        SeqListBak(x) = -1
    End If
    
Next x
ReDim GrpM(NumSeqs)
If SelGrpFlag > 0 Then
    For x = 0 To NumSeqs - 1
        GrpM(x) = GrpMaskSeq(SeqList(x))
    Next x
End If

Dim NTX As Variant
NTX = NumSeqs * (NumSeqs + 1)

NTX = NTX * (NumSeqs - 1)
NTX = NTX / 6
NumTrips = NTX
'Exit Sub

nt = 0
Dim TDS As Integer

If NumTrips > MaxAnalNo And MCCorrection > MaxAnalNo Then
    SS = Abs(GetTickCount)
    ReDim TDist(NumSeqs - 1, NumSeqs - 1)
    For x = 0 To NumSeqs - 2
        A = SeqListBak(x)
        If A > -1 Then
            For Y = x + 1 To NumSeqs - 1
                b = SeqListBak(Y)
                If b > -1 Then
                    TDist(x, Y) = CInt(TreeDistance(A, b) * 32000)
                End If
            Next Y
        End If
    Next x
    For x = 0 To NumSeqs - 2
        For Y = x + 1 To NumSeqs - 1
            If TDist(Y, x) = 0 Then
                TDS = TDist(x, Y)
                nt = nt + 1
                TDist(Y, x) = nt
                For Z = 0 To NumSeqs - 1
                    
                    If Z < Y Then
                        If TDist(Z, Y) = TDS Then
                            If TDist(Y, Z) = 0 Then
                                TDist(Y, Z) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    ElseIf Z > Y Then
                        If TDist(Y, Z) = TDS Then
                            If TDist(Z, Y) = 0 Then
                                TDist(Z, Y) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    End If
                    If Z < x Then
                        If TDist(Z, x) = TDS Then
                            If TDist(x, Z) = 0 Then
                                TDist(x, Z) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    ElseIf Z > x Then
                        If TDist(x, Z) = TDS Then
                            If TDist(Z, x) = 0 Then
                                TDist(Z, x) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                            
                        End If
                    End If
                Next Z
            End If
        Next Y
    
    Next x
    XX = nt
    EE = Abs(GetTickCount)
    TT = EE - SS '6 seconds for urmillas dataset
    x = x
'    NT = 0
'    Dim OnSide() As Byte
'    For X = 0 To Nextno
'        ReDim TDCat(32000)
'        ReDim OnSide(Nextno)
'        For Y = 0 To Nextno
'            If treex(X, Y) > -1 Then
'                OnSide(SeqListBak(treex(X, Y))) = 1
'            Else
'                Exit For
'            End If
'        Next Y
'        Dim Groups() As Integer, GN() As Long, N As Byte
'
'        ReDim Groups(1, NumSeqs), GN(1)
'        For Z = 0 To NumSeqs - 1
'            N = OnSide(Z)
'            Groups(N, GN(N)) = Z
'            GN(N) = GN(N) + 1
'        Next Z
'
'        For A = 0 To GN(0) - 1
'            For B = 0 To GN(1) - 1
'                C = Groups(0, A)
'                D = Groups(1, B)
'
'                If C < D Then
'                    If TDist(D, C) = 0 Then
'                        If TDCat(TDist(C, D)) = 0 Then
'                            TDCat(TDist(C, D)) = 1
'                            NT = NT + 1
'                        End If
'                        TDist(D, C) = NT
'                    End If
'                Else
'                    If TDist(C, D) = 0 Then
'                        If TDCat(TDist(D, C)) = 0 Then
'                            TDCat(TDist(D, C)) = 1
'                            NT = NT + 1
'                        End If
'                        TDist(C, D) = NT
'                    End If
'                End If
'            Next B
'        Next A
'    Next X
    
    XX = nt
    'For X = 0 To NumSeqs - 2
    '    For Y = X + 1 To NumSeqs - 1
    '        XX = TDist(Y, X) '7,7,8,2,9
    '    Next Y
    'Next X
    'make potential lists
    Dim NumPerCat() As Long
    ReDim NumPerCat(nt)
    For x = 0 To NumSeqs - 2
        For Y = x + 1 To NumSeqs - 1
            NumPerCat(TDist(Y, x)) = NumPerCat(TDist(Y, x)) + 1
        Next Y
    Next x
    
    Dim TD1 As Long, TD2 As Long, NTSNo As Long, MaxNums As Variant, AcceptPerCat() As Long, NTS() As Long
    Dim OverDrawn As Long, Choices As Long, NTS2() As Long
    SS = Abs(GetTickCount)
    
    If nt <= 1 Then nt = 2
    ReDim NTS(nt, nt), NTS2(nt, nt)
    NTSNo = (nt * (nt - 1)) / 2
     MaxNums = CLng(MaxAnalNo / NTSNo)
    ReDim AcceptPerCat(nt, nt)
    
    Form1.SSPanel1.Caption = "Selecting triplets for analysis"
    Form1.ProgressBar1.Value = 7 'Then Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    'Form1.ProgressBar1 = 5
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
'    If X = X Then
        Dummy = MakeNTS(nt, SelGrpFlag, NumSeqs, TDist(0, 0), GrpM(0), NTS(0, 0))
'    Else
'        If SelGrpFlag > 0 Then
'
'            For X = 0 To NumSeqs - 3
'                For Y = X + 1 To NumSeqs - 2
'                    TD1 = TDist(Y, X)
'                    For Z = Y + 1 To NumSeqs - 1
'                        If GrpM(X) + GrpM(Y) + GrpM(Z) >= 2 Then
'                            TD2 = TDist(Z, X)
'                            If TD1 = TD2 Then
'                               TD2 = TDist(Z, Y)
'                            End If
'                            NTS(TD1, TD2) = NTS(TD1, TD2) + 1
'                            NTS(TD2, TD1) = NTS(TD1, TD2)
'                        End If
'                    Next Z
'                Next Y
'            Next X
'        Else
'            For X = 0 To NumSeqs - 3
'                For Y = X + 1 To NumSeqs - 2
'                    TD1 = TDist(Y, X)
'                    For Z = Y + 1 To NumSeqs - 1
'                        TD2 = TDist(Z, X)
'                        If TD1 = TD2 Then
'                           TD2 = TDist(Z, Y)
'                        End If
'                        NTS(TD1, TD2) = NTS(TD1, TD2) + 1
'                        NTS(TD2, TD1) = NTS(TD1, TD2)
'                    Next Z
'                Next Y
'            Next X
'
'
'        End If
'    End If
    
    'For X = 1 To NT
    '    For Y = X + 1 To NT
    '        TD1 = NumPerCat(X)
    '        TD2 = NumPerCat(Y)
    '        XX = NTS(X, Y)
    '    Next Y
    'Next X
    Form1.SSPanel1.Caption = "Optimising triplet list"
    Form1.ProgressBar1 = 55
    Call UpdateF2Prog
    
    EE = Abs(GetTickCount)
    TT = EE - SS '159.714'denv = 4.4 seconds in c
    x = x
    Dim Tot As Long, NoOD As Long, MNInc As Long, LastNoOD As Long, VarDump As Variant
    If MaxNums = 0 Then MaxNums = 1
    
    SS = Abs(GetTickCount)
    If MaxNums > 1 Then
  
        Do
            'LeftOvers = 0
            OverDrawn = 0
            VarDump = 0
            Tot = 0
            'LeftOvers = 0
            NoOD = 0
            For x = 1 To nt - 1
                For Y = x + 1 To nt
                    If NTS(x, Y) < MaxNums Then
                        
                        Tot = Tot + NTS(x, Y)
                    Else
                        Tot = Tot + MaxNums
                        'OverDrawn = OverDrawn + (NTS(X, Y) - MaxNums)
                        'VarDump = Choices
                        VarDump = VarDump + NTS(x, Y)
                        'Choices = CLng(VarDump)
                        NoOD = NoOD + 1
                    End If
                Next Y
            Next x
            
            Tot = MaxAnalNo - Tot
            If Tot <= 0 Then
                MaxNums = MaxNums - MNInc
                If MaxNums = 0 Then MaxNums = 1
                Exit Do
            End If
            LastNoOD = NoOD
            If NoOD <= 1 Then Exit Do
            MNInc = CLng(Tot / NoOD)
            
            If MNInc < 1 Then MNInc = 1
            MaxNums = MaxNums + MNInc
        Loop
    End If
    
    EE = Abs(GetTickCount)
    TT = EE - SS '159.714'denv = 4.4 seconds in c
    x = x
    
    x = x
    Form1.SSPanel1.Caption = "Making final list"
    Form1.ProgressBar1 = 60
    Call UpdateF2Prog
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    If MaxNums = 0 Then MaxNums = 1
    
    
    Dim WhichToChoose() As Byte, Frac As Double
    
    
    Dim NTSX As Variant
    
    NTSX = nt * (nt - 1)
    NTSX = NTSX / 2
    
    'XX = UBound(SubValid, 1)
    If MaxAnalNo > NTSX Then
        ReDim Analysislist(2, MaxAnalNo * 2)
    Else
        ReDim Analysislist(2, NTSX * 2)
    End If
    nt = 0
    
    Rnd (-BSRndNumSeed)
'    XX = UBound(AnalysisList, 2)
    'XX = UBound(TDist, 1)
    SS = Abs(GetTickCount)
'    If X = X Then
        nt = MakeAnalysisListX(3, MaxNums, UBound(NTS, 1), SelGrpFlag, NumSeqs, TDist(0, 0), GrpM(0), NTS(0, 0), Analysislist(0, 0), NTS2(0, 0), SeqList(0))
'        X = X
'    Else
'        If SelGrpFlag > 0 Then
'            For X = 0 To NumSeqs - 3
'                For Y = X + 1 To NumSeqs - 2
'                    TD1 = TDist(Y, X)
'                    For Z = Y + 1 To NumSeqs - 1
'                        If GrpM(X) + GrpM(Y) + GrpM(Z) >= 2 Then
'                            TD2 = TDist(Z, X)
'                            If TD1 = TD2 Then
'                               TD2 = TDist(Z, Y)
'                            End If
'                            GoOn = 0
'
'
'                            'If MaxNums = 0 Then MaxNums = 1
'                            If NTS(TD1, TD2) <= MaxNums Then
'                                GoOn = 1
'                            Else
'                                If NTS2(TD1, TD2) < MaxNums Then
'                                    Frac = MaxNums / NTS(TD1, TD2) ' / MaxNums
'                                    X = X
'                                    testx = Rnd
'                                    If Frac > testx Then GoOn = 1
'                                End If
'                                'XX = Rnd
'                                'X = X
'                            End If
'                            If GoOn = 1 Then
'                                If nt > UBound(AnalysisList, 2) Then
'                                    ReDim Preserve AnalysisList(2, nt + 1000)
'                                End If
'                                NTS2(TD1, TD2) = NTS2(TD1, TD2) + 1
'                                NTS2(TD2, TD1) = NTS2(TD1, TD2)
'                                AnalysisList(0, nt) = SeqList(X)
'                                AnalysisList(1, nt) = SeqList(Y)
'                                AnalysisList(2, nt) = SeqList(Z)
'                                nt = nt + 1
'                               ' If NT > UBound(AnalysisList, 2) Then
'                               '     ReDim Preserve AnalysisList(2, NT + 1000)
'                               ' End If
'                                X = X
'                            End If
'                        End If
'                    Next Z
'                Next Y
'            Next X
'        Else
'            For X = 0 To NumSeqs - 3
'                For Y = X + 1 To NumSeqs - 2
'                    TD1 = TDist(Y, X)
'                    For Z = Y + 1 To NumSeqs - 1
'
'                        TD2 = TDist(Z, X)
'                        If TD1 = TD2 Then
'                           TD2 = TDist(Z, Y)
'                        End If
'                        GoOn = 0
'
'
'                        'If MaxNums = 0 Then MaxNums = 1
'                        If NTS(TD1, TD2) <= MaxNums Then
'                            GoOn = 1
'                        Else
'                            If NTS2(TD1, TD2) < MaxNums Then
'                                Frac = MaxNums / NTS(TD1, TD2) ' / MaxNums
'
'                                testx = Rnd
'                                If Frac > testx Then GoOn = 1
'                            End If
'                            'XX = Rnd
'                            'X = X
'                        End If
'                        If GoOn = 1 Then
'                            If nt > UBound(AnalysisList, 2) Then
'                                ReDim Preserve AnalysisList(2, nt + 1000)
'                            End If
'                            NTS2(TD1, TD2) = NTS2(TD1, TD2) + 1
'                            NTS2(TD2, TD1) = NTS2(TD1, TD2)
'                            AnalysisList(0, nt) = SeqList(X)
'                            AnalysisList(1, nt) = SeqList(Y)
'                            AnalysisList(2, nt) = SeqList(Z)
'                            nt = nt + 1
'                           ' If NT > UBound(AnalysisList, 2) Then
'                           '     ReDim Preserve AnalysisList(2, NT + 1000)
'                           ' End If
'                            X = X
'                        End If
'                    Next Z
'                Next Y
'            Next X
'        End If
'    End If
    EE = Abs(GetTickCount)
    TT = EE - SS '331.846
    '22.869 tylcv
    
    'Force first entry for every sequence pair to be at the lowest possible position
    x = x
    Analysislist(0, 0) = 0
    Analysislist(1, 0) = 1
    Analysislist(2, 0) = 2
    For x = 1 To nt - 1
'        If AnalysisList(0, x) = 1000 Then
'            x = x
'        End If
XX = Analysislist(0, x)
XX = Analysislist(1, x)
XX = Analysislist(2, x)

       If Analysislist(1, x) <> Analysislist(1, x - 1) And Analysislist(1, x) < NextNo Then
            Analysislist(2, x) = Analysislist(1, x) + 1
       End If
    Next x
    x = x
    Dim PC() As Long
    ReDim PC(NextNo, NextNo)
    For x = 0 To nt
        PC(Analysislist(0, x), Analysislist(1, x)) = PC(Analysislist(0, x), Analysislist(1, x)) + 1
        PC(Analysislist(0, x), Analysislist(2, x)) = PC(Analysislist(0, x), Analysislist(2, x)) + 1
        PC(Analysislist(1, x), Analysislist(2, x)) = PC(Analysislist(1, x), Analysislist(2, x)) + 1
        PC(Analysislist(1, x), Analysislist(0, x)) = PC(Analysislist(0, x), Analysislist(1, x))
        PC(Analysislist(2, x), Analysislist(0, x)) = PC(Analysislist(0, x), Analysislist(2, x))
        PC(Analysislist(2, x), Analysislist(1, x)) = PC(Analysislist(1, x), Analysislist(2, x))
        
    Next x
    Highest = 0
    Lowest = nt
    For x = 0 To NextNo
    
        For Y = x + 1 To NextNo
            If Lowest > PC(x, Y) Then
                Lowest = PC(x, Y)
                winnerl1 = x
                winnerl2 = Y
            End If
            If Highest < PC(x, Y) Then
                Highest = PC(x, Y)
                winnerh1 = x
                winnerh2 = Y
            End If
        Next Y
    Next x
    ReDim Preserve Analysislist(2, nt) '58156 urmillas dataset
    x = x
    
Else
    ReDim Analysislist(2, MCCorrection + 100)
    nt = 0
    If SelGrpFlag > 0 Then
        For x = 0 To NumSeqs - 3
            For Y = x + 1 To NumSeqs - 2
                For Z = Y + 1 To NumSeqs - 1
                    If GrpM(x) + GrpM(Y) + GrpM(Z) >= 2 Then
                        Analysislist(0, nt) = SeqList(x)
                        Analysislist(1, nt) = SeqList(Y)
                        Analysislist(2, nt) = SeqList(Z)
                        nt = nt + 1
                    End If
                Next Z
            Next Y
        Next x
    Else
        For x = 0 To NumSeqs - 3
            If MaskSeq(x) = 0 Then
                For Y = x + 1 To NumSeqs - 2
                    If MaskSeq(Y) = 0 Then
                        For Z = Y + 1 To NumSeqs - 1
                            If MaskSeq(Z) = 0 Then
                                Analysislist(0, nt) = SeqList(x)
                                Analysislist(1, nt) = SeqList(Y)
                                Analysislist(2, nt) = SeqList(Z)
                                nt = nt + 1
                            End If
                        Next Z
                    End If
                Next Y
            End If
        Next x
    End If
    
End If
TripListLen = nt - 1
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If Form2.Visible = True Then
    Form2.Visible = False
End If
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Form1.Refresh
End Sub
Public Sub MakeAnalysisList4()
Dim NumSeqs As Long, SeqList() As Long, SeqListBak() As Long, NumTrips As Variant, nt As Long, TDist() As Integer, A As Integer, b As Integer
Dim TDCat() As Integer
'XX = TreeDistance(0, 6)
SS = Abs(GetTickCount)
If NJFlag = 0 Then
    Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Erase TreeX
    End If

End If


ReDim SeqList(NextNo), SeqListBak(NextNo)
NumSeqs = 0
For x = 0 To NextNo
    If MaskSeq(x) = 0 Then
        SeqList(NumSeqs) = x
        SeqListBak(x) = NumSeqs
        NumSeqs = NumSeqs + 1
    Else
        SeqListBak(x) = -1
    End If
Next x


Dim NTX As Variant
NTX = NumSeqs * (NumSeqs - 1)

NTX = NTX * (NTX - 2)
NTX = NTX / 6
NumTrips = NTX
'Exit Sub
nt = 0
Dim TDS As Integer
If NumTrips > MaxAnalNo Then
    
    ReDim TDist(NumSeqs - 1, NumSeqs - 1)
    For x = 0 To NumSeqs - 2
        A = SeqListBak(x)
        If A > -1 Then
            For Y = x + 1 To NumSeqs - 1
                b = SeqListBak(Y)
                If b > -1 Then
                    TDist(x, Y) = CInt(TreeDistance(A, b) * 32000)
                End If
            Next Y
        End If
    Next x
    For x = 0 To NumSeqs - 2
        For Y = x + 1 To NumSeqs - 1
            If TDist(Y, x) = 0 Then
                TDS = TDist(x, Y)
                nt = nt + 1
                TDist(Y, x) = nt
                For Z = 0 To NumSeqs - 1
                    
                    If Z < Y Then
                        If TDist(Z, Y) = TDS Then
                            If TDist(Y, Z) = 0 Then
                                TDist(Y, Z) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    ElseIf Z > Y Then
                        If TDist(Y, Z) = TDS Then
                            If TDist(Z, Y) = 0 Then
                                TDist(Z, Y) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    End If
                    If Z < x Then
                        If TDist(Z, x) = TDS Then
                            If TDist(x, Z) = 0 Then
                                TDist(x, Z) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                        End If
                    ElseIf Z > x Then
                        If TDist(x, Z) = TDS Then
                            If TDist(Z, x) = 0 Then
                                TDist(Z, x) = nt
                                For ZZ = Z + 1 To NumSeqs - 1
                                    If TDist(Z, ZZ) = TDS Then
                                        TDist(ZZ, Z) = nt
                                    End If
                                Next ZZ
                            Else
                                x = x
                            End If
                            
                        End If
                    End If
                Next Z
            End If
        Next Y
    
    Next x
    XX = nt
    EE = Abs(GetTickCount)
    TT = EE - SS
    x = x
'    NT = 0
'    Dim OnSide() As Byte
'    For X = 0 To Nextno
'        ReDim TDCat(32000)
'        ReDim OnSide(Nextno)
'        For Y = 0 To Nextno
'            If treex(X, Y) > -1 Then
'                OnSide(SeqListBak(treex(X, Y))) = 1
'            Else
'                Exit For
'            End If
'        Next Y
'        Dim Groups() As Integer, GN() As Long, N As Byte
'
'        ReDim Groups(1, NumSeqs), GN(1)
'        For Z = 0 To NumSeqs - 1
'            N = OnSide(Z)
'            Groups(N, GN(N)) = Z
'            GN(N) = GN(N) + 1
'        Next Z
'
'        For A = 0 To GN(0) - 1
'            For B = 0 To GN(1) - 1
'                C = Groups(0, A)
'                D = Groups(1, B)
'
'                If C < D Then
'                    If TDist(D, C) = 0 Then
'                        If TDCat(TDist(C, D)) = 0 Then
'                            TDCat(TDist(C, D)) = 1
'                            NT = NT + 1
'                        End If
'                        TDist(D, C) = NT
'                    End If
'                Else
'                    If TDist(C, D) = 0 Then
'                        If TDCat(TDist(D, C)) = 0 Then
'                            TDCat(TDist(D, C)) = 1
'                            NT = NT + 1
'                        End If
'                        TDist(C, D) = NT
'                    End If
'                End If
'            Next B
'        Next A
'    Next X
    
    XX = nt
    For x = 0 To NumSeqs - 2
        For Y = x + 1 To NumSeqs - 1
            XX = TDist(Y, x) '7,7,8,2,9
        Next Y
    Next x
    'make potential lists
    
    
Else
    ReDim Analysislist(2, NumTrips)
    nt = 0
    For x = 0 To NumSeqs
        For Y = x + 1 To NumSeqs
            For Z = Y + 1 To NumSeqs
                Analysislist(0, nt) = SeqList(x)
                Analysislist(1, nt) = SeqList(Y)
                Analysislist(2, nt) = SeqList(Z)
                nt = nt + 1
            Next Z
        Next Y
    Next x
End If
End Sub
Public Sub MakeAnalysisList2()

Dim SValidDiff() As Byte, SV As Byte, SD As Byte, DonePair() As Byte, DoubList() As Integer, DoubListLen As Long





Dim AlistTrace() As Integer, AlistTraceBak() As Integer
ReDim AlistTrace(NextNo), AlistTraceBak(NextNo)
Y = 0
For x = 0 To NextNo
    If MaskSeq(x) = 0 Then
        AlistTrace(x) = Y
        AlistTraceBak(Y) = x
        Y = Y + 1
    End If
Next x
Dim UnmaskedNo As Integer, TX As Integer
UnmaskedNo = Y - 1
'ReDim SValidDiff(UnmaskedNo, UnmaskedNo)
Dim SVx() As Byte, SDx() As Byte, SizeRedim As Long
ReDim Analysislist(2, 100), SVx(UnmaskedNo), SDx(UnmaskedNo)
'test
Dim DVXY As Single, DVXZ As Single, CV  As Single
'ListLen = 0
SS = Abs(GetTickCount)

'1st window
TripListLen = 0
SizeRedim = UnmaskedNo
For x = 0 To NextNo
    

    If MaskSeq(x) = 0 Then
        ReDim DoubList(1, 1 + (SizeRedim * (SizeRedim - 1)) / 2)
        SizeRedim = SizeRedim - 1
        DoubListLen = 0
        For Y = x + 1 To NextNo
            If MaskSeq(Y) = 0 Then
                For Z = Y + 1 To NextNo
                    If MaskSeq(Z) = 0 Then
                        DoubListLen = DoubListLen + 1
                        DoubList(0, DoubListLen) = Y
                        DoubList(1, DoubListLen) = Z
                    End If
                Next Z
            End If
        Next Y
        
        For Y = x + 1 To NextNo
            If MaskSeq(Y) = 0 Then
                SV = 0
                SD = 0
                For Z = 1 To 100
                    If SeqNum(Z, x) <> 46 Then
                        If SeqNum(Z, Y) <> 46 Then
                            SV = SV + 1
                            If SeqNum(Z, Y) <> SeqNum(Z, x) Then
                                SD = SD + 1
                            End If
                        End If
                        
                    End If
                Next Z
                'A = AlistTrace(X)
                b = AlistTrace(Y)
                SVx(b) = SV
                SDx(b) = SD
            End If
        Next Y
        
    
        'MakeDonepair
        TX = AlistTrace(x)
        'ReDim DonePair(UnmaskedNo, UnmaskedNo)
        V = 1
        
        Do
            Y = DoubList(0, V)
            
            A = AlistTrace(Y)
            If SVx(A) > 0 Then
                
                DVXY = SDx(A) / SVx(A)
                Z = DoubList(1, V)
                b = AlistTrace(Z)
                
                'If DonePair(A, B) = 0 Then
                    If SVx(b) > 0 Then
                        DVXZ = SDx(b) / SVx(b)
                        If DVXY > DVXZ Then
                            If 1 - Distance(x, Y) < 1 - Distance(x, Z) Then
                               'CalcChiV = (
                               
                               'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                               'If CV > 1.7 Then
                                    TripListLen = TripListLen + 1
                                    If TripListLen > UBound(Analysislist, 2) Then
                                         ReDim Preserve Analysislist(2, TripListLen + 1000)
                                    End If
                                    'AnalysisList(0, ListLen) = X
                                    Analysislist(0, TripListLen) = x
                                    Analysislist(1, TripListLen) = Y
                                    Analysislist(2, TripListLen) = Z
                                    If V < DoubListLen Then
                                         DoubList(0, V) = DoubList(0, DoubListLen)
                                         DoubList(1, V) = DoubList(1, DoubListLen)
                                     Else
                                         DoubListLen = DoubListLen - 1
                                         Exit Do
                                     End If
                                     DoubListLen = DoubListLen - 1
                                     V = V - 1
                                'End If
                            End If
                        ElseIf DVXY < DVXZ Then
                            If 1 - Distance(x, Y) > 1 - Distance(x, Z) Then
                               'CV = CalcChiV(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                               'If CV > 1.7 Then

                                    TripListLen = TripListLen + 1
                                    If TripListLen > UBound(Analysislist, 2) Then
                                         ReDim Preserve Analysislist(2, TripListLen + 1000)
                                    End If
                                    Analysislist(0, TripListLen) = x
                                    Analysislist(1, TripListLen) = Y
                                    Analysislist(2, TripListLen) = Z
                                    If V < DoubListLen Then
                                         DoubList(0, V) = DoubList(0, DoubListLen)
                                         DoubList(1, V) = DoubList(1, DoubListLen)
                                     Else
                                         DoubListLen = DoubListLen - 1
                                         Exit Do
                                     End If
                                     DoubListLen = DoubListLen - 1
                                     V = V - 1
                                'End If
                            End If
                        End If
                    End If
                'End If
                   
            End If
            V = V + 1
            If V > DoubListLen Then Exit Do
        Loop

        Dim FP As Long, lP As Long, W As Long
        If V <= 1 Then
            Exit For
        End If
        FP = 1
        lP = 100
        Dim si As Long, S As Long
        si = 20
        S = 0
        For W = 2 To Len(StrainSeq(0)) - 100
            lP = lP + 1
            
            For Y = x + 1 To NextNo
                If MaskSeq(Y) = 0 Then
                    b = AlistTrace(Y)
                    SV = SVx(b)
                    SD = SDx(b)
                    If SeqNum(FP, x) <> 46 Then
                    
                        If SeqNum(FP, Y) <> 46 Then
                            SV = SV - 1
                            If SeqNum(FP, Y) <> SeqNum(FP, x) Then
                                SD = SD - 1
                            End If
                        End If
                    End If
                    If SeqNum(lP, x) <> 46 Then
                        If SeqNum(lP, Y) <> 46 Then
                            SV = SV + 1
                            If SeqNum(lP, Y) <> SeqNum(lP, x) Then
                                SD = SD + 1
                            End If
                        End If
                    End If
                    'check
                    
                    
                    SVx(b) = SV '79,93,87,91
                    SDx(b) = SD '25,45,36,42
                End If
                
            Next Y
            
            S = S + 1
            'ReDim DonePair(UnmaskedNo, UnmaskedNo)
            'For Y = 1 To ListLen(TX)
            '    A = AnalysisList(TX, 0, Y)
            '    B = AnalysisList(TX, 1, Y)
            '    A = AlistTrace(A)
            '    B = AlistTrace(B)
            '    DonePair(A, B) = 1
            'Next Y
            'TX = AlistTrace(X)
            If S >= si Then
                V = 1
                si = 0
                Do
                    Y = DoubList(0, V)
                    
                    A = AlistTrace(Y)
                    If SVx(A) > 0 Then
                        
                        DVXY = SDx(A) / SVx(A)
                        Z = DoubList(1, V)
                        b = AlistTrace(Z)
                        'If DonePair(A, B) = 0 Then
                            If SVx(b) > 0 Then
                                DVXZ = SDx(b) / SVx(b)
                                If DVXY > DVXZ Then
                                    If 1 - Distance(x, Y) < 1 - Distance(x, Z) Then
                                       'CalcChiV = (
                                       
                                       'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                                       'If CV > 1.7 Then
                                            TripListLen = TripListLen + 1
                                            If TripListLen > UBound(Analysislist, 2) Then
                                                 ReDim Preserve Analysislist(2, TripListLen + 1000)
                                            End If
                                            'AnalysisList(0, ListLen) = X
                                            Analysislist(0, TripListLen) = x
                                            Analysislist(1, TripListLen) = Y
                                            Analysislist(2, TripListLen) = Z
                                            If V < DoubListLen Then
                                                 DoubList(0, V) = DoubList(0, DoubListLen)
                                                 DoubList(1, V) = DoubList(1, DoubListLen)
                                             Else
                                                 DoubListLen = DoubListLen - 1
                                                 Exit Do
                                             End If
                                             DoubListLen = DoubListLen - 1
                                             V = V - 1
                                        'End If
                                    End If
                                ElseIf DVXY < DVXZ Then
                                    If 1 - Distance(x, Y) > 1 - Distance(x, Z) Then
                                       'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                                       'If CV > 1.7 Then
        
                                            TripListLen = TripListLen + 1
                                            If TripListLen > UBound(Analysislist, 2) Then
                                                 ReDim Preserve Analysislist(2, TripListLen + 1000)
                                            End If
                                            Analysislist(0, TripListLen) = x
                                            Analysislist(1, TripListLen) = Y
                                            Analysislist(2, TripListLen) = Z
                                            If V < DoubListLen Then
                                                 DoubList(0, V) = DoubList(0, DoubListLen)
                                                 DoubList(1, V) = DoubList(1, DoubListLen)
                                             Else
                                                 DoubListLen = DoubListLen - 1
                                                 Exit Do
                                             End If
                                             DoubListLen = DoubListLen - 1
                                             V = V - 1
                                        'End If
                                    End If
                                End If
                            End If
                        'End If
                           
                    End If
                    V = V + 1
                    If V > DoubListLen Then Exit Do
                Loop
            End If
            FP = FP + 1
        'Form1.ProgressBar1.Value = (W / Len(StrainSeq(0))) * 100
        'Form1.Refresh
            If V <= 1 Then Exit For
        
        Next W
    End If
    Form1.SSPanel1.Caption = "Prescreening " + Trim(Str(x)) + " of " + Trim(Str(NextNo)) + " for evidence of recombination"
    Form1.ProgressBar1.Value = (x / NextNo) * 100
    Call UpdateF2Prog
    Form1.Refresh
    x = x
Next x
EE = Abs(GetTickCount)
TT = EE - SS
'31.38'9.126
'17.284, 12.933 wiith long
'2285
'XX = ListLen
LL = TripListLen '1289
'For Y = 1 To TripListLen
'    For Z = Y + 1 To TripListLen
'        If AnalysisList(0, Y) = AnalysisList(0, Z) And AnalysisList(1, Y) = AnalysisList(1, Z) And AnalysisList(2, Y) = AnalysisList(2, Z) Then
'            X = X
'        End If
'    Next Z
'Next Y


x = x
End Sub
Public Sub MakeAnalysisList3()

Dim SValidDiff() As Byte, SV As Byte, SD As Byte, DonePair() As Byte, DoubList() As Integer, DoubListLen As Long


If PermNextno > TripListSaveCO Then
    ReDim TripListLenSeq(NextNo)
End If


Dim AlistTrace() As Integer, AlistTraceBak() As Integer, IV1 As Integer, IV2 As Integer, IV3 As Integer, IV4 As Integer
ReDim AlistTrace(NextNo), AlistTraceBak(NextNo)
Y = 0
For x = 0 To NextNo
    If MaskSeq(x) = 0 Then
        AlistTrace(x) = Y
        AlistTraceBak(Y) = x
        Y = Y + 1
    End If
Next x
Dim UnmaskedNo As Integer, TX As Integer
UnmaskedNo = Y - 1
'ReDim SValidDiff(UnmaskedNo, UnmaskedNo)
Dim SVx() As Integer, SDx() As Integer, SizeRedim As Long, MaxTrpLen As Long

'test
Dim DVXY As Single, DVXZ As Single, CV  As Single, VV As Variant
'ListLen = 0
SS = Abs(GetTickCount)
VV = UnmaskedNo + 1
If TripListSaveCO < PermNextno Then
    VV = VV * (UnmaskedNo) / 2
Else
    VV = VV * (UnmaskedNo) * (UnmaskedNo - 1) / 6
End If
MaxTrpLen = VV 'UnmaskedNo * (UnmaskedNo - 1) / 2
ReDim Analysislist(2, MaxTrpLen), SVx(UnmaskedNo), SDx(UnmaskedNo)
'1st window
TripListLen = 0
SizeRedim = UnmaskedNo + 1
For x = 0 To NextNo
    

    If MaskSeq(x) = 0 Then
        ReDim DoubList(1, 1 + (SizeRedim * (SizeRedim - 1)) / 2)
        'SizeRedim = SizeRedim - 1
        DoubListLen = 0
        For Y = 0 To NextNo
            If MaskSeq(Y) = 0 And Y <> x Then
                For Z = Y + 1 To NextNo
                    If MaskSeq(Z) = 0 And Z <> x Then
                        If (Distance(x, Y) > Distance(x, Z) And Distance(x, Y) > Distance(Y, Z)) Or (Distance(x, Z) > Distance(x, Y) And Distance(x, Z) > Distance(Y, Z)) Then
                            DoubListLen = DoubListLen + 1
                            DoubList(0, DoubListLen) = Y
                            DoubList(1, DoubListLen) = Z
                        End If
                    End If
                Next Z
            End If
        Next Y
        
        For Y = 0 To NextNo
            If MaskSeq(Y) = 0 And Y <> x Then
                SV = 0
                SD = 0
                For Z = 1 To 25
                    'SV = SV + CompressValid4(ISeq4P(Z, X), ISeq4P(Z, Y))
                    'SD = SD + CompressDiffs4(ISeq4P(Z, X), ISeq4P(Z, Y))
                    
                    IV1 = ISeq4P(Z, x)
                    IV2 = ISeq4P(Z, Y)
                    
                    
                    
                    
                    SV = SV + CompressValid4(IV1, IV2)
                    SD = SD + CompressDiffs4(IV1, IV2)
                    
                Next Z
                'A = AlistTrace(X)
                b = AlistTrace(Y)
                SVx(b) = SV
                SDx(b) = SD
            End If
        Next Y
        
    
        'MakeDonepair
        TX = AlistTrace(x)
        'ReDim DonePair(UnmaskedNo, UnmaskedNo)
        V = 1
        
        Do
            Y = DoubList(0, V)
            
            A = AlistTrace(Y)
            If SVx(A) > 50 Then
                
                DVXY = SDx(A) / SVx(A)
                Z = DoubList(1, V)
                b = AlistTrace(Z)
                'If DonePair(A, B) = 0 Then
                    If SVx(b) > 50 Then
                        DVXZ = SDx(b) / SVx(b)
                        If DVXY > DVXZ Then
                            If 1 - Distance(x, Y) < 1 - Distance(x, Z) Then
                               'CalcChiV = (
                               
                               'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                               'If CV > 1.7 Then
                                    TripListLen = TripListLen + 1
                                    'If TripListLen > UBound(AnalysisList, 2) Then
                                    '     ReDim Preserve AnalysisList(2, TripListLen + 1000)
                                    'End If
                                    'AnalysisList(0, ListLen) = X
                                    Analysislist(0, TripListLen) = x
                                    Analysislist(1, TripListLen) = Y
                                    Analysislist(2, TripListLen) = Z
                                    If V < DoubListLen Then
                                         DoubList(0, V) = DoubList(0, DoubListLen)
                                         DoubList(1, V) = DoubList(1, DoubListLen)
                                     Else
                                         DoubListLen = DoubListLen - 1
                                         Exit Do
                                     End If
                                     DoubListLen = DoubListLen - 1
                                     V = V - 1
                                'End If
                            End If
                        ElseIf DVXY < DVXZ Then
                            If (1 - Distance(x, Y)) > (1 - Distance(x, Z)) Then
                               'CV = CalcChiV(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                               'If CV > 1.7 Then

                                    TripListLen = TripListLen + 1
                                    'If TripListLen > UBound(AnalysisList, 2) Then
                                    '     ReDim Preserve AnalysisList(2, TripListLen + 1000)
                                    'End If
                                    Analysislist(0, TripListLen) = x
                                    Analysislist(1, TripListLen) = Y
                                    Analysislist(2, TripListLen) = Z
                                    If V < DoubListLen Then
                                         DoubList(0, V) = DoubList(0, DoubListLen)
                                         DoubList(1, V) = DoubList(1, DoubListLen)
                                     Else
                                         DoubListLen = DoubListLen - 1
                                         Exit Do
                                     End If
                                     DoubListLen = DoubListLen - 1
                                     V = V - 1
                                'End If
                            End If
                        End If
                    End If
                'End If
                   
            End If
            V = V + 1
            If V > DoubListLen Then Exit Do
        Loop

        Dim FP As Long, lP As Long, W As Long
        If V <= 1 Then
            Exit For
        End If
        FP = 1
        lP = 25
        Dim si As Long, S As Long
        si = 20
        S = 0
        For W = 2 To UBound(ISeq4P, 1) - 25
            lP = lP + 1
            For Y = 0 To NextNo
                If MaskSeq(Y) = 0 And x <> Y Then
                    b = AlistTrace(Y)
                    SV = SVx(b)
                    SD = SDx(b)
                    If SV > 100 Then
                        x = x
                    End If
                    IV1 = ISeq4P(FP, x)
                    IV2 = ISeq4P(FP, Y)
                    IV3 = ISeq4P(lP, x)
                    IV4 = ISeq4P(lP, Y)
                    
                    SV = SV - CompressValid4(IV1, IV2)
                    SD = SD - CompressDiffs4(IV1, IV2)
                    
                    SV = SV + CompressValid4(IV3, IV4)
                    SD = SD + CompressDiffs4(IV3, IV4)
                    
                    
                    'check
                    
                    
                    SVx(b) = SV '78,92,86,90
                    SDx(b) = SD '25,45,38,44
                End If
                
            Next Y
            
            S = S + 1
            'ReDim DonePair(UnmaskedNo, UnmaskedNo)
            'For Y = 1 To ListLen(TX)
            '    A = AnalysisList(TX, 0, Y)
            '    B = AnalysisList(TX, 1, Y)
            '    A = AlistTrace(A)
            '    B = AlistTrace(B)
            '    DonePair(A, B) = 1
            'Next Y
            'TX = AlistTrace(X)
            If S >= si Then
                si = 0
                If x = 1234567890 Then
                    Dummy = MakeTrpListLen(x, UBound(Distance, 1), TripListLen, Analysislist(0, 0), DoubListLen, DoubList(0, 0), SVx(0), SDx(0), AlistTrace(0), Distance(0, 0))
                Else
                    V = 1
                    
                    Do
                        Y = DoubList(0, V)
                        
                        A = AlistTrace(Y)
                        If SVx(A) > 50 Then
                            
                            DVXY = SDx(A) / SVx(A)
                            Z = DoubList(1, V)
                            b = AlistTrace(Z)
                            'If DonePair(A, B) = 0 Then
                                If SVx(b) > 50 Then
                                    DVXZ = SDx(b) / SVx(b)
                                    
                                    If DVXY > DVXZ Then
                                        
                                        If 1 - Distance(x, Y) < 1 - Distance(x, Z) Then
                                           'CalcChiV = (
                                           
                                           'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                                           'If CV > 1.7 Then
                                                TripListLen = TripListLen + 1
                                                
                                                'If TripListLen > UBound(AnalysisList, 2) Then
                                                '     ReDim Preserve AnalysisList(2, TripListLen + 1000)
                                                'End If
                                                'AnalysisList(0, ListLen) = X
                                                Analysislist(0, TripListLen) = x
                                                Analysislist(1, TripListLen) = Y
                                                Analysislist(2, TripListLen) = Z
                                                If V < DoubListLen Then
                                                     DoubList(0, V) = DoubList(0, DoubListLen)
                                                     DoubList(1, V) = DoubList(1, DoubListLen)
                                                 Else
                                                     DoubListLen = DoubListLen - 1
                                                     Exit Do
                                                 End If
                                                 DoubListLen = DoubListLen - 1
                                                 V = V - 1
                                            'End If
                                        End If
                                    ElseIf DVXY < DVXZ Then
                                        
                                        If 1 - Distance(x, Y) > 1 - Distance(x, Z) Then
                                           'CV = CalcChiV2(CInt(DVXY * 100), Int((1 - Distance(X, Y)) * 100), CInt(DVXZ * 100), Int((1 - Distance(X, Z)) * 100))
                                           'If CV > 1.7 Then
            
                                                TripListLen = TripListLen + 1
                                                'If TripListLen > UBound(AnalysisList, 2) Then
                                                '     ReDim Preserve AnalysisList(2, TripListLen + 1000)
                                                'End If
                                                Analysislist(0, TripListLen) = x
                                                Analysislist(1, TripListLen) = Y
                                                Analysislist(2, TripListLen) = Z
                                                If V < DoubListLen Then
                                                     DoubList(0, V) = DoubList(0, DoubListLen)
                                                     DoubList(1, V) = DoubList(1, DoubListLen)
                                                 Else
                                                     DoubListLen = DoubListLen - 1
                                                     Exit Do
                                                 End If
                                                 DoubListLen = DoubListLen - 1
                                                 V = V - 1
                                            'End If
                                        End If
                                    End If
                                End If
                            'End If
                               
                        End If
                        V = V + 1
                        
                        If V > DoubListLen Then Exit Do
                    Loop
                End If
            End If
            FP = FP + 1
        'Form1.ProgressBar1.Value = (W / Len(StrainSeq(0))) * 100
        'Form1.Refresh
            If V <= 1 Then Exit For
        
        Next W
    End If
    Form1.SSPanel1.Caption = "Prescreening " + Trim(Str(x)) + " of " + Trim(Str(NextNo)) + " for evidence of recombination"
    Form1.ProgressBar1.Value = (x / NextNo) * 100
    Call UpdateF2Prog
    Form1.Refresh
    If PermNextno > TripListSaveCO Then
    
        TripListLenSeq(x) = TripListLen
        ReDim Preserve Analysislist(2, TripListLen)
        FF = FreeFile
        Open "TrpList" + Trim(Str(x)) For Binary As #FF
        Put #FF, , Analysislist()
        Close #FF
        TripListLen = 0
    End If
    GG = Abs(GetTickCount)
    TT = GG - SS
    '216.779 (first cycle DenV)'215.312 without redims'214.080
    x = x
    x = x
Next x
EE = Abs(GetTickCount)
TT = EE - SS
'31.38'9.126
'17.284, 12.933 wiith long'2,761,'0.78 with iseq4, 0.687,0.671 (2.169 with CV screen)
'2285'2282 with iseq4
'XX = ListLen
LL = TripListLen '1289
'For Y = 1 To TripListLen
'    For Z = Y + 1 To TripListLen
'        If AnalysisList(0, Y) = AnalysisList(0, Z) And AnalysisList(1, Y) = AnalysisList(1, Z) And AnalysisList(2, Y) = AnalysisList(2, Z) Then
'            X = X
'        End If
'    Next Z
'Next Y


x = x
End Sub
Public Sub Checkformat(FName As String, SName As String)
Dim FF As Long, TempString As String, PosLB As Long, PosLF As Long, LastPos As Long
Form1.SSPanel1.Caption = "Checking sequence file format"
FF = FreeFile

Open FName For Binary As #FF
If LOF(FF) < 5000000 Then
    TempString = String(LOF(FF), " ")
Else
    TempString = String(5000000, " ")
End If
Get #FF, , TempString
Close #FF

PosLF = InStr(1, TempString, Chr$(10), vbBinaryCompare)
PosCR = InStr(1, TempString, Chr$(13), vbBinaryCompare)
SS = Abs(GetTickCount)
If Abs(PosLF - PosCR) > 1 Or PosCR = 0 Then
 
    Form1.SSPanel1.Caption = "Reformatting sequence file"
    LastPos = 1
    Do
        Pos = InStr(LastPos, TempString, Chr$(10), vbBinaryCompare)

        If Pos > 0 Then
            'XX = Mid$(TempString, Pos + 1, 1)
            If Mid$(TempString, Pos + 1, 1) <> Chr$(13) Then
                Mid$(TempString, Pos, 1) = Chr$(13)
            End If
            LastPos = Pos + 2
            EE = Abs(GetTickCount)
            If Abs(EE - SS) > 500 Then
                SS = EE
                Form1.ProgressBar1.Value = (LastPos / (Len(TempString) + 2)) * 100
                Call UpdateF2Prog
                Form1.Refresh
            End If
        Else
            Exit Do
        End If
        
            
    Loop
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    Open SName For Output As #FF
    SaveFlag = 1
    Print #FF, TempString
    Close #FF
Else
    SName = FName
End If
x = x
End Sub
Public Sub ConvertLongToRGB(L As Long, r As Byte, g As Byte, b As Byte)
'Convert LONG to RGB:
 Dim RX As Long, Gx As Long, Bx As Long
 Bx = CLng(L \ 65536)
 Gx = CLng((L - Bx * 65536) \ 256)
 
 RX = CLng(L - Bx * 65536 - Gx * 256)
 
If Bx <= 255 Then
    b = Bx
Else
    b = 255
End If

If Gx <= 255 Then
    g = Gx
Else
    g = 255
End If
If RX <= 255 Then
    r = RX
Else
    r = 255
End If
 
End Sub
Public Sub KevinDenV()
'load sequence from .ct file
Dim Tmp As String, Tmp2 As String, CTString As String, CoevString As String, SynString As String, oDir As String
Dim CoevAlignToCoevSeq() As Long, CoevSeqToCoevAlign() As Long, LenS As Long, Site1 As Long, Site2 As Long, PairingArray() As Byte, Pos As Long, LastPos As Long, PairedSites() As Byte
Dim A As Long, b As Long, C As Long, D As Long, CPV() As Double

Open "dengue_2_structure.ct" For Input As #1
CTString = ""
Input #1, Tmp

'XX = CalcChiP(100, 250, 1000, 40000)


Pos = InStr(1, Tmp, Chr(9), vbBinaryCompare)

LenS = val(Left$(Tmp, Pos))

ReDim PairingArray(LenS, LenS)
ReDim PairedSites(LenS)
For x = 1 To LenS
    Input #1, Tmp
    
    Pos = InStr(1, Tmp, Chr(9), vbBinaryCompare)
    Site1 = val(Left$(Tmp, Pos))
    
    Tmp2 = Mid$(Tmp, Pos + 1, 1)
    
    Tmp2 = UCase(Tmp2)
    If Tmp2 <> "U" Then
        CTString = CTString + Tmp2
    Else
        CTString = CTString + "T"
    End If
    LastPos = Pos
    Pos = InStr(Pos + 2, Tmp, Chr(9), vbBinaryCompare)
    Pos = InStr(Pos + 1, Tmp, Chr(9), vbBinaryCompare)
    Pos = InStr(Pos + 1, Tmp, Chr(9), vbBinaryCompare)
    LastPos = Pos
    Pos = InStr(Pos + 1, Tmp, Chr(9), vbBinaryCompare)
    Tmp2 = (Mid$(Tmp, LastPos + 1, (Pos - LastPos) - 1))
    Site2 = val(Mid$(Tmp, LastPos + 1, (Pos - LastPos) - 1))
    If Site2 > 0 Then
        PairingArray(Site1, Site2) = 1
        PairingArray(Site2, Site1) = 1
        PairedSites(Site1) = 1
        PairedSites(Site2) = 1
    End If
    
    x = x
    
Next x


Close #1

'Get the coevolution sequence
'find the longest sequence
Dim Longest As Long, LLength As Long
LLength = Len(StrainSeq(0)) / 2
ReDim CoevAlignToCoevSeq(Len(StrainSeq(0)))
ReDim CoevSeqToCoevAlign(Len(StrainSeq(0)))
For x = 0 To NextNo
    If LLength > SeqSpaces(Len(StrainSeq(0)) / 2, x) Then
        LLength = SeqSpaces(Len(StrainSeq(0)) / 2, x)
        Longest = x
    End If

Next x
x = x
CoevString = ""
Dim ValidPos As Long
ValidPos = 0
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, Longest) = 66 Then
        ValidPos = ValidPos + 1
        CoevString = CoevString + "A"
        CoevAlignToCoevSeq(x) = ValidPos
    ElseIf SeqNum(x, Longest) = 68 Then
        ValidPos = ValidPos + 1
        CoevString = CoevString + "C"
        CoevAlignToCoevSeq(x) = ValidPos
    ElseIf SeqNum(x, Longest) = 72 Then
        ValidPos = ValidPos + 1
        CoevString = CoevString + "G"
        CoevAlignToCoevSeq(x) = ValidPos
    ElseIf SeqNum(x, Longest) = 85 Then
        ValidPos = ValidPos + 1
        CoevString = CoevString + "T"
        CoevAlignToCoevSeq(x) = ValidPos
    End If
    CoevSeqToCoevAlign(ValidPos) = x
Next x

'get the synonymous subst rate sequence

Open "E_dengue2_polyprotein_300_aligned.fas" For Input As #1

Line Input #1, Tmp

Line Input #1, SynString
'XX = Len(SynString)
Close #1


'Make clustalW batch file
oDir = CurDir
ChDir App.Path
ChDrive App.Path

If DebuggingFlag < 2 Then On Error Resume Next
KillFile "IF" + UFTag + ".seq"
KillFile "IF" + UFTag + ".fasta"
KillFile "clustalw.bat"
On Error GoTo 0
Dim OSX As String
Open "clustal.bat" For Output As #1
OSX = "clustalw /infile=IF" + UFTag + ".seq /output=fasta /outorder=INPUT /type=d /gapopen=" + "12" + " /gapext=" + "3"
Print #1, OSX
'Print #1, "del clustalw.bat"
Close #1



'align coev and ctstring


Open "IF" + UFTag + ".seq" For Output As #1
Print #1, ">1"
Print #1, CTString
Print #1, ">2"
Print #1, CoevString
Close #1

ShellAndClose App.Path + "\" + "clustal.bat", 0

'read aligned sequences and work out offsets
Open "IF" + UFTag + ".fasta" For Binary As #1
Tmp = String(LOF(1), " ")
Get #1, , Tmp
Close #1

Dim CurMap As Long, SeqToAlign() As Long, AlignToSeq() As Long
ReDim SeqToAlign(1, 1, LenS * 2)
ReDim AlignToSeq(1, 1, LenS * 2)
CurMap = -1
Pos = 0
ValidPos = 0
For x = 1 To Len(Tmp)
    If Mid$(Tmp, x, 1) = "A" Or Mid$(Tmp, x, 1) = "C" Or Mid$(Tmp, x, 1) = "G" Or Mid$(Tmp, x, 1) = "T" Then
        Pos = Pos + 1
        ValidPos = ValidPos + 1
        SeqToAlign(0, CurMap, ValidPos) = Pos
        AlignToSeq(0, CurMap, Pos) = ValidPos
    ElseIf Mid$(Tmp, x, 1) = "-" Then
        Pos = Pos + 1
        AlignToSeq(0, CurMap, Pos) = ValidPos
    ElseIf Mid$(Tmp, x, 1) = ">" Then
        CurMap = CurMap + 1
        Pos = 0
        ValidPos = 0
    End If
Next x

XX = SeqToAlign(0, 0, 61)

XX = XX
'align synstring and ctstring

If DebuggingFlag < 2 Then On Error Resume Next
KillFile "IF" + UFTag + ".seq"
KillFile "IF" + UFTag + ".fasta"
On Error GoTo 0

Open "IF" + UFTag + ".seq" For Output As #1
Print #1, ">1"
Print #1, CTString
Print #1, ">2"
Print #1, SynString
Close #1

ShellAndClose App.Path + "\" + "clustal.bat", 0

'read aligned sequences and work out offsets
Open "IF" + UFTag + ".fasta" For Binary As #1
Tmp = String(LOF(1), " ")
Get #1, , Tmp
Close #1

CurMap = -1
Pos = 0
ValidPos = 0
For x = 1 To Len(Tmp)
    If Mid$(Tmp, x, 1) = "A" Or Mid$(Tmp, x, 1) = "C" Or Mid$(Tmp, x, 1) = "G" Or Mid$(Tmp, x, 1) = "T" Then
        Pos = Pos + 1
        ValidPos = ValidPos + 1
        SeqToAlign(1, CurMap, ValidPos) = Pos
        AlignToSeq(1, CurMap, Pos) = ValidPos
    ElseIf Mid$(Tmp, x, 1) = "-" Then
        Pos = Pos + 1
        AlignToSeq(1, CurMap, Pos) = ValidPos
    ElseIf Mid$(Tmp, x, 1) = ">" Then
        CurMap = CurMap + 1
        Pos = 0
        ValidPos = 0
    End If
Next x

XX = XX


ChDir oDir
ChDrive oDir







'Read the coev results and write them to matrix with coordinates mapped to those of the ct file
Dim CoevSitePairList() As Single, NumCoevSites As Long
ReDim CoevSitePairList(2, 10000)
ValidPos = 0

Dim MaxDist As Long

MaxDist = 200
Open "creation_200_pval_0.1.txt" For Input As #1
'Open "Complementary_Coevolution_200.txt" For Input As #1
'Open "Coevolution_100window.txt" For Input As #1
'creation_200_pval_0.1.txt
'Complementary_Coevolution_200.txt
Do While Not EOF(1)
    Input #1, Tmp
    Pos = InStr(1, Tmp, Chr(9), vbBinaryCompare)
    If Pos > 0 Then
        
        ValidPos = ValidPos + 1
        If ValidPos > UBound(CoevSitePairList, 2) Then
            ReDim Preserve CoevSitePairList(2, ValidPos + 10000)
        End If
        'Tmp2 = Left$(Tmp, Pos - 1)
        Site1 = CoevAlignToCoevSeq(val(Left$(Tmp, Pos - 1)) + 1)
        If AlignToSeq(0, 0, SeqToAlign(0, 1, Site1)) = 61 Or AlignToSeq(0, 0, SeqToAlign(0, 1, Site1)) = 11 Then
            x = x
        End If
        CoevSitePairList(0, ValidPos) = AlignToSeq(0, 0, SeqToAlign(0, 1, Site1))
        LastPos = Pos
        Pos = InStr(Pos + 1, Tmp, Chr(9), vbBinaryCompare)
        'Tmp2 = Mid$(Tmp, LastPos + 1, (Pos - LastPos) - 1)
        'X = X
        'XX = UBound(CoevAlignToCoevSeq, 1)
        'XX = Val(Mid$(Tmp, LastPos + 1, (Pos - LastPos) - 1) + 1)
        Site2 = CoevAlignToCoevSeq(val(Mid$(Tmp, LastPos + 1, (Pos - LastPos) - 1) + 1))
        'If SeqToAlign(0, 1, Site2) <> Site2 Then
        '    X = X
        'End If
        CoevSitePairList(1, ValidPos) = AlignToSeq(0, 0, SeqToAlign(0, 1, Site2))
        'Tmp2 = Right$(Tmp, Len(Tmp) - Pos)
        CoevSitePairList(2, ValidPos) = val(Right$(Tmp, Len(Tmp) - Pos))
        x = x
    End If
    x = x
Loop
NumCoevSites = ValidPos
Close #1
x = x

'Read the Synsubst results and write them to a linear array with coordinates mapped to those of the ct file


Dim AlphaVals() As Single, AV As Single
ReDim AlphaVals(Len(StrainSeq(0)))
Open "E_dengue2_polyprotein_300_aligned_FUBAR_report.csv" For Input As #1
Tmp = ""
Line Input #1, Tmp
x = x
For x = 0 To UBound(AlphaVals, 1)
    AlphaVals(x) = -1
Next x
Do While Not EOF(1)

    Input #1, Site1
    Site1 = Site1 * 3 - 2
    
    Input #1, AV
    'uncomment to look at all sites else all we look at is the third position
    'AlphaVals(AlignToSeq(1, 0, SeqToAlign(1, 1, Site1))) = AV
    'AlphaVals(AlignToSeq(1, 0, SeqToAlign(1, 1, Site1 + 1))) = AV
    AlphaVals(AlignToSeq(1, 0, SeqToAlign(1, 1, Site1 + 2))) = AV
    Line Input #1, Tmp
    x = x

Loop
Close #1


'Load regions
Dim RegionCount As Long, RegionName() As String, RegionCoords() As Long
ReDim RegionName(100), RegionCoords(1, 100)
Open "regions.csv" For Input As #1

Line Input #1, Tmp
Do While Not EOF(1)
    Input #1, Site1
    If Site1 > UBound(RegionName, 1) Then
        ReDim Preserve RegionName(Site1 + 100)
        ReDim Preserve RegionCoords(1, Site1 + 100)
    End If
    Input #1, RegionCoords(0, Site1)
    Input #1, RegionCoords(1, Site1)
    Input #1, RegionName(Site1)
    Do
        Pos = InStr(1, RegionName(Site1), ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(RegionName(Site1), Pos, 1) = "+"
        Else
            Exit Do
        End If
    Loop
    RegionCount = Site1
    x = x
Loop
Close #1

'Add coev data to pairing array
'0 = neither
'2=both
'1=pairing
'3 = coev


Dim PA() As Byte
ReDim PA(UBound(PairingArray, 1), UBound(PairingArray, 1))
A = 0
For x = 0 To UBound(PairingArray, 1)
    For Y = 0 To UBound(PairingArray, 1)
        If Abs(x - Y) <= MaxDist Then
            PA(x, Y) = PairingArray(x, Y)
            If PairingArray(x, Y) > 0 Then
                A = A + 1
            End If
        Else
            PA(x, Y) = 255
        End If
    Next Y
Next x
A = A
'ignor identical sites
If x = 12345 Then
    For x = 0 To Len(StrainSeq(0))
        If Identical(x) = 1 Then
            Z = CoevAlignToCoevSeq(x)
            Z = AlignToSeq(0, 0, SeqToAlign(0, 1, Z))
            For Y = 0 To UBound(PairingArray, 1)
                
                    PA(Z, Y) = 255
                    PA(Y, Z) = 255
                
            Next Y
        End If
    Next x
End If


OffS = 0
For x = 1 To NumCoevSites
    
    If PA(CoevSitePairList(0, x) + OffS, CoevSitePairList(1, x) + OffS) = 1 Then
        PA(CoevSitePairList(0, x) + OffS, CoevSitePairList(1, x) + OffS) = 2
        PA(CoevSitePairList(1, x) + OffS, CoevSitePairList(0, x) + OffS) = 2
        
        If CoevSitePairList(0, x) < 150 Then
            x = x
        End If
        
    ElseIf PA(CoevSitePairList(0, x) + OffS, CoevSitePairList(1, x) + OffS) <> 255 Then
        PA(CoevSitePairList(0, x) + OffS, CoevSitePairList(1, x) + OffS) = 3
        PA(CoevSitePairList(1, x) + OffS, CoevSitePairList(0, x) + OffS) = 3
    End If
Next x




'Test for association between coevolving sites and paired sites in each region

'0 = neither
'2=both
'1=pairing
'3 = coev
Dim A2 As Long, b2 As Long, c2 As Long, D2 As Long
ReDim CPV(RegionCount + 2)
A2 = 0: b2 = 0: c2 = 0: D2 = 0
For x = 1 To RegionCount
    A = 0: b = 0: C = 0: D = 0
    For Z = RegionCoords(0, x) To RegionCoords(1, x) - 1
        For Y = Z + 1 To RegionCoords(1, x)
            If PA(Z, Y) = 0 Then
                D = D + 1
            ElseIf PA(Z, Y) = 1 Then
                b = b + 1
            ElseIf PA(Z, Y) = 2 Then
                A = A + 1
            ElseIf PA(Z, Y) = 3 Then
                C = C + 1
            
            
            End If
        Next Y
    Next Z
    A2 = A2 + A
    b2 = b2 + b
    c2 = c2 + C
    D2 = D2 + D
    CPV(x) = CalcChiP(A, b, C, D)
    Open "test chi.csv" For Append As #1
    Print #1, Str(x) + "," + Str(A) + "," + Str(b) + ","; Str(C) + ","; Str(D)
    Close #1
    x = x
Next x
CPV(RegionCount + 1) = CalcChiP(A2, b2, c2, D2)

A = 0: b = 0: C = 0: D = 0
For Z = 1 To LenS - 1
    For Y = Z + 1 To LenS
        If PA(Z, Y) = 0 Then
            D = D + 1
        ElseIf PA(Z, Y) = 1 Then
            b = b + 1
        ElseIf PA(Z, Y) = 2 Then
            A = A + 1
        ElseIf PA(Z, Y) = 3 Then
            C = C + 1
        End If
    Next Y
Next Z
CPV(RegionCount + 2) = CalcChiP(A, b, C, D)

'Test for an ssociation between pairing and low syn subst rates
Dim ListP() As Single, ListU() As Single, LPn As Long, LPU As Long, Tot As Single, U As Double
Dim AVSyn() As Double
ReDim AVSyn(RegionCount + 2)
Dim AvBSyn As Single
ReDim ListU(LenS)
LPU = 0
AvBSyn = 0
For x = 1 To LenS
    If AlphaVals(x) <> -1 Then
        If PairedSites(x) = 0 Then
            LPU = LPU + 1
            ListU(LPU) = AlphaVals(x)
            AvBSyn = AvBSyn + AlphaVals(x)
        End If
    End If
Next x
AvBSyn = AvBSyn / LPU
Dim SPV() As Single
ReDim SPV(RegionCount + 2)
'0.8634
For A = 1 To RegionCount + 2
    ReDim ListP(LenS)
    LPn = 0
    AVSyn(A) = 0
    
    If A <= RegionCount Then
        For x = RegionCoords(0, A) To RegionCoords(1, A)
            If AlphaVals(x) <> -1 Then
                If PairedSites(x) = 1 Then
                    LPn = LPn + 1
                    ListP(LPn) = AlphaVals(x)
                    AVSyn(A) = AVSyn(A) + AlphaVals(x)
                End If
            End If
        Next x
    ElseIf A = RegionCount + 1 Then
        For b = 1 To RegionCount
            For x = RegionCoords(0, b) To RegionCoords(1, b)
                If AlphaVals(x) <> -1 Then
                    If PairedSites(x) = 1 Then
                        LPn = LPn + 1
                        ListP(LPn) = AlphaVals(x)
                        AVSyn(A) = AVSyn(A) + AlphaVals(x)
                    End If
                End If
            Next x
        Next b
    Else
        For x = 1 To LenS
            If AlphaVals(x) <> -1 Then
                If PairedSites(x) = 1 Then
                    LPn = LPn + 1
                    ListP(LPn) = AlphaVals(x)
                    AVSyn(A) = AVSyn(A) + AlphaVals(x)
                End If
            End If
        Next x
    End If
    AVSyn(A) = AVSyn(A) / LPn
    
    U = 0
    Tot = 0
    tot2 = 0
    For x = 1 To LPn
        For Y = 1 To LPU
            If ListP(x) < ListU(Y) Then
                Tot = Tot + 1
            ElseIf ListP(x) = ListU(Y) Then
                Tot = Tot + 0.5
                tot2 = tot2 + 0.5
            Else
                tot2 = tot2 + 1
            End If
        Next Y
    Next x
    'If tot2 > Tot Then
        u1 = LPn * LPU + (LPn * ((LPn + 1) / 2)) - Tot
    'Else
        u2 = (LPn * LPU) + (LPU * ((LPU + 1) / 2)) - tot2
    'End If
    
    If u1 < u2 Then
        U = u1
    Else
        U = u2
    End If
    
    
    Dim M As Double, SD As Double
    
    M = (LPn * LPU) / 2
    SD = LPn * LPU
    SD = SD * (LPn + LPU + 1)
    SD = SD / 12 '(LPN + LPU)
    SD = Sqr(SD)
    U = (U - M) / SD
    
    x = x
    'XX = NormalZ(1.96)
    WinP = NormalZ(U)
    SPV(A) = WinP
Next A
x = x




Open "results.csv" For Output As #1
Print #1, "Genome site, Start, End, Coev,AvSyn Pair vs unpair ,Syn Subst"

For x = 1 To RegionCount
    Print #1, RegionName(x) + "," + Str(RegionCoords(0, x)) + "," + Str(RegionCoords(1, x)) + "," + Str(CPV(x)) + "," + Str(AVSyn(x)) + "vs" + Str(AvBSyn) + "," + Str(SPV(x))
Next x

Print #1, "All " + Trim(Str(RegionCount)) + " Regions, --, --," + Str(CPV(RegionCount + 1)) + "," + Str(AVSyn(RegionCount + 1)) + "vs" + Str(AvBSyn) + "," + Str(SPV(RegionCount + 1))
Print #1, "Whole Sequence, --, --," + Str(CPV(RegionCount + 2)) + "," + Str(AVSyn(RegionCount + 2)) + "vs" + Str(AvBSyn) + "," + Str(SPV(RegionCount + 2))

Close #1

End Sub
Public Sub PassXOInfoOver(SEventNumber As Long, SEN As Long, Seqno As Long, MinPx As Double, WinY As Long, CurrentXOver() As Integer, XoverList() As XOverDefine, Confirm() As Integer, ConfirmP() As Double)
Dim x As Long, TempC() As Single, TempCP() As Single, Z As Long, Y As Long
WinY = -1


Dim UBSEL As Long
UBSEL = UBound(SuperEventList, 1)

For x = 1 To CurrentXOver(Seqno)
    If XoverList(Seqno, x).Eventnumber <= UBSEL Then
    If SuperEventList(XoverList(Seqno, x).Eventnumber) = SEventNumber Then
        
        If XoverList(Seqno, x).Probability < MinPx And XoverList(Seqno, x).Probability > 0 And DoScans(0, XoverList(Seqno, x).ProgramFlag) = 1 Then
            MinPx = XoverList(Seqno, x).Probability
            WinY = x
        End If
        'Update confirms etc.
        PN = XoverList(Seqno, x).ProgramFlag
        If PN > AddNum - 1 Then PN = PN - AddNum
        'Confirm(SEN, PN) = Confirm(SEN, PN) - 1
        'ConfirmP(SEN, PN) = ConfirmP(SEN, PN) - (-Log10(XOverlist(Seqno, X).Probability))
        
        If SEventNumber > UBound(YannWarn, 1) Then ReDim Preserve YannWarn(SEventNumber + 100)
        YannWarn(SEventNumber) = 1
        If UBound(ConfirmP, 1) >= SEventNumber Then
            Confirm(SEventNumber, PN) = 1
            ConfirmP(SEventNumber, PN) = (-Log10(XoverList(Seqno, x).Probability))
            
        Else
            ReDim TempC(UBound(Confirm, 1) + 100, UBound(Confirm, 2))
            ReDim TempCP(UBound(ConfirmP, 1) + 100, UBound(ConfirmP, 2))
            
            For Z = 0 To UBound(Confirm, 1)
                For Y = 0 To UBound(Confirm, 2)
                    TempC(Z, Y) = Confirm(Z, Y)
                    TempCP(Z, Y) = ConfirmP(Z, Y)
                Next Y
            Next Z
            ReDim Confirm(UBound(Confirm, 1) + 100, UBound(Confirm, 2))
            ReDim ConfirmP(UBound(ConfirmP, 1) + 100, UBound(ConfirmP, 2))
            For Z = 0 To UBound(Confirm, 1) - 100
                For Y = 0 To UBound(Confirm, 2)
                    Confirm(Z, Y) = TempC(Z, Y)
                    ConfirmP(Z, Y) = TempCP(Z, Y)
                Next Y
            Next Z
        End If
    End If
    End If
Next x

If WinY = -1 Then
    For x = 1 To CurrentXOver(Seqno)
        If XoverList(Seqno, x).Eventnumber <= UBSEL Then
            If SuperEventList(XoverList(Seqno, x).Eventnumber) = SEventNumber Then
                
                If XoverList(Seqno, x).Probability < MinPx And XoverList(Seqno, x).Probability > 0 Then
                    MinPx = XoverList(Seqno, x).Probability
                    WinY = x
                End If
                
            End If
        End If
    Next x

End If
End Sub
Public Sub MakeSLookup(NextNo, IndividualA, IndividualB, ISeqs() As Long, RNum() As Long, MaskSeq() As Integer, TraceSub() As Long, SLookup() As Long, SLookupNum() As Long, ActualSeqSize() As Long)

Dim x As Long
ReDim SLookup(1, NextNo + 1), SLookupNum(1)
            
            
If IndividualB > -1 Then
    'Seq1 = Nextno - RNum(WinPP) + WinPPY
    Call IndB(NextNo, IndividualA, IndividualB, RNum(), MaskSeq(), TraceSub(), SLookup(), SLookupNum, ActualSeqSize())
   
ElseIf IndividualA > -1 Then
    
    Call IndA(NextNo, IndividualA, IndividualB, ISeqs(), RNum(), MaskSeq(), TraceSub(), SLookup(), SLookupNum, ActualSeqSize())
       
Else
   'For WinPPY = 0 To RNum(WinPP)
       For x = 0 To NextNo
           If MaskSeq(x) = 0 Then
               SLookupNum(0) = SLookupNum(0) + 1
               SLookup(0, SLookupNum(0)) = x
               SLookupNum(1) = SLookupNum(1) + 1
               SLookup(1, SLookupNum(1)) = x
           End If
       Next x
   'Next WinPPY
End If

End Sub
Public Sub IndA(NextNo, IndividualA, IndividualB, ISeqs() As Long, RNum() As Long, MaskSeq() As Integer, TraceSub() As Long, SLookup() As Long, SLookupNum() As Long, ActualSeqSize() As Long)


Dim x As Long

For x = NextNo - RNum(WinPP) To NextNo
    If TraceSub(x) = IndividualA Then Exit For
Next x
If x <= NextNo Then
    Seq1 = TraceSub(x)
    For x = 0 To NextNo - RNum(WinPP) - 1
        If TraceSub(x) <> Seq1 And MaskSeq(x) < 2 And ActualSeqSize(x) > MinSeqSize Then
            SLookupNum(0) = SLookupNum(0) + 1
            SLookup(0, SLookupNum(0)) = x
            SLookupNum(1) = SLookupNum(1) + 1
            SLookup(1, SLookupNum(1)) = x
        End If
    Next x
Else
    SLookupNum(1) = 1
    Seq1 = TraceSub(ISeqs(WinPP))
    For x = 0 To NextNo - RNum(WinPP) - 1
        If TraceSub(x) = IndividualA Then
            SLookupNum(0) = SLookupNum(0) + 1
            SLookup(0, 1) = x
        ElseIf TraceSub(x) <> Seq1 And MaskSeq(x) < 2 And ActualSeqSize(x) > MinSeqSize Then
            SLookupNum(1) = SLookupNum(1) + 1
            SLookup(1, SLookupNum(1)) = x
        End If
        
    Next x
       
End If
End Sub


Public Sub IndB(NextNo, IndividualA, IndividualB, RNum() As Long, MaskSeq() As Integer, TraceSub() As Long, SLookup() As Long, SLookupNum() As Long, ActualSeqSize() As Long)


For x = NextNo - RNum(WinPP) To NextNo
    If TraceSub(x) = IndividualA Or TraceSub(x) = IndividualB Then Exit For
Next x
If x <= NextNo Then
    Seq1 = TraceSub(x)
    If Seq1 = IndividualA Then
        SLookup(0, 1) = IndividualB
    Else
        SLookup(0, 1) = IndividualA
    End If
    SLookupNum(1) = 1
    For x = 0 To NextNo - RNum(WinPP) - 1
        If TraceSub(x) <> Seq1 And MaskSeq(x) < 2 And ActualSeqSize(x) > MinSeqSize Then
            If TraceSub(x) <> IndividualA And TraceSub(x) <> IndividualB Then
                SLookupNum(1) = SLookupNum(1) + 1
                SLookup(1, SLookupNum(1)) = x
            End If
        End If
    Next x
Else
    SLookupNum(0) = 1
    SLookup(0, 1) = IndividualA
    SLookupNum(1) = 2
    SLookup(1, 2) = IndividualB
End If

End Sub

Public Sub CheckSisMem()
Dim LmB As Variant, OP As Long
GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwTotalPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        LmB = Len(StrainSeq(0))
        LmB = LmB * SSNumPerms
        LmB = LmB * 12
        If APhys < LmB Then
                OP = SSNumPerms
            SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
            pSSNumPerms = SSNumPerms
            If SSNumPerms < 100 Then
            
                'MsgBox ("There is not enough free memory available to perform a SiScans in either exploratory or checking modes - Both modes will, therefore, be disabled.  Perhaps if you close some programs the situation will improve.")
                DoScans(0, 5) = 0
                DoScans(1, 5) = 0
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Else
                'MsgBox ("You have specified that you would like to do a Siscans with " + Trim(Str(OP)) + " permutations. There is, however, only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations.")

            End If
        End If

End Sub
Public Sub MakeTotX(AddNum, TotT, MethodTime() As Double, TimeFract() As Double)
Dim x As Long
TotT = 0
For x = 0 To AddNum - 1
    TotT = TotT + MethodTime(x)
Next x

If TotT > 0 Then
    For x = 0 To AddNum - 1
        TimeFract(x) = MethodTime(x) / TotT
        
    Next x
Else
    For x = 0 To AddNum - 1
        TimeFract(x) = 0.2
        
    Next x
    TotT = 1.2
End If
'XX = TimeFract(0)
x = x
End Sub

Public Function strGetCommonAppDataPath() As String
    Dim strPath As String

    strPath = Space$(512)
    'Call SHGetFolderPath(0, CSIDL_COMMON_APPDATA, 0, 0, strPath)
    strPath = Left$(strPath, InStr(strPath, vbNullChar))

    strGetCommonAppDataPath = strPath
End Function
Public Sub RecheckSpecificsignal(RX, RY)
Dim oRelX, oRelY, SENum As Long ', ListToCHeck(10) As Long
SENum = SuperEventList(XoverList(RX, RY).Eventnumber)
oRelX = RelX
oRelY = RelY

RelX = RX
RelY = RY
'ListToCHeck(0) = 0
'ListToCHeck(1) = 1
'ListToCHeck(2) = 2
'ListToCHeck(3) = 3
'ListToCHeck(4) = 4
'ListToCHeck(5) = 5
'ListToCHeck(6) = 16

ISPerm(0) = XoverList(RX, RY).Daughter
ISPerm(1) = XoverList(RX, RY).MajorP '1213
ISPerm(2) = XoverList(RX, RY).MinorP '2774

DontRedrawPlotsFlag = 1
MinPAGlobal = 1
' GrabProbsFlag = 1
If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
    CurrentCheck = 0
    Call RDPChecking
ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
    CurrentCheck = 16
    Call ChimaeraChecking ' ts is sent to chimaerachecking so that all three tracks get tested
ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
    CurrentCheck = 1
    GCSeq1 = XoverList(RX, RY).Daughter
    GCSeq2 = XoverList(RX, RY).MajorP '1213
    GCSeq3 = XoverList(RX, RY).MinorP '2774
    If Len(StrainSeq(0)) < 30000 Then
        Call GCCompare
    End If
    If pGCTripletflag = 0 Then
        Call GCChecking
    Else
        Call GCChecking2
    End If

ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
    CurrentCheck = 2
    Call BootscanChecking
ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
    CurrentCheck = 10
    Call TSChecking ' chimaera is sent to ts checking so that all three tracks get tested
ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
    CurrentCheck = 5
    Call SiScanChecking
ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
    'Call PhylProChecking
ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
    CurrentCheck = 4
    If MCTripletFlag = 0 Then
        Call MaxChiChecking
    Else
        Call MaxChiCheckingII
    End If
End If
x = x
'GrabProbsFlag = 0
'update the signals in bestxolistmi and bestxolistma?






 

CurrentCheck = -1

DontRedrawPlotsFlag = 0
If MinPAGlobal < 1 Then
    XoverList(RX, RY).Probability = MinPAGlobal
    
    PF = XoverList(RX, RY).ProgramFlag
    If PF = 3 Or PF = 5 Then
        If PF < AddNum Then
            
            ConfirmP(SENum, PF) = ConfirmP(SENum, PF) + -Log10(XoverList(RX, RY).Probability)
        End If
    End If
    'XX = Confirm(SENum, PF)
End If

Dim Prog As Long, EvN As Long, PV As Double, BE As Long, EN As Long
Prog = XoverList(RX, RY).ProgramFlag
EvN = SuperEventList(XoverList(RX, RY).Eventnumber)
'XX = RelX
PV = MinPAGlobal 'XOverlist(RX, RY).Probability
BE = XoverList(RX, RY).Beginning
EN = XoverList(RX, RY).Ending
XX = BestEvent(EvN, 0)
If PV = 1 Then PV = -1
If x = x Then 'PV < LowestProb Then
    For x = 0 To PermNextno
        If MinorPar(EvN, x) > 0 Then
            For Y = 1 To BCurrentXoverMi(x)
            
                If SuperEventList(BestXOListMi(x, Y).Eventnumber) = EvN Then
                    If BestXOListMi(x, Y).ProgramFlag = Prog And BestXOListMi(x, Y).MinorP = RX Then '- need to use orelx because relx get replaced by the new version
                        BestXOListMi(x, Y).Probability = PV
                        BestXOListMi(x, Y).Ending = EN
                        BestXOListMi(x, Y).Beginning = BE
                    End If
                End If
            Next Y
        End If
        If MajorPar(EvN, x) > 0 Then
            For Y = 1 To BCurrentXoverMa(x)
                If SuperEventList(BestXOListMa(x, Y).Eventnumber) = EvN Then
                    If BestXOListMa(x, Y).ProgramFlag = Prog And BestXOListMa(x, Y).MajorP = RX Then
                        BestXOListMa(x, Y).Probability = PV
                        BestXOListMa(x, Y).Ending = EN
                        BestXOListMa(x, Y).Beginning = BE
                    End If
                End If
            Next Y
        End If
    
    Next x
End If
    
   
x = x


RelX = oRelX
RelY = oRelY
End Sub

Public Function CheckYann(PHIWarn, SEN As Long, ISeqs() As Long, BPos As Long, Epos As Long, SeqNum() As Integer, ExtraHits() As Byte, ExtraHitsMi() As Byte, ExtraHitsMa() As Byte, TraceSub() As Long)
Dim x As Long, S1 As Long, s2 As Long, S3 As Long, n1 As Long, n2 As Long, N3 As Long, IsPresent(255) As Byte, A(2) As Long, b(2) As Long, TotA As Long, TotB As Long, C(2) As Long, D(2) As Long, ChiV As Double, Warn As Double, Z As Long
Dim Y As Long

'Dim Ax(2) As Long, Bx(2) As Long
'If x = x Then
'&
    Dummy = CheckYannP(SEN, NextNo, Len(StrainSeq(0)), BPos, Epos, ISeqs(0), UBound(SeqNum, 1), SeqNum(0, 0), IsPresent(0), TraceSub(0), UBound(ExtraHits, 1), UBound(ExtraHitsMi, 1), UBound(ExtraHitsMa, 1), ExtraHits(0, 0), ExtraHitsMi(0, 0), ExtraHitsMa(0, 0), A(0), b(0))

'S1 = ISeqs(0)
's2 = ISeqs(1)
'S3 = ISeqs(2)
'    If BPos < Epos Then
'        '@'@'@
'        For x = 1 To BPos - 1
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    '@'@'@'@'$'$'$
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            A(0) = A(0) + 1
'                        ElseIf n1 = N3 Then
'                            A(1) = A(1) + 1
'                        ElseIf n2 = N3 Then
'                            A(2) = A(2) + 1
'                        End If
'                    Else
'                    x = x
'                    End If
'                End If
'            End If
'        Next x
'        '@'@'@'@''@
'        For x = Epos + 1 To Len(StrainSeq(0))
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            '@'@'@
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    '@
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            A(0) = A(0) + 1
'                        ElseIf n1 = N3 Then
'                            A(1) = A(1) + 1
'                        ElseIf n2 = N3 Then
'                            A(2) = A(2) + 1
'                        End If
'                    Else
'                    x = x
'                    End If
'                End If
'            End If
'        Next x
'        For x = BPos To Epos
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    '@
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            B(0) = B(0) + 1
'                        ElseIf n1 = N3 Then
'                            B(1) = B(1) + 1
'                        ElseIf n2 = N3 Then
'                            B(2) = B(2) + 1
'                        End If
'                    Else
'                    x = x
'                    End If
'                End If
'            End If
'        Next x
'    Else
'        For x = Epos + 1 To BPos - 1
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            A(0) = A(0) + 1
'                        ElseIf n1 = N3 Then
'                            A(1) = A(1) + 1
'                        ElseIf n2 = N3 Then
'                            A(2) = A(2) + 1
'                        End If
'
'                    End If
'                End If
'            End If
'        Next x
'        For x = 1 To Epos
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            B(0) = B(0) + 1
'                        ElseIf n1 = N3 Then
'                            B(1) = B(1) + 1
'                        ElseIf n2 = N3 Then
'                            B(2) = B(2) + 1
'                        End If
'
'                    End If
'                End If
'            End If
'        Next x
'        For x = BPos To Len(StrainSeq(0))
'            n1 = SeqNum(x, S1)
'            n2 = SeqNum(x, s2)
'            N3 = SeqNum(x, S3)
'
'            If n1 > 46 And n2 > 46 And N3 > 46 Then
'                If n1 <> n2 Or n1 <> N3 Then
'                    'check if this site is parsimony informative wrt recombination (i.e. recombinant and all its corecombinnats are considered as a single sequence as parents and their co-parenst are all considered single sequneces)
'                    IsPresent(n1) = 0: IsPresent(n2) = 0: IsPresent(N3) = 0
'                    For Y = 0 To NextNo
'                        Z = TraceSub(Y)
'                        If Z <= UBound(ExtraHits, 1) And Z <= UBound(ExtraHitsMi, 1) And Z <= UBound(ExtraHitsMa, 1) Then
'                            If ExtraHits(Z, SEN) = 0 And ExtraHitsMi(Z, SEN) = 0 And ExtraHitsMa(Z, SEN) = 0 Then
'                                IsPresent(SeqNum(x, Y)) = 1
'                            End If
'                        End If
'                    Next Y
'                    If IsPresent(n1) = 1 And IsPresent(n2) = 1 And IsPresent(N3) = 1 Then 'this polymorphic site is informative about this ercombination event
'                        If n1 = n2 Then
'                            B(0) = B(0) + 1
'                        ElseIf n1 = N3 Then
'                            B(1) = B(1) + 1
'                        ElseIf n2 = N3 Then
'                            B(2) = B(2) + 1
'                        End If
'
'                    End If
'                End If
'            End If
'        Next x
'    End If
'End If
'If Ax(0) <> A(0) Or Ax(1) <> A(1) Or Ax(2) <> A(2) Then
'x = x
'End If
'If Bx(0) <> B(0) Or Bx(1) <> B(1) Or Bx(2) <> B(2) Then
'x = x
'End If
TotA = A(0) + A(1) + A(2)
TotB = b(0) + b(1) + b(2)
Warn = 1
Dim ChiP As Double
Dim MC As Long
If MCFlag = 0 Then
    MC = MCCorrection
Else
    MC = 1
End If

For x = 0 To 2
    ChiV = CalcChiValue2(A(x), b(x), TotA, TotB)
    If ChiV > 0 Then
        ChiP = ChiPVal2(ChiV) * MC
    
    
        If ChiP < 0.05 Then
            If PHIWarn = 0 Then
                Warn = 0
                'Exit For
            Else
               If ChiP < 0.0001 Then
                    Warn = 0
               End If
            End If
        End If
    End If
Next x
CheckYann = Warn

End Function
Public Sub UpdateIDScores()
If RelX = 0 And RelY = 0 Then Exit Sub
Dim SeqMap() As Byte, WeightMod() As Long, PermSScores() As Long, PermPScores() As Long, PScoreHolder() As Long, SScoreHolder() As Long, SeqScore3() As Integer
Dim DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, Seq34Conv() As Byte, VRandConv(15, 12) As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte
Dim STime As Long, SAll As Long, oSeq As Long, RankF(2, 1) As Long
Dim BPMat() As Single
Dim CorrectP As Double
SAbortFlag = 0
MaxRepeatCycles = 2
Dim tDaught() As Byte, OSX As String
DoQuick = 0
Dim NoRes As Byte

NoRes = 1
Dim tDon() As Byte
Dim TotP() As Double, TVal() As Double, TPVal() As Double, PScores() As Double, RLScore() As Double


Dim tDscores() As Double, ZPScoreHolder() As Double, ZSScoreHolder() As Double

Dim Consensus() As Double
'
SSSS = Abs(GetTickCount)

Dim EventScore() As Long, Y As Long, otMatch As Double, OKSeq() As Double, RFF As Byte, SRCompatF(2) As Double, SRCompatS(2) As Double, RList2() As Long, RNum2() As Long
Dim PhPrScore() As Double, PhPrScore2() As Double, tPhPrScore2() As Double, SubPhPrScore2() As Double, SubScore2() As Double
Dim MeanPScore() As Double, SDPScore() As Double
Dim RetrimFlag As Byte
Dim PhPrScore3() As Double, tPhPrScore3() As Double, SubPhPrScore3() As Double, SubScore3() As Double
Dim NuminGroup() As Long, BPlots() As Single, tRCorr() As Single, RCorr() As Single, RInv() As Single, ListCorr3() As Single, ListCorr() As Single, ListCorr2() As Single, tListCorr() As Single, BadDists() As Single, SSDist(2) As Double, TDiffs() As Single, TValid() As Single
Dim oRNumX(2), SimScore() As Byte, SimScoreB() As Double, UNF() As Byte, INList() As Byte, OUList() As Byte, AAF As Byte, MiF As Byte, MaxBP(1) As Double, oPMax As Single, oPMin As Single, RWinPP As Byte, NPh As Long, SetTot() As Long, TotD As Double, RCorrWarn() As Byte, DontRedo() As Byte
Dim oXOSize As Long, JumpFlag As Byte, tEventAdd As Long, Epos As Long, BPos As Long, DMatS() As Single, LDst(1) As Double, AVSN(3) As Double, LowP As Double, RedoCycle As Byte, SLS As Long, UBX As Long
Dim InvS() As Byte, DoneProg() As Byte, TempDone() As Byte, DoneSeq() As Byte
Dim Outlyer(3) As Byte, SeqPair(2) As Byte, MinPair(1) As Byte
Dim DoneTarget As Byte, MissIDFlag As Byte
Dim Relevant2() As Byte, PDist(2, 3) As Single, tMatch(1) As Double, TrpScore(3) As Double, SubScore(3) As Double, SubPhPrScore(2) As Double
Dim MinDist(1) As Double, LDist(2) As Double, LDist2(2) As Double, LDist3(2) As Double, LDist4(2) As Double, LDistB(2) As Double, LDistB2(2) As Double, LDistB3(2) As Double, LDistB4(2) As Double, TtX(1) As Double, IntVal(1) As Double, MinDistZ(2) As Double

Dim TmF As Double, AvDst As Double

Dim TraceSub() As Long, Uninvolved() As Long
Dim dMax(2) As Single, RCompatC(2) As Long, RCompatD(2) As Long, RCompatB(2) As Long, RCompat(2) As Long, BPosLR(3) As Long, RSize(5) As Long, CSeq(1) As Long, CompMat(2, 1) As Long, ISeqs(2) As Long, Trace(1) As Long
Dim NScoresX() As Long, WinnerPos() As Long, WinnerPosMa() As Long, WinnerPosMi() As Long, SLookup() As Long, SLookupNum() As Long, DoPairs() As Byte, RListX() As Long, RNumX() As Long, RList() As Long, RNum() As Long, oRNum() As Long
Dim OuCheck() As Long, oBreaks() As Long, oRList() As Long, tMatchX() As Long, FoundOne() As Long, SQ() As Long, OLSeq() As Long, OLSeqB() As Long, OLSeqE() As Long, GoodC() As Long, MinSeq() As Long, MaxSeq() As Long, GroupSeq() As Long, DoneOne() As Long, Breaks() As Long, InvListX() As Long, InvList() As Long, InPen() As Long, InPenX() As Long
Dim NumD As Long, x As Long, Mi As Long, DA As Long, Ma As Long, UB As Long
Dim OLSize As Long, TWinner As Long, BPos2 As Long, EPos2 As Long, tWinPP As Long, OS As Long, OE As Long, WinPP As Long, ActualE As Long, BXOSize As Long
Dim xNextno As Long, WinPPY As Long, EventAdd As Long, SP(5) As Long, EP(5) As Long, VSN As Long, tSN As Long, oldY As Long, XOSize As Long, WinRL As Long, oTotRecs As Long, sNextno As Long
Dim PhylCheck As Byte

Dim CAcList() As Integer, AcList() As Integer, tSeqnum() As Integer
Dim tBXOListMa() As XOverDefine, tBXOListMi() As XOverDefine, CollectEvents() As XOverDefine, CollectEventsMi() As XOverDefine, CollectEventsMa() As XOverDefine, PXOList() As XOverDefine, TempXOList() As XOverDefine, BestXOList() As XOverDefine
Dim tBcurrentxoverma() As Integer, tBcurrentxovermi() As Integer, DoneX() As Long, RCats() As Long, NRNum() As Long, NRList() As Long, NRNum2() As Long, NRList2() As Long, Relevant() As Long, PCurrentXover() As Integer, tCurrentxover() As Integer, BCurrentXOver() As Integer
Dim SENum As Long
  
  
  
  
oSeq1 = Seq1
oSeq2 = Seq2
oSeq3 = Seq3

    
    'Call UnModSeqNum(0)
Dim exEventnumber As Long

exEventnumber = Eventnumber
Eventnumber = XoverList(RelX, RelY).Eventnumber
'SENum = SEventNumber
SENum = SuperEventList(Eventnumber)
EditSeqFlag = 1
DontRedoQuickDistFlag = 1
BPos = XoverList(RelX, RelY).Beginning
Epos = XoverList(RelX, RelY).Ending

DontRedoQuickDistFlag = 0




Dim Segbound() As Byte
ReDim Segbound(Len(StrainSeq(0)))
If ReassortmentFlag = 1 Then
    
    For x = 0 To RBPNum
        'TBP = RBPPos(X)
        Segbound(RBPPos(x)) = 1
    Next x
End If



RedoCycle = 0
ReDim SQ(2), RecombNo(AddNum)
ReDim ExtraHits(PermNextno, 1), ExtraHitsMa(PermNextno, 1), ExtraHitsMi(PermNextno, 1)

If DoQuick = 0 Then
    PhylCheck = 1
Else
    PhylCheck = 0
End If
'xxx = CurDir
'Open "Scores.csv" For Output As #1
'Close #1
oGCIndelFlag = GCIndelFlag


   
        
If MCFlag = 0 Then
    CorrectP = LowestProb / MCCorrection
Else
    CorrectP = LowestProb
End If



'Make permanent copy of xoverlist
XOSize = UBound(XoverList, 2)


ReDim TraceSub(NextNo)
If NextNo > PermNextno Then
    ReDim Preserve PermOriginalName(NextNo)
End If
If PermNextno > NextNo Then
    For x = 0 To NextNo
        TraceSub(x) = x
        PermOriginalName(x) = OriginalName(TraceSub(x))
    Next x
ElseIf NextNo > PermNextno Then
    For x = PermNextno + 1 To NextNo
        TraceSub(x) = S2TraceBack(x)
        PermOriginalName(x) = OriginalName(TraceSub(x))
    Next x
End If
If NextNo > PermNextno Then
    ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
End If
TXOS = NextNo
'PermNextNo = NextNo
oNextno = NextNo
'Dummy = CopySeqs(Len(StrainSeq(0)), Nextno, SeqNum(0, 0), SimSeqNum(0, 0))

CompMat(0, 0) = 1: CompMat(0, 1) = 2: CompMat(1, 0) = 0: CompMat(1, 1) = 2: CompMat(2, 0) = 0: CompMat(2, 1) = 1

STime = Abs(ST)

ReDim RepeatCycles(1000)
ReDim Relevant(NextNo), Uninvolved(NextNo)
ReDim PCurrentXover(NextNo), TempXOList(NextNo, XOSize), PXOList(NextNo, XOSize)
ReDim DoneSeq(NextNo, UBound(PXOList, 2))
ReDim NumRecsI(NextNo), Relevant2(2, NextNo)

MSize = GetMSize(XoverList())


Call CopyXOLists(XOSize, DoneSeq(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())

Dim Last0 As Long, Last1 As Long

'Do 'loop until everything is completed from best to worst
    sNextno = NextNo
    DoneTarget = 0
    C = 0
    LowestProb = pLowestProb
     'Test movement in the tree
     XX = RelX
     XX = RelY
     BEX = RelX 'BestEvent(SENum, 0)
     BEY = RelY 'BestEvent(SENum, 1)
     Epos = XoverList(BEX, BEY).Ending
     BPos = XoverList(BEX, BEY).Beginning
     
     If BPos = 0 Then BPos = 1
     If Epos = 0 Then Epos = 1
     Seq1 = XoverList(BEX, BEY).Daughter
     Seq2 = XoverList(BEX, BEY).MajorP '1213
     Seq3 = XoverList(BEX, BEY).MinorP '2774
     'If SEventNumber = 12 Then
    
        
     ISeqs(0) = Seq1
     ISeqs(1) = Seq2
     ISeqs(2) = Seq3
     
     'Seq1 = 10
     'Seq2 = 0
     'Seq3 = 6
     
     
     LongFlag = DoneTarget
     
     
     ReDim FAMat(NextNo, NextNo), SAMat(NextNo, NextNo)
     
     off = ForcePhylE
     
     ForcePhylE = 0
     
     
     NSeq1 = Seq1
     NSeq2 = Seq2
     nseq3 = Seq3
     DontLoseSeqsFlag = 1
     Call MakeTreeSeqs(BPos, Epos)
     
     ISeqs(0) = Seq1
     ISeqs(1) = Seq2
     ISeqs(2) = Seq3
     
     DontLoseSeqsFlag = 0
     DontRedoQuickDistFlag = 1
     
     Call TestMoveInTree(0, 10, 1, BPos, Epos, SeqPair(), MinPair(), ISeqs(), SeqNum())
     
     DontRedoQuickDistFlag = 0
     
     
     
     
     
     ForcePhylE = off
     If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(SCMat, 1)
    On Error GoTo 0
    If UB > 0 Then
        For x = 0 To NextNo
            FCMat(x, x) = 0
            SCMat(x, x) = 0
            
        Next x
    End If
     Form1.SSPanel1.Caption = "Calculating recombinant identification scores"
     'is the diff in minpair translatable to a change in tree shape?
     MinDist(0) = 1000000
     MinDist(1) = 1000000
     
     Outlyer(0) = 2
     Outlyer(1) = 1
     Outlyer(2) = 0
     Z = 0
     
     For x = 0 To 1
         For Y = x + 1 To 2
             If FAMatSmall(x, ISeqs(Y)) < MinDist(0) Then
                 MinDist(0) = FAMatSmall(x, ISeqs(Y))
                 MinPair(0) = Z
                 SeqPair(0) = x
                 SeqPair(1) = Y
                 SeqPair(2) = Outlyer(Z)
             End If
             If SAMatSmall(x, ISeqs(Y)) < MinDist(1) Then
                 MinDist(1) = SAMatSmall(x, ISeqs(Y))
                 MinPair(1) = Z
             End If
             Z = Z + 1
         Next Y
     Next x
      
     RedoCycle = 0
     
     
     
     'Mark this specific example as the for this event.
     
   
   'find smallest distance in famat
    
    
    'The best remaining event is found (favouring those that cause movement in the tree)
    'now test which is the recominant
    
    
    'begin section3******************
    
    'Call PhylProChecks(NextNo, SubPhPrScore(), SubScore(), PhPrScore(), SubValid(), SubDiffs(), PermValid(), PermDiffs(), FAMat(), SAMat(), FMat(), SMat(), Iseqs())
    
    Dim LD(1, 2, 1) As Double, TraceInvolvedBak() As Long, DoneThis() As Long, tPhPrScore(2) As Double
    ReDim TraceInvolvedBak(NextNo)
    ReDim DoneThis(1, NextNo)
   
   
    'make donethis
    
     If PermNextno > MemPoc Then
        GetPermValid
        GetPermDiffs
    End If

    Call MakeSmallArrays(ISeqs(), PermValid(), PermValidSmall())
    Call MakeSmallArrays(ISeqs(), PermDIffs(), PermDiffsSmall())
    
    If PermNextno > MemPoc Then
        ReDim PermValid(0, 0), PermDIffs(0, 0)
    End If
    
    'Dummy = MakeDoneThis(Nextno, FMat(0, 0), FAMat(0, 0), SAMat(0, 0), LD(0, 0, 0), DoneThis(0, 0), ISeqs(0))
    
    'Dummy = MakeDoneThis2(Nextno, FMat(0, 0), FMat(0, 0), SMat(0, 0), DoneThis(0, 0), ISeqs(0))
    Dummy = MakeDoneThis3(NextNo, FMatSmall(0, 0), FMatSmall(0, 0), SMatSmall(0, 0), DoneThis(0, 0), ISeqs(0))
    
   
    For x = 0 To NextNo
            If DoneThis(0, x) = 0 Then
                If SubValidSmall(0, x) > 0 And SubValidSmall(1, x) > 0 And SubValidSmall(2, x) > 0 Then
                    If (SubDiffsSmall(0, x) / SubValidSmall(0, x)) > 0.6 Or SubDiffsSmall(1, x) / SubValidSmall(1, x) > 0.6 Or SubDiffsSmall(2, x) / SubValidSmall(2, x) > 0.6 Then
                        DoneThis(0, x) = 1 '0,2,3,4,6
                        DoneThis(1, x) = 1
                    End If
                End If
                If PermValidSmall(0, x) > 0 And PermValidSmall(1, x) > 0 And PermValidSmall(2, x) > 0 Then
                    If PermDiffsSmall(0, x) / PermValidSmall(0, x) > 0.6 Or PermDiffsSmall(1, x) / PermValidSmall(1, x) > 0.6 Or PermDiffsSmall(2, x) / PermValidSmall(2, x) > 0.6 Then
                        DoneThis(0, x) = 1
                        DoneThis(1, x) = 1
                    End If
                End If
            End If
        Next x
    
    
    If PermNextno > MemPoc Then
        GetFMat
        GetSMat
    End If
    Call MakeSSDistB(ISeqs(), SSDist(), FAMatSmall(), FMat(), SMat(), NextNo, DoneThis())

    'Phylpro correlation check - this uses all sites and not just variable sites
    'I must see if a variable sites version will work better
    ReDim PhPrScore(2)
    
    Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore(0), FMat(0, 0), SMat(0, 0), tPhPrScore(0), SubPhPrScore(0), SubScore(0))
    
    
    ReDim PhPrScore2(2), tPhPrScore2(2), SubScore2(3), SubPhPrScore2(2)
    
    'Call PhylProChecks(NextNo, SubPhPrScore2(), SubScore2(), PhPrScore2(), SubValid(), SubDiffs(), PermValid(), PermDiffs(), FAMat(), SAMat(), FAMat(), SAMat(), Iseqs())
    If PermNextno > MemPoc Then
        ReDim FMat(0, 0)
        ReDim SMat(0, 0)
        Call GetSAMat
        Call GetFAMat
    End If
    Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore2(0), FAMat(0, 0), SAMat(0, 0), tPhPrScore2(0), SubPhPrScore2(0), SubScore2(0))
    
    If PermNextno > MemPoc Then
        ReDim SAMat(0, 0)
        ReDim FAMat(0, 0)
        GetSCMat
        GetFCMat
    End If
    
    ReDim PhPrScore3(2), tPhPrScore3(2), SubScore3(3), SubPhPrScore3(2), DoneThis(1, NextNo)
   
    'make donethis
    'XX = Trace(1)
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SCMat, 1)
    On Error GoTo 0
    If UB > 0 Then
        'Dummy = MakeDoneThis(Nextno, FMat(0, 0), FCMat(0, 0), SCMat(0, 0), LD(0, 0, 0), DoneThis(0, 0), ISeqs(0))
            
        'Dummy = MakeDoneThis2(Nextno, FMat(0, 0), FMat(0, 0), SMat(0, 0), DoneThis(0, 0), ISeqs(0))
        For x = 0 To NextNo
            FCMat(x, x) = 0
            SCMat(x, x) = 0
            
        Next x
        
        Dummy = MakeDoneThis3(NextNo, FMatSmall(0, 0), FMatSmall(0, 0), SMatSmall(0, 0), DoneThis(0, 0), ISeqs(0))
        
        For x = 0 To NextNo
            If DoneThis(0, x) = 0 Then
                If SubValidSmall(0, x) > 0 And SubValidSmall(1, x) > 0 And SubValidSmall(2, x) > 0 Then
                    If (SubDiffsSmall(0, x) / SubValidSmall(0, x)) > 0.6 Or SubDiffsSmall(1, x) / SubValidSmall(1, x) > 0.6 Or SubDiffsSmall(2, x) / SubValidSmall(2, x) > 0.6 Then
                        DoneThis(0, x) = 1 '0,2,3,4,6
                        DoneThis(1, x) = 1
                    End If
                End If
                If PermValidSmall(0, x) > 0 And PermValidSmall(1, x) > 0 And PermValidSmall(2, x) > 0 Then
                    If PermDiffsSmall(0, x) / PermValidSmall(0, x) > 0.6 Or PermDiffsSmall(1, x) / PermValidSmall(1, x) > 0.6 Or PermDiffsSmall(2, x) / PermValidSmall(2, x) > 0.6 Then
                        DoneThis(0, x) = 1
                        DoneThis(1, x) = 1
                    End If
                End If
            End If
        Next x
        
    
        Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore3(0), FCMat(0, 0), SCMat(0, 0), tPhPrScore3(0), SubPhPrScore3(0), SubScore3(0))
    End If
    'end make phprscore
    If PermNextno > MemPoc Then
        ReDim SCMat(0, 0)
        ReDim FCMat(0, 0)
        
    End If
    
    'begin section 4**********************************************
    'More direct tree check for recombination
    'test for associations that have changed between the
    'famat and samat matrices for the sequence triplet in question
                
    'go down tree from closest to furthest away for each of the seqs
    '-Scores for all seqs on all branches of FAMat are averaged over the whole
    'branch
      
    
   For x = 0 To 2
                    
        ReDim DoneOne(NextNo), GroupSeq(NextNo), NuminGroup(NextNo)
        TrpScore(x) = 0
        'Dummy = MakeTrpGroups(x, NextNo, NumInGroup(0), CompMat(0, 0), ISeqs(0), DoneOne(0), GroupSeq(0), MinDistZ(0), FAMat(0, 0))
        Dummy = MakeTrpGroups2(x, NextNo, NuminGroup(0), CompMat(0, 0), ISeqs(0), DoneOne(0), GroupSeq(0), MinDistZ(0), FAMatSmall(0, 0))
                
        'Dummy = MakeTrpScore(x, NextNo, FAMat(0, 0), SAMat(0, 0), TrpScore(0), NumInGroup(0), ISeqs(0), GroupSeq(0))
        Dummy = MakeTrpScore2(x, NextNo, FAMatSmall(0, 0), SAMatSmall(0, 0), TrpScore(0), NuminGroup(0), ISeqs(0), GroupSeq(0))
                    
        
    Next x
    
    
    'end section 4*************************************
    '0.110 5k perms
    '(1) find NO, PI and NI
    Call MakeINList(INList(), OUList(), MinPair())
     x = x
    
    'begin section 5 ***************************************************
    'begin section 5.1 ***************************************************
    
    
    'Check for similar ddetected events with other sequences
    'do this first by looking accross each of the breakpoints and looking
    'for correlation between a potential recombinant sequenence and other sequences
    '(1) Each breakpoint is tested independantly using a simple distance scan
    'of sequences spanning the breakpoint
    '(2) Existing evidence of recombination is scanned for potential "co-recombinants"
    'identified in (1)
    
    '(1) independant testing of bps
    
    'Find VSN vriable sites on either side of two breakpoints
    
    tSN = 0: VSN = 60 '(XOverWindowX * 3) + mcwin
    
    Dummy = MakeBPosLR(VSN, tSN, Len(StrainSeq(0)), BPos, Epos, SeqNum(0, 0), ISeqs(0), BPosLR(0), AVSN(0))
    
    'end section 5.1 ****************************************************************
    '1.432 5K perms
    '0.040
    
    'begin section 5.2 ****************************************************************
    ReDim tRCorr(2, 2, 4, NextNo), InvS(2, NextNo), RCorr(2, 2, NextNo), RInv(2, 2, NextNo)
    'RInv is used to collect information on the polarity of the correlation - ie
    'whether, if you switch the parent groups in the triplet correlation scan across
    'the breakpoints you get a correlation or not
    
    
    SP(0) = BPosLR(0): EP(0) = BPos - 1
    SP(1) = BPos: EP(1) = BPosLR(1)
    SP(2) = BPosLR(2): EP(2) = Epos
    SP(3) = Epos + 1: EP(3) = BPosLR(3)
    SP(4) = BPos: EP(4) = Epos
    For x = 0 To 3
        If SP(x) > Len(StrainSeq(0)) Then
            SP(x) = SP(x) - Len(StrainSeq(0))
        ElseIf SP(x) < 1 Then
            SP(x) = SP(x) + Len(StrainSeq(0))
        End If
            
        If EP(x) > Len(StrainSeq(0)) Then
            EP(x) = EP(x) - Len(StrainSeq(0))
        ElseIf EP(x) < 1 Then
            EP(x) = EP(x) + Len(StrainSeq(0))
        End If
    Next x
    
    ReDim RCorrWarn(2)
   'XX = RCorrWarn(2)
    Call MakeProperRCorr(INList(), MissingData(), RCorrWarn(), RInv(), tRCorr(), RCorr(), CompMat(), Len(StrainSeq(0)), ISeqs(), SP(), EP(), SeqNum())
    If RCorrWarn(0) = 1 And RCorrWarn(1) = 1 Then RCorrWarn(2) = 0
   
    Call MakeDMatS(NextNo, SP(), EP(), SeqNum(), DMatS(), ISeqs())
    'check for possible rcorr problems
    
    'If X = X Then
        For x = 0 To 3
        
            TotD = DMatS(x, 0, ISeqs(1)) + DMatS(x, 0, ISeqs(2)) + DMatS(x, 2, ISeqs(1))
            If TotD > 0 Then
                TotD = 2 / TotD
                If (1 - DMatS(x, 0, ISeqs(1)) * TotD) < 0.4 And (1 - DMatS(x, 0, ISeqs(2)) * TotD) < 0.4 And (1 - DMatS(x, 2, ISeqs(1)) * TotD) < 0.4 Then
                    If x < 2 Then
                        RCorrWarn(0) = 1
                    Else
                        RCorrWarn(1) = 1
                    End If
                End If
            Else
                TotD = 0
                If x < 2 Then
                    RCorrWarn(0) = 1
                Else
                    RCorrWarn(1) = 1
                End If
                'make a warning
            End If
        Next x
        If RCorrWarn(0) = 1 And RCorrWarn(1) = 1 Then
            RCorrWarn(2) = 0
        ElseIf RCorrWarn(0) = 1 Or RCorrWarn(1) = 1 Then
            RCorrWarn(2) = 1
        End If
    'End If
    
   
    
    'Find out how many steps needed if each of Iseqs were recombinant and
    'put into rcompat.
    'Do this by
    '(1) collecting all R values greater that 0.83 (r2 = 0.7)
    '(on either side of bp)
    '(2) finding most distant common ancestor of the group.
    '(3) Find offspring of the MRCA
    '(4) subtract potential recombinants from the offspring group
    '(5) go through the recombinant group and count the number of distance
    'categories between each recombinant and non-recombinants: rcompat = the
    'highest number of categories.
    
    'begin section 6 ***************************************************************
    'begin section 6.1 ***************************************************************
    
   
    'ss = Abs(GetTickCount)
    'For i = 0 To 5000
    ReDim GoodC(NextNo, 1), InPenX(2), InPen(2), NRList(2, NextNo), NRNum(2), NRList2(2, NextNo)
    ReDim NRNum2(2), oRNum(2), RLScore(2, NextNo), RListX(2, NextNo, 9), RNumX(2, 9)
    ReDim InvListX(2, NextNo), RList(2, NextNo), RNum(2), InvList(2, NextNo), TVal(2, NextNo, 2)
    ReDim TPVal(2, NextNo, 2), PScores(2, NextNo, 2), TotP(2, NextNo, 1)
    
    'Find valid comparisons - anything with 10 or more overlapping nts is valid
    Dummy = MakeGoodC(NextNo, Len(StrainSeq(0)), GoodC(0, 0), BPosLR(0), SeqNum(0, 0))
    
    
    

   
   ' XX = GoodC(11, 0): XX = GoodC(11, 1)

    '10.615 5K perms
    '0.187 5K perms
    
   
    'TotPTarget = 1
    'I must port this to C++ when I'm done debugging
    

    'Take another look at ssdist
    
    Dim OUIndexA(2) As Byte
    If SSDist(INList(0)) > SSDist(INList(1)) And SSDist(INList(0)) > SSDist(INList(2)) Then
        OUIndexA(INList(0)) = 1: OUIndexA(INList(1)) = 0: OUIndexA(INList(2)) = 0
    ElseIf SSDist(INList(0)) < SSDist(INList(1)) And SSDist(INList(0)) < SSDist(INList(2)) Then
        OUIndexA(INList(0)) = 0: OUIndexA(INList(1)) = 1: OUIndexA(INList(2)) = 1
    Else
        OUIndexA(INList(0)) = 0: OUIndexA(INList(1)) = 0: OUIndexA(INList(2)) = 0
    End If
    
    
    Dim AcceptableCoR() As Byte
   
    ReDim AcceptableCoR(2, NextNo)
    For x = 0 To NextNo
       
        If FAMatSmall(INList(0), x) < FAMatSmall(INList(2), ISeqs(INList(0))) Or SAMatSmall(INList(1), x) < SAMatSmall(INList(1), ISeqs(INList(0))) Then
            AcceptableCoR(INList(0), x) = 1 '0,1,2,3,4,9,10,11,12,13,14,16,18,19
            AcceptableCoR(INList(1), x) = 1
        End If
        
        If FAMatSmall(INList(2), x) < FAMatSmall(INList(2), ISeqs(INList(0))) Or SAMatSmall(INList(2), x) < SAMatSmall(INList(2), ISeqs(INList(0))) Then
            AcceptableCoR(INList(2), x) = 1 '0,1,2,3,12,13,15,18,19
        End If
    Next x
    
    'This doesnt do anything exept redimention the dontredo array
    ReDim DontRedo(2, NextNo)
    'Call MakeDontRedo(Nextno, ISeqs(), RList(), RNum(), FAMatSmall(), SAMatSmall(), INList(), RCorr(), DontRedo())

'     XX = RNum(0)
'        XX = RNum(1)
'        XX = RNum(2)
    
    
    For x = 0 To 2
    '5,1,5
        'RNumX(X) = RNum(X)
        For Y = 0 To RNum(x)
        
            For Z = 0 To 9
                RListX(x, Y, Z) = RList(x, Y)
            Next Z
        Next Y
    Next x
    

    Dummy = MakeRList(NextNo, GoodC(0, 0), ISeqs(0), RListX(0, 0, 0), InvListX(0, 0), RNumX(0, 0), RList(0, 0), InvList(0, 0), RNum(0), RInv(0, 0, 0), RCorr(0, 0, 0), PScores(0, 0, 0), TPVal(0, 0, 0), TVal(0, 0, 0), TotP(0, 0, 0), RLScore(0, 0), DontRedo(0, 0), AcceptableCoR(0, 0), RCorrWarn(0))
    
    
    oRNumX(0) = RNum(0)
    oRNumX(1) = RNum(1)
    oRNumX(2) = RNum(2)
  ' XX = TPVal(2, 12, 0)
    ReDim OKSeq(2, 18, NextNo)
    
   
    'if there are contradictions go with the no inversion option.
   
    For Y = 0 To 2
        For x = 0 To RNum(Y)
        
            If InvList(Y, x) = 1 Then
                For Z = 0 To 2
                    If RCorr(Y, Z, RList(Y, x)) > 0.83 And RInv(Y, Z, RList(Y, x)) = 0 Then
                        InvList(Y, x) = 0 '4,0,3:1,0,3:
                        For A = 0 To 2
                            If RInv(Y, A, RList(Y, x)) > 0 Then
                                RCorr(Y, A, RList(Y, x)) = 0 And RInv(Y, A, RList(Y, x)) = 0
                            End If
                        Next A
                    End If
                Next Z
            End If
        Next x
    Next Y

    
    For x = 0 To 2
        For Y = 0 To RNum(x)
            OKSeq(x, 4, RList(x, Y)) = 1
        Next Y
    Next x
    
    Call AddOK1(PermNextno, DontRedo(), RCorr(), RList(), RNum(), OKSeq(), TPVal(), RInv())
    
    
    
    If MinPair(0) <> MinPair(1) Then
        
        
        
        'Make ListCorr
        'this is where I compare rcorrs and rinvs for evidence that each of the iseqs is recombinant
        '(1) find NO, PI and NI
        '(2) find expected lists for NO, PI and NI: NO=0, PI=1, NI=2
        '(3) for each rcor (left, right and middle or 0,1,2) work out which list fits the observed
        'correlations best
        
        

        Call MakeOUCheck(NextNo, ISeqs(), MinPair(), INList(), FAMatSmall(), SAMatSmall(), OuCheck())
        'Call MakeOUCheck(NextNo, ISeqs(), MinPair(), INList(), FCMat(), SCMat(), OuCheckB(), OuCheck2B(), OuCheck3B())
        
         '(2) find expected lists for NO, PI and NI: NO=0, PI=1, NI=2
         Dim EList() As Integer
         ReDim EList(2, 2, NextNo)
         Call MakeEList(NextNo, EList(), ISeqs(), INList(), SAMatSmall(), FAMatSmall())

         
         '(3) for each rcor (left, right and middle or 0,1,2) work out which list fits the observed
         'correlations best
         'first build AcList
         ReDim AcList(2, 2, NextNo)
         'note that the 2nd dimention here refers to the beginning, end and middle
         'recombinant region
        
         ReDim ListCorr3(2), ListCorr2(2), ListCorr(2), tListCorr(2, 2)
          
         Call MakeListCorr(ISeqs(), INList(), EList(), tRCorr(), RNum(), RList(), RInv(), AcList(), ListCorr3(), ListCorr2(), ListCorr(), tListCorr(), RCorrWarn())
         'Call MakeListCorr(ISeqs(), INList(), EList(), tRCorr(), RNum(), RList(), RInv(), AcList(), ListCorr3(), ListCorr2(), ListCorr(), tListCorr())
         Erase EList
    Else
        ReDim ListCorr3(2), ListCorr2(2), ListCorr(2), tListCorr(2, 2)
        ReDim OuCheck(2)

    
    End If
    
    
    For x = 0 To 2
        For Y = 0 To RNum(x)
            If InvList(x, Y) = 1 Then
                InvS(x, RList(x, Y)) = 1
                
            End If
        Next Y
    Next x
    
    
    
    
    'end of section 6.1******************************************************
    '11.486 5K perms
    '4.734 5K perms
    '4.281 - just taking out soem of the crap in ttest
    '1.797 - ttest using ttestprob
    '0.407 - using makerlist
    'check to see if events suggested in RList are there or not
    '2.047!!!!!
    '1.985
    
    '1.873 - 5kperms with 350 events
    
    'Set up array for region overlap
    
    
      
    ReDim Relevant(NextNo)
    Dummy = MakeRelevant(NextNo, Relevant(0), RNum(0), RList(0, 0))
     
    Dim BMatch() As Single, BPMatch() As Long
    ReDim BMatch(2, NextNo), BPMatch(2, 1, NextNo)
    'BMatch(0) = 0: BMatch(1) = 0: BMatch(2) = 0
    
    '1.412
    ReDim SQ(3), UNF(2, NextNo)
    
    If IndividualA = -1 And x = 123456 Then 'only do this if a proper balanced search for recombination
        
       ReDim OLSeq(Len(StrainSeq(0))), OLSeqB(Len(StrainSeq(0))), OLSeqE(Len(StrainSeq(0)))
        Dummy = MakeOLSeq(Len(StrainSeq(0)), SP(0), EP(1), RSize(2), OLSeqB(0))
        Dummy = MakeOLSeq(Len(StrainSeq(0)), SP(2), EP(3), RSize(4), OLSeqE(0))
        Dummy = MakeOLSeq(Len(StrainSeq(0)), BPos, Epos, RSize(0), OLSeq(0))
        
'        XX = RNum(0)
'        XX = RNum(1)
'        XX = RNum(2)
'
        
        Call FindActualEventsVB(RLScore(), UNF(), InvList(), NextNo, RSize(), BPMatch(), BMatch(), OKSeq(), FoundOne(), SP(), EP(), RCorr(), OLSeq(), OLSeqB(), OLSeqE(), CSeq(), RNum(), RList(), InvS(), tMatch(), PXOList(), PCurrentXover(), SQ(), tDon(), ISeqs(), CompMat())
    
        
'        XX = RNum(0)
'        XX = RNum(1)
'        XX = RNum(2)
   
    ElseIf BusyWithExcludes = 0 Then
        For x = 0 To 2
            For Y = 0 To RNum(x)
                UNF(x, Y) = 1
            Next Y
        Next x
    End If
     
    ReDim RList2(2, NextNo), RNum2(2)
    
    Call FindSets(TraceSub(), OKSeq(), SetTot(), NextNo, BPos, Epos, ISeqs(), RList2(), RNum2(), PXOList(), PCurrentXover())

    Dummy = StripDupInv(NextNo, RCorr(0, 0, 0), RLScore(0, 0), InPen(0), RNum(0), RList(0, 0), InvList(0, 0))

    For x = 0 To 2
        For Y = 0 To RNum(x)
            OKSeq(x, 4, RList(x, Y)) = 1
        Next Y
    Next x
    
    '******************need to add in a similarity check for high corrolaters*******************
    '******************only accept if corrolaters more similer over BP than  *******************
    '******************the rest of the sequences in other groups are to one  *******************
    '******************another                                               *******************
    
 
    Dim RCompatNF(2, 9), RCompatNS(2, 9)
     
    For x = 0 To 2
        For Y = 0 To 9
            RCompatNF(x, Y) = 0: RCompatNS(x, Y) = 0
        Next Y
    Next x
    
    Dim RCompatXF(2) As Long, RCompatXS(2) As Long, RCompatBXF(2) As Long, RCompatBXS(2) As Long, RCompat2(2) As Long, RCompatB2(2) As Long, RCompat3(2) As Long, RCompatB3(2) As Long, RCompat4(2) As Long, RCompatB4(2) As Long
    Dim RCompatS(2) As Long, RCompatBS(2) As Long, RCompatS2(2) As Long, RCompatBS2(2) As Long, RCompatS3(2) As Long, RCompatBS3(2) As Long, RCompatS4(2) As Long, RCompatBS4(2) As Long
        
   For WinPP = 0 To 2
        
        RCompat(WinPP) = 0: RCompatB(WinPP) = 0: RCompat2(WinPP) = 0: RCompatB2(WinPP) = 0
        RCompat3(WinPP) = 0: RCompatB3(WinPP) = 0: RCompat4(WinPP) = 0: RCompatB4(WinPP) = 0
        
        RCompatS(WinPP) = 0: RCompatBS(WinPP) = 0: RCompatS2(WinPP) = 0: RCompatBS2(WinPP) = 0
        RCompatS3(WinPP) = 0: RCompatBS3(WinPP) = 0: RCompatS4(WinPP) = 0: RCompatBS4(WinPP) = 0
    Next WinPP
    
    If x = 1234567 Then
        If PermNextno > MemPoc Then
            Call GetFAMat
        End If
        Dummy = MakeLDist(NextNo, LDist(0), FAMat(0, 0), RNum(0), RList(0, 0))
         
        For WinPP = 0 To 2
            ReDim DoneX(NextNo), RCats(NextNo * 3)
            'makercmpat Requires SAMat and FAMat - wont work with SAMatSmall or FAMatsmall
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList(0, 0), FAMat(0, 0), LDist(0))
            
        Next WinPP
         If PermNextno > MemPoc Then
            ReDim FAMat(0, 0)
            Call GetSAMat
        End If
        Dummy = MakeLDist(NextNo, LDist3(0), SAMat(0, 0), RNum(0), RList(0, 0))
        For WinPP = 0 To 2
            ReDim DoneX(NextNo), RCats(NextNo * 3)
            'Using SMat
            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS(0), RCompatBS(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SAMat(0, 0), LDist3(0))
        Next WinPP
        If PermNextno > MemPoc Then
            ReDim SAMat(0, 0)
        End If
    End If
    
'    For X = 0 To 2
'        'For Y = 0 To Nextno
'        For Z = 0 To RNum(X)
'            If LDist(X) = FAMat(ISeqs(X), RList(X, Z)) Then
'                X = X
'            End If
'        Next Z
'        'Next Y
'    Next X
'    XX = LDist(0) '0
'    XX = LDist(1) '0
'    XX = LDist(2) '1.99999
'    XX = RCompat(0) '1,0
'    XX = RCompat(1) '1,0
'    XX = RCompat(2) '0,0
'    XX = InPen(0) '1'0
'    XX = InPen(1) '1'0
'    XX = InPen(2) '0'0
'    XX = RNum(0) '0'18
'    XX = RNum(1) '0'0
'    XX = RNum(2) '18'0
'    XX = NRNum(0) '-1'-1
'    XX = NRNum(1) '-1'-1
'    XX = NRNum(2) '-1'-1
'    XX = ISeqs(0) '0'10
'    XX = ISeqs(1) '6'0
'    XX = ISeqs(2) '10'6
    
    If RCompat(0) <> RCompat(1) Or RCompat(0) <> RCompat(2) Then
        
    Else 'only bother moving on with looking for sequence set with fewest SPR moves if there is a tie using famat
        If NextNo > 2 Then
            If PermNextno > MemPoc Then
                
                GetFCMat
            End If
    
            If DebuggingFlag < 2 Then On Error Resume Next
                UB = 0
                UB = UBound(FCMat, 1)
            On Error GoTo 0
            If UB > 0 Then
                Dummy = MakeLDist(NextNo, LDist2(0), FCMat(0, 0), RNum(0), RList(0, 0))
                
                For WinPP = 0 To 2
                    ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                    Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat2(0), RCompatB2(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), FCMat(0, 0), LDist2(0))
                Next WinPP
            End If
            If PermNextno > MemPoc Then
                ReDim FCMat(0, 0)
            End If
    
        End If
        
        If RCompat2(0) <> RCompat2(1) Or RCompat2(0) <> RCompat2(2) Then
        Else
            If PermNextno > MemPoc Then
                Call GetFAMat
            End If
            Dummy = MakeLDist(NextNo, LDistB(0), FAMat(0, 0), RNum2(0), RList2(0, 0))
            
            For WinPP = 0 To 2
                'setsRcompat with non-BS tree
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat3(0), RCompatB3(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), FAMat(0, 0), LDistB(0))
            Next WinPP
            If PermNextno > MemPoc Then
                ReDim FAMat(0, 0)
            End If
            If RCompat3(0) <> RCompat3(1) Or RCompat3(0) <> RCompat3(2) Then
            Else
                If NextNo > 2 Then
                    If PermNextno > MemPoc Then
                        GetFCMat
                       
                    End If
    
                    If DebuggingFlag < 2 Then On Error Resume Next
                        UB = 0
                        UB = UBound(FCMat, 1)
                    On Error GoTo 0
                    If UB > 0 Then
                        Dummy = MakeLDist(NextNo, LDistB2(0), FCMat(0, 0), RNum2(0), RList2(0, 0))
                        For WinPP = 0 To 2
                            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat4(0), RCompatB4(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), FCMat(0, 0), LDistB2(0))
                        Next WinPP
                    End If
                    If PermNextno > MemPoc Then
                        ReDim FCMat(0, 0)
                    End If
    
                End If
            End If
        End If
    End If
    
    If RCompatS(0) <> RCompatS(1) Or RCompatS(0) <> RCompatS(2) Then
    
    Else 'only bother moving on with looking for sequence set with fewest SPR moves if there is a tie using samat
        
    
        If NextNo > 2 Then
            If PermNextno > MemPoc Then
                GetSCMat
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
                UB = 0
                UB = UBound(SCMat, 1)
            On Error GoTo 0
            If UB > 0 Then
                Dummy = MakeLDist(NextNo, LDist4(0), SCMat(0, 0), RNum(0), RList(0, 0))
                For WinPP = 0 To 2
                    'normal rcompats with BS tree
                    ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                    Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS2(0), RCompatBS2(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SCMat(0, 0), LDist4(0))
                Next WinPP
            End If
            If PermNextno > MemPoc Then
                ReDim SCMat(0, 0)
            End If
        End If
        If RCompatS2(0) <> RCompatS2(1) Or RCompatS2(0) <> RCompatS2(2) Then
        Else
            If PermNextno > MemPoc Then
                Call GetSAMat
            End If
            Dummy = MakeLDist(NextNo, LDistB3(0), SAMat(0, 0), RNum2(0), RList2(0, 0))
            For WinPP = 0 To 2
                'setsrcompats with non-BS tree
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS3(0), RCompatBS3(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), SAMat(0, 0), LDistB3(0))
            Next WinPP
             If PermNextno > MemPoc Then
                ReDim SAMat(0, 0)
            End If
            If RCompatS3(0) <> RCompatS3(1) Or RCompatS3(0) <> RCompatS3(2) Then
            Else
                If NextNo > 2 Then
                    If PermNextno > MemPoc Then
                        GetSCMat
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
                        UB = 0
                        UB = UBound(SCMat, 1)
                    On Error GoTo 0
                    If UB > 0 Then
                        Dummy = MakeLDist(NextNo, LDistB4(0), SCMat(0, 0), RNum2(0), RList2(0, 0))
                        'setsrcompats with BS tree
                        For WinPP = 0 To 2
                            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS4(0), RCompatBS4(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), SCMat(0, 0), LDistB4(0))
                        Next WinPP
                    End If
                    If PermNextno > MemPoc Then
                        ReDim SCMat(0, 0)
                    End If
                End If
            End If
        End If
    End If
  
    
    'Clean up rlistx
    Dim FEntry() As Byte
    
    For x = 0 To 2
        ReDim FEntry(NextNo)
        For Y = 0 To RNum(x)
            FEntry(RList(x, Y)) = 1
        Next Y
        For Y = 1 To 9 'ie leave 0 alone
            Z = 0
            Do While Z <= RNumX(x, Y)
                If FEntry(RListX(x, Z, Y)) = 0 Then
                    If Z < RNumX(x, Y) Then
                        RListX(x, Z, Y) = RListX(x, RNumX(x, Y), Y)
                    End If
                    RNumX(x, Y) = RNumX(x, Y) - 1
                Else
                    Z = Z + 1
                End If
            Loop
            
        Next Y
    Next x
    If x = 123456 Then
        Dim txLDist(2) As Double, txRNum(2) As Long, txRList() As Long
        If PermNextno > MemPoc Then
            Call GetFAMat
            Call GetSAMat
        End If
        For x = 0 To 9
            For WinPP = 0 To 2
                RCompatXF(WinPP) = 0: RCompatXS(WinPP) = 0: RCompatBXF(WinPP) = 0: RCompatBXS(WinPP) = 0
            Next WinPP
            
            txLDist(0) = 0: txLDist(1) = 0: txLDist(2) = 0
            ReDim txRList(2, NextNo)
            
            For Y = 0 To 2
                txRNum(Y) = RNumX(Y, x)
                For Z = 0 To RNumX(Y, x)
                    txRList(Y, Z) = RListX(Y, Z, x)
                Next Z
            Next Y
            
            Dummy = MakeLDist(NextNo, txLDist(0), FAMat(0, 0), txRNum(0), txRList(0, 0))
            For WinPP = 0 To 2
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo), InPenX(2)
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatXF(0), RCompatBXF(0), InPenX(0), RCats(0), txRNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), txRList(0, 0), NRList2(0, 0), FAMat(0, 0), txLDist(0))
                
            Next WinPP
            RCompatNF(0, x) = RCompatXF(0): RCompatNF(1, x) = RCompatXF(1): RCompatNF(2, x) = RCompatXF(2)
            
            txLDist(0) = 0: txLDist(1) = 0: txLDist(2) = 0
            ReDim txRList(2, NextNo)
            
            For Y = 0 To 2
                txRNum(Y) = RNumX(Y, x)
                For Z = 0 To RNumX(Y, x)
                    txRList(Y, Z) = RListX(Y, Z, x)
                Next Z
            Next Y
            
            Dummy = MakeLDist(NextNo, txLDist(0), SAMat(0, 0), txRNum(0), txRList(0, 0))
            For WinPP = 0 To 2
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo), InPenX(2)
                ''
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatXS(0), RCompatBXS(0), InPenX(0), RCats(0), txRNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), txRList(0, 0), NRList2(0, 0), SAMat(0, 0), txLDist(0))
                
            Next WinPP
             
            'XX = RNum(2)
            RCompatNS(0, x) = RCompatXS(0): RCompatNS(1, x) = RCompatXS(1): RCompatNS(2, x) = RCompatXS(2)
        Next x
        If PermNextno > MemPoc Then
            ReDim SAMat(0, 0)
            ReDim FAMat(0, 0)
        End If
        
        For Y = 0 To 2
            SRCompatF(Y) = 0: SRCompatS(Y) = 0
            For x = 0 To 9
                SRCompatF(Y) = SRCompatF(Y) + RCompatNF(Y, x)
                SRCompatS(Y) = SRCompatS(Y) + RCompatNS(Y, x)
            Next x
            SRCompatF(Y) = SRCompatF(Y) / 10 + InPen(Y)
            SRCompatS(Y) = SRCompatS(Y) / 10 + InPen(Y)
            
        Next Y
    
        For WinPP = 0 To 2
            RCompatXF(WinPP) = 0: RCompatXS(WinPP) = 0: RCompatBXF(WinPP) = 0: RCompatBXS(WinPP) = 0
        Next WinPP
    End If
    
     ReDim SimScore(2)
    'needs FMat and SMat
    If PermNextno > MemPoc Then
        GetFMat
        GetSMat
    End If
    Call SimpleDist(RankF(), NextNo, SimScore(), SimScoreB(), RList(), RNum(), INList(), ISeqs(), FMat(), SMat())
    If PermNextno > MemPoc Then
        ReDim FMat(0, 0)
        ReDim SMat(0, 0)
    End If
   
    'work out baddists
    Call GetBadDists(NextNo, RCorr(), FAMatSmall(), CompMat(), DMatS(), ISeqs(), BadDists(), UNF(), RList(), RNum())
   
    
    'draw trees with regions centred on the breakpoints - this is skipped
    
    
    PhylCheck = 0 'phylogenetic evidence will still be used, just not in the proximity of the breakpoints
    If DebuggingFlag < 2 Then On Error Resume Next
    ReDim BPMat(0, 0, 0)
    
    ReDim Consensus(2, 3), tDscores(25, 2)
        
    
    RetrimFlag = 0
    
    If x = 12345 Then
        If RCompat(0) > 0 And RCompat(1) > 0 And RCompat(2) > 0 And RCompatS(0) > 0 And RCompatS(1) > 0 And RCompatS(2) > 0 Then
            RetrimFlag = 1
        End If
        
        For x = 0 To 2
            RCompatC(x) = 0: RCompatD(x) = 0
        Next x
     End If
  
    Call CheckPattern(OKSeq(), ISeqs(), RList(), SP(), EP(), CompMat(), RNum(), SeqNum(), RInv(), InvList(), RCorrWarn())
     
           
    MissIDFlag = 0
    RFF = 0
    If RetrimFlag = 1 And x = 12345 Then
        RWinPP = 4
        RFF = 1
        DontDoScansFlag = 0
        Call FinalTrim(WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), LowP, 0, WeightMod(), OKSeq(), BMatch(), BPMatch(), MinPair(), INList(), RInv(), BPos, Epos, RWinPP, MissIDFlag, PhylCheck, BackUpNextno, NextNo, CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), XoverList(), CurrentXOver(), PCurrentXover(), PXOList(), MissingData(), TraceSub(), Trace(), DMatS(), CompMat(), BPMat(), RCorrWarn(), UNF(), RCorr(), ISeqs(), FCMatSmall(), SCMatSmall(), FAMatSmall(), SAMatSmall(), NRNum(), NRList(), RNum(), RList())
        'AbortFlag = 1
        If PermNextno > MemPoc Then
            Call GetFAMat
        End If
        For x = 0 To 2
            RCompatB(x) = 0
            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
            'Requires FAMat (wont work with FAmatSmall)
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), x, NextNo, RCompatC(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), FAMat(0, 0), LDist(0))
        'do RCompatC
        Next x
        
        If PermNextno > MemPoc Then
            ReDim FAMat(0, 0)
            Call GetSAMat
        End If
        
        For x = 0 To 2
            RCompatB(x) = 0
            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'Requires SAMat (wont work with SAmatSmall)
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), x, NextNo, RCompatD(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SAMat(0, 0), LDist3(0))
        'do RCompatC
        Next x
         If PermNextno > MemPoc Then
            ReDim SAMat(0, 0)
        End If
    End If
     
    'finally, do visrd dmax
    Call CalcMaxD(ISeqs(), dMax(), BPos, Epos)
    
    
    
    'DScores(X, 0, SENum)
    'fudge scores 1,2, and 14
    For x = 0 To 2
        If DScores(2, x, SENum) = 10 Then
            BadDists(x) = 0
        ElseIf DScores(2, x, SENum) = 5 Then
            BadDists(x) = 1
        Else
            BadDists(x) = 2
        End If
        If DScores(1, x, SENum) = 20 Then
            RCompat(x) = 0
            RCompat2(x) = 0
            RCompat3(x) = 0
            RCompat4(x) = 0
            RCompatXF(x) = 0
        ElseIf DScores(1, x, SENum) = 10 Then
            RCompat(x) = 1
            RCompatXF(x) = 0
            RCompat2(x) = 1
            RCompat3(x) = 1
            RCompat4(x) = 1
        ElseIf DScores(1, x, SENum) = 5 Then
            RCompat(x) = 2
            RCompat2(x) = 2
            RCompat3(x) = 2
            RCompat4(x) = 2
            RCompatXF(x) = 1
        Else
            RCompat(x) = 3
            RCompat2(x) = 3
            RCompat3(x) = 3
            RCompat4(x) = 3
            RCompatXF(x) = 2
        End If

        If DScores(14, x, SENum) = 20 Then
            RCompatS(x) = 0
            RCompatS2(x) = 0
            RCompatS3(x) = 0
            RCompatS4(x) = 0
            RCompatXS(x) = 0
        ElseIf DScores(14, x, SENum) = 10 Then
            RCompatS(x) = 1
            RCompatXS(x) = 0
            RCompatS2(x) = 1
            RCompatS3(x) = 1
            RCompatS4(x) = 1
        ElseIf DScores(14, x, SENum) = 5 Then
            RCompatS(x) = 2
            RCompatS2(x) = 2
            RCompatS3(x) = 2
            RCompatS4(x) = 2
            RCompatXS(x) = 1
        Else
            RCompatS(x) = 3
            RCompatS2(x) = 3
            RCompatS3(x) = 3
            RCompatS4(x) = 3
            RCompatXS(x) = 2
        End If

    Next x
    DontRedoQuickDistFlag = 1
    Call MakeConsensusC(SetTot(), OUList(), RankF(), dMax(), SimScore(), SimScoreB(), PhPrScore3(), RCompatC(), RCompatD(), RCompat2(), RCompat3(), RCompat4(), RCompatS(), RCompatS2(), RCompatS3(), RCompatS4(), SSDist(), OUIndexA(), tDscores(), Consensus(), INList(), CompMat(), SubScore2(), SubPhPrScore2(), ListCorr3(), SubScore(), PhPrScore2(), ListCorr(), ListCorr2(), TrpScore(), PhPrScore(), SubPhPrScore(), OuCheck(), BadDists(), RCompat(), tListCorr())
    DontRedoQuickDistFlag = 0

    
    'Now force winpp to be the current daughter
    WinPP = 0
    
       
    tWinPP = WinPP
    Dim tListX() As Byte
    ReDim NRList(2, NextNo)
    For WinPP = 0 To 2
    
        
        ReDim tListX(NextNo)
        
        For x = 0 To RNum(WinPP)
            tListX(RList(WinPP, x)) = 1
        Next x
        NRNum(WinPP) = 0
        For x = 0 To NextNo
            If tListX(x) = 0 Then
                NRList(WinPP, NRNum(WinPP)) = x
                NRNum(WinPP) = NRNum(WinPP) + 1
            End If
        Next x
        NRNum(WinPP) = NRNum(WinPP) - 1
    Next WinPP
    WinPP = tWinPP
   
    'edit RList to contain only those sequences that are not separated by
    'non-recombinants from the original hit - ie iseqs(winpp)
    'This is probably where the identity check should be included....
    
   
'************* Got to expand NRList to include all sequences not in RList**************
    
    If AAF <> 1 Then
        RWinPP = WinPP
        DontDoScansFlag = 1
        If NextNo <> UBound(SMat, 1) Then Call ModNextno
        Call FinalTrim(WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), LowP, RFF, WeightMod(), OKSeq(), BMatch(), BPMatch(), MinPair(), INList(), RInv(), BPos, Epos, RWinPP, MissIDFlag, PhylCheck, BackUpNextno, NextNo, CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), XoverList(), CurrentXOver(), PCurrentXover(), PXOList(), MissingData(), TraceSub(), Trace(), DMatS(), CompMat(), BPMat(), RCorrWarn(), UNF(), RCorr(), ISeqs(), FCMatSmall(), SCMatSmall(), FAMatSmall(), SAMatSmall(), NRNum(), NRList(), RNum(), RList())
        DontDoScansFlag = 0
        WinPP = RWinPP
    End If
'
'     XX = FAMat(Seq1, Seq2)
'    XX = FAMat(Seq1, Seq3)
'    XX = FAMat(Seq2, Seq3)
'    XX = SAMat(Seq1, Seq2)
'    XX = SAMat(Seq1, Seq3)
'    XX = SAMat(Seq2, Seq3)
    
    
    Erase DMatS
    ReDim SCMat(0, 0)
    ReDim FCMat(0, 0)
    ReDim FAMat(0, 0)
    ReDim SAMat(0, 0)
    'XX = Nextno
    
    Dim PF As Long
    'Erase all p-values for this event and rescan everything with everything
    
    'XX = UBound(ConfirmP, 2)
    For x = 0 To AddNum - 1
        ConfirmP(SENum, x) = 0
    Next x
    'I need to keep a backup of xdiffpos and gdcpflag because they'll get changed in the code below
    
    Dim XPD() As Long, XPD2() As Long, UBXD1 As Long, UBXD2 As Long, oGDCPFlag As Byte
    oGDCPFlag = GDPCFlag
    If DebuggingFlag < 2 Then On Error Resume Next
    Dim AD As Long
    
    AD = ArrayDims(XDiffPos())
        
        'UBXD1 = -1
        UBXD1 = UBound(XDiffPos, 1)
        
        
    On Error GoTo 0
    If AD = 1 Then
        ReDim XDP(UBXD1)
        For x = 0 To UBXD1
            XDP(x) = XDiffPos(x)
        Next x
    ElseIf AD = 2 Then
        UBXD2 = UBound(XDiffPos, 2)
        ReDim XDP2(UBXD1, UBXD2)
        For x = 0 To UBXD1
            For Y = 0 To UBXD2
                XDP2(x, Y) = XDiffPos(x, Y)
            Next Y
        Next x
    End If
     
    
    
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(BestXOListMi, 2)
    
    If UB = -1 Then
    
       If XOMiMaInFileFlag = 1 Then
               'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
           
           oDirX = CurDir
           ChDrive App.Path
           ChDir App.Path
           FF = FreeFile
           ReDim BestXOListMi(PermNextno, UBXOMi)
           ReDim BestXOListMa(PermNextno, UBXoMa)
           If MiRec < 1 Then
               Open "RDP5BestXOListMi" + UFTag For Binary As #FF
               Get #FF, , BestXOListMi()
               Close #FF
               MiRec = 1
           End If
           If MaRec < 1 Then
               Open "RDP5BestXOListMa" + UFTag For Binary As #FF
               Get #FF, , BestXOListMa()
               Close #FF
               MaRec = 1
           End If
           ChDrive oDirX
           ChDir oDirX
           
       End If
    End If

'minpair (0) encodes the pair which is most similar in the "background"
'minpair(1) encodes the pair which is most similar in the recombinant region
'in minpair(0): 0 = sequence 1 and 2, 1 = sequence 0 and sequence 2, 2= sequence 1 and sequence 2

    
'    If INList(0) <> INList(1) And INList(0) <> INList(2) And INList(1) <> INList(2) Then
'        If INList(0) = WinPP Then 'NO recombinant
'            NOPINI(0, SENum) = 0: NOPINI(1, SENum) = 1: NOPINI(2, SENum) = 2
'        ElseIf INList(1) = WinPP Then 'PI recombinant
'            NOPINI(0, SENum) = 1: NOPINI(1, SENum) = 0: NOPINI(2, SENum) = 2
'        ElseIf INList(2) = WinPP Then 'NI recombinant
'            NOPINI(0, SENum) = 2: NOPINI(1, SENum) = 1: NOPINI(2, SENum) = 0
'        End If
'   End If
    
   
    Dim AV As Long
    'arranged daughter, major, minor in 0,1 and 2
    If MinPair(0) = 0 And MinPair(1) = 1 Then
        AV = 0
    ElseIf MinPair(0) = 0 And MinPair(1) = 2 Then
        AV = 2 'minor parent unknown
    ElseIf MinPair(0) = 1 And MinPair(1) = 2 Then
        AV = 2
    ElseIf MinPair(0) = 1 And MinPair(1) = 0 Then
        AV = 1 'major parent unknown
    ElseIf MinPair(0) = 2 And MinPair(1) = 0 Then
        AV = 1
    ElseIf MinPair(0) = 2 And MinPair(1) = 1 Then
        AV = 1
    ElseIf MinPair(0) = 0 And MinPair(1) = 0 Then
        AV = 2
    ElseIf MinPair(0) = 1 And MinPair(1) = 1 Then
        AV = 1
    ElseIf MinPair(0) = 2 And MinPair(1) = 2 Then
        AV = 1
    End If
    
    
    Dim tIsPerm(2) 'isperm is used in the checking routines to indcate which seq1, seq2 and seq3 to use during rescans
    tIsPerm(0) = ISPerm(0)
    tIsPerm(1) = ISPerm(1)
    tIsPerm(2) = ISPerm(2)
    
    For x = 0 To PermNextno
        For Y = 1 To CurrentXOver(x)
            If SuperEventList(XoverList(x, Y).Eventnumber) = SENum Then
                
                XoverList(x, Y).Probability = 1
                Call RecheckSpecificsignal(x, Y)
                XoverList(x, Y).OutsideFlag = AV
                If x <> BestEvent(SENum, 0) Or Y <> BestEvent(SENum, 1) Then
                    If XoverList(x, Y).Probability = 0 Then XoverList(x, Y).Probability = 1
                    
                    If XoverList(x, Y).Probability = 1 Then
                        XoverList(x, Y).Probability = -1
                    End If
                Else
                x = x
                    If XoverList(x, Y).Probability = 1 Then XoverList(x, Y).Probability = 0.99
                
                End If
                
            End If
        Next Y
    Next x
    
    
    
    ISPerm(0) = tIsPerm(0)
    ISPerm(1) = tIsPerm(1)
    ISPerm(2) = tIsPerm(2)
    
'    XX = RelX
'    XX = RelY
'    XX = XOverlist(RelX, RelY).Probability
    'erase signals that have p-vaues = -1?
    
    
    
    
    Call CleanXOList(SENum, XoverList(), CurrentXOver(), Daught())
    Call CleanXOList(SENum, BestXOListMi(), BCurrentXoverMi(), MinorPar())
    Call CleanXOList(SENum, BestXOListMa(), BCurrentXoverMa(), MajorPar())

    
    'setting these to zero will cause makebestevent to redetermine them for this event
    BestEvent(SENum, 0) = 0
    BestEvent(SENum, 1) = 0
    Call MakeBestEvent
    
    RelX = BestEvent(SENum, 0)
    RelY = BestEvent(SENum, 1)
    
     
    If AD = 1 Then
        ReDim XDiffPos(UBXD1)
        For x = 0 To UBXD1
            XDiffPos(x) = XDP(x)
        Next x
    ElseIf AD = 2 Then
       ReDim XDiffPos(UBXD1, UBXD2)
        For x = 0 To UBXD1
            For Y = 0 To UBXD2
                XDiffPos(x, Y) = XDP2(x, Y)
            Next Y
        Next x
    End If
    
    GDPCFlag = oGDCPFlag
    
    
    'recalculate confirmp
    
    ReDim Confirm(SEventNumber + 1, AddNum - 1), ConfirmP(SEventNumber + 1, AddNum - 1)

    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
        
            PF = XoverList(TreeTrace(x), Y).ProgramFlag
            If PF >= AddNum Then PF = PF - AddNum
            
                
                Confirm(SuperEventList(XoverList(TreeTrace(x), Y).Eventnumber), PF) = Confirm(SuperEventList(XoverList(TreeTrace(x), Y).Eventnumber), PF) + 1
                ConfirmP(SuperEventList(XoverList(TreeTrace(x), Y).Eventnumber), PF) = ConfirmP(SuperEventList(XoverList(TreeTrace(x), Y).Eventnumber), PF) + -Log10(XoverList(TreeTrace(x), Y).Probability)
        Next Y
    Next x
    
'    Call RescanBest(SENum)
    
    For x = 0 To 25 'with findactual events (wrong):1,3,4, 5 VERY wrong),6,7(VERY Wrong)
'        XX = DScores(0, 0, SENum): YY = TDScores(0, 0) '30      30       30     30     30
'        XX = DScores(0, 1, SENum): YY = TDScores(0, 1) '5.367   2.7925   9.484  3.38   3.101
'        XX = DScores(0, 2, SENum): YY = TDScores(0, 2) '11.501  9.4148   0      7.394  5.769
'
'        XX = DScores(1, 0, SENum): YY = TDScores(1, 0)
'        XX = DScores(1, 1, SENum): YY = TDScores(1, 1)
'        XX = DScores(1, 2, SENum): YY = TDScores(1, 2)
'
'        XX = DScores(2, 0, SENum): YY = TDScores(2, 0)
'        XX = DScores(2, 1, SENum): YY = TDScores(2, 1)
'        XX = DScores(2, 2, SENum): YY = TDScores(2, 2)
'
'        XX = DScores(3, 0, SENum): YY = TDScores(3, 0)
'        XX = DScores(3, 1, SENum): YY = TDScores(3, 1)
'        XX = DScores(3, 2, SENum): YY = TDScores(3, 2)
'
'        XX = DScores(4, 0, SENum): YY = TDScores(4, 0)
'        XX = DScores(4, 1, SENum): YY = TDScores(4, 1)
'        XX = DScores(4, 2, SENum): YY = TDScores(4, 2)
'
'        XX = DScores(5, 0, SENum): YY = TDScores(5, 0)
'        XX = DScores(5, 1, SENum): YY = TDScores(5, 1)
'        XX = DScores(5, 2, SENum): YY = TDScores(5, 2)
'
'        XX = DScores(7, 0, SENum): YY = TDScores(7, 0)
'        XX = DScores(7, 1, SENum): YY = TDScores(7, 1)
'        XX = DScores(7, 2, SENum): YY = TDScores(7, 2)
'
'
'        XX = DScores(9, 0, SENum): YY = TDScores(9, 0)
'        XX = DScores(9, 1, SENum): YY = TDScores(9, 1)
'        XX = DScores(9, 2, SENum): YY = TDScores(9, 2)
'
'        XX = DScores(6, 0, SENum): YY = TDScores(6, 0)
'        XX = DScores(6, 1, SENum): YY = TDScores(6, 1)
'        XX = DScores(6, 2, SENum): YY = TDScores(6, 2)
        If x = x Then 'without findactual events (wrong):1,5 VERY wrong,6,
            If x <> 1 And x <> 2 And x <> 14 Then
                
                DScores(x, 0, SENum) = tDscores(x, 0)
                'If SwapFlag = 0 Then
                    DScores(x, 1, SENum) = tDscores(x, 1)
                    DScores(x, 2, SENum) = tDscores(x, 2)
                'Else
                
                'End If
            End If
        End If
      
        
    Next x
    x = x
    'event 28
    'correct:1-5
    'incorrect: 6,9
    
    'event 12
    'correct: 3-13,15-20
    'incorrect: 1,2,14
    
    'event 11
    'correct: all
    'incorrect: none
    
    'event 10
    'correct: 2-13
    'incorrect: 1,14
    
    'event 9
    'correct: 2-20
    'incorrect: 1
    
    'event 8
    'correct: 1-13, 15-20
    'incorrect: 14
    
    'event 7
    'correct: all
    'incorrect: none
    
    'event 6
    'correct: 1,3-20
    'incorrect: 2
    
    'event 5
    'correct: 2-13, 15-20
    'incorrect: 1,14
    
    'event 4
    'correct: all
    'incorrect: none
    
    'event 3
    'correct: all
    'incorrect: none
    'need to make extrhits array
    For x = 0 To PermNextno
        For Y = 1 To CurrentXOver(x)
            If SuperEventList(XoverList(x, Y).Eventnumber) = SENum Then
                ExtraHits(x, 1) = 1
                Exit For
            End If
        Next Y
        For Y = 1 To BCurrentXoverMi(x)
            If SuperEventList(BestXOListMi(x, Y).Eventnumber) = SENum Then
                ExtraHitsMi(x, 1) = 1
                Exit For
            End If
        Next Y
        For Y = 1 To BCurrentXoverMa(x)
            If SuperEventList(BestXOListMa(x, Y).Eventnumber) = SENum Then
                ExtraHitsMi(x, 1) = 1
                Exit For
            End If
        Next Y
    Next x
    
 
     YannWarn(SENum) = CheckYann(0, 1, ISeqs(), BPos, Epos, SeqNum(), ExtraHits(), ExtraHitsMi(), ExtraHitsMa(), TraceSub())
     
     
     
     
     




If XOMiMaInFileFlag = 1 Then
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If MiRec < 1 Then
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
    End If
    If MaRec < 1 Then
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
    End If
    ChDrive oDirX
    ChDir oDirX
        
    Erase BestXOListMa
    Erase BestXOListMi
    MaRec = MaRec - 1
    MiRec = MiRec - 1
End If


Seq1 = oSeq1
Seq2 = oSeq2
Seq3 = oSeq3
Eventnumber = exEventnumber
If UpdateProgressBar = 0 Then
    Form1.SSPanel1.Caption = ""
End If
End Sub
Public Function RedoBreakpoints(DontAskFlag As Byte)
Dim CIOut() As Long, BPos As Long, Epos As Long, Response As Byte, EN As Long, BEX As Long, BEY As Long
ReDim CIOut(100)

EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
BEX = BestEvent(EN, 0)
BEY = BestEvent(EN, 1)
BPos = XoverList(BEX, BEY).Beginning
Epos = XoverList(BEX, BEY).Ending
Seq1 = XoverList(BEX, BEY).MajorP
Seq2 = XoverList(BEX, BEY).MinorP
Seq3 = XoverList(BEX, BEY).Daughter
Dim oPointer As Long
oPointer = Screen.MousePointer
If Screen.MousePointer <> 11 Then
    Screen.MousePointer = 11
End If
Form1.SSPanel1.Caption = "Repositioning breakpoints"
'Form1.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Form2.SSPanel3.Caption = "Repositioning breakpoints"
'Form2.Refresh
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState







Call ModSeqNum(BPos, Epos, 0)

' For X = 0 To PermNextno
'
'    If Daught(EN, X) > 0 Then
'    X = X
'
'    End If
'
'    Next X

Call MakeTreeSeqs(BPos, Epos)
' For X = 0 To PermNextno
'
'    If Daught(EN, X) > 0 Then
'    X = X
'
'    End If
'
'    Next X
Call ModNextno


'XX = MissingData(BPos, Seq1)
'XX = MissingData(BPos, Seq2)
'For X = 0 To Len(StrainSeq(0))
'
'    If MissingData(X, Seq2) = 0 Then '3498-9587 = missingdata
'        X = X
'    End If
'Next X
'
'
'XX = MissingData(BPos, Seq3)



Call PolishBP(20, 1, BPos, Epos, Seq1, Seq2, Seq3, CIOut())

For ZZ = 0 To 9
    BPCIs(ZZ, EN) = CIOut(ZZ)
Next ZZ
GoOn = 0
If DontAskFlag = 0 Then
    If BPos <> XoverList(RelX, RelY).Beginning And Epos <> XoverList(RelX, RelY).Ending Then
        Response = MsgBox("BURT has indicated that both the beginning and ending breakpoints are not at their statistically optimal positions.  Would you like to automatically shift the breakpoint locations to their optimal positions?", vbYesNo)
    ElseIf BPos <> XoverList(RelX, RelY).Beginning Then
        Response = MsgBox("BURT has indicated that the beginning breakpoint is not at its statistically optimal position.  Would you like to automatically shift the breakpoint to its optimal position?", vbYesNo)
    ElseIf Epos <> XoverList(RelX, RelY).Ending Then
        Response = MsgBox("BURT has indicated that the ending breakpoint is not at its statistically optimal position.  Would you like to automatically shift the breakpoint to its optimal position?", vbYesNo)
    End If
    
    If Response = 6 Then
        GoOn = 1
    End If
Else
    GoOn = 0
End If


'XOverlist(RelX, RelY).Beginning = BPos
'XOverlist(RelX, RelY).Ending = EPos

If GoOn = 1 Then 'addjust the BP positions
    oRelX = RelX
    oRelY = RelY
    For RelX = 0 To NextNo
        For RelY = 1 To CurrentXOver(RelX)
            If SuperEventList(XoverList(RelX, RelY).Eventnumber) = EN Then
                XoverList(RelX, RelY).Beginning = BPos
                XoverList(RelX, RelY).Ending = Epos
                XoverList(RelX, RelY).SBPFlag = 0
                'check to see if the new BP pos is close to misssing data
                
                Call DoEnds(0)
            End If
        Next RelY
    Next RelX
    
    RelX = oRelX
    RelY = oRelY
    
    'clear tree test stats
    If DebuggingFlag < 2 Then On Error Resume Next
    asx = 0
    asx = UBound(TreeTestStats, 2)
    If asx < EV Then ReDim Preserve TreeTestStats(3, EV)
    For x = 0 To 3
        TreeTestStats(x, EV) = -1
    Next x
    On Error GoTo 0
    If XoverList(BEX, BEY).Accept = 1 Then
        AcceptChangeFlag = 2
        Form1.Command10.Enabled = True
    ElseIf AcceptChangeFlag = 0 Then
        AcceptChangeFlag = 1
    End If
    
    Call IntegrateXOvers(0)
    PermXVal = 0: PermYVal = 0
    UpdateIDFlag = 1
    'Call GoToThis2(1, RelX, RelY, PermXVal, PermYVal)
    Dim inRelX As Long, inRelY As Long
    inRelX = RelX: inRelY = RelY
    Call GoToThis2(1, RelX, RelY, PermXVal, PermYVal)
    If inRelX <> RelX Or inRelY <> RelY Then
        
        Call IntegrateXOvers(0)
        UpdateIDFlag = 0: PermXVal = 0: PermYVal = 0
        
        Call GoToThis2(1, RelX, RelY, PermXVal, PermYVal)
    End If
    If RIMode = 0 Then
        Call MakeRecombinationInfo(RelX, RelY)
    End If
    UpdateIDFlag = 0
    'XX = UBound(SubValid, 1)
    
    TreeImage(3) = 0
    DoneTree(0, 3) = 0
    DoneTree(1, 3) = 0
    DoneTree(2, 3) = 0
    DoneTree(3, 3) = 0
    DoneTree(4, 3) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Form2.SSPanel1(2).ZOrder
    On Error GoTo 0
End If



RedoBreakpoints = GoOn

End Function
Public Sub PolishBP(HMMCycles, ReposFlag, BPos, Epos, Seq1, Seq2, Seq3, CIOut() As Long)
'1min 42s without polish
Dim TT As Long, Tmp As Long, TCI(4) As Long, CurCI As Long
Dim Dummy As Long, CIs() As Long
Dim b As Long, A As Long, Temp As Long, BME As Long, BPoCs As Long
Dim Z As Long, GoOn As Long, Y As Long, x As Long, oB As Long, OE As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long

oSeq1 = Seq1
oSeq2 = Seq2
oSeq3 = Seq3
'If oSeq1 < oSeq2 And oSeq1 < oSeq3 Then
'    Seq1 = oSeq1
'    If oSeq2 < oSeq3 Then
'        Seq2 = oSeq2
'        Seq3 = oSeq3
'    Else
'        Seq3 = oSeq2
'        Seq2 = oSeq3
'    End If
'ElseIf oSeq2 < oSeq1 And oSeq2 < oSeq3 Then
'    Seq1 = oSeq2
'    If oSeq1 < oSeq3 Then
'        Seq2 = oSeq1
'        Seq3 = oSeq3
'    Else
'        Seq2 = oSeq3
'        Seq3 = oSeq1
'    End If
'ElseIf oSeq3 < oSeq1 And oSeq3 < oSeq2 Then
'    Seq1 = oSeq3
'    If oSeq1 < oSeq2 Then
'        Seq2 = oSeq1
'        Seq3 = oSeq2
'    Else
'        Seq2 = oSeq2
'        Seq3 = oSeq1
'    End If
'End If

If ReassortmentFlag = 1 Then ' make sure that breakpoints don't wrap if reassortment is possible
    If BPos > Epos Then
        Tmp = BPos
        BPos = Epos
        Epos = Tmp
    End If
    Dim tBP As Long
    If UBound(RBPPos, 1) < RBPNum Then
        ReDim Preserve RBPPos(RBPNum)
    End If
    For x = 0 To RBPNum
        tBP = RBPPos(x)
        For Y = 0 To NextNo
            MissingData(tBP, Y) = 1
        Next Y
    Next x
    'scan for a segment boundary
    Dim Segbound() As Byte
    ReDim Segbound(Len(StrainSeq(0)))
    For x = 0 To RBPNum
        tBP = RBPPos(x)
        Segbound(RBPPos(x)) = 1
    Next x
    
End If
'If SEventNumber = 40 Then
'    X = X
'End If
oB = BPos '156, 632
OE = Epos
TT = Abs(GetTickCount)
If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    Form1.SSPanel1.Caption = "Calculating breakpoint confidence intervals"
End If
If BPos < Epos Then

    BME = Epos - BPos
Else
    BME = Len(StrainSeq(0)) + (Epos - BPos)
End If
'double version
'Dummy = BenHMM(HMMCycles, 0, CurCI, CIs(), Seq1, Seq2, Seq3)

'Single version
Dummy = BenHMM(HMMCycles, 0, CurCI, CIs(), Seq1, Seq2, Seq3)


Seq1 = oSeq1
Seq2 = oSeq2
Seq3 = oSeq3


If CurCI > -1 Then
    If (BPos > 1 And BPos < Len(StrainSeq(0))) Or ReassortmentFlag = 1 Then
        Call MatchBPtoCI(CurCI, CIs(), BPos, TCI())
        CIOut(0) = (TCI(0)) 'left bound 99%
        CIOut(1) = (TCI(1)) 'right bound 99%
        CIOut(2) = (TCI(2)) 'hmm beginp
        CIOut(6) = (TCI(3))
        CIOut(7) = (TCI(4))
        
    Else
        CIOut(0) = -BPos
        CIOut(1) = -BPos
        CIOut(2) = -BPos
        CIOut(6) = -BPos
        CIOut(7) = -BPos
        x = x
    End If
    
    If (Epos > 1 And Epos < Len(StrainSeq(0))) Or ReassortmentFlag = 1 Then
        Call MatchBPtoCI(CurCI, CIs(), Epos, TCI())
        CIOut(3) = (TCI(0)) '
        CIOut(4) = (TCI(1))
        CIOut(5) = (TCI(2))
        CIOut(8) = (TCI(3))
        CIOut(9) = (TCI(4))
        x = x
    Else
        CIOut(3) = -Epos
        CIOut(4) = -Epos
        CIOut(5) = -Epos
        CIOut(8) = -Epos
        CIOut(9) = -Epos
        x = x
    End If
    '11674
    
    
    If Abs(Abs(CIOut(2)) - Abs(CIOut(5))) > 2 Then
        If CIOut(2) >= 0 Or ReposFlag = 1 Then
            BPos = Abs(CIOut(2))
        Else ' the cis didnt include the target breakpoint
            If Abs(BPos - Abs(CIOut(2))) < BME / 2 Or ((CircularFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) - Abs(BPos - Abs(CIOut(2))) < BME / 2) Then
                BPos = Abs(CIOut(2))
                CIOut(0) = Abs(CIOut(0))
                CIOut(1) = Abs(CIOut(1))
                CIOut(2) = Abs(CIOut(2))
                CIOut(6) = Abs(CIOut(6))
                CIOut(7) = Abs(CIOut(7))
            Else
                'CIOut(0) = -1
                'CIOut(1) = -1
                'CIOut(2) = -1
            End If
        
        End If
        If CIOut(5) >= 0 Or ReposFlag = 1 Then
            Epos = Abs(CIOut(5))
        Else
            If Abs(Epos - Abs(CIOut(5))) < BME / 2 Or ((CircularFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) - Abs(Epos - Abs(CIOut(5))) < BME / 2) Then
                Epos = Abs(CIOut(5))
                CIOut(3) = Abs(CIOut(3))
                CIOut(4) = Abs(CIOut(4))
                CIOut(5) = Abs(CIOut(5))
                CIOut(8) = Abs(CIOut(8))
                CIOut(9) = Abs(CIOut(9))
                
            Else
                'CIOut(3) = -1
                'CIOut(4) = -1
                'CIOut(5) = -1
            End If
        
        
        End If
    Else
        
        
        'which is closer, Bpos or epos
        If (Abs(BPos - Abs(CIOut(2))) <= Abs(Epos - Abs(CIOut(2))) Or ((CircularFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) - Abs(BPos - Abs(CIOut(2))) <= Abs(Epos - Abs(CIOut(2))))) And (CircularFlag = 0 Or (Abs(BPos - Abs(CIOut(2))) <= Len(StrainSeq(0)) - Abs(Epos - Abs(CIOut(2))) Or Len(StrainSeq(0)) - Abs(BPos - Abs(CIOut(2))) <= Len(StrainSeq(0)) - Abs(Epos - Abs(CIOut(2))))) Then
            
            If Abs(BPos - Abs(CIOut(2))) < BME / 2 Or ((CircularFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) - Abs(BPos - Abs(CIOut(2))) < BME / 2) Then
                BPos = Abs(CIOut(2))
            Else
                CIOut(0) = -1
                CIOut(1) = -1
                CIOut(2) = -1
            End If
            CIOut(3) = -1
            CIOut(4) = -1
            CIOut(5) = -1
        Else
            
            
            If Abs(Epos - Abs(CIOut(5))) < BME / 2 Or ((CircularFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) - Abs(Epos - Abs(CIOut(5))) < BME / 2) Then
                Epos = Abs(CIOut(5))
            Else
                CIOut(3) = -1
                CIOut(4) = -1
                CIOut(5) = -1
            End If
            CIOut(0) = -1
            CIOut(1) = -1
            CIOut(2) = -1
        End If
    End If
Else

End If




If CIOut(0) = 0 And CIOut(1) = 0 And CIOut(2) = 0 Then
    CIOut(0) = -1
    CIOut(1) = -1
    CIOut(2) = -1
    BPos = oB
End If
If CIOut(3) = 0 And CIOut(4) = 0 And CIOut(5) = 0 Then
    CIOut(3) = -1
    CIOut(4) = -1
    CIOut(5) = -1
    Epos = OE
End If



If x = x Then
    
    
    
    
    'check if ci overlaps missing data
    
    
    If CIOut(0) > -1 Then
        Y = CIOut(1)
        Do
            Y = Y - 1
            If Y < 1 Then Y = Len(StrainSeq(0))
            If Y = CIOut(2) Then
                BPos = CIOut(2)
                Exit Do
            End If
            If MissingData(Y, Seq1) = 1 Or MissingData(Y, Seq2) = 1 Or MissingData(Y, Seq3) = 1 Then
                If CIOut(2) < CIOut(5) Then
                    If Y < CIOut(5) Then
                        CIOut(2) = Y + 1
                        BPoCs = Y + 1
                        Exit Do
                    
                    Else
                        BPos = CIOut(2)
                Exit Do
                    End If
                Else
                    CIOut(2) = Y + 1
                    BPoCs = Y + 1
                    Exit Do
                End If
            End If
        
        
        Loop
        
        
        
        'first make sure that ciout(2) and ciout5 (the breakpoint positions are not at misisng data sites)
'        If MissingData(CIOut(2), Seq1) > 0 Or MissingData(CIOut(2), Seq2) > 0 Or MissingData(CIOut(2), Seq3) > 0 Then
'            'track towards the rhs breakpoint (i.e. presumably towards the epos within the exchanged recombinant fragment)
'            Y = CIOut(2)
'            Do
'                Y = Y + 1
'                If Y > Len(StrainSeq(0)) Then Y = 1
'                If Y = CIOut(2) Then Exit Do
'                If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
'                    CIOut(2) = Y
'                End If
'
'            Loop
'        End If
'        If MissingData(CIOut(5), Seq1) > 0 Or MissingData(CIOut(5), Seq2) > 0 Or MissingData(CIOut(5), Seq3) > 0 Then
'            'track towards the lhs breakpoint (i.e. presumably towards the bpos within the exchanged recombinant fragment)
'            Y = CIOut(5)
'            Do
'                Y = Y - 1
'                If Y < 1 Then Y = Len(StrainSeq(0))
'                If Y = CIOut(5) Then Exit Do
'                If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
'                    CIOut(5) = Y
'                End If
'
'            Loop
'        End If
'        If CIOut(0) < CIOut(1) Then 'do bpos first
'            For X = CIOut(2) To CIOut(0) Step -1
'                If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                    BPos = X
'                    CIOut(2) = BPos
'                    Exit For
'                End If
'            Next X
'            X = X
'        Else
'            GoOn = 1
'            For X = CIOut(0) To Len(StrainSeq(0))
'                If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                    BPos = X
'                    CIOut(2) = BPos
'                    Exit For
'                    GoOn = 0
'                End If
'            Next X
'            If GoOn = 1 Then
'                For X = 1 To CIOut(1)
'                    If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                        BPos = X
'                        CIOut(2) = BPos
'                        Exit For
'                    End If
'                Next X
'            End If
'        End If
    'if burt detects no beginning breakpoint
    Else
    
    End If
    'XX = BPos
    If CIOut(3) > -1 Then
        Y = CIOut(3)
        Do
            Y = Y + 1
            If Y > Len(StrainSeq(0)) Then Y = 1
            If Y = CIOut(5) Then
                Epos = CIOut(5)
                Exit Do
            End If
            If MissingData(Y, Seq1) = 1 Or MissingData(Y, Seq2) = 1 Or MissingData(Y, Seq3) = 1 Then
                
                If CIOut(2) < CIOut(5) Then
                    If Y > CIOut(2) Then
                    
                        CIOut(5) = Y - 1
                        Epos = Y - 1
                        Exit Do
                    Else
                        Epos = CIOut(5)
                        Exit Do
                    End If
                
                Else
                    CIOut(5) = Y - 1
                    Epos = Y - 1
                    Exit Do
                End If
            End If
        
        
        Loop
        x = x
'        If CIOut(3) < CIOut(4) Then 'do epos first
'            For X = CIOut(3) To CIOut(4)
'                If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                    EPos = X
'                    CIOut(5) = EPos
'                    Exit For
'                End If
'            Next X
'        Else
'            GoOn = 1
'            For X = CIOut(3) To Len(StrainSeq(0))
'                If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                    EPos = X
'                    CIOut(5) = EPos
'                    GoOn = 0
'                    Exit For
'                End If
'            Next X
'            If GoOn = 1 Then
'                For X = 1 To CIOut(4)
'                    If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                        EPos = X
'                        CIOut(5) = EPos
'                        Exit For
'                    End If
'                Next X
'            End If
'        End If
    End If
    
    If CIOut(1) > -1 Then
    'For X = 0 To 2
        GoOn = 1
        If BPos > Len(StrainSeq(0)) Then
            BPos = BPos - Len(StrainSeq(0))
        End If
'        XX = UBound(MissingData, 1)
        If MissingData(BPos, Seq1) > 0 Or MissingData(BPos, Seq2) > 0 Or MissingData(BPos, Seq3) > 0 Then
            For Y = BPos To Len(StrainSeq(0))
                If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                    BPos = Y
                    CIOut(0) = BPos
                    GoOn = 0
                    Exit For
                End If
            Next Y
            If GoOn = 1 Then
                For Y = 1 To BPos
                    If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                        BPos = Y
                        CIOut(0) = BPos
                        GoOn = 0
                        Exit For
                    End If
                Next Y
            End If
        End If
    End If
    'Next X
    'now do epos
    'For X = 0 To 2
    
    If CIOut(5) > -1 Then
        GoOn = 1
        If Epos > Len(StrainSeq(0)) Then
            Epos = Epos - Len(StrainSeq(0))
        End If
        If MissingData(Epos, Seq1) > 0 Or MissingData(Epos, Seq2) > 0 Or MissingData(Epos, Seq3) > 0 Then
            For Y = Epos To 1 Step -1
                If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                    Epos = Y
                    CIOut(4) = Epos
                    GoOn = 0
                    Exit For
                End If
            Next Y
            If GoOn = 1 Then
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                        Epos = Y
                        CIOut(4) = Epos
                        GoOn = 0
                        Exit For
                    End If
                Next Y
            End If
        End If
    End If
End If
'If SEventNumber = 3 Then
'    X = X
'End If
If ReassortmentFlag = 1 Then 'differentiate between recombination and reassortment
    If Segbound(BPos - 1) = 1 Then
        BPos = BPos - 1
    End If
    If Epos < Len(StrainSeq(0)) Then
        If Segbound(Epos + 1) = 1 Then
            Epos = Epos + 1
        End If
    End If
    If (MissingData(BPos, Seq1) = 1 Or MissingData(BPos, Seq2) = 1 Or MissingData(BPos, Seq3) = 1) And Segbound(BPos) = 0 Then
        'track back to where there is no missing data or segbound reached
        For x = BPos - 1 To 1 Step -1
            If Segbound(x) = 1 Then
                BPos = x
                Exit For
            ElseIf MissingData(x, Seq1) = 0 And MissingData(x, Seq2) = 0 And MissingData(x, Seq3) = 0 Then
                
                Exit For
            End If
        Next x
        If Segbound(BPos) = 0 Then
            For Y = BPos + 1 To Len(StrainSeq(0))
                If Segbound(Y) = 1 Then
                    BPos = Y
                    Exit For
                ElseIf MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                    Exit For
                End If
            Next Y
        End If
    End If
    
    
    If (MissingData(Epos, Seq1) = 1 Or MissingData(Epos, Seq2) = 1 Or MissingData(Epos, Seq3) = 1) And Segbound(Epos) = 0 Then
        'track back to where there is no missing data or segbound reached
        For x = Epos To Len(StrainSeq(0))
            If Segbound(x) = 1 Then
                Epos = x
                Exit For
            ElseIf MissingData(x, Seq1) = 0 And MissingData(x, Seq2) = 0 And MissingData(x, Seq3) = 0 Then
                Exit For
            End If
        Next x
        If Segbound(Epos) = 0 Then
            For Y = Epos - 1 To 1 Step -1
                If Segbound(Y) = 1 Then
                    Epos = Y
                    Exit For
                ElseIf MissingData(Y, Seq1) = 0 And MissingData(Y, Seq2) = 0 And MissingData(Y, Seq3) = 0 Then
                    Exit For
                End If
            Next Y
        End If
    End If
    If x = 123456678 Then 'this forces only single component reassortment
        If Segbound(BPos) = 1 Then
            CIOut(0) = BPos
            CIOut(1) = BPos
            For x = BPos + 1 To Len(StrainSeq(0))
                If Segbound(x) = 1 Then
                    Epos = x
                    CIOut(3) = x
                    CIOut(4) = x
                    CIOut(5) = x
                    Exit For
                End If
                
            Next x
        
        ElseIf Segbound(Epos) = 1 Then
            CIOut(3) = Epos
            CIOut(4) = Epos
            For x = Epos - 1 To 1 Step -1
                If Segbound(x) = 1 Then
                    BPos = x
                    CIOut(0) = x
                    CIOut(1) = x
                    CIOut(2) = x
                    Exit For
                End If
                
            Next x
        End If
    End If
    
    
    
End If

'If SEventNumber >= 6 Then
'X = X
'End If

If ReassortmentFlag > 0 Then
  Dim MinDx As Long, WInD As Long
  MinDx = Len(StrainSeq(0))
  
  
  If ReassortmentFlag = 1 Then
      If BPos > Epos Then
        Temp = BPos
        BPos = Epos
        Epos = Temp
      End If
      If Epos = RBPPos(RBPNum) And BPos = RBPPos(RBPNum - 1) Then
          Epos = RBPPos(RBPNum - 1)
          BPos = RBPPos(RBPNum - 2)
      End If
      If x = 1234567890 Then 'this forces single component reassortment
        If Segbound((Epos)) = 1 Then
            If Segbound((BPos)) <> 1 Then
              For x = 1 To RBPNum 'RBPPos(X)
                  If Abs(RBPPos(x) - BPos) < MinDx And RBPPos(x) <> Epos Then
                      MinDx = Abs(RBPPos(x) - BPos)
                      WInD = RBPPos(x)
                  End If
              Next x
              BPos = WInD
            End If
            
            
        ElseIf Segbound((BPos)) = 1 Then
            If Segbound((Epos)) <> 1 Then
              For x = 1 To RBPNum 'RBPPos(X)
                  If Abs(RBPPos(x) - Epos) < MinDx And RBPPos(x) <> BPos Then
                      MinDx = Abs(RBPPos(x) - Epos)
                      WInD = RBPPos(x)
                  End If
              Next x
              Epos = WInD
            End If
           
            
        Else
              
          
        
        End If
    End If
  End If
  

  
  'Final check to see if the event spans a segment boundary
  Dim tBPx() As Long, tBPNum As Long, MaxSpan As Long, tSpan As Long
  ReDim tBPx(RBPNum)
  
  If x = 123456 Then 'force singe component reassortment
    
    If BPos = Epos Then
        Exit Sub
    End If
    tBPNum = 0
    x = BPos
    Do
        If Segbound(x) = 1 Then
            tBPNum = tBPNum + 1
            tBPx(tBPNum) = x
            
        
        End If
        x = x + 1
        If x = Epos Then
            If Segbound(x) = 1 Then
                tBPNum = tBPNum + 1
                tBPx(tBPNum) = x
            End If
            Exit Do
        End If
        If x > Len(StrainSeq(0)) Then x = 0
        If x = Epos Then
            If Segbound(x) = 1 Then
                tBPNum = tBPNum + 1
                tBPx(tBPNum) = x
            End If
            Exit Do
        End If
        ''ext X
    Loop
    If tBPNum = 0 Then
        
        Exit Sub
    ElseIf tBPNum = 1 Then
        x = x
        tSpan = tBPx(1) - BPos
        If tSpan < (Epos - tBPx(1)) Then
            BPos = tBPx(1)
        Else
            Epos = tBPx(1)
        End If
    ElseIf tBPNum = 2 Then
        BPos = tBPx(1)
        Epos = tBPx(2)
    Else
        MaxSpan = 0
        MaxSpan = tBPx(1) - BPos
        Epos = tBPx(1)
        For x = 2 To tBPNum
            If tBPx(x - 1) < tBPx(x) Then
                tSpan = tBPx(x) - tBPx(x - 1)
            Else
                tSpan = tBPx(x) + Len(StrainSeq(0)) - tBPx(x - 1)
            End If
            If tSpan > MaxSpan Then
                BPos = tBPx(x - 1)
                Epos = tBPx(x)
            End If
            
        Next x
    End If
    If Segbound((Epos)) = 1 Then
          If Segbound((BPos)) <> 1 Then
            For x = 1 To RBPNum 'RBPPos(X)
                If Abs(RBPPos(x) - BPos) < MinDx And RBPPos(x) <> Epos Then
                    MinDx = Abs(RBPPos(x) - BPos)
                    WInD = RBPPos(x)
                End If
            Next x
            BPos = WInD
          End If
          
          
      ElseIf Segbound((BPos)) = 1 Then
          If Segbound((Epos)) <> 1 Then
            For x = 1 To RBPNum 'RBPPos(X)
                If Abs(RBPPos(x) - Epos) < MinDx And RBPPos(x) <> BPos Then
                    MinDx = Abs(RBPPos(x) - Epos)
                    WInD = RBPPos(x)
                End If
            Next x
            Epos = WInD
          End If
         
          
      End If
  Else 'allow multi-component reassortment
    If BPos = Epos Then
        Exit Sub
    End If
    tBPNum = 0
    x = BPos
    Do
        If Segbound(x) = 1 Then
            tBPNum = tBPNum + 1
            tBPx(tBPNum) = x
            
        
        End If
        x = x + 1
        If x = Epos Then
            If Segbound(x) = 1 Then
                tBPNum = tBPNum + 1
                tBPx(tBPNum) = x
            End If
            Exit Do
        End If
        If x > Len(StrainSeq(0)) Then x = 0
        If x = Epos Then
            If Segbound(x) = 1 Then
                tBPNum = tBPNum + 1
                tBPx(tBPNum) = x
            End If
            Exit Do
        End If
        ''ext X
    Loop
    
    
    
    If tBPNum = 0 Then
        'no segment boundaries are crossed - scan back from bpos and forwards from epos to nearest boundary
        For x = BPos To 1 Step -1
            If Segbound(x) = 1 Then Exit For
        Next x
        For Y = Epos To Len(StrainSeq(0)) 'force reassortment if >80% of the component is "recombined"
            If Segbound(Y) = 1 Then Exit For
        Next Y
        If (Epos - BPos) > ((Y - x) * 0.8) Then 'if more than 80% of the component is between the breakpoints then force brakpoints to segment boundary
            BPos = x
            Epos = Y
        Else
            If Abs(CIOut(4)) > Y And Abs(CIOut(3)) < Y Then
                Epos = Y
            End If
               
            If Abs(CIOut(1)) > x And Abs(CIOut(0)) < x Then
                BPos = x
            End If
        x = x
        End If
        
        Exit Sub
    ElseIf tBPNum > 0 Then ' force reassortment if the distances from the single crossed segment boundary justify it
        For x = BPos To 1 Step -1
            If Segbound(x) = 1 Then Exit For
        Next x
        For Y = Epos To Len(StrainSeq(0))
            If Segbound(Y) = 1 Then Exit For
        Next Y
        For A = BPos To Len(StrainSeq(0))
            If Segbound(A) = 1 Then Exit For
        Next A
        For b = Epos To 1 Step -1
            If Segbound(b) = 1 Then Exit For
        Next b
        If (Epos - BPos) > ((Y - x) * 0.9) Then 'if more than 80% of the component is between the breakpoints then force brakpoints to segment boundary
            BPos = x
            Epos = Y
        Else
            If (A - BPos) < (Epos - b) Then
                If A - BPos > (A - x) * 0.8 Then
                    BPos = x
                Else
                    BPos = A
                End If
                If (Epos - b) > ((Y - A) * 0.8) Then
                    Epos = Y
                Else
                    If Abs(CIOut(4)) > Y And Abs(CIOut(3)) < Y Then
                        Epos = Y
                    End If
                End If
                x = x
            Else
                If (Epos - b) > ((Y - A) * 0.8) Then
                    Epos = Y
                Else
                    Epos = b
                End If
                If A - BPos > (A - x) * 0.8 Then
                    BPos = x
                Else
                    If Abs(CIOut(1)) > x And Abs(CIOut(0)) < x Then
                        BPos = x
                    End If
                End If
            End If
            
        End If
    End If
    If x = 1234567890 Then 'force breakpoints to segment boundaries
          If Segbound((Epos)) = 1 Then
                If Segbound((BPos)) <> 1 Then
                  For x = 1 To RBPNum 'RBPPos(X)
                      If Abs(RBPPos(x) - BPos) < MinDx And RBPPos(x) <> Epos Then
                          MinDx = Abs(RBPPos(x) - BPos)
                          WInD = RBPPos(x)
                      End If
                  Next x
                  BPos = WInD
                End If
                
                
            ElseIf Segbound((BPos)) = 1 Then
                If Segbound((Epos)) <> 1 Then
                  For x = 1 To RBPNum 'RBPPos(X)
                      If Abs(RBPPos(x) - Epos) < MinDx And RBPPos(x) <> BPos Then
                          MinDx = Abs(RBPPos(x) - Epos)
                          WInD = RBPPos(x)
                      End If
                  Next x
                  Epos = WInD
                End If
               
                
            End If
        End If
   End If
End If



Dim oD As Long, ID As Long
oD = 0
ID = 0
If BPos < Epos Then
    
    
    For x = 0 To BPos - 1
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                oD = oD + 1
            End If
            
        End If
    Next x
    
    For x = Epos + 1 To Len(StrainSeq(0))
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                oD = oD + 1
            End If
            
        End If
    Next x
    
    
    For x = BPos To Epos
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                ID = ID + 1
            End If
        End If
    Next x
    
Else

    For x = 0 To Epos
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                ID = ID + 1
            End If
            
        End If
    Next x
    
    For x = Epos + 1 To BPos - 1
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                oD = oD + 1
            End If
            
        End If
    Next x
    
    
    For x = BPos To Len(StrainSeq(0))
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq3) > 46 Then
            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                ID = ID + 1
            End If
        End If
    Next x
End If
x = x
If oD < 3 Or ID < 3 Then
    BPos = oB
    Epos = OE

End If

'make sure that bpos and epos are on sites with nts in all three sequences
If SeqNum(BPos, Seq1) = 46 Or SeqNum(BPos, Seq2) = 46 Or SeqNum(BPos, Seq3) = 46 Then
    x = BPos + 1
    CycleX = 0
    Do
        If x > Len(StrainSeq(0)) Then
            If CircularFlag = 1 Then
                x = 1
                CycleX = CycleX + 1
                If CycleX > 1 Then Exit Do
            Else
                Exit Do
            End If
        End If
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq2) > 46 Then
            BPos = x
            Exit Do
            XX = SEventNumber
        End If
        x = x + 1
    Loop
End If

If SeqNum(Epos, Seq1) = 46 Or SeqNum(Epos, Seq2) = 46 Or SeqNum(Epos, Seq3) = 46 Then
    x = Epos - 1
    CycleX = 0
    Do
        If x > 0 Then
            If CircularFlag = 1 Then
                x = Len(StrainSeq(0))
                CycleX = CycleX + 1
                If CycleX > 1 Then Exit Do
            Else
                Exit Do
            End If
        End If
        If x < 1 And CircularFlag = 1 Then
            x = Len(StrainSeq(0)) + x
            
        ElseIf x < 1 Then
            Epos = 1
            x = 1
            Exit Do
        End If
        If SeqNum(x, Seq1) > 46 And SeqNum(x, Seq2) > 46 And SeqNum(x, Seq2) > 46 Then
            Epos = x
            Exit Do
        End If
        x = x - 1
    Loop
End If



'Next X
'If SEventNumber >= 27 Then
'    X = X
'    XX = oB
'    XX = BPos
'
'    XX = oE
'    XX = EPos
'
'End If


End Sub
Public Sub MatchBPtoCI(CurCI, CIs() As Long, BP, TCI() As Long)
Dim Y As Long, TFx As Long, x As Long, RangeE() As Byte, MatchDist() As Long
If CurCI = -1 Then Exit Sub
ReDim MatchDist(CurCI)


For x = 1 To CurCI
    ReDim RangeE(Len(StrainSeq(0)))
    TFx = Int(CIs(0, x) / Len(StrainSeq(0)))
    'If TFx > 7 Then
    '    X = X
    'End If
    If CIs(0, x) > Len(StrainSeq(0)) Then CIs(0, x) = CIs(0, x) - Len(StrainSeq(0)) * TFx
    If CIs(1, x) > Len(StrainSeq(0)) Then CIs(1, x) = CIs(1, x) - Len(StrainSeq(0)) * TFx
    If CIs(2, x) > Len(StrainSeq(0)) Then CIs(2, x) = CIs(2, x) - Len(StrainSeq(0)) * TFx
    If CIs(3, x) > Len(StrainSeq(0)) Then CIs(3, x) = CIs(3, x) - Len(StrainSeq(0)) * TFx
    If CIs(4, x) > Len(StrainSeq(0)) Then CIs(4, x) = CIs(4, x) - Len(StrainSeq(0)) * TFx
    If CIs(0, x) <= Len(StrainSeq(0)) Then
   
        If CIs(1, x) <= Len(StrainSeq(0)) Then
   
            If CIs(2, x) <= Len(StrainSeq(0)) Then
   
            'If X = 12345 Then 'this is a more complicated way
                If CIs(0, x) < CIs(1, x) Then 'i.e the confidence interval does not wrap
                    For Y = CIs(0, x) To CIs(1, x)
                        RangeE(Y) = 1
                    Next Y
                    
                Else 'if the ci wraps
                    For Y = CIs(0, x) To Len(StrainSeq(0))
                        RangeE(Y) = 1
                    Next Y
                    For Y = 0 To CIs(1, x)
                        RangeE(Y) = 1
                    Next Y
                
                End If
                If CIs(2, x) >= 0 Then
                    MatchDist(x) = Abs(XPosDiff(BP) - XPosDiff(CIs(2, x)))
                End If
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    If (XPosDiff(Len(StrainSeq(0))) - MatchDist(x)) < MatchDist(x) Then MatchDist(x) = XPosDiff(Len(StrainSeq(0))) - MatchDist(x)
                End If
                If RangeE(BP) = 1 Then 'it is within the confidence interval
                    If (XPosDiff(Len(StrainSeq(0))) - MatchDist(x)) < MatchDist(x) Then
                        MatchDist(x) = -(XPosDiff(Len(StrainSeq(0))) - MatchDist(x)) ' the nearest match that is within a CI will be the lowest value
                    Else
                        MatchDist(x) = -MatchDist(x)
                    End If
                End If
            'End If
            End If
        End If
    End If
    
    
Next x


'find the smallest matchdist - i could get fancier here but will do it simple first
Dim SmallestM As Long, M As Long
SmallestM = Len(StrainSeq(0))
For x = 1 To CurCI
    If SmallestM = 0 Then Exit For
    If SmallestM > 0 Then
        If SmallestM > (MatchDist(x)) Then
            SmallestM = (MatchDist(x))
            M = x
        End If
    Else
       If Abs(SmallestM) > Abs(MatchDist(x)) Then
            If MatchDist(x) <= 0 Then
                SmallestM = (MatchDist(x))
                M = x
            End If
        End If
    End If
Next x
If SmallestM <= 0 Then
    'If CIs(1, M) <> CIs(4, M) Then
    '    X = X
    'End If
    TCI(0) = CIs(0, M)
    TCI(1) = CIs(1, M)
    TCI(2) = CIs(2, M)
    TCI(3) = CIs(3, M)
    TCI(4) = CIs(4, M)
Else
    TCI(0) = -CIs(0, M)
    TCI(1) = -CIs(1, M)
    TCI(2) = -CIs(2, M)
    TCI(3) = -CIs(3, M)
    TCI(4) = -CIs(4, M)
End If

'Exit Sub




End Sub

Public Function BenHMM(HMMCycles, DrawPFlag, CurCI As Long, CIs() As Long, oSeq1, oSeq2, oSeq3)

Dim Pict As Long, YScaleFactor As Single, TotProb As Variant, MaxV As Variant, Z As Long, x As Long, Y As Long, Seq1 As Long, Seq2 As Long, Seq3 As Long, iVal As Single, Dummy As Long
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
If oSeq1 < oSeq2 And oSeq1 < oSeq3 Then
    Seq1 = oSeq1
    If oSeq2 < oSeq3 Then
        Seq2 = oSeq2
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq2
    End If
ElseIf oSeq2 < oSeq1 And oSeq2 < oSeq3 Then
    Seq1 = oSeq2
    If oSeq1 < oSeq3 Then
        Seq2 = oSeq1
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq1
    End If
    
ElseIf oSeq3 < oSeq1 And oSeq3 < oSeq2 Then
    Seq1 = oSeq3
    If oSeq1 < oSeq2 Then
        Seq2 = oSeq1
        Seq3 = oSeq2
    Else
        Seq2 = oSeq2
        Seq3 = oSeq1
    End If
End If

Dim RecodeB() As Byte, SLen As Long, Coffset As Long, Recode() As Byte

'recode the sequences into an ABC string

ReDim RecodeB(Len(StrainSeq(0)) * 2)


Y = 0
ReDim XPosDiff(Len(StrainSeq(0)) * 2), XDiffPos(Len(StrainSeq(0)) * 2)
'@
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, Seq1) <> 46 Then
        If SeqNum(x, Seq2) <> 46 Then
            If SeqNum(x, Seq3) <> 46 Then
                If SeqNum(x, Seq1) = SeqNum(x, Seq2) Then
                    If SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                        Y = Y + 1
                        RecodeB(Y - 1) = 0
                        XDiffPos(Y) = x
                        
                    End If
                ElseIf SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    
                    RecodeB(Y - 1) = 2
                    XDiffPos(Y) = x
                ElseIf SeqNum(x, Seq2) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    RecodeB(Y - 1) = 1
                    XDiffPos(Y) = x
                End If
            End If
        End If
    End If
    
    XPosDiff(x) = Y
Next x



If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    Coffset = CLng(Y / 2)
    Dim TXPD() As Long, TXDP() As Long, RB() As Byte, A As Long
    ReDim TXPD(Y * 2), TXDP(Y * 2), RB(Y + Coffset * 2)
    For A = 0 To Coffset - 1
    
        RB((Y + A + Coffset + 1)) = RecodeB(A) '1678-2237'0(2468)-821(3289)

    Next A
    For A = Coffset To Y - 1
        'TXPD(A - COffset) = XPosDiff(A)
        'TXDP(A - COffset) = XDiffPos(A)
        RB((A - Coffset)) = RecodeB(A) '822(0)-1644(822)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    For A = 0 To Y - 1
        'TXPD(A + COffset) = XPosDiff(A)
        'TXDP(A + COffset) = XDiffPos(A)
        RB((A + Coffset + 1)) = RecodeB(A) '1(823)-1644(2467)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    Y = Y + (Coffset) * 2
    SLen = Y
    For A = 0 To SLen
        'XPosDiff(A) = TXPD(A)
        'XDiffPos(A) = TXDP(A)
        RecodeB(A) = RB(A)
    
    Next A
    
    
Else
    SLen = Y
    Coffset = 0
End If


'Initialisation
'For X = 0 To 6
'    X = X
'    XX = RecodeB(X)
'Next X

Dim NumberXY As Long
Dim NumberABC As Long

NumberXY = 3
NumberABC = 3


Dim TransitionBak() As Double, EmissionBak() As Double
Dim InitPBak() As Double, MaxP As Double, MinP As Double

Dim TransitionM2() As Double, EmissionM2() As Double, InitP() As Double

ReDim TransitionM2(NumberXY - 1, NumberXY - 1), EmissionM2(NumberABC - 1, NumberXY - 1), InitP(NumberXY - 1)

Dim NumCycles As Long
Dim bestLike As Double

Dim LaticePathBak() As Long, StateCount() As Double, TotCount As Double, TransitionCount() As Double, TotXY(), LaticeAB() As Double, LaticeXY() As Double, LaticePath() As Long, Fudge As Double, Maxiterations As Long, PathLike As Double, MaxL As Double, PathMax As Double


bestLike = -1000000
'Dim ImballancedSeq As Long
'For ImballancedSeq = 0 To 5

    'If ImballancedSeq = 0 Then
    'For X = 0 To SLen
    '    RecodeB(X) = SwapAround(ImballancedSeq, Recode(X))
    'Next X
    
   ' End If
    Rnd (-BSRndNumSeed)
    
    If x = x Then
        'SS = abs(gettickcount)
        ReDim TransitionBak(NumberXY - 1, NumberXY - 1), EmissionBak(NumberABC - 1, NumberXY - 1), InitPBak(NumberXY - 1), LaticePathBak(SLen)
        '@'$
        'bestLike = DoHMMCyclesDetermin(CLng(BSRndNumSeed), SLen, HMMCycles, Len(StrainSeq(0)), NumberXY, NumberABC, RecodeB(0), TransitionBak(0, 0), EmissionBak(0, 0), InitPBak(0), LaticePathBak(0))
        bestLike = DoHMMCyclesSerial(CLng(BSRndNumSeed), SLen, HMMCycles, Len(StrainSeq(0)), NumberXY, NumberABC, RecodeB(0), TransitionBak(0, 0), EmissionBak(0, 0), InitPBak(0), LaticePathBak(0))
        
        ReDim LaticeXY(SLen, NumberXY - 1), LaticePath(SLen + 3)
        
    Else
        For NumCycles = 0 To HMMCycles '3.77 with polishbreaks off, 0 = 3.84, 5 = 4.17, 10 = 4.49, 20 = 5.6, 40 = 6.28, 80 = 8.64
            iVal = 5 / Len(StrainSeq(0))
            If NumberXY > 1 Then
                For x = 0 To NumberXY - 1
                    For Y = 0 To NumberXY - 1
                        If x = Y Then
                            TransitionM2(x, Y) = Log(1 - iVal)
                        Else
                            TransitionM2(x, Y) = Log((iVal) / (NumberXY - 1))
                        End If
                        x = x
                    Next Y
                Next x
            Else
                TransitionM2(0, 0) = Log(1)
            End If
            
            'Dim PosMaxP As Double, PosMax As Long
            
            'For X = 0 To NumberXY - 1
            '    PosMaxP = ((X + 1) / NumberABC) * (NumberABC) - 1
            '    PosMaxP = NumberABC - PosMaxP - 1 'CLng(PosMaxP) 'the value in the list that will be the maximum
            '    PosMax = PosMaxP
            '    MaxP = X / NumberXY
            '    MaxP = 0.8 'the value of the maximum
            '    MinP = (1 - MaxP) / (NumberABC - 1) 'the value of the minumum
            '    For Y = 0 To NumberABC - 1
            '
            '
            '        If Y = PosMax Then
            '            EmissionM2(Y, X) = Log(MaxP)
            '        Else
            '            EmissionM2(Y, X) = Log(MinP)
            '        End If
            '        X = X
            '    Next Y
            '    X = X
            'Next X
            
            Dim DoneImba() As Long, Imballance As Double, Imballance2 As Long
            
            'RNDSEED = RNDSEED + 1
            
            
            Imballance = (Int((NumberABC * Rnd) + 1)) / 10 '0.1,0.3
            'Imballance = 10 ^ -2
            
            If x = x Then
                ReDim DoneImba(NumberABC)
                For x = 0 To NumberXY - 1
                    
                    Do
                        
                        Imballance2 = Int(((NumberXY + 3) * Rnd)) - 2  '3,0,2,3,2
                        If Imballance2 >= 0 And Imballance2 < NumberXY Then '102,120,021,201,021,102
                            If DoneImba(Imballance2) = 0 Then
                                For Y = 0 To NumberABC - 1
                                    If Y = Imballance2 Then
                                        EmissionM2(Y, x) = 1 / NumberABC + Imballance * 2
                                    Else
                                        EmissionM2(Y, x) = 1 / NumberABC - Imballance
                                    End If
                                Next Y
                                
                                DoneImba(Imballance2) = 1
                                Exit Do
                            End If
                        End If
                    Loop
                Next x
            Else
                If NumberXY = 2 And NumberABC = 3 Then
                    EmissionM2(0, 0) = 0.1
                    EmissionM2(1, 0) = 0.1
                    EmissionM2(2, 0) = 0.8
                    EmissionM2(0, 1) = 0.6
                    EmissionM2(1, 1) = 0.2
                    EmissionM2(2, 1) = 0.2
                ElseIf NumberXY = 3 And NumberABC = 3 Then
                    EmissionM2(0, 0) = 0.1
                    EmissionM2(1, 0) = 0.1
                    EmissionM2(2, 0) = 0.8
                    EmissionM2(0, 1) = 0.15
                    EmissionM2(1, 1) = 0.7
                    EmissionM2(2, 1) = 0.15
                    EmissionM2(0, 2) = 0.6
                    EmissionM2(1, 2) = 0.2
                    EmissionM2(2, 2) = 0.2
                End If
            End If
            
            For x = 0 To NumberXY - 1
            
                For Y = 0 To NumberABC - 1
                    EmissionM2(Y, x) = Log(EmissionM2(Y, x))
                    
                Next Y
            Next x
            
            ' 0.1 0.1 0.8
            ' 0.5 0.5 0.5
            '
            
            For x = 0 To NumberXY - 1
                InitP(x) = Log(1 / NumberXY)
            Next x
            
            'InitP(0) = Log(0.5)
            'InitP(1) = Log(0.5)
            
            
            ReDim LaticeXY(SLen, NumberXY - 1), LaticePath(SLen + 3)
            Fudge = 0.01
            
            Maxiterations = 100
    '        XX = CurDir
            'viterbi training
            'Open "transition.csv" For Output As #1
            'Open "emission.csv" For Output As #2
            
            
        
            For A = 1 To Maxiterations
            
                Call Viterbi(NumberABC, NumberXY, SLen, RecodeB(), LaticeXY(), LaticeAB(), TransitionM2(), EmissionM2(), InitP())
                
                
                Dim LastHigh As Byte
                
                    '@
                    MaxL = GetLaticePathP(SLen, NumberXY, LaticeXY(0, 0), LaticeAB(0, 0), LaticePath(0))
                
                If PathMax = MaxL Then
                    Exit For
                
                Else 'PathMax <> MaxL Then
                    PathMax = MaxL
                
                End If
               
                           
                 
                
                
                'update transition and emission matrices
                If NumberXY > 1 Then
                    ReDim TotXY(NumberXY - 1)
                    '
                    ReDim TransitionCount(NumberXY - 1, NumberXY - 1)
                    '
                    ReDim StateCount(NumberABC - 1, NumberXY - 1)
                    
        '            '@
                    Dummy = UpdateCountsP(SLen, NumberABC, NumberXY, LaticePath(0), RecodeB(0), TransitionCount(0, 0), StateCount(0, 0))
                   '@
                   For x = 0 To NumberXY - 1
                        TotCount = 0
                        For Y = 0 To NumberXY - 1
                            'TransitionM2(X, Y) = TransitionCount(X, Y)
                            TotCount = TotCount + TransitionCount(x, Y)
                        Next Y
                        TotCount = TotCount + (Fudge * NumberXY)
                        For Y = 0 To NumberXY - 1
                            TransitionCount(x, Y) = TransitionCount(x, Y) + Fudge
                            
                            TransitionM2(x, Y) = Log((TransitionCount(x, Y) / TotCount))
                            
                        Next Y
                   Next x
                    
                    For Y = 0 To NumberXY - 1
                        TotCount = 0
                        For Z = 0 To NumberABC - 1
                            TotCount = TotCount + StateCount(Z, Y)
                        Next Z
                        TotCount = TotCount + (Fudge * NumberABC)
                        For Z = 0 To NumberABC - 1
                            
                            EmissionM2(Z, Y) = Log(((StateCount(Z, Y) + Fudge) / TotCount))
                           
                        Next Z
                        
                    Next Y
                Else
                    TransitionM2(0, 0) = Log(1)
                End If
                
            Next A
            
            If MaxL > bestLike Then '-1105, -1087,-1087, -1098,-1087
                'back up emmission and transition matrices
                bestLike = MaxL
                ReDim TransitionBak(NumberXY - 1, NumberXY - 1), EmissionBak(NumberABC - 1, NumberXY - 1), InitPBak(NumberXY - 1), LaticePathBak(SLen)
                For x = 0 To NumberXY - 1
                    InitPBak(x) = InitP(x)
                    For Y = 0 To NumberXY - 1
                        TransitionBak(x, Y) = TransitionM2(x, Y)
                    Next Y
                    For Y = 0 To NumberABC - 1
                        EmissionBak(Y, x) = EmissionM2(Y, x)
                    Next Y
                Next x
                For x = 0 To SLen
                    LaticePathBak(x) = LaticePath(x)
                Next x
            End If
        Next NumCycles
    End If
'Next ImballancedSeq

For x = 0 To NumberXY - 1
    InitP(x) = InitPBak(x)
    For Y = 0 To NumberXY - 1
        TransitionM2(x, Y) = TransitionBak(x, Y)
    Next Y
    For Y = 0 To NumberABC - 1
        EmissionM2(Y, x) = EmissionBak(Y, x)
    Next Y
    
Next x

For Y = 0 To SLen
    LaticePath(Y) = LaticePathBak(Y)
'    If LaticePath(Y) <> 1 Then
'        x = x
'    End If
Next Y
MaxL = bestLike '-2804.014251443'-3061.432060
'Close #1
'Close #2
Dim MaxY As Double


Dim LaticeCD() As Double
ReDim LaticeCD(SLen, NumberXY - 1)

Call Forward(NumberABC, NumberXY, SLen, RecodeB(), LaticeCD(), TransitionM2(), EmissionM2(), InitP())

Dim LaticeEF() As Double
ReDim LaticeEF(SLen, NumberXY - 1)

Call Reverse(NumberABC, NumberXY, SLen, RecodeB(), LaticeEF(), TransitionM2(), EmissionM2(), InitP())


Dim StateProb() As Double
ReDim StateProb(SLen, NumberXY)
'
For x = 0 To SLen
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = LaticeCD(x, Y) + LaticeEF(x, Y)
    Next Y
    MaxV = -10 ^ 22
    
    For Y = 0 To NumberXY - 1
        If MaxV < StateProb(x, Y) Then MaxV = StateProb(x, Y) '- 696.22904; -696.6417
        
    Next Y
    TotProb = 0
    
    For Y = 0 To NumberXY - 1
        
        StateProb(x, Y) = StateProb(x, Y) - MaxV
        StateProb(x, Y) = Exp(StateProb(x, Y))
        TotProb = TotProb + StateProb(x, Y)
        
    Next Y
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = StateProb(x, Y) / TotProb
        
    Next Y
    
Next x

MaxY = 0
For x = 1 To SLen
    For Y = 0 To NumberXY - 1
        If Abs(StateProb(x, Y)) > MaxY Then MaxY = Abs(StateProb(x, Y)) '8168;8649
    Next Y
Next x



LenXoverSeq = SLen

If SLen > 0 Then
    If CircularFlag = 1 Or ReassortmentFlag = 1 Then 'get rid of overlap
        For x = 0 To SLen / 2
            LaticePath(x) = LaticePath(x + Coffset + 1)
            For Y = 0 To NumberXY - 1
                StateProb(x, Y) = StateProb((x + Coffset + 1), Y)
            Next Y
        Next x
        SLen = SLen / 2
    End If
End If
    
Dim GoOn As Byte
ReDim CIs(5, 10)
CurCI = -1

If SLen = 0 Then Exit Function
If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    LaticePath(SLen - 1) = LaticePath(2)
    'LaticePath(SLen - 1) = LaticePath(1)
    'For Z = 0 To NumberXY - 1
    '    StateProb(SLen - 1, Z) = StateProb(1, Z)
    'Next Z
Else
    LaticePath(SLen - 1) = LaticePath(SLen - 2)
    'LaticePath(SLen + 1) = LaticePath(SLen)
End If
CurCI = 0
'If SEventNumber = 8 Then
'    X = X
'End If
x = x
'For X = 1 To SLen
'    If StateProb(X, 0) >= StateProb(X, 1) And StateProb(X, 0) >= StateProb(X, 2) Then
'        LaticePath(X) = 0
'    ElseIf StateProb(X, 1) >= StateProb(X, 0) And StateProb(X, 1) >= StateProb(X, 2) Then
'        LaticePath(X) = 1
'    ElseIf StateProb(X, 2) >= StateProb(X, 0) And StateProb(X, 2) >= StateProb(X, 1) Then
'        LaticePath(X) = 2
'    End If
'
'Next X


For x = 2 To SLen - 2
    
    If LaticePath(x) <> LaticePath(x + 1) Then 'breakpoint position found
        
        CurCI = CurCI + 1
        
        If CurCI > UBound(CIs, 2) Then
            ReDim Preserve CIs(5, CurCI + 10)
        End If
        If x < SLen - 2 Then '1937,1946:2202-2220
            CIs(2, CurCI) = (XDiffPos(x)) + ((XDiffPos(x + 1)) - (XDiffPos(x))) / 2
        Else
            CIs(2, CurCI) = (XDiffPos(x)) + ((Len(StrainSeq(0))) - (XDiffPos(x))) / 2
        End If
        'find left 99% (0) and 95% (3) CI
        If CIs(2, CurCI) < 0 Then CIs(2, CurCI) = 0
        CIs(3, CurCI) = 0
        CIs(4, CurCI) = 0
        For Y = x To -SLen Step -1
            If Y <= 0 Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y + SLen
                Else
                    CIs(0, CurCI) = 1
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(3, CurCI) = 0 Then
                    
                        If A > 1 Then
                            'If A < SLen Then
                            CIs(3, CurCI) = (XDiffPos(A - 1)) + 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                            'End If
                            
                        Else
                            CIs(3, CurCI) = 1 '(XDiffPos(A)) + 1 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                        End If
                    
                    End If
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A > 1 Then
                                CIs(0, CurCI) = (XDiffPos(A - 1)) + 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                                
                            Else
                                CIs(0, CurCI) = 1 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                            End If
                        GoOn = 0
                        Exit For
                    End If
                
                End If
                
            
            Next Z
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2227,2227
        'XX = SEventNumber
        'find right 99% (1) and 95% (4) CI
        
        For Y = x + 1 To SLen * 2
            If Y > SLen Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y - SLen
                Else
                    CIs(1, CurCI) = (Len(StrainSeq(0)))
                    CIs(4, CurCI) = (Len(StrainSeq(0)))
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(4, CurCI) = 0 Then
                    
                        If A < SLen - 1 Then
                            CIs(4, CurCI) = (XDiffPos(A + 1)) - 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                        Else
                            CIs(4, CurCI) = (Len(StrainSeq(0))) 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                            
                        End If
                   End If
                    
                    
               
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A < SLen - 1 Then
                                CIs(1, CurCI) = (XDiffPos(A + 1)) - 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                            Else
                                CIs(1, CurCI) = (Len(StrainSeq(0))) 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                                
                            End If
                       
                        GoOn = 0
                        Exit For
                    End If
                End If
            Next Z
            
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2277,2280
        x = x
    
        If CircularFlag = 1 Or ReassortmentFlag = 1 Then
            For Z = 0 To 4
                If Z <> 2 Then
                    If CIs(Z, CurCI) = 1 Or CIs(Z, CurCI) = (Len(StrainSeq(0))) Then
                        
                        
                        If Z = 1 Or Z = 4 Then
                            CIs(Z, CurCI) = (XDiffPos(1)) - 1
                            If CIs(Z, CurCI) < 1 Then CIs(Z, CurCI) = 1
                            'CIs(4) = (XDiffPos(1)) - 1
                        Else
                            
                            CIs(Z, CurCI) = (XDiffPos(SLen)) + 1
                            If CIs(Z, CurCI) > (Len(StrainSeq(0))) Then CIs(Z, CurCI) = (Len(StrainSeq(0)))
                            
                        End If
                    End If
                End If
            Next Z
        End If
        
        If CIs(3, CurCI) < CIs(4, CurCI) Then 'the 95% cis are unwrapped
            If CIs(2, CurCI) > CIs(3, CurCI) And CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = CIs(3, CurCI) + CLng((CIs(4, CurCI) - CIs(3, CurCI)) / 2)
            End If
        Else 'the 95% cis are wrapped
            If CIs(2, CurCI) > CIs(3, CurCI) Or CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = (CIs(3, CurCI) + ((Len(StrainSeq(0))) - CIs(4, CurCI))) / 2
                If CIs(2, CurCI) > (Len(StrainSeq(0))) Then CIs(2, CurCI) = CIs(2, CurCI) - (Len(StrainSeq(0)))
            End If
        
        End If
        
        
        
    End If
    

Next x




If x = 12345 Then
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.Picture = LoadPicture()
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Pict = Form1.Picture7.hdc
    XFactor = ((Form1.Picture7.Width - 40) / (Len(StrainSeq(0))))

Call DoAxes(0, 0, (Len(StrainSeq(0))), -1, CSng(MaxY), 0, 1, "P")
Dim PntAPI As POINTAPI
    
    
    
    
    Dim PHX As Long, RDPA As Single
    PHX = PicHeight - 35
    
'    SS = Abs(GetTickCount)
  
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        Form1.Picture7.ForeColor = RGB(128, 128, 128)
        Form1.Picture7.DrawWidth = 5
        'If Len(StrainSeq(0)) = (Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
            Dim YP As Long, XP As Long, OXP As Long
            Dim MaY As Long, MiY As Long
            MoveToEx Pict, 30 + (XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((LaticePath(1) / (NumberXY - 1))) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(LaticePath(x) / (NumberXY - 1)))) * (PicHeight - 35)))
                XP = 30 + (XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Form1.Picture7.DrawWidth = 1

        For Y = 0 To NumberXY - 1
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        'If Len(StrainSeq(0)) = (Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
           
            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((StateProb(1, Y)) / MaxY) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(StateProb(x - 1, Y)) / MaxY)) * (PicHeight - 35)))
                XP = 30 + Decompress(XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Next 'Y
    Form1.Picture7.ForeColor = 0
    For x = 0 To CurCI
        If CIs(0, x) < CIs(1, x) Then
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
        Else
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, 15
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
            
            MoveToEx Pict, 30 + Decompress(1) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, 15
        End If
    Next x
    Form1.Picture7.DrawWidth = 1
End If

BenHMM = 1

End Function
Public Function BenHMMF(HMMCycles, DrawPFlag, CurCI As Long, CIs() As Long, oSeq1, oSeq2, oSeq3)

Dim Pict As Long, YScaleFactor As Single, TotProb As Variant, MaxV As Variant, Z As Long, x As Long, Y As Long, Seq1 As Long, Seq2 As Long, Seq3 As Long, iVal As Single, Dummy As Long
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
If oSeq1 < oSeq2 And oSeq1 < oSeq3 Then
    Seq1 = oSeq1
    If oSeq2 < oSeq3 Then
        Seq2 = oSeq2
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq2
    End If
ElseIf oSeq2 < oSeq1 And oSeq2 < oSeq3 Then
    Seq1 = oSeq2
    If oSeq1 < oSeq3 Then
        Seq2 = oSeq1
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq1
    End If
    
ElseIf oSeq3 < oSeq1 And oSeq3 < oSeq2 Then
    Seq1 = oSeq3
    If oSeq1 < oSeq2 Then
        Seq2 = oSeq1
        Seq3 = oSeq2
    Else
        Seq2 = oSeq2
        Seq3 = oSeq1
    End If
End If

Dim RecodeB() As Byte, SLen As Long, Coffset As Long, Recode() As Byte

'recode the sequences into an ABC string

ReDim RecodeB(Len(StrainSeq(0)) * 2)


Y = 0
ReDim XPosDiff(Len(StrainSeq(0)) * 2), XDiffPos(Len(StrainSeq(0)) * 2)
'@
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, Seq1) <> 46 Then
        If SeqNum(x, Seq2) <> 46 Then
            If SeqNum(x, Seq3) <> 46 Then
                If SeqNum(x, Seq1) = SeqNum(x, Seq2) Then
                    If SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                        Y = Y + 1
                        RecodeB(Y - 1) = 0
                        XDiffPos(Y) = x
                        
                    End If
                ElseIf SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    
                    RecodeB(Y - 1) = 2
                    XDiffPos(Y) = x
                ElseIf SeqNum(x, Seq2) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    RecodeB(Y - 1) = 1
                    XDiffPos(Y) = x
                End If
            End If
        End If
    End If
    
    XPosDiff(x) = Y
Next x



If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    Coffset = CLng(Y / 2)
    Dim TXPD() As Long, TXDP() As Long, RB() As Byte, A As Long
    ReDim TXPD(Y * 2), TXDP(Y * 2), RB(Y + Coffset * 2)
    For A = 0 To Coffset - 1
    
        RB((Y + A + Coffset + 1)) = RecodeB(A) '1678-2237'0(2468)-821(3289)

    Next A
    For A = Coffset To Y - 1
        'TXPD(A - COffset) = XPosDiff(A)
        'TXDP(A - COffset) = XDiffPos(A)
        RB((A - Coffset)) = RecodeB(A) '822(0)-1644(822)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    For A = 0 To Y - 1
        'TXPD(A + COffset) = XPosDiff(A)
        'TXDP(A + COffset) = XDiffPos(A)
        RB((A + Coffset + 1)) = RecodeB(A) '1(823)-1644(2467)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    Y = Y + (Coffset) * 2
    SLen = Y
    For A = 0 To SLen
        'XPosDiff(A) = TXPD(A)
        'XDiffPos(A) = TXDP(A)
        RecodeB(A) = RB(A)
    
    Next A
    
    
Else
    SLen = Y
    Coffset = 0
End If


'Initialisation
'For X = 0 To 6
'    X = X
'    XX = RecodeB(X)
'Next X

Dim NumberXY As Long
Dim NumberABC As Long

NumberXY = 3
NumberABC = 3


Dim TransitionBak() As Single, EmissionBak() As Single, TransitionM2() As Single, EmissionM2() As Single, InitPBak() As Single, InitP() As Single, MaxP As Double, MinP As Double

ReDim TransitionM2(NumberXY - 1, NumberXY - 1), EmissionM2(NumberABC - 1, NumberXY - 1), InitP(NumberXY - 1)

Dim NumCycles As Long
Dim bestLike As Double




bestLike = -1000000
'Dim ImballancedSeq As Long
'For ImballancedSeq = 0 To 5

    'If ImballancedSeq = 0 Then
    'For X = 0 To SLen
    '    RecodeB(X) = SwapAround(ImballancedSeq, Recode(X))
    'Next X
    
   ' End If
    Rnd (-BSRndNumSeed)
    
    
    For NumCycles = 0 To HMMCycles '3.77 with polishbreaks off, 0 = 3.84, 5 = 4.17, 10 = 4.49, 20 = 5.6, 40 = 6.28, 80 = 8.64
        iVal = 5 / Len(StrainSeq(0))
        If NumberXY > 1 Then
            For x = 0 To NumberXY - 1
                For Y = 0 To NumberXY - 1
                    If x = Y Then
                        TransitionM2(x, Y) = Log(1 - iVal)
                    Else
                        TransitionM2(x, Y) = Log((iVal) / (NumberXY - 1))
                    End If
                    x = x
                Next Y
            Next x
        Else
            TransitionM2(0, 0) = Log(1)
        End If
        
        'Dim PosMaxP As Double, PosMax As Long
        
        'For X = 0 To NumberXY - 1
        '    PosMaxP = ((X + 1) / NumberABC) * (NumberABC) - 1
        '    PosMaxP = NumberABC - PosMaxP - 1 'CLng(PosMaxP) 'the value in the list that will be the maximum
        '    PosMax = PosMaxP
        '    MaxP = X / NumberXY
        '    MaxP = 0.8 'the value of the maximum
        '    MinP = (1 - MaxP) / (NumberABC - 1) 'the value of the minumum
        '    For Y = 0 To NumberABC - 1
        '
        '
        '        If Y = PosMax Then
        '            EmissionM2(Y, X) = Log(MaxP)
        '        Else
        '            EmissionM2(Y, X) = Log(MinP)
        '        End If
        '        X = X
        '    Next Y
        '    X = X
        'Next X
        
        Dim DoneImba() As Long, Imballance As Double, Imballance2 As Long
        
        'RNDSEED = RNDSEED + 1
        
        
        Imballance = (Int((NumberABC * Rnd) + 1)) / 10 '0.1,0.3
        'Imballance = 10 ^ -2
        If x = x Then
            ReDim DoneImba(NumberABC)
            For x = 0 To NumberXY - 1
                
                Do
                    
                    Imballance2 = Int(((NumberXY + 3) * Rnd)) - 2  '2,2,2,1,1,2,2,0,1,0,0,2,2,2,0,1,0,0,1,1,0,0,1
                    If Imballance2 >= 0 And Imballance2 < NumberXY Then '102,120,021,201,021,102
                        If DoneImba(Imballance2) = 0 Then
                            For Y = 0 To NumberABC - 1
                                If Y = Imballance2 Then
                                    EmissionM2(Y, x) = 1 / NumberABC + Imballance * 2
                                Else
                                    EmissionM2(Y, x) = 1 / NumberABC - Imballance
                                End If
                            Next Y
                            
                            DoneImba(Imballance2) = 1
                            Exit Do
                        End If
                    End If
                Loop
            Next x
        Else
            If NumberXY = 2 And NumberABC = 3 Then
                EmissionM2(0, 0) = 0.1
                EmissionM2(1, 0) = 0.1
                EmissionM2(2, 0) = 0.8
                EmissionM2(0, 1) = 0.6
                EmissionM2(1, 1) = 0.2
                EmissionM2(2, 1) = 0.2
            ElseIf NumberXY = 3 And NumberABC = 3 Then
                EmissionM2(0, 0) = 0.1
                EmissionM2(1, 0) = 0.1
                EmissionM2(2, 0) = 0.8
                EmissionM2(0, 1) = 0.15
                EmissionM2(1, 1) = 0.7
                EmissionM2(2, 1) = 0.15
                EmissionM2(0, 2) = 0.6
                EmissionM2(1, 2) = 0.2
                EmissionM2(2, 2) = 0.2
            End If
        End If
        
        For x = 0 To NumberXY - 1
        
            For Y = 0 To NumberABC - 1
                EmissionM2(Y, x) = Log(EmissionM2(Y, x))
                
            Next Y
        Next x
        
        ' 0.1 0.1 0.8
        ' 0.5 0.5 0.5
        '
        
        For x = 0 To NumberXY - 1
            InitP(x) = Log(1 / NumberXY)
        Next x
        
        'InitP(0) = Log(0.5)
        'InitP(1) = Log(0.5)
        
        Dim LaticePathBak() As Long, StateCount() As Single, TotCount As Single, TransitionCount() As Single, TotXY(), LaticeAB() As Single, LaticeXY() As Single, LaticePath() As Long, Fudge As Double, Maxiterations As Long, PathLike As Double, MaxL As Double, PathMax As Double
        ReDim LaticeXY(SLen, NumberXY - 1), LaticePath(SLen + 3)
        Fudge = 0.01
        
        Maxiterations = 100
'        XX = CurDir
        'viterbi training
        'Open "transition.csv" For Output As #1
        'Open "emission.csv" For Output As #2
        
        
    
        For A = 1 To Maxiterations
        
            Call ViterbiF(NumberABC, NumberXY, SLen, RecodeB(), LaticeXY(), LaticeAB(), TransitionM2(), EmissionM2(), InitP())
            
            
            Dim LastHigh As Byte
            
                '@
                MaxL = GetLaticePathPF(SLen, NumberXY, LaticeXY(0, 0), LaticeAB(0, 0), LaticePath(0))
            
            If PathMax = MaxL Then
                Exit For
            
            Else 'PathMax <> MaxL Then
                PathMax = MaxL
            
            End If
           
                       
             
            
            
            'update transition and emission matrices
            If NumberXY > 1 Then
                ReDim TotXY(NumberXY - 1)
                '
                ReDim TransitionCount(NumberXY - 1, NumberXY - 1)
                '
                ReDim StateCount(NumberABC - 1, NumberXY - 1)
                
    '            '@
                Dummy = UpdateCountsPF(SLen, NumberABC, NumberXY, LaticePath(0), RecodeB(0), TransitionCount(0, 0), StateCount(0, 0))
               '@
               For x = 0 To NumberXY - 1
                    TotCount = 0
                    For Y = 0 To NumberXY - 1
                        'TransitionM2(X, Y) = TransitionCount(X, Y)
                        TotCount = TotCount + TransitionCount(x, Y)
                    Next Y
                    TotCount = TotCount + (Fudge * NumberXY)
                    For Y = 0 To NumberXY - 1
                        TransitionCount(x, Y) = TransitionCount(x, Y) + Fudge
                        
                        TransitionM2(x, Y) = Log((TransitionCount(x, Y) / TotCount))
                        
                    Next Y
               Next x
                
                For Y = 0 To NumberXY - 1
                    TotCount = 0
                    For Z = 0 To NumberABC - 1
                        TotCount = TotCount + StateCount(Z, Y)
                    Next Z
                    TotCount = TotCount + (Fudge * NumberABC)
                    For Z = 0 To NumberABC - 1
                        
                        EmissionM2(Z, Y) = Log(((StateCount(Z, Y) + Fudge) / TotCount))
                       
                    Next Z
                    
                Next Y
            Else
                TransitionM2(0, 0) = Log(1)
            End If
            
        Next A
        
        If MaxL > bestLike Then '-1105, -1087,-1087, -1098,-1087
            'back up emmission and transition matrices
            bestLike = MaxL
            ReDim TransitionBak(NumberXY - 1, NumberXY - 1), EmissionBak(NumberABC - 1, NumberXY - 1), InitPBak(NumberXY - 1), LaticePathBak(SLen)
            For x = 0 To NumberXY - 1
                InitPBak(x) = InitP(x)
                For Y = 0 To NumberXY - 1
                    TransitionBak(x, Y) = TransitionM2(x, Y)
                Next Y
                For Y = 0 To NumberABC - 1
                    EmissionBak(Y, x) = EmissionM2(Y, x)
                Next Y
            Next x
            For x = 0 To SLen
                LaticePathBak(x) = LaticePath(x)
            Next x
        End If
    Next NumCycles
'Next ImballancedSeq

For x = 0 To NumberXY - 1
    InitP(x) = InitPBak(x)
    For Y = 0 To NumberXY - 1
        TransitionM2(x, Y) = TransitionBak(x, Y)
    Next Y
    For Y = 0 To NumberABC - 1
        EmissionM2(Y, x) = EmissionBak(Y, x)
    Next Y
    
Next x

For Y = 0 To SLen
    LaticePath(Y) = LaticePathBak(Y)
Next Y
MaxL = bestLike '-2804.014251443'-3061.432060
'Close #1
'Close #2
Dim MaxY As Double


Dim LaticeCD() As Single
ReDim LaticeCD(SLen, NumberXY - 1)

Call ForwardF(NumberABC, NumberXY, SLen, RecodeB(), LaticeCD(), TransitionM2(), EmissionM2(), InitP())

Dim LaticeEF() As Single
ReDim LaticeEF(SLen, NumberXY - 1)

Call ReverseF(NumberABC, NumberXY, SLen, RecodeB(), LaticeEF(), TransitionM2(), EmissionM2(), InitP())


Dim StateProb() As Double
ReDim StateProb(SLen, NumberXY)
'
For x = 0 To SLen
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = LaticeCD(x, Y) + LaticeEF(x, Y)
    Next Y
    MaxV = -10 ^ 22
    
    For Y = 0 To NumberXY - 1
        If MaxV < StateProb(x, Y) Then MaxV = StateProb(x, Y) '- 696.22904; -696.6417
        
    Next Y
    TotProb = 0
    
    For Y = 0 To NumberXY - 1
        
        StateProb(x, Y) = StateProb(x, Y) - MaxV
        StateProb(x, Y) = Exp(StateProb(x, Y))
        TotProb = TotProb + StateProb(x, Y)
        
    Next Y
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = StateProb(x, Y) / TotProb
        
    Next Y
    
Next x

MaxY = 0
For x = 1 To SLen
    For Y = 0 To NumberXY - 1
        If Abs(StateProb(x, Y)) > MaxY Then MaxY = Abs(StateProb(x, Y)) '8168;8649
    Next Y
Next x



LenXoverSeq = SLen

If SLen > 0 Then
    If CircularFlag = 1 Or ReassortmentFlag = 1 Then 'get rid of overlap
        For x = 0 To SLen / 2
            LaticePath(x) = LaticePath(x + Coffset + 1)
            For Y = 0 To NumberXY - 1
                StateProb(x, Y) = StateProb((x + Coffset + 1), Y)
            Next Y
        Next x
        SLen = SLen / 2
    End If
End If
    
Dim GoOn As Byte
ReDim CIs(5, 10)
CurCI = -1

If SLen = 0 Then Exit Function
If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    LaticePath(SLen - 1) = LaticePath(2)
    'LaticePath(SLen - 1) = LaticePath(1)
    'For Z = 0 To NumberXY - 1
    '    StateProb(SLen - 1, Z) = StateProb(1, Z)
    'Next Z
Else
    LaticePath(SLen - 1) = LaticePath(SLen - 2)
    'LaticePath(SLen + 1) = LaticePath(SLen)
End If
CurCI = 0
'If SEventNumber = 8 Then
'    X = X
'End If

'For X = 1 To SLen
'    If StateProb(X, 0) >= StateProb(X, 1) And StateProb(X, 0) >= StateProb(X, 2) Then
'        LaticePath(X) = 0
'    ElseIf StateProb(X, 1) >= StateProb(X, 0) And StateProb(X, 1) >= StateProb(X, 2) Then
'        LaticePath(X) = 1
'    ElseIf StateProb(X, 2) >= StateProb(X, 0) And StateProb(X, 2) >= StateProb(X, 1) Then
'        LaticePath(X) = 2
'    End If
'
'Next X


For x = 2 To SLen - 2
    
    If LaticePath(x) <> LaticePath(x + 1) Then 'breakpoint position found
        
        CurCI = CurCI + 1
        
        If CurCI > UBound(CIs, 2) Then
            ReDim Preserve CIs(5, CurCI + 10)
        End If
        If x < SLen - 2 Then '1937,1946:2202-2220
            CIs(2, CurCI) = (XDiffPos(x)) + ((XDiffPos(x + 1)) - (XDiffPos(x))) / 2
        Else
            CIs(2, CurCI) = (XDiffPos(x)) + ((Len(StrainSeq(0))) - (XDiffPos(x))) / 2
        End If
        'find left 99% (0) and 95% (3) CI
        If CIs(2, CurCI) < 0 Then CIs(2, CurCI) = 0
        CIs(3, CurCI) = 0
        CIs(4, CurCI) = 0
        For Y = x To -SLen Step -1
            If Y <= 0 Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y + SLen
                Else
                    CIs(0, CurCI) = 1
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(3, CurCI) = 0 Then
                    
                        If A > 1 Then
                            'If A < SLen Then
                            CIs(3, CurCI) = (XDiffPos(A - 1)) + 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                            'End If
                            
                        Else
                            CIs(3, CurCI) = 1 '(XDiffPos(A)) + 1 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                        End If
                    
                    End If
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A > 1 Then
                                CIs(0, CurCI) = (XDiffPos(A - 1)) + 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                                
                            Else
                                CIs(0, CurCI) = 1 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                            End If
                        GoOn = 0
                        Exit For
                    End If
                
                End If
                
            
            Next Z
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2227,2227
        'XX = SEventNumber
        'find right 99% (1) and 95% (4) CI
        
        For Y = x + 1 To SLen * 2
            If Y > SLen Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y - SLen
                Else
                    CIs(1, CurCI) = (Len(StrainSeq(0)))
                    CIs(4, CurCI) = (Len(StrainSeq(0)))
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(4, CurCI) = 0 Then
                    
                        If A < SLen - 1 Then
                            CIs(4, CurCI) = (XDiffPos(A + 1)) - 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                        Else
                            CIs(4, CurCI) = (Len(StrainSeq(0))) 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                            
                        End If
                   End If
                    
                    
               
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A < SLen - 1 Then
                                CIs(1, CurCI) = (XDiffPos(A + 1)) - 1 'CLng((XDiffPos(A)) + ((XDiffPos(A + 1)) - (XDiffPos(A))) / 2)
                            Else
                                CIs(1, CurCI) = (Len(StrainSeq(0))) 'CLng((XDiffPos(A)) + ((Len(StrainSeq(0))) - (XDiffPos(A))) / 2)
                                
                            End If
                       
                        GoOn = 0
                        Exit For
                    End If
                End If
            Next Z
            
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2277,2280
        x = x
    
        If CircularFlag = 1 Or ReassortmentFlag = 1 Then
            For Z = 0 To 4
                If Z <> 2 Then
                    If CIs(Z, CurCI) = 1 Or CIs(Z, CurCI) = (Len(StrainSeq(0))) Then
                        
                        
                        If Z = 1 Or Z = 4 Then
                            CIs(Z, CurCI) = (XDiffPos(1)) - 1
                            If CIs(Z, CurCI) < 1 Then CIs(Z, CurCI) = 1
                            'CIs(4) = (XDiffPos(1)) - 1
                        Else
                            
                            CIs(Z, CurCI) = (XDiffPos(SLen)) + 1
                            If CIs(Z, CurCI) > (Len(StrainSeq(0))) Then CIs(Z, CurCI) = (Len(StrainSeq(0)))
                            
                        End If
                    End If
                End If
            Next Z
        End If
        
        If CIs(3, CurCI) < CIs(4, CurCI) Then 'the 95% cis are unwrapped
            If CIs(2, CurCI) > CIs(3, CurCI) And CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = CIs(3, CurCI) + CLng((CIs(4, CurCI) - CIs(3, CurCI)) / 2)
            End If
        Else 'the 95% cis are wrapped
            If CIs(2, CurCI) > CIs(3, CurCI) Or CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = (CIs(3, CurCI) + ((Len(StrainSeq(0))) - CIs(4, CurCI))) / 2
                If CIs(2, CurCI) > (Len(StrainSeq(0))) Then CIs(2, CurCI) = CIs(2, CurCI) - (Len(StrainSeq(0)))
            End If
        
        End If
        
        
        
    End If
    

Next x




If x = 12345 Then
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.Picture = LoadPicture()
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Pict = Form1.Picture7.hdc
    XFactor = ((Form1.Picture7.Width - 40) / (Len(StrainSeq(0))))

Call DoAxes(0, 0, (Len(StrainSeq(0))), -1, CSng(MaxY), 0, 1, "P")
Dim PntAPI As POINTAPI
    
    
    
    
    Dim PHX As Long, RDPA As Single
    PHX = PicHeight - 35
    
'    SS = Abs(GetTickCount)
  
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        Form1.Picture7.ForeColor = RGB(128, 128, 128)
        Form1.Picture7.DrawWidth = 5
        'If Len(StrainSeq(0)) = (Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
            Dim YP As Long, XP As Long, OXP As Long
            Dim MaY As Long, MiY As Long
            MoveToEx Pict, 30 + (XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((LaticePath(1) / (NumberXY - 1))) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(LaticePath(x) / (NumberXY - 1)))) * (PicHeight - 35)))
                XP = 30 + (XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Form1.Picture7.DrawWidth = 1

        For Y = 0 To NumberXY - 1
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        'If Len(StrainSeq(0)) = (Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
           
            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((StateProb(1, Y)) / MaxY) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(StateProb(x - 1, Y)) / MaxY)) * (PicHeight - 35)))
                XP = 30 + Decompress(XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Next 'Y
    Form1.Picture7.ForeColor = 0
    For x = 0 To CurCI
        If CIs(0, x) < CIs(1, x) Then
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
        Else
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, 15
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
            
            MoveToEx Pict, 30 + Decompress(1) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, 15
        End If
    Next x
    Form1.Picture7.DrawWidth = 1
End If

BenHMMF = 1

End Function
Public Function BenHMM3(HMMCycles, DrawPFlag, CurCI As Long, CIs() As Long, oSeq1, oSeq2, oSeq3)

Dim Pict As Long, YScaleFactor As Single, TotProb As Variant, MaxV As Variant, Z As Long, x As Long, Y As Long, Seq1 As Long, Seq2 As Long, Seq3 As Long, iVal As Single, Dummy As Long
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
If oSeq1 < oSeq2 And oSeq1 < oSeq3 Then
    Seq1 = oSeq1
    If oSeq2 < oSeq3 Then
        Seq2 = oSeq2
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq2
    End If
ElseIf oSeq2 < oSeq1 And oSeq2 < oSeq3 Then
    Seq1 = oSeq2
    If oSeq1 < oSeq3 Then
        Seq2 = oSeq1
        Seq3 = oSeq3
    Else
        Seq2 = oSeq3
        Seq3 = oSeq1
    End If
    
ElseIf oSeq3 < oSeq1 And oSeq3 < oSeq2 Then
    Seq1 = oSeq3
    If oSeq1 < oSeq2 Then
        Seq2 = oSeq1
        Seq3 = oSeq2
    Else
        Seq2 = oSeq2
        Seq3 = oSeq1
    End If
End If

Dim RecodeB() As Byte, SLen As Long, Coffset As Long, Recode() As Byte

'recode the sequences into an ABC string

ReDim RecodeB(Len(StrainSeq(0)) * 2)


Y = 0
ReDim XPosDiff(Len(StrainSeq(0)) * 2), XDiffPos(Len(StrainSeq(0)) * 2)

For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, Seq1) <> 46 Then
        If SeqNum(x, Seq2) <> 46 Then
            If SeqNum(x, Seq3) <> 46 Then
                If SeqNum(x, Seq1) = SeqNum(x, Seq2) Then
                    If SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                        Y = Y + 1
                        RecodeB(Y - 1) = 0
                        XDiffPos(Y) = x
                        
                    End If
                ElseIf SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    
                    RecodeB(Y - 1) = 2
                    XDiffPos(Y) = x
                ElseIf SeqNum(x, Seq2) = SeqNum(x, Seq3) Then
                    Y = Y + 1
                    RecodeB(Y - 1) = 1
                    XDiffPos(Y) = x
                End If
            End If
        End If
    End If
    
    XPosDiff(x) = Y
Next x



If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    Coffset = CLng(Y / 2)
    Dim TXPD() As Long, TXDP() As Long, RB() As Byte, A As Long
    ReDim TXPD(Y * 2), TXDP(Y * 2), RB(Y + Coffset * 2)
    For A = 0 To Coffset - 1
    
        RB((Y + A + Coffset + 1)) = RecodeB(A) '1678-2237'0(2468)-821(3289)

    Next A
    For A = Coffset To Y - 1
        'TXPD(A - COffset) = XPosDiff(A)
        'TXDP(A - COffset) = XDiffPos(A)
        RB((A - Coffset)) = RecodeB(A) '822(0)-1644(822)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    For A = 0 To Y - 1
        'TXPD(A + COffset) = XPosDiff(A)
        'TXDP(A + COffset) = XDiffPos(A)
        RB((A + Coffset + 1)) = RecodeB(A) '1(823)-1644(2467)
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    Y = Y + (Coffset) * 2
    SLen = Y
    For A = 0 To SLen
        'XPosDiff(A) = TXPD(A)
        'XDiffPos(A) = TXDP(A)
        RecodeB(A) = RB(A)
    
    Next A
    
    
Else
    SLen = Y
    Coffset = 0
End If


'Initialisation
'For X = 0 To 6
'    X = X
'    XX = RecodeB(X)
'Next X

Dim NumberXY As Long
Dim NumberABC As Long

NumberXY = 3
NumberABC = 3


Dim TransitionBak() As Double, EmissionBak() As Double, TransitionM2() As Double, EmissionM2() As Double, InitPBak() As Double, InitP() As Double, MaxP As Double, MinP As Double
ReDim TransitionM2(NumberXY - 1, NumberXY - 1), EmissionM2(NumberABC - 1, NumberXY - 1), InitP(NumberXY - 1)

Dim NumCycles As Long
Dim bestLike As Double




bestLike = -1000000
'Dim ImballancedSeq As Long
'For ImballancedSeq = 0 To 5

    'If ImballancedSeq = 0 Then
    'For X = 0 To SLen
    '    RecodeB(X) = SwapAround(ImballancedSeq, Recode(X))
    'Next X
    
   ' End If
    Rnd (-BSRndNumSeed)
    For NumCycles = 0 To HMMCycles '3.77 with polishbreaks off, 0 = 3.84, 5 = 4.17, 10 = 4.49, 20 = 5.6, 40 = 6.28, 80 = 8.64
        iVal = 5 / Len(StrainSeq(0))
        If NumberXY > 1 Then
            For x = 0 To NumberXY - 1
                For Y = 0 To NumberXY - 1
                    If x = Y Then
                        TransitionM2(x, Y) = Log(1 - iVal)
                    Else
                        TransitionM2(x, Y) = Log((iVal) / (NumberXY - 1))
                    End If
                    x = x
                Next Y
            Next x
        Else
            TransitionM2(0, 0) = Log(1)
        End If
        
        'Dim PosMaxP As Double, PosMax As Long
        
        'For X = 0 To NumberXY - 1
        '    PosMaxP = ((X + 1) / NumberABC) * (NumberABC) - 1
        '    PosMaxP = NumberABC - PosMaxP - 1 'CLng(PosMaxP) 'the value in the list that will be the maximum
        '    PosMax = PosMaxP
        '    MaxP = X / NumberXY
        '    MaxP = 0.8 'the value of the maximum
        '    MinP = (1 - MaxP) / (NumberABC - 1) 'the value of the minumum
        '    For Y = 0 To NumberABC - 1
        '
        '
        '        If Y = PosMax Then
        '            EmissionM2(Y, X) = Log(MaxP)
        '        Else
        '            EmissionM2(Y, X) = Log(MinP)
        '        End If
        '        X = X
        '    Next Y
        '    X = X
        'Next X
        
        Dim DoneImba() As Long, Imballance As Double, Imballance2 As Long
        
        'RNDSEED = RNDSEED + 1
        
        
        Imballance = (Int((NumberABC * Rnd) + 1)) / 10 '0.1,0.3
        'Imballance = 10 ^ -2
        If x = x Then
            ReDim DoneImba(NumberABC)
            For x = 0 To NumberXY - 1
                
                Do
                    
                    Imballance2 = Int(((NumberXY + 3) * Rnd)) - 2  '2,2,2,1,1,2,2,0,1,0,0,2,2,2,0,1,0,0,1,1,0,0,1
                    If Imballance2 >= 0 And Imballance2 < NumberXY Then '102,120,021,201,021,102
                        If DoneImba(Imballance2) = 0 Then
                            For Y = 0 To NumberABC - 1
                                If Y = Imballance2 Then
                                    EmissionM2(Y, x) = 1 / NumberABC + Imballance * 2
                                Else
                                    EmissionM2(Y, x) = 1 / NumberABC - Imballance
                                End If
                            Next Y
                            
                            DoneImba(Imballance2) = 1
                            Exit Do
                        End If
                    End If
                Loop
            Next x
        Else
            If NumberXY = 2 And NumberABC = 3 Then
                EmissionM2(0, 0) = 0.1
                EmissionM2(1, 0) = 0.1
                EmissionM2(2, 0) = 0.8
                EmissionM2(0, 1) = 0.6
                EmissionM2(1, 1) = 0.2
                EmissionM2(2, 1) = 0.2
            ElseIf NumberXY = 3 And NumberABC = 3 Then
                EmissionM2(0, 0) = 0.1
                EmissionM2(1, 0) = 0.1
                EmissionM2(2, 0) = 0.8
                EmissionM2(0, 1) = 0.15
                EmissionM2(1, 1) = 0.7
                EmissionM2(2, 1) = 0.15
                EmissionM2(0, 2) = 0.6
                EmissionM2(1, 2) = 0.2
                EmissionM2(2, 2) = 0.2
            End If
        End If
        
        For x = 0 To NumberXY - 1
        
            For Y = 0 To NumberABC - 1
                EmissionM2(Y, x) = Log(EmissionM2(Y, x))
                
            Next Y
        Next x
        
        ' 0.1 0.1 0.8
        ' 0.5 0.5 0.5
        '
        
        For x = 0 To NumberXY - 1
            InitP(x) = Log(1 / NumberXY)
        Next x
        
        'InitP(0) = Log(0.5)
        'InitP(1) = Log(0.5)
        
        Dim LaticePathBak() As Long, StateCount() As Double, TotCount As Double, TransitionCount() As Double, TotXY(), LaticeAB() As Double, LaticeXY() As Double, LaticePath() As Long, Fudge As Double, Maxiterations As Long, PathLike As Double, MaxL As Double, PathMax As Double
        ReDim LaticeXY(SLen, NumberXY - 1), LaticePath(SLen + 3)
        Fudge = 0.01
        
        Maxiterations = 100
'        XX = CurDir
        'viterbi training
        'Open "transition.csv" For Output As #1
        'Open "emission.csv" For Output As #2
        
        
    
        For A = 1 To Maxiterations
           ' If X = X Then
               ' Print #1, CStr(Exp(TransitionM2(0, 0))) + "," + CStr(Exp(TransitionM2(0, 1))) + "," + CStr(Exp(TransitionM2(0, 2))) + "," + CStr(Exp(TransitionM2(1, 0))) + CStr(Exp(TransitionM2(1, 1))) + "," + CStr(Exp(TransitionM2(1, 2))) + "," + CStr(Exp(TransitionM2(2, 0))) + CStr(Exp(TransitionM2(2, 1))) + "," + CStr(Exp(TransitionM2(2, 2)))
               ' Print #2, CStr(Exp(EmissionM2(0, 0))) + "," + CStr(Exp(EmissionM2(0, 1))) + "," + CStr(Exp(EmissionM2(0, 2))) + "," + CStr(Exp(EmissionM2(1, 0))) + "," + CStr(Exp(EmissionM2(1, 1))) + "," + CStr(Exp(EmissionM2(1, 2))) + "," + CStr(Exp(EmissionM2(2, 0))) + "," + CStr(Exp(EmissionM2(2, 1))) + "," + CStr(Exp(EmissionM2(2, 2)))
            
           ' End If
        
        
            Call Viterbi(NumberABC, NumberXY, SLen, RecodeB(), LaticeXY(), LaticeAB(), TransitionM2(), EmissionM2(), InitP())
            
            
            Dim LastHigh As Byte
            
    '        If X = X Then
                '
                MaxL = GetLaticePathP(SLen, NumberXY, LaticeXY(0, 0), LaticeAB(0, 0), LaticePath(0))
                'X = X
    '        Else
    '
    '            MaxL = -1E+22
    '
    '
    '            For Y = 0 To NumberXY - 1
    '
    '                If LaticeXY(SLen, Y) > MaxL Then
    '                    MaxL = LaticeXY(SLen, Y)
    '                    LaticePath(SLen) = LaticeAB(SLen, Y)
    '
    '                End If
    '
    '            Next Y
    '
    '            For X = SLen - 1 To 0 Step -1
    '                For Y = 0 To NumberXY - 1
    '                    'If LaticeXY(SLen, Y) > MaxL Then
    '
    '                        LaticePath(X) = LaticeAB(X, LaticePath(X + 1))
    '
    '                    'End If
    '                Next Y
    '            Next X
    '
    '        End If
            
            If PathMax = MaxL Then
                Exit For
            
            Else 'PathMax <> MaxL Then
                PathMax = MaxL
            
            End If
           
                       
             
            
            
            'update transition and emission matrices
            If NumberXY > 1 Then
                ReDim TotXY(NumberXY - 1)
                '
                ReDim TransitionCount(NumberXY - 1, NumberXY - 1)
                '
                ReDim StateCount(NumberABC - 1, NumberXY - 1)
                
    '            If X = X Then
                    Dummy = UpdateCountsP(SLen, NumberABC, NumberXY, LaticePath(0), RecodeB(0), TransitionCount(0, 0), StateCount(0, 0))
    '            Else
    '                For Z = 0 To SLen - 1
    '                    TransitionCount(LaticePath(Z), LaticePath(Z + 1)) = TransitionCount(LaticePath(Z), LaticePath(Z + 1)) + 1
    '                    X = X
    '                    'StateCount(RecodeB(Z), LaticePath(Z)) = StateCount(RecodeB(Z), LaticePath(Z)) + 1
    '                Next Z
    '                For Z = 0 To SLen
    '                    StateCount(RecodeB(Z), LaticePath(Z)) = StateCount(RecodeB(Z), LaticePath(Z)) + 1
    '                Next Z
    '            End If
                
               '
               For x = 0 To NumberXY - 1
                    TotCount = 0
                    For Y = 0 To NumberXY - 1
                        'TransitionM2(X, Y) = TransitionCount(X, Y)
                        TotCount = TotCount + TransitionCount(x, Y)
                    Next Y
                    TotCount = TotCount + (Fudge * NumberXY)
                    For Y = 0 To NumberXY - 1
                        TransitionCount(x, Y) = TransitionCount(x, Y) + Fudge
                        
                        TransitionM2(x, Y) = Log((TransitionCount(x, Y) / TotCount))
                        
                    Next Y
               Next x
                
                For Y = 0 To NumberXY - 1
                    TotCount = 0
                    For Z = 0 To NumberABC - 1
                        TotCount = TotCount + StateCount(Z, Y)
                    Next Z
                    TotCount = TotCount + (Fudge * NumberABC)
                    For Z = 0 To NumberABC - 1
                        
                        EmissionM2(Z, Y) = Log(((StateCount(Z, Y) + Fudge) / TotCount))
                       
                    Next Z
                    
                Next Y
            Else
                TransitionM2(0, 0) = Log(1)
            End If
            
        Next A
        
        If MaxL > bestLike Then '-1105, -1087,-1087, -1098,-1087
            'back up emmission and transition matrices
            bestLike = MaxL
            ReDim TransitionBak(NumberXY - 1, NumberXY - 1), EmissionBak(NumberABC - 1, NumberXY - 1), InitPBak(NumberXY - 1), LaticePathBak(SLen)
            For x = 0 To NumberXY - 1
                InitPBak(x) = InitP(x)
                For Y = 0 To NumberXY - 1
                    TransitionBak(x, Y) = TransitionM2(x, Y)
                Next Y
                For Y = 0 To NumberABC - 1
                    EmissionBak(Y, x) = EmissionM2(Y, x)
                Next Y
            Next x
            For x = 0 To SLen
                LaticePathBak(x) = LaticePath(x)
            Next x
        End If
    Next NumCycles
'Next ImballancedSeq

For x = 0 To NumberXY - 1
    InitP(x) = InitPBak(x)
    For Y = 0 To NumberXY - 1
        TransitionM2(x, Y) = TransitionBak(x, Y)
    Next Y
    For Y = 0 To NumberABC - 1
        EmissionM2(Y, x) = EmissionBak(Y, x)
    Next Y
    
Next x

For Y = 0 To SLen
    LaticePath(Y) = LaticePathBak(Y)
Next Y
MaxL = bestLike '-2804.014251443'-3061.432060
'Close #1
'Close #2
Dim MaxY As Double


Dim LaticeCD() As Double
ReDim LaticeCD(SLen, NumberXY - 1)

Call Forward(NumberABC, NumberXY, SLen, RecodeB(), LaticeCD(), TransitionM2(), EmissionM2(), InitP())

Dim LaticeEF() As Double
ReDim LaticeEF(SLen, NumberXY - 1)

Call Reverse(NumberABC, NumberXY, SLen, RecodeB(), LaticeEF(), TransitionM2(), EmissionM2(), InitP())


Dim StateProb() As Double, LikeDist() As Double

ReDim StateProb(SLen, NumberXY), LikeDist(SLen, NumberXY)
'
For x = 0 To SLen
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = LaticeCD(x, Y) + LaticeEF(x, Y)
    Next Y
    MaxV = -10 ^ 22
    
    For Y = 0 To NumberXY - 1
        If MaxV < StateProb(x, Y) Then MaxV = StateProb(x, Y) '- 696.22904; -696.6417
        
    Next Y
    TotProb = 0
    
    For Y = 0 To NumberXY - 1
        
        LikeDist(x, Y) = StateProb(x, Y) - MaxV
        StateProb(x, Y) = Exp(LikeDist(x, Y))
        TotProb = TotProb + StateProb(x, Y)
        
    Next Y
    For Y = 0 To NumberXY - 1
        StateProb(x, Y) = StateProb(x, Y) / TotProb
        
    Next Y
    
Next x

MaxY = 0
For x = 1 To SLen
    For Y = 0 To NumberXY - 1
        If Abs(StateProb(x, Y)) > MaxY Then MaxY = Abs(StateProb(x, Y)) '8168;8649
    Next Y
Next x



LenXoverSeq = SLen

If SLen > 0 Then
    If CircularFlag = 1 Or ReassortmentFlag = 1 Then 'get rid of overlap
        For x = 0 To SLen / 2
            LaticePath(x) = LaticePath(x + Coffset + 1)
            For Y = 0 To NumberXY - 1
                StateProb(x, Y) = StateProb((x + Coffset + 1), Y)
            Next Y
        Next x
        SLen = SLen / 2
    End If
End If
    
Dim GoOn As Byte
ReDim CIs(5, 10)
CurCI = -1

If SLen = 0 Then Exit Function
If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    LaticePath(SLen - 1) = LaticePath(2)
    'LaticePath(SLen - 1) = LaticePath(1)
    'For Z = 0 To NumberXY - 1
    '    StateProb(SLen - 1, Z) = StateProb(1, Z)
    'Next Z
Else
    LaticePath(SLen - 1) = LaticePath(SLen - 2)
    'LaticePath(SLen + 1) = LaticePath(SLen)
End If
CurCI = 0
'If SEventNumber = 8 Then
'    X = X
'End If

'For X = 1 To SLen
'    If StateProb(X, 0) >= StateProb(X, 1) And StateProb(X, 0) >= StateProb(X, 2) Then
'        LaticePath(X) = 0
'    ElseIf StateProb(X, 1) >= StateProb(X, 0) And StateProb(X, 1) >= StateProb(X, 2) Then
'        LaticePath(X) = 1
'    ElseIf StateProb(X, 2) >= StateProb(X, 0) And StateProb(X, 2) >= StateProb(X, 1) Then
'        LaticePath(X) = 2
'    End If
'
'Next X


For x = 2 To SLen - 2
    
    If LaticePath(x) <> LaticePath(x + 1) Then 'breakpoint position found
        For AA = 2 To SLen
'            If LikeDist(AA, 0) = 0 Then '0 - 855;875-1173;1190-1224:1247-1621:1657-1792:1815-1865:1929-1948:1954-2028:2071-2435:2444-3005:3035-
'                X = X
'            End If
'            XX = LikeDist(AA, 0) '-11.7,-12.1, -14.1, -12.1, -11.7, -11.6, -11.7, -11.8, -12.1, -13.9, -12.1, -11.7, -11.54
'            XX = LikeDist(AA, 1) '0,0,0,0,0,0,0,0,0,0
'            XX = LikeDist(AA, 2) '-16.6,-14.1,-10.4,-14.1, -16.6, -16.9, -16.9, -16.6, -14.1, -10.4, -14.1, -16.6, -16.95
'            XX = LikeDist(AA, 3) '0,0,0,0,0,0,0,0,0,0
        Next AA
        CurCI = CurCI + 1
        
        If CurCI > UBound(CIs, 2) Then
            ReDim Preserve CIs(5, CurCI + 10)
        End If
        If x < SLen - 2 Then '1937,1946:2202-2220
            CIs(2, CurCI) = Decompress(XDiffPos(x)) + (Decompress(XDiffPos(x + 1)) - Decompress(XDiffPos(x))) / 2
        Else
            CIs(2, CurCI) = Decompress(XDiffPos(x)) + (Decompress(Len(StrainSeq(0))) - Decompress(XDiffPos(x))) / 2
        End If
        'find left 99% (0) and 95% (3) CI
        If CIs(2, CurCI) < 0 Then CIs(2, CurCI) = 0
        CIs(3, CurCI) = 0
        CIs(4, CurCI) = 0
        For Y = x To -SLen Step -1
            If Y <= 0 Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y + SLen
                Else
                    CIs(0, CurCI) = 1
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(3, CurCI) = 0 Then
                    
                        If A > 1 Then
                            'If A < SLen Then
                            CIs(3, CurCI) = Decompress(XDiffPos(A - 1)) + 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                            'End If
                            
                        Else
                            CIs(3, CurCI) = 1 'Decompress(XDiffPos(A)) + 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(Len(StrainSeq(0))) - Decompress(XDiffPos(A))) / 2)
                        End If
                    
                    End If
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A > 1 Then
                                CIs(0, CurCI) = Decompress(XDiffPos(A - 1)) + 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                                
                            Else
                                CIs(0, CurCI) = 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(Len(StrainSeq(0))) - Decompress(XDiffPos(A))) / 2)
                            End If
                        GoOn = 0
                        Exit For
                    End If
                
                End If
                
            
            Next Z
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2227,2227
        'XX = SEventNumber
        'find right 99% (1) and 95% (4) CI
        
        For Y = x + 1 To SLen * 2
            If Y > SLen Then
                If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                    A = Y - SLen
                Else
                    CIs(1, CurCI) = Decompress(Len(StrainSeq(0)))
                    CIs(4, CurCI) = Decompress(Len(StrainSeq(0)))
                    Exit For
                End If
            Else
                A = Y
            End If
            GoOn = 1
            For Z = 0 To NumberXY - 1
                If StateProb(A, Z) > 0.995 Then
                    If CIs(4, CurCI) = 0 Then
                    
                        If A < SLen - 1 Then
                            CIs(4, CurCI) = Decompress(XDiffPos(A + 1)) - 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                        Else
                            CIs(4, CurCI) = Decompress(Len(StrainSeq(0))) 'CLng(Decompress(XDiffPos(A)) + (Decompress(Len(StrainSeq(0))) - Decompress(XDiffPos(A))) / 2)
                            
                        End If
                   End If
                    
                    
               
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A < SLen - 1 Then
                                CIs(1, CurCI) = Decompress(XDiffPos(A + 1)) - 1 'CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                            Else
                                CIs(1, CurCI) = Decompress(Len(StrainSeq(0))) 'CLng(Decompress(XDiffPos(A)) + (Decompress(Len(StrainSeq(0))) - Decompress(XDiffPos(A))) / 2)
                                
                            End If
                       
                        GoOn = 0
                        Exit For
                    End If
                End If
            Next Z
            
            If GoOn = 0 Then Exit For
            
            
        Next Y
        '2277,2280
        x = x
    
        If CircularFlag = 1 Or ReassortmentFlag = 1 Then
            For Z = 0 To 4
                If Z <> 2 Then
                    If CIs(Z, CurCI) = 1 Or CIs(Z, CurCI) = Decompress(Len(StrainSeq(0))) Then
                        
                        
                        If Z = 1 Or Z = 4 Then
                            CIs(Z, CurCI) = Decompress(XDiffPos(1)) - 1
                            If CIs(Z, CurCI) < 1 Then CIs(Z, CurCI) = 1
                            'CIs(4) = Decompress(XDiffPos(1)) - 1
                        Else
                            
                            CIs(Z, CurCI) = Decompress(XDiffPos(SLen)) + 1
                            If CIs(Z, CurCI) > Decompress(Len(StrainSeq(0))) Then CIs(Z, CurCI) = Decompress(Len(StrainSeq(0)))
                            
                        End If
                    End If
                End If
            Next Z
        End If
        
        If CIs(3, CurCI) < CIs(4, CurCI) Then 'the 95% cis are unwrapped
            If CIs(2, CurCI) > CIs(3, CurCI) And CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = CIs(3, CurCI) + CLng((CIs(4, CurCI) - CIs(3, CurCI)) / 2)
            End If
        Else 'the 95% cis are wrapped
            If CIs(2, CurCI) > CIs(3, CurCI) Or CIs(2, CurCI) < CIs(4, CurCI) Then 'the breakpoint is where it should be
                
            Else 'the breakpoint is not where it should be
                'place it in the middle of the cis
                CIs(2, CurCI) = (CIs(3, CurCI) + (Decompress(Len(StrainSeq(0))) - CIs(4, CurCI))) / 2
                If CIs(2, CurCI) > Decompress(Len(StrainSeq(0))) Then CIs(2, CurCI) = CIs(2, CurCI) - Decompress(Len(StrainSeq(0)))
            End If
        
        End If
        
        
        
    End If
    

Next x




If x = 12345 Then
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.Picture = LoadPicture()
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Pict = Form1.Picture7.hdc
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))

Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxY), 0, 1, "P")
Dim PntAPI As POINTAPI
    
    
    
    
    Dim PHX As Long, RDPA As Single
    PHX = PicHeight - 35
    
'    SS = Abs(GetTickCount)
  
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        Form1.Picture7.ForeColor = RGB(128, 128, 128)
        Form1.Picture7.DrawWidth = 5
        'If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
            Dim YP As Long, XP As Long, OXP As Long
            Dim MaY As Long, MiY As Long
            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((LaticePath(1) / (NumberXY - 1))) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(LaticePath(x) / (NumberXY - 1)))) * (PicHeight - 35)))
                XP = 30 + Decompress(XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Form1.Picture7.DrawWidth = 1

        For Y = 0 To NumberXY - 1
        Pict = Form1.Picture7.hdc
        
        If Y = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf Y = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If
        
        'If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
        '
        'Else
           
            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * XFactor, PicHeight - (15 + Abs((StateProb(1, Y)) / MaxY) * (PicHeight - 35)), PntAPI
            OXP = 0
            For x = 2 To SLen
                YP = PicHeight - ((15 + ((Abs(StateProb(x - 1, Y)) / MaxY)) * (PicHeight - 35)))
                XP = 30 + Decompress(XDiffPos(x - 1)) * XFactor + XFactor
                If OXP <> XP Then
                    MiY = 10000
                    MaY = 0
                End If
                OXP = XP
                If YP > MaY Or YP < MiY Then
                    LineTo Pict, XP, YP
                    If YP > MaY Then MaY = YP
                    If YP < MiY Then MiY = YP
                End If
            Next 'X
        'End If
    Next 'Y
    Form1.Picture7.ForeColor = 0
    For x = 0 To CurCI
        If CIs(0, x) < CIs(1, x) Then
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
        Else
            MoveToEx Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, 15
            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(CIs(0, x)) * XFactor, 15
            
            MoveToEx Pict, 30 + Decompress(1) * XFactor, 15, PntAPI
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, 15
            LineTo Pict, 30 + Decompress(CIs(1, x)) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, PicHeight - 15
            LineTo Pict, 30 + Decompress(1) * XFactor, 15
        End If
    Next x
    Form1.Picture7.DrawWidth = 1
End If

BenHMM3 = 1

End Function

Public Sub AddBreakBounds(SLen As Long, BPProbDistSE As Long, LaticePath() As Long, BPProbDist() As Single, BPosX As Long, EPosX As Long, XPosDiff() As Long, Coffset As Long)
Dim x As Long, Y As Long, Minv As Single, WinPosA As Long, WinPosB As Long, WinPosC As Long, WinPosD As Long, MaxB As Long, TargetPos As Long, SLenMod As Single

'If x = x Then
'    If BPCIs(0, BPProbDistSE) > 0 Then
'        WinPosA = XPosDiff(BPCIs(0, BPProbDistSE)) + Coffset
'        WinPosB = XPosDiff(BPCIs(1, BPProbDistSE)) + Coffset
'    End If
'    If BPCIs(3, BPProbDistSE) > 0 Then
'        WinPosC = XPosDiff(BPCIs(3, BPProbDistSE)) + Coffset
'        WinPosD = XPosDiff(BPCIs(4, BPProbDistSE)) + Coffset
'    End If
'    x = x
'Else 'dynamically determine the beradth of the distribution

'If CircularFlag = 1 Then
'    For x = 1 To SLen - Coffset * 2
'        If BPProbDist(x, BPProbDistSE) < BPProbDist(x + Coffset * 2, BPProbDistSE) Then
'            BPProbDist(x, BPProbDistSE) = BPProbDist(x + Coffset * 2, BPProbDistSE)
'        Else
'            BPProbDist(x + Coffset * 2, BPProbDistSE) = BPProbDist(x, BPProbDistSE)
'        End If
'    Next x
'End If

If BPCIs(0, BPProbDistSE) > UBound(XPosDiff, 1) Or BPCIs(1, BPProbDistSE) > UBound(XPosDiff, 1) Then
    WinPosA = 0
    WinPosB = 0
Else
If BPCIs(0, BPProbDistSE) > 0 Then
        WinPosA = XPosDiff(BPCIs(0, BPProbDistSE)) + Coffset
        WinPosB = XPosDiff(BPCIs(1, BPProbDistSE)) + Coffset
        x = x
Else
    If CircularFlag = 1 Then
        SLenMod = SLen * 0.75
    Else
        SLenMod = SLen
    End If
    If BPosX > 0 And EPosX > 0 Then
        If BPosX < EPosX Then
            MaxB = (EPosX - BPosX) / 2
        Else
            MaxB = (EPosX + SLen - BPosX) / 2
            MaxB = MaxB / 2
            x = x
        End If
    ElseIf BPosX > 0 Then
       ' If CircularFlag = 0 Then
            If BPosX > SLen / 2 Then
                MaxB = (SLen - BPosX) / 2
            Else
                MaxB = BPosX / 2
            End If
    '    Else
    '        If BPosX < EPosX Then
    '            MaxB = (EPosX - BPosX) / 2
    '        Else
    '            MaxB = (EPosX + SLen - BPosX) / 2
    '            MaxB = MaxB / 2
    '            x = x
    '        End If
    '    End If
    ElseIf EPosX > 0 Then
        If EPosX > SLen / 2 Then
            MaxB = (SLen - EPosX) / 2
        Else
            MaxB = EPosX / 2
        End If
    End If
    '427 for both breakpoints
    '444 for ending on its own
    '410 for beginning on its own
    If BPosX > -1 Then
        'BPProbDist(BPosX, BPProbDistSE) = 2
        Minv = 50
        If BPosX - MaxB > 1 Then
            Target = BPosX - MaxB
        Else
            Target = 1
        End If
        For x = BPosX To Target Step -1
            If BPProbDist(x, BPProbDistSE) < Minv Then
                Minv = BPProbDist(x, BPProbDistSE) '0.17-1008
                WinPosA = x
                
            End If
            If BPosX - x > 4 And LaticePath(x - 1) <> LaticePath(x) Then
                Exit For
            End If
        Next x
        Minv = 50
        If BPosX + MaxB < SLen - 2 Then
            Target = BPosX + MaxB
        Else
            Target = SLen - 2
        End If
        For x = BPosX To Target
            If BPProbDist(x, BPProbDistSE) < Minv Then
                Minv = BPProbDist(x, BPProbDistSE)
                WinPosB = x
                
            End If
            If x - BPosX > 4 And LaticePath(x + 2) <> LaticePath(x + 1) Then
                Exit For
            End If
        Next x
    End If
End If
End If


If BPCIs(3, BPProbDistSE) > UBound(XPosDiff, 1) Or BPCIs(4, BPProbDistSE) > UBound(XPosDiff, 1) Then
    WinPosC = 0
    WinPosD = 0
Else
If BPCIs(3, BPProbDistSE) > 0 Then
    WinPosC = XPosDiff(BPCIs(3, BPProbDistSE)) + Coffset
    WinPosD = XPosDiff(BPCIs(4, BPProbDistSE)) + Coffset
Else
    If CircularFlag = 1 Then
        SLenMod = SLen * 0.75
    Else
        SLenMod = SLen
    End If
    If BPosX > 0 And EPosX > 0 Then
        If BPosX < EPosX Then
            MaxB = (EPosX - BPosX) / 2
        Else
            MaxB = (EPosX + SLen - BPosX) / 2
            MaxB = MaxB / 2
            x = x
        End If
    ElseIf BPosX > 0 Then
       ' If CircularFlag = 0 Then
            If BPosX > SLen / 2 Then
                MaxB = (SLen - BPosX) / 2
            Else
                MaxB = BPosX / 2
            End If
    '    Else
    '        If BPosX < EPosX Then
    '            MaxB = (EPosX - BPosX) / 2
    '        Else
    '            MaxB = (EPosX + SLen - BPosX) / 2
    '            MaxB = MaxB / 2
    '            x = x
    '        End If
    '    End If
    ElseIf EPosX > 0 Then
        If EPosX > SLen / 2 Then
            MaxB = (SLen - EPosX) / 2
        Else
            MaxB = EPosX / 2
        End If
    End If
    If EPosX > -1 Then
        'BPProbDist(EPosX, BPProbDistSE) = 2
        Minv = 50
        If EPosX - MaxB > 1 Then
            Target = EPosX - MaxB
        Else
            Target = 1
        End If
        For x = EPosX To Target Step -1
            If BPProbDist(x, BPProbDistSE) < Minv Then
                Minv = BPProbDist(x, BPProbDistSE) '0.006 : 1063-
                WinPosC = x
                
            End If
            If EPosX - x > 4 And LaticePath(x - 1) <> LaticePath(x) Then
                Exit For
            End If
        Next x
        Minv = 50
        If EPosX + MaxB < SLen - 2 Then
            Target = EPosX + MaxB
        Else
            Target = SLen - 2
        End If
        For x = EPosX To Target
            If BPProbDist(x, BPProbDistSE) < Minv Then '1064 -0.5
                Minv = BPProbDist(x, BPProbDistSE)
                WinPosD = x
                
            End If
            If x - EPosX > 4 And LaticePath(x + 2) <> LaticePath(x + 1) Then
                Exit For
            End If
        Next x
    End If
End If
End If
XX = BPosX
XX = EPosX
XX = WinPosA
XX = WinPosB
XX = WinPosC
XX = WinPosD
Dim tProbdist() As Single
ReDim tProbdist(UBound(BPProbDist, 1))
If WinPosA > 0 Or WinPosB > 0 Then
    If BPosX > -1 Then
        Dim TotV As Single
        TotV = 0
        If WinPosA <= WinPosB Then
            
            For x = WinPosA To WinPosB
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            If TotV > 0 Then
                For x = WinPosA To WinPosB
                    
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                    'x = x
                Next x
            End If
        Else
            For x = WinPosA To (XPosDiff(Len(StrainSeq(0))) + Coffset)
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            For x = Coffset To WinPosB
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            If TotV > 0 Then
                For x = WinPosA To (XPosDiff(Len(StrainSeq(0))) + Coffset)
                    
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                Next x
                For x = Coffset To WinPosB
                    
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                Next x
            
            End If
        End If
    End If
End If
If EPosX > -1 Then
    If WinPosC > 0 Or WinPosD > 0 Then
        TotV = 0
        If WinPosC <= WinPosD Then
            For x = WinPosC To WinPosD
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            If TotV > 0 Then
                For x = WinPosC To WinPosD
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                Next x
            End If
        Else
            For x = WinPosC To (XPosDiff(Len(StrainSeq(0))) + Coffset)
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            For x = Coffset To WinPosD
                TotV = TotV + BPProbDist(x, BPProbDistSE)
            Next x
            If TotV > 0 Then
                For x = WinPosC To (XPosDiff(Len(StrainSeq(0))) + Coffset)
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                Next x
                For x = Coffset To WinPosD
                    tProbdist(x) = BPProbDist(x, BPProbDistSE) / TotV
                Next x
            End If
        End If
    End If
End If
For x = 0 To UBound(BPProbDist, 1)
    If BPProbDist(x, BPProbDistSE) > 0 Then
        x = x
    End If
    BPProbDist(x, BPProbDistSE) = tProbdist(x)
    
Next x
Dim TotProb As Double
'For x = WinPosD + 1 To UBound(BPProbDist, 1)
'    If BPProbDist(x, BPProbDistSE) Then
'        x = x
'    End If
'Next x
x = x
End Sub
Public Function BenHMM2(NumberXY As Long, Seq1, Seq2, Seq3)

ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1

'XX = Nextno
Dim Recode As String, RecodeB() As Byte, SLen As Long

'recode the sequences into an ABC string
Recode = String(Len(StrainSeq(0)), " ")
ReDim RecodeB(Len(StrainSeq(0)) * 2)
'Seq1 = 2
'Seq2 = 1
'Seq3 = 0
Y = 0
ReDim XPosDiff(Len(StrainSeq(0))), XDiffPos(Len(StrainSeq(0)))
For x = 1 To Len(StrainSeq(0))
    If SeqNum(x, Seq1) <> 46 Then
        If MissingData(x, Seq1) <> 1 Then
            If SeqNum(x, Seq2) <> 46 Then
                If MissingData(x, Seq2) <> 1 Then
                    If SeqNum(x, Seq3) <> 46 Then
                        If MissingData(x, Seq3) <> 1 Then
                            If SeqNum(x, Seq1) = SeqNum(x, Seq2) Then
                                If SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                                    Y = Y + 1
                                    RecodeB(Y - 1) = 0
                                    XDiffPos(Y) = x
                                    
                                End If
                            ElseIf SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                                Y = Y + 1
                                RecodeB(Y - 1) = 2
                                XDiffPos(Y) = x
                            ElseIf SeqNum(x, Seq2) = SeqNum(x, Seq3) Then
                                Y = Y + 1
                                RecodeB(Y - 1) = 1
                                XDiffPos(Y) = x
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If
'    If X >= 2500 Then
'        X = X
'    End If
    XPosDiff(x) = Y
Next x

LenXoverSeq = Y
Dim Coffset As Long
If CircularFlag = 1 Or ReassortmentFlag = 1 Then
    Coffset = CLng(Y / 2)
    Dim TXPD() As Long, TXDP() As Long, RB() As Byte
    ReDim TXPD(Y * 2), TXDP(Y * 2), RB(Y * 2 + 2)
    For A = 0 To Coffset - 1
        
        RB((Y + A + Coffset + 1)) = RecodeB(A) '1678-2237

    Next A
    For A = Coffset To Y - 1
        'TXPD(A - COffset) = XPosDiff(A)
        'TXDP(A - COffset) = XDiffPos(A)
        RB((A - Coffset)) = RecodeB(A) '0-558
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    For A = 0 To Y - 1
        'TXPD(A + COffset) = XPosDiff(A)
        'TXDP(A + COffset) = XDiffPos(A)
        RB((A + Coffset + 1)) = RecodeB(A) '559-1677
'        If A = Y - 1 Then
'            X = X
'        End If
    Next A
    Y = Y + Coffset * 2
    SLen = Y
    For A = 0 To SLen
        'XPosDiff(A) = TXPD(A)
        'XDiffPos(A) = TXDP(A)
        RecodeB(A) = RB(A)
    
    Next A
    
    
Else
    SLen = Y
    Coffset = 0
End If


'Initialisation
'For X = 0 To 6
'    X = X
'    XX = RecodeB(X)
'Next X


'Dim NumberXY As Long
Dim NumberABC As Long

NumberXY = 3
NumberABC = 3


Dim TransitionBak() As Double, EmissionBak() As Double, TransitionM2() As Double, EmissionM2() As Double, InitPBak() As Double, InitP() As Double, MaxP As Double, MinP As Double
ReDim TransitionM2(NumberXY - 1, NumberXY - 1), EmissionM2(NumberABC - 1, NumberXY - 1), InitP(NumberXY - 1)

Dim NumCycles As Long
Dim bestLike As Double
'If SEventNumber = 2 Then
'    X = X
'End If
bestLike = -100000000
Rnd (-BSRndNumSeed)
For NumCycles = 0 To 20
    '012,021,102,120,201,210
    iVal = 5 / Len(StrainSeq(0))
    If NumberXY > 1 Then
        For x = 0 To NumberXY - 1
            For Y = 0 To NumberXY - 1
                If x = Y Then
                    TransitionM2(x, Y) = Log(1 - iVal)
                Else
                    TransitionM2(x, Y) = Log((iVal) / (NumberXY - 1))
                End If
                x = x
            Next Y
        Next x
    Else
        TransitionM2(0, 0) = Log(1)
    End If
    
    'Dim PosMaxP As Double, PosMax As Long
    
    'For X = 0 To NumberXY - 1
    '    PosMaxP = ((X + 1) / NumberABC) * (NumberABC) - 1
    '    PosMaxP = NumberABC - PosMaxP - 1 'CLng(PosMaxP) 'the value in the list that will be the maximum
    '    PosMax = PosMaxP
    '    MaxP = X / NumberXY
    '    MaxP = 0.8 'the value of the maximum
    '    MinP = (1 - MaxP) / (NumberABC - 1) 'the value of the minumum
    '    For Y = 0 To NumberABC - 1
    '
    '
    '        If Y = PosMax Then
    '            EmissionM2(Y, X) = Log(MaxP)
    '        Else
    '            EmissionM2(Y, X) = Log(MinP)
    '        End If
    '        X = X
    '    Next Y
    '    X = X
    'Next X
    
    Dim DoneImba() As Long, Imballance As Double, Imballance2 As Long
    
    'RNDSEED = RNDSEED + 1
    'RNDSEED = 54
    'Rnd (-RNDSEED)
    Imballance = (Int((NumberABC * Rnd) + 1)) / 10
    'Imballance = 10 ^ -2
    If x = x Then
        'Exit Function
        ReDim DoneImba(NumberXY)
        For x = 0 To NumberXY - 1
            
            Do
                'Exit Function
                Imballance2 = Int(((NumberXY + 3) * Rnd)) - 2  '2,2,2,1,1,2,2,0,1,0,0,2,2,2,0,1,0,0,1,1,0,0,1
                If Imballance2 >= 0 And Imballance2 < NumberXY Then '102,120,021,201,021,102
                    If DoneImba(Imballance2) = 0 Then
                        For Y = 0 To NumberABC - 1
                            If Y = Imballance2 Then
                                EmissionM2(Y, x) = 1 / NumberABC + Imballance * 2
                            Else
                                EmissionM2(Y, x) = 1 / NumberABC - Imballance
                            End If
                        Next Y
                        
                        DoneImba(Imballance2) = 1
                        Exit Do
                    End If
                End If
            Loop
        
        
        Next x
        
        For x = 0 To NumberXY - 1
            Imballance = 0
            For Y = 0 To NumberABC - 1
            
                Imballance = Imballance + Abs(EmissionM2(Y, x))
            
            Next Y
            
            For Y = 0 To NumberABC - 1
            
                EmissionM2(Y, x) = Abs(EmissionM2(Y, x)) / Imballance
            
            Next Y
            
      Next x
        x = x
        
    Else
        If NumberXY = 2 And NumberABC = 3 Then
            EmissionM2(0, 0) = 0.1
            EmissionM2(1, 0) = 0.1
            EmissionM2(2, 0) = 0.8
            EmissionM2(0, 1) = 0.6
            EmissionM2(1, 1) = 0.2
            EmissionM2(2, 1) = 0.2
        ElseIf NumberXY = 3 And NumberABC = 3 Then
            EmissionM2(0, 0) = 0.1
            EmissionM2(1, 0) = 0.1
            EmissionM2(2, 0) = 0.8
            EmissionM2(0, 1) = 0.15
            EmissionM2(1, 1) = 0.7
            EmissionM2(2, 1) = 0.15
            EmissionM2(0, 2) = 0.6
            EmissionM2(1, 2) = 0.2
            EmissionM2(2, 2) = 0.2
        End If
    End If
    
    For x = 0 To NumberXY - 1
    
        For Y = 0 To NumberABC - 1
            If EmissionM2(Y, x) <= 0 Then
                Exit Function
            End If
            EmissionM2(Y, x) = Log(EmissionM2(Y, x))
            
        Next Y
    Next x
    
    ' 0.1 0.1 0.8
    ' 0.5 0.5 0.5
    '
    
    For x = 0 To NumberXY - 1
        InitP(x) = Log(1 / NumberXY)
    Next x
    
    'InitP(0) = Log(0.5)
    'InitP(1) = Log(0.5)
    
    Dim LaticePathBak() As Long, StateCount() As Double, TotCount As Double, TransitionCount() As Double, TotXY(), LaticeAB() As Double, LaticeXY() As Double, LaticePath() As Long, Fudge As Double, Maxiterations As Long, PathLike As Double, MaxL As Double, PathMax As Double
    ReDim LaticeXY(SLen, NumberXY - 1), LaticePath(SLen)
    Fudge = 0.01
    
    Maxiterations = 100
    XX = CurDir
    'viterbi training
    'Open "transition.csv" For Output As #1
    'Open "emission.csv" For Output As #2
    
    

    For A = 1 To Maxiterations
       ' If X = X Then
           ' Print #1, CStr(Exp(TransitionM2(0, 0))) + "," + CStr(Exp(TransitionM2(0, 1))) + "," + CStr(Exp(TransitionM2(0, 2))) + "," + CStr(Exp(TransitionM2(1, 0))) + CStr(Exp(TransitionM2(1, 1))) + "," + CStr(Exp(TransitionM2(1, 2))) + "," + CStr(Exp(TransitionM2(2, 0))) + CStr(Exp(TransitionM2(2, 1))) + "," + CStr(Exp(TransitionM2(2, 2)))
           ' Print #2, CStr(Exp(EmissionM2(0, 0))) + "," + CStr(Exp(EmissionM2(0, 1))) + "," + CStr(Exp(EmissionM2(0, 2))) + "," + CStr(Exp(EmissionM2(1, 0))) + "," + CStr(Exp(EmissionM2(1, 1))) + "," + CStr(Exp(EmissionM2(1, 2))) + "," + CStr(Exp(EmissionM2(2, 0))) + "," + CStr(Exp(EmissionM2(2, 1))) + "," + CStr(Exp(EmissionM2(2, 2)))
        
       ' End If
    
    
        Call Viterbi(NumberABC, NumberXY, SLen, RecodeB(), LaticeXY(), LaticeAB(), TransitionM2(), EmissionM2(), InitP())
        
        
        Dim LastHigh As Byte
        
        If x = x Then
            MaxL = GetLaticePath(SLen, NumberXY, LaticeXY(0, 0), LaticeAB(0, 0), LaticePath(0))
            x = x
        Else
        
            MaxL = -1E+22
            
            
            For Y = 0 To NumberXY - 1
                
                If LaticeXY(SLen, Y) > MaxL Then
                    MaxL = LaticeXY(SLen, Y)
                    LaticePath(SLen) = LaticeAB(SLen, Y)
                    
                End If
                
            Next Y
            
            For x = SLen - 1 To 0 Step -1
                For Y = 0 To NumberXY - 1
                    'If LaticeXY(SLen, Y) > MaxL Then
                        
                        LaticePath(x) = LaticeAB(x, LaticePath(x + 1))
                       
                    'End If
                Next Y
            Next x
            
        End If
        
        If PathMax = MaxL Then
            Exit For
        
        Else 'PathMax <> MaxL Then
            PathMax = MaxL
        
        End If
       
                   
         
        
        
        'update transition and emission matrices
        If NumberXY > 1 Then
            ReDim TotXY(NumberXY - 1)
            ReDim TransitionCount(NumberXY - 1, NumberXY - 1)
            ReDim StateCount(NumberABC - 1, NumberXY - 1)
            
            If x = x Then
                Dummy = UpdateCounts(SLen, NumberABC, NumberXY, LaticePath(0), RecodeB(0), TransitionCount(0, 0), StateCount(0, 0))
            Else
                For Z = 0 To SLen - 1
                    TransitionCount(LaticePath(Z), LaticePath(Z + 1)) = TransitionCount(LaticePath(Z), LaticePath(Z + 1)) + 1
                    x = x
                    'StateCount(RecodeB(Z), LaticePath(Z)) = StateCount(RecodeB(Z), LaticePath(Z)) + 1
                Next Z
                For Z = 0 To SLen
                    StateCount(RecodeB(Z), LaticePath(Z)) = StateCount(RecodeB(Z), LaticePath(Z)) + 1
                Next Z
            End If
            
            
           For x = 0 To NumberXY - 1
                TotCount = 0
                For Y = 0 To NumberXY - 1
                    'TransitionM2(X, Y) = TransitionCount(X, Y)
                    TotCount = TotCount + TransitionCount(x, Y)
                Next Y
                TotCount = TotCount + (Fudge * NumberXY)
                For Y = 0 To NumberXY - 1
                    TransitionCount(x, Y) = TransitionCount(x, Y) + Fudge
                    
                    TransitionM2(x, Y) = Log((TransitionCount(x, Y) / TotCount))
                    
                Next Y
                
               
                
                
           Next x
            
            For Y = 0 To NumberXY - 1
                TotCount = 0
                For Z = 0 To NumberABC - 1
                    TotCount = TotCount + StateCount(Z, Y)
                Next Z
                TotCount = TotCount + (Fudge * NumberABC)
                For Z = 0 To NumberABC - 1
                    
                    EmissionM2(Z, Y) = Log(((StateCount(Z, Y) + Fudge) / TotCount))
                    x = x
                Next Z
                
            Next Y
        Else
            TransitionM2(0, 0) = Log(1)
        End If
        
    Next A
    
    If MaxL > bestLike Then '-1105, -1087,-1087, -1098,-1087
        'back up emmission and transition matrices
        bestLike = MaxL
        ReDim TransitionBak(NumberXY - 1, NumberXY - 1), EmissionBak(NumberABC - 1, NumberXY - 1), InitPBak(NumberXY - 1), LaticePathBak(SLen)
        For x = 0 To NumberXY - 1
            InitPBak(x) = InitP(x)
            For Y = 0 To NumberXY - 1
                TransitionBak(x, Y) = TransitionM2(x, Y)
            Next Y
            For Y = 0 To NumberABC - 1
                EmissionBak(Y, x) = EmissionM2(Y, x)
            Next Y
        Next x
        For x = 0 To SLen
            LaticePathBak(x) = LaticePath(x)
        Next x
    End If
Next NumCycles

MaxL = bestLike
For x = 0 To NumberXY - 1
    InitP(x) = InitPBak(x)
    For Y = 0 To NumberXY - 1
        TransitionM2(x, Y) = TransitionBak(x, Y)
    Next Y
    For Y = 0 To NumberABC - 1
        EmissionM2(Y, x) = EmissionBak(Y, x)
    Next Y
    For Y = 0 To SLen
        LaticePath(Y) = LaticePathBak(Y)
    Next Y
    
Next x
'Close #1
'Close #2
Dim MaxY As Double


Dim LaticeCD() As Double
ReDim LaticeCD(SLen, NumberXY - 1)

Call Forward(NumberABC, NumberXY, SLen, RecodeB(), LaticeCD(), TransitionM2(), EmissionM2(), InitP())

Dim LaticeEF() As Double
ReDim LaticeEF(SLen, NumberXY - 1)

Call Reverse(NumberABC, NumberXY, SLen, RecodeB(), LaticeEF(), TransitionM2(), EmissionM2(), InitP())

'XX = XPosDiff(144)
Dim StateProb() As Double
ReDim StateProb(SLen, NumberXY)
If BPProbDistFlag = 1 Then

'    If SLen > 0 Then
'        If CircularFlag = 1 Or ReassortmentFlag = 1 Then 'git rid of the overlap
'            For X = 0 To SLen / 2
'                LaticePath(X) = LaticePath(X + COffset + 1)
'                RecodeB(X) = RecodeB(X + COffset)
'                For Y = O To NumberXY - 1
'                    StateProb(X, Y) = StateProb(X + COffset + 1, Y)
'                Next Y
'            Next X
'            SLen = SLen / 2
'            COffset = 0
'        End If
'    End If
'XX = XPosDiff(Len(StrainSeq(0)))
    If SLen - 1 > UBound(BPProbDist, 1) Then
        Dim tBPD() As Single, tMB() As Long
        Dim Odim As Long
        Odim = UBound(BPProbDist, 1)
        ReDim tBPD(Odim + 100, SEventNumber)
        ReDim tMB(Odim + 100, SEventNumber)
        For x = 0 To Odim
            For Y = 0 To SEventNumber
                tBPD(x, Y) = BPProbDist(x, Y)
                tMB(x, Y) = MapBack(x, Y)
            Next Y
        Next x
        
        ReDim BPProbDist(SLen, SEventNumber), MapBack(SLen, SEventNumber) ', MapBack(GCDimSize * 2, SEventNumber)'long
        
        
        For x = 0 To Odim
            For Y = 0 To SEventNumber
               BPProbDist(x, Y) = tBPD(x, Y)
                MapBack(x, Y) = tMB(x, Y)
            Next Y
        Next x
        
    End If
    
    For x = 1 To SLen - 1
        
        For Y = 0 To NumberXY - 1
            StateProb(x, Y) = LaticeCD(x, Y) + LaticeEF(x, Y)
        Next Y
        MaxV = -10 ^ 22
        For Y = 0 To NumberXY - 1
            If MaxV < StateProb(x, Y) Then
                MaxV = StateProb(x, Y)
            End If
            
        Next Y
        For Y = 0 To NumberXY - 1
            
            StateProb(x, Y) = StateProb(x, Y) - MaxV
            StateProb(x, Y) = Exp(StateProb(x, Y))
            
        Next Y

        BPProbDist(x, BPProbDistSE) = 0
        For Y = 0 To NumberXY - 1
            
            If StateProb(x, Y) < 1 Then
                BPProbDist(x, BPProbDistSE) = BPProbDist(x, BPProbDistSE) + Abs(StateProb(x, Y))
'                If StateProb(X, Y) = 1 Then
'                    X = X
'                End If
            End If

        Next Y
'        If BPProbDist(x, BPProbDistSE) = 0 > 1 Then
'            x = x
'        End If
       
        
        
        
        
    Next x
    
    
    
    
    
    'Find bounds the bp position and find lowest bpprobdist
    Dim BPosX As Long, EPosX As Long, BestX As Long, BestY As Long, BPW As Long
    BestX = BestEvent(BPProbDistSE, 0)
    BestY = BestEvent(BPProbDistSE, 1)
    BPW = XoverList(BestX, BestY).SBPFlag
    
    If BPW <> 1 And BPW <> 3 Then
        BPosX = XoverList(BestX, BestY).Beginning
        BPosX = XPosDiff(BPosX) + Coffset '650
        If BPosX = 0 Then BPosX = -1
    Else
        BPosX = -1
    End If
    If BPW <> 2 And BPW <> 3 Then
        EPosX = XoverList(BestX, BestY).Ending
        EPosX = XPosDiff(EPosX) + Coffset '705
        If EPosX = 0 Then EPosX = -1
    Else
        EPosX = -1
    End If
    'at the breakpoint site add the highest stateorob
    XX = Len(StrainSeq(0))
    Dim BestV As Double
'    If BPosX <> -1 Then
'        If BPProbDist(BPosX, BPProbDistSE) < 1 - BPProbDist(BPosX, BPProbDistSE) Then BPProbDist(BPosX, BPProbDistSE) = 1 - BPProbDist(BPosX, BPProbDistSE)
'    End If
'    If EPosX <> -1 Then
'        If BPProbDist(EPosX, BPProbDistSE) < 1 - BPProbDist(EPosX, BPProbDistSE) Then BPProbDist(EPosX, BPProbDistSE) = 1 - BPProbDist(EPosX, BPProbDistSE)
'
'    End If
    
    Call AddBreakBounds(SLen, BPProbDistSE, LaticePath(), BPProbDist(), BPosX, EPosX, XPosDiff(), Coffset)
    
    'get rid of the overlap
    If (EPosX <> -1 Or BPosX <> -1) And Coffset > 0 Then
        If CircularFlag = 1 Then 'need to wrap ends
            Y = 1
            For x = 0 To SLen / 2
                If BPProbDist(x, BPProbDistSE) < BPProbDist(x + Coffset * 2, BPProbDistSE) Then
                    BPProbDist(x, BPProbDistSE) = BPProbDist(x + Coffset * 2, BPProbDistSE)
                Else
                    BPProbDist(x + Coffset * 2, BPProbDistSE) = BPProbDist(x, BPProbDistSE)
                End If
                'Y = Y + 1
                
            Next x
        End If
        For x = 0 To (SLen / 2)
'            If x > SLen / 2 - 5 Then '365 Then
'                x = x
'            End If
            BPProbDist(x, BPProbDistSE) = BPProbDist(x + Coffset, BPProbDistSE)
            MapBack(x, BPProbDistSE) = XDiffPos(x) 'MapBack(X + COffset, BPProbDistSE)
'            If BPProbDistSE = 1 And (x + COffset = 1064 Or x + COffset = 1008) Then
'                x = x '706=0.679:650=0.193:slen=716
'            End If
        Next x
        
        Tot = 0
        Dim Adjust As Single, Target As Single
        For Y = 0 To SLen / 2
            Tot = Tot + BPProbDist(Y, BPProbDistSE)
        Next Y
        If BPW = 0 Then
            Target = 2
        ElseIf BPW < 3 Then
            Target = 1
        End If
        If Tot > 0 Then
            Adjust = Target / Tot
            If Adjust <> 1 Then
                For Y = 0 To SLen
                    BPProbDist(Y, BPProbDistSE) = BPProbDist(Y, BPProbDistSE) * Adjust
                Next Y
            End If
        End If
        x = x
    Else
        For x = 0 To SLen
'            If x = 365 Then
'                x = x
'            End If
            MapBack(x, BPProbDistSE) = XDiffPos(x) 'MapBack(X + COffset, BPProbDistSE)
'            If BPProbDistSE = 1 And (x + COffset = 1064 Or x + COffset = 1008) Then
'                x = x '706=0.679:650=0.193:slen=716
'            End If
        Next x
    End If
  x = x
  
Else
    For x = 0 To SLen
        For Y = 0 To NumberXY - 1
            StateProb(x, Y) = LaticeCD(x, Y) + LaticeEF(x, Y)
        Next Y
        MaxV = -10 ^ 22
        For Y = 0 To NumberXY - 1
            If MaxV < StateProb(x, Y) Then
                MaxV = StateProb(x, Y)
            End If
            
        Next Y
        TotProb = 0
        
        For Y = 0 To NumberXY - 1
            
            StateProb(x, Y) = StateProb(x, Y) - MaxV
            StateProb(x, Y) = Exp(StateProb(x, Y))
            TotProb = TotProb + StateProb(x, Y)
            
        Next Y
        For Y = 0 To NumberXY - 1
            StateProb(x, Y) = StateProb(x, Y) / TotProb
            x = x
        Next Y
        
    Next x
    
    If SLen > 0 Then
        If CircularFlag = 1 Or ReassortmentFlag = 1 Then 'git rid of the overlap
            For x = 0 To SLen / 2
                LaticePath(x) = LaticePath(x + Coffset + 1)
                RecodeB(x) = RecodeB(x + Coffset)
                For Y = O To NumberXY - 1
                    StateProb(x, Y) = StateProb(x + Coffset + 1, Y)
                Next Y
            Next x
            SLen = SLen / 2
        End If
    End If
    
    MaxY = 0
    For x = 1 To SLen
        For Y = 0 To NumberXY - 1
            If Abs(StateProb(x, Y)) > MaxY Then MaxY = Abs(StateProb(x, Y))
        Next Y
    Next x
    
    
    
    LenXoverSeq = SLen

    



    Dim GoOn As Byte
    ReDim CIs(5, 10)
    CurCI = -1
    For x = 2 To SLen - 2
        If LaticePath(x) <> LaticePath(x + 1) Then
            
            CurCI = CurCI + 1
            
            If CurCI > UBound(CIs, 2) Then
                ReDim Preserve CIs(5, CurCI + 10)
            End If
            
            CIs(2, CurCI) = Decompress(XDiffPos(x)) + (Decompress(XDiffPos(x + 1)) - Decompress(XDiffPos(x))) / 2
            'find left 99% (0) and 95% (3) CI
            If CIs(2, CurCI) < 0 Then CIs(2, CurCI) = 0
            CIs(3, CurCI) = 0
            CIs(4, CurCI) = 0
            For Y = x - 1 To -SLen Step -1
                If Y < 0 Then
                    If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                        A = Y + SLen
                    Else
                        CIs(0, CurCI) = 1
                        Exit For
                    End If
                Else
                    A = Y
                End If
                GoOn = 1
                For Z = 0 To NumberXY - 1
                    If StateProb(A, Z) > 0.995 And CIs(3, CurCI) = 0 Then
                        
                            If A < SLen - 1 Then
                                CIs(3, CurCI) = CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                                
                            Else
                                CIs(3, CurCI) = 1
                            End If
                        
                    End If
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A < SLen - 1 Then
                                CIs(0, CurCI) = CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                                x = x
                            Else
                                CIs(0, CurCI) = 1
                            End If
                        GoOn = 0
                        Exit For
                    End If
                
                Next Z
                If GoOn = 0 Then Exit For
                
                
            Next Y
            
            'find right 99% (1) and 95% (4) CI
            For Y = x + 1 To SLen * 2
                If Y > SLen Then
                    If CircularFlag = 1 Or ReassortmentFlag = 1 Then
                        A = Y - SLen
                    Else
                        CIs(1, CurCI) = SLen
                        Exit For
                    End If
                Else
                    A = Y
                End If
                GoOn = 1
                For Z = 0 To NumberXY - 1
                    If StateProb(A, Z) > 0.995 And CIs(4, CurCI) = 0 Then
                        
                            If A < SLen Then
                                CIs(4, CurCI) = CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                            Else
                                CIs(4, CurCI) = Decompress(Len(StrainSeq(0)))
                                
                            End If
                       
                        
                        
                    End If
                    If StateProb(A, Z) > 0.999 Then
                        
                            If A < SLen Then
                                CIs(1, CurCI) = CLng(Decompress(XDiffPos(A)) + (Decompress(XDiffPos(A + 1)) - Decompress(XDiffPos(A))) / 2)
                            Else
                                CIs(1, CurCI) = Decompress(Len(StrainSeq(0)))
                                
                            End If
                       
                        GoOn = 0
                        Exit For
                        
                    End If
                Next Z
                If GoOn = 0 Then Exit For
                
                
            Next Y
            
            x = x
        End If
        
    
    Next x
    
    If x = x And NumberXY > 0 Then
    
    
    
    'Get everything into the standard format for printing and saving
        LenXoverSeq = SLen
        NumLines = 6  'number of lines to print
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
        GPrintNum = NumLines - 1
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        'If XDiffPos(0) = 0 Then XDiffPos(0) = XDiffPos(1)
    
    
    
    Form1.Picture7.DrawWidth = 1
        Form1.Picture7.Picture = LoadPicture()
        YScaleFactor = 0.85
        PicHeight = Form1.Picture7.Height * YScaleFactor
        Pict = Form1.Picture7.hdc
        XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
        GLegend = "Probability"
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
    'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MaxY, 0, 1, "Probability")
    
    GPrintMin(1) = MaxY
    GPrintMin(0) = 0
    
    'Call Highlight(0)
    
    Dim PntAPI As POINTAPI
        
        
        
        
        Dim PHX As Long, RDPA As Single
        PHX = PicHeight - 35
        
        SS = Abs(GetTickCount)
      
            Pict = Form1.Picture7.hdc
            
            
            
            Form1.Picture7.ForeColor = RGB(128, 128, 128)
            Form1.Picture7.DrawWidth = 5
            'If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
            '
            'Else
                Dim YP As Long, XP As Long, OXP As Long
                Dim MaY As Long, MiY As Long
                
                'uncomment to draw grey path
                'MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * xFactor, PicHeight - (15 + Abs((LaticePath(1) / (NumberXY - 1))) * (PicHeight - 35)), PntAPI
                OXP = 0
    '            For X = 2 To SLen
    '                YP = PicHeight - ((15 + ((Abs(LaticePath(X) / (NumberXY - 1)))) * (PicHeight - 35)))
    '                XP = 30 + XDiffPos(X) * XFactor + XFactor
    '                If OXP <> XP Then
    '                    MiY = 10000
    '                    MaY = 0
    '                End If
    '                OXP = XP
    '                If YP > MaY Or YP < MiY Then
    '                    'uncomment to draw grey path
    '                    'LineTo Pict, XP, YP
    '                    If YP > MaY Then MaY = YP
    '                    If YP < MiY Then MiY = YP
    '                End If
    '            Next 'X
            'End If
            Form1.Picture7.DrawWidth = 1
            Dim ColTest() As Double
            ReDim ColTest(NumberXY - 1, 2)
            
            
            Dim Winner As Long, MaxScore As Double, WinCol() As Long
            ReDim WinCol(NumberXY - 1)
            For Y = 0 To NumberXY - 1
                
                For x = 1 To SLen - 1
                    ColTest(Y, RecodeB(x)) = ColTest(Y, RecodeB(x)) + StateProb(x - 1, Y)
                    
                Next x
                Winner = -1
                MaxScore = 0
                For x = 0 To 2
                    If ColTest(Y, x) >= MaxScore Then
                        MaxScore = ColTest(Y, x)
                        Winner = x
                    End If
                Next x
                If Winner = 0 Then
                    WinCol(Y) = Yellow
                    GPrintCol(Y) = Yellow
                ElseIf Winner = 1 Then
                    WinCol(Y) = Purple
                    GPrintCol(Y) = Purple
                ElseIf Winner = 2 Then
                    WinCol(Y) = Green
                    GPrintCol(Y) = Green
                End If
            Next Y
            
        For Y = 0 To NumberXY - 1
            Pict = Form1.Picture7.hdc
            
            
            If x = 12345 Then
                If Y = 0 Then
                    Form1.Picture7.ForeColor = RGB(255, 0, 0)
                ElseIf Y = 1 Then
                    Form1.Picture7.ForeColor = RGB(255, 255, 0)
                ElseIf Y = 2 Then
                    Form1.Picture7.ForeColor = RGB(255, 0, 255)
                ElseIf Y = 3 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 255)
                ElseIf Y = 4 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 0)
                Else
                    Form1.Picture7.ForeColor = RGB(0, 0, 255)
                End If
            Else
                Form1.Picture7.ForeColor = WinCol(Y)
            End If
            'If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            '    Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
            '
            'Else
               
    '            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * xFactor, PicHeight - (15 + Abs((StateProb(1, Y)) / MaxY) * (PicHeight - 35)), PntAPI
                
                GPrint(Y, 1) = Abs((StateProb(1, Y)))
                GPrintPos(Y, 1) = XDiffPos(1)
                OXP = 0
                For x = 2 To SLen - 1
                    YP = PicHeight - ((15 + ((Abs(StateProb(x - 1, Y)) / MaxY)) * (PicHeight - 35)))
                    XP = 30 + XDiffPos(x) * XFactor + XFactor
                    If OXP <> XP Then
                        MiY = 10000
                        MaY = 0
                    End If
                    OXP = XP
                   ' If X = 2000 Then
                   '         X = X
                   '     End If
                   ' If YP > MaY Or YP < MiY Then
    '                    LineTo Pict, XP, YP
                        If YP > MaY Then MaY = YP
                        If YP < MiY Then MiY = YP
                        GPrint(Y, x) = Abs(StateProb(x - 1, Y))
                        GPrintPos(Y, x) = XDiffPos(x)
                        
                    'End If
                Next 'X
            'End If
            x = x
        Next 'Y
        GPrintLen = SLen
        GPrintType = 0
        ReDim GCritval(10)
        GCritval(0) = 0
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawWidth = 1
    End If
    Form1.Picture7.CurrentY = PicHeight + 10
    Form1.Picture7.CurrentX = 30
    Dim Out As String
    Out = "Log Likelihood =" & Trim(Str((Int(MaxL * 10000)) / 10000))
    GPVTNum = GPVTNum + 1
    GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
    GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
    GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
    GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
    GPVText(GPVTNum) = Out$
    
    Form1.Picture7.Print Out
    
    Call RedrawPlotAA(1)
End If
BenHMM2 = 1
End Function
Public Sub Reverse(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Double, TransitionM2() As Double, EmissionM2() As Double, InitP() As Double)

Dim Dummy As Long, x As Long, OptXY() As Double
ReDim OptXY(NumberXY - 1, NumberXY - 1)
ReDim LaticeAB(SLen, NumberXY - 1)
Dim Minv As Double, ValXY() As Double
            'ReDim ValXY(NumberXY - 1)
ReDim ValXY(NumberXY - 1)



For x = 0 To NumberXY - 1
        LaticeXY(SLen, x) = 0  '-2.9957, -1.386
       
Next x
    'LaticeXY(0, 0) = TransitionM2(0, 0) + EmissionM2(RecodeB(0), 0)
    'LaticeXY(0, 1) = TransitionM2(1, 1) + EmissionM2(RecodeB(0), 1)
    

'If X = X Then
    Dummy = ReverseCP(SLen, NumberABC, NumberXY, ValXY(0), OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0))
'Else
'    For X = SLen - 1 To 0 Step -1
'        'For Y = 0 To UBound(TransitionM2, 1)
'            'If RecodeB(X) = 0 Then
'
'            For A = 0 To NumberXY - 1 'first state
'                For B = 0 To NumberXY - 1 'second state
'                    OptXY(A, B) = LaticeXY(X + 1, B) + TransitionM2(A, B) + EmissionM2(RecodeB(X + 1), B) 'general
'
'
'                    'OptXY(0, 0) = LaticeXY(X - 1, 0) + TransitionM2(0, 0) + EmissionM2(RecodeB(X), 0) 'x going to x
'                    'OptXY(1, 0) = LaticeXY(X - 1, 1) + TransitionM2(1, 0) + EmissionM2(RecodeB(X), 0) 'y going to x
'                   '
'                   ' OptXY(0, 1) = LaticeXY(X - 1, 0) + TransitionM2(0, 1) + EmissionM2(RecodeB(X), 1) 'x going to y
'                   ' OptXY(1, 1) = LaticeXY(X - 1, 1) + TransitionM2(1, 1) + EmissionM2(RecodeB(X), 1) 'y going to y
'
'                Next B
'            Next A
'
'
'            For A = 0 To NumberXY - 1
'                ValXY(A) = 0
'            Next A
'            For A = 0 To NumberXY - 1
'                MinV = -10 ^ 22
'                For B = 0 To NumberXY - 1 '
'                    If MinV < OptXY(A, B) Then
'                        MinV = OptXY(A, B)
'                    End If
'                Next B
'                LaticeXY(X, A) = 0
'                For B = 0 To NumberXY - 1 '
'                    ValXY(B) = OptXY(A, B) - MinV
'                    ValXY(B) = Exp(ValXY(B))
'                    LaticeXY(X, A) = LaticeXY(X, A) + ValXY(B)
'
'                Next B
'                LaticeXY(X, A) = Log(LaticeXY(X, A))
'                LaticeXY(X, A) = LaticeXY(X, A) + MinV
'
'            Next A
'
'    Next X
'End If
'
''XX = LaticeXY(1, 0)
''XX = LaticeXY(1, 1)
'
'X = X
End Sub
Public Sub ReverseF(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Single, TransitionM2() As Single, EmissionM2() As Single, InitP() As Single)

Dim Dummy As Long, x As Long, OptXY() As Single
ReDim OptXY(NumberXY - 1, NumberXY - 1)
ReDim LaticeAB(SLen, NumberXY - 1)
Dim Minv As Double, ValXY() As Single
            'ReDim ValXY(NumberXY - 1)
ReDim ValXY(NumberXY - 1)



For x = 0 To NumberXY - 1
        LaticeXY(SLen, x) = 0  '-2.9957, -1.386
       
Next x
    'LaticeXY(0, 0) = TransitionM2(0, 0) + EmissionM2(RecodeB(0), 0)
    'LaticeXY(0, 1) = TransitionM2(1, 1) + EmissionM2(RecodeB(0), 1)
    

'If X = X Then
    Dummy = ReverseCPF(SLen, NumberABC, NumberXY, ValXY(0), OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0))
'Else
'    For X = SLen - 1 To 0 Step -1
'        'For Y = 0 To UBound(TransitionM2, 1)
'            'If RecodeB(X) = 0 Then
'
'            For A = 0 To NumberXY - 1 'first state
'                For B = 0 To NumberXY - 1 'second state
'                    OptXY(A, B) = LaticeXY(X + 1, B) + TransitionM2(A, B) + EmissionM2(RecodeB(X + 1), B) 'general
'
'
'                    'OptXY(0, 0) = LaticeXY(X - 1, 0) + TransitionM2(0, 0) + EmissionM2(RecodeB(X), 0) 'x going to x
'                    'OptXY(1, 0) = LaticeXY(X - 1, 1) + TransitionM2(1, 0) + EmissionM2(RecodeB(X), 0) 'y going to x
'                   '
'                   ' OptXY(0, 1) = LaticeXY(X - 1, 0) + TransitionM2(0, 1) + EmissionM2(RecodeB(X), 1) 'x going to y
'                   ' OptXY(1, 1) = LaticeXY(X - 1, 1) + TransitionM2(1, 1) + EmissionM2(RecodeB(X), 1) 'y going to y
'
'                Next B
'            Next A
'
'
'            For A = 0 To NumberXY - 1
'                ValXY(A) = 0
'            Next A
'            For A = 0 To NumberXY - 1
'                MinV = -10 ^ 22
'                For B = 0 To NumberXY - 1 '
'                    If MinV < OptXY(A, B) Then
'                        MinV = OptXY(A, B)
'                    End If
'                Next B
'                LaticeXY(X, A) = 0
'                For B = 0 To NumberXY - 1 '
'                    ValXY(B) = OptXY(A, B) - MinV
'                    ValXY(B) = Exp(ValXY(B))
'                    LaticeXY(X, A) = LaticeXY(X, A) + ValXY(B)
'
'                Next B
'                LaticeXY(X, A) = Log(LaticeXY(X, A))
'                LaticeXY(X, A) = LaticeXY(X, A) + MinV
'
'            Next A
'
'    Next X
'End If
'
''XX = LaticeXY(1, 0)
''XX = LaticeXY(1, 1)
'
'X = X
End Sub
Public Sub ForwardF(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Single, TransitionM2() As Single, EmissionM2() As Single, InitP() As Single)

Dim x As Long, Dummy As Long, OptXY() As Single
ReDim OptXY(NumberXY - 1, NumberXY - 1)
ReDim LaticeAB(SLen, NumberXY - 1)
Dim Minv As Double, ValXY() As Single
ReDim ValXY(NumberXY - 1)
For x = 0 To NumberXY - 1
        LaticeXY(0, x) = EmissionM2(RecodeB(0), x) + InitP(x) '-2.9957, -1.386
        
Next x
    'LaticeXY(0, 0) = TransitionM2(0, 0) + EmissionM2(RecodeB(0), 0)
    'LaticeXY(0, 1) = TransitionM2(1, 1) + EmissionM2(RecodeB(0), 1)
'If X = X Then
    Dummy = ForwardCPF(SLen, NumberABC, NumberXY, ValXY(0), OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0))
'Else
'    For X = 1 To SLen
'        'For Y = 0 To UBound(TransitionM2, 1)
'            'If RecodeB(X) = 0 Then
'
'            For A = 0 To NumberXY - 1 'first state
'                For B = 0 To NumberXY - 1 'second state
'                    OptXY(A, B) = LaticeXY(X - 1, A) + TransitionM2(A, B) + EmissionM2(RecodeB(X), B) 'general
'
'
'                    'OptXY(0, 0) = LaticeXY(X - 1, 0) + TransitionM2(0, 0) + EmissionM2(RecodeB(X), 0) 'x going to x
'                    'OptXY(1, 0) = LaticeXY(X - 1, 1) + TransitionM2(1, 0) + EmissionM2(RecodeB(X), 0) 'y going to x
'                   '
'                   ' OptXY(0, 1) = LaticeXY(X - 1, 0) + TransitionM2(0, 1) + EmissionM2(RecodeB(X), 1) 'x going to y
'                   ' OptXY(1, 1) = LaticeXY(X - 1, 1) + TransitionM2(1, 1) + EmissionM2(RecodeB(X), 1) 'y going to y
'
'                Next B
'            Next A
'
'            For A = 0 To NumberXY - 1
'                ValXY(A) = 0
'            Next A
'
'            For A = 0 To NumberXY - 1
'                MinV = -10 ^ 22
'                For B = 0 To NumberXY - 1 '
'                    If MinV < OptXY(B, A) Then
'                        MinV = OptXY(B, A)
'                    End If
'                Next B
'
'                LaticeXY(X, A) = 0
'                For B = 0 To NumberXY - 1 '
'                    ValXY(B) = OptXY(B, A) - MinV
'                    ValXY(B) = Exp(ValXY(B))
'                    LaticeXY(X, A) = LaticeXY(X, A) + ValXY(B)
'                    X = X
'                Next B
'                LaticeXY(X, A) = Log(LaticeXY(X, A))
'                LaticeXY(X, A) = LaticeXY(X, A) + MinV
'                X = X
'            Next A
'
'    Next X
'
'End If


'XX = LaticeXY(SLen - 1, 1)
'XX = LaticeXY(SLen - 1, 0)

End Sub
Public Sub Forward(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Double, TransitionM2() As Double, EmissionM2() As Double, InitP() As Double)

Dim x As Long, Dummy As Long, OptXY() As Double
ReDim OptXY(NumberXY - 1, NumberXY - 1)
ReDim LaticeAB(SLen, NumberXY - 1)
Dim Minv As Double, ValXY() As Double
ReDim ValXY(NumberXY - 1)
For x = 0 To NumberXY - 1
        LaticeXY(0, x) = EmissionM2(RecodeB(0), x) + InitP(x) '-2.9957, -1.386
        
Next x
    'LaticeXY(0, 0) = TransitionM2(0, 0) + EmissionM2(RecodeB(0), 0)
    'LaticeXY(0, 1) = TransitionM2(1, 1) + EmissionM2(RecodeB(0), 1)
'If X = X Then
    Dummy = ForwardCP(SLen, NumberABC, NumberXY, ValXY(0), OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0))
'Else
'    For X = 1 To SLen
'        'For Y = 0 To UBound(TransitionM2, 1)
'            'If RecodeB(X) = 0 Then
'
'            For A = 0 To NumberXY - 1 'first state
'                For B = 0 To NumberXY - 1 'second state
'                    OptXY(A, B) = LaticeXY(X - 1, A) + TransitionM2(A, B) + EmissionM2(RecodeB(X), B) 'general
'
'
'                    'OptXY(0, 0) = LaticeXY(X - 1, 0) + TransitionM2(0, 0) + EmissionM2(RecodeB(X), 0) 'x going to x
'                    'OptXY(1, 0) = LaticeXY(X - 1, 1) + TransitionM2(1, 0) + EmissionM2(RecodeB(X), 0) 'y going to x
'                   '
'                   ' OptXY(0, 1) = LaticeXY(X - 1, 0) + TransitionM2(0, 1) + EmissionM2(RecodeB(X), 1) 'x going to y
'                   ' OptXY(1, 1) = LaticeXY(X - 1, 1) + TransitionM2(1, 1) + EmissionM2(RecodeB(X), 1) 'y going to y
'
'                Next B
'            Next A
'
'            For A = 0 To NumberXY - 1
'                ValXY(A) = 0
'            Next A
'
'            For A = 0 To NumberXY - 1
'                MinV = -10 ^ 22
'                For B = 0 To NumberXY - 1 '
'                    If MinV < OptXY(B, A) Then
'                        MinV = OptXY(B, A)
'                    End If
'                Next B
'
'                LaticeXY(X, A) = 0
'                For B = 0 To NumberXY - 1 '
'                    ValXY(B) = OptXY(B, A) - MinV
'                    ValXY(B) = Exp(ValXY(B))
'                    LaticeXY(X, A) = LaticeXY(X, A) + ValXY(B)
'                    X = X
'                Next B
'                LaticeXY(X, A) = Log(LaticeXY(X, A))
'                LaticeXY(X, A) = LaticeXY(X, A) + MinV
'                X = X
'            Next A
'
'    Next X
'
'End If


'XX = LaticeXY(SLen - 1, 1)
'XX = LaticeXY(SLen - 1, 0)

End Sub
Public Sub Viterbi(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Double, LaticeAB() As Double, TransitionM2() As Double, EmissionM2() As Double, InitP() As Double)

Dim Dummy As Long, x As Long, OptXY() As Double
ReDim OptXY(NumberXY - 1, NumberXY - 1)
'@
ReDim LaticeAB(SLen, NumberXY - 1)

ReDim LaticeXY(SLen, NumberXY - 1)
For x = 0 To NumberXY - 1
    LaticeXY(0, x) = EmissionM2(RecodeB(0), x) + InitP(x) '-4.499,-1.167,-4.499,-3.754
    x = x
Next x
    

'@'@'@'@
    Dummy = ViterbiCP(SLen, NumberABC, NumberXY, OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0), LaticeAB(0, 0))

x = x
End Sub
Public Sub ViterbiF(NumberABC As Long, NumberXY As Long, SLen As Long, RecodeB() As Byte, LaticeXY() As Single, LaticeAB() As Single, TransitionM2() As Single, EmissionM2() As Single, InitP() As Single)

Dim Dummy As Long, x As Long, OptXY() As Single
ReDim OptXY(NumberXY - 1, NumberXY - 1)
'@
ReDim LaticeAB(SLen, NumberXY - 1)

ReDim LaticeXY(SLen, NumberXY - 1)
For x = 0 To NumberXY - 1
    LaticeXY(0, x) = EmissionM2(RecodeB(0), x) + InitP(x) '-2.9957, -1.386
Next x
    

'@'@'@'@
    Dummy = ViterbiCPF(SLen, NumberABC, NumberXY, OptXY(0, 0), RecodeB(0), LaticeXY(0, 0), TransitionM2(0, 0), EmissionM2(0, 0), LaticeAB(0, 0))

x = x
End Sub
Public Sub FastDistanceCalc3(NextNo As Long, PermDIffs() As Single, PermValid() As Single, SeqNum() As Integer, Distance() As Single, AvDst As Double, Udst As Double)

Dim D As Byte, W As Byte, NumSeq() As Byte, ConvNumSeq(255) As Byte, PositionA As Long, PositionB As Long, CompressValid() As Byte, CompressDiffs() As Byte
ReDim CompressValid(625, 625), CompressDiffs(625, 625)
Dim A As Long, b As Long
Position = -1
SS = Abs(GetTickCount)
'convert the sequences into a 0 to 4 string
ConvNumSeq(66) = 1
ConvNumSeq(68) = 2
ConvNumSeq(72) = 3
ConvNumSeq(85) = 4

'This is used to encode the nucleotides in the following way:
'0=-
'1=A
'2=C
'3=G
'4=t

ReDim NumSeq(Len(StrainSeq(0)), NextNo)
For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        NumSeq(Y, x) = ConvNumSeq(SeqNum(Y, x))
    Next Y
Next x
EE = Abs(GetTickCount)
TT = EE - SS
'0.5 seconds with 1200 3kb sequences

Dim SeqCompressor(4, 4, 4) As Integer


'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns
PositionA = -1
SS = Abs(GetTickCount)
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            'For D = 0 To 4
                
                PositionA = PositionA + 1
                SeqCompressor(A, b, C) = PositionA
                
                
                PositionB = -1
                For W = 0 To 4
                    For x = 0 To 4
                        For Y = 0 To 4
                           ' For Z = 0 To 4
                                
                                PositionB = PositionB + 1
                                If A <> 0 Then
                                    If W <> 0 Then
                                        CompressValid(PositionA, PositionB) = CompressValid(PositionA, PositionB) + 1
                                        If A <> W Then
                                            CompressDiffs(PositionA, PositionB) = CompressDiffs(PositionA, PositionB) + 1
                                        End If
                                    End If
                                End If
                                If b <> 0 Then
                                    If x <> 0 Then
                                        CompressValid(PositionA, PositionB) = CompressValid(PositionA, PositionB) + 1
                                        If b <> x Then
                                            CompressDiffs(PositionA, PositionB) = CompressDiffs(PositionA, PositionB) + 1
                                        End If
                                    End If
                                End If
                                If C <> 0 Then
                                    If Y <> 0 Then
                                        CompressValid(PositionA, PositionB) = CompressValid(PositionA, PositionB) + 1
                                        If C <> Y Then
                                            CompressDiffs(PositionA, PositionB) = CompressDiffs(PositionA, PositionB) + 1
                                        End If
                                    End If
                                End If
                                
                                'CompressValid(PositionB, PositionA) = CompressValid(PositionA, PositionB)
                                'CompressDiffs(PositionB, PositionA) = CompressDiffs(PositionA, PositionB)
                                       
                           ' Next Z
                        Next Y
                    Next x
                Next W

                    
            'Next D
        Next C
    Next b
Next A


'0.2 seconds with 1200 3kb sequences
SS = Abs(GetTickCount)

ReDim ISeq3(CLng(Len(StrainSeq(0)) / 3) + 1, NextNo)
'compress the alignment
Dim StepPos As Long

For x = 0 To NextNo
    StepPos = 0
    For Y = 1 To Len(StrainSeq(0)) - 3 Step 3
        StepPos = StepPos + 1
        A = NumSeq(Y, x)
        b = NumSeq(Y + 1, x)
        C = NumSeq(Y + 2, x)
       
        ISeq3(StepPos, x) = SeqCompressor(A, b, C)
    Next Y
    StepPos = StepPos + 1
    A = 0
    b = 0
    C = 0
    
    If Y <= UBound(SeqNum, 1) Then
        A = NumSeq(Y, x)
        If Y + 1 <= UBound(SeqNum, 1) Then
            b = NumSeq(Y + 1, x)
            If Y + 2 <= UBound(SeqNum, 1) Then
                C = NumSeq(Y + 2, x)
            'Else
            '    C = 0
            End If
        'Else
            'B = 0
            'C = 0
        End If
    'Else
    '    A = 0
    '    B = 0
    '    C = 0
    End If
    ISeq3(StepPos, x) = SeqCompressor(A, b, C)
Next x

Dim DistCheckA() As Double, DistCheckB() As Double

EE = Abs(GetTickCount)
TT = EE - SS
SS = Abs(GetTickCount) 'EE - SS
'0.5 seconds with 1200 sequences

Dim VV As Byte, DV As Byte, dX As Double

EE = Abs(GetTickCount)
TT = EE - SS
    
   
    UBX = UBound(ISeq3)
    Dim XCVal() As Integer
    ReDim XCVal(UBX)
    
       
    SS = Abs(GetTickCount)
    Dim tRedoDist() As Integer
    ReDim tRedoDist(NextNo)
    For x = 0 To NextNo
            tRedoDist(x) = 1
    Next x
    
    
    
    
    Udst = FastSimilarityA(UBound(ISeq3, 1), NextNo, UBX, AvDst, PermDIffs(0, 0), PermValid(0, 0), XCVal(0), ISeq3(0, 0), CompressValid(0, 0), CompressDiffs(0, 0), Distance(0, 0), tRedoDist(0))
    
   
    
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    x = x '' X '67937 on 903 sequences'51259 using a nnd b, 50672 - not querying ubound every time,43875 45406 - only adding to diffs when b <> c' 55.105 with a as the outside loop
'35.407 - withxcval 3.844 with fastdista, 3.453-with ints rather than doubles
'12.5 seconds with 1200 3kb sequences


End Sub


Public Sub MakeSeqCompressor4()

'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns

Dim PositionA As Long, PositionB As Long, A As Byte, b As Byte, C As Byte, D As Byte, W As Byte, x As Byte, Y As Byte, Z As Byte
PositionA = -1
'SS = Abs(GetTickCount)
ReDim BinConverter4(1024, 1024)
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            For D = 0 To 4
                
                PositionA = PositionA + 1
                SeqCompressor4(A, b, C, D) = PositionA
                
                
                PositionB = -1
                For W = 0 To 4
                    For x = 0 To 4
                        For Y = 0 To 4
                            For Z = 0 To 4
'                                If A = 4 And B = 2 And C = 1 And D = 0 And W = 4 And X = 2 And Y = 4 And Z = 0 Then
'                                    X = X
'                                End If
                                PositionB = PositionB + 1
'                                If PositionA = 111 And PositionB = 114 Then
'                                    X = X
'                                End If
                                If A <> 0 Then
                                    If W <> 0 Then
                                        CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If A <> W Then
                                            CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 64
                                        End If
                                    Else
                                        BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 128
                                    End If
                                Else
                                    BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 128
                                End If
                                If b <> 0 Then
                                    If x <> 0 Then
                                        CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If b <> x Then
                                            CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 16
                                       End If
                                    Else
                                        BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 32
                                    End If
                                Else
                                    BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 32
                                End If
                                If C <> 0 Then
                                    If Y <> 0 Then
                                        CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If C <> Y Then
                                            CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 4
                                        End If
                                   Else
                                        BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 8
                                    End If
                                Else
                                    BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 8
                                End If
                                If D <> 0 Then
                                    If Z <> 0 Then
                                        CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If D <> Z Then
                                            CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 1
                                        End If
                                    Else
                                        BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 2
                                    End If
                                Else
                                    BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 2
                                End If
                                'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                 x = x
                            Next Z
                        Next Y
                    Next x
                Next W

                    
            Next D
        Next C
    Next b
Next A
'EE = Abs(GetTickCount)
'TT = EE - SS


End Sub

Public Sub MakeSeqCompressor3b()

'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns

Dim PositionA As Long, PositionB As Long, A As Byte, b As Byte, C As Byte, D As Byte, W As Byte, x As Byte, Y As Byte, Z As Byte
PositionA = -1
'SS = Abs(GetTickCount)
ReDim BinConverter3(125, 125)
'For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            For D = 0 To 4
                
                PositionA = PositionA + 1
                SeqCompressor3(b, C, D) = PositionA
                
                
                PositionB = -1
                'For W = 0 To 4
                    For x = 0 To 4
                        For Y = 0 To 4
                            For Z = 0 To 4
'                                If B = 4 And C = 2 And D = 1 And X = 4 And Y = 2 And Z = 4 Then
'                                    X = X
'                                End If
                                PositionB = PositionB + 1
'                                If PositionA = 111 And PositionB = 114 Then
'                                    X = X
'                                End If
                                
                                If b <> 0 Then
                                    If x <> 0 Then
                                        'CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If b <> x Then
                                            'CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 16
                                       End If
                                    Else
                                        BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 32
                                    End If
                                Else
                                    BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 32
                                End If
                                If C <> 0 Then
                                    If Y <> 0 Then
                                        'CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If C <> Y Then
                                            'CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 4
                                        End If
                                   Else
                                        BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 8
                                    End If
                                Else
                                    BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 8
                                End If
                                If D <> 0 Then
                                    If Z <> 0 Then
                                        'CompressValid3(PositionA, PositionB) = CompressValid3(PositionA, PositionB) + 1
                                        If D <> Z Then
                                            'CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                            BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 1
                                        End If
                                    Else
                                        BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 2
                                    End If
                                Else
                                    BinConverter3(PositionA, PositionB) = BinConverter3(PositionA, PositionB) + 2
                                End If
                                'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                 x = x
                            Next Z
                        Next Y
                    Next x
                'Next W

                    
            Next D
        Next C
    Next b
'Next A
'EE = Abs(GetTickCount)
'TT = EE - SS


End Sub

Public Sub MakeBinCompressor4()
Exit Sub
'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns

Dim PositionA As Long, PositionB As Long, A As Byte, b As Byte, C As Byte, D As Byte, W As Byte, x As Byte, Y As Byte, Z As Byte
PositionA = -1
SS = Abs(GetTickCount)
ReDim BinConverter4(625, 625)
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            For D = 0 To 4
                
                PositionA = PositionA + 1
                SeqCompressor4(A, b, C, D) = PositionA
                
                
                PositionB = -1
                For W = 0 To 4
                    For x = 0 To 4
                        For Y = 0 To 4
                            For Z = 0 To 4
                                
                                PositionB = PositionB + 1
                                If A <> 0 Then
                                    If W <> 0 Then
                                        
                                        If A <> W Then
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 64
                                        End If
                                    End If
                                End If
                                If b <> 0 Then
                                    If x <> 0 Then
                                        
                                        If b <> x Then
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 16
                                        End If
                                    End If
                                End If
                                If C <> 0 Then
                                    If Y <> 0 Then
                                        
                                        If C <> Y Then
                                            BinConverter4(PositionA, PositionB) = BinConverter4(PositionA, PositionB) + 16
                                        End If
                                    End If
                                End If
                                If D <> 0 Then
                                    If Z <> 0 Then
                                        CompressValid4(PositionA, PositionB) = CompressValid4(PositionA, PositionB) + 1
                                        If D <> Z Then
                                            CompressDiffs4(PositionA, PositionB) = CompressDiffs4(PositionA, PositionB) + 1
                                        End If
                                    End If
                                End If
                                'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                       
                            Next Z
                        Next Y
                    Next x
                Next W

                    
            Next D
        Next C
    Next b
Next A
EE = Abs(GetTickCount)
TT = EE - SS


End Sub
Public Sub MakeSeqCompressor3()

'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns

Dim PositionA As Long, PositionB As Long, PositionC As Long, A As Long, b As Long, C As Long, D As Long, W As Long, x As Long, Y As Long, Z As Long, L As Long, M As Long, n As Long



PositionA = -1
SS = Abs(GetTickCount)
ReDim FindSS0(125, 125, 125, 5)
'ReDim SeqCompressor3(4, 4, 4)
ReDim BinConverter3(125, 125)
ReDim SkipTrip(125, 125, 125)
'Nogaps - FindSS0
For A = 0 To 4
    For b = 0 To 4
        For C = 0 To 4
            'For D = 0 To 4
                
                PositionA = PositionA + 1
                SeqCompressor3(A, b, C) = PositionA
                
                
                PositionB = -1
                For W = 0 To 4
                    For x = 0 To 4
                        For Y = 0 To 4
                            'For Z = 0 To 4
                                
                                PositionB = PositionB + 1
                                
                                
                                PositionC = -1
                                For L = 0 To 4
                                    For M = 0 To 4
                                        For n = 0 To 4
                                
                                            PositionC = PositionC + 1
                                            If A <> 0 Then
                                                If W <> 0 Then
                                                    If L <> 0 Then
                                                        
                                                        If A = W And A <> L Then
                                                            FindSS0(PositionA, PositionB, PositionC, 0) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 1) = 0
                                                        ElseIf A = L And A <> W Then
                                                            FindSS0(PositionA, PositionB, PositionC, 0) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 1) = 1
                                                        ElseIf A <> W And W = L Then
                                                            FindSS0(PositionA, PositionB, PositionC, 0) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 1) = 2
                                                        
                                                        Else
                                                        
                                                        End If
                                                    End If
                                                End If
                                            End If
                                            
                                            If b <> 0 Then
                                                If x <> 0 Then
                                                    If M <> 0 Then
                                                        
                                                        If b = x And b <> M Then
                                                            FindSS0(PositionA, PositionB, PositionC, 2) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 3) = 0
                                                        ElseIf b = M And b <> x Then
                                                            FindSS0(PositionA, PositionB, PositionC, 2) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 3) = 1
                                                        ElseIf b <> x And x = M Then
                                                            FindSS0(PositionA, PositionB, PositionC, 2) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 3) = 2
                                                        End If
                                                    End If
                                                End If
                                            End If
                                            
                                            If C <> 0 Then
                                                If Y <> 0 Then
                                                    If n <> 0 Then
                                                        
                                                        If C = Y And C <> n Then
                                                            FindSS0(PositionA, PositionB, PositionC, 4) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 5) = 0
                                                        ElseIf C = n And C <> Y Then
                                                            FindSS0(PositionA, PositionB, PositionC, 4) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 5) = 1
                                                        ElseIf C <> Y And Y = n Then
                                                            FindSS0(PositionA, PositionB, PositionC, 4) = 1 'increase subseq by 1
                                                            FindSS0(PositionA, PositionB, PositionC, 5) = 2
                                                        End If
                                                    End If
                                                End If
                                            End If
                                            SkipTrip(PositionA, PositionB, PositionC) = FindSS0(PositionA, PositionB, PositionC, 0) + FindSS0(PositionA, PositionB, PositionC, 2) + FindSS0(PositionA, PositionB, PositionC, 4)
                                        Next n
                                    Next M
                                Next L
                                       
                            'Next Z
                        Next Y
                    Next x
                Next W

                    
            'Next D
        Next C
    Next b
Next A





EE = Abs(GetTickCount)
TT = EE - SS '1.656

x = x
End Sub
Public Sub MakeIntegerSeq3()
Dim NucMatB() As Byte, NucMat() As Byte, x As Long, Z As Long, Y As Long
ReDim NucMatB(4)

ReDim NucMat(100)


NucMat(66) = 1
NucMat(68) = 2
NucMat(72) = 3
NucMat(85) = 4


NucMatB(1) = 66
NucMatB(2) = 68
NucMatB(3) = 72
NucMatB(4) = 85

'convert nts into integers between 0 and 4

ReDim IntegerSeq3(Len(StrainSeq(0)) + 3, NextNo)

For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        IntegerSeq3(Y, x) = NucMat(SeqNum(Y, x))
    Next Y
Next x





ReDim CompressedSeqs3(Len(StrainSeq(0)) / 3 + 3, NextNo)
For x = 0 To NextNo
    Z = 0
    For Y = 1 To Len(StrainSeq(0)) Step 3
        Z = Z + 1
        CompressedSeqs3(Z, x) = SeqCompressor3(IntegerSeq3(Y, x), IntegerSeq3(Y + 1, x), IntegerSeq3(Y + 2, x))
    Next Y
Next x
For x = Z + 1 To UBound(CompressedSeqs3, 1)
    For Y = 0 To NextNo
        CompressedSeqs3(Z, Y) = 0
    Next Y
Next x

End Sub

Public Function FindSubSeqPVB(XoverWindow As Long, A As Long, b As Long, C As Long, XoverSeqNumW() As Byte, AH() As Long, XDP() As Long, XPD() As Long)
Dim Z As Long, Y As Long, V1 As Long, V2 As Long, V3 As Long, YV As Long, FS1 As Long, SkipT As Long
    'UBX = Len(StrainSeq(0)) + XoverWindow * 2
    'UB = UBound(XoverSeqNumW, 1)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    Z = 0
    For Y = 1 To UBound(CompressedSeqs3, 1)
        V1 = CompressedSeqs3(Y, A)
        V2 = CompressedSeqs3(Y, b)
        V3 = CompressedSeqs3(Y, C)
        SkipT = SkipTrip(V1, V2, V3)
        YV = (Y - 1) * 3 + 1
        If SkipT > 0 Then
           
            
            If FindSS0(V1, V2, V3, 0) = 1 Then
                Z = Z + 1
                FS1 = FindSS0(V1, V2, V3, 1)
                AH(FS1) = AH(FS1) + 1
                XoverSeqNumW(Z + XoverWindow, FS1) = 1
                XDP(Z) = YV
                SkipT = SkipT - 1
                
            End If
            'YV = YV + 1
            XPD(YV) = Z
            If SkipT > 0 Then
                If FindSS0(V1, V2, V3, 2) = 1 Then
                    Z = Z + 1
                    FS1 = FindSS0(V1, V2, V3, 3)
                    AH(FS1) = AH(FS1) + 1
                    XoverSeqNumW(Z + XoverWindow, FS1) = 1
                     XDP(Z) = YV + 1
                     SkipT = SkipT - 1
                     'XPD(YV) = Z
                End If
                'YV = YV + 1
                XPD(YV + 1) = Z
                If SkipT > 0 Then
                    'If FindSS0(V1, V2, V3, 4) = 1 Then
                        Z = Z + 1
                        FS1 = FindSS0(V1, V2, V3, 5)
                        AH(FS1) = AH(FS1) + 1
                        XoverSeqNumW(Z + XoverWindow, FS1) = 1
                        XDP(Z) = YV + 2
                         'XPD(YV) = Z
                    'End If
                End If
                XPD(YV + 2) = Z
            Else
              XPD(YV + 1) = Z
              XPD(YV + 2) = Z
            End If
        Else
            XPD(YV) = Z
            XPD(YV + 1) = Z
            XPD(YV + 2) = Z
        End If
      
        
    Next Y
    If x = x Then
        Dim WMX As Long
        Dim WPX As Long
        WMX = Z - XoverWindow
        WPX = Z + XoverWindow
        For Y = 1 To XoverWindow
            WMX = WMX + 1
            WPX = WPX + 1
            XoverSeqNumW(Y, 0) = XoverSeqNumW(WMX + XoverWindow, 0)
            XoverSeqNumW(Y, 1) = XoverSeqNumW(WMX + XoverWindow, 1)
            XoverSeqNumW(Y, 2) = XoverSeqNumW(WMX + XoverWindow, 2)
    
            XoverSeqNumW(WPX, 0) = XoverSeqNumW(Y + XoverWindow, 0)  '';//XOverSeqNum(X, 0)
            XoverSeqNumW(WPX, 1) = XoverSeqNumW(Y + XoverWindow, 1)
            XoverSeqNumW(WPX, 2) = XoverSeqNumW(Y + XoverWindow, 2)
        Next Y
    End If
    FindSubSeqPVB = Z
End Function

Public Sub MakeSeqCompressors()

'Much of this will be moved outside this routine
'work out the distances between the 625 possible 4nt long nt patterns

Dim GoOn As Long, FF As Long, oDirX As String, PositionA As Long, PositionB As Long, A As Byte, b As Byte, C As Byte, D As Byte, W As Byte, x As Byte, Y As Byte, Z As Byte
Dim e As Byte, F As Byte, g As Byte, H As Byte, i As Byte, j As Byte
Dim V As Byte, U As Byte, T As Byte, S As Byte, r As Byte, Q As Byte
'SS = Abs(GetTickCount)




'Public CompressValid11(1024, 1024) As Byte, CompressDiffs11(1024, 1024) As Byte
'Public CompressValid02(1024, 1024) As Byte, CompressDiffs02(1024, 1024) As Byte
'Public CompressValid12(729, 729) As Byte, CompressDiffs12(729, 729) As Byte
'Public CompressValid03(729, 729) As Byte, CompressDiffs03(729, 729) As Byte
'Public CompressValid13(1024, 1024) As Byte, CompressDiffs13(1024, 1024) As Byte
'Public CompressValid04(1024, 1024) As Byte, CompressDiffs04(1024, 1024) As Byte
'Public CompressValid14(625, 625) As Byte, CompressDiffs14(625, 625) As Byte
'
'Public SeqCompressor11(1, 1, 1, 1, 1, 1, 1, 1, 1, 1) As Integer, SeqCompressor02(1, 1, 1, 1, 1, 1, 1, 1, 1, 1) As Integer
'Public SeqCompressor03(2, 2, 2, 2, 2, 2) As Integer, SeqCompressor12(2, 2, 2, 2, 2, 2) As Integer
'Public SeqCompressor13(3, 3, 3, 3, 3) As Integer, SeqCompressor04(3, 3, 3, 3, 3) As Integer
'Public SeqCompressor14(4, 4, 4, 4) As Integer



oDirX = CurDir
ChDrive App.Path
ChDir App.Path
FF = FreeFile
Open "SCF" For Binary As #FF
If LOF(FF) > 100 Then
    Get #FF, , CompressValid11
    Get #FF, , CompressDiffs11
    Get #FF, , CompressValid02
    Get #FF, , CompressDiffs02
    Get #FF, , CompressValid12
    Get #FF, , CompressDiffs12
    Get #FF, , CompressValid03
    Get #FF, , CompressDiffs03
    Get #FF, , CompressValid13
    Get #FF, , CompressDiffs13
    Get #FF, , CompressValid04
    Get #FF, , CompressDiffs04
    Get #FF, , CompressValid14
    Get #FF, , CompressDiffs14
    Get #FF, , SeqCompressor11
    Get #FF, , SeqCompressor02
    Get #FF, , SeqCompressor12
    Get #FF, , SeqCompressor03
    Get #FF, , SeqCompressor13
    Get #FF, , SeqCompressor04
    Get #FF, , SeqCompressor14
Else
    GoOn = 1
End If
Close #FF

ChDrive oDirX
ChDir oDirX

If GoOn = 1 Then
    PositionA = -1
    '14
    For A = 0 To 4
        For b = 0 To 4
            For C = 0 To 4
                For D = 0 To 4
                    PositionA = PositionA + 1
                    SeqCompressor14(A, b, C, D) = PositionA
                    PositionB = -1
                    If PositionA = 525 Then
                        x = x
                    End If
                    For W = 0 To 4
                        For x = 0 To 4
                            For Y = 0 To 4
                                For Z = 0 To 4
                                    PositionB = PositionB + 1
                                    If A <> 0 Then
                                                If W <> 0 Then
                                                    CompressValid14(PositionA, PositionB) = CompressValid14(PositionA, PositionB) + 1
                                                    If A <> W Then
                                                        CompressDiffs14(PositionA, PositionB) = CompressDiffs14(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If b <> 0 Then
                                                If x <> 0 Then
                                                    CompressValid14(PositionA, PositionB) = CompressValid14(PositionA, PositionB) + 1
                                                    If b <> x Then
                                                        CompressDiffs14(PositionA, PositionB) = CompressDiffs14(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If C <> 0 Then
                                                If Y <> 0 Then
                                                    CompressValid14(PositionA, PositionB) = CompressValid14(PositionA, PositionB) + 1
                                                    If C <> Y Then
                                                        CompressDiffs14(PositionA, PositionB) = CompressDiffs14(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If D <> 0 Then
                                                If Z <> 0 Then
                                                    CompressValid14(PositionA, PositionB) = CompressValid14(PositionA, PositionB) + 1
                                                    If D <> Z Then
                                                        CompressDiffs14(PositionA, PositionB) = CompressDiffs14(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                    'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                    'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                           
                                Next Z
                            Next Y
                        Next x
                    Next W
    
                        
                Next D
            Next C
        Next b
    Next A
    
    ' 13
    PositionA = -1
    For A = 0 To 3
        For b = 0 To 3
            For C = 0 To 3
                For D = 0 To 3
                    For e = 0 To 3
                        PositionA = PositionA + 1
                        SeqCompressor13(A, b, C, D, e) = PositionA
                        PositionB = -1
                        For V = 0 To 3
                            For W = 0 To 3
                                For x = 0 To 3
                                    For Y = 0 To 3
                                        For Z = 0 To 3
                                            PositionB = PositionB + 1
                                            If A <> 0 Then
                                                If V <> 0 Then
                                                    CompressValid13(PositionA, PositionB) = CompressValid13(PositionA, PositionB) + 1
                                                    If A <> V Then
                                                        CompressDiffs13(PositionA, PositionB) = CompressDiffs13(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If b <> 0 Then
                                                If W <> 0 Then
                                                    CompressValid13(PositionA, PositionB) = CompressValid13(PositionA, PositionB) + 1
                                                    If b <> W Then
                                                        CompressDiffs13(PositionA, PositionB) = CompressDiffs13(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If C <> 0 Then
                                                If x <> 0 Then
                                                    CompressValid13(PositionA, PositionB) = CompressValid13(PositionA, PositionB) + 1
                                                    If C <> x Then
                                                        CompressDiffs13(PositionA, PositionB) = CompressDiffs13(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If D <> 0 Then
                                                If Y <> 0 Then
                                                    CompressValid13(PositionA, PositionB) = CompressValid13(PositionA, PositionB) + 1
                                                    If D <> Y Then
                                                        CompressDiffs13(PositionA, PositionB) = CompressDiffs13(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            If e <> 0 Then
                                                If Z <> 0 Then
                                                    CompressValid13(PositionA, PositionB) = CompressValid13(PositionA, PositionB) + 1
                                                    If e <> Z Then
                                                        CompressDiffs13(PositionA, PositionB) = CompressDiffs13(PositionA, PositionB) + 1
                                                    End If
                                                End If
                                            End If
                                            
                                            'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                            'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                                   
                                        Next Z
                                    Next Y
                                Next x
                            Next W
                        Next V
                    Next e
                Next D
            Next C
        Next b
    Next A
    
    ' 04
    PositionA = -1
    For A = 0 To 3
        For b = 0 To 3
            For C = 0 To 3
                For D = 0 To 3
                    For e = 0 To 3
                        PositionA = PositionA + 1
                        SeqCompressor04(A, b, C, D, e) = PositionA
                        PositionB = -1
                        For V = 0 To 3
                            For W = 0 To 3
                                For x = 0 To 3
                                    For Y = 0 To 3
                                        For Z = 0 To 3
                                            PositionB = PositionB + 1
                                            'CompressValid04(PositionA, PositionB) = CompressValid04(PositionA, PositionB) + 1
                                            If A <> V Then
                                                CompressDiffs04(PositionA, PositionB) = CompressDiffs04(PositionA, PositionB) + 1
                                            End If
                                            'CompressValid04(PositionA, PositionB) = CompressValid04(PositionA, PositionB) + 1
                                            If b <> W Then
                                                CompressDiffs04(PositionA, PositionB) = CompressDiffs04(PositionA, PositionB) + 1
                                            End If
                                            'CompressValid04(PositionA, PositionB) = CompressValid04(PositionA, PositionB) + 1
                                            If C <> x Then
                                                CompressDiffs04(PositionA, PositionB) = CompressDiffs04(PositionA, PositionB) + 1
                                            End If
                                            'CompressValid04(PositionA, PositionB) = CompressValid04(PositionA, PositionB) + 1
                                            If D <> Y Then
                                                CompressDiffs04(PositionA, PositionB) = CompressDiffs04(PositionA, PositionB) + 1
                                            End If
                                            'CompressValid04(PositionA, PositionB) = CompressValid04(PositionA, PositionB) + 1
                                            If e <> Z Then
                                                CompressDiffs04(PositionA, PositionB) = CompressDiffs04(PositionA, PositionB) + 1
                                            End If
                                            
                                        Next Z
                                    Next Y
                                Next x
                            Next W
                        Next V
                    Next e
                Next D
            Next C
        Next b
    Next A
    
    ' 12
    PositionA = -1
    For A = 0 To 2
        For b = 0 To 2
            For C = 0 To 2
                For D = 0 To 2
                    For e = 0 To 2
                        For F = 0 To 2
                            PositionA = PositionA + 1
                            SeqCompressor12(A, b, C, D, e, F) = PositionA
                            PositionB = -1
                            For U = 0 To 2
                                For V = 0 To 2
                                    For W = 0 To 2
                                        For x = 0 To 2
                                            For Y = 0 To 2
                                                For Z = 0 To 2
                                                    PositionB = PositionB + 1
                                                    If A <> 0 Then
                                                        If U <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If A <> U Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    If b <> 0 Then
                                                        If V <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If b <> V Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    If C <> 0 Then
                                                        If W <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If C <> W Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    If D <> 0 Then
                                                        If x <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If D <> x Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    If e <> 0 Then
                                                        If Y <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If Y <> e Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    If F <> 0 Then
                                                        If Z <> 0 Then
                                                            CompressValid12(PositionA, PositionB) = CompressValid12(PositionA, PositionB) + 1
                                                            If Z <> F Then
                                                                CompressDiffs12(PositionA, PositionB) = CompressDiffs12(PositionA, PositionB) + 1
                                                            End If
                                                        End If
                                                    End If
                                                    
                                                    'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                                    'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                                           
                                                Next Z
                                            Next Y
                                        Next x
                                    Next W
                                Next V
                            Next U
                        Next F
                    Next e
                Next D
            Next C
        Next b
    Next A
    
    '03
    PositionA = -1
    For A = 0 To 2
        For b = 0 To 2
            For C = 0 To 2
                For D = 0 To 2
                    For e = 0 To 2
                        For F = 0 To 2
                            PositionA = PositionA + 1
                            SeqCompressor03(A, b, C, D, e, F) = PositionA
                            PositionB = -1
                            For U = 0 To 2
                                For V = 0 To 2
                                    For W = 0 To 2
                                        For x = 0 To 2
                                            For Y = 0 To 2
                                                For Z = 0 To 2
                                                    PositionB = PositionB + 1
    '                                                If A <> 0 Then
    '                                                    If U <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If A <> U Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
    '                                                If B <> 0 Then
    '                                                    If V <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If b <> V Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
    '                                                If C <> 0 Then
    '                                                    If W <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If C <> W Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
    '                                                If D <> 0 Then
    '                                                    If X <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If D <> x Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
    '                                                If E <> 0 Then
    '                                                    If Y <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If Y <> e Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
    '                                                If F <> 0 Then
    '                                                    If Z <> 0 Then
                                                            CompressValid03(PositionA, PositionB) = CompressValid03(PositionA, PositionB) + 1
                                                            If Z <> F Then
                                                                CompressDiffs03(PositionA, PositionB) = CompressDiffs03(PositionA, PositionB) + 1
                                                            End If
    '                                                    End If
    '                                                End If
                                                    
                                                    'CompressValid4(PositionB, PositionA) = CompressValid4(PositionA, PositionB)
                                                    'CompressDiffs4(PositionB, PositionA) = CompressDiffs4(PositionA, PositionB)
                                                           
                                                Next Z
                                            Next Y
                                        Next x
                                    Next W
                                Next V
                            Next U
                        Next F
                    Next e
                Next D
            Next C
        Next b
    Next A
'    EE = Abs(GetTickCount)
'    TT = EE - SS
    
    
    ' 11
    PositionA = -1
    For A = 0 To 1
        For b = 0 To 1
            For C = 0 To 1
                For D = 0 To 1
                    For e = 0 To 1
                        For F = 0 To 1
                            For g = 0 To 1
                                For H = 0 To 1
                                    For i = 0 To 1
                                        For j = 0 To 1
                                            PositionA = PositionA + 1
                                            SeqCompressor11(A, b, C, D, e, F, g, H, i, j) = PositionA
                                            PositionB = -1
                                            For U = 0 To 1
                                                For V = 0 To 1
                                                    For W = 0 To 1
                                                        For x = 0 To 1
                                                            For Y = 0 To 1
                                                                For Z = 0 To 1
                                                                    For Q = 0 To 1
                                                                        For r = 0 To 1
                                                                            For S = 0 To 1
                                                                                For T = 0 To 1
                                                                                    PositionB = PositionB + 1
'                                                                                    If PositionA = 876 And PositionB = 950 Then
'                                                                                        X = X
'                                                                                    End If
'                                                                                    If PositionB = 876 And PositionA = 950 Then
'                                                                                        X = X
'                                                                                    End If
                                                                                    If A <> 0 Then
                                                                                        If U <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If A <> U Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If b <> 0 Then
                                                                                        If V <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If b <> V Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If C <> 0 Then
                                                                                        If W <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If C <> W Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If D <> 0 Then
                                                                                        If x <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If D <> x Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If e <> 0 Then
                                                                                        If Y <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If Y <> e Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If F <> 0 Then
                                                                                        If Z <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If Z <> F Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If g <> 0 Then
                                                                                        If Q <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If g <> Q Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If H <> 0 Then
                                                                                        If r <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If H <> r Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If i <> 0 Then
                                                                                        If S <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If i <> S Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                                    If j <> 0 Then
                                                                                        If T <> 0 Then
                                                                                            CompressValid11(PositionA, PositionB) = CompressValid11(PositionA, PositionB) + 1
                                                                                            If j <> T Then
                                                                                                CompressDiffs11(PositionA, PositionB) = CompressDiffs11(PositionA, PositionB) + 1
                                                                                            End If
                                                                                        End If
                                                                                    End If
                                                                    
                                                                                Next T
                                                                            Next S
                                                                        Next r
                                                                    Next Q
                                                                Next Z
                                                            Next Y
                                                        Next x
                                                    Next W
                                                Next V
                                            Next U
                                        Next j
                                    Next i
                                Next H
                            Next g
                        Next F
                    Next e
                Next D
            Next C
        Next b
    Next A
    
    ' 02
    PositionA = -1
    For A = 0 To 1
        For b = 0 To 1
            For C = 0 To 1
                For D = 0 To 1
                    For e = 0 To 1
                        For F = 0 To 1
                            For g = 0 To 1
                                For H = 0 To 1
                                    For i = 0 To 1
                                        For j = 0 To 1
                                            PositionA = PositionA + 1
                                            SeqCompressor02(A, b, C, D, e, F, g, H, i, j) = PositionA
                                            PositionB = -1
                                            For U = 0 To 1
                                                For V = 0 To 1
                                                    For W = 0 To 1
                                                        For x = 0 To 1
                                                            For Y = 0 To 1
                                                                For Z = 0 To 1
                                                                    For Q = 0 To 1
                                                                        For r = 0 To 1
                                                                            For S = 0 To 1
                                                                                For T = 0 To 1
                                                                                    PositionB = PositionB + 1
    '                                                                                If A <> 0 Then
    '                                                                                    If U <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If A <> U Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If B <> 0 Then
    '                                                                                    If V <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If b <> V Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If C <> 0 Then
    '                                                                                    If W <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If C <> W Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If D <> 0 Then
    '                                                                                    If X <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If D <> x Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If E <> 0 Then
    '                                                                                    If Y <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If Y <> e Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If F <> 0 Then
    '                                                                                    If Z <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If Z <> F Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If G <> 0 Then
    '                                                                                    If Q <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If g <> Q Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If H <> 0 Then
    '                                                                                    If R <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If H <> r Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If I <> 0 Then
    '                                                                                    If S <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If i <> S Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
    '                                                                                If J <> 0 Then
    '                                                                                    If T <> 0 Then
                                                                                            CompressValid02(PositionA, PositionB) = CompressValid02(PositionA, PositionB) + 1
                                                                                            If j <> T Then
                                                                                                CompressDiffs02(PositionA, PositionB) = CompressDiffs02(PositionA, PositionB) + 1
                                                                                            End If
    '                                                                                    End If
    '                                                                                End If
                                                                    
                                                                                Next T
                                                                            Next S
                                                                        Next r
                                                                    Next Q
                                                                Next Z
                                                            Next Y
                                                        Next x
                                                    Next W
                                                Next V
                                            Next U
                                        Next j
                                    Next i
                                Next H
                            Next g
                        Next F
                    Next e
                Next D
            Next C
        Next b
    Next A
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SCF" For Binary As #FF
    
    Put #FF, , CompressValid11
    Put #FF, , CompressDiffs11
    Put #FF, , CompressValid02
    Put #FF, , CompressDiffs02
    Put #FF, , CompressValid12
    Put #FF, , CompressDiffs12
    Put #FF, , CompressValid03
    Put #FF, , CompressDiffs03
    Put #FF, , CompressValid13
    Put #FF, , CompressDiffs13
    Put #FF, , CompressValid04
    Put #FF, , CompressDiffs04
    Put #FF, , CompressValid14
    Put #FF, , CompressDiffs14
    Put #FF, , SeqCompressor11
    Put #FF, , SeqCompressor02
    Put #FF, , SeqCompressor12
    Put #FF, , SeqCompressor03
    Put #FF, , SeqCompressor13
    Put #FF, , SeqCompressor04
    Put #FF, , SeqCompressor14
    
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    
    
    
    
End If
End Sub
Public Sub SetUpNumSeq()
ReDim NumSeq(Len(StrainSeq(0)) + 1, NextNo)
Dummy = MakeNumSeq(NextNo, Len(StrainSeq(0)), UBound(NumSeq, 1), 1, Len(StrainSeq(0)), ConvNumSeq(0), SeqNum(0, 0), NumSeq(0, 0))
ReDim ISeq4(CLng(UBound(NumSeq, 1) / 4) + 1, NextNo)
Dummy = MakeISeq4(NextNo, UBound(NumSeq, 1), UBound(ISeq4, 1), SeqCompressor4(0, 0, 0, 0), ISeq4(0, 0), NumSeq(0, 0))
End Sub


Public Sub OuterScan3(MCCorrectX As Double, SAll As Long, sNextno As Long, WinPP As Long, SLookup() As Long, ISeqs() As Long, RNum() As Long, RList() As Long, TraceSub() As Long, ActualSeqSize() As Long, SLookupNum() As Long, DoPairs() As Byte, FindallFlag As Long, WinNum As Long, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno As Long, MissingData() As Byte)
Dim ZZZ As Long, UB As Long, Dummy As Long, TT As Long, PBV As Long, oTotRecs As Long, ELT As Long, ETx As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, otSeq1 As Long, otSeq2 As Long, otSeq3 As Long, WinPPY As Long, x As Long, g As Long, H As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long, b As Long
Dim A As Long, FF As Long, oDirX As String, GoOn As Byte, UBTS1 As Long
LowestProb = pLowestProb
'LT = Abs(GetTickCount)
UBTS1 = UBound(TraceSub, 1)

If PermNextno > MemPoc And (TempTreeDistanceDumpFlag = 1 Or UBound(TreeDistance, 1) <> NextNo) And x = 1234567 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim TreeDistance(UBTD1, UBTD1)
    Open "RDP5TreeDistance" + UFTag For Binary As #FF
    Get #FF, , TreeDistance
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End If

If UBound(Distance, 1) = 0 And PermNextno > MemPoc And x = 1234567 Then
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    FF = FreeFile
    'UBDistance = UBound(Distance, 1)
    XX = UBound(SCMat, 1)
    ReDim Distance(UBDistance, UBDistance)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Get #FF, , Distance()
    Close #FF
    'Erase Distance
    ChDir oDir
    ChDrive oDir

End If


If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    ReDim PermValid(UBPermValid, UBPermValid)
    Open "RDP5PermValid" + UFTag For Binary As #FF
    Get #FF, , PermValid()
    Close #FF
    
    
    ReDim PermDIffs(UBPermDiffs, UBPermDiffs)
    Open "RDP5PermDiffs" + UFTag For Binary As #FF
    Get #FF, , PermDIffs()
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
End If


If UseALFlag = 1 Then
    Dim FMatInFileFlag As Byte, UBF1 As Long, UBS1 As Long
    If TripListLen > 1000000 Then
        oDirX = CurDir
        '@
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        UBF1 = 0: UBS1 = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        UBF1 = UBound(FMat, 1)
        UBS1 = UBound(SMat, 1)
        On Error GoTo 0
        If UBS1 > 0 Then
            Open "RDP5SMat" + UFTag For Binary As #FF
            Put #FF, , SMat()
            Close #FF
            ReDim SMat(0, 0)
        End If
        If UBF1 > 0 Then
            Open "RDP5FMat" + UFTag For Binary As #FF
            Put #FF, , FMat()
            Close #FF
            ReDim FMat(0, 0)
        End If
        FMatInFileFlag = 1
    
        ReDim Preserve Analysislist(2, TripListLen)
        '@'@'@
        Open "RDP5AnalysisList" + UFTag For Binary As #FF
        Get #FF, , Analysislist
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SubValid, 1)
    On Error GoTo 0
    If UB < NextNo Then ' > LowMemThreshold Then
'            oDir = CurDir
'            ChDir App.Path
'            ChDrive App.Path
'            FF = FreeFile
        ReDim SubValid(NextNo, NextNo)
        For Z = 0 To NextNo - 1
            For Y = Z + 1 To NextNo
                SubValid(Z, Y) = 100
                SubValid(Y, Z) = 100
            Next Y
        Next Z
        
        
'            Open "RDP5SubValid" + UFTag For Binary As #FF
'            Get #FF, , SubValid()
'            Close #FF
'
'            ChDir oDir
'            ChDrive oDir
    End If
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    ReDim SubSeq(Len(StrainSeq(0)), 6)
    For x = 0 To TripListLen
    '@'@'@'@'@'@'@'@'@'@'@'@'@
        
        If Worthwhilescan(x) > 0 Or BusyWithExcludes = 1 Then
            
            CurrentTripListNum = x
            GoOn = 1
            Seq1 = Analysislist(0, x)
            '@
            If Seq1 <= UBTS1 Then
                If Seq1 > sNextno Then
                    tSeq1 = TraceSub(Seq1)
                Else
                    tSeq1 = Seq1
                End If
            Else
                GoOn = 0
            End If
            '@'@'@'@'@'@'@'@
            Seq2 = Analysislist(1, x)
            If Seq2 <= UBTS1 Then
                If Seq2 > sNextno Then
                    tSeq2 = TraceSub(Seq2)
                Else
                    tSeq2 = Seq2
                End If
            Else
                GoOn = 0
            End If
            If DoPairs(tSeq1, tSeq2) = 1 Then
                Seq3 = Analysislist(2, x)
                If Seq3 <= UBTS1 Then
                    If Seq3 > sNextno Then
                        tSeq3 = TraceSub(Seq3)
                    Else
                        tSeq3 = Seq3
                    End If
                Else
                    GoOn = 0
                End If
                
                If DoPairs(tSeq1, tSeq3) = 1 And DoPairs(tSeq2, tSeq3) = 1 Then
                    If GoOn = 1 Then
                        XX = SEventNumber
                        For WinPPY = NextNo - RNum(WinPP) To NextNo
                            A = WinPPY
                            If A > PermNextno Then
                                b = TraceSub(A)
                            Else
                                
                                b = A
                            End If
                            If Seq1 = b Or Seq2 = b Or Seq3 = b Then
                                If b = Seq1 Then
                                    Seq1 = A
                                ElseIf b = Seq2 Then
                                    Seq2 = A
                                ElseIf b = Seq3 Then
                                    Seq3 = A
                                End If
                                If ActualSeqSize(Seq1) > MinSeqSize Then
                                    If ActualSeqSize(Seq2) > MinSeqSize Then
                                        If ActualSeqSize(Seq3) > MinSeqSize Then
                                            'If SubValid(tSeq2, tSeq3) > 20 Then
                                                'XX = UBound(SubValid, 2)
                                                If SubValid(tSeq1, tSeq3) > 20 Then
                                                    If SubValid(tSeq1, tSeq2) > 20 Then
                                                             If ProgBinRead(0, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 0) = 1 Then Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                             End If
                                                             If ProgBinRead(1, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 1) = 1 Then Call GCXoverD(0)
                                                             End If
                                                             If ProgBinRead(2, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 2) = 1 Then
                                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                End If
                                                             End If
                                                             If ProgBinRead(3, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
                                                            End If
                                                             If ProgBinRead(4, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 4) = 1 Then
                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                                
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                                
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                                
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                                End If
                                                            End If
                                                             
                                                             If ProgBinRead(6, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 8) = 1 Then
                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                            
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                            
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                            
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                                End If
                                                            End If
                                                             If ProgBinRead(5, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                If DoScans(0, 5) = 1 Then
                                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                End If
                                                            End If
                                                    End If
                                                End If
                                            'End If
                                        End If
                                    End If
                                End If
                            End If
                        Next WinPPY
                    End If
                End If
            End If
            '@'@
            '@
            ETx = Abs(GetTickCount)
            '@
            If Abs(ETx - GlobalTimer) > 500 Then
                            
                GlobalTimer = ETx
                'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                Form1.SSPanel1.Refresh
                
                
                If Abs(ETx - ELT) > 2000 Then
                     ELT = ETx
                     If oTotRecs > 0 Then
                         PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                         If PBV > Form1.ProgressBar1 Then
                             Form1.ProgressBar1 = PBV
                             Call UpdateF2Prog
                         End If
                     End If
                     
                End If
                 
                UpdateRecNums (SEventNumber)
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - SAll))
                Call UpdateTimeCaps(ETx, SAll)
                Form1.Refresh
                'If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                DoEvents 'covered by currentlyrunningflag
                If AbortFlag = 1 Then
                    Exit For
                End If
                
            End If
        End If
    Next x
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = Trim(Str(TripListLen)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    If TripListLen > 1000000 Then
        Erase Analysislist
    End If
    If FMatInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        If UBS1 > -1 Then
            ReDim SMat(UBS1, UBS1)
            Open "RDP5SMat" + UFTag For Binary As #FF
            Get #FF, , SMat()
            Close #FF
        End If
        If UBF1 > 0 Then
            ReDim FMat(UBF1, UBF1)
            Open "RDP5FMat" + UFTag For Binary As #FF
            Get #FF, , FMat()
            Close #FF
        End If
        FMatInFileFlag = 0
    End If
Else
    'For aaa = 1 To 10
    
    Dim NumInList As Long
    ReDim BinArray(Len(StrainSeq(0)), NextNo)
    Dim GoOnG() As Byte, ExitDoFlag As Byte, ElementNum As Long, LenXOverSeqG() As Long, ElementSeq() As Long, ElementSeq2() As Long, XPosDiffG() As Long, XDiffPosG() As Long, AHG() As Long, XOverSeqnumWG() As Byte
    Dim GrpTest As Long
    Dim SpacerSeqsG() As Integer, ValidSpacerG() As Integer, SpacerNoG() As Integer
    Dim NDiffG() As Long, SubSeqG() As Byte
    Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long
    Dim HiFragScoreG() As Long, FragMaxScoreG() As Long, MaxScorePosG() As Long, MissPenG() As Double
    GroupSize = 31
    
    If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
        GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
    End If
    If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
        ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize), XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), ElementSeq(GroupSize), ElementSeq2(GroupSize)
        ReDim GoOnG(GroupSize)
        ReDim LenXOverSeqG(GroupSize)
    End If
    If DoScans(0, 0) = 1 And BusyWithExcludes = 0 Then
        
        ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
        UB = UBound(TreeDistance, 1)
        ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
        ReDim Preserve MaskSeq(UB)
        
    End If
    
    If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then
        ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
        '@
        ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
        ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
        
    End If
    
    For WinPPY = 0 To RNum(WinPP)
        Seq1 = NextNo - RNum(WinPP) + WinPPY
        GoOn = 0
        If IndividualA = TraceSub(ISeqs(WinPP)) Or IndividualB = TraceSub(ISeqs(WinPP)) Then
            If TraceSub(Seq1) = IndividualA Or TraceSub(Seq1) = IndividualB Then
                GoOn = 1
            End If
        Else
            GoOn = 1
        End If
        If GoOn = 1 And ActualSeqSize(Seq1) > MinSeqSize Then
            
            If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
'                If DoScans(0, 0) = 1 Then
''                    ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
''                    ReDim LenXOverSeqG(GroupSize)
''                    ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
''                    UB = UBound(TreeDistance, 1)
''                    ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
''                    ReDim Preserve Maskseq(UB)
'                    'ReDim LenXOverSeqG(GroupSize)
'                End If
                
                
                Dummy = MakeBinArray3P(sNextno, UBound(DoPairs, 1), DoPairs(0, 0), Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0), SLookupNum(0), SLookup(0, 0), TraceSub(0), ActualSeqSize(0), MinSeqSize)
                '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79
                
                'XX = DoPairs(Seq1, Seq2)
                
                If DoScans(0, 0) = 1 Then 'Do RDP
                    ReDim GoOnG(GroupSize) 'this needs to be flushed
                    'ReDim LenXOverSeqG(GroupSize)
                    For g = 1 To SLookupNum(0)
                        Seq2 = SLookup(0, g)
                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
                            If Seq2 > sNextno Then
                                tSeq2 = TraceSub(Seq2)
                            Else
                                tSeq2 = Seq2
                            End If
                            If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                            'If IsIn(Seq2) = 0 Then
                                x = WinPPY + 1
                                If Seq2 >= NextNo - RNum(WinPP) + x Then
                                    'If X = 12345 Then
                                        x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
'                                    Else
'                                        For X = 0 To WinPPY
'                                            If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                        Next X
'                                    End If
'                                    For X = 0 To WinPPY
'                                        If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
'                                    Next X
                                End If
                                If x = WinPPY + 1 Then
                                    H = g
                                    ExitDoFlag = 0
                                    Do
                                        ElementNum = -1
        
                                        Do
        
                                            H = H + 1
                                            If H > SLookupNum(1) Then
                                                Do
                                                    g = g + 1
                                                    If g > SLookupNum(0) Then
                                                        ExitDoFlag = 1
                                                        Exit Do
                                                    End If
                                                    Seq2 = SLookup(0, g)
                                                    If Seq2 > sNextno Then
                                                        tSeq2 = TraceSub(Seq2)
                                                    Else
                                                        tSeq2 = Seq2
                                                    End If
                                                    If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                                                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
    '                                                        If Seq2 > SNextno Then
    '                                                            tSeq2 = TraceSub(Seq2)
    '                                                        Else
    '                                                            tSeq2 = Seq2
    '                                                        End If
                                                            'If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                                                            'If IsIn(Seq2) = 0 Then
                                                            H = g + 1
                                                            If H > SLookupNum(1) Then
                                                                ExitDoFlag = 1
                                                                Exit Do
                                                            Else
                                                                Exit Do
                                                            End If
                            
                                                           ' End If
                                                        End If
                                                    End If
        
                                                Loop
                                                If ExitDoFlag = 1 Then Exit Do
                                                'Exit Do
                                            End If
                                            Seq3 = SLookup(1, H)
                                            'If ExitDoFLag = 0 Then
        
        
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                
                                                
                                                x = WinPPY + 1
                                                '@'@'@
                                                If Seq3 >= (NextNo - RNum(WinPP) + x) Then
                                                    '@'@'@'@'@'@'@'@'@'@
                                                    'If X = X Then
                                                        x = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
'                                                        If CC > 0 Then
'                                                            X = X
'                                                        End If
                                                    'Else
'                                                        For X = 0 To WinPPY
'                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                                        Next X
'                                                        If X > 2 Then
'                                                            X = X
'                                                        End If
'                                                        If CC <> X Then
'                                                            X = X
'                                                        End If
                                                    'End If
                                                End If
                                                If x = WinPPY + 1 Then
                                                'If IsIn(Seq3) = 0 Then
                                                '@
                                                    If Seq3 > sNextno Then
                                                        tSeq3 = TraceSub(Seq3)
                                                    Else
                                                        tSeq3 = Seq3
                                                    End If
                                                    If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then '
                                                        If TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
                                                            GoOn = 1
                                                            If SelGrpFlag > 0 Then
                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                                If GrpTest >= 2 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 And FastestFlag = 1 Then
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 0 Or BusyWithExcludes = 1 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 Then
                                                                ElementNum = ElementNum + 1
                                                                ElementSeq(ElementNum) = Seq3
                                                                ElementSeq2(ElementNum) = Seq2
                                                            End If
                                                        End If
                                                    End If
                                                End If
                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                                            'For Seq3 = Seq2 + 1 To Nextno
                                            End If
                                            If ElementNum = GroupSize Then Exit Do
                                        Loop
                                        If ElementNum > -1 Then
                                            ReDim GoOnG(ElementNum)
                                            For x = 0 To ElementNum
        
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                GoOnG(x) = 1
                                                If SpacerFlag > 0 Then
                                                    If SpacerFlag < 4 Then
                                                        UB = UBound(TreeDistance, 1)
        
                                                       InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNoG(x), TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqsG(0, x), ValidSpacerG(0, x))
        
        
                                                        If InRangeFlag = 0 Then GoOnG(x) = 0
                                                    ElseIf SpacerFlag = 4 Then
                                                        SpacerNoG(x) = 1
                                                        SpacerSeqsG(1, x) = Spacer4No
                                                    End If
        
        
        
                                                    'Find Information rich subsequences (takes 11/21)
        
                                                    If SpacerNoG(x) = 0 Then
                                                        GoOnG(x) = 0
                                                    End If
                                                End If
        
        
                                            Next x
                                           ' ReDim XOverSeqnumWG(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3))
                                            'WARNING: lenstrainseq here actually equals len(strainseq(0))+1
                                            
                                            Dummy = FindSubSeqP8(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXOverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, ElementSeq2(0), ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
        
                                                         'XX = XDiffposG(2000, 4)
                                                        ' XX = LenXoverSeqG(0) '0
                                            For x = 0 To ElementNum
        
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                'If Maskseq(Seq3) = 0 Then
        
                                                    LastY3 = -1
                                                    b = b + 1
                                                    ZZZ = ZZZ + 1
                                                    'aaa = Abs(GetTickCount)
                                                    'For X = 1 To 20
                                                    '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79'
                                                    If LenXOverSeqG(x) >= XoverWindow * 2 Then '0=0,2;162 =0,9; 0 = 0,10; 0 = 0,17; 0=0,19; 103 = 0,22:s1=79
        
                                                        Call XOverV(0, x, LenXOverSeqG(x), SpacerNoG(x), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                        x = x
                                                    End If
                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
                                            Next x
        '                                    Else
        '                                        For X = 0 To ElementNum
        '                                            Seq3 = ElementSeq(X)
        '                                            If DoScans(0, 0) = 1 Then
        '                                                If FastestFlag = 1 Then
        '
        '                                                    NuminList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
        '                                                    If ProgBinRead(0, Worthwhilescan(NuminList)) = 1 Then
        '                                                        Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
        '                                                        Unmissedscans = Unmissedscans + 1
        '                                                    Else
        '                                                        MissedScans = MissedScans + 1
        '                                                    End If
        '                                                Else
        '                                                    Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
        '                                                End If
        '
        '                                            End If
        '                                        Next X
                                        End If
                                        If ExitDoFlag = 1 Then Exit Do
                                    Loop
                                End If
    
                            End If
    
                        End If
                    Next g
                End If
                If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then    'Do geneconv
                    ReDim GoOnG(GroupSize)  'this needs to be flushed
                    'If DoScans(0, 1) = 1 Then
'                        ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
'                        ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
'                        ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
'                        ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
'                        ReDim LenXOverSeqG(GroupSize)
                    'End If
                    
                    'ReDim LenXOverSeqG(GroupSize)
                    For g = 1 To SLookupNum(0)
                        Seq2 = SLookup(0, g)
                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
                            If Seq2 > sNextno Then
                                tSeq2 = TraceSub(Seq2)
                            Else
                                tSeq2 = Seq2
                            End If
                            If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                            'If IsIn(Seq2) = 0 Then
                                x = WinPPY + 1
                                If Seq2 >= NextNo - RNum(WinPP) + x Then
'                                    If X = 12345 Then
                                        x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
'                                    Else
'                                        For X = 0 To WinPPY
'                                            If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                        Next X
'                                    End If
'                                    For X = 0 To WinPPY
'                                        If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
'                                    Next X
                                End If
                                If x = WinPPY + 1 Then
                                    H = g
                                    ExitDoFlag = 0
                                    Do
                                        ElementNum = -1
        
                                        Do
        
                                            H = H + 1
                                            If H > SLookupNum(1) Then
                                                Do
                                                    g = g + 1
                                                    If g > SLookupNum(0) Then
                                                        ExitDoFlag = 1
                                                        Exit Do
                                                    End If
                                                    Seq2 = SLookup(0, g)
                                                    If Seq2 > sNextno Then
                                                        tSeq2 = TraceSub(Seq2)
                                                    Else
                                                        tSeq2 = Seq2
                                                    End If
                                                    If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                                                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
                                                            H = g + 1
                                                            If H > SLookupNum(1) Then
                                                                ExitDoFlag = 1
                                                                Exit Do
                                                            Else
                                                                Exit Do
                                                            End If
                            
                                                           ' End If
                                                        End If
                                                    End If
        
                                                Loop
                                                If ExitDoFlag = 1 Then Exit Do
                                                'Exit Do
                                            End If
                                            Seq3 = SLookup(1, H)
                                            'If ExitDoFLag = 0 Then
        
        
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                
                                                
                                                x = WinPPY + 1
                                                If Seq3 >= NextNo - RNum(WinPP) + x Then
                                                    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                                                    'If X = X Then
                                                        x = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
                                                    'Else
'                                                        If CC > 0 Then
'                                                            X = X
'                                                        End If
'                                                        For X = 0 To WinPPY
'                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                                        Next X
'                                                        If X > 2 Then
'                                                            X = X
'                                                        End If
'                                                        If CC <> X Then
'                                                            X = X
'                                                        End If
                                                    'End If
'                                                    For X = 0 To WinPPY
'                                                        If Seq3 = Nextno - RNum(WinPP) + X Then Exit For
'                                                    Next X
                                                End If
                                                If x = WinPPY + 1 Then
                                                'If IsIn(Seq3) = 0 Then
                                                    If Seq3 > sNextno Then
                                                        tSeq3 = TraceSub(Seq3)
                                                    Else
                                                        tSeq3 = Seq3
                                                    End If
                                                    If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then '
                                                        If TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
                                                            GoOn = 1
                                                            If SelGrpFlag > 0 Then
                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                                If GrpTest >= 2 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 And FastestFlag = 1 Then
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 And BusyWithExcludes = 0 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 Then
                                                                ElementNum = ElementNum + 1
                                                                ElementSeq(ElementNum) = Seq3
                                                                ElementSeq2(ElementNum) = Seq2
                                                            End If
                                                        End If
                                                    End If
                                                End If
                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                                            'For Seq3 = Seq2 + 1 To Nextno
                                            End If
                                            If ElementNum = GroupSize Then Exit Do
                                        Loop
                                        If ElementNum > -1 Then
                                            '@
                                           Dummy = FindSubSeqGCAP4(UBound(NDiffG, 1), UBound(XPosDiffG, 1), UBound(SubSeqG, 1), UBound(SubSeqG, 2), ElementNum, LenXOverSeqG(0), GCIndelFlag, Len(StrainSeq(0)), Seq1, ElementSeq2(0), ElementSeq(0), SeqNum(0, 0), SubSeqG(0, 0, 0), XPosDiffG(0, 0), XDiffPosG(0, 0), NDiffG(0, 0), BinArray(0, 0))
'                                           Open "Test GCAP3.csv" For Output As #1
'                                            For X = 0 To ElementNum
'                                               ' For Y = 0 To 6
'                                                    Print #1, " "
'                                                    'For Z = 0 To LenXOverSeqG(X)
'                                                    For Z = 0 To Len(StrainSeq(0))
'                                                        'Print #1, SubSeqG(Z, Y, X)
'                                                        Print #1, XDiffPosG(Z, X)
'                                                    Next Z
'                                               ' Next Y
'
'                                            Next X
                                            
'                                            Close #1
                                            
                                            Dummy = GetFragsP2(GoOnG(0), ElementNum, UBound(FragCountG, 1), UBound(FragScoreG, 1), UBound(FragScoreG, 2), UBound(SubSeq, 1), UBound(SubSeq, 2), CircularFlag, LenXOverSeqG(0), Len(StrainSeq(0)), GCDimSize, SubSeqG(0, 0, 0), FragStG(0, 0, 0), FragEnG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0))
                                            GetMaxFragScoreP2 ElementNum, LenXOverSeqG(0), GCDimSize, CircularFlag, GCMissmatchPen, MissPenG(0, 0), MaxScorePosG(0, 0, 0), FragMaxScoreG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0), HiFragScoreG(0, 0), NDiffG(0, 0)
                                            For x = 0 To ElementNum
        
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                'If Maskseq(Seq3) = 0 Then
        
                                                    LastY3 = -1
                                                    b = b + 1
                                                    ZZZ = ZZZ + 1
                                                    'aaa = Abs(GetTickCount)
                                                    'For X = 1 To 20
                                                    '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79'
                                                    If LenXOverSeqG(x) > 0 Then
                
                                                        'Call GCXoverDV(X, FragStG(), FragEnG(), FragScoreG(), FragCountG(), LenXOverSeqG(X), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                                        Call GCXoverDVI(HiFragScoreG(), FragMaxScoreG(), MaxScorePosG(), MissPenG(), x, FragStG(), FragEnG(), FragCountG(), LenXOverSeqG(x), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                                    End If
                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
                                            Next x
                                        End If
                                        If ExitDoFlag = 1 Then Exit Do
                                    Loop
                                End If
    
                            End If
    
                        End If
                    Next g
                End If
            End If
            If BusyWithExcludes = 1 Or (DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Or (DoScans(0, 1) = 1 And GCDimSize >= 20000)) Then
                For g = 1 To SLookupNum(0)
                    Seq2 = SLookup(0, g)
                    If ActualSeqSize(Seq2) > MinSeqSize And (TraceSub(Seq1) <> TraceSub(Seq2) Or BusyWithExcludes = 1) Then
                        If Seq2 > sNextno Then
                            tSeq2 = TraceSub(Seq2)
                        Else
                            tSeq2 = Seq2
                        End If
                        
                        If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                            x = WinPPY + 1
                            If Seq2 >= NextNo - RNum(WinPP) + x Then
                                'If X = 12345 Then
                                    x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
'                                Else
'                                    For X = 0 To WinPPY
'                                        If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                    Next X
'                                End If
'                                For X = 0 To WinPPY
'                                    If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
'                                Next X
                            End If
                            If x = WinPPY + 1 Then
                                
                                For H = g + 1 To SLookupNum(1)
                                    Seq3 = SLookup(1, H)
                                    
                                    If FastestFlag = 1 Then
                                        NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                    End If
                                    If Worthwhilescan(NumInList) > 0 Or BusyWithExcludes = 1 Then
                                    
                                    
                                    
                                        '
                                        If ActualSeqSize(Seq3) > MinSeqSize Then
                                            x = WinPPY + 1
                                            If Seq3 >= NextNo - RNum(WinPP) + x Then
                                                'If X = X Then
                                                        CC = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
                                                    'Else
'                                                        If CC > 0 Then
'                                                            X = X
'                                                        End If
'                                                        For X = 0 To WinPPY
'                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
'                                                        Next X
''                                                        If X > 2 Then
'                                                            X = X
'                                                        End If
'                                                        If CC <> X Then
'                                                            X = X
'                                                        End If
                                                    'End If
'                                                For X = 0 To WinPPY
'                                                    If Seq3 = Nextno - RNum(WinPP) + X Then Exit For
'                                                Next X
                                            End If
                                            If x = WinPPY + 1 Then
                                                If Seq3 > sNextno Then
                                                    tSeq3 = TraceSub(Seq3)
                                                Else
                                                    tSeq3 = Seq3
                                                End If
                                                
                                                If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then
                                                    If (TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3)) Or BusyWithExcludes = 1 Then
                                                        
                                                        '
                                                        If DoScans(0, 0) = 1 And BusyWithExcludes = 1 Then
                                                            If FastestFlag = 0 Then
                                                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                            Else
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                    Unmissedscans = Unmissedscans + 1
                                                                Else
                                                                    MissedScans = MissedScans + 1
                                                                End If
                                                            End If
                                                        End If
                                                        
                                                       
                                                        
                                                        If (DoScans(0, 1) = 1 And GCDimSize >= 20000) Or BusyWithExcludes = 1 Then
        
                                                            If FastestFlag = 0 Then
                                                                Call GCXoverD(0)
                                                            Else
        
                                                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                   Call GCXoverD(0)
        
                                                                End If
                                                            End If
                                                        End If
                                                        If DoScans(0, 2) = 1 Then
                                                           
                                                            If FastestFlag = 0 Then
                                                                 Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                            Else
                                                                
                                                                If ProgBinRead(2, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                End If
                                                            End If
                                                        End If
                                                        '
                                                        If DoScans(0, 3) = 1 Then
                                                            
                                                            If FastestFlag = 0 Then
                                                                Call MCXoverF(0, 0, 0)
                                                            Else
                                                                
                                                                If ProgBinRead(3, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                   Call MCXoverF(0, 0, 0)
                                                                End If
                                                            End If
                                                        End If
                                                       '
                                                        If DoScans(0, 4) = 1 Then
                                                        
                                                            If FastestFlag = 0 Then
                                                                 otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                        
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                            
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                            
                                                                Call CXoverA(0, 0, 0)
                                                                            
                                                                Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                            Else
                                                                
                                                                If ProgBinRead(4, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                            
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                                
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                                
                                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                                End If
                                                            End If
                                                        
                                                        
                                                           
                                                        End If
                                                        
                                                        
                                                        
                                                        
                                                        If DoScans(0, 8) = 1 Then
                                                            
                                                            If FastestFlag = 0 Then
                                                                 otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                    
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                        
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                        
                                                                Call TSXOver(0)
                                                                        
                                                                Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                            Else
                                                                
                                                                If ProgBinRead(6, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                    
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                            
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                            
                                                                    Call TSXOver(0)
                                                                            
                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                                End If
                                                            End If
                                                            
                                                           
                                                        End If
                                                        If DoScans(0, 5) = 1 Then
                                                            
                                                            If FastestFlag = 0 Then
                                                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                            Else
                                                                
                                                                If ProgBinRead(5, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                End If
                                                            End If
                                                            
                                                        End If
                                                    End If
                                                
                                                End If
                                                b = b + 1
                                            End If
                                                
                                            ET = Abs(GetTickCount)
                                            If Abs(ET - GlobalTimer) > 500 Then
                                                
                                                GlobalTimer = ET
                                                
                                                Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                                                If Abs(ET - ELT) > 2000 Then
                                                    ELT = ET
                                                    If oTotRecs > 0 Then
                                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                                        If PBV > Form1.ProgressBar1 Then
                                                            Form1.ProgressBar1 = PBV
                                                            Call UpdateF2Prog
                                                        End If
                                                    End If
                                                    
                                                End If
                                                
                                                UpdateRecNums (SEventNumber)
                                               Call UpdateTimeCaps(ET, SAll)
                                               If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                                DoEvents 'covered by currentlyrunningflag
                                                Form1.WindowState = Form1.WindowState
                                                If AbortFlag = 1 Then
                                                    WinPPY = NextNo
                                                    g = NextNo
                                                    H = NextNo
                                                End If
                                            End If
                                        End If
                                    End If
                                Next H
                            
                            End If
                        
                        End If
                    End If
                Next g
            End If
        End If
    Next WinPPY
    'Next aaa
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = Trim(Str(MCCorrectX)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
        Form1.SSPanel1.Refresh
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
End If

'If PermNextno > mempoc and x=1234567 Then
'    ReDim TreeDistance(0, 0)
'    ReDim Distance(0, 0)
'
'End If

If PermNextno > MemPoc Then
    ReDim PermValid(0, 0)
    ReDim PermDIffs(0, 0)
End If

End Sub
Public Sub OuterScan4(STime As Long, MCCorrectX As Double, SAll As Long, sNextno As Long, WinPP As Long, SLookup() As Long, ISeqs() As Long, RNum() As Long, RList() As Long, TraceSub() As Long, ActualSeqSize() As Long, SLookupNum() As Long, DoPairs() As Byte, FindallFlag As Long, WinNum As Long, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno As Long, MissingData() As Byte)
Dim ZZZ As Long, UB As Long, Dummy As Long, TT As Long, PBV As Long, oTotRecs As Long, ELT As Long, ETx As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, otSeq1 As Long, otSeq2 As Long, otSeq3 As Long, WinPPY As Long, x As Long, g As Long, H As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long, b As Long
Dim A As Long, FF As Long, oDirX As String, GoOn As Byte, UBTS1 As Long
LowestProb = pLowestProb
'LT = Abs(GetTickCount)
UBTS1 = UBound(TraceSub, 1)

If PermNextno > MemPoc And (TempTreeDistanceDumpFlag = 1 Or UBound(TreeDistance, 1) <> NextNo) And x = 1234567 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim TreeDistance(UBTD1, UBTD1)
    Open "RDP5TreeDistance" + UFTag For Binary As #FF
    Get #FF, , TreeDistance
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End If

If UBound(Distance, 1) = 0 And PermNextno > MemPoc And x = 1234567 Then
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    FF = FreeFile
    'UBDistance = UBound(Distance, 1)
    XX = UBound(SCMat, 1)
    ReDim Distance(UBDistance, UBDistance)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Get #FF, , Distance()
    Close #FF
    'Erase Distance
    ChDir oDir
    ChDrive oDir

End If


If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    ReDim PermValid(UBPermValid, UBPermValid)
    Open "RDP5PermValid" + UFTag For Binary As #FF
    Get #FF, , PermValid()
    Close #FF
    
    
    ReDim PermDIffs(UBPermDiffs, UBPermDiffs)
    Open "RDP5PermDiffs" + UFTag For Binary As #FF
    Get #FF, , PermDIffs()
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
End If


ReDim XoverList(NextNo, 10)
ReDim CurrentXOver(NextNo)
ReDim MaxXOP(AddNum - 1, NextNo)
Call ResetMaxPVCO(NextNo)
Dim FindAllFlagX As Byte
FindAllFlagX = 0
If UseALFlag = 1 Then
    Dim FMatInFileFlag As Byte, UBF1 As Long, UBS1 As Long
    If TripListLen > 1000000 Then
        oDirX = CurDir
        '@
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        UBF1 = 0: UBS1 = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        UBF1 = UBound(FMat, 1)
        UBS1 = UBound(SMat, 1)
        On Error GoTo 0
        If UBS1 > 0 Then
            Open "RDP5SMat" + UFTag For Binary As #FF
            Put #FF, , SMat()
            Close #FF
            ReDim SMat(0, 0)
        End If
        If UBF1 > 0 Then
            Open "RDP5FMat" + UFTag For Binary As #FF
            Put #FF, , FMat()
            Close #FF
            ReDim FMat(0, 0)
        End If
        FMatInFileFlag = 1
    '$
        ReDim Preserve Analysislist(2, TripListLen)
        '@'@'@
        Open "RDP5AnalysisList" + UFTag For Binary As #FF
        Get #FF, , Analysislist
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SubValid, 1)
    On Error GoTo 0
    If UB < NextNo Then ' > LowMemThreshold Then
'            oDir = CurDir
'            ChDir App.Path
'            ChDrive App.Path
'            FF = FreeFile
        ReDim SubValid(NextNo, NextNo)
        '$
        For Z = 0 To NextNo - 1
            For Y = Z + 1 To NextNo
                SubValid(Z, Y) = 100
                SubValid(Y, Z) = 100
            Next Y
        Next Z
        
        
'            Open "RDP5SubValid" + UFTag For Binary As #FF
'            Get #FF, , SubValid()
'            Close #FF
'
'            ChDir oDir
'            ChDrive oDir
    End If
   
    ReDim SubSeq(Len(StrainSeq(0)), 6)
    Dim RestartPos() As Long
    ReDim RestartPos(2)
    
    Dim UCThresh As Double
    If MCFlag = 0 Then
        UCThresh = LowestProb / MCCorrection
    Else
        UCThresh = LowestProb
    End If
   
    If DoScans(0, 0) = 1 Or DoScans(0, 1) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Then
        
        Dim AList() As Integer
        Dim BAL As Variant, ALC As Long
        Dim RedoL3() As Byte, StepsX As Long, EPX As Long
        Call MakeScanCompressArrays(NextNo, SeqNum())
    
        If DoScans(0, 0) = 1 Then
            ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
            ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
'            If (BAL + 3 * RNum(WinPP)) > TripListLen Then
'                BAL = BAL - 3 * RNum(WinPP)
'            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            
            ALC = -1
            '@'$
            ALC = MakeAListOSP(UBound(AList, 2), BusyWithExcludes, UBound(SubValid, 1), SubValid(0, 0), sNextno, UBound(TraceSub, 1), 0, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$'$
                    NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                    'If NumRedos > 0 Then
                        
                    For x = Y To EPX
    '                    If x = 475 Then
    '                        x = x
    '                    End If
                        If RedoL3(x) > 0 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            
                            ' Print #1, Str(Seq1) + "," + Str(Seq2) + "," + Str(Seq3)
                            ''22,245,285
                            CurrentTripListNum = x
                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                        Else
                            x = x
                        End If
                        x = x
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
                'End If
            End If
        End If
        
        If DoScans(0, 1) = 1 Then
            GCIndelFlag = 0
            ReDim RestartPos(2)
            ReDim FragMaxScore(GCDimSize, 5)
            ReDim MaxScorePos(GCDimSize, 5)
            ReDim PVals(GCDimSize, 5)
            ReDim FragSt(GCDimSize, 6)
            ReDim FragEn(GCDimSize, 6)
            ReDim FragScore(GCDimSize, 6)
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            ALC = MakeAListOSP(UBound(AList, 2), BusyWithExcludes, UBound(SubValid, 1), SubValid(0, 0), sNextno, UBound(TraceSub, 1), 1, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$
                    ' NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), ALC, Y, EPX, NextNo, UCTHresh,                 RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, UCThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                    'If NumRedos > 0 Then
                    '@'@
                    For x = Y To EPX
                        If RedoL3(x) = 1 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            'ZZZ = ZZZ + 1
                            CurrentTripListNum = x
                            ''22,245,285
                             NewOneFound = 0
                            Call GCXoverD(0)
'                            If RedoL3(x) = 2 And NewOneFound = 1 Then
'                                x = x
'                            End If
'                            If NewOneFound = 0 Then
'                                x = x
'                            End If
                        ElseIf RedoL3(x) = 2 Then
                            
                            Call AddToRedoList(1, AList(0, x), AList(1, x), AList(2, x))
                            x = x
                        End If
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        '$
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
            End If
            UseCompress = 0
               
            
        End If
        If DoScans(0, 3) = 1 Then
            Call SetupMCArrays
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            ALC = MakeAListOSP(UBound(AList, 2), BusyWithExcludes, UBound(SubValid, 1), SubValid(0, 0), sNextno, UBound(TraceSub, 1), 3, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$
                    ' NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), ALC, Y, EPX, NextNo, UCTHresh,                 RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    HWindowWidth = CLng(MCWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    NumRedos = AlistMC3(SEventNumber, Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                   
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                    'If NumRedos > 0 Then
                    '@'@
                    For x = Y To EPX
                        If RedoL3(x) = 1 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            'ZZZ = ZZZ + 1
                            CurrentTripListNum = x
                            ''22,245,285
                            BQPV = 1
                            NewOneFound = 0
                            Call MCXoverF(FindAllFlagX, 0, 0)
'                            If RedoL3(x) = 2 And NewOneFound = 1 Then
'                                x = x
'                            End If
'                            If NewOneFound = 0 Then
'                                x = x
'                            End If
                        ElseIf RedoL3(x) = 2 Then
                            
                            Call AddToRedoList(3, AList(0, x), AList(1, x), AList(2, x))
                           ' x = x
                        End If
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        '$
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
            End If
            UseCompress = 0
            Call SetupMCArrays
            
        End If
        If DoScans(0, 4) = 1 Then
        
            
        
        
            
            Dim LXOS() As Long
            Dim XDP() As Long, XPD() As Long
            
            HWindowWidth = CLng(CWinSize / 2)
            lHWindowWidth = HWindowWidth
            
            ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
            ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
            ReDim ChiValsX(Len(StrainSeq(0)))
            ReDim SmoothChiX(Len(StrainSeq(0)))
            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
            ReDim LXOS(3)
            ReDim XDP(Len(StrainSeq(0)) + 200, 2), XPD(Len(StrainSeq(0)) + 200, 2)
            
            Call GetCriticalDiff(1)
            If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
                CWinSize = HWindowWidth * 2
            End If
            
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            ReDim RestartPos(2)
            '$'$'$
            
            
            ALC = MakeAListOSP(UBound(AList, 2), BusyWithExcludes, UBound(SubValid, 1), SubValid(0, 0), sNextno, UBound(TraceSub, 1), 4, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                oepx = -1
                XX = RedoListSize
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh,                        RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0),        ALC,         Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    HWindowWidth = CLng(CWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    'NumRedos = AlistMC3(SEventNumber,                  Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, 0,             NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, CDbl(LowestProb / MCCorrection), LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                    
                    NumRedos = AlistChi(SEventNumber, MissingData(0, 0), Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCThresh, LowestProb, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSRDP, 2), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                    
                    '@'@
                    For x = Y To EPX
                        '1578,4229, 4348
                        
                        CurrentTripListNum = x
                        If RedoL3(x) > 0 Then
                            If ProgBinRead(0, RedoL3(x)) = 1 Then
                                
                                Seq1 = AList(0, x) '0
                                Seq2 = AList(1, x) '31
                                Seq3 = AList(2, x) '83
                                ZZZ = ZZZ + 1
                                BQPV = 1
'                                If Y = 4229 Then
'                                    x = x
'                                End If
                                
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If (NewOneFound = 0 And ProgBinRead(0, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(0, RedoL3(x)) = 0) Then
'                                    x = x
'                                End If
                                
                            End If
                            If ProgBinRead(2, RedoL3(x)) = 1 Then
                                
                                Seq3 = AList(0, x) '5
                                Seq1 = AList(1, x) '83
                                Seq2 = AList(2, x) '104
                                ZZZ = ZZZ + 1
                                BQPV = 1
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If (NewOneFound = 0 And ProgBinRead(2, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(2, RedoL3(x)) = 0) Then
'                                    x = x
'                                End If
                            End If
                            If ProgBinRead(4, RedoL3(x)) = 1 Then
                                
                                Seq2 = AList(0, x) '5
                                Seq3 = AList(1, x) '83
                                Seq1 = AList(2, x) '107
                                ZZZ = ZZZ + 1
                                BQPV = 1
                                NewOneFound = 0
                                Call CXoverA(FindAllFlagX, 0, 0)
'                                If (NewOneFound = 0 And ProgBinRead(4, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(4, RedoL3(x)) = 0) Then
'                                    x = x
'                                End If
                            End If
                            If ProgBinRead(1, RedoL3(x)) = 1 Or ProgBinRead(3, RedoL3(x)) = 1 Or ProgBinRead(5, RedoL3(x)) = 1 Then
                                ZZZ = ZZZ + 1
'                                If ProgBinRead(4, Worthwhilescan(x)) = 0 Then
'                                    Worthwhilescan(x) = Worthwhilescan(x) + 5
'                                End If
                                Call AddToRedoList(4, AList(0, x), AList(1, x), AList(2, x))
                            End If
                        End If
                        
                        
                    Next x
                    
                    
                    
                    'End If
                    OY = Y
                    oepx = EPX
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
            End If
            UseCompress = 0
            'Call SetupMCArrays
'            HWindowWidth = CLng(CWinSize / 2)
'            lHWindowWidth = HWindowWidth
'            ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
'            ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
'            ReDim ChiValsX(Len(StrainSeq(0)))
'            ReDim SmoothChiX(Len(StrainSeq(0)))
'            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'            ReDim LXOS(3)
'            ReDim XDP(Len(StrainSeq(0)) + 200, 2), XPD(Len(StrainSeq(0)) + 200, 2)
            
        End If
    End If
    If DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then 'Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Then
        Call MakeScanCompressArrays(NextNo, SeqNum())
        UseCompress = 1
        GCIndelFlag = 0 'need to use this with
        For x = 0 To TripListLen
        '@'@'@'@'@'@'@'@'@'@'@'@'@
            
            If Worthwhilescan(x) > 0 Or BusyWithExcludes = 1 Then
                
                CurrentTripListNum = x
                GoOn = 1
                Seq1 = Analysislist(0, x)
                '@
                If Seq1 <= UBTS1 Then
                    If Seq1 > sNextno Then
                        tSeq1 = TraceSub(Seq1)
                    Else
                        tSeq1 = Seq1
                    End If
                Else
                    GoOn = 0
                End If
                '@'@'@'@'@'@'@'@
                Seq2 = Analysislist(1, x)
                If Seq2 <= UBTS1 Then
                    If Seq2 > sNextno Then
                        tSeq2 = TraceSub(Seq2)
                    Else
                        tSeq2 = Seq2
                    End If
                Else
                    GoOn = 0
                End If
                If DoPairs(tSeq1, tSeq2) = 1 Then
                    Seq3 = Analysislist(2, x)
                    If Seq3 <= UBTS1 Then
                        If Seq3 > sNextno Then
                            tSeq3 = TraceSub(Seq3)
                        Else
                            tSeq3 = Seq3
                        End If
                    Else
                        GoOn = 0
                    End If
                    
                    If DoPairs(tSeq1, tSeq3) = 1 And DoPairs(tSeq2, tSeq3) = 1 Then
                        If GoOn = 1 Then
                            XX = SEventNumber
                            For WinPPY = NextNo - RNum(WinPP) To NextNo
                                A = WinPPY
                                If A > PermNextno Then
                                    b = TraceSub(A)
                                Else
                                    
                                    b = A
                                End If
                                If Seq1 = b Or Seq2 = b Or Seq3 = b Then
                                    If b = Seq1 Then
                                        Seq1 = A
                                    ElseIf b = Seq2 Then
                                        Seq2 = A
                                    ElseIf b = Seq3 Then
                                        Seq3 = A
                                    End If
                                    If ActualSeqSize(Seq1) > MinSeqSize Then
                                        If ActualSeqSize(Seq2) > MinSeqSize Then
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                'If SubValid(tSeq2, tSeq3) > 20 Then
                                                    'XX = UBound(SubValid, 2)
                                                    If SubValid(tSeq1, tSeq3) > 20 Then
                                                        If SubValid(tSeq1, tSeq2) > 20 Then
'                                                                 If ProgBinRead(2, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    If DoScans(0, 2) = 1 Then
'                                                                        Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
'                                                                    End If
'                                                                 End If
'                                                                 If ProgBinRead(3, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    If DoScans(0, 3) = 1 Then Call MCXoverF(FindAllFlagX, 0, 0)
'                                                                End If
'                                                                 If ProgBinRead(4, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    If DoScans(0, 4) = 1 Then
'                                                                        otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
'
'                                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                        Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
'
'                                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                        Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
'
'                                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                        Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
'                                                                    End If
'                                                                End If
                                                                 
                                                                 If ProgBinRead(6, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                    If DoScans(0, 8) = 1 Then
                                                                        otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
                                                                                
                                                                        Call TSXOver(0)
                                                                                
                                                                        Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
                                                                                
                                                                        Call TSXOver(0)
                                                                                
                                                                        Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
                                                                                
                                                                        Call TSXOver(0)
                                                                                
                                                                        Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
                                                                    End If
                                                                End If
                                                                 If ProgBinRead(5, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                                                    If DoScans(0, 5) = 1 Then
                                                                        oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                        Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                    End If
                                                                End If
                                                        End If
                                                    End If
                                                'End If
                                            End If
                                        End If
                                    End If
                                End If
                            Next WinPPY
                        End If
                    End If
                End If
                '@'@
                '@
                ETx = Abs(GetTickCount)
                '@
                If Abs(ETx - GlobalTimer) > 500 Then
                                
                    GlobalTimer = ETx
                    'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                    Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                    Form1.SSPanel1.Refresh
                    
                    
                    If Abs(ETx - ELT) > 2000 Then
                         ELT = ETx
                         If oTotRecs > 0 Then
                             PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                             If PBV > Form1.ProgressBar1 Then
                                 Form1.ProgressBar1 = PBV
                                 Call UpdateF2Prog
                             End If
                         End If
                         
                    End If
                     
                    UpdateRecNums (SEventNumber)
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - SAll))
                    Call UpdateTimeCaps(ETx, SAll)
                    
                    
                    
                    Form1.Refresh
                    'If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    DoEvents 'covered by currentlyrunningflag
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                    
                End If
            End If
        Next x
        If DoScans(0, 3) = 1 Then
            Call SetupMCArrays
        End If
    End If
    
    If DoScans(0, 2) = 1 Then
        Dim NumInList As Long
        ReDim BinArray(Len(StrainSeq(0)), NextNo)
        Dim GoOnG() As Byte, ExitDoFlag As Byte, ElementNum As Long, LenXOverSeqG() As Long, ElementSeq() As Long, ElementSeq2() As Long, XPosDiffG() As Long, XDiffPosG() As Long, AHG() As Long, XOverSeqnumWG() As Byte
        Dim GrpTest As Long
        Dim SpacerSeqsG() As Integer, ValidSpacerG() As Integer, SpacerNoG() As Integer
        Dim NDiffG() As Long, SubSeqG() As Byte
        Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long
        Dim HiFragScoreG() As Long, FragMaxScoreG() As Long, MaxScorePosG() As Long, MissPenG() As Double
        GroupSize = 31
        
        If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
            GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
        End If
        
        
        For WinPPY = 0 To RNum(WinPP)
            Seq1 = NextNo - RNum(WinPP) + WinPPY
            GoOn = 0
            If IndividualA = TraceSub(ISeqs(WinPP)) Or IndividualB = TraceSub(ISeqs(WinPP)) Then
                If TraceSub(Seq1) = IndividualA Or TraceSub(Seq1) = IndividualB Then
                    GoOn = 1
                End If
            Else
                GoOn = 1
            End If
            If GoOn = 1 And ActualSeqSize(Seq1) > MinSeqSize Then
                
                
                'If BusyWithExcludes = 1 Or (DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Or (DoScans(0, 1) = 1 And GCDimSize >= 20000)) Then
                    For g = 1 To SLookupNum(0)
                        Seq2 = SLookup(0, g)
                        If ActualSeqSize(Seq2) > MinSeqSize And (TraceSub(Seq1) <> TraceSub(Seq2) Or BusyWithExcludes = 1) Then
                            If Seq2 > sNextno Then
                                tSeq2 = TraceSub(Seq2)
                            Else
                                tSeq2 = Seq2
                            End If
                            
                            If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
                                x = WinPPY + 1
                                If Seq2 >= NextNo - RNum(WinPP) + x Then
                                    'If X = 12345 Then
                                        x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
    '                                Else
    '                                    For X = 0 To WinPPY
    '                                        If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
    '                                    Next X
    '                                End If
    '                                For X = 0 To WinPPY
    '                                    If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
    '                                Next X
                                End If
                                If x = WinPPY + 1 Then
                                    
                                    For H = g + 1 To SLookupNum(1)
                                        Seq3 = SLookup(1, H)
                                        
                                        
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                x = WinPPY + 1
                                                If Seq3 >= NextNo - RNum(WinPP) + x Then
                                                    'If X = X Then
                                                            CC = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
                                                End If
                                                If x = WinPPY + 1 Then
                                                    If Seq3 > sNextno Then
                                                        tSeq3 = TraceSub(Seq3)
                                                    Else
                                                        tSeq3 = Seq3
                                                    End If
                                                    
                                                    If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then
                                                        If (TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3)) Or BusyWithExcludes = 1 Then
                                                            
                                                            If DoScans(0, 2) = 1 Then
                                                               
                                                                'If FastestFlag = 0 Then
                                                                     Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                'Else
                                                                '
                                                                '    If ProgBinRead(2, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                '        Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                '    End If
                                                                'End If
                                                            End If
                                                            '
                                                        End If
                                                    
                                                    End If
                                                    b = b + 1
                                                End If
                                                    
                                                ET = Abs(GetTickCount)
                                                If Abs(ET - GlobalTimer) > 500 Then
                                                    
                                                    GlobalTimer = ET
                                                    
                                                    Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                                                    If Abs(ET - ELT) > 2000 Then
                                                        ELT = ET
                                                        If oTotRecs > 0 Then
                                                            PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                                            If PBV > Form1.ProgressBar1 Then
                                                                Form1.ProgressBar1 = PBV
                                                                Call UpdateF2Prog
                                                            End If
                                                        End If
                                                        
                                                    End If
                                                    
                                                    UpdateRecNums (SEventNumber)
                                                   Call UpdateTimeCaps(ET, SAll)
                                                   If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                                    DoEvents 'covered by currentlyrunningflag
                                                    Form1.WindowState = Form1.WindowState
                                                    If AbortFlag = 1 Then
                                                        WinPPY = NextNo
                                                        g = NextNo
                                                        H = NextNo
                                                    End If
                                                End If
                                            End If
                                        
                                    Next H
                                
                                End If
                            
                            End If
                        End If
                    Next g
                'End If
            End If
        Next WinPPY
        'Next aaa
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
            Form1.SSPanel1.Caption = Trim(Str(MCCorrectX)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
            Form1.SSPanel1.Refresh
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    
    End If
    
    
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = Trim(Str(TripListLen)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
    If TripListLen > 1000000 Then
        Erase Analysislist
    End If
    If FMatInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        If UBS1 > -1 Then
            ReDim SMat(UBS1, UBS1)
            Open "RDP5SMat" + UFTag For Binary As #FF
            Get #FF, , SMat()
            Close #FF
        End If
        If UBF1 > 0 Then
            ReDim FMat(UBF1, UBF1)
            Open "RDP5FMat" + UFTag For Binary As #FF
            Get #FF, , FMat()
            Close #FF
        End If
        FMatInFileFlag = 0
    End If
Else
    'For aaa = 1 To 10
    
'    Dim NumInList As Long
'    ReDim BinArray(Len(StrainSeq(0)), NextNo)
'    Dim GoOnG() As Byte, ExitDoFlag As Byte, ElementNum As Long, LenXOverSeqG() As Long, ElementSeq() As Long, ElementSeq2() As Long, XPosDiffG() As Long, XDiffPosG() As Long, AHG() As Long, XOverSeqnumWG() As Byte
'    Dim GrpTest As Long
'    Dim SpacerSeqsG() As Integer, ValidSpacerG() As Integer, SpacerNoG() As Integer
'    Dim NDiffG() As Long, SubSeqG() As Byte
'    Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long
'    Dim HiFragScoreG() As Long, FragMaxScoreG() As Long, MaxScorePosG() As Long, MissPenG() As Double
'    GroupSize = 31
'
'    If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
'        GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
'    End If
'    If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
'        ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize), XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), ElementSeq(GroupSize), ElementSeq2(GroupSize)
'        ReDim GoOnG(GroupSize)
'        ReDim LenXOverSeqG(GroupSize)
'    End If
'    If DoScans(0, 0) = 1 And BusyWithExcludes = 0 Then
'
'        ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
'        UB = UBound(TreeDistance, 1)
'        ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
'        ReDim Preserve MaskSeq(UB)
'
'    End If
'
'    If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then
'        ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
'        '@
'        ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
'        ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
'
'    End If
'
'    For WinPPY = 0 To RNum(WinPP)
'        Seq1 = NextNo - RNum(WinPP) + WinPPY
'        GoOn = 0
'        If IndividualA = TraceSub(ISeqs(WinPP)) Or IndividualB = TraceSub(ISeqs(WinPP)) Then
'            If TraceSub(Seq1) = IndividualA Or TraceSub(Seq1) = IndividualB Then
'                GoOn = 1
'            End If
'        Else
'            GoOn = 1
'        End If
'        If GoOn = 1 And ActualSeqSize(Seq1) > MinSeqSize Then
'
'            If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
''                If DoScans(0, 0) = 1 Then
'''                    ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
'''                    ReDim LenXOverSeqG(GroupSize)
'''                    ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
'''                    UB = UBound(TreeDistance, 1)
'''                    ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
'''                    ReDim Preserve Maskseq(UB)
''                    'ReDim LenXOverSeqG(GroupSize)
''                End If
'
'
'                Dummy = MakeBinArray3P(sNextno, UBound(DoPairs, 1), DoPairs(0, 0), Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0), SLookupNum(0), SLookup(0, 0), TraceSub(0), ActualSeqSize(0), MinSeqSize)
'                '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79
'
'                'XX = DoPairs(Seq1, Seq2)
'
'                If DoScans(0, 0) = 1 Then 'Do RDP
'                    ReDim GoOnG(GroupSize) 'this needs to be flushed
'                    'ReDim LenXOverSeqG(GroupSize)
'                    For g = 1 To SLookupNum(0)
'                        Seq2 = SLookup(0, g)
'                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
'                            If Seq2 > sNextno Then
'                                tSeq2 = TraceSub(Seq2)
'                            Else
'                                tSeq2 = Seq2
'                            End If
'                            If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                            'If IsIn(Seq2) = 0 Then
'                                x = WinPPY + 1
'                                If Seq2 >= NextNo - RNum(WinPP) + x Then
'                                    'If X = 12345 Then
'                                        x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
''                                    Else
''                                        For X = 0 To WinPPY
''                                            If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                        Next X
''                                    End If
''                                    For X = 0 To WinPPY
''                                        If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
''                                    Next X
'                                End If
'                                If x = WinPPY + 1 Then
'                                    H = g
'                                    ExitDoFlag = 0
'                                    Do
'                                        ElementNum = -1
'
'                                        Do
'
'                                            H = H + 1
'                                            If H > SLookupNum(1) Then
'                                                Do
'                                                    g = g + 1
'                                                    If g > SLookupNum(0) Then
'                                                        ExitDoFlag = 1
'                                                        Exit Do
'                                                    End If
'                                                    Seq2 = SLookup(0, g)
'                                                    If Seq2 > sNextno Then
'                                                        tSeq2 = TraceSub(Seq2)
'                                                    Else
'                                                        tSeq2 = Seq2
'                                                    End If
'                                                    If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                                                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
'    '                                                        If Seq2 > SNextno Then
'    '                                                            tSeq2 = TraceSub(Seq2)
'    '                                                        Else
'    '                                                            tSeq2 = Seq2
'    '                                                        End If
'                                                            'If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                                                            'If IsIn(Seq2) = 0 Then
'                                                            H = g + 1
'                                                            If H > SLookupNum(1) Then
'                                                                ExitDoFlag = 1
'                                                                Exit Do
'                                                            Else
'                                                                Exit Do
'                                                            End If
'
'                                                           ' End If
'                                                        End If
'                                                    End If
'
'                                                Loop
'                                                If ExitDoFlag = 1 Then Exit Do
'                                                'Exit Do
'                                            End If
'                                            Seq3 = SLookup(1, H)
'                                            'If ExitDoFLag = 0 Then
'
'
'                                            If ActualSeqSize(Seq3) > MinSeqSize Then
'
'
'                                                x = WinPPY + 1
'                                                '@'@'@
'                                                If Seq3 >= (NextNo - RNum(WinPP) + x) Then
'                                                    '@'@'@'@'@'@'@'@'@'@
'                                                    'If X = X Then
'                                                        x = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
''                                                        If CC > 0 Then
''                                                            X = X
''                                                        End If
'                                                    'Else
''                                                        For X = 0 To WinPPY
''                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                                        Next X
''                                                        If X > 2 Then
''                                                            X = X
''                                                        End If
''                                                        If CC <> X Then
''                                                            X = X
''                                                        End If
'                                                    'End If
'                                                End If
'                                                If x = WinPPY + 1 Then
'                                                'If IsIn(Seq3) = 0 Then
'                                                '@
'                                                    If Seq3 > sNextno Then
'                                                        tSeq3 = TraceSub(Seq3)
'                                                    Else
'                                                        tSeq3 = Seq3
'                                                    End If
'                                                    If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then '
'                                                        If TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
'                                                            GoOn = 1
'                                                            If SelGrpFlag > 0 Then
'                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
'                                                                If GrpTest >= 2 Then
'                                                                    GoOn = 0
'                                                                End If
'                                                            End If
'                                                            If GoOn = 1 And FastestFlag = 1 Then
'                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
'                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 0 Or BusyWithExcludes = 1 Then
'                                                                    GoOn = 0
'                                                                End If
'                                                            End If
'                                                            If GoOn = 1 Then
'                                                                ElementNum = ElementNum + 1
'                                                                ElementSeq(ElementNum) = Seq3
'                                                                ElementSeq2(ElementNum) = Seq2
'                                                            End If
'                                                        End If
'                                                    End If
'                                                End If
'                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
'                                            'For Seq3 = Seq2 + 1 To Nextno
'                                            End If
'                                            If ElementNum = GroupSize Then Exit Do
'                                        Loop
'                                        If ElementNum > -1 Then
'                                            ReDim GoOnG(ElementNum)
'                                            For x = 0 To ElementNum
'
'                                                Seq3 = ElementSeq(x)
'                                                Seq2 = ElementSeq2(x)
'                                                GoOnG(x) = 1
'                                                If SpacerFlag > 0 Then
'                                                    If SpacerFlag < 4 Then
'                                                        UB = UBound(TreeDistance, 1)
'
'                                                       InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNoG(x), TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqsG(0, x), ValidSpacerG(0, x))
'
'
'                                                        If InRangeFlag = 0 Then GoOnG(x) = 0
'                                                    ElseIf SpacerFlag = 4 Then
'                                                        SpacerNoG(x) = 1
'                                                        SpacerSeqsG(1, x) = Spacer4No
'                                                    End If
'
'
'
'                                                    'Find Information rich subsequences (takes 11/21)
'
'                                                    If SpacerNoG(x) = 0 Then
'                                                        GoOnG(x) = 0
'                                                    End If
'                                                End If
'
'
'                                            Next x
'                                           ' ReDim XOverSeqnumWG(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3))
'                                            'WARNING: lenstrainseq here actually equals len(strainseq(0))+1
'
'                                            Dummy = FindSubSeqP8(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXOverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, ElementSeq2(0), ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
'
'                                                         'XX = XDiffposG(2000, 4)
'                                                        ' XX = LenXoverSeqG(0) '0
'                                            For x = 0 To ElementNum
'
'                                                Seq3 = ElementSeq(x)
'                                                Seq2 = ElementSeq2(x)
'                                                'If Maskseq(Seq3) = 0 Then
'
'                                                    LastY3 = -1
'                                                    b = b + 1
'                                                    ZZZ = ZZZ + 1
'                                                    'aaa = Abs(GetTickCount)
'                                                    'For X = 1 To 20
'                                                    '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79'
'                                                    If LenXOverSeqG(x) >= XoverWindow * 2 Then '0=0,2;162 =0,9; 0 = 0,10; 0 = 0,17; 0=0,19; 103 = 0,22:s1=79
'
'                                                        Call XOverV(0, x, LenXOverSeqG(x), SpacerNoG(x), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                        x = x
'                                                    End If
'                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
'                                            Next x
'        '                                    Else
'        '                                        For X = 0 To ElementNum
'        '                                            Seq3 = ElementSeq(X)
'        '                                            If DoScans(0, 0) = 1 Then
'        '                                                If FastestFlag = 1 Then
'        '
'        '                                                    NuminList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
'        '                                                    If ProgBinRead(0, Worthwhilescan(NuminList)) = 1 Then
'        '                                                        Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
'        '                                                        Unmissedscans = Unmissedscans + 1
'        '                                                    Else
'        '                                                        MissedScans = MissedScans + 1
'        '                                                    End If
'        '                                                Else
'        '                                                    Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
'        '                                                End If
'        '
'        '                                            End If
'        '                                        Next X
'                                        End If
'                                        If ExitDoFlag = 1 Then Exit Do
'                                    Loop
'                                End If
'
'                            End If
'
'                        End If
'                    Next g
'                End If
'                If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then    'Do geneconv
'                    ReDim GoOnG(GroupSize)  'this needs to be flushed
'                    'If DoScans(0, 1) = 1 Then
''                        ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
''                        ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
''                        ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
''                        ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
''                        ReDim LenXOverSeqG(GroupSize)
'                    'End If
'
'                    'ReDim LenXOverSeqG(GroupSize)
'                    For g = 1 To SLookupNum(0)
'                        Seq2 = SLookup(0, g)
'                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
'                            If Seq2 > sNextno Then
'                                tSeq2 = TraceSub(Seq2)
'                            Else
'                                tSeq2 = Seq2
'                            End If
'                            If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                            'If IsIn(Seq2) = 0 Then
'                                x = WinPPY + 1
'                                If Seq2 >= NextNo - RNum(WinPP) + x Then
''                                    If X = 12345 Then
'                                        x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
''                                    Else
''                                        For X = 0 To WinPPY
''                                            If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                        Next X
''                                    End If
''                                    For X = 0 To WinPPY
''                                        If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
''                                    Next X
'                                End If
'                                If x = WinPPY + 1 Then
'                                    H = g
'                                    ExitDoFlag = 0
'                                    Do
'                                        ElementNum = -1
'
'                                        Do
'
'                                            H = H + 1
'                                            If H > SLookupNum(1) Then
'                                                Do
'                                                    g = g + 1
'                                                    If g > SLookupNum(0) Then
'                                                        ExitDoFlag = 1
'                                                        Exit Do
'                                                    End If
'                                                    Seq2 = SLookup(0, g)
'                                                    If Seq2 > sNextno Then
'                                                        tSeq2 = TraceSub(Seq2)
'                                                    Else
'                                                        tSeq2 = Seq2
'                                                    End If
'                                                    If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                                                        If ActualSeqSize(Seq2) > MinSeqSize And TraceSub(Seq1) <> TraceSub(Seq2) Then
'                                                            H = g + 1
'                                                            If H > SLookupNum(1) Then
'                                                                ExitDoFlag = 1
'                                                                Exit Do
'                                                            Else
'                                                                Exit Do
'                                                            End If
'
'                                                           ' End If
'                                                        End If
'                                                    End If
'
'                                                Loop
'                                                If ExitDoFlag = 1 Then Exit Do
'                                                'Exit Do
'                                            End If
'                                            Seq3 = SLookup(1, H)
'                                            'If ExitDoFLag = 0 Then
'
'
'                                            If ActualSeqSize(Seq3) > MinSeqSize Then
'
'
'                                                x = WinPPY + 1
'                                                If Seq3 >= NextNo - RNum(WinPP) + x Then
'                                                    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
'                                                    'If X = X Then
'                                                        x = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
'                                                    'Else
''                                                        If CC > 0 Then
''                                                            X = X
''                                                        End If
''                                                        For X = 0 To WinPPY
''                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                                        Next X
''                                                        If X > 2 Then
''                                                            X = X
''                                                        End If
''                                                        If CC <> X Then
''                                                            X = X
''                                                        End If
'                                                    'End If
''                                                    For X = 0 To WinPPY
''                                                        If Seq3 = Nextno - RNum(WinPP) + X Then Exit For
''                                                    Next X
'                                                End If
'                                                If x = WinPPY + 1 Then
'                                                'If IsIn(Seq3) = 0 Then
'                                                    If Seq3 > sNextno Then
'                                                        tSeq3 = TraceSub(Seq3)
'                                                    Else
'                                                        tSeq3 = Seq3
'                                                    End If
'                                                    If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then '
'                                                        If TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
'                                                            GoOn = 1
'                                                            If SelGrpFlag > 0 Then
'                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
'                                                                If GrpTest >= 2 Then
'                                                                    GoOn = 0
'                                                                End If
'                                                            End If
'                                                            If GoOn = 1 And FastestFlag = 1 Then
'                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
'                                                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 And BusyWithExcludes = 0 Then
'                                                                    GoOn = 0
'                                                                End If
'                                                            End If
'                                                            If GoOn = 1 Then
'                                                                ElementNum = ElementNum + 1
'                                                                ElementSeq(ElementNum) = Seq3
'                                                                ElementSeq2(ElementNum) = Seq2
'                                                            End If
'                                                        End If
'                                                    End If
'                                                End If
'                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
'                                            'For Seq3 = Seq2 + 1 To Nextno
'                                            End If
'                                            If ElementNum = GroupSize Then Exit Do
'                                        Loop
'                                        If ElementNum > -1 Then
'                                            '@
'                                           Dummy = FindSubSeqGCAP4(UBound(NDiffG, 1), UBound(XPosDiffG, 1), UBound(SubSeqG, 1), UBound(SubSeqG, 2), ElementNum, LenXOverSeqG(0), GCIndelFlag, Len(StrainSeq(0)), Seq1, ElementSeq2(0), ElementSeq(0), SeqNum(0, 0), SubSeqG(0, 0, 0), XPosDiffG(0, 0), XDiffPosG(0, 0), NDiffG(0, 0), BinArray(0, 0))
''                                           Open "Test GCAP3.csv" For Output As #1
''                                            For X = 0 To ElementNum
''                                               ' For Y = 0 To 6
''                                                    Print #1, " "
''                                                    'For Z = 0 To LenXOverSeqG(X)
''                                                    For Z = 0 To Len(StrainSeq(0))
''                                                        'Print #1, SubSeqG(Z, Y, X)
''                                                        Print #1, XDiffPosG(Z, X)
''                                                    Next Z
''                                               ' Next Y
''
''                                            Next X
'
''                                            Close #1
'
'                                            Dummy = GetFragsP2(GoOnG(0), ElementNum, UBound(FragCountG, 1), UBound(FragScoreG, 1), UBound(FragScoreG, 2), UBound(SubSeq, 1), UBound(SubSeq, 2), CircularFlag, LenXOverSeqG(0), Len(StrainSeq(0)), GCDimSize, SubSeqG(0, 0, 0), FragStG(0, 0, 0), FragEnG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0))
'                                            GetMaxFragScoreP2 ElementNum, LenXOverSeqG(0), GCDimSize, CircularFlag, GCMissmatchPen, MissPenG(0, 0), MaxScorePosG(0, 0, 0), FragMaxScoreG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0), HiFragScoreG(0, 0), NDiffG(0, 0)
'                                            For x = 0 To ElementNum
'
'                                                Seq3 = ElementSeq(x)
'                                                Seq2 = ElementSeq2(x)
'                                                'If Maskseq(Seq3) = 0 Then
'
'                                                    LastY3 = -1
'                                                    b = b + 1
'                                                    ZZZ = ZZZ + 1
'                                                    'aaa = Abs(GetTickCount)
'                                                    'For X = 1 To 20
'                                                    '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79'
'                                                    If LenXOverSeqG(x) > 0 Then
'
'                                                        'Call GCXoverDV(X, FragStG(), FragEnG(), FragScoreG(), FragCountG(), LenXOverSeqG(X), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
'                                                        Call GCXoverDVI(HiFragScoreG(), FragMaxScoreG(), MaxScorePosG(), MissPenG(), x, FragStG(), FragEnG(), FragCountG(), LenXOverSeqG(x), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
'                                                    End If
'                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
'                                            Next x
'                                        End If
'                                        If ExitDoFlag = 1 Then Exit Do
'                                    Loop
'                                End If
'
'                            End If
'
'                        End If
'                    Next g
'                End If
'            End If
'            If BusyWithExcludes = 1 Or (DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Or (DoScans(0, 1) = 1 And GCDimSize >= 20000)) Then
'                For g = 1 To SLookupNum(0)
'                    Seq2 = SLookup(0, g)
'                    If ActualSeqSize(Seq2) > MinSeqSize And (TraceSub(Seq1) <> TraceSub(Seq2) Or BusyWithExcludes = 1) Then
'                        If Seq2 > sNextno Then
'                            tSeq2 = TraceSub(Seq2)
'                        Else
'                            tSeq2 = Seq2
'                        End If
'
'                        If DoPairs(TraceSub(Seq1), tSeq2) = 1 Then
'                            x = WinPPY + 1
'                            If Seq2 >= NextNo - RNum(WinPP) + x Then
'                                'If X = 12345 Then
'                                    x = FindNewX(WinPPY, WinPP, Seq2, NextNo, RNum(0))
''                                Else
''                                    For X = 0 To WinPPY
''                                        If Seq2 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                    Next X
''                                End If
''                                For X = 0 To WinPPY
''                                    If Seq2 = Nextno - RNum(WinPP) + X Then Exit For
''                                Next X
'                            End If
'                            If x = WinPPY + 1 Then
'
'                                For H = g + 1 To SLookupNum(1)
'                                    Seq3 = SLookup(1, H)
'
'                                    If FastestFlag = 1 Then
'                                        NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
'                                    End If
'                                    If Worthwhilescan(NumInList) > 0 Or BusyWithExcludes = 1 Then
'
'
'
'                                        '
'                                        If ActualSeqSize(Seq3) > MinSeqSize Then
'                                            x = WinPPY + 1
'                                            If Seq3 >= NextNo - RNum(WinPP) + x Then
'                                                'If X = X Then
'                                                        CC = FindNewX(WinPPY, WinPP, Seq3, NextNo, RNum(0))
'                                                    'Else
''                                                        If CC > 0 Then
''                                                            X = X
''                                                        End If
''                                                        For X = 0 To WinPPY
''                                                            If Seq3 = (Nextno - RNum(WinPP) + X) Then Exit For
''                                                        Next X
'''                                                        If X > 2 Then
''                                                            X = X
''                                                        End If
''                                                        If CC <> X Then
''                                                            X = X
''                                                        End If
'                                                    'End If
''                                                For X = 0 To WinPPY
''                                                    If Seq3 = Nextno - RNum(WinPP) + X Then Exit For
''                                                Next X
'                                            End If
'                                            If x = WinPPY + 1 Then
'                                                If Seq3 > sNextno Then
'                                                    tSeq3 = TraceSub(Seq3)
'                                                Else
'                                                    tSeq3 = Seq3
'                                                End If
'
'                                                If DoPairs(tSeq2, tSeq3) = 1 And DoPairs(TraceSub(Seq1), tSeq3) = 1 Then
'                                                    If (TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3)) Or BusyWithExcludes = 1 Then
'
'                                                        '
'                                                        If DoScans(0, 0) = 1 And BusyWithExcludes = 1 Then
'                                                            If FastestFlag = 0 Then
'                                                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                            Else
'                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
'                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                                    Unmissedscans = Unmissedscans + 1
'                                                                Else
'                                                                    MissedScans = MissedScans + 1
'                                                                End If
'                                                            End If
'                                                        End If
'
'
'
'                                                        If (DoScans(0, 1) = 1 And GCDimSize >= 20000) Or BusyWithExcludes = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                Call GCXoverD(0)
'                                                            Else
'
'                                                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                   Call GCXoverD(0)
'
'                                                                End If
'                                                            End If
'                                                        End If
'                                                        If DoScans(0, 2) = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                 Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
'                                                            Else
'
'                                                                If ProgBinRead(2, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
'                                                                End If
'                                                            End If
'                                                        End If
'                                                        '
'                                                        If DoScans(0, 3) = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                Call MCXoverF(FindAllFlagX, 0, 0)
'                                                            Else
'
'                                                                If ProgBinRead(3, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                   Call MCXoverF(FindAllFlagX, 0, 0)
'                                                                End If
'                                                            End If
'                                                        End If
'                                                       '
'                                                        If DoScans(0, 4) = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                 otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
'
'                                                                Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
'
'                                                                Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
'
'                                                                Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
'                                                            Else
'
'                                                                If ProgBinRead(4, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
'
'                                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
'
'                                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
'
'                                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
'                                                                End If
'                                                            End If
'
'
'
'                                                        End If
'
'
'
'
'                                                        If DoScans(0, 8) = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                 otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
'
'                                                                Call TSXOver(0)
'
'                                                                Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
'
'                                                                Call TSXOver(0)
'
'                                                                Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
'
'                                                                Call TSXOver(0)
'
'                                                                Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
'                                                            Else
'
'                                                                If ProgBinRead(6, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    otSeq1 = Seq1: otSeq2 = Seq2: otSeq3 = Seq3
'
'                                                                    Call TSXOver(0)
'
'                                                                    Seq1 = otSeq2: Seq2 = otSeq3: Seq3 = otSeq1
'
'                                                                    Call TSXOver(0)
'
'                                                                    Seq1 = otSeq3: Seq2 = otSeq1: Seq3 = otSeq2
'
'                                                                    Call TSXOver(0)
'
'                                                                    Seq1 = otSeq1: Seq2 = otSeq2: Seq3 = otSeq3
'                                                                End If
'                                                            End If
'
'
'                                                        End If
'                                                        If DoScans(0, 5) = 1 Then
'
'                                                            If FastestFlag = 0 Then
'                                                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
'                                                                Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
'                                                                Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
'                                                            Else
'
'                                                                If ProgBinRead(5, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
'                                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
'                                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
'                                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
'                                                                End If
'                                                            End If
'
'                                                        End If
'                                                    End If
'
'                                                End If
'                                                b = b + 1
'                                            End If
'
'                                            ET = Abs(GetTickCount)
'                                            If Abs(ET - GlobalTimer) > 500 Then
'
'                                                GlobalTimer = ET
'
'                                                Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
'                                                If Abs(ET - ELT) > 2000 Then
'                                                    ELT = ET
'                                                    If oTotRecs > 0 Then
'                                                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
'                                                        If PBV > Form1.ProgressBar1 Then
'                                                            Form1.ProgressBar1 = PBV
'                                                            Call UpdateF2Prog
'                                                        End If
'                                                    End If
'
'                                                End If
'
'                                                UpdateRecNums (SEventNumber)
'                                               Call UpdateTimeCaps(ET, SAll)
'                                               If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'                                                DoEvents 'covered by currentlyrunningflag
'                                                Form1.WindowState = Form1.WindowState
'                                                If AbortFlag = 1 Then
'                                                    WinPPY = NextNo
'                                                    g = NextNo
'                                                    H = NextNo
'                                                End If
'                                            End If
'                                        End If
'                                    End If
'                                Next H
'
'                            End If
'
'                        End If
'                    End If
'                Next g
'            End If
'        End If
'    Next WinPPY
'    'Next aaa
'    TT = Abs(GetTickCount)
'    If TT - GlobalTimer > 500 Then
'      GlobalTimer = TT
'        Form1.SSPanel1.Caption = Trim(Str(MCCorrectX)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
'        Form1.SSPanel1.Refresh
'        Form1.Refresh
'        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'    End If
End If

'If PermNextno > mempoc and x=1234567 Then
'    ReDim TreeDistance(0, 0)
'    ReDim Distance(0, 0)
'
'End If

If PermNextno > MemPoc Then
    ReDim PermValid(0, 0)
    ReDim PermDIffs(0, 0)
End If

End Sub



Public Sub InnerScan3(MCCorrectX As Double, STime As Long, SAll As Long, WinPP As Long, SLookup() As Long, ISeqs() As Long, RNum() As Long, RList() As Long, TraceSub() As Long, ActualSeqSize() As Long, SLookupNum() As Long, DoPairs() As Byte, FindallFlag As Long, WinNum As Long, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno As Long, MissingData() As Byte)
Dim oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, b As Long, FF As Long, oDirX As String, LT As Long, GoOn As Byte, IsIn() As Byte
Dim ZZZ As Long, Dummy As Long, TT As Long, xNextno As Long, PBV As Single, oTotRecs As Long, ELT As Long, ETx As Long, x As Long, g As Long, H As Long, WinPPY As Long, A As Long, Y As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
'XX = BusyWithExcludes

ReDim GPVTFont(5, 100), GPVText(100)
GPVTNum = -1
'XXX = 0
'yyy = 0
'For x = 0 To NextNo
'    XXX = XXX + CurrentXOver(x)
'    For Y = 0 To AddNum - 1
'        yyy = yyy + MaxXOP(Y, x)
'    Next Y
'Next x
'If XXX > 0 Or yyy > 0 Then
'
'End If
'x = x
LT = Abs(GetTickCount)

If PermNextno > MemPoc And (TempTreeDistanceDumpFlag = 1 Or UBound(TreeDistance, 1) = 0) Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim TreeDistance(UBTD1, UBTD1)
    Open "RDP5TreeDistance" + UFTag For Binary As #FF
    Get #FF, , TreeDistance
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End If

If UBound(Distance, 1) = 0 And PermNextno > MemPoc And x = 1234567 Then
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    FF = FreeFile
    'UBDistance = UBound(Distance, 1)
    XX = UBound(SCMat, 1)
    ReDim Distance(UBDistance, UBDistance)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Get #FF, , Distance()
    Close #FF
    'Erase Distance
    ChDir oDir
    ChDrive oDir

End If


If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    ReDim PermValid(UBPermValid, UBPermValid)
    Open "RDP5PermValid" + UFTag For Binary As #FF
    Get #FF, , PermValid()
    Close #FF
    
    
    ReDim PermDIffs(UBPermDiffs, UBPermDiffs)
    Open "RDP5PermDiffs" + UFTag For Binary As #FF
    Get #FF, , PermDIffs()
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
End If



LowestProb = pLowestProb
'Form1.Frame17.Visible = True
ReDim SubSeq(Len(StrainSeq(0)), 6)
If UseALFlag = 1 And BusyWithExcludes = 0 Then
    'is it necessery to redim this here?
    'XX = UBound(AnalysisList, 2)
    Dim FMatInFileFlag As Byte, UBF1 As Long, UBS1 As Long
    
    
    If TripListLen > 1000000 Then
    
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBF1 = 0: UBS1 = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        UBF1 = UBound(FMat, 1)
        UBS1 = UBound(SMat, 1)
        On Error GoTo 0
        If UBS1 > 0 Then
            Open "RDP5SMat" + UFTag For Binary As #FF
            Put #FF, , SMat()
            Close #FF
            ReDim SMat(0, 0)
        End If
        If UBF1 > -1 Then
            Open "RDP5FMat" + UFTag For Binary As #FF
            Put #FF, , FMat()
            Close #FF
            ReDim FMat(0, 0)
        End If
        FMatInFileFlag = 1
        
    
        On Error Resume Next
        Do
            
            ReDim Analysislist(2, TripListLen)
            If UBound(Analysislist, 2) < TripListLen Then
                TripListLen = CLng(TripListLen * 0.95)
            Else
                
                Exit Do
            End If
            
        Loop
        On Error GoTo 0
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        FF = FreeFile
        
        
        
        
        Open "RDP5AnalysisList" + UFTag For Binary As #FF
        Get #FF, , Analysislist
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
        'Erase AnalysisList
    Else
        '@
        ReDim Preserve Analysislist(2, TripListLen)
        x = x
    End If
    ''
    
    
'    XXX = 0
'            For x = 0 To NextNo
'                XXX = XXX + CurrentXOver(x) '586,225,9411,1210,365
'                '585,350,
'            Next x
'            x = x
    Dim RestartPos() As Long
    ReDim RestartPos(2)
    If DoScans(0, 0) = 1 Or DoScans(0, 1) = 1 Or DoScans(0, 3) = 1 Then
        
        Dim AList() As Integer
        Dim BAL As Variant, ALC As Long
        Dim RedoL3() As Byte, StepsX As Long, EPX As Long
        Call MakeScanCompressArrays(NextNo, SeqNum())
        If DoScans(0, 0) = 1 Then
            ReDim RestartPos(2)
            ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
            ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            '@'$
            ALC = MakeAListISP2(0, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), UBound(AList, 2), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'@
                    NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                    'If NumRedos > 0 Then
                        
                    For x = Y To EPX
    '                    If x = 475 Then
    '                        x = x
    '                    End If
                        If RedoL3(x) > 0 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            
                            ' Print #1, Str(Seq1) + "," + Str(Seq2) + "," + Str(Seq3)
                            ''22,245,285
                            CurrentTripListNum = x
                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                        Else
                            x = x
                        End If
                        x = x
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
                UseCompress = 0
                'End If
            End If
        End If
        'geneconv
        If DoScans(0, 1) = 1 Then
            GCIndelFlag = 0
            
            ReDim FragMaxScore(GCDimSize, 5)
            ReDim MaxScorePos(GCDimSize, 5)
            ReDim PVals(GCDimSize, 5)
            ReDim FragSt(GCDimSize, 6)
            ReDim FragEn(GCDimSize, 6)
            ReDim FragScore(GCDimSize, 6)
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            ReDim RestartPos(2)
            '$'$'$
            ALC = MakeAListISP2(1, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), UBound(AList, 2), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                    ' NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), ALC, Y, EPX, NextNo, UCTHresh,                 RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                    'If NumRedos > 0 Then
                    '@'@
                    For x = Y To EPX
                        If RedoL3(x) > 1 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            'ZZZ = ZZZ + 1
                            CurrentTripListNum = x
                            ''22,245,285
                             NewOneFound = 0
                            Call GCXoverD(0)
'                            If RedoL3(x) = 2 And NewOneFound = 1 Then
'                                x = x
'                            End If
'                            If NewOneFound = 0 Then
'                                x = x
'                            End If
                        ElseIf RedoL3(x) = 2 Then
                            Call AddToRedoList(1, AList(0, x), AList(1, x), AList(2, x))
                            x = x
                        End If
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
            End If
            UseCompress = 0
               
            
        End If
        'maxchi
        
        
'        Dim oXOl1() As XOverDefine, CXO1() As Integer, oXOl2() As XOverDefine, CXO2() As Integer
'        ReDim oXOl1(UBound(XoverList, 1), UBound(XoverList, 2)), CXO1(UBound(CurrentXOver))
'        For x = 0 To UBound(XoverList, 1)
'            For Y = 0 To UBound(XoverList, 2)
'                oXOl1(x, Y) = XoverList(x, Y)
'
'            Next Y
'        Next x
'        ReDim CXO1(UBound(CurrentXOver))
'        For x = 0 To UBound(CurrentXOver)
'            CXO1(x) = CurrentXOver(x)
'        Next x
        
        If DoScans(0, 3) = 1 Then
            
            
            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
            'BAL = TripListLen
            BAL = NextNo - (RNum(WinPP) + 1)
            BAL = (BAL + 1) * BAL
            BAL = BAL * (RNum(WinPP) + 1)
            If BAL > TripListLen Then
                BAL = TripListLen
            End If
            If BAL > 10000000 Then
                BAL = 10000000
            End If
            ReDim AList(2, BAL + 3 * RNum(WinPP))
            ALC = -1
            ReDim RestartPos(2)
            '$'$'$
            ALC = MakeAListISP2(3, RestartPos(0), UBound(ProgBinRead, 1), ProgBinRead(0, 0), TraceSub(0), WinPP, RNum(0), UBound(RList, 1), RList(0, 0), UBound(Analysislist, 1), Analysislist(0, 0), TripListLen, Worthwhilescan(0), ActualSeqSize(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), UBound(AList, 2), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0))
            If ALC > -1 Then
                ReDim RedoL3(ALC)
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh,                        RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0),        ALC,         Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    HWindowWidth = CLng(MCWinSize / 2)
                    lHWindowWidth = HWindowWidth
                    'NumRedos = AlistMC2(Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindallFlag, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, CDbl(LowestProb / MCCorrection), LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), , Chimap(0), ChiTable2(0))
                    
                    'If NumRedos > 0 Then
                    '@'@
                    For x = Y To EPX
                        If RedoL3(x) = 1 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            'ZZZ = ZZZ + 1
                            CurrentTripListNum = x
                            ''22,245,285
                            NewOneFound = 0
                            Call MCXoverF(0, 0, 0)
'                            If RedoL3(x) = 2 And NewOneFound = 1 Then
'                                x = x
'                            End If
'                            If NewOneFound = 0 Then
'                                x = x
'                            End If
                        ElseIf RedoL3(x) = 2 Then
                            
                            Call AddToRedoList(3, AList(0, x), AList(1, x), AList(2, x))
                            x = x
                        End If
                    Next x
                    'End If
                    
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        GlobalTimer = ET
                        LT = ET
                        'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                        Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        If Abs(ET - ELT) > 2000 Then
                            ELT = ET
                            If oTotRecs > 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                If PBV > Form1.ProgressBar1 Then
                                    Form1.ProgressBar1 = PBV
                                    Call UpdateF2Prog
                                End If
                            End If
                                    
                        End If
                        xNextno = NextNo
                        
                        DoEvents 'covered by currentlyrunningflag
                        NextNo = xNextno
                        If AbortFlag = 1 Then
                            WinPPY = NextNo
                            g = NextNo
                            H = NextNo
                        End If
                        UpdateRecNums (SEventNumber)
                        
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                        Call UpdateTimeCaps(ET, SAll)
                        
                        
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        If AbortFlag = 1 Then
                            Exit For
                        End If
    
                    End If
                Next Y
            End If
            UseCompress = 0
               
            
        End If
        
'        Close #1
'        XXX = 0
'            For x = 0 To NextNo
'                XXX = XXX + CurrentXOver(x) '586,225,9411,1210,365
'                '585,350,363,5552
'            Next x
'            x = x
'        x = x
'        Open "RecombsNew.csv" For Output As #1
'            For x = 0 To NextNo
'                For Y = 1 To CurrentXOver(x)
'                    Print #1, Str(x) + "," + Str(Y) + "," + Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).MajorP) + ","
'                Next Y
'            Next x
'        Close #1
        x = x
    End If
    
    
'    ReDim oXOl2(UBound(XoverList, 1), UBound(XoverList, 2)), CXO2(UBound(CurrentXOver))
'    For x = 0 To UBound(XoverList, 1)
'        For Y = 0 To UBound(XoverList, 2)
'            oXOl2(x, Y) = XoverList(x, Y)
'        Next Y
'    Next x
'    ReDim CXO2(UBound(CurrentXOver))
'        For x = 0 To UBound(CurrentXOver)
'            CXO2(x) = CurrentXOver(x)
'        Next x
'    ReDim XoverList(UBound(oXOl1, 1), UBound(oXOl1, 2))
'    For x = 0 To UBound(XoverList, 1)
'        For Y = 0 To UBound(XoverList, 2)
'             XoverList(x, Y) = oXOl1(x, Y)
'        Next Y
'    Next x
'    ReDim CXO1(UBound(CurrentXOver))
'    For x = 0 To UBound(CXO1)
'        CurrentXOver(x) = CXO1(x)
'    Next x
    
    If DoScans(0, 2) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then
        'Open "old.csv" For Output As #1
       
        Call MakeScanCompressArrays(NextNo, SeqNum())
            UseCompress = 1
            GCIndelFlag = 0 'need to use this with compression
        For x = 0 To TripListLen
'            If x = 66886 Then
'                x = x
'            End If
            
            '@'@'@'@'@'@'@'@'@
            If Worthwhilescan(x) > 0 Or BusyWithExcludes = 1 Then
                Seq1 = Analysislist(0, x) '17,17,17,17
                Seq2 = Analysislist(1, x) '686,686,687,687
                Seq3 = Analysislist(2, x) '1531,1798,690, 694,710,822,824,832,913
                CurrentTripListNum = x
                For WinPPY = 0 To RNum(WinPP)
                    '@'@'@'@'@
                    A = RList(WinPP, WinPPY)
                    If A <= PermNextno Then
                        b = A
                    Else
                        b = TraceSub(A)
                    End If
                    If Seq1 = b Or Seq2 = b Or Seq3 = b Then
                        If b = Seq1 Then
                            Seq1 = A
                        ElseIf b = Seq2 Then
                            Seq2 = A
                        ElseIf b = Seq3 Then
                            Seq3 = A
                        End If
                        If ActualSeqSize(Seq1) > MinSeqSize Then
                            If ActualSeqSize(Seq2) > MinSeqSize Then
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If DoPairs(Seq1, Seq2) = 1 And DoPairs(Seq1, Seq3) = 1 And DoPairs(Seq2, Seq3) = 1 Then
'                                         If ProgBinRead(0, Worthwhilescan(x)) = 1 Then
'                                            If DoScans(0, 0) = 1 Then
''                                                If FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV) = 1 Then
''                                                   ' Print #1, Str(Seq1) + "," + Str(Seq2) + "," + Str(Seq3)
''                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
''                                                End If
''                                                x = x
'                                            End If
'                                         End If
                                         'XX = UseCompress
                                         'XX = GCIndelFlag
'                                         If ProgBinRead(1, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
''                                            ReDim XDiffPos(Len(StrainSeq(0)) + 200)
''                                            ReDim XPosDiff(Len(StrainSeq(0)) + 200)
''                                            ReDim FragMaxScore(GCDimSize, 5)
''                                            ReDim MaxScorePos(GCDimSize, 5)
''                                            ReDim PVals(GCDimSize, 5)
''                                            ReDim FragSt(GCDimSize, 6)
''                                            ReDim FragEn(GCDimSize, 6)
''                                            ReDim FragScore(GCDimSize, 6)
''                                            ReDim DeleteArray(Len(StrainSeq(0)) + 1)
'                                            NewOneFound = 0
'                                            If DoScans(0, 1) = 1 Then Call GCXoverD(0)
'                                            x = x
'
'                                         End If
                                         If ProgBinRead(2, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                            If DoScans(0, 2) = 1 Then
                                                Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                            End If
                                         End If
'                                         If ProgBinRead(3, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
'                                            If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
'                                        End If
                                         If ProgBinRead(4, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                            If DoScans(0, 4) = 1 Then
                                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                            
                                                Call CXoverA(0, 0, 0)
                                                            
                                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                Call CXoverA(0, 0, 0)
                                                            
                                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                Call CXoverA(0, 0, 0)
                                                            
                                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                            End If
                                        End If
                                         
                                         If ProgBinRead(6, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                            If DoScans(0, 8) = 1 Then
                                                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                Call TSXOver(0)
                                                        
                                                Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                        
                                                Call TSXOver(0)
                                                        
                                                Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                        
                                                Call TSXOver(0)
                                                        
                                                Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                            End If
                                        End If
                                         If ProgBinRead(5, Worthwhilescan(x)) = 1 Or BusyWithExcludes = 1 Then
                                            If DoScans(0, 5) = 1 Then
                                                oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                            End If
                                        End If
                                    End If
                                
                                End If
                            End If
                        End If
                    End If
                    '@
                Next WinPPY
                ETx = Abs(GetTickCount)
                If Abs(ETx - GlobalTimer) > 500 Then
                                
                    GlobalTimer = ETx
                    'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                    Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                    Form1.SSPanel1.Refresh
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    
                    If Abs(ETx - ELT) > 2000 Then
                        ELT = ETx
                        If oTotRecs > 0 Then
                            PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                            If PBV > Form1.ProgressBar1 Then
                                Form1.ProgressBar1 = PBV
                                Call UpdateF2Prog
                            End If
                        End If
                                
                    End If
                    xNextno = NextNo
                    
                    DoEvents 'covered by currentlyrunningflag
                    NextNo = xNextno
                    If AbortFlag = 1 Then
                        WinPPY = NextNo
                        g = NextNo
                        H = NextNo
                    End If
                    UpdateRecNums (SEventNumber)
                    
                    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(ETx, SAll)
                    
                    
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                    
                End If
            End If
            '@'@
        Next x
        UseCompress = 0
'        Close #1
'        Open "RecombsOld.csv" For Output As #1
'            For x = 0 To NextNo
'                For Y = 1 To CurrentXOver(x)
'                    Print #1, Str(x) + "," + Str(Y) + "," + Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).MajorP) + ","
'                Next Y
'            Next x
'        Close #1
'         XXX = 0
'            For x = 0 To NextNo
'                XXX = XXX + CurrentXOver(x) '586,225,9411,1210,365
'                '585,350,363,5552
'            Next x
'            x = x
    End If
    
'    For x = 0 To UBound(XoverList, 1)
'        For Y = 0 To UBound(XoverList, 2)
'            If oXOl2(x, Y).Daughter <> XoverList(x, Y).Daughter Or oXOl2(x, Y).MajorP <> XoverList(x, Y).MajorP Or oXOl2(x, Y).MinorP <> XoverList(x, Y).MinorP Or oXOl2(x, Y).Beginning <> XoverList(x, Y).Beginning Or oXOl2(x, Y).Ending <> XoverList(x, Y).Ending Then
'                x = x
'            End If
'        Next Y
'    Next x
    
    
    
    
    
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = Trim(Str(TripListLen)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
    '    Form1.SSPanel1.Refresh
    '    Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    'DoEvents
    End If
    If TripListLen > 1000000 Then
        Erase Analysislist
        
    End If
    If FMatInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        
        If UBS1 > 0 Then
            ReDim SMat(UBS1, UBS1)
            Open "RDP5SMat" + UFTag For Binary As #FF
            Get #FF, , SMat()
            Close #FF
        End If
        If UBF1 > 0 Then
            ReDim FMat(UBF1, UBF1)
            Open "RDP5FMat" + UFTag For Binary As #FF
            Get #FF, , FMat()
            Close #FF
        End If
        FMatInFileFlag = 0
    End If
    
ElseIf BusyWithExcludes = 0 Then
    'For aaa = 1 To 10
    
    Dim NumInList As Long
    ReDim BinArray(Len(StrainSeq(0)), NextNo)
    Dim GoOnG() As Byte, ExitDoFlag As Byte, UB As Long, ElementNum As Long, LenXOverSeqG() As Long, ElementSeq() As Long, ElementSeq2() As Long, XPosDiffG() As Long, XDiffPosG() As Long, AHG() As Long, XOverSeqnumWG() As Byte
    Dim GrpTest As Long
    Dim SpacerSeqsG() As Integer, ValidSpacerG() As Integer, SpacerNoG() As Integer
    
    Dim NDiffG() As Long, SubSeqG() As Byte
    Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long
    Dim HiFragScoreG() As Long, FragMaxScoreG() As Long, MaxScorePosG() As Long, MissPenG() As Double

    
    
    GroupSize = 31
    If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
        GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
    End If
    If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
        ReDim ElementSeq(GroupSize)
        ReDim ElementSeq2(GroupSize)
        ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize)
        ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize)
        ReDim GoOnG(GroupSize)
        ReDim LenXOverSeqG(GroupSize)
    End If
    If DoScans(0, 0) = 1 And BusyWithExcludes = 0 Then
        ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
        UB = UBound(TreeDistance, 1)
        ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
        ReDim Preserve MaskSeq(UB)
        
        
        'ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize), ElementSeq(GroupSize), ElementSeq2(GroupSize)
    End If
    '@
    If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then
        ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
        '@
        ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
        ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
        
        'ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize), ElementSeq(GroupSize), ElementSeq2(GroupSize)
    End If
    
    For WinPPY = 0 To RNum(WinPP)
      'For Seq1 = 0 To Nextno
        'scan seqx against all the rest
        ' ie similar to individualA scan
        
        Seq1 = RList(WinPP, WinPPY)
        
        GoOn = 0
        If IndividualA = TraceSub(ISeqs(WinPP)) Or IndividualB = TraceSub(ISeqs(WinPP)) Then
            If TraceSub(Seq1) = IndividualA Or TraceSub(Seq1) = IndividualB Then
                GoOn = 1
            End If
        Else
            GoOn = 1
        End If
        
        GoOn = 1
        Dim oG As Long
        If Seq1 > UBound(MaskSeq, 1) Then ReDim Preserve MaskSeq(Seq1 + 10)
        If GoOn = 1 And ActualSeqSize(Seq1) > MinSeqSize And MaskSeq(Seq1) = 0 Then
            
            ReDim IsIn(NextNo)
            For x = 0 To WinPPY
                IsIn(RList(WinPP, x)) = 1
            Next x
            If IndividualA = -1 And IndividualB = -1 Then
                
                
                'XX = UBound(BinArray, 2)
                
                If (DoScans(0, 0) = 1 Or DoScans(0, 1) = 1) And BusyWithExcludes = 0 Then
                
                    
                
                
                    Dummy = MakeBinArray2P(UBound(PermValid, 1), PermValid(0, 0), UBound(DoPairs, 1), DoPairs(0, 0), Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0), SLookupNum(0), SLookup(0, 0), IsIn(0), TraceSub(0), ActualSeqSize(0), MinSeqSize)
                    If DoScans(0, 0) = 1 Then 'Do RDP
                        'If DoScans(0, 0) = 1 Then
'                            ReDim AHG(2, GroupSize), XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
'                            UB = UBound(TreeDistance, 1)
'                            ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
'                            ReDim Preserve Maskseq(UB)
'                            ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
                            'ReDim LenXOverSeqG(GroupSize)
                            
                       ' End If
                        'ReDim LenXOverSeqG(GroupSize)
                        ReDim GoOnG(GroupSize)  'this needs to be flushed
                        For g = 1 To SLookupNum(0)
                            Seq2 = SLookup(0, g)
                            If ActualSeqSize(Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize Then
                                If IsIn(Seq2) = 0 And DoPairs(Seq1, Seq2) = 1 Then
                                    
                                    
                        
                                    H = g
                                    ExitDoFlag = 0
                                    Do
                                        ElementNum = -1
                
                                        Do
                
                                            H = H + 1
                                            If H > SLookupNum(1) Then
                                                Do
                                                    g = g + 1
                                                    If g > SLookupNum(0) Then
                                                        ExitDoFlag = 1
                                                        Exit Do
                                                    End If
                                                    Seq2 = SLookup(0, g)
                                                    If ActualSeqSize(Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize And DoPairs(Seq1, Seq2) = 1 Then
                                                        If IsIn(Seq2) = 0 Then
                                                            H = g + 1
                                                            If H > SLookupNum(1) Then
                                                                ExitDoFlag = 1
                                                                Exit Do
                                                            Else
                                                                Exit Do
                                                            End If
                                                           
                                                        End If
                                                    End If
                                                
                                                Loop
                                                If ExitDoFlag = 1 Then Exit Do
                                                'Exit Do
                                            End If
                                            Seq3 = SLookup(1, H)
                                            'If ExitDoFLag = 0 Then
                                            
                
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                If IsIn(Seq3) = 0 Then
                                                    If DoPairs(Seq2, Seq3) = 1 Then '
                                                        If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                                            GoOn = 1
                                                            If SelGrpFlag > 0 Then
                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                                If GrpTest >= 2 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 And FastestFlag = 1 Then
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 0 And BusyWithExcludes = 0 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 Then
                                                                ElementNum = ElementNum + 1
                                                                ElementSeq(ElementNum) = Seq3
                                                                ElementSeq2(ElementNum) = Seq2
                                                            End If
                                                        End If
                                                    End If
                                                End If
                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                                            'For Seq3 = Seq2 + 1 To Nextno
                                            End If
                                            If ElementNum = GroupSize Then Exit Do
                                        Loop
                                        If ElementNum > -1 Then
                                            ReDim GoOnG(ElementNum)
                                            For x = 0 To ElementNum
                
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                GoOnG(x) = 1
                                                
                                                If SpacerFlag > 0 Then
                                                    If SpacerFlag < 4 Then
                                                        UB = UBound(TreeDistance, 1)
                
                                                       InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNoG(x), TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqsG(0, x), ValidSpacerG(0, x))
                
                
                                                        If InRangeFlag = 0 Then GoOnG(x) = 0
                                                    ElseIf SpacerFlag = 4 Then
                                                        SpacerNoG(x) = 1
                                                        SpacerSeqsG(1, x) = Spacer4No
                                                    End If
                
                
                
                                                    'Find Information rich subsequences (takes 11/21)
                
                                                    If SpacerNoG(x) = 0 Then
                                                        GoOnG(x) = 0
                                                    End If
                                                End If
                
                
                                            Next x
                                           ' ReDim XOverSeqnumWG(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3))
                                            'WARNING: lenstrainseq here actually equals len(strainseq(0))+1
                                            '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                                            '@
                                            Dummy = FindSubSeqP8(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXOverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, ElementSeq2(0), ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
                
                '                                         XX = XDiffposG(2000, 1)
                '                                         XX = LenXoverSeqG(1)
                                            '@
                                            For x = 0 To ElementNum
                                                    
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                'If Maskseq(Seq3) = 0 Then
'                                                XX = OriginalName(Seq1)
'                                                XX = OriginalName(Seq2)
'                                                XX = OriginalName(Seq3)
                                                    LastY3 = -1
                                                    b = b + 1
                                                    ZZZ = ZZZ + 1
                                                    'aaa = Abs(GetTickCount)
                                                    'For X = 1 To 20                                            '
                                                    If LenXOverSeqG(x) >= XoverWindow * 2 Then
                
                                                        Call XOverV(0, x, LenXOverSeqG(x), SpacerNoG(x), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    End If
                                                    x = x
                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
                                            Next x
    '                                    Else
    '                                        For X = 0 To ElementNum
    '                                            Seq3 = ElementSeq(X)
    '                                            If DoScans(0, 0) = 1 Then
    '                                                If FastestFlag = 1 Then
    '
    '                                                    NuminList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
    '                                                    If ProgBinRead(0, Worthwhilescan(NuminList)) = 1 Then
    '                                                        Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
    '                                                        Unmissedscans = Unmissedscans + 1
    '                                                    Else
    '                                                        MissedScans = MissedScans + 1
    '                                                    End If
    '                                                Else
    '                                                    Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
    '                                                End If
    '
    '                                            End If
    '                                        Next X
                                        End If
                                        If ExitDoFlag = 1 Then Exit Do
                                    Loop
                
                                End If
                            
                            End If
                        Next g
                    End If
                    If DoScans(0, 1) = 1 And GCDimSize < 20000 And BusyWithExcludes = 0 Then  'Do geneconv
                        'If DoScans(0, 1) = 1 Then
'                            ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize)
'                            ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize)
'                            ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize)
'                            ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize), GoOnG(GroupSize)
                            'ReDim LenXOverSeqG(GroupSize)
                        'End If
                        ReDim GoOnG(GroupSize) 'this needs to be flushed
                        'ReDim LenXOverSeqG(GroupSize)
                        For g = 1 To SLookupNum(0)
                            Seq2 = SLookup(0, g)
                            If ActualSeqSize(Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize Then
                                If IsIn(Seq2) = 0 And DoPairs(Seq1, Seq2) = 1 Then
                                    
                                    
                        
                                    H = g
                                    ExitDoFlag = 0
                                    Do
                                        ElementNum = -1
                
                                        Do
                
                                            H = H + 1
                                            If H > SLookupNum(1) Then
                                                Do
                                                    g = g + 1
                                                    If g > SLookupNum(0) Then
                                                        ExitDoFlag = 1
                                                        Exit Do
                                                    End If
                                                    Seq2 = SLookup(0, g)
                                                    If ActualSeqSize(Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize And DoPairs(Seq1, Seq2) = 1 Then
                                                        If IsIn(Seq2) = 0 Then
                                                            H = g + 1
                                                            If H > SLookupNum(1) Then
                                                                ExitDoFlag = 1
                                                                Exit Do
                                                            Else
                                                                Exit Do
                                                            End If
                                                           
                                                        End If
                                                    End If
                                                
                                                Loop
                                                If ExitDoFlag = 1 Then Exit Do
                                                'Exit Do
                                            End If
                                            Seq3 = SLookup(1, H)
                                            'If ExitDoFLag = 0 Then
                
                
                                            If ActualSeqSize(Seq3) > MinSeqSize Then
                                                If IsIn(Seq3) = 0 Then
                                                    If DoPairs(Seq2, Seq3) = 1 Then '
                                                        If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                                            GoOn = 1
                                                            If SelGrpFlag > 0 Then
                                                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                                If GrpTest >= 2 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 And FastestFlag = 1 Then
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                '@
                                                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 And BusyWithExcludes = 0 Then
                                                                    GoOn = 0
                                                                End If
                                                            End If
                                                            If GoOn = 1 Then
                                                                ElementNum = ElementNum + 1
                                                                ElementSeq(ElementNum) = Seq3
                                                                ElementSeq2(ElementNum) = Seq2
                                                            End If
                                                        End If
                                                    End If
                                                End If
                                            'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                                            'For Seq3 = Seq2 + 1 To Nextno
                                            End If
                                            If ElementNum = GroupSize Then Exit Do
                                        Loop
                                        If ElementNum > -1 Then
                                            'ReDim GoOnG(ElementNum)
                                            'ReDim NDiffG(6, GroupSize)
                                            
                                           ' ReDim XOverSeqnumWG(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3))
                                            'WARNING: lenstrainseq here actually equals len(strainseq(0))+1
                                            '
                                            'Dummy = FindSubSeqP8(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXOverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, ElementSeq2(0), ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
                                            '@
                                            Dummy = FindSubSeqGCAP4(UBound(NDiffG, 1), UBound(XPosDiffG, 1), UBound(SubSeqG, 1), UBound(SubSeqG, 2), ElementNum, LenXOverSeqG(0), GCIndelFlag, Len(StrainSeq(0)), Seq1, ElementSeq2(0), ElementSeq(0), SeqNum(0, 0), SubSeqG(0, 0, 0), XPosDiffG(0, 0), XDiffPosG(0, 0), NDiffG(0, 0), BinArray(0, 0))
'                                           Open "Test GCAP3.csv" For Output As #1
'                                            For X = 0 To ElementNum
'                                               ' For Y = 0 To 6
'                                                    Print #1, " "
'                                                    'For Z = 0 To LenXOverSeqG(X)
'                                                    For Z = 0 To Len(StrainSeq(0))
'                                                        'Print #1, SubSeqG(Z, Y, X)
'                                                        Print #1, XDiffPosG(Z, X)
'                                                    Next Z
'                                               ' Next Y
'
'                                            Next X
                                            
'                                            Close #1
                                            Dummy = GetFragsP2(GoOnG(0), ElementNum, UBound(FragCountG, 1), UBound(FragScoreG, 1), UBound(FragScoreG, 2), UBound(SubSeq, 1), UBound(SubSeq, 2), CircularFlag, LenXOverSeqG(0), Len(StrainSeq(0)), GCDimSize, SubSeqG(0, 0, 0), FragStG(0, 0, 0), FragEnG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0))
                                            GetMaxFragScoreP2 ElementNum, LenXOverSeqG(0), GCDimSize, CircularFlag, GCMissmatchPen, MissPenG(0, 0), MaxScorePosG(0, 0, 0), FragMaxScoreG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0), HiFragScoreG(0, 0), NDiffG(0, 0)
              
                                            For x = 0 To ElementNum
                
                                                Seq3 = ElementSeq(x)
                                                Seq2 = ElementSeq2(x)
                                                'If Maskseq(Seq3) = 0 Then
                
                                                    LastY3 = -1
                                                    b = b + 1
                                                    ZZZ = ZZZ + 1
                                                    'aaa = Abs(GetTickCount)
                                                    'For X = 1 To 20                                            '
                                                    If LenXOverSeqG(x) > 0 Then
                
                                                        'Call GCXoverDV(X, FragStG(), FragEnG(), FragScoreG(), FragCountG(), LenXOverSeqG(X), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                                        Call GCXoverDVI(HiFragScoreG(), FragMaxScoreG(), MaxScorePosG(), MissPenG(), x, FragStG(), FragEnG(), FragCountG(), LenXOverSeqG(x), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                                    End If
                                                    'If DoScans(0, 3) = 1 Then Call MCXoverFIV(X, LenXoverSeqG(X), 0, 0, 0)
                                            Next x
    '                                    Else
    '                                        For X = 0 To ElementNum
    '                                            Seq3 = ElementSeq(X)
    '                                            If DoScans(0, 0) = 1 Then
    '                                                If FastestFlag = 1 Then
    '
    '                                                    NuminList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
    '                                                    If ProgBinRead(0, Worthwhilescan(NuminList)) = 1 Then
    '                                                        Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
    '                                                        Unmissedscans = Unmissedscans + 1
    '                                                    Else
    '                                                        MissedScans = MissedScans + 1
    '                                                    End If
    '                                                Else
    '                                                    Call XOver(SeqNum(), Seq1, Seq2, Seq3, 0)
    '                                                End If
    '
    '                                            End If
    '                                        Next X
                                        End If
                                        If ExitDoFlag = 1 Then Exit Do
                                    Loop
                
                                End If
                            
                            End If
                        Next g
                    End If
                End If
                
                
                If BusyWithExcludes = 1 Or (DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Or (DoScans(0, 1) = 1 And GCDimSize >= 20000)) Then
                    For g = 1 To SLookupNum(0)
                        Seq2 = SLookup(0, g)
                        If ActualSeqSize(Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize Then
                            If IsIn(Seq2) = 0 And DoPairs(Seq1, Seq2) = 1 Then
                                
                                
                                For H = g + 1 To SLookupNum(1)
                                    
                                    
                                    
                                    Seq3 = SLookup(1, H)
                                    If ActualSeqSize(Seq3) > MinSeqSize Then
                                        If IsIn(Seq3) = 0 Then
                                            If DoPairs(Seq2, Seq3) = 1 Then '
                                                If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                                    'If X = X Or SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
            
                                                        If (TraceSub(Seq1) <> TraceSub(Seq2) And TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3)) Or BusyWithExcludes = 1 Then
        '                                                     AA = Abs(GetTickCount)
        '                                                    For zzz = 1 To 100
                                                            If DoScans(0, 0) = 1 And BusyWithExcludes = 1 Then
                                                                If FastestFlag = 1 Then
    
                                                                    NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                    If ProgBinRead(0, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                        Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                        Unmissedscans = Unmissedscans + 1
                                                                    Else
                                                                        MissedScans = MissedScans + 1
                                                                    End If
                                                                Else
                                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                End If
    
                                                            End If
        '                                                    Next zzz
        '                                                    BB = Abs(GetTickCount)
        '                                                    CC = BB - AA
                                                            
                                                           If FastestFlag = 1 Then
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                            End If
                                                            
                                                            
                                                            
                                                            
                                                             
                                                             If (DoScans(0, 1) = 1 And GCDimSize >= 20000) Or BusyWithExcludes = 1 Then
                                                             'XX = UBound(Worthwhilescan, 1)
                                                                 'Call GCXoverD(0)
                                                                 If FastestFlag = 0 Then
                                                                     Call GCXoverD(0)
                                                                 Else
    
                                                                     If ProgBinRead(1, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                        Call GCXoverD(0)
    
                                                                     End If
                                                                 End If
                                                             End If
                                    
    
    
                                                             If DoScans(0, 2) = 1 Then
                                                                
                                                                 If FastestFlag = 0 Then
                                                                      Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                 Else
                                                                     
                                                                     If ProgBinRead(2, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                         Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                                     End If
                                                                 End If
                                                             End If
                                                             '
                                                             If DoScans(0, 3) = 1 Then
                                                                 
                                                                 If FastestFlag = 0 Then
                                                                     Call MCXoverF(0, 0, 0)
                                                                 Else
                                                                     
                                                                     If ProgBinRead(3, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                        Call MCXoverF(0, 0, 0)
                                                                     End If
                                                                 End If
                                                             End If
                                                            '
                                                             If DoScans(0, 4) = 1 Then
                                                             
                                                                 If FastestFlag = 0 Then
                                                                      tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                             
                                                                     Call CXoverA(0, 0, 0)
                                                                                 
                                                                     Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                 
                                                                     Call CXoverA(0, 0, 0)
                                                                                 
                                                                     Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                 
                                                                     Call CXoverA(0, 0, 0)
                                                                                 
                                                                     Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                                 Else
                                                                     
                                                                     If ProgBinRead(4, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                         tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                 
                                                                         Call CXoverA(0, 0, 0)
                                                                                     
                                                                         Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                     
                                                                         Call CXoverA(0, 0, 0)
                                                                                     
                                                                         Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                     
                                                                         Call CXoverA(0, 0, 0)
                                                                                     
                                                                         Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                                     End If
                                                                 End If
                                                             
                                                             
                                                                
                                                             End If
                                                             
                                                             
                                                             
                                                             
                                                             If DoScans(0, 8) = 1 Then
                                                                 
                                                                 If FastestFlag = 0 Then
                                                                      tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                         
                                                                     Call TSXOver(0)
                                                                             
                                                                     Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                             
                                                                     Call TSXOver(0)
                                                                             
                                                                     Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                             
                                                                     Call TSXOver(0)
                                                                             
                                                                     Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                                 Else
                                                                    
                                                                     If ProgBinRead(6, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                         tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                         
                                                                         Call TSXOver(0)
                                                                                 
                                                                         Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                 
                                                                         Call TSXOver(0)
                                                                                 
                                                                         Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                 
                                                                         Call TSXOver(0)
                                                                                 
                                                                         Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                                     End If
                                                                 End If
                                                                 
                                                                
                                                             End If
                                                             If DoScans(0, 5) = 1 Then
                                                                 
                                                                 If FastestFlag = 0 Then
                                                                     oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                     Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                     Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                 Else
                                                                     
                                                                     If ProgBinRead(5, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                         oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                                         Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                                         Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                                     End If
                                                                 End If
                                                                 
                                                             End If
                                                            
                                                            
                                                            
                                                            b = b + 1
                                                            
                                                        End If
                                                        
                                                    'End If
                                                End If
                                                
                                            'Else
                                            '    X = X
                                            End If
                                        End If
                                    End If
                                    ET = Abs(GetTickCount)
                                    '
                                    If Abs(ET - GlobalTimer) > 500 Then
                                        If AbortFlag = 1 Then Exit For
                                        GlobalTimer = ET
                                        Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                                        If Abs(ET - ELT) > 2000 Then
                                            ELT = ET
                                            If oTotRecs > 0 Then
                                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                                If PBV > Form1.ProgressBar1 Then
                                                    Form1.ProgressBar1 = PBV
                                                    Call UpdateF2Prog
                                                End If
                                            End If
                                                    
                                        End If
                                        
                                        
                                        
                                        
                                        If AbortFlag = 1 Then
                                            WinPPY = NextNo
                                            g = NextNo
                                            H = NextNo
                                        End If
                                        UpdateRecNums (SEventNumber)
                                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                        Call UpdateTimeCaps(ET, SAll)
                                        Form1.Refresh
                                        xNextno = NextNo
                                        
                                        DoEvents 'covered by currentlyrunningflag
                                        Form1.WindowState = Form1.WindowState
                                        NextNo = xNextno
                                    End If
                                Next H
                            End If
                        End If
                        If AbortFlag = 1 Then Exit For
                    Next g
                End If
            Else
            'For Seq2 = Seq1 + 1 To Nextno
                For g = 1 To SLookupNum(0)
                    Seq2 = SLookup(0, g)
                    If ActualSeqSize(Seq2) > MinSeqSize Then
                        If IsIn(Seq2) = 0 Then
                            For H = g + 1 To SLookupNum(1)
                                Seq3 = SLookup(1, H)
                                If ActualSeqSize(Seq3) > MinSeqSize Then
                                    If IsIn(Seq3) = 0 Then
                                        If DoPairs(Seq2, Seq3) = 1 Then '
                                            If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                                'If X = X Or SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
        
                                                    If TraceSub(Seq1) <> TraceSub(Seq2) And TraceSub(Seq1) <> TraceSub(Seq3) And TraceSub(Seq2) <> TraceSub(Seq3) Then
    '                                                     AA = Abs(GetTickCount)
    '                                                    For zzz = 1 To 100
                                                        If DoScans(0, 0) = 1 Then
                                                            If FastestFlag = 1 Then
                                                            
                                                                NumInList = GetNumInList(TraceSub(Seq1), TraceSub(Seq2), TraceSub(Seq3))
                                                                If ProgBinRead(0, Worthwhilescan(NumInList)) = 1 Or BusyWithExcludes = 1 Then
                                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                    Unmissedscans = Unmissedscans + 1
                                                                Else
                                                                    MissedScans = MissedScans + 1
                                                                End If
                                                            Else
                                                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                                x = x
                                                            End If
                                                                
                                                        End If
    '                                                    Next zzz
    '                                                    BB = Abs(GetTickCount)
    '                                                    CC = BB - AA
                                                        '
                                                        If DoScans(0, 1) = 1 Then Call GCXoverD(0)
    
                                                        
                                                        If DoScans(0, 2) = 1 Then
                                                                'BSStepsize = BSStepsize
                                                            Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                        End If
                                                        
                                                        If DoScans(0, 3) = 1 Then Call MCXoverF(0, 0, 0)
                                                        
                                                        
                                                        If DoScans(0, 4) = 1 Then
                                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                    
                                                            Call CXoverA(0, 0, 0)
                                                                    
                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                    
                                                            Call CXoverA(0, 0, 0)
                                                                    
                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                    
                                                            Call CXoverA(0, 0, 0)
                                                                    
                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                        End If
                                                        If DoScans(0, 8) = 1 Then
                                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                    
                                                            Call TSXOver(0)
                                                                    
                                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                        End If
                                                        If DoScans(0, 5) = 1 Then
                                                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                            Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                        End If
                                                        b = b + 1
                                                        
                                                    End If
                                                    
                                                'End If
                                            End If
                                            
                                        'Else
                                        '    X = X
                                        End If
                                    End If
                                End If
                                ET = Abs(GetTickCount)
                                '
                                If Abs(ET - GlobalTimer) > 500 Then
                                    If AbortFlag = 1 Then Exit For
                                    GlobalTimer = ET
                                    Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                                    If Abs(ET - ELT) > 2000 Then
                                        ELT = ET
                                        If oTotRecs > 0 Then
                                            PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                            If PBV > Form1.ProgressBar1 Then
                                                Form1.ProgressBar1 = PBV
                                                Call UpdateF2Prog
                                            End If
                                        End If
                                                
                                    End If
                                    
                                    
                                    
                                    
                                    If AbortFlag = 1 Then
                                        WinPPY = NextNo
                                        g = NextNo
                                        H = NextNo
                                    End If
                                    UpdateRecNums (SEventNumber)
                                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                                    Call UpdateTimeCaps(ET, SAll)
                                    Form1.Refresh
                                    xNextno = NextNo
                                    DoEvents 'covered by currentlyrunning flag
                                    NextNo = xNextno
                                End If
                            Next H
                        End If
                    End If
                    If AbortFlag = 1 Then Exit For
                Next g
            End If
        End If
        If BusyWithExcludes = 1 Then
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                    ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
                        XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MajorP > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
                    ElseIf XoverList(x, Y).MinorP > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                    ElseIf XoverList(x, Y).Daughter > PermNextno Then
                        XoverList(x, Y).EndP = 0
                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                    'XX = XoverList(x, Y).EndP '0
                    End If
'                    'XoverList(x, Y).EndP = OriginalPos(Seq)
'                    If XoverList(x, Y).MajorP > PermNextno Then
'                        'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).MajorP)
'                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (x + 1))
'                    ElseIf XoverList(x, Y).MinorP > PermNextno Then
'                        'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).MinorP)
'                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (x + 1))
'                    ElseIf XoverList(x, Y).Daughter > PermNextno Then
'                        'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).Daughter)
'                        XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (x + 1))
'                    End If
                Next Y
            Next x
        End If
        
        If AbortFlag = 1 Then Exit For
    Next WinPPY
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
    'Next aaa
        Form1.SSPanel1.Caption = Trim(Str(MCCorrection)) & " of " & Trim(Str(MCCorrection)) & " triplets reexamined"
    '    Form1.SSPanel1.Refresh
    '    Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
ElseIf BusyWithExcludes = 1 Then
    oDWS = DontWorryAboutSplitsFlag
    DontWorryAboutSplitsFlag = 1
    Dim Spos1 As Long, spos2 As Long
    'If (NextNo - PermNextno) > 100 Then 'probably worthwhile to do sequence compression
    
    'End If
    If DoScans(0, 0) = 1 Then
        ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    End If
    'Dim RestartPos() As Long
    ReDim RestartPos(2)
    If DoScans(0, 0) = 1 Or DoScans(0, 1) = 1 Or DoScans(0, 3) = 1 Then
        BAL = (PermNextno + 1)
        BAL = BAL * (NextNo)
        BAL = BAL * (NextNo - 1)
        BAL = CLng(BAL / 6 + 1)
        If BAL <= 6000000 Then
            ReDim AList(2, BAL)
        Else
            ReDim AList(2, 6000000)
        End If
        'Dim AList2() As Integer
        'ReDim AList2(2, BAL)
        'ReDim AList(2, BAL)
        Dim ProgP As Single, ProgS As Single
        ProgS = 0
        Do While RestartPos(0) > -1
            'If x = x Then
                ALC = MakeAListISE(RestartPos(0), PermNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DoPairs, 1), DoPairs(0, 0), UBound(PermValid, 1), PermValid(0, 0))
                
'            Else
'
'
'                ALC = -1
'                For Seq1 = 0 To PermNextno
'                    For Seq2 = Seq1 + 1 To NextNo
'                        If DoPairs(Seq1, Seq2) = 1 Then
'                        If Seq1 <> Seq2 Then
'                            If Seq2 > PermNextno Then
'                                Spos = Seq2 + 1
'                            Else
'                                Spos = PermNextno + 1
'                            End If
'                            For Seq3 = Spos To NextNo
'                                If DoPairs(Seq1, Seq3) = 1 And DoPairs(Seq2, Seq3) = 1 Then
'                                    If Seq1 <= UBound(PermValid, 2) And Seq2 <= UBound(PermValid, 2) And Seq3 <= UBound(PermValid, 2) Then
'                                        If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
'                                            If Seq1 <= NextNo And Seq2 <= NextNo And Seq3 <= NextNo Then
'                                                ALC = ALC + 1
'    '                                            If ALC = 260 Then
'    '                                                x = x
'    '                                            End If
'                                                AList(0, ALC) = Seq1
'                                                AList(1, ALC) = Seq2
'                                                AList(2, ALC) = Seq3
'    '                                            XX = AList2(0, ALC)
'    '                                            XX = AList2(1, ALC)
'    '                                            XX = AList2(2, ALC)
'    '                                            x = x
'                                            End If
'                                        End If
'                                    End If
'
'                                End If
'                            Next Seq3
'                        End If
'                        End If
'                    Next Seq2
'                Next Seq1
'            End If
    '        For Y = 0 To ALC
    '        For x = 0 To 2
    '            If AList(x, Y) <> AList2(x, Y) Then
    '                x = x
    '            End If
    '            If AList2(1, Y) > PermNextno Then
    '                x = x
    '            End If
    '
    '        Next x
    '
    '        Next Y
            If ALC > -1 Then
            
                If RestartPos(0) = -1 Then
                    PropP = 1
                Else
                    PropP = PermNextno - RestartPos(0) - 1
                End If
                
                If PropP > 1 Or PropP = 0 Then PropP = 1
                Call MakeScanCompressArrays(NextNo, SeqNum())
                UseCompress = 1
                'ReDim Preserve AList(2, ALC)
                
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                If DoScans(0, 0) = 1 Then
                    ReDim RedoL3(ALC)
                    
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@
                        NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        'If NumRedos > 0 Then
                            
                        For x = Y To EPX
        '                    If x = 475 Then
        '                        x = x
        '                    End If
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                
                                ' Print #1, Str(Seq1) + "," + Str(Seq2) + "," + Str(Seq3)
                                ''22,245,285
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                            Else
                                x = x
                            End If
                            
                            
                        Next x
                        'End If
                        
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            GlobalTimer = ET
                            LT = ET
                            'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                            Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                            Form1.SSPanel1.Refresh
                            Form1.Refresh
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            If Abs(ET - ELT) > 2000 Then
                                ELT = ET
                                If oTotRecs > 0 Then
                                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                    If PBV > Form1.ProgressBar1 Then
                                        Form1.ProgressBar1 = PBV
                                        Call UpdateF2Prog
                                    End If
                                End If
                                        
                            End If
                            xNextno = NextNo
                            
                            DoEvents 'covered by currentlyrunningflag
                            NextNo = xNextno
                            If AbortFlag = 1 Then
                                WinPPY = NextNo
                                g = NextNo
                                H = NextNo
                            End If
                            UpdateRecNums (SEventNumber)
                            
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                            Call UpdateTimeCaps(ET, SAll)
                            
                            
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            If AbortFlag = 1 Then
                                Exit For
                            End If
        
                        End If
                    Next Y
                End If
                If DoScans(0, 1) = 1 Then
                    ReDim RedoL3(ALC)
                    
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@
                        NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                        'If NumRedos > 0 Then
                        '@'@
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                'ZZZ = ZZZ + 1
                               ' CurrentTripListNum = x
                                ''22,245,285
                                 NewOneFound = 0
                                Call GCXoverD(0)
                                If NewOneFound = 0 Then
                                    x = x
                                End If
                            End If
                        Next x
                        'End If
                        
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            GlobalTimer = ET
                            LT = ET
                            'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                            Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                            Form1.SSPanel1.Refresh
                            Form1.Refresh
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            If Abs(ET - ELT) > 2000 Then
                                ELT = ET
                                If oTotRecs > 0 Then
                                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                    If PBV > Form1.ProgressBar1 Then
                                        Form1.ProgressBar1 = PBV
                                        Call UpdateF2Prog
                                    End If
                                End If
                                        
                            End If
                            xNextno = NextNo
                            
                            DoEvents 'covered by currentlyrunningflag
                            NextNo = xNextno
                            If AbortFlag = 1 Then
                                WinPPY = NextNo
                                g = NextNo
                                H = NextNo
                            End If
                            UpdateRecNums (SEventNumber)
                            
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                            Call UpdateTimeCaps(ET, SAll)
                            
                            
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            If AbortFlag = 1 Then
                                Exit For
                            End If
        
                        End If
                    Next Y
                End If
                
                
                If DoScans(0, 3) = 1 Then
                    ReDim RedoL3(ALC)
                    
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@
                        'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                        'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, CDbl(LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                        HWindowWidth = CLng(MCWinSize / 2)
                        lHWindowWidth = HWindowWidth
                        NumRedos = AlistMC3(SEventNumber, Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindallFlag, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, CDbl(LowestProb / MCCorrection), LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                    
                        'If NumRedos > 0 Then
                        '@'@
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                'ZZZ = ZZZ + 1
                               ' CurrentTripListNum = x
                                ''22,245,285
                                 NewOneFound = 0
                                Call MCXoverF(0, 0, 0)
                                
                            End If
                        Next x
                        'End If
                        
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            GlobalTimer = ET
                            LT = ET
                            'Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                            Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                            Form1.SSPanel1.Refresh
                            Form1.Refresh
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            If Abs(ET - ELT) > 2000 Then
                                ELT = ET
                                If oTotRecs > 0 Then
                                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                    If PBV > Form1.ProgressBar1 Then
                                        Form1.ProgressBar1 = PBV
                                        Call UpdateF2Prog
                                    End If
                                End If
                                        
                            End If
                            xNextno = NextNo
                            
                            DoEvents 'covered by currentlyrunningflag
                            NextNo = xNextno
                            If AbortFlag = 1 Then
                                WinPPY = NextNo
                                g = NextNo
                                H = NextNo
                            End If
                            UpdateRecNums (SEventNumber)
                            
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                            Call UpdateTimeCaps(ET, SAll)
                            
                            
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            If AbortFlag = 1 Then
                                Exit For
                            End If
        
                        End If
                    Next Y
                End If
                
                Form1.SSPanel1.Caption = Trim(Str(EPX)) & " of " & Trim(Str(ALC)) & " triplets reexamined"
                DoEvents
                UseCompress = 0
    '            XXX = 0
    '                       For x = 0 To NextNo
    '                XXX = XXX + CurrentXOver(x) '586,225,9411,1210,365
    '                '585,350,363,5552
    '            Next x
    '            x = x
    '        x = x
    '        Open "RecombsNew.csv" For Output As #1
    '            For x = 0 To NextNo
    '                For Y = 1 To CurrentXOver(x)
    '                    Print #1, Str(x) + "," + Str(Y) + "," + Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).MajorP) + ","
    '                Next Y
    '            Next x
    '        Close #1
            End If
        Loop
    End If
    If DoScans(0, 3) = 1 Or DoScans(0, 2) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then
        
        UseCompress = 1
        Call MakeScanCompressArrays(NextNo, SeqNum())
        
        For Seq1 = 0 To PermNextno
            For Seq2 = Seq1 + 1 To NextNo
                If DoPairs(Seq1, Seq2) = 1 Then
                If Seq1 <> Seq2 Then
                    If Seq2 > PermNextno Then
                        Spos = Seq2 + 1
                    Else
                        Spos = PermNextno + 1
                    End If
                    For Seq3 = Spos To NextNo
                    If DoPairs(Seq1, Seq3) = 1 And DoPairs(Seq2, Seq3) = 1 Then
                        
                        If Seq1 <= UBound(PermValid, 2) And Seq2 <= UBound(PermValid, 2) And Seq3 <= UBound(PermValid, 2) Then
                            If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                    If Seq1 <= NextNo And Seq2 <= NextNo And Seq3 <= NextNo Then
                                        b = b + 1
                                        '@'@
'                                        If DoScans(0, 0) = 1 Then
'
'                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                        End If
'                                        If DoScans(0, 1) = 1 Then
'                                            Call GCXoverD(0)
'                                        End If
                                        If DoScans(0, 2) = 1 Then
                                            Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                        End If
                                        If DoScans(0, 3) = 1 Then
                                            Call MCXoverF(0, 0, 0)
                                        End If
                                        '@
                                        If DoScans(0, 4) = 1 Then
                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                        
                                            Call CXoverA(0, 0, 0)
                                                                        
                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                        
                                            Call CXoverA(0, 0, 0)
                                                                        
                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                        
                                            Call CXoverA(0, 0, 0)
                                                                        
                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                        End If
                                        
                                        If DoScans(0, 5) = 1 Then
                                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                            Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                        End If
                                        
                                        
                                        If DoScans(0, 8) = 1 Then
                                                                             
                                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                
                                            Call TSXOver(0)
                                                    
                                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                    
                                            Call TSXOver(0)
                                                    
                                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                    
                                            Call TSXOver(0)
                                                    
                                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                        End If
                                       
                                        
                                    End If
                                'End If
                            End If
                        End If
                        ET = Abs(GetTickCount)
                        '@'@
                        If Abs(ET - GlobalTimer) > 500 Then
                            DoEvents
                            If AbortFlag = 1 Then Exit For
                            GlobalTimer = ET
                            Form1.SSPanel1.Caption = Trim(Str(b)) & " of " & Trim(Str(MCCorrectX)) & " triplets reexamined"
                            If Abs(ET - ELT) > 2000 Then
                                ELT = ET
                                If oTotRecs > 0 Then
                                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                                    If PBV > Form1.ProgressBar1 Then
                                        Form1.ProgressBar1 = PBV
                                        Call UpdateF2Prog
                                    End If
                                End If
                                        
                            End If
                            
                            
                            
                            
                            If AbortFlag = 1 Then
                                WinPPY = NextNo
                                g = NextNo
                                H = NextNo
                            End If
                            UpdateRecNums (SEventNumber)
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                            Call UpdateTimeCaps(ET, SAll)
                            Form1.Refresh
                            xNextno = NextNo
                            DoEvents 'covered by currentlyrunning flag
                            NextNo = xNextno
                        End If
                    End If
                    Next Seq3
                End If
                End If
            Next Seq2
        Next Seq1
'        XXX = 0
'                       For x = 0 To NextNo
'                XXX = XXX + CurrentXOver(x) '586,225,9411,1210,365
'                '585,350,363,5552
'            Next x
            x = x
    End If
    UseCompress = 0
    DontWorryAboutSplitsFlag = oDWS
    Dim NumNew
    NumNew = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            NumNew = NumNew + 1
            
            If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
                XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
            ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
                XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
                XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
            ElseIf XoverList(x, Y).MajorP > PermNextno Then
                XoverList(x, Y).EndP = 0
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
            ElseIf XoverList(x, Y).MinorP > PermNextno Then
                XoverList(x, Y).EndP = 0
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            ElseIf XoverList(x, Y).Daughter > PermNextno Then
                XoverList(x, Y).EndP = 0
                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            'XX = XoverList(x, Y).EndP '0
            End If
'            If XoverList(x, Y).MajorP > PermNextno Then
'                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (x + 1))
'                'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).MajorP)
'            ElseIf XoverList(x, Y).MinorP > PermNextno Then
'                'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).MinorP)
'                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (x + 1))
'            ElseIf XoverList(x, Y).Daughter > PermNextno Then
'                'XoverList(x, Y).EndP = OSNPos(XoverList(x, Y).Daughter)
'                XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (x + 1))
'            End If
            'XX = XoverList(x, Y).EndP '0
        Next Y
    Next x
    x = x



End If
If PermNextno > MemPoc Then
    ReDim PermDIffs(0, 0)
    ReDim PermValid(0, 0)
End If


End Sub
Public Sub RecodeSeqs(NextNo As Long, SeqNum() As Integer, Recoded() As Byte)
'Replaces 46,66,68, 72 and 85 in original alinment with other numbers
'in each column the most common nt will be 0 and gaps will be 4
Dim UBSN1 As Long, UBSN2 As Long, SeqNumDropped As Byte, Compression As Long, NucMat(255) As Byte, NucCount() As Long, NN As Byte, x As Long, Y As Long, H As Long, W As Long, Replace() As Byte, RNM(4) As Byte
Dim CycleX As Long

ReDim Recoded(0, 0)

SeqNumDropped = 0

ReDim NucCount(Len(StrainSeq(0)), 4)


Compression = 4

NucMat(66) = 1: RNM(1) = 66
NucMat(68) = 2: RNM(2) = 68
NucMat(72) = 3: RNM(3) = 72
NucMat(85) = 4: RNM(4) = 85
NucMat(46) = 0: RNM(0) = 46

Dim oDirX As String
'@'$'$
If x = x Then
    Dummy = CountNucs(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), SeqNum(0, 0), NucMat(0), UBound(NucCount, 1), NucCount(0, 0))
Else
    For Y = 0 To NextNo
        For x = 1 To Len(StrainSeq(0))
        'count the number of each nucleotide in each column
            NN = SeqNum(x, Y)
            NN = NucMat(NN)
            NucCount(x, NN) = NucCount(x, NN) + 1
        Next x
    Next Y
End If
'if sequences are very long this can get very expensive so need to drop stuff to disk
If (Len(StrainSeq(0)) * NextNo) > 30000000 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    SeqNumDropped = 1
    'drop seqnum onto the disk and just work with one sequence at a time
    FF = FreeFile
    Open "tseqnum" + UFTag For Binary As #FF
    Put #FF, , SeqNum()
    Close #FF
    UBSN1 = UBound(SeqNum, 1)
    UBSN2 = UBound(SeqNum, 2)
    ReDim SeqNum(0, 0)
    
    ChDrive oDirX
    ChDir oDirX
End If
ReDim Replace(Len(StrainSeq(0)), 4)
'work out which nts should be replaced with what number in each column
Dim tSeqnum() As Integer
'$'@'@'@

If x = x Then 'this c++ routine doesnt seem to be much faster than the vb one
    Dummy = RecodeNucs(NextNo, Len(StrainSeq(0)), UBound(NucCount, 1), NucCount(0, 0), UBound(Replace, 1), Replace(0, 0))
Else
    
    For x = 1 To Len(StrainSeq(0))
        CycleX = 1
        Do
            H = 0
            For Y = 1 To 4
                If H < NucCount(x, Y) Then
                    H = NucCount(x, Y)
                    W = Y
                End If
                
            Next Y
            If H = 0 Then Exit Do
            NucCount(x, W) = -1
            
            Replace(x, W) = CycleX
            If H = NextNo + 1 Then Exit Do
            CycleX = CycleX + 1
            
        Loop
    Next x
End If
ReDim NucCount(0, 0)
'Make the recoded alignment
'@'@'$'$


ReDim Recoded(Len(StrainSeq(0)) + 3, NextNo)
If SeqNumDropped = 1 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "tseqnum" + UFTag For Binary As #FF
    
    Dim LSeq As Long
    LSeq = Len(StrainSeq(0))
    
    For Y = 0 To NextNo
    
        ReDim tSeqnum(UBSN1)
        Get #FF, , tSeqnum()
        
        If x = x Then
            Dummy = RecodeNucsLong(Y, LSeq, UBound(Recoded, 1), UBound(Replace, 1), tSeqnum(0), NucMat(0), Replace(0, 0), Recoded(0, 0))
        Else
            For x = 1 To LSeq
    '            If tSeqnum(x) <> SeqNum(x, Y) Then
    '                x = x
    '            End If
                    
                NN = tSeqnum(x)
                NN = NucMat(NN)
                Recoded(x, Y) = Replace(x, NN)
                'X = X
            Next x
        End If
    Next Y
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
Else
    '@'$'$'$
    If x = x Then
'        SS = GetTickCount
'        For x = 1 To 100
        Dummy = DoRecodeP(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), SeqNum(0, 0), UBound(Recoded, 1), Recoded(0, 0), NucMat(0), UBound(Replace, 1), Replace(0, 0))
'        Next x
'        EE = GetTickCount
'        TT = EE - SS
    x = x
    Else
        For Y = 0 To NextNo
            For x = 1 To Len(StrainSeq(0))
                NN = SeqNum(x, Y)
                NN = NucMat(NN)
                Recoded(x, Y) = Replace(x, NN)
                'X = X
            Next x
        Next Y
    End If
End If
ReDim Replace(0, 0)

If SeqNumDropped = 1 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    ReDim SeqNum(UBSN1, UBSN2)
    Open "tseqnum" + UFTag For Binary As #FF
    Get #FF, , SeqNum()
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End If


'For X = 0 To NextNo
'    For Y = 1 To Len(StrainSeq(0))
'        Mid(StrainSeq(X), Y, 1) = Chr(RNM(Recoded(Y, X)) - 1)
'    Next Y
'Next X

End Sub

Public Sub MakeCompressSeq(NextNo As Long, Recoded() As Byte, CompressSeq() As Byte)
Dim Compression As Long, Y As Long, x As Long, Z As Long
Compression = 3

ReDim CompressSeq((UBound(Recoded, 1) / Compression) + 1, NextNo)


If x = x Then
    Dummy = MakeCompressSeqP(NextNo, UBound(Recoded), Recoded(0, 0), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(CompressorRDP, 1), UBound(CompressorRDP, 1), CompressorRDP(0, 0, 0))
Else


    For Y = 0 To NextNo
        Z = 0
        For x = 1 To UBound(Recoded, 1) - 3 Step 3
            Z = Z + 1
            CompressSeq(Z, Y) = CompressorRDP(Recoded(x, Y), Recoded(x + 1, Y), Recoded(x + 2, Y))
        Next x
    Next Y
End If
'ReDim CC(125, 125)
'For x = 0 To UBound(CompressSeq, 1)
'    For Y = 0 To Nextno
'        For Z = Y + 1 To Nextno
'            CC(CompressSeq(x, Y), CompressSeq(x, Z)) = CC(CompressSeq(x, Y), CompressSeq(x, Z)) + 1
'            CC(CompressSeq(x, Z), CompressSeq(x, Y)) = CC(CompressSeq(x, Y), CompressSeq(x, Z))
'        Next Z
'    Next Y
'Next x
'Dim C As Long
'C = 0
'For x = 0 To 125
'    For Y = 0 To 125
'        If CC(x, Y) = 0 Then
'            C = C + 1
'        End If
'    Next Y
'Next x

'ReDim CC(125)
'For x = 0 To UBound(CompressSeq, 1)
'    For Y = 0 To Nextno
'        CC(CompressSeq(x, Y)) = CC(CompressSeq(x, Y)) + 1
'    Next Y
'Next x
'Dim C As Long
'C = 0
'For x = 0 To 125
'    If CC(x) = 0 Then
'        C = C + 1
'    End If
'Next x


End Sub
Public Sub FindSubSeqRDPFast(CS() As Byte, Seq1 As Long, Seq2 As Long, Seq3 As Long, XoverSeqNumW() As Byte)

Dim AH(2) As Long, x As Long, Y As Long, Holder As Byte, H As Byte, Z As Byte, XoverWindow As Integer
Dim XOverSeqNumW2() As Byte, XDiffPos2() As Long, XPosDiff2() As Long
ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
ReDim XOverSeqNumW2(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
ReDim ValidSpacer(0)
ReDim SpacerSeqs(0)
ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XDiffPos2(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
ReDim XPosDiff2(Len(StrainSeq(0)) + 200)
Dim AHX(2) As Long, S1 As Long, s2 As Long, S3 As Long
XoverWindow = Int(XOverWindowX / 2)
SS = Abs(GetTickCount)
''For ZZ = 1 To 2000
''Y = 0
''For x = 1 To UBound(CS, 1)
''    s1 = CS(x, Seq1)
''    s2 = CS(x, Seq2)
''    S3 = CS(x, Seq3)
''    For Z = 0 To 2
''
''        Holder = FSSRDP(Z, s1, s2, S3)
''        If Holder > 0 Then
''            Y = Y + 1
''            XDiffPos2(Y) = (x - 1) * 3 + Z + 1
''            H = Holder - 1
''            AH(H) = AH(H) + 1
''            XoverSeqNumW(Y + XOverWindow, H) = 1
''        End If
''    Next Z
''Next x
''
''
''Dim WMX As Integer, WPX As Integer
''
''WMX = Y - XOverWindow
''WPX = Y + XOverWindow
''For b = 1 To XOverWindow
''    WMX = WMX + 1
''    WPX = WPX + 1
''    XoverSeqNumW(b, 0) = XoverSeqNumW(WMX + XOverWindow, 0)
''    XoverSeqNumW(b, 1) = XoverSeqNumW(WMX + XOverWindow, 1)
''    XoverSeqNumW(b, 2) = XoverSeqNumW(WMX + XOverWindow, 2)
''
''    XoverSeqNumW(WPX, 0) = XoverSeqNumW(b + XOverWindow, 0)
''    XoverSeqNumW(WPX, 1) = XoverSeqNumW(b + XOverWindow, 1)
''    XoverSeqNumW(WPX, 2) = XoverSeqNumW(b + XOverWindow, 2)
''Next b
''
''Next ZZ

EE = Abs(GetTickCount)
TT = EE - SS

LenXoverSeq1 = Y '1000
XX = AH(0)
XX = AH(1)
AA = AH(2)
'XX = CS(1, 2)
SS = Abs(GetTickCount)
For ZZ = 1 To 2000
LenXoverSeq1 = FindSubSeqPB(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CS, 1), Len(StrainSeq(0)), NextNo, Seq1, Seq2, Seq3, CS(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), XDiffPos(0), XPosDiff(0), FSSRDP(0, 0, 0, 0))
Next ZZ
EE = Abs(GetTickCount)
TT = EE - SS '47
SS = Abs(GetTickCount)
'TT = EE - SS
For ZZ = 1 To 2000
LenXoverSeq = FindSubSeq(AHX(0), 0, 0, XoverWindow, Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XOverSeqNumW2(0, 0), SpacerSeqs(0), XDiffPos2(0), XPosDiff2(0), ValidSpacer(0))
Next ZZ
EE = Abs(GetTickCount)
TT = EE - SS '172
For x = 0 To UBound(XDiffPos, 1)
    If XDiffPos(x) <> XDiffPos2(x) Then
        x = x
    End If
Next x
XX = Len(StrainSeq(0))
For x = 0 To UBound(XPosDiff, 1)
    If XPosDiff(x) <> XPosDiff2(x) Then
        x = x
    End If
Next x

x = x
XX = AHX(0)
XX = AHX(1)
AA = AHX(2)
XX = XoverWindow
For x = 0 To Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2
    
    For Y = 0 To 2
    
    If XoverSeqNumW(x, Y) <> XOverSeqNumW2(x, Y) Then
        x = x
    End If
    Next Y
Next x

End Sub
Public Sub FillFSSRDP()
Dim FF As Long
oDirX = CurDir
ChDrive App.Path
ChDir App.Path
FF = FreeFile
GoOn = 0
Open "RDP5FSSRDP" For Binary As #FF
If LOF(FF) > 100 Then
    ReDim FSSRDP(3, 125, 125, 125)
    
    Get #FF, , FSSRDP()
    ReDim FSSMC(2, 125, 125, 125)
    Get #FF, , FSSMC()
    
    ReDim FSSGC(3, 125, 125, 125)
    Get #FF, , FSSGC()
    
    ReDim CompressorRDP(125, 125, 125)
    Get #FF, , CompressorRDP()
Else
    GoOn = 1
End If
Close #FF

ChDrive oDirX
ChDir oDirX
If GoOn = 1 Then
    Dim A As Byte, b As Byte, C As Byte, L As Byte, M As Byte, n As Byte, W As Byte, x As Byte, Y As Byte
    Dim PositionA As Long, PositionB As Long, PositionC As Long, ActionCase(3) As Integer
    'it is possible to make this better by only encoding the combinations that actually exist in a given column
    'this encoding is generic and should work for every alignment.
    'for triplet scans there is only enough memeory to encode 125 possibilities
    ReDim FSSRDP(3, 125, 125, 125)
    ReDim FSSMC(2, 125, 125, 125)
    ReDim FSSGC(3, 125, 125, 125)
    PositionA = -1
    ReDim CompressorRDP(125, 125, 125)
    Dim PT As Long
    For A = 0 To 4
        For b = 0 To 4
            For C = 0 To 4
                PositionA = PositionA + 1
                CompressorRDP(A, b, C) = PositionA
                PositionB = -1
                For L = 0 To 4
                    For M = 0 To 4
                        For n = 0 To 4
                            PositionB = PositionB + 1
                            PositionC = -1
                            For W = 0 To 4
                                For x = 0 To 4
                                    For Y = 0 To 4
                                        PositionC = PositionC + 1
                                        'site 1
                                        
                                        PT = 0
                                        If A <> 0 Then
                                            If L <> 0 Then
                                                If W <> 0 Then
                                                    If A <> W Or A <> L Then
                                                        If A = L Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 1
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 1
                                                        ElseIf A = W Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 2
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 2
                                                        ElseIf W = L Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 3
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 3
                                                        Else
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 7
                                                        End If
                                                        FSSMC(0, PositionA, PositionB, PositionC) = 1
                                                    End If
                                                End If
                                            End If
                                        End If
                                        'site2
                                        PT = 1
                                        If b <> 0 Then
                                            If M <> 0 Then
                                                If x <> 0 Then
                                                    If b <> x Or b <> M Then
                                                        If b = M Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 1
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 1
                                                        ElseIf b = x Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 2
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 2
                                                        ElseIf M = x Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 3
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 3
                                                        Else
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 7
                                                        End If
                                                        FSSMC(1, PositionA, PositionB, PositionC) = 1
                                                    End If
                                                End If
                                            End If
                                        End If
                                        'site 3
                                        PT = 2
                                        If C <> 0 Then
                                            If n <> 0 Then
                                                If Y <> 0 Then
                                                    If C <> Y Or C <> n Then
                                                        If C = n Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 1
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 1
                                                        ElseIf C = Y Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 2
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 2
                                                        ElseIf n = Y Then
                                                            
                                                            FSSRDP(PT, PositionA, PositionB, PositionC) = 3
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 3
                                                        Else
                                                            FSSGC(PT, PositionA, PositionB, PositionC) = 7
                                                        End If
                                                        FSSMC(2, PositionA, PositionB, PositionC) = 1
                                                    End If
                                                End If
                                                
                                            End If
                                        End If
                                        FSSRDP(3, PositionA, PositionB, PositionC) = FSSRDP(0, PositionA, PositionB, PositionC) + FSSRDP(1, PositionA, PositionB, PositionC) + FSSRDP(2, PositionA, PositionB, PositionC)
                                        FSSGC(3, PositionA, PositionB, PositionC) = FSSGC(0, PositionA, PositionB, PositionC) + FSSGC(1, PositionA, PositionB, PositionC) + FSSGC(2, PositionA, PositionB, PositionC)
'                                        If ActionCase(1) = 1 Then
'                                            If ActionCase(2) = 1 Then
'                                                If ActionCase(3) = 1 Then '111
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 1
'                                                ElseIf ActionCase(3) = 2 Then '112
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 2
'                                                ElseIf ActionCase(3) = 3 Then '113
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 3
'                                                Else '11
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 4
'                                                End If
'                                            ElseIf ActionCase(2) = 2 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 5
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 6
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 7
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 8
'                                                End If
'                                            ElseIf ActionCase(2) = 3 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 9
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 10
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 11
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 12
'                                                End If
'                                            Else
'                                                If ActionCase(3) = 1 Then '11
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 13
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 14
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 15
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 16
'                                                End If
'                                            End If
'
'                                        ElseIf ActionCase(1) = 2 Then
'                                            If ActionCase(2) = 1 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 17
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 18
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 19
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 20
'                                                End If
'                                            ElseIf ActionCase(2) = 2 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 21
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 22
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 23
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 24
'                                                End If
'                                            ElseIf ActionCase(2) = 3 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 25
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 26
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 27
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 28
'                                                End If
'                                            Else
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 29
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 30
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 31
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 32
'                                                End If
'                                            End If
'                                        ElseIf ActionCase(1) = 3 Then
'                                            If ActionCase(2) = 1 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 33
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 34
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 35
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 36
'                                                End If
'                                            ElseIf ActionCase(2) = 2 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 37
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 38
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 39
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 40
'                                                End If
'                                            ElseIf ActionCase(2) = 3 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 41
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 42
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 43
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 44
'                                                End If
'                                            Else
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 45
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 46
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 47
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 48
'                                                End If
'                                            End If
'                                        Else
'                                            If ActionCase(2) = 1 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 49
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 50
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 51
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 52
'                                                End If
'                                            ElseIf ActionCase(2) = 2 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 53
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 54
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 55
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 56
'                                                End If
'                                            ElseIf ActionCase(2) = 3 Then
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 57
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 58
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 59
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 60
'                                                End If
'                                            Else
'                                                If ActionCase(3) = 1 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 61
'                                                ElseIf ActionCase(3) = 2 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 62
'                                                ElseIf ActionCase(3) = 3 Then
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 63
'                                                Else
'                                                    FSSRDP(PositionA, PositionB, PositionC) = 64
'                                                End If
'                                            End If
'                                        End If
                                    Next Y
                                Next x
                            Next W
                        Next n
                    Next M
                Next L
            Next C
        Next b
    Next A
    'XX = FSSRDP(2, 1, 1, 2)
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "RDP5FSSRDP" For Binary As #FF
    'ReDim FSSRDP(125, 125, 125, 2)
    Put #FF, , FSSRDP()
    Put #FF, , FSSMC()
    Put #FF, , FSSGC()
    Put #FF, , CompressorRDP()
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    
    
End If




'SeqCompressor14
End Sub
Public Sub CompressString(TString As String, Compressed() As Integer, Element As Long)

Dim x As Long, Y As Long, TS2 As String
If CompressValid11(876, 950) = 0 Then
    Call MakeSeqCompressors 'this code should only ever be executed once per install
End If

'I'll use SeqCompressor14(A, b, C, D)
'In SeqCompressor14:
'0= a gap
'1=A
'2=C
'3=G
'4=T

Dim Charconvert(255) As Byte
Charconvert(Asc("-")) = 0
Charconvert(Asc("A")) = 1
Charconvert(Asc("C")) = 2
Charconvert(Asc("G")) = 3
Charconvert(Asc("T")) = 4
Dim CurChar(3) As Byte
'XX = Charconvert(65)
On Error Resume Next
UB = -1
UB = UBound(Compressed, 1)
If UBound(Compressed, 1) < CLng((Len(TString)) / 4) + 2 Then
    ReDim Compressed(Len(TString) + 2, 0)
End If
Y = -1

TS2 = TString + "-----"
For x = 1 To Len(TString) + 1 Step 4
   Y = Y + 1
   'XX = Asc(Mid$(TS2, X, 1))
   CurChar(0) = Charconvert(Asc(Mid$(TS2, x, 1)))
   CurChar(1) = Charconvert(Asc(Mid$(TS2, x + 1, 1)))
   CurChar(2) = Charconvert(Asc(Mid$(TS2, x + 2, 1)))
   CurChar(3) = Charconvert(Asc(Mid$(TS2, x + 3, 1)))
   Compressed(Y, Element) = SeqCompressor14(CurChar(0), CurChar(1), CurChar(2), CurChar(3))
   x = x
Next x

End Sub
Public Sub FastBootDistanceCalcZ(ShowProg, StoreFlag, StartPosInAlign, EndPosInAlign, NextNo As Long, PermDIffs() As Single, PermValid() As Single, SeqNum() As Integer, Distance() As Single, AvDst As Double, Udst As Double, tRedoDist() As Integer)


'SS = Abs(GetTickCount)

Dim TT As Long, SSSS As Long, LLLL As Long, Dummy As Long, AA() As Long, SeqSpace() As Byte, ANum, SeqCatCount() As Long, NucMat() As Byte, NumNucs As Byte, NucMat2() As Byte
ReDim SeqSpace(Len(StrainSeq(0)))
Dim Nuc11() As Byte, Nuc02() As Byte, Nuc12() As Byte
Dim Nuc03() As Byte, Nuc13() As Byte, Nuc04() As Byte, Nuc14() As Byte
'Dim MissChar() As Byte
'Dim NucChar() As Byte
Dim ISeq11() As Integer, ISeq02() As Integer, ISeq12() As Integer
Dim ISeq03() As Integer, ISeq13() As Integer, ISeq04() As Integer, ISeq14() As Integer

'ReDim Nuc10(1, CLng(Len(StrainSeq(0) / 10)) + 1)
'ReDim Nuc01(1, CLng(Len(StrainSeq(0) / 10)) + 1)
Dim A As Long, b As Long, C As Long, D As Long, e As Long, F As Long, g As Long, H As Long, i As Long, j As Long
Dim Q As Long, r As Long, S As Long, T As Long, U As Long, V As Long, W As Long, x As Long, Y As Long, Z As Long
Dim FLP() As Byte, ML() As Byte, NL() As Byte

Dim NucMatB() As Byte
ReDim NucMatB(4)
ReDim NucMat2(100)
ReDim NucMat(100)

NucMat(66) = 1
NucMat(68) = 2
NucMat(72) = 3
NucMat(85) = 4
'@
ReDim FLP(NextNo, Len(StrainSeq(0)))
ReDim ML(Len(StrainSeq(0))), NL(Len(StrainSeq(0)))
'ReDim MissChar(Len(StrainSeq(0)))
'ReDim NucChar(Len(StrainSeq(0)))


If CompressValid11(876, 950) = 0 Then
    Call MakeSeqCompressors 'this code should only ever be executed once per install
End If

NucMatB(1) = 66
NucMatB(2) = 68
NucMatB(3) = 72
NucMatB(4) = 85
ReDim SeqCatCount(1, 4)

ReDim AA(4)

'SS = Abs(GetTickCount)
'SS = Abs(GetTickCount)
'this categorizes sites based on numbers of nucleotide polymorphisms and the presence/absence of gaps
'If X = X Then
    ''''''
    'Dummy = MakeSeqCatCount(Nextno, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0))
    '@'@'@'@
    If NextNo < 500 Or x = x Then
        Dummy = MakeSeqCatCount2(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0), SeqSpace(0), NucMatB(0), NucMat2(0), FLP(0, 0), ML(0), NL(0))
    Else
        Dummy = MakeSeqCatCount2P(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0), SeqSpace(0), NucMatB(0), NucMat2(0), FLP(0, 0), ML(0), NL(0))
   End If
   'EE = abs(gettickcount)
   'TT = EE - SS
   'for freds start at event 2 - 250/1579
   'p version 234/1641
   'with parallelization 2nd loop 172/1175
   'rearrangement first loop 78/563
   'paralleization 1st loop 16/94
   x = x
'Else
'
'    ANum = 0
'    SeqCatCount(1, 1) = 0
'    SeqCatCount(1, 2) = 0
'    SeqCatCount(0, 3) = 0
'    SeqCatCount(1, 3) = 0
'    SeqCatCount(0, 4) = 0
'    SeqCatCount(1, 4) = 0
'    SeqCatCount(0, 2) = 0
'    SeqCatCount(0, 0) = 0
'    SeqCatCount(0, 1) = 0
'    SeqCatCount(1, 0) = 0
'    If StartPosInAlign <= EndPosInAlign Then
'
'
'        For X = StartPosInAlign To EndPosInAlign
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'        Next X
'
'    ElseIf StartPosInAlign > EndPosInAlign Then
'        For X = StartPosInAlign To LSeq
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'
'        Next X
'        For X = 1 To EndPosInAlign
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'
'        Next X
'
'    End If
'
'
'End If
'EE = Abs(GetTickCount)
'    TT = EE - SS '0.640,3.042'0.452,0.2215
'1.950 for 3200 sequences'1.514 for 3200'1.342 - not calc seqspaces etc
'0.983 in VB 0.749 in C for 1700 sequences 0.592 with bytes instead of longs
ReDim Nuc11(SeqCatCount(1, 1), NextNo + 1)
ReDim Nuc02(SeqCatCount(0, 2), NextNo + 1)
ReDim Nuc12(SeqCatCount(1, 2), NextNo + 1)
ReDim Nuc03(SeqCatCount(0, 3), NextNo + 1)
ReDim Nuc13(SeqCatCount(1, 3), NextNo + 1)
ReDim Nuc04(SeqCatCount(0, 4), NextNo + 1)
ReDim Nuc14(SeqCatCount(1, 4), NextNo + 1)

'If X = 1234567 Then
'    A = StartPosInAlign
'    B = EndPosInAlign
'    Dummy = MakeNucSets3(UBound(FLP, 1), Nextno, A, B, UBound(Nuc11, 1), UBound(Nuc12, 1), UBound(Nuc13, 1), UBound(Nuc14, 1), UBound(Nuc02, 1), UBound(Nuc03, 1), UBound(Nuc04, 1), NL(0), ML(0), FLP(0, 0), Nuc11(0, 0), Nuc02(0, 0), Nuc12(0, 0), Nuc03(0, 0), Nuc13(0, 0), Nuc04(0, 0), Nuc14(0, 0))
'    'XX = SeqCatCount(1, 0)
'
'    X = X
'Else
    
    
    
    
    Dim N02 As Long, N03 As Long, N04 As Long, N11 As Long, N12 As Long, N13 As Long, N14 As Long
    N02 = 0: N03 = 0: N04 = 0
    N11 = 0: N12 = 0: N13 = 0: N14 = 0
'    SS = Abs(GetTickCount)
    x = StartPosInAlign
    
    
    'This makes a separate nucxx for all the different site categories
     '
    Do
        
        If ML(x) = 0 Then 'there are no gaps at this site
            If NL(x) = 2 Then ' there are two variants at this site
                N02 = N02 + 1
                Dummy = FillNucXX(N02, NextNo, x, UBound(Nuc02, 1), UBound(FLP, 1), Nuc02(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc02(N02, Y) = FLP(X, Y)
'                Next Y
                
                
            ElseIf NL(x) = 3 Then 'there are three variants at this site
                N03 = N03 + 1
                Dummy = FillNucXX(N03, NextNo, x, UBound(Nuc03, 1), UBound(FLP, 1), Nuc03(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc03(N03, Y) = FLP(X, Y)
'                Next Y
                
                
            ElseIf NL(x) = 4 Then 'there are 4 variants at this site
                N04 = N04 + 1
                Dummy = FillNucXX(N04, NextNo, x, UBound(Nuc04, 1), UBound(FLP, 1), Nuc04(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc04(N04, Y) = FLP(X, Y)
'                Next Y
                
            End If
            
        Else 'there are gaps at this site
            If NL(x) = 1 Then 'there is only one type of nucleotide at this site
                N11 = N11 + 1
                '
                Dummy = FillNucXX(N11, NextNo, x, UBound(Nuc11, 1), UBound(FLP, 1), Nuc11(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc11(N11, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 2 Then 'there are two nucleotide variants at this site
                N12 = N12 + 1
                ''
                Dummy = FillNucXX(N12, NextNo, x, UBound(Nuc12, 1), UBound(FLP, 1), Nuc12(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc12(N12, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 3 Then 'there are three nucleotide variants at this site
                N13 = N13 + 1
                 '
                Dummy = FillNucXX(N13, NextNo, x, UBound(Nuc13, 1), UBound(FLP, 1), Nuc13(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc13(N13, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 4 Then 'there are 4 nucleotide variants at this site
                N14 = N14 + 1
                '@
                Dummy = FillNucXX(N14, NextNo, x, UBound(Nuc14, 1), UBound(FLP, 1), Nuc14(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc14(N14, Y) = FLP(X, Y)
'                Next Y
                
            End If
        
        End If
        '@
        If x = EndPosInAlign Then Exit Do
        x = x + 1
        '@
        If x > Len(StrainSeq(0)) Then x = 1
        
    
    Loop
'    If X = 1234567 Then
'    N11 = SeqCatCount(1, 1)
'    N12 = SeqCatCount(1, 2)
'    N13 = SeqCatCount(1, 3)
'    N14 = SeqCatCount(1, 4)
'    N02 = SeqCatCount(0, 2)
'    N03 = SeqCatCount(0, 3)
'    N04 = SeqCatCount(0, 4)
'    End If
'End If


'
'EE = Abs(GetTickCount)
'    TT = EE - SS '0.561,2.855,3.447,3.432, 0.156,1.108'0.630.359
'    X = X '4.446,4.430, 3.338,3.370
    '0.499'2.808 -c++ version
    '0.499,2.730 - vb version
'6.303 for 3200'3.386 for 3200'2.153 for 3200 with bytes
'2.184 for 1700 seqs in VB' 1.293 in C
ReDim ISeq11(CLng(SeqCatCount(1, 1) / 10) + 1, NextNo)
ReDim ISeq02(CLng(SeqCatCount(0, 2) / 10) + 1, NextNo)
ReDim ISeq12(CLng(SeqCatCount(1, 2) / 6) + 1, NextNo)
ReDim ISeq03(CLng(SeqCatCount(0, 3) / 6) + 1, NextNo)
ReDim ISeq13(CLng(SeqCatCount(1, 3) / 5) + 1, NextNo)
ReDim ISeq04(CLng(SeqCatCount(0, 4) / 5) + 1, NextNo)
ReDim ISeq14(CLng(SeqCatCount(1, 4) / 4) + 1, NextNo)


'SS = Abs(GetTickCount)
'1178,0,1082,0,491,0,100

Dim StepPos As Long
'14
'For x = 0 To UBound(Nuc14, 1)
'    For Z = 0 To UBound(Nuc14, 2)
'        If Nuc14(x, Z) > 4 Then
'            x = x
'        End If
'    Next Z
'Next x
'For x = 0 To Len(StrainSeq(0))
'
'    If SeqNum(x, 1001) <> 46 And SeqNum(x, 1001) <> 66 And SeqNum(x, 1001) <> 68 And SeqNum(x, 1001) <> 72 And SeqNum(x, 1001) <> 85 Then
'        x = x
'        XX = SeqNum(x, 1)
'    End If
'Next x
'x = x
'this makes compressed sequences (stored in iseqxx) comprising only sites in a a single site actegory (catorgory 02, for example, are sites with no gaps and 2 nucleotide variants whereas sites in category 14 have one or more gaps and 4 different nucleotides present)
For x = 0 To NextNo
   ' If tRedoDist(X) = 1 Then
        'If UBound(Nuc14, 2) > 10 Then
            StepPos = MakeSC14(x, Y, UBound(Nuc14), UBound(ISeq14), ISeq14(0, 0), SeqCompressor14(0, 0, 0, 0), Nuc14(0, 0))
'        Else
'
'
'            StepPos = 0
'            For Y = 1 To UBound(Nuc14, 1) - 4 Step 4
'                StepPos = StepPos + 1
'                A = Nuc14(Y, x) '4,4,4
'                b = Nuc14(Y + 1, x) '1,1,4
'                c = Nuc14(Y + 2, x) '0,4,4
'                D = Nuc14(Y + 3, x) '0,4,4
'                ISeq14(StepPos, x) = SeqCompressor14(A, b, c, D)
'            Next Y
'        End If
        StepPos = StepPos + 1
        
        A = 0
        b = 0
        C = 0
        D = 0
        If Y <= UBound(Nuc14, 1) Then
            A = Nuc14(Y, x)
            If Y + 1 <= UBound(Nuc14, 1) Then
                b = Nuc14(Y + 1, x)
                If Y + 2 <= UBound(Nuc14, 1) Then
                    C = Nuc14(Y + 2, x)
                    If Y + 3 <= UBound(Nuc14, 1) Then
                        D = Nuc14(Y + 3, x)
                    End If
                End If
            End If
        End If
        ISeq14(StepPos, x) = SeqCompressor14(A, b, C, D)
  '  End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.047 '0.374 for 3800
'X = X
''13
'XX = SeqNum(100, 6)
'SS = Abs(GetTickCount)
'@
For x = 0 To NextNo
   ' If tRedoDist(X) = 1 Or X = X Then
        '
       ' XX = UBound(Nuc13, 2)
        StepPos = MakeSC13(x, Y, UBound(Nuc13), UBound(ISeq13), ISeq13(0, 0), SeqCompressor13(0, 0, 0, 0, 0), Nuc13(0, 0))
'        StepPos = 0
'
'        For Y = 1 To UBound(Nuc13, 1) - 5 Step 5
'            StepPos = StepPos + 1
'            A = Nuc13(Y, X)
'            B = Nuc13(Y + 1, X)
'            C = Nuc13(Y + 2, X)
'            D = Nuc13(Y + 3, X)
'            E = Nuc13(Y + 4, X)
'            ISeq13(StepPos, X) = SeqCompressor13(A, B, C, D, E)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        
        If Y <= UBound(Nuc13, 1) Then
            A = Nuc13(Y, x)
            If Y + 1 <= UBound(Nuc13, 1) Then
                b = Nuc13(Y + 1, x)
                If Y + 2 <= UBound(Nuc13, 1) Then
                    C = Nuc13(Y + 2, x)
                    If Y + 3 <= UBound(Nuc13, 1) Then
                        D = Nuc13(Y + 3, x)
                        If Y + 4 <= UBound(Nuc13, 1) Then
                            e = Nuc13(Y + 4, x)
                        End If
                    End If
                End If
            End If
        End If
        
        ISeq13(StepPos, x) = SeqCompressor13(A, b, C, D, e)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.094, 0.265 for 3800
'X = X
''04
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
   ' XX = UBound(Nuc04, 2)
        StepPos = MakeSC04(x, Y, UBound(Nuc04), UBound(ISeq04), ISeq04(0, 0), SeqCompressor04(0, 0, 0, 0, 0), Nuc04(0, 0))
'        StepPos = 0
'        For Y = 1 To UBound(Nuc04, 1) - 5 Step 5
'            StepPos = StepPos + 1
'            A = Nuc04(Y, X)
'            B = Nuc04(Y + 1, X)
'            C = Nuc04(Y + 2, X)
'            D = Nuc04(Y + 3, X)
'            E = Nuc04(Y + 4, X)
'            ISeq04(StepPos, X) = SeqCompressor04(A, B, C, D, E)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        If Y <= UBound(Nuc04, 1) Then
            A = Nuc04(Y, x)
            If Y + 1 <= UBound(Nuc04, 1) Then
                b = Nuc04(Y + 1, x)
                If Y + 2 <= UBound(Nuc04, 1) Then
                    C = Nuc04(Y + 2, x)
                    If Y + 3 <= UBound(Nuc04, 1) Then
                        D = Nuc04(Y + 3, x)
                        If Y + 4 <= UBound(Nuc04, 1) Then
                            e = Nuc04(Y + 4, x)
                        
                        End If
                    
                    End If
                
                End If
           
            End If
            
        
        End If
        ISeq04(StepPos, x) = SeqCompressor04(A, b, C, D, e)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.016, 0 for 3800
'X = X
''12
'
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
        'If X = X Then
            '
            'XX = UBound(Nuc12, 2)
            StepPos = MakeSC12(x, Y, UBound(Nuc12, 1), UBound(ISeq12, 1), ISeq12(0, 0), SeqCompressor12(0, 0, 0, 0, 0, 0), Nuc12(0, 0))
'        Else
'            StepPos = 0
'
'            For Y = 1 To UBound(Nuc12, 1) - 6 Step 6
'                StepPos = StepPos + 1
'                A = Nuc12(Y, X)
'                B = Nuc12(Y + 1, X)
'                C = Nuc12(Y + 2, X)
'                D = Nuc12(Y + 3, X)
'                E = Nuc12(Y + 4, X)
'                F = Nuc12(Y + 5, X)
'                ISeq12(StepPos, X) = SeqCompressor12(A, B, C, D, E, F)
'            Next Y
'        End If
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        If Y <= UBound(Nuc12, 1) Then
            A = Nuc12(Y, x)
            If Y + 1 <= UBound(Nuc12, 1) Then
                b = Nuc12(Y + 1, x)
                If Y + 2 <= UBound(Nuc12, 1) Then
                    C = Nuc12(Y + 2, x)
                    If Y + 3 <= UBound(Nuc12, 1) Then
                        D = Nuc12(Y + 3, x)
                        If Y + 4 <= UBound(Nuc12, 1) Then
                            e = Nuc12(Y + 4, x)
                            If Y + 5 <= UBound(Nuc12, 1) Then
                                F = Nuc12(Y + 5, x)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        ISeq12(StepPos, x) = SeqCompressor12(A, b, C, D, e, F)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.172, 0.452 for 3800
'X = X
''03
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    ' tRedoDist(X) = 1 Or X = X Then
    
         StepPos = 0
         'If UBound(Nuc03, 2) > 12 And x = 12345 Then
            StepPos = MakeSC03(x, Y, UBound(Nuc03, 1), UBound(ISeq03, 1), ISeq03(0, 0), SeqCompressor03(0, 0, 0, 0, 0, 0), Nuc03(0, 0))
'         Else
'
'            For Y = 1 To UBound(Nuc03, 1) - 6 Step 6
'                StepPos = StepPos + 1
'                A = Nuc03(Y, x)
'                b = Nuc03(Y + 1, x)
'                c = Nuc03(Y + 2, x)
'                D = Nuc03(Y + 3, x)
'                E = Nuc03(Y + 4, x)
'                F = Nuc03(Y + 5, x)
'                ISeq03(StepPos, x) = SeqCompressor03(A, b, c, D, E, F)
'            Next Y
'         End If
         StepPos = StepPos + 1
         A = 0
         b = 0
         C = 0
         D = 0
         e = 0
         F = 0
         If Y <= UBound(Nuc03, 1) Then
             A = Nuc03(Y, x)
             If Y + 1 <= UBound(Nuc03, 1) Then
                 b = Nuc03(Y + 1, x)
                 If Y + 2 <= UBound(Nuc03, 1) Then
                     C = Nuc03(Y + 2, x)
                     If Y + 3 <= UBound(Nuc03, 1) Then
                         D = Nuc03(Y + 3, x)
                         If Y + 4 <= UBound(Nuc03, 1) Then
                             e = Nuc03(Y + 4, x)
                             If Y + 5 <= UBound(Nuc03, 1) Then
                                 F = Nuc03(Y + 5, x)
                             
                             End If
                         
                         End If
                    
                     End If
                 
                 End If
                 
            
             End If
        
         End If
         ISeq03(StepPos, x) = SeqCompressor03(A, b, C, D, e, F)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.000, 0.16 for 3800
'X = X
'11
'
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
        'If X = X Then
       ' XX = UBound(Nuc11, 2)
            StepPos = MakeSC11(x, Y, UBound(Nuc11, 1), UBound(ISeq11, 1), ISeq11(0, 0), SeqCompressor11(0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Nuc11(0, 0))
        'Else
'            StepPos = 0
'
'            For Y = 1 To UBound(Nuc11, 1) - 10 Step 10
'                StepPos = StepPos + 1
'                A = Nuc11(Y, X)
'                B = Nuc11(Y + 1, X)
'                C = Nuc11(Y + 2, X)
'                D = Nuc11(Y + 3, X)
'                E = Nuc11(Y + 4, X)
'                F = Nuc11(Y + 5, X)
'                G = Nuc11(Y + 6, X)
'                H = Nuc11(Y + 7, X)
'                I = Nuc11(Y + 8, X)
'                J = Nuc11(Y + 9, X)
'                ISeq11(StepPos, X) = SeqCompressor11(A, B, C, D, E, F, G, H, I, J)
'            Next Y
'        End If
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        g = 0
        H = 0
        i = 0
        j = 0
        
        If Y <= UBound(Nuc11, 1) Then
            A = Nuc11(Y, x)
            If Y + 1 <= UBound(Nuc11, 1) Then
                b = Nuc11(Y + 1, x)
                If Y + 2 <= UBound(Nuc11, 1) Then
                    C = Nuc11(Y + 2, x)
                    If Y + 3 <= UBound(Nuc11, 1) Then
                        D = Nuc11(Y + 3, x)
                        If Y + 4 <= UBound(Nuc11, 1) Then
                            e = Nuc11(Y + 4, x)
                            If Y + 5 <= UBound(Nuc11, 1) Then
                                F = Nuc11(Y + 5, x)
                                If Y + 6 <= UBound(Nuc11, 1) Then
                                    g = Nuc11(Y + 6, x)
                                    If Y + 7 <= UBound(Nuc11, 1) Then
                                        H = Nuc11(Y + 7, x)
                                        If Y + 8 <= UBound(Nuc11, 1) Then
                                            i = Nuc11(Y + 8, x)
                                            If Y + 9 <= UBound(Nuc11, 1) Then
                                                j = Nuc11(Y + 9, x)
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
        ISeq11(StepPos, x) = SeqCompressor11(A, b, C, D, e, F, g, H, i, j)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.156 '0.500 for 3800
'X = X
''02
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
    'XX = UBound(Nuc02, 2)
        StepPos = MakeSC02(x, Y, UBound(Nuc02, 1), UBound(ISeq02, 1), ISeq02(0, 0), SeqCompressor02(0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Nuc02(0, 0))

'        StepPos = 0
'        For Y = 1 To UBound(Nuc02, 1) - 10 Step 10
'            StepPos = StepPos + 1
'            A = Nuc02(Y, X) '0,0
'            B = Nuc02(Y + 1, X) '0,1
'            C = Nuc02(Y + 2, X) '0,0
'            D = Nuc02(Y + 3, X) '1,1
'            E = Nuc02(Y + 4, X) '0,0
'            F = Nuc02(Y + 5, X) '1,0
'            G = Nuc02(Y + 6, X) '0,0
'            H = Nuc02(Y + 7, X) '1,0
'            I = Nuc02(Y + 8, X) '0,0
'            J = Nuc02(Y + 9, X) '1,0
'            ISeq02(StepPos, X) = SeqCompressor02(A, B, C, D, E, F, G, H, I, J)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        g = 0
        H = 0
        i = 0
        j = 0
        
        If Y <= UBound(Nuc02, 1) Then
            A = Nuc02(Y, x)
            If Y + 1 <= UBound(Nuc02, 1) Then
                b = Nuc02(Y + 1, x)
                If Y + 2 <= UBound(Nuc02, 1) Then
                    C = Nuc02(Y + 2, x)
                    If Y + 3 <= UBound(Nuc02, 1) Then
                        D = Nuc02(Y + 3, x)
                        If Y + 4 <= UBound(Nuc02, 1) Then
                            e = Nuc02(Y + 4, x)
                            If Y + 5 <= UBound(Nuc02, 1) Then
                                F = Nuc02(Y + 5, x)
                                If Y + 6 <= UBound(Nuc02, 1) Then
                                    g = Nuc02(Y + 6, x)
                                    If Y + 7 <= UBound(Nuc02, 1) Then
                                        H = Nuc02(Y + 7, x)
                                        If Y + 8 <= UBound(Nuc02, 1) Then
                                            i = Nuc02(Y + 8, x)
                                            If Y + 9 <= UBound(Nuc02, 1) Then
                                                j = Nuc02(Y + 9, x)
                                            
                                            End If
                                        
                                        End If
                                   
                                    End If
                                
                                End If
                                
                            
                            End If
                        
                        End If
                    
                    End If
               
                End If
            
            End If
        End If
        ISeq02(StepPos, x) = SeqCompressor02(A, b, C, D, e, F, g, H, i, j)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.000 for 3800
'X = X
''1.014 for 3200 seqs

'4.478 for 1700 sequences'7.143 for 3200 sequences'4.4  3200 seqs
Dim TValid As Long, TDiffs As Long
'XX = UBound(Nuc11, 1)
'XX = UBound(Nuc02, 1)
'XX = UBound(Nuc12, 1)
'XX = UBound(Nuc03, 1)
'XX = UBound(Nuc13, 1)
'XX = UBound(Nuc04, 1)
'XX = UBound(Nuc14, 1)
'SS2 = Abs(GetTickCount)
Dim Upper As Double
Udst = 0
Dim TargetVal As Long, DoneNum As Long
DoneNum = 0
TargetVal = NextNo * (NextNo + 1) / 2
'
'SS = Abs(GetTickCount)
'XX = SeqCatCount
Dim ExtraValids As Long
ExtraValids = 0
'XX = UBound(Decompress, 1)
If Len(StrainSeq(0)) <> Decompress(Len(StrainSeq(0))) Then 'And (StartPosInAlign <> 1 Or EndPosInAlign <> Len(StrainSeq(0))) Then
    If StartPosInAlign < EndPosInAlign Then
        '@'@'@'@
        For x = Decompress(StartPosInAlign) To Decompress(EndPosInAlign)
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
    Else
        For x = Decompress(StartPosInAlign) To Decompress(Len(StrainSeq(0)))
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
        For x = 1 To Decompress(EndPosInAlign)
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
    End If
    SeqCatCount(0, 1) = SeqCatCount(0, 1) + ExtraValids
End If

'EE = Abs(GetTickCount)
'TT = EE - SS '0.000 for 3800
'X = X
'SS = Abs(GetTickCount)
'0.702 seconds and 6.9 seconds Urmillas event 1
SS = Abs(GetTickCount)

If ShowProg = 1 Then
Udst = SuperDistP2(0, NextNo, UBound(ISeq14, 1), UBound(ISeq04, 1), UBound(ISeq13, 1), UBound(ISeq03, 1), UBound(ISeq12, 1), UBound(ISeq02, 1), UBound(ISeq11, 1), AvDst, PermDIffs(0, 0), PermValid(0, 0), Distance(0, 0), tRedoDist(0), SeqCatCount(0, 0), ISeq14(0, 0), ISeq04(0, 0), ISeq13(0, 0), ISeq03(0, 0), ISeq12(0, 0), ISeq02(0, 0), ISeq11(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0), CompressValid13(0, 0), CompressDiffs13(0, 0), CompressValid12(0, 0), CompressDiffs12(0, 0), CompressValid11(0, 0), CompressDiffs11(0, 0), CompressDiffs04(0, 0), CompressDiffs03(0, 0), CompressDiffs02(0, 0))
'     EE = abs(gettickcount)
'         TT = EE - SS
'         If TT < 7 Then TT = 7
'         FBD = FBD + TT
    'Dummy = SuperDist2(Nextno, UBound(ISeq14, 1), UBound(ISeq04, 1), UBound(ISeq13, 1), UBound(ISeq03, 1), UBound(ISeq12, 1), UBound(ISeq02, 1), UBound(ISeq11, 1), SeqCatCount(0, 0), ISeq14(0, 0), ISeq04(0, 0), ISeq13(0, 0), ISeq03(0, 0), ISeq12(0, 0), ISeq02(0, 0), ISeq11(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0), CompressValid13(0, 0), CompressDiffs13(0, 0), CompressValid12(0, 0), CompressDiffs12(0, 0), CompressValid11(0, 0), CompressDiffs11(0, 0), CompressDiffs04(0, 0), CompressDiffs03(0, 0), CompressDiffs02(0, 0))
Else

    AvDst = 0
    For x = 0 To NextNo - 1
        
        If x = x Then
            '@,@'@'@'@'@'@'@'@'@'@
            Upper = SuperDistP(x, NextNo, UBound(ISeq14, 1), UBound(ISeq04, 1), UBound(ISeq13, 1), UBound(ISeq03, 1), UBound(ISeq12, 1), UBound(ISeq02, 1), UBound(ISeq11, 1), AvDst, PermDIffs(0, 0), PermValid(0, 0), Distance(0, 0), tRedoDist(0), SeqCatCount(0, 0), ISeq14(0, 0), ISeq04(0, 0), ISeq13(0, 0), ISeq03(0, 0), ISeq12(0, 0), ISeq02(0, 0), ISeq11(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0), CompressValid13(0, 0), CompressDiffs13(0, 0), CompressValid12(0, 0), CompressDiffs12(0, 0), CompressValid11(0, 0), CompressDiffs11(0, 0), CompressDiffs04(0, 0), CompressDiffs03(0, 0), CompressDiffs02(0, 0))
            
            If Udst < Upper Then Udst = Upper
        Else
            For Y = x + 1 To NextNo
                TValid = 0
                TDiffs = 0
                '14
                For Z = 1 To UBound(ISeq14, 1)
                    TValid = TValid + CompressValid14(ISeq14(Z, x), ISeq14(Z, Y))
                    TDiffs = TDiffs + CompressDiffs14(ISeq14(Z, x), ISeq14(Z, Y))
                Next Z
               'XX = CompressValid(ISeq14(Z, X), ISeq14(Z, Y))
               ' XX = CompressDiffs(ISeq14(Z, X), ISeq14(Z, Y))
                '4,1
                '3,3
                For Z = 1 To UBound(ISeq13, 1)
                    TValid = TValid + CompressValid13(ISeq13(Z, x), ISeq13(Z, Y))
                    TDiffs = TDiffs + CompressDiffs13(ISeq13(Z, x), ISeq13(Z, Y))
                Next Z
                '04
                '19,10
                '19,15
                For Z = 1 To UBound(ISeq04, 1)
                    
                    TDiffs = TDiffs + CompressDiffs04(ISeq04(Z, x), ISeq04(Z, Y))
                Next Z
                TValid = TValid + SeqCatCount(0, 4)
                '12
                
                '635,932
                '744,932
                For Z = 1 To UBound(ISeq12, 1)
                    TValid = TValid + CompressValid12(ISeq12(Z, x), ISeq12(Z, Y))
                    TDiffs = TDiffs + CompressDiffs12(ISeq12(Z, x), ISeq12(Z, Y))
                Next Z
                '03
                For Z = 1 To UBound(ISeq03, 1)
                    'tValid = tValid + CompressValid03(ISeq03(Z, X), ISeq03(Z, Y))
                    TDiffs = TDiffs + CompressDiffs03(ISeq03(Z, x), ISeq03(Z, Y))
                Next Z
                TValid = TValid + SeqCatCount(0, 3)
                '11
                For Z = 1 To UBound(ISeq11, 1)
                    TValid = TValid + CompressValid11(ISeq11(Z, x), ISeq11(Z, Y))
                    TDiffs = TDiffs + CompressDiffs11(ISeq11(Z, x), ISeq11(Z, Y))
                     
                Next Z
                '02
                For Z = 1 To UBound(ISeq02, 1)
                    'tValid = tValid + CompressValid02(ISeq02(Z, X), ISeq02(Z, Y))
                    TDiffs = TDiffs + CompressDiffs02(ISeq02(Z, x), ISeq02(Z, Y))
                   
                Next Z
                TValid = TValid + SeqCatCount(0, 2)
                TValid = TValid + SeqCatCount(0, 1)
                
                
                
                
                
                
                PermValid(x, Y) = TValid
                PermValid(Y, x) = TValid
                PermDIffs(Y, x) = TDiffs
                PermDIffs(x, Y) = TDiffs
                
              
                
            Next Y
        End If
        
        DoneNum = DoneNum + (NextNo) - x
        If ShowProg = 0 Then
            SSSS = Abs(GetTickCount)
            If Abs(SSSS - GlobalTimer) > 500 Then
                GlobalTimer = SSSS
                 '
                If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated"
                'Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated "
                ' '
                'Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                'if Abs(ssss - llll) > 500
                'Form1.SetFocus
                
                
                LLLL = SSSS
                'DoEvents
            End If
        End If
    Next x
End If

'EE = abs(gettickcount)
'         TT = EE - SS
'         If TT < 7 Then TT = T
'         FBD = FBD + TT

If ShowProg = 0 Then
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
End If
'DoEvents


'686.092
'48.09 in c++
'39.531 without updating every cycle
'EE = Abs(GetTickCount)
'TT = EE - SS '34.968 vs 12.250 with superdistp'14.334 with "critical" section to increase consistency
''46.036 for 3200 seqs
'X = X
'3.5 seconds and 6.957 seconds Urmillas event 1'3.3 seconds, 4.228; 3.3 for first 3.29 for second
'3.510 seconds and 5.960 seconds Urmillas event 1 with makeseqcatcount
End Sub
Public Sub FastDistanceCalcZ(ShowProg, StoreFlag, StartPosInAlign, EndPosInAlign, NextNo As Long, PermDIffs() As Single, PermValid() As Single, SeqNum() As Integer, Distance() As Single, AvDst As Double, Udst As Double, tRedoDist() As Integer)


'SS = Abs(GetTickCount)

Dim TT As Long, SSSS As Long, LLLL As Long, Dummy As Long, AA() As Long, SeqSpace() As Byte, ANum, SeqCatCount() As Long, NucMat() As Byte, NumNucs As Byte, NucMat2() As Byte
ReDim SeqSpace(Len(StrainSeq(0)))
Dim Nuc11() As Byte, Nuc02() As Byte, Nuc12() As Byte
Dim Nuc03() As Byte, Nuc13() As Byte, Nuc04() As Byte, Nuc14() As Byte
'Dim MissChar() As Byte
'Dim NucChar() As Byte
Dim ISeq11() As Integer, ISeq02() As Integer, ISeq12() As Integer
Dim ISeq03() As Integer, ISeq13() As Integer, ISeq04() As Integer, ISeq14() As Integer

'ReDim Nuc10(1, CLng(Len(StrainSeq(0) / 10)) + 1)
'ReDim Nuc01(1, CLng(Len(StrainSeq(0) / 10)) + 1)
Dim A As Long, b As Long, C As Long, D As Long, e As Long, F As Long, g As Long, H As Long, i As Long, j As Long
Dim Q As Long, r As Long, S As Long, T As Long, U As Long, V As Long, W As Long, x As Long, Y As Long, Z As Long
Dim FLP() As Byte, ML() As Byte, NL() As Byte

Dim NucMatB() As Byte
ReDim NucMatB(4)
ReDim NucMat2(100)
ReDim NucMat(100)

NucMat(66) = 1
NucMat(68) = 2
NucMat(72) = 3
NucMat(85) = 4
'@'@'@'@
ReDim FLP(NextNo, Len(StrainSeq(0)))
ReDim ML(Len(StrainSeq(0))), NL(Len(StrainSeq(0)))
'ReDim MissChar(Len(StrainSeq(0)))
'ReDim NucChar(Len(StrainSeq(0)))


If CompressValid11(876, 950) = 0 Then
    Call MakeSeqCompressors 'this code should only ever be executed once per install
End If

NucMatB(1) = 66
NucMatB(2) = 68
NucMatB(3) = 72
NucMatB(4) = 85
ReDim SeqCatCount(1, 4)

ReDim AA(4)

'SS = Abs(GetTickCount)
'SS = Abs(GetTickCount)
'this categorizes sites based on numbers of nucleotide polymorphisms and the presence/absence of gaps
'If X = X Then
    ''''''
    'Dummy = MakeSeqCatCount(Nextno, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0))
    '@'@'@'@'@'@'@'@'$'$'@'&'&'&'&
    If NextNo < 500 Or x = x Then
    
        Dummy = MakeSeqCatCount2(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0), SeqSpace(0), NucMatB(0), NucMat2(0), FLP(0, 0), ML(0), NL(0))
    Else
        '&
        Dummy = MakeSeqCatCount2P(NextNo, Len(StrainSeq(0)), UBound(SeqNum, 1), UBound(SeqCatCount, 1), StartPosInAlign, EndPosInAlign, SeqCatCount(0, 0), AA(0), SeqNum(0, 0), NucMat(0), SeqSpace(0), NucMatB(0), NucMat2(0), FLP(0, 0), ML(0), NL(0))
   End If
   'EE = abs(gettickcount)
   'TT = EE - SS
   'for freds start at event 2 - 250/1579
   'p version 234/1641
   'with parallelization 2nd loop 172/1175
   'rearrangement first loop 78/563
   'paralleization 1st loop 16/94
   x = x
'Else
'
'    ANum = 0
'    SeqCatCount(1, 1) = 0
'    SeqCatCount(1, 2) = 0
'    SeqCatCount(0, 3) = 0
'    SeqCatCount(1, 3) = 0
'    SeqCatCount(0, 4) = 0
'    SeqCatCount(1, 4) = 0
'    SeqCatCount(0, 2) = 0
'    SeqCatCount(0, 0) = 0
'    SeqCatCount(0, 1) = 0
'    SeqCatCount(1, 0) = 0
'    If StartPosInAlign <= EndPosInAlign Then
'
'
'        For X = StartPosInAlign To EndPosInAlign
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'        Next X
'
'    ElseIf StartPosInAlign > EndPosInAlign Then
'        For X = StartPosInAlign To LSeq
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'
'        Next X
'        For X = 1 To EndPosInAlign
'            AA(0) = 0
'            AA(1) = 0
'            AA(2) = 0
'            AA(3) = 0
'            AA(4) = 0
'
'            For Y = 0 To Nextno
'                AA(NucMat(SeqNum(X, Y))) = 1
'            Next Y
'            ANum = CLng(AA(1) + AA(2) + AA(3) + AA(4))
'
'            SeqSpace(X) = AA(0)
'            NumNucs = CLng(AA(0))
'            SeqCatCount(NumNucs, ANum) = SeqCatCount(NumNucs, ANum) + 1
'
'            For Y = 1 To 4
'                If AA(Y) = 1 Then
'                    NucMat2(NucMatB(Y)) = NumNucs
'                    NumNucs = NumNucs + 1
'                End If
'            Next Y
'            ML(X) = AA(0)
'            NL(X) = ANum
'            For Y = 0 To Nextno
'                FLP(Y, X) = NucMat2(SeqNum(X, Y))
'            Next Y
'
'        Next X
'
'    End If
'
'
'End If
'EE = Abs(GetTickCount)
'    TT = EE - SS '0.640,3.042'0.452,0.2215
'1.950 for 3200 sequences'1.514 for 3200'1.342 - not calc seqspaces etc
'0.983 in VB 0.749 in C for 1700 sequences 0.592 with bytes instead of longs
ReDim Nuc11(SeqCatCount(1, 1), NextNo + 1)
'@
ReDim Nuc02(SeqCatCount(0, 2), NextNo + 1)
ReDim Nuc12(SeqCatCount(1, 2), NextNo + 1)
ReDim Nuc03(SeqCatCount(0, 3), NextNo + 1)
ReDim Nuc13(SeqCatCount(1, 3), NextNo + 1)
ReDim Nuc04(SeqCatCount(0, 4), NextNo + 1)
ReDim Nuc14(SeqCatCount(1, 4), NextNo + 1)

'If X = 1234567 Then
'    A = StartPosInAlign
'    B = EndPosInAlign
'    Dummy = MakeNucSets3(UBound(FLP, 1), Nextno, A, B, UBound(Nuc11, 1), UBound(Nuc12, 1), UBound(Nuc13, 1), UBound(Nuc14, 1), UBound(Nuc02, 1), UBound(Nuc03, 1), UBound(Nuc04, 1), NL(0), ML(0), FLP(0, 0), Nuc11(0, 0), Nuc02(0, 0), Nuc12(0, 0), Nuc03(0, 0), Nuc13(0, 0), Nuc04(0, 0), Nuc14(0, 0))
'    'XX = SeqCatCount(1, 0)
'
'    X = X
'Else
    
    
    
    
    Dim N02 As Long, N03 As Long, N04 As Long, N11 As Long, N12 As Long, N13 As Long, N14 As Long
    N02 = 0: N03 = 0: N04 = 0
    N11 = 0: N12 = 0: N13 = 0: N14 = 0
'    SS = Abs(GetTickCount)
    x = StartPosInAlign
    
    
    'This makes a separate nucxx for all the different site categories
    '@'@
    Do
        
        If ML(x) = 0 Then 'there are no gaps at this site
            If NL(x) = 2 Then ' there are two variants at this site
                N02 = N02 + 1
                Dummy = FillNucXX(N02, NextNo, x, UBound(Nuc02, 1), UBound(FLP, 1), Nuc02(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc02(N02, Y) = FLP(X, Y)
'                Next Y
                
                
            ElseIf NL(x) = 3 Then 'there are three variants at this site
                N03 = N03 + 1
                Dummy = FillNucXX(N03, NextNo, x, UBound(Nuc03, 1), UBound(FLP, 1), Nuc03(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc03(N03, Y) = FLP(X, Y)
'                Next Y
                
                
            ElseIf NL(x) = 4 Then 'there are 4 variants at this site
                N04 = N04 + 1
                Dummy = FillNucXX(N04, NextNo, x, UBound(Nuc04, 1), UBound(FLP, 1), Nuc04(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc04(N04, Y) = FLP(X, Y)
'                Next Y
                
            End If
            
        Else 'there are gaps at this site
            If NL(x) = 1 Then 'there is only one type of nucleotide at this site
                N11 = N11 + 1
                '
                Dummy = FillNucXX(N11, NextNo, x, UBound(Nuc11, 1), UBound(FLP, 1), Nuc11(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc11(N11, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 2 Then 'there are two nucleotide variants at this site
                N12 = N12 + 1
                ''
                Dummy = FillNucXX(N12, NextNo, x, UBound(Nuc12, 1), UBound(FLP, 1), Nuc12(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc12(N12, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 3 Then 'there are three nucleotide variants at this site
                N13 = N13 + 1
                 '
                Dummy = FillNucXX(N13, NextNo, x, UBound(Nuc13, 1), UBound(FLP, 1), Nuc13(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc13(N13, Y) = FLP(X, Y)
'                Next Y
                
            ElseIf NL(x) = 4 Then 'there are 4 nucleotide variants at this site
                N14 = N14 + 1
                '@'@'$'$
                Dummy = FillNucXX(N14, NextNo, x, UBound(Nuc14, 1), UBound(FLP, 1), Nuc14(0, 0), FLP(0, 0))
'                For Y = 0 To Nextno
'                    Nuc14(N14, Y) = FLP(X, Y)
'                Next Y
                
            End If
        
        End If
        '@
        If x = EndPosInAlign Then Exit Do
        x = x + 1
        '@
        If x > Len(StrainSeq(0)) Then x = 1
        
    
    Loop
'    If X = 1234567 Then
'    N11 = SeqCatCount(1, 1)
'    N12 = SeqCatCount(1, 2)
'    N13 = SeqCatCount(1, 3)
'    N14 = SeqCatCount(1, 4)
'    N02 = SeqCatCount(0, 2)
'    N03 = SeqCatCount(0, 3)
'    N04 = SeqCatCount(0, 4)
'    End If
'End If


'
'EE = Abs(GetTickCount)
'    TT = EE - SS '0.561,2.855,3.447,3.432, 0.156,1.108'0.630.359
'    X = X '4.446,4.430, 3.338,3.370
    '0.499'2.808 -c++ version
    '0.499,2.730 - vb version
'6.303 for 3200'3.386 for 3200'2.153 for 3200 with bytes
'2.184 for 1700 seqs in VB' 1.293 in C
ReDim ISeq11(CLng(SeqCatCount(1, 1) / 10) + 1, NextNo)
ReDim ISeq02(CLng(SeqCatCount(0, 2) / 10) + 1, NextNo)
ReDim ISeq12(CLng(SeqCatCount(1, 2) / 6) + 1, NextNo)
ReDim ISeq03(CLng(SeqCatCount(0, 3) / 6) + 1, NextNo)
ReDim ISeq13(CLng(SeqCatCount(1, 3) / 5) + 1, NextNo)
ReDim ISeq04(CLng(SeqCatCount(0, 4) / 5) + 1, NextNo)
ReDim ISeq14(CLng(SeqCatCount(1, 4) / 4) + 1, NextNo)


'SS = Abs(GetTickCount)
'1178,0,1082,0,491,0,100

Dim StepPos As Long
'14
'For x = 0 To UBound(Nuc14, 1)
'    For Z = 0 To UBound(Nuc14, 2)
'        If Nuc14(x, Z) > 4 Then
'            x = x
'        End If
'    Next Z
'Next x
'For x = 0 To Len(StrainSeq(0))
'
'    If SeqNum(x, 1001) <> 46 And SeqNum(x, 1001) <> 66 And SeqNum(x, 1001) <> 68 And SeqNum(x, 1001) <> 72 And SeqNum(x, 1001) <> 85 Then
'        x = x
'        XX = SeqNum(x, 1)
'    End If
'Next x
'x = x
'this makes compressed sequences (stored in iseqxx) comprising only sites in a a single site actegory (catorgory 02, for example, are sites with no gaps and 2 nucleotide variants whereas sites in category 14 have one or more gaps and 4 different nucleotides present)
For x = 0 To NextNo
   ' If tRedoDist(X) = 1 Then
        'If UBound(Nuc14, 2) > 10 Then
            StepPos = MakeSC14(x, Y, UBound(Nuc14), UBound(ISeq14), ISeq14(0, 0), SeqCompressor14(0, 0, 0, 0), Nuc14(0, 0))
'        Else
'
'
'            StepPos = 0
'            For Y = 1 To UBound(Nuc14, 1) - 4 Step 4
'                StepPos = StepPos + 1
'                A = Nuc14(Y, x) '4,4,4
'                b = Nuc14(Y + 1, x) '1,1,4
'                c = Nuc14(Y + 2, x) '0,4,4
'                D = Nuc14(Y + 3, x) '0,4,4
'                ISeq14(StepPos, x) = SeqCompressor14(A, b, c, D)
'            Next Y
'        End If
        StepPos = StepPos + 1
        
        A = 0
        b = 0
        C = 0
        D = 0
        If Y <= UBound(Nuc14, 1) Then
            A = Nuc14(Y, x)
            If Y + 1 <= UBound(Nuc14, 1) Then
                b = Nuc14(Y + 1, x)
                If Y + 2 <= UBound(Nuc14, 1) Then
                    C = Nuc14(Y + 2, x)
                    If Y + 3 <= UBound(Nuc14, 1) Then
                        D = Nuc14(Y + 3, x)
                    End If
                End If
            End If
        End If
        ISeq14(StepPos, x) = SeqCompressor14(A, b, C, D)
  '  End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.047 '0.374 for 3800
'X = X
''13
'XX = SeqNum(100, 6)
'SS = Abs(GetTickCount)
'@
For x = 0 To NextNo
   ' If tRedoDist(X) = 1 Or X = X Then
        '
       ' XX = UBound(Nuc13, 2)
        StepPos = MakeSC13(x, Y, UBound(Nuc13), UBound(ISeq13), ISeq13(0, 0), SeqCompressor13(0, 0, 0, 0, 0), Nuc13(0, 0))
'        StepPos = 0
'
'        For Y = 1 To UBound(Nuc13, 1) - 5 Step 5
'            StepPos = StepPos + 1
'            A = Nuc13(Y, X)
'            B = Nuc13(Y + 1, X)
'            C = Nuc13(Y + 2, X)
'            D = Nuc13(Y + 3, X)
'            E = Nuc13(Y + 4, X)
'            ISeq13(StepPos, X) = SeqCompressor13(A, B, C, D, E)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        
        If Y <= UBound(Nuc13, 1) Then
            A = Nuc13(Y, x)
            If Y + 1 <= UBound(Nuc13, 1) Then
                b = Nuc13(Y + 1, x)
                If Y + 2 <= UBound(Nuc13, 1) Then
                    C = Nuc13(Y + 2, x)
                    If Y + 3 <= UBound(Nuc13, 1) Then
                        D = Nuc13(Y + 3, x)
                        If Y + 4 <= UBound(Nuc13, 1) Then
                            e = Nuc13(Y + 4, x)
                        End If
                    End If
                End If
            End If
        End If
        
        ISeq13(StepPos, x) = SeqCompressor13(A, b, C, D, e)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.094, 0.265 for 3800
'X = X
''04
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
   ' XX = UBound(Nuc04, 2)
        StepPos = MakeSC04(x, Y, UBound(Nuc04), UBound(ISeq04), ISeq04(0, 0), SeqCompressor04(0, 0, 0, 0, 0), Nuc04(0, 0))
'        StepPos = 0
'        For Y = 1 To UBound(Nuc04, 1) - 5 Step 5
'            StepPos = StepPos + 1
'            A = Nuc04(Y, X)
'            B = Nuc04(Y + 1, X)
'            C = Nuc04(Y + 2, X)
'            D = Nuc04(Y + 3, X)
'            E = Nuc04(Y + 4, X)
'            ISeq04(StepPos, X) = SeqCompressor04(A, B, C, D, E)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        If Y <= UBound(Nuc04, 1) Then
            A = Nuc04(Y, x)
            If Y + 1 <= UBound(Nuc04, 1) Then
                b = Nuc04(Y + 1, x)
                If Y + 2 <= UBound(Nuc04, 1) Then
                    C = Nuc04(Y + 2, x)
                    If Y + 3 <= UBound(Nuc04, 1) Then
                        D = Nuc04(Y + 3, x)
                        If Y + 4 <= UBound(Nuc04, 1) Then
                            e = Nuc04(Y + 4, x)
                        
                        End If
                    
                    End If
                
                End If
           
            End If
            
        
        End If
        ISeq04(StepPos, x) = SeqCompressor04(A, b, C, D, e)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.016, 0 for 3800
'X = X
''12
'
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
        'If X = X Then
            '
            'XX = UBound(Nuc12, 2)
            StepPos = MakeSC12(x, Y, UBound(Nuc12, 1), UBound(ISeq12, 1), ISeq12(0, 0), SeqCompressor12(0, 0, 0, 0, 0, 0), Nuc12(0, 0))
'        Else
'            StepPos = 0
'
'            For Y = 1 To UBound(Nuc12, 1) - 6 Step 6
'                StepPos = StepPos + 1
'                A = Nuc12(Y, X)
'                B = Nuc12(Y + 1, X)
'                C = Nuc12(Y + 2, X)
'                D = Nuc12(Y + 3, X)
'                E = Nuc12(Y + 4, X)
'                F = Nuc12(Y + 5, X)
'                ISeq12(StepPos, X) = SeqCompressor12(A, B, C, D, E, F)
'            Next Y
'        End If
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        If Y <= UBound(Nuc12, 1) Then
            A = Nuc12(Y, x)
            If Y + 1 <= UBound(Nuc12, 1) Then
                b = Nuc12(Y + 1, x)
                If Y + 2 <= UBound(Nuc12, 1) Then
                    C = Nuc12(Y + 2, x)
                    If Y + 3 <= UBound(Nuc12, 1) Then
                        D = Nuc12(Y + 3, x)
                        If Y + 4 <= UBound(Nuc12, 1) Then
                            e = Nuc12(Y + 4, x)
                            If Y + 5 <= UBound(Nuc12, 1) Then
                                F = Nuc12(Y + 5, x)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        ISeq12(StepPos, x) = SeqCompressor12(A, b, C, D, e, F)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.172, 0.452 for 3800
'X = X
''03
'SS = Abs(GetTickCount)
'@
For x = 0 To NextNo
    ' tRedoDist(X) = 1 Or X = X Then
    
         StepPos = 0
         'If UBound(Nuc03, 2) > 12 And x = 12345 Then
            StepPos = MakeSC03(x, Y, UBound(Nuc03, 1), UBound(ISeq03, 1), ISeq03(0, 0), SeqCompressor03(0, 0, 0, 0, 0, 0), Nuc03(0, 0))
'         Else
'
'            For Y = 1 To UBound(Nuc03, 1) - 6 Step 6
'                StepPos = StepPos + 1
'                A = Nuc03(Y, x)
'                b = Nuc03(Y + 1, x)
'                c = Nuc03(Y + 2, x)
'                D = Nuc03(Y + 3, x)
'                E = Nuc03(Y + 4, x)
'                F = Nuc03(Y + 5, x)
'                ISeq03(StepPos, x) = SeqCompressor03(A, b, c, D, E, F)
'            Next Y
'         End If
         StepPos = StepPos + 1
         A = 0
         b = 0
         C = 0
         D = 0
         e = 0
         F = 0
         If Y <= UBound(Nuc03, 1) Then
             A = Nuc03(Y, x)
             If Y + 1 <= UBound(Nuc03, 1) Then
                 b = Nuc03(Y + 1, x)
                 If Y + 2 <= UBound(Nuc03, 1) Then
                     C = Nuc03(Y + 2, x)
                     If Y + 3 <= UBound(Nuc03, 1) Then
                         D = Nuc03(Y + 3, x)
                         If Y + 4 <= UBound(Nuc03, 1) Then
                             e = Nuc03(Y + 4, x)
                             If Y + 5 <= UBound(Nuc03, 1) Then
                                 F = Nuc03(Y + 5, x)
                             
                             End If
                         
                         End If
                    
                     End If
                 
                 End If
                 
            
             End If
        
         End If
         ISeq03(StepPos, x) = SeqCompressor03(A, b, C, D, e, F)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.000, 0.16 for 3800
'X = X
'11
'
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
        'If X = X Then
       ' XX = UBound(Nuc11, 2)
       '@
            StepPos = MakeSC11(x, Y, UBound(Nuc11, 1), UBound(ISeq11, 1), ISeq11(0, 0), SeqCompressor11(0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Nuc11(0, 0))
        'Else
'            StepPos = 0
'
'            For Y = 1 To UBound(Nuc11, 1) - 10 Step 10
'                StepPos = StepPos + 1
'                A = Nuc11(Y, X)
'                B = Nuc11(Y + 1, X)
'                C = Nuc11(Y + 2, X)
'                D = Nuc11(Y + 3, X)
'                E = Nuc11(Y + 4, X)
'                F = Nuc11(Y + 5, X)
'                G = Nuc11(Y + 6, X)
'                H = Nuc11(Y + 7, X)
'                I = Nuc11(Y + 8, X)
'                J = Nuc11(Y + 9, X)
'                ISeq11(StepPos, X) = SeqCompressor11(A, B, C, D, E, F, G, H, I, J)
'            Next Y
'        End If

        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        g = 0
        H = 0
        i = 0
        j = 0
        
        If Y <= UBound(Nuc11, 1) Then
            A = Nuc11(Y, x)
            If Y + 1 <= UBound(Nuc11, 1) Then
                b = Nuc11(Y + 1, x)
                If Y + 2 <= UBound(Nuc11, 1) Then
                    C = Nuc11(Y + 2, x)
                    If Y + 3 <= UBound(Nuc11, 1) Then
                        D = Nuc11(Y + 3, x)
                        If Y + 4 <= UBound(Nuc11, 1) Then
                            e = Nuc11(Y + 4, x)
                            If Y + 5 <= UBound(Nuc11, 1) Then
                                F = Nuc11(Y + 5, x)
                                If Y + 6 <= UBound(Nuc11, 1) Then
                                    g = Nuc11(Y + 6, x)
                                    If Y + 7 <= UBound(Nuc11, 1) Then
                                        H = Nuc11(Y + 7, x)
                                        If Y + 8 <= UBound(Nuc11, 1) Then
                                            i = Nuc11(Y + 8, x)
                                            If Y + 9 <= UBound(Nuc11, 1) Then
                                                j = Nuc11(Y + 9, x)
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
        ISeq11(StepPos, x) = SeqCompressor11(A, b, C, D, e, F, g, H, i, j)
    'End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.156 '0.500 for 3800
'X = X
''02
'SS = Abs(GetTickCount)
For x = 0 To NextNo
    'If tRedoDist(X) = 1 Or X = X Then
    'XX = UBound(Nuc02, 2)
        StepPos = MakeSC02(x, Y, UBound(Nuc02, 1), UBound(ISeq02, 1), ISeq02(0, 0), SeqCompressor02(0, 0, 0, 0, 0, 0, 0, 0, 0, 0), Nuc02(0, 0))

'        StepPos = 0
'        For Y = 1 To UBound(Nuc02, 1) - 10 Step 10
'            StepPos = StepPos + 1
'            A = Nuc02(Y, X) '0,0
'            B = Nuc02(Y + 1, X) '0,1
'            C = Nuc02(Y + 2, X) '0,0
'            D = Nuc02(Y + 3, X) '1,1
'            E = Nuc02(Y + 4, X) '0,0
'            F = Nuc02(Y + 5, X) '1,0
'            G = Nuc02(Y + 6, X) '0,0
'            H = Nuc02(Y + 7, X) '1,0
'            I = Nuc02(Y + 8, X) '0,0
'            J = Nuc02(Y + 9, X) '1,0
'            ISeq02(StepPos, X) = SeqCompressor02(A, B, C, D, E, F, G, H, I, J)
'        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        e = 0
        F = 0
        g = 0
        H = 0
        i = 0
        j = 0
        
        If Y <= UBound(Nuc02, 1) Then
            A = Nuc02(Y, x)
            If Y + 1 <= UBound(Nuc02, 1) Then
                b = Nuc02(Y + 1, x)
                If Y + 2 <= UBound(Nuc02, 1) Then
                    C = Nuc02(Y + 2, x)
                    If Y + 3 <= UBound(Nuc02, 1) Then
                        D = Nuc02(Y + 3, x)
                        If Y + 4 <= UBound(Nuc02, 1) Then
                            e = Nuc02(Y + 4, x)
                            If Y + 5 <= UBound(Nuc02, 1) Then
                                F = Nuc02(Y + 5, x)
                                If Y + 6 <= UBound(Nuc02, 1) Then
                                    g = Nuc02(Y + 6, x)
                                    If Y + 7 <= UBound(Nuc02, 1) Then
                                        H = Nuc02(Y + 7, x)
                                        If Y + 8 <= UBound(Nuc02, 1) Then
                                            i = Nuc02(Y + 8, x)
                                            If Y + 9 <= UBound(Nuc02, 1) Then
                                                j = Nuc02(Y + 9, x)
                                            
                                            End If
                                        
                                        End If
                                   
                                    End If
                                
                                End If
                                
                            
                            End If
                        
                        End If
                    
                    End If
               
                End If
            
            End If
        End If
        ISeq02(StepPos, x) = SeqCompressor02(A, b, C, D, e, F, g, H, i, j)
   ' End If
Next x
'EE = Abs(GetTickCount)
'TT = EE - SS '0.000 for 3800
'X = X
''1.014 for 3200 seqs

'4.478 for 1700 sequences'7.143 for 3200 sequences'4.4  3200 seqs
Dim TValid As Long, TDiffs As Long
'XX = UBound(Nuc11, 1)
'XX = UBound(Nuc02, 1)
'XX = UBound(Nuc12, 1)
'XX = UBound(Nuc03, 1)
'XX = UBound(Nuc13, 1)
'XX = UBound(Nuc04, 1)
'XX = UBound(Nuc14, 1)
'SS2 = Abs(GetTickCount)
Dim Upper As Double
Udst = 0
Dim TargetVal As Long, DoneNum As Long
DoneNum = 0
TargetVal = NextNo * (NextNo + 1) / 2
'
'SS = Abs(GetTickCount)
'XX = SeqCatCount
Dim ExtraValids As Long
ExtraValids = 0
'XX = UBound(Decompress, 1)
If Len(StrainSeq(0)) <> Decompress(Len(StrainSeq(0))) Then 'And (StartPosInAlign <> 1 Or EndPosInAlign <> Len(StrainSeq(0))) Then
    If StartPosInAlign < EndPosInAlign Then
        '@'@'@'@
        For x = Decompress(StartPosInAlign) To Decompress(EndPosInAlign)
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
    Else
        For x = Decompress(StartPosInAlign) To Decompress(Len(StrainSeq(0)))
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
        For x = 1 To Decompress(EndPosInAlign)
            If ABCons(x) > 0 Then
                ExtraValids = ExtraValids + 1
            End If
        Next x
    End If
    SeqCatCount(0, 1) = SeqCatCount(0, 1) + ExtraValids
End If

'EE = Abs(GetTickCount)
'TT = EE - SS '0.000 for 3800
'X = X
'SS = Abs(GetTickCount)
'0.702 seconds and 6.9 seconds Urmillas event 1
SS = Abs(GetTickCount)
If ShowProg = 1 And x = x Then
    '@'@'@'@'@'@'@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'&'&'&'&'&'&'&'&'&'&'&'&
    Udst = SuperDistP2(0, NextNo, UBound(ISeq14, 1), UBound(ISeq04, 1), UBound(ISeq13, 1), UBound(ISeq03, 1), UBound(ISeq12, 1), UBound(ISeq02, 1), UBound(ISeq11, 1), AvDst, PermDIffs(0, 0), PermValid(0, 0), Distance(0, 0), tRedoDist(0), SeqCatCount(0, 0), ISeq14(0, 0), ISeq04(0, 0), ISeq13(0, 0), ISeq03(0, 0), ISeq12(0, 0), ISeq02(0, 0), ISeq11(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0), CompressValid13(0, 0), CompressDiffs13(0, 0), CompressValid12(0, 0), CompressDiffs12(0, 0), CompressValid11(0, 0), CompressDiffs11(0, 0), CompressDiffs04(0, 0), CompressDiffs03(0, 0), CompressDiffs02(0, 0))
     x = x
Else

    AvDst = 0
    For x = 0 To NextNo - 1
        
        If x = x Then
            '@,@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
            Upper = SuperDistP(x, NextNo, UBound(ISeq14, 1), UBound(ISeq04, 1), UBound(ISeq13, 1), UBound(ISeq03, 1), UBound(ISeq12, 1), UBound(ISeq02, 1), UBound(ISeq11, 1), AvDst, PermDIffs(0, 0), PermValid(0, 0), Distance(0, 0), tRedoDist(0), SeqCatCount(0, 0), ISeq14(0, 0), ISeq04(0, 0), ISeq13(0, 0), ISeq03(0, 0), ISeq12(0, 0), ISeq02(0, 0), ISeq11(0, 0), CompressValid14(0, 0), CompressDiffs14(0, 0), CompressValid13(0, 0), CompressDiffs13(0, 0), CompressValid12(0, 0), CompressDiffs12(0, 0), CompressValid11(0, 0), CompressDiffs11(0, 0), CompressDiffs04(0, 0), CompressDiffs03(0, 0), CompressDiffs02(0, 0))
            
            If Udst < Upper Then Udst = Upper
        Else
            For Y = x + 1 To NextNo
                TValid = 0
                TDiffs = 0
                '14
                For Z = 1 To UBound(ISeq14, 1)
                    TValid = TValid + CompressValid14(ISeq14(Z, x), ISeq14(Z, Y))
                    TDiffs = TDiffs + CompressDiffs14(ISeq14(Z, x), ISeq14(Z, Y))
                Next Z
               'XX = CompressValid(ISeq14(Z, X), ISeq14(Z, Y))
               ' XX = CompressDiffs(ISeq14(Z, X), ISeq14(Z, Y))
                '4,1
                '3,3
                For Z = 1 To UBound(ISeq13, 1)
                    TValid = TValid + CompressValid13(ISeq13(Z, x), ISeq13(Z, Y))
                    TDiffs = TDiffs + CompressDiffs13(ISeq13(Z, x), ISeq13(Z, Y))
                Next Z
                '04
                '19,10
                '19,15
                For Z = 1 To UBound(ISeq04, 1)
                    
                    TDiffs = TDiffs + CompressDiffs04(ISeq04(Z, x), ISeq04(Z, Y))
                Next Z
                TValid = TValid + SeqCatCount(0, 4)
                '12
                
                '635,932
                '744,932
                For Z = 1 To UBound(ISeq12, 1)
                    TValid = TValid + CompressValid12(ISeq12(Z, x), ISeq12(Z, Y))
                    TDiffs = TDiffs + CompressDiffs12(ISeq12(Z, x), ISeq12(Z, Y))
                Next Z
                '03
                For Z = 1 To UBound(ISeq03, 1)
                    'tValid = tValid + CompressValid03(ISeq03(Z, X), ISeq03(Z, Y))
                    TDiffs = TDiffs + CompressDiffs03(ISeq03(Z, x), ISeq03(Z, Y))
                Next Z
                TValid = TValid + SeqCatCount(0, 3)
                '11
                For Z = 1 To UBound(ISeq11, 1)
                    TValid = TValid + CompressValid11(ISeq11(Z, x), ISeq11(Z, Y))
                    TDiffs = TDiffs + CompressDiffs11(ISeq11(Z, x), ISeq11(Z, Y))
                     
                Next Z
                '02
                For Z = 1 To UBound(ISeq02, 1)
                    'tValid = tValid + CompressValid02(ISeq02(Z, X), ISeq02(Z, Y))
                    TDiffs = TDiffs + CompressDiffs02(ISeq02(Z, x), ISeq02(Z, Y))
                   
                Next Z
                TValid = TValid + SeqCatCount(0, 2)
                TValid = TValid + SeqCatCount(0, 1)
                
                
                
                
                
                
                PermValid(x, Y) = TValid
                PermValid(Y, x) = TValid
                PermDIffs(Y, x) = TDiffs
                PermDIffs(x, Y) = TDiffs
                
              
                
            Next Y
        End If
        
        DoneNum = DoneNum + (NextNo) - x
        If ShowProg = 0 Then
            SSSS = Abs(GetTickCount)
            If Abs(SSSS - GlobalTimer) > 500 Then
                GlobalTimer = SSSS
                 '
                If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated"
                'Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated "
                ' '
                'Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                'if Abs(ssss - llll) > 500
                'Form1.SetFocus
                
                
                LLLL = SSSS
                'DoEvents
            End If
        End If
    Next x
End If

If ShowProg = 0 Then
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        If CurrentlyRunningFlag = 0 Then Form1.SSPanel1.Caption = Str(DoneNum) + " of " + Trim(Str(TargetVal)) + " pairwise distances calculated"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    End If
End If
'DoEvents


'686.092
'48.09 in c++
'39.531 without updating every cycle
'EE = Abs(GetTickCount)
'TT = EE - SS '34.968 vs 12.250 with superdistp'14.334 with "critical" section to increase consistency
''46.036 for 3200 seqs
'X = X
'3.5 seconds and 6.957 seconds Urmillas event 1'3.3 seconds, 4.228; 3.3 for first 3.29 for second
'3.510 seconds and 5.960 seconds Urmillas event 1 with makeseqcatcount
End Sub
Public Sub FastDistanceCalcX(StoreFlag, StartPosInAlign, EndPosInAlign, NextNo As Long, PermDIffs() As Single, PermValid() As Single, SeqNum() As Integer, Distance() As Single, AvDst As Double, Udst As Double, tRedoDist() As Integer)

Dim D As Byte, W As Byte, NumSeq() As Byte, ConvNumSeq(255) As Byte

Dim A As Long, b As Long, Offset As Long
Position = -1
SS = Abs(GetTickCount)


'0=-
'1=A
'2=C
'3=G
'4=t
SS = Abs(GetTickCount)
If StartPosInAlign <= EndPosInAlign Then
    ReDim NumSeq(EndPosInAlign - StartPosInAlign + 1, NextNo)
Else
    ReDim NumSeq(EndPosInAlign + (Len(StrainSeq(0)) - StartPosInAlign + 1), NextNo)
End If
If x = x Then
    Dummy = MakeNumSeq(NextNo, Len(StrainSeq(0)), UBound(NumSeq, 1), StartPosInAlign, EndPosInAlign, ConvNumSeq(0), SeqNum(0, 0), NumSeq(0, 0))

Else
    
    'convert the sequences into a 0 to 4 string
    ConvNumSeq(66) = 1
    ConvNumSeq(68) = 2
    ConvNumSeq(72) = 3
    ConvNumSeq(85) = 4
    For x = 0 To NextNo
        If StartPosInAlign < EndPosInAlign Then
            For Y = StartPosInAlign To EndPosInAlign
                NumSeq(Y - StartPosInAlign + 1, x) = ConvNumSeq(SeqNum(Y, x))
            Next Y
        Else
            For Y = StartPosInAlign To Len(StrainSeq(0))
                NumSeq(Y - StartPosInAlign + 1, x) = ConvNumSeq(SeqNum(Y, x))
            Next Y
            Offset = Len(StrainSeq(0)) - StartPosInAlign + 1
            For Y = 1 To EndPosInAlign
                NumSeq(Y + Offset, x) = ConvNumSeq(SeqNum(Y, x))
            Next Y
        End If
    Next x
End If
EE = Abs(GetTickCount)
TT = EE - SS
x = x
'0.5 seconds with 1200 3kb sequences, 0.031 with nextno = 4715 and slen = 4965





'0.2 seconds with 1200 3kb sequences
SS = Abs(GetTickCount)



'porting this to c++ will cut execution time down by ~5%
ReDim ISeq4(CLng(UBound(NumSeq, 1) / 4) + 1, NextNo)
'compress the alignment

'XX = UBound(ISeq4, 1)
If x = x Then
    Dummy = MakeISeq4(NextNo, UBound(NumSeq, 1), UBound(ISeq4, 1), SeqCompressor4(0, 0, 0, 0), ISeq4(0, 0), NumSeq(0, 0))

Else
    Dim StepPos As Long
    
    For x = 0 To NextNo
        StepPos = 0
        
        For Y = 1 To UBound(NumSeq, 1) - 4 Step 4
            StepPos = StepPos + 1
            A = NumSeq(Y, x)
            b = NumSeq(Y + 1, x)
            C = NumSeq(Y + 2, x)
            D = NumSeq(Y + 3, x)
            ISeq4(StepPos, x) = SeqCompressor4(A, b, C, D)
        Next Y
        StepPos = StepPos + 1
        A = 0
        b = 0
        C = 0
        D = 0
        If Y <= UBound(NumSeq, 1) Then
            A = NumSeq(Y, x)
            If Y + 1 <= UBound(NumSeq, 1) Then
                b = NumSeq(Y + 1, x)
                If Y + 2 <= UBound(NumSeq, 1) Then
                    C = NumSeq(Y + 2, x)
                    If Y + 3 <= UBound(NumSeq, 1) Then
                        D = NumSeq(Y + 3, x)
                    End If
                End If
            End If
        End If
        ISeq4(StepPos, x) = SeqCompressor4(A, b, C, D)
    Next x
End If

If StoreFlag = 1 And x = 12345 Then
    UB1 = UBound(ISeq4, 1)
    UB2 = UBound(ISeq4, 2)
    ReDim ISeq4P(UB1, UB2)
    For x = 0 To UB1
        For Y = 0 To UB2
            ISeq4P(x, Y) = ISeq4(x, Y)
        Next Y
    Next x
End If


Dim DistCheckA() As Double, DistCheckB() As Double

EE = Abs(GetTickCount)
TT = EE - SS
SS = Abs(GetTickCount) 'EE - SS
'0.5 seconds with 1200 sequences
'0.031 with nextno = 4715 and slen = 4965
'ReDim DistCheckA(Nextno, Nextno)
'ReDim DistCheckB(Nextno, Nextno)
Dim VV As Byte, DV As Byte, dX As Double

EE = Abs(GetTickCount)
TT = EE - SS
    
   
    UBX = UBound(ISeq4)
    Dim XCVal() As Integer
    ReDim XCVal(UBX)
    
       
    SS = Abs(GetTickCount)
    'Dim tRedoDist() As Integer
    'ReDim tRedoDist(Nextno)
    'all of this has to be done in the calling routine
    
    'For X = 0 To nextno
    '    If tRedoDist(X) = 1 Then
     '       X = X
    ''    End If
    'Next X
    SS = Abs(GetTickCount)
    Udst = FastSimilarityA(UBound(ISeq4, 1), NextNo, UBX, AvDst, PermDIffs(0, 0), PermValid(0, 0), XCVal(0), ISeq4(0, 0), CompressValid4(0, 0), CompressDiffs4(0, 0), Distance(0, 0), tRedoDist(0))
    EE = Abs(GetTickCount)
    TT = EE - SS
    '63.383
    x = x
    'all of this must be done in the calling routine

    
    x = x
    
    '18(132)
    Erase ISeq4
    Erase NumSeq
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    
    x = x '' X '67937 on 903 sequences'51259 using a nnd b, 50672 - not querying ubound every time,43875 45406 - only adding to diffs when b <> c' 55.105 with a as the outside loop
'35.407 - withxcval 3.844 with fastdista, 3.453-with ints rather than doubles
'12.5 seconds with 1200 3kb sequences
'62.010 with nextno = 4715 and slen = 4965


End Sub
Public Sub FastBootDistB(DoFirst, Reps, NextNo As Long, LenSeq As Long, Diffs() As Single, Valid() As Single, WeightMod() As Long, SeqNum() As Integer, Distance() As Single)
'Declare FastBootDist(ByVal DoFirst As Long, ByVal Reps As Long, ByVal Nextno As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double
'Dummy = FastBootDist(0, TBSReps, Nextno, LSx, DiffsX(0), ValidX(0), WeightMod(0, 0), ETSeqNum(0, 0), DstMat(0, 0, 0))
'dofirst refers to the first replicate (which is the actual sequence and not a bootstrap sample)
Dim D As Byte, W As Byte, NumSeq() As Byte, ConvNumSeq(255) As Byte

Dim A As Long, b As Long, Offset As Long
Position = -1
SS = Abs(GetTickCount)

StartPosInAlign = 1
EndPosInAlign = LenSeq

'0=-
'1=A
'2=C
'3=G
'4=t


ReDim NumSeq(LenSeq, NextNo)


Dummy = MakeNumSeq(NextNo, LenSeq, UBound(NumSeq, 1), StartPosInAlign, EndPosInAlign, ConvNumSeq(0), SeqNum(0, 0), NumSeq(0, 0))


ReDim ISeq4(CLng(UBound(NumSeq, 1) / 4) + 1, NextNo)
'compress the alignment
Dummy = MakeISeq4(NextNo, UBound(NumSeq, 1), UBound(ISeq4, 1), SeqCompressor4(0, 0, 0, 0), ISeq4(0, 0), NumSeq(0, 0))

'Dim DistCheckA() As Double, DistCheckB() As Double


Dim VV As Byte, DV As Byte, dX As Double


    UBX = UBound(ISeq4)
    Dim XCVal() As Integer
    ReDim XCVal(UBX)
    
       
    
    'Dim tRedoDist() As Integer
    'ReDim tRedoDist(Nextno)
    'all of this has to be done in the calling routine

 '   If DebuggingFlag < 2 Then On Error Resume Next
    Dummy = FastSimilarityBP(DoFirst, Reps, UBound(ISeq4, 1), NextNo, UBX, Valid(0), Diffs(0), XCVal(0), ISeq4(0, 0), CompressValid4(0, 0), CompressDiffs4(0, 0), Distance(0, 0, 0), WeightMod(0, 0))
    ' FastSimilarityB(       int df, int reps, int ISDim, int Nextno, int UBX,float *Valid, float *Diffs, short int *XCVal, short int *IntegerSeq, unsigned char *CompressValid, unsigned char *CompressDiffs, float *DistCheckB, int *weightmod)
 '   On Error GoTo 0



    'all of this must be done in the calling routine
'
    
    x = x
    
    '18(132)
    
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    
    x = x '' X '67937 on 903 sequences'51259 using a nnd b, 50672 - not querying ubound every time,43875 45406 - only adding to diffs when b <> c' 55.105 with a as the outside loop
'35.407 - withxcval 3.844 with fastdista, 3.453-with ints rather than doubles
'12.5 seconds with 1200 3kb sequences
'62.010 with nextno = 4715 and slen = 4965


End Sub


Public Sub NJTree2(NJF As Integer)
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
    
    Dim FString As String, TName As String, TreeString2 As String, Boots() As String, Getstring As String, BootName As String, Header As String, oDir As String, TString As String, ScaleVal As String
    Dim NodeFind() As Byte
    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, NameXPos() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim ScaleValD As Double, tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, ColTotals() As Single
    
    Dim DoneLine() As Byte, OrderArray() As Byte, SHolder() As Byte, Treebyte() As Byte
    
    Dim NHFlag As Integer, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NameLen As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer, FF As Integer, Scratch() As Integer, bttSeqNum() As Integer
    
    Dim YCnt As Long, LS As Long, oReps As Long, A As Long, b As Long, NLen As Long, PNodeStr() As Long, LSeq As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Cnt As Long, SP As Long, DEN() As Long, LTree As Long, NumberOfSeqs As Long
    
   
   'Work out sequence coverage (used later when shading branches on trees)
   Dim CS As Long, Gaps As Long, Fullbit As Long
    
   CurrentlyRunningFlag = 1
    
    LS = TSeqLen
    GlobalMemoryStatus MemSit

    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    oReps = TBSReps
    'TBSReps = 100
    
'    If XX = 12345 Then
'
'        tls = LS * 36
'
'        If (TBSReps * tls) > APhys Then
'            If NJF = 1 Or NJF = 2 Then
'
'                TBSReps = APhys / (LS * 36)
'                If TBSReps > 4 Then
'                    MsgBox ("You have specified that you would like to make a tree with " + Trim(Str(oReps)) + " bootstrap replicates. Your computer only has enough free memory available to draw the tree with " + Trim(Str(TBSReps)) + " bootstrap replicates.")
'                Else
'                    MsgBox ("You have specified that you would like to make a tree with " + Trim(Str(oReps)) + " bootstrap replicates. Unfortunately your computer doesn't have enough available free memory to draw a tree with any.")
'
'                    TBSReps = 0
'                End If
'            End If
'        End If
'    End If
    Form2.SSPanel1(0).Enabled = False
    Form2.SSPanel1(1).Enabled = False
    Form2.SSPanel1(2).Enabled = False
    Form2.SSPanel1(3).Enabled = False
    
    SS = Abs(GetTickCount)
    If TBSReps < 1 Then TBSReps = 1
    
    If NextNo = -1 Then
        Erase ETSeqNum
        CurrentlyRunningFlag = 0
        Exit Sub
    End If
    ReDim PNodeStr(NextNo * 2)
    ReDim DLen(NextNo)
    LSeq = TSeqLen


    Call GetNHFlag(F2TreeIndex, NJF, NHFlag)
    

    NumberOfSeqs = NextNo

    If TBSReps = 0 And ((NJF = 1 And F2TreeIndex <> 3) Or NJF = 2) Then
    
        Form1.ProgressBar1.Value = 10
        Call UpdateF2Prog
    ElseIf NJF <> 0 Then
        Form1.ProgressBar1.Value = 5
        Call UpdateF2Prog
    Else
        If BusyWithTreeFlag = 0 Then
            Form1.ProgressBar1.Value = 5
            Call UpdateF2Prog
        End If
    End If

    Form2.Command2.Enabled = True
    'Sort out directory locations
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    Dim CycleFlag As Long
    CycleFlag = 0
RedoRaxML:   'step backin if raxmlerror
    
    'Clean up files
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    KillFile "infile_phyml_boot_trees.txt"
    KillFile "RAxML_info.treefile"
    KillFile "RAxML_parsimonyTree.treefile"
    KillFile "RAxML_log.treefile"
    KillFile "RAxML_result.treefile"
    KillFile "RAxML_bestTree.treefile"
    KillFile "RAxML_bootstrap.treefile"
    On Error GoTo 0
    ReDim Boots(NextNo + 2)
    'Set up copies of sequences that can be edited and rearranged etc
    NumberOfSeqs = NextNo
    'Set up batch files

    
    If NJF = 3 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then  '3 = ML trees, 0 = fast NJ
        If DebuggingFlag < 2 Then On Error Resume Next
        Randomize
        KillFile "dnadist.bat"
        KillFile "treefile"
        
        '
        
        If Dir("dnadist.bat") <> "" Then 'this means that for some reason the file did not get deleted - we need to use another name for it
            
            FString = "dnadist" & Trim(Str(Rnd)) & ".bat"
            FLen = FileLen("dnadist.bat")
        Else
            FString = "dnadist.bat"
            FLen = 0
        End If
        'On Error GoTo 0
        
        
        Open FString For Output As #1
        If x = 12345 Then
            'old code for fastdnaml shelling
            Print #1, "fastdnaml <infile"
            'Print #1, "fastdnaml <optfile"
            'Print #1, "dnaml <optfile"
            Print #1, "del treefile"
            Print #1, "rename treefile.0 treefile "
            
            
            
        Else
            If NJF = 3 Or (NJF = 1 And F2TreeIndex = 3) Then
                
                If ModelTestFlag = 1 And BSTreeStrat <> 4 And BSTreeStrat <> 5 Then
                    Call ModelTestPHYML
                ElseIf ModelTestFlag = 2 And BSTreeStrat <> 4 And BSTreeStrat <> 5 Then
                    Call ModelTestPHYML3
                End If
                'phyml seqs1 0 i 2 0 HKY 4.0 e 1 1.0 BIONJ y y
                'sequences file, data type, sequence format, nb data sets, nb bootstrapped data sets,
                'substitution model, ts/tv ratio , prop. invariable sites, nb categories gamma parameter, starting tree,
                'optimise topology, optimise branch lengths and rate parameters
              
              
                If BSTreeStrat < 3 Then 'phyml3 command
                    OutString = ""
                    OutString = "PhyML_3.0_win32.exe -i infile "
                    
                    'BSupTest = -1
                    If BSupTest = 0 And TBSReps <= 1 Then
                      OutString = OutString + " -b 0"
                    ElseIf BSupTest = 0 Then  'had to do this because bs reps are nort working in my version of phyml3
                      OutString = OutString + " -b " + Trim(Str(TBSReps))
                    ElseIf BSupTest = 1 Then  'approximate lr test returning aLRT stats
                      OutString = OutString + " -b -1"
                    ElseIf BSupTest = 2 Then   'approximate lr test returning chi square based stats
                      OutString = OutString + " -b -2"
                    ElseIf BSupTest = 3 Then 'sh-like branch support test
                      OutString = OutString + " -b -3"
                    End If
                    'Substitution model
                    If TPModel = 0 Then
                          OutString = OutString + " -m JC69"
                    ElseIf TPModel = 1 Then
                          OutString = OutString + " -m K80"
                    ElseIf TPModel = 6 Then
                          OutString = OutString + " -m HKY85"
                    ElseIf TPModel = 2 Then
                          OutString = OutString + " -m F81"
                    ElseIf TPModel = 3 Then
                          OutString = OutString + " -m F84"
                    ElseIf TPModel = 4 Then
                          OutString = OutString + " -m TN93"
                    ElseIf TPModel = 5 Then
                          OutString = OutString + " -m GTR"
                    End If
                    'tvrat
                    If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
                          If TPTVRat > 0 Then
                                OutString = OutString + " -t " + Trim(Str(TPTVRat * 2))
                          Else
                                OutString = OutString + "-t e "
                          End If
                    ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
                      OutString = OutString + "-t 1.0"
                    End If
                    
                    'proportion invariable sites
                    If TPInvSites < 1 Then
                      OutString = OutString + " -v " + Trim(Str(TPInvSites))
                    Else
                      OutString = OutString + " -v e "
                    End If
                    
                    'number rate categories
                     OutString = OutString + " - c " + Trim(Str(TPGamma))
                    'gamma correction
                     'If TPGamma > 1 Then
                    If TPAlpha = 0 Then
                        OutString = OutString + " -a e " ' " 1.0"
                    Else
                        OutString = OutString + " -a " + Trim(Str(TPAlpha))
                    End If
                    'BSTreeStrat = 0
                    If BSTreeStrat = 0 Then
                        OutString = OutString + " -s NNI "
                    ElseIf BSTreeStrat = 1 Then
                        OutString = OutString + " -s SPR "
                    ElseIf BSTreeStrat = 2 Then
                        OutString = OutString + " -s BEST "
                    End If
                    x = x
                    'Open "testbat.bat" For Output As #2
                    'Print #2, OutString
                    ''Close #2
                    OutString = OutString + " --no_memory_check"
                    Print #1, OutString
                    'Print #1, "del treefile"
                    Print #1, "rename infile_phyml_tree.txt treefile "
                    BatIndex = 7
                ElseIf BSTreeStrat = 3 Then 'phyml1 command
                    OutString = ""
                    OutString = "phyml_win32.exe infile 0 s 1"
                    ' BS reps
                    If TBSReps <= 1 Then
                      OutString = OutString + " 0"
                    Else
                      OutString = OutString + " " + Trim(Str(TBSReps))
                    End If
                    'Substitution model
                    If TPModel = 0 Then
                          OutString = OutString + " K2P"
                    ElseIf TPModel = 1 Then
                          OutString = OutString + " K2P"
                    ElseIf TPModel = 6 Then
                          OutString = OutString + " HKY"
                    ElseIf TPModel = 2 Then
                          OutString = OutString + " F81"
                    ElseIf TPModel = 3 Then
                          OutString = OutString + " F84"
                    ElseIf TPModel = 4 Then
                          OutString = OutString + " TN93"
                    ElseIf TPModel = 5 Then
                          OutString = OutString + " GTR"
                    End If
                    'tvrat
                    If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
                          If TPTVRat > 0 Then
                                OutString = OutString + Str(TPTVRat * 2)
                          Else
                                OutString = OutString + " e"
                          End If
                    ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
                      OutString = OutString + " 1.0"
                    End If
                    'proportion invariable sites
                    If TPInvSites < 1 Then
                      OutString = OutString + Str(TPInvSites)
                    Else
                      OutString = OutString + " e"
                    End If
                    'number rate categories
                     OutString = OutString + Str(TPGamma)
                    'gamma correction
                     'If TPGamma > 1 Then
                          If TPAlpha = 0 Then
                              OutString = OutString + " e" ' " 1.0"
                          Else
                              OutString = OutString + Str(TPAlpha)
                          End If
                     'End If
                    'starting tree
                    OutString = OutString + " BIONJ y y"
                    Print #1, OutString
                    Print #1, "del treefile"
                    Print #1, "rename infile_phyml_tree.txt treefile "
                    BatIndex = 7
                ElseIf BSTreeStrat = 5 Then 'fasttree command
                    
                    'Outstring = "FastTree -nt -nome -noml -boot 50 -fastest infile > treefile" 'This is the fastNJ option
                    OutString = "FastTree -pseudo -gtr -seed " + Trim(Str(BSRndNumSeed)) + " -nt infile > treefile" '-nosupport-pseudo
                    'BatIndex = 65
                    PrF = 7
                    Print #1, OutString
                ElseIf BSTreeStrat = 4 Then 'raxml command
                    Dim SysInfo As SYSTEM_INFO
                    
                    GetSystemInfo SysInfo
                    Dim Outstring2 As String
                    OutString = ""
                    Dim NumProc As Long
                    NumProc = SysInfo.dwNumberOrfProcessors
                    If NumProc > 4 Then NumProc = 4
                    If NumProc > 1 And CycleFlag = 0 Then  'for some reason pthreads crashes/does not give a tree
                        OutString = "raxmlHPC-PTHREADS -s infile -p 123 -n treefile -m GTRCAT -T " + Trim(Str(NumProc))
                    Else
                        OutString = "raxmlHPC -s infile -p 123 -n treefile -m GTRCAT"
                    End If
                    XX = TPGamma
                    
                    'If RAxMLCats <> 25 Or X = X Then
                    '    Outstring = Outstring + " - c " + Trim(Str(RAxMLCats))
                    'End If
                    
                    ' BS reps
                    If TBSReps > 1 Then
                      
                      Outstring2 = OutString + " -x " + Trim(Str(BSRndNumSeed)) + " -N " + Trim(Str(TBSReps))
                    End If
                    'Substitution model
                    
                    
                    Print #1, OutString
                    If TBSReps > 1 Then
                       
                        Print #1, "del RAxML_info.treefile"
                        Print #1, "del RAxML_parsimonyTree.treefile"
                        Print #1, "del RAxML_log.treefile"
                        Print #1, "del RAxML_result.treefile"
                        'killfile "RAxML_bestTree.treefile"
                        'killfile "RAxML_bootstrap.treefile"
                        Print #1, Outstring2
                    End If
                    Print #1, "del treefile"
                    Print #1, "del infile"
                    If TBSReps > 1 Then
                        'RAxML_bootstrap.treefile
                        
                        Print #1, "rename RAxML_bootstrap.treefile infile"
                        Print #1, "rename RAxML_bestTree.treefile treefile"
                    Else
                        'Print #1, "rename RAxML_fastTree.treefile treefile"
                        Print #1, "rename RAxML_bestTree.treefile treefile"
                    
                    End If
                    BatIndex = 53
                End If   '
             
            ElseIf NJF = 0 Then
                If PseudoFlag = 1 Then
                    OutString = "FastTree -nt -nome -noml -boot 50 -fastest -pseudo infile > treefile" 'This is the fastNJ option
                Else
                    OutString = "FastTree -nt -nome -noml -boot 50 -fastest infile > treefile" 'This is the fastNJ option
                End If
                PrF = 8
                Print #1, OutString
            End If
        End If
        Close #1
        
        On Error GoTo 0
    ElseIf NJF = 4 Then 'Bayesian trees
          Dim FLX As Long
          If DebuggingFlag < 2 Then On Error Resume Next
          KillFile "boptout"
          FLX = 0
          
          If Dir("boptout") <> "" Then
                FLX = FileLen("boptout")
                Response = MsgBox("MrBayes is still running in the background.  If you press the CTL,ALT & DEL keys all at the same time the TaskManager will pop up and you will be able to shut MrBayes down manually.  On the 'Processes' tab find 'MrBayes' in the program list, click on it and then press the 'End Process' button on the bottom right.", 48)
                KillFile "boptout"
                FLX = 0
                FLX = FileLen("boptout")
                If FLX > 0 Then
                    AbortFlag = 1
                    Form2.SSPanel1(0).Enabled = True
                    Form2.SSPanel1(1).Enabled = True
                    Form2.SSPanel1(2).Enabled = True
                    Form2.SSPanel1(3).Enabled = True
                    oReps = TBSReps
                    TBSReps = oReps
                    Erase ETSeqNum
                    CurrentlyRunningFlag = 0
                    Exit Sub
                End If
          End If
          'Exit Sub
          On Error GoTo 0
          
          
            If DebuggingFlag < 2 Then On Error Resume Next
            Randomize
            KillFile "dnadist.bat"
            FLen = 0
            
            
            
            If Dir("dnadist.bat") <> "" Then 'this means that for some reason the file did not get deleted - we need to use another name for it
                
                FString = "dnadist" & Trim(Str(Rnd)) & ".bat"
            Else
                FString = "dnadist.bat"
            End If
            Open FString For Output As #1
          'write commandline
          
          Print #1, "mrbayes.exe <bopt >boptout"
          Print #1, "del treefile"
          Print #1, "rename outfile.con treefile "
          Close #1
          On Error GoTo 0
          'Write the options file later
          
    
    End If
    
    If (NJF = 1 Or NJF = 2 Or (NJF = 3 And TBSReps > 1 And BSTreeStrat = 4) Or (NJF = 1 And F2TreeIndex = 3)) And TBSReps > 2 Then
        
        Call MakeConsenseFiles(NextNo)
        
    End If
    'Work out branch lengths
    
    
    
    
    
    If NJF = 3 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
        'Do FastDNAML options file
        If BSTreeStrat = 5 Or NJF = 0 Then 'fasttree takes a fasta file
            Open "infile" For Output As #1
            NLen = Len(Trim(Str(NumberOfSeqs)))
            If NLen = 1 Then NLen = 2
            'XX = Len(TempSeq(0))
            For x = 0 To NumberOfSeqs
                
                TName = Trim$(CStr(x))
                TName = String(NLen - Len(TName), "0") & TName
                TName = "S" & TName
                Print #1, ">" + Trim(TName)
                TString = TempSeq(x)
                Print #1, TString
            Next 'X
    
            'Set up the initial infile
            Close #1
            
        Else
            If Len(TempSeq(0)) > 100000 Then
                
               Dim TS2() As String, MyVa As Long
               ReDim TS2(NextNo)
               For x = 0 To NextNo
                    TS2(x) = TempSeq(x)
                    TempSeq(x) = String(100000, " ")
               Next x
                Rnd (-BSRndNumSeed)
                
                For x = 1 To 100000
                    MyVa = CLng(((Len(StrainSeq(0))) * Rnd) + 0.5)  '
                    For Y = 0 To NextNo
                        Mid(TempSeq(Y), x, 1) = Mid$(TS2(Y), MyVa, 1)
                    Next Y
                Next 'X
                Erase TS2
            End If
    
            Open "infile" For Output As #1
            Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
            
            If x = 12335 Then
                
            Else
                Print #1, Header
                
            End If
            NLen = Len(Trim(Str(NumberOfSeqs)))
            If NLen = 1 Then NLen = 2
            XX = Len(TempSeq(0))
            For x = 0 To NumberOfSeqs
                
                TName = Trim$(CStr(x))
                TName = String(NLen - Len(TName), "0") & TName
                TName = "S" & TName
                BootName = TName
                BootName = BootName + String$(10 - (Len(BootName)), " ")
                TString = TempSeq(x)
                Boots(x) = BootName + TString
                Print #1, Boots(x)
            Next 'X
    
            'Set up the initial infile
            Close #1
        End If
        
        PBStart = Form1.ProgressBar1.Value
        PBTarget = (100 - PBStart) / 4 + PBStart
        If NJF = 0 Then
            Form1.SSPanel1.Caption = "Making FastNJ tree (with FastTree)"
        ElseIf BSTreeStrat < 3 Then
            Form1.SSPanel1.Caption = "Making ML tree (with PHYML3)"
        ElseIf BSTreeStrat = 3 Then
            Form1.SSPanel1.Caption = "Making ML tree (with PHYML1)"
        ElseIf BSTreeStrat = 4 Then
            Form1.SSPanel1.Caption = "Making ML tree (with RAxML)"
        ElseIf BSTreeStrat = 5 Then
            Form1.SSPanel1.Caption = "Making ML tree (with FastTree)"
        End If
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    ElseIf NJF = 4 Then ' Sort out MrBayes infiles
        'write mrbayes options file
        Open "bopt" For Output As #1
        
        Print #1, "execute infile;"
        
        Print #1, "quit;"
        Close #1
        'Do Mr Bayes sequence file
        If Len(TempSeq(0)) > 32000 Then

            For x = 0 To NextNo
                TempSeq(x) = Left$(TempSeq(x), 32000)
            Next 'X

        End If
        'write nexus data file
        Call MrBayesInfile(NumberOfSeqs, 1, TBNGens, TBSampFreq)
    End If

    'work out sequence coverage
    ReDim SeqCoverage(NextNo)
    
    If F2TreeIndex = 1 Then
        If FubValidInFile = 1 Then
            
            '****************************
            'Better to read just single value from the file
            '*******************************
            ReDim FubValid(FVL, FVL)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5FVFile" + UFTag For Binary As #FF
            Get #FF, , FubValid
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
    
         Call MakeSeqCoverage(0, FubValid())
         If FubValidInFile = 1 Then
            
            ReDim FubValid(0, 0)
        End If
         'XX = SeqCoverage(8)
         'X = X
    ElseIf F2TreeIndex = 2 Then
'         If FubValidInFile = 1 Then
'
'            '****************************
'            'Better to read just single value from the file
'            '*******************************
''            ReDim SubValid(FVL, FVL)
'            ODirX = CurDir
'            ChDrive App.Path
'            ChDir App.Path
'            FF = FreeFile
'            Open "SVFile" For Binary As #FF
'            Get #FF, , SubValid
'            Close #FF
'            ChDrive ODirX
'            ChDir ODirX
'        End If
        Call MakeSeqCoverage(0, SubValid())
'        redim SubValid(0,0)
    ElseIf (NJF = 1 And F2TreeIndex <> 3) Or NJF = 2 Then
        For x = 0 To NextNo
        
            'XX = UBound(SeqSpaces, 1)
            Gaps = 0
            
            Fullbit = UBound(ETSeqNum, 1)
            
            For Y = 1 To Fullbit
                If ETSeqNum(Y, x) = 46 Then Gaps = Gaps + 1
            Next Y
            
            SeqCoverage(x) = (Fullbit - Gaps) / Fullbit '138,175,132,132
            x = x
            
        Next x
    Else
        For x = 0 To NextNo
        
            'XX = UBound(SeqSpaces, 1)
            Gaps = 0
            
            Fullbit = Len(TempSeq(0))
            
            For Y = 1 To Fullbit
                If Mid(TempSeq(x), Y, 1) = "-" Then Gaps = Gaps + 1
            Next Y
            
            SeqCoverage(x) = (Fullbit - Gaps) / Fullbit
            
            
        Next x
    End If




SSX = Abs(GetTickCount)
    'Calculate distance matrices
    If (NJF = 1 And F2TreeIndex <> 3) Or NJF = 2 Then
        
        Dim CycleNoY As Long, CNX As Long, LSx As Long, ETSeqNumBak() As Integer, UBX As Long, UBY As Long, OSET, TotMatC() As Single
        
        If TModel <> 3 Then
            If LS > 50000 And x = 12345 Then
                LSx = LS / 50000
                LSx = CInt(LSx)
                CycleNoY = LSx - 1
                LSx = LS / LSx
                LSx = CLng(LSx + 0.5) - 1
                UBX = UBound(ETSeqNum, 1)
                UBY = UBound(ETSeqNum, 2)
                ReDim ETSeqNumBak(UBX, UBY)
                For A = 0 To UBX
                    For b = 0 To UBY
                        ETSeqNumBak(A, b) = ETSeqNum(A, b)
                    Next b
                Next A
                ReDim ETSeqNum(LSx, UBY)
                ReDim TotMatC(TBSReps, UBY, UBY)
            Else
                CycleNoY = 0
                LSx = LS
            End If
        Else
            If LS > 32000 Then
                LSx = LS / 32000
                LSx = CInt(LSx) + 1
                CycleNoY = LSx - 1
                LSx = LS / LSx
                LSx = CLng(LSx + 0.5) - 1
                UBX = UBound(ETSeqNum, 1)
                UBY = UBound(ETSeqNum, 2)
                ReDim ETSeqNumBak(UBX, UBY)
                For A = 0 To UBX
                    For b = 0 To UBY
                        ETSeqNumBak(A, b) = ETSeqNum(A, b)
                    Next b
                Next A
                ReDim ETSeqNum(LSx, UBY)
                ReDim TotMatC(TBSReps, UBY, UBY)
            Else
                CycleNoY = 0
                LSx = LS
            End If
        
        End If
        For CNX = 0 To CycleNoY
            
            If LSx < LS Then
            
                
                OSET = CNX * LSx
                XX = OSET + LSx
                For A = 0 To LSx
                    For b = 0 To UBY
                        If OSET + A > Len(StrainSeq(0)) Then
                            C = OSET + A - Len(StrainSeq(0))
                        Else
                            C = OSET + A
                        End If
                        If C <= UBX = UBound(ETSeqNumBak, 1) Then
                            ETSeqNum(A, b) = ETSeqNumBak(C, b)
                        End If
                    Next b
                Next A
            End If
        
        
             
           
           
            ReDim WeightMod(TBSReps, LSx - 1)
            ReDim tMat(NextNo, NextNo)
            ReDim SHolder((NextNo + 1) * 40 * 2)
            ReDim Scratch(LSx)
            ReDim Alias(LSx)
            ReDim Ally(LSx)
            
            ReDim XX1(3) 'int
            ReDim XX2(3) 'int
            
            
            ReDim Weight(TBSReps, LSx) 'long
            ReDim Location(LSx) 'long
            ReDim Px(NextNo, LSx) 'int
            ReDim Prod1(LSx) 'doub
            ReDim Prod2(LSx) 'doub
            ReDim Prod3(LSx) 'doub
       
            
            
            'GlobalMemoryStatus MemSit
        
            'APhys = Abs(MemSit.dwTotalPhys)
            'If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
            'XX = NumberOfSeqs
            varsize = TBSReps
            varsize = varsize * NextNo
            varsize = varsize * NextNo
            varsize = varsize * 4
            If varsize > APhys / 8 Then
                x = x
                Dim nTBSReps As Long
                If TBSReps > 1 Then
                    nTBSReps = CLng((APhys / 8) / (NextNo * NextNo * 8))
                    Response = MsgBox("There is not enough available memory to construct this tree using " & Trim(Str(TBSReps)) & " bootstrap replicates.  There is, however, enough free memory to construct the tree with " & Trim(Str(nTBSReps)) & " replicates.  Would you like me to try with this reduced number of replicates?  If I try this there is a reasonable chance that your computer will still not have enough RAM and I will crash. You could alternatively try making a maximum likelihood tree.", vbYesNo)
                    If Response = 6 Then
                        TBSReps = nTBSReps
                    Else
                        Erase ETSeqNum
                        CurrentlyRunningFlag = 0
                        Form2.SSPanel1(0).Enabled = True
                        Form2.SSPanel1(1).Enabled = True
                        Form2.SSPanel1(2).Enabled = True
                        Form2.SSPanel1(3).Enabled = True
                        Exit Sub
                    
                        
                        
                    End If
                    
                Else
                    Response = MsgBox("There is not enough available memory to construct this tree.  You could try making a maximum likelihood tree.", vbOKOnly)
                    Erase ETSeqNum
                    CurrentlyRunningFlag = 0
                    Exit Sub
                End If
                
            End If
            
            ReDim DstMat(TBSReps, NextNo, NextNo) 'single
            ReDim DistVal(TBSReps + 1) 'double
            ReDim Num1(TBSReps + 1) 'long
            ReDim Num2(TBSReps + 1) 'long
            ReDim DEN(TBSReps + 1) 'long
            ReDim num(TBSReps + 1) ''double
            
            If TBSReps > 1 Then
                SEQBOOT2 BSRndNumSeed, TBSReps, LSx, Scratch(0), WeightMod(0, 0)
                'For X = 0 To LSX - 1
                '    If WeightMod(1, X) = 0 Then
                '        X = X
                '    End If
                'Next X
            Else
                x = x
                For x = 0 To LSx - 1
                    WeightMod(0, x) = 1
                Next x
            End If
            Dim SeqScores() As Double
            ReDim SeqScores(NextNo)
            Dim MaxDScore As Double
            MaxDScore = 0
            Dim ValidX() As Single, DiffsX() As Single
            
            If TModel <> 3 Then
                If CNX = 0 Then
                    Form1.SSPanel1.Caption = "Calculating distances"
                    
                    Form1.ProgressBar1 = 20
                    Call UpdateF2Prog
                End If
                If TModel = 0 Then
                    'For X = 0 To UBound(ETSeqNum, 1)
                    '    ETSeqNum(X, 0) = ETSeqNum(X, 0)
                    'Next X
                    ReDim ValidX(TBSReps), DiffsX(TBSReps) ', DstMat(BSBootReps, NextNo, NextNo)
'                    SS = Abs(GetTickCount)
'                    For AA = 0 To 50
                    
                   ' Dummy = FastBootDist(0, TBSReps, Nextno, LSx, DiffsX(0), ValidX(0), WeightMod(0, 0), ETSeqNum(0, 0), DstMat(0, 0, 0))

                    Dummy = FastBootDistIP(0, TBSReps, NextNo, LSx, DiffsX(0), ValidX(0), WeightMod(0, 0), ETSeqNum(0, 0), DstMat(0, 0, 0))

                    'There is soething sreiously wrong eith the IP version
                     '   Dummy = FastBootDistIP(0, TBSReps, Nextno, LSx, DiffsX(0), ValidX(0), WeightMod(0, 0), ETSeqNum(0, 0), DstMat(0, 0, 0))
'
'                    'Call FastBootDistB(0, TBSReps, Nextno, LSx, DiffsX(), ValidX(), WeightMod(), ETSeqNum(), DstMat())
'                    Next AA
'                    EE = Abs(GetTickCount)
'                    TT = EE - SS
                    '22.360 with fastbootdist
                    '19.484 with fastbootdistb
                    '11.828 dastbootdistb with fastsimilaritybp
                    '8.313 with Fastbootdistp
                    '2.469 with fastbootdistip but with mem leak
                    '4.344 with fastbootdistip corrected
                    '3.766 with dx and vx dimming outside of y-loop
                    '1.906 for 50 with fastbootdistip
                    '3.375 for 50 with fastbootdistp' 0.890 for 25 0.500
                    '7.7 for 10 reps, 7.3 for 20 reps
                    '1.641, 0.922 with release at end of
                    x = x
                
                Else
                    BootDist TBSReps, TCoeffVar, TTVRat, TModel, NextNo + 1, LSx, ETSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), num(0), WeightMod(0, 0)
                End If
                If CNX >= CycleNoY Then
                    Form1.SSPanel1.Caption = "Making trees"
                    Form1.ProgressBar1 = 60
                    Call UpdateF2Prog
                Else
                    pcx = CLng(((CNX + 1) / CycleNoY) * 100)
                    Form1.SSPanel1.Caption = Trim(Str(pcx)) + "% of distance matrices calculated"
                    Form1.ProgressBar1 = 20 + (pcx / 100) * 40
                    Call UpdateF2Prog
                
                End If
                
                For x = 0 To NextNo
                
                    For Y = 0 To NextNo
                        SeqScores(x) = SeqScores(x) + DstMat(0, x, Y)
                    Next Y
                Next x
                
                For x = 0 To NextNo
                    If SeqScores(x) > MaxDScore Then
                        Outie = x
                        MaxDScore = SeqScores(x)
                    End If
                Next x
                
            Else
                 ReDim bttSeqNum(LSx, NumberOfSeqs)
                For x = 0 To TBSReps - 1
    
                    If x > 0 Then
                        SP = 0
    
                        For Z = 1 To LSx
    
                            For A = 1 To WeightMod(x, Z - 1)
                                SP = SP + 1
    
                                For Y = 0 To NumberOfSeqs
                                    bttSeqNum(SP, Y) = ETSeqNum(Z, Y)
                                Next 'Y
    
                            Next 'A
    
                        Next 'Z
    
                    Else
    
                        For Z = 0 To LSx
    
                            For Y = 0 To NumberOfSeqs
                                bttSeqNum(Z, Y) = ETSeqNum(Z, Y)
                            Next 'Y
    
                        Next 'Z
    
                    End If
                    ReDim Weight(TBSReps, BSStepWin)
                    
                    
                    
                    Dummy = DNADIST(TCoeffVar, TTVRat, TBaseFreqFlag, TModel, TAfreq, TCFreq, TGFreq, TTFreq, NextNo + 1, LSx, bttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0))
                     
                    If CNX >= CycleNoY Then
                        Form1.SSPanel1.Caption = Str(x) & " of" & Str(TBSReps) & " matrices calculated"
                        
                        Form1.ProgressBar1 = 20 + 40 * (x / TBSReps)
                        Call UpdateF2Prog
                    Else
                        pcx = (((CNX + 1) / CycleNoY) * 100)
                        pcx = pcx + ((x / TBSReps) * (100 / CycleNoY))
                        pcx = CLng(pcx)
                        Form1.SSPanel1.Caption = Trim(Str(pcx)) + "% of distance matrices calculated"
                        Form1.ProgressBar1 = 20 + (pcx / 100) * 40
                        Call UpdateF2Prog
                    End If
                    'If RelX = 0 And RelY = 0 Then
                    
                        For Y = 0 To NumberOfSeqs - 1
                            For Z = Y + 1 To NumberOfSeqs
                                DstMat(x, Y, Z) = tMat(Y, Z)
                                DstMat(x, Z, Y) = tMat(Y, Z)
                                'AbortFlag = 1
                                'Exit Sub
                            Next 'Z
        
                        Next 'Y
                   ' Else
                   '     For Y = 0 To NumberOfSeqs - 1
                   '         For Z = Y + 1 To NumberOfSeqs
                   '             If TMat(Y, Z) > 1 Then
                   '                 TMat(Y, Z) = 1
                   '             End If
                   '             DstMat(X, Y, Z) = TMat(Y, Z)
                   '             DstMat(X, Z, Y) = TMat(Y, Z)
                   '         Next 'Z
                   '
                   '     Next 'Y
                   ' End If
    
                Next 'X
                For x = 0 To NextNo
                    For Y = 0 To NextNo
                        SeqScores(x) = SeqScores(x) + DstMat(0, x, Y)
                    Next Y
                Next x
                
                For x = 0 To NextNo
                    If SeqScores(x) > MaxDScore Then
                        MaxDScore = SeqScores(x)
                        Outie = x
                    End If
                Next x
                
            End If
            If CycleNoY > 0 Then
            
                For C = 0 To TBSReps
                    For A = 0 To UBY
                        For b = 0 To UBY
                            TotMatC(C, A, b) = TotMatC(C, A, b) + DstMat(C, A, b)
                        Next b
                    Next A
                Next C
            End If
        Next CNX
        If CycleNoY > 0 Then
            For C = 0 To TBSReps
                For A = 0 To UBY
                    For b = 0 To UBY
                        DstMat(C, A, b) = TotMatC(C, A, b) / CycleNoY
                        x = x
                    Next b
                Next A
            Next C
            
            ReDim ETSeqNum(UBX, UBY)
            For A = 0 To UBX
                For b = 0 To UBY
                    ETSeqNum(A, b) = ETSeqNumBak(A, b)
                Next b
            Next A
        End If
        
        If (NJF = 1 And F2TreeIndex <> 3) Then ' ie NJ tree
            
          ' ssx = Abs(GetTickCount)
            For x = 0 To NextNo
                For Y = x + 1 To NextNo
                    DstMat(0, x, Y) = (CLng(DstMat(0, x, Y) * 10000000)) / 10000000
                    DstMat(0, Y, x) = DstMat(0, x, Y)
                    
                Next Y
            Next x
            
            
            Dim Treestring As String, UB As Long
            UB = UBound(DstMat, 2)
            ReDim tMat(UB, UB)
            ReDim SHolder((NextNo + 1) * 40 * 2)
            Close #1
            If TBSReps > 1 Then
                Open "infile" For Output As #1
            End If
                
                
                
                'For X = 0 To NextNo
                '    For Y = X + 1 To NextNo
                '        DstMat(0, X, Y) = (CLng(DstMat(0, X, Y) * 10000000)) / 10000000
                '        DstMat(0, Y, X) = DstMat(0, X, Y)
                '        'SMat(X, Y) = (CLng(SMat(X, Y) * 10000000)) / 10000000
                '        'SMat(Y, X) = SMat(X, Y)
                '    Next Y
                'Next X
            SS = Abs(GetTickCount)
            For x = 0 To TBSReps - 1
                'DstMat(0, 0, 29) = 0.049
                If (RelX = 0 And RelY = 0) Or x > 0 Then
                    
                    Dummy = TransferDist(UB, x, TBSReps, tMat(0, 0), DstMat(0, 0, 0))
                Else
                     Dummy = TransferDist(UB, x, TBSReps, tMat(0, 0), DstMat(0, 0, 0))
                   ' For Y = 0 To NextNo - 1
                   '     For Z = Y + 1 To NextNo
                   '         If tMat(Y, Z) > 1 Then
                  '
                  '              tMat(Y, Z) = 1
                  '              tMat(Z, Y) = 1
                  '          End If
                  '      Next 'Z
                  '
                  '  Next 'Y
                End If
                
                
                
'                If x = 12345 Then
'                      Open "distmat.csv" For Output As #5
'                      XX = CurDir
'
'                      For A = 0 To TBSReps
'                         For Z = 0 To Nextno    'xxxx
'                             OS = ""
'
'                             For Y = 0 To Nextno   'xxxx
'                                 If x = x Then
'                                     OS = OS + Str(DstMat(A, Z, Y)) + ","
'                                 Else
'                                     OS = OS + " 0 ,"
'                                 End If
'                             Next Y
'                             Print #5, OS
'                         Next Z
'                         Print #5, OS
'                      Next A
'                    '  'XX = TreeTraceSeqs(1, 46)
'                      Close #5
'                      x = x
'                End If
                
                ReDim ColTotals(NextNo)
                Dim Treearray() As Single
                ReDim Treearray(NextNo, NextNo)
                'LTree = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, Nextno + 1, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                LTree = Clearcut(0, NextNo, 1, 100, BSRndNumSeed, 1, UBound(tMat, 1), tMat(0, 0), SHolder(0))
                'byte array to string
                Dim CurrentTX As Long, LastTX As Long
                CurrentTX = Abs(GetTickCount)
                If Abs(CurrentTX - LastTX) > 500 Then
                    LastTX = CurrentTX
                    'XX = TreeTraceSeqs(1, 60)'79
                    Form1.SSPanel1.Caption = Str(x) & " of " & Trim(Str(TBSReps)) & " trees drawn"
                    Form1.ProgressBar1 = 60 + 40 * (x / TBSReps)
                    Call UpdateF2Prog
                    Form2.Refresh
                    Form1.Refresh
                    DoEvents 'covered by currentlyrunningflag
                    If AbortFlag = 1 Then
                        Form2.SSPanel1(0).Enabled = True
                        Form2.SSPanel1(1).Enabled = True
                        Form2.SSPanel1(2).Enabled = True
                        Form2.SSPanel1(3).Enabled = True
                        If DebuggingFlag < 2 Then On Error Resume Next
                
                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
                        TBSReps = oReps
                        Erase ETSeqNum
                        CurrentlyRunningFlag = 0
                        Exit Sub
                    End If
                End If
                Treestring = ""
                TreeString2 = ""
                For Y = 1 To LTree
                    GoOn = 1
                    If TNegBLFlag = 0 Then
                       If SHolder(Y) = 45 Then
                            If SHolder(Y - 1) = 58 Then
                                SHolder(Y) = 48
                                'GoOn = 0
                            End If
                       End If
                    End If
                    If GoOn = 1 Then
                        Treestring = Treestring + Chr$(SHolder(Y))
                        TreeString2 = TreeString2 + Chr$(SHolder(Y))
                        
                        If Chr$(SHolder(Y)) = "(" Or Chr$(SHolder(Y)) = ")" Then
                            TreeString2 = TreeString2 + Chr(13)
                        End If
                    End If
                Next Y
                'Write to consense infile
                If TBSReps > 1 Then
                    
                    Print #1, TreeString2
                End If
                If x = 0 Then
                    Getstring = Treestring
                    NHString(NHFlag) = Getstring
                    If NHFlag = 7 Then
                        NHComp(1) = Getstring
                    ElseIf NHFlag = 10 Then
                    
                        NHComp(0) = Getstring
                    End If
                    ReDim Treebyte(LTree)
                    For Y = 1 To LTree
                        Treebyte(Y - 1) = SHolder(Y)
                    Next Y
                End If
            Next x
            
            If TBSReps > 1 Then
                Close #1
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS '2.625,2.504,2.625 10.125, 10.938, 15.969 with neighbour
                            '0.5,0.515, 0.515, 1.313, 1.328, 1.282  with clearcut NJ
                            '0.39, 0.3910.406, 0.843, 0.860  with clearcut relaxed NJ
            
            x = x
        Else
            Open "outfilex2" For Output As #1
            Open "outfilex3" For Output As #2
            For Z = 0 To TBSReps
                If Z = 0 Then
                        Print #2, "  " & CStr(NumberOfSeqs + 1)
                End If
                Print #1, "  " & CStr(NumberOfSeqs + 1)
                NLen = Len(Trim(Str(NumberOfSeqs)))
                If NLen = 1 Then NLen = 2
                For x = 0 To NumberOfSeqs
                
                    
                    TName = Trim$(CStr(x))
                    TName = String(NLen - Len(TName), "0") & TName
                    TName = "S" & TName
                    
                    OutString = TName & String$(9 - Len(TName), " ")
                    
                    For Y = 0 To NumberOfSeqs
            
                        If DstMat(Z, x, Y) = 0 Then
                            OutString = OutString & "  0.0000"
                        ElseIf DstMat(Z, x, Y) = 1 Then
                            OutString = OutString & "  1.0000"
                        ElseIf DstMat(Z, x, Y) > 1 Then
                            OutString = OutString & "  " & Int(DstMat(Z, x, Y) * 10000) / 10000 '& String$((6 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        Else
                            OutString = OutString & "  " & Int(DstMat(Z, x, Y) * 10000) / 10000 '& String$((5 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        End If
            
                    Next 'Y
                    If Z = 0 Then
                        Print #2, OutString
                    End If
                    Print #1, OutString
                Next 'X
            Next 'Z
            Close #2
            Close #1
        End If
        x = x
    Else ' MrBayes and ML shell
        'Do
        
        SSX = Abs(GetTickCount)
        If (NJF = 3 And BSTreeStrat = 5) Or NJF = 0 Then
            Dummy = GetCommandOutput(FString, PrF, True, True)
        ElseIf NJF = 3 And ((BSTreeStrat = 0 And BSupTest <> 0) Or BSTreeStrat = 1 Or BSTreeStrat = 2 Or BSTreeStrat = 3) Then
            Dummy = GetCommandOutput(FString, 14, True, True)
        Else
            ShellAndClose FString, 0
        End If
        EEE = Abs(GetTickCount)
        ttt = EEE - SSX '155891 with v 7 raxml'153 with v8, 106 with v8ss3, 59 pthreads with 3 processors, 53 pthreads with 4 processors
        '37.144 raxml-pthreads 8 laptop processors,36.458 7 processors, 39 with 6, 33 for 4, 40 with 3
        '13.8 seconds on laptop with fasttree
        '3.697 with -f E switch (but there are no branchlengths
        '4.143 with -f F switch
        'Loop
        
        eex = Abs(GetTickCount)
        TT = Abs(eex - SSX) '192'173'raxml=8873'1069
        x = x
        'With aaa.fas
        '-gtr -noml = 100.703
        '-gtr -noml -nome = 65.890
        '-gtr -noml -nome -fastest = 63.015
        '-gtr -fastest = 189.078
        '-gtr -nome = 169.578
        
        '-noml -nome = 65.672
        '-noml -nome -nocat = 65.734
        '-noml -nome -nosupport = 8.594, 8.922
        '-noml -nome -boot 100 = 14.922
        '-noml -nome -boot 100 -fastest = 12.2297
        '-nocat -noml -nome -boot 100 -fastest = 12.2297
        '-nocat -noml -nome -boot 100 -fastest -rawdist = 12.2297
        '-noml -nome -boot 100 -fastest -no2nd = 12.484,12266
        '-noml -nome -nosupport -fastest = 12.484,12266 = 5.937
        '-noml -nome -boot 100 -fastest = 12.2265
        '-noml -nome -boot 50 -fastest = 9.438
        XX = XX
        'raxml fastbootstrap - 25.468'
        'raxml slowbootstrap - 93.468
        'phyml1 - 25.156
        'phyml3nni - alrt - 93.156'
        'phyml3nni - bootstrap - 559.156'
        'phyml3spr + alrt - 29.172
        'phyml3spr+nni + alrt - 111.156
        
        'raxml fastbootstrap 1 rate cat - 30.235
        'raxml fastbootstrap 25 rates cat - 34.235
        If NJF = 4 Then
            Dim tRead As String, RB As Long, lR As Long
            FF = FreeFile
            Open "boptout" For Binary As #FF
            LF = LOF(FF)
            tRead = String(LF, " ")
            If LF > 1100 Then
                Get #FF, 1, tRead
            End If
            Close #FF
            If InStr(1, tRead, "No trees are sampled ", vbBinaryCompare) > 1 Then
                Pos = InStr(1, tRead, "Try setting burnin to a number less than ", vbBinaryCompare)
                Pos = Pos + 41
                NPos = InStr(Pos, tRead, Chr(13), vbBinaryCompare)
                x = x
                RB = val(Mid$(tRead, Pos, NPos - Pos))
                RB = RB - 1
                lR = RB * 100 * 10
                RB = CLng(lR / 500)
                Call MrBayesInfile(NumberOfSeqs, 0, lR, RB)
                ShellAndClose FString, 0
               ' If NJF = 4 And TT < 1000 Then
               '
               '     Call MrBayesInfile(NumberOfSeqs, 0, 10000, 10)
               '     ShellAndClose "dnadist.bat", 0
               '     X = X
               ' ElseIf NJF = 4 And TT < 2000 Then
               '
               '     Call MrBayesInfile(NumberOfSeqs, 0, 20000, 20)
               '     ShellAndClose "dnadist.bat", 0
               '     X = X
               ' ElseIf NJF = 4 And TT < 4000 Then
               '
               '     Call MrBayesInfile(NumberOfSeqs, 0, 40000, 40)
               '     ShellAndClose "dnadist.bat", 0
               '     X = X
               ' ElseIf NJF = 4 And TT < 10000 Then
               '
               '     Call MrBayesInfile(NumberOfSeqs, 0, 100000, 100)
               '     ShellAndClose "dnadist.bat", 0
               '     X = X
               ' End If
            End If
            x = x
        End If
        
        '23.093 - infile 0 s 1 5 JC69 e e 1 1.0 BIONJ y y
        '20.729 - infile 0 s 1 5 F84 4 e 1 1.0 BIONJ y y
        '16.193 - no invariable sites infile 0 s 1 5 F84 4 0 1 1.0 BIONJ y y
        '15.002 - infile 0 s 1 5 HKY 4 0 1 1.0 BIONJ y y
        '16.393 infile 0 s 1 5 GTR 4 0 1 1.0 BIONJ y y

        x = x
        'Loop
    End If
    
    If AbortFlag = 1 Then
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        If DebuggingFlag < 2 Then On Error Resume Next

        ChDir oDir
        ChDrive oDir
        On Error GoTo 0
        TBSReps = oReps
        Erase ETSeqNum
        CurrentlyRunningFlag = 0
        Exit Sub
    End If

    If TBSReps < 2 And ((NJF = 1 And F2TreeIndex <> 3) Or NJF = 2) Then
        Form1.ProgressBar1.Value = 60
        Call UpdateF2Prog
    ElseIf (NJF = 1 And F2TreeIndex <> 3) Or NJF = 2 Then
        Form1.ProgressBar1.Value = 10
        Call UpdateF2Prog
    End If

    If NJF = 2 Then
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infilex"
        KillFile "infile"
        CurrentlyRunningFlag = 0
        On Error GoTo 0
        'AbortFlag = 1
        'Exit Sub

        
            Name "outfilex3" As "infile"
        

        'Make the NEIGHBOR optfile
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '    Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, BSRndNumSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "2"
            'Print #1, "3"
            Print #1, "y"
        

        Close #1
        Form1.SSPanel1.Caption = "Drawing Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        If DebuggingFlag < 2 Then On Error Resume Next
        Open "neighbor.bat" For Output As #1
        Print #1, "fitch <optfilen"
        Print #1, "rename outfile outfilex"
        Close #1
        On Error GoTo 0
        
        ShellAndClose "neighbor.bat", 0
        'AbortFlag = 1

        If AbortFlag = 1 Then
            Form2.SSPanel1(0).Enabled = True
            Form2.SSPanel1(1).Enabled = True
            Form2.SSPanel1(2).Enabled = True
            Form2.SSPanel1(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            TBSReps = oReps
            Erase ETSeqNum
            CurrentlyRunningFlag = 0
            Exit Sub
        End If

    End If
    If NJF >= 2 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
    'Open treefile and read in the tree.
    
        If TBSReps < 2 And NJF = 2 Then
            Form1.ProgressBar1.Value = 70
            Call UpdateF2Prog
        ElseIf (NJF = 1 And F2TreeIndex <> 3) Or NJF = 2 Then
            Form1.ProgressBar1.Value = 15
            Call UpdateF2Prog
        ElseIf NJF <> 0 Then
            Form1.ProgressBar1.Value = 98
            Call UpdateF2Prog
        ElseIf NJF = 0 Then
            Form1.ProgressBar1.Value = PBTarget
            Call UpdateF2Prog
            PBStart = Form1.ProgressBar1.Value
            PBTarget = (100 - PBStart) / 8 + PBStart
'            If BusyWithTreeFlag = 0 Then
'                Form1.ProgressBar1.Value = 98
'                Form2.ProgressBar1.Value = 98
'            ElseIf BusyWithTreeFlag = 1 Then
'                Form1.ProgressBar1.Value = 40
'                Form2.ProgressBar1.Value = 40
'            ElseIf BusyWithTreeFlag = 2 Then
'                Form1.ProgressBar1.Value = 60
'                Form2.ProgressBar1.Value = 60
'            ElseIf BusyWithTreeFlag = 3 Then
'                Form1.ProgressBar1.Value = 80
'                Form2.ProgressBar1.Value = 80
'            ElseIf BusyWithTreeFlag = 4 Then
'                Form1.ProgressBar1.Value = 98
'                Form2.ProgressBar1.Value = 98
'            End If
        End If
        If NJF = 2 Then
            Call ReadTreeFile(NextNo, 0, 0, "outtree", Getstring, Treebyte())
        ElseIf NJF = 4 Then
            Call ReadTreeFile(NextNo, 0, 0, "outfile.con.tre", Getstring, Treebyte())
        Else
            Call ReadTreeFile(NextNo, 0, 0, "treefile", Getstring, Treebyte())
        End If
        NHString(NHFlag) = Getstring
        If NHFlag = 11 Or NHFlag = 12 Or NHFlag = 13 Then
            NHComp(0) = Getstring
        ElseIf NHFlag = 8 Or NHFlag = 9 Or NHFlag = 10 Then
            NHComp(1) = Getstring
        End If
        If (NJF = 3 Or (NJF = 1 And F2TreeIndex = 3)) And TBSReps > 1 And BSTreeStrat = 4 Then
        
        Else
            Call ReplaceNames(OriginalName(), NumberOfSeqs, NHString(NHFlag))
        End If
    End If
    
    'Open "TS.txt" For Output As #1
    'Print #1, NHString(NHFlag)
    'Close #1
    
    
    'Open "tester.tre" For Output As #1
    'Print #1, NHString(NHFlag)
    'Close #1
    LPos = 0
    'xxx = CurDir
    Dim ZPos As Long, SSCount As Long
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(x, Y) = -1
           
        Next 'Y

    Next 'X
    ReDim DLen(NumberOfSeqs + 1)
    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim NameXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    Dim Tracer() As Long
    ReDim Tracer(NumberOfSeqs + 1, NumberOfSeqs + 1)
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    
        Do While LPos < Len(Getstring)
            mZNo = 0
            lZNo = 0
            ZNo = NextNo + 1
            
            ' This collects:
            '(1) internal branch lengths (put into llen)
            '(2) terminal branch lnegths (put into seqxpos)
            '(3) positions of ")" in the encoded tree so that bootstrap values can be added later
            '(4) bracket pairs in which sequences are found (stored in Nodedepth - element 1=bracket pair,2=sequence order)
            If Treebyte(LPos - 1) = 40 Then '(
                'find the matching )
                
                If CCount > -1 Then
                    lZNo = ZNo
                    If ZNo + 1 <= mZNo Then
                        ZNo = mZNo + 1
                    Else
                        ZNo = ZNo + 1
                    End If
                    
                    
                End If
                CCount = CCount + 1
                
                DCount = 1
                SCount = 0
                TPos = LPos + 1
    
                Do
    
                    If Treebyte(TPos - 1) = 40 Then '(
                        DCount = DCount + 1
                        
                        
                    ElseIf Treebyte(TPos - 1) = 41 Then ')
                        
                        
                        
                        DCount = DCount - 1
    
                        If DCount = 0 Then ' Matching ) found - find branch len associated with this subtree
                            If NJF = 3 Or NJF = 4 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then 'for ml and bayes trees
                                If Treebyte(TPos) <> 58 Then
                                    Xpos = TPos + 1
                                    Do While Xpos < Len(Getstring)
                                        If Treebyte(Xpos) = 58 Then
                                            Exit Do
                                        End If
                                        Xpos = Xpos + 1
                                    Loop
                                    If Xpos < Len(Getstring) And CCount <= UBound(DLen, 1) Then
                                        
                                        DLen(CCount) = val(Mid$(Getstring, TPos + 1, (Xpos - TPos)))
                                       
                                    ElseIf CCount <= UBound(DLen, 1) Then
                                        DLen(CCount) = 0
                                    End If
                                    TPos = Xpos
                                Else
                                    If CCount > UBound(DLen) Then
                                        ReDim Preserve DLen(CCount)
                                    End If
                                    DLen(CCount) = 0
                                End If
                                If CCount <= UBound(DLen, 1) Then
                                    If DLen(CCount) < 0 And TNegBLFlag = 0 Then
                                        DLen(CCount) = 0
                                    End If
                                End If
                            End If
                            If Treebyte(TPos) = 58 Then ':
    
                                If Treebyte(TPos + 1) = 45 Then '-
    
                                    If NJF = 3 Or NJF = 4 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
                                    'XX = Val(Mid$(Getstring, TPos + 2, 8))
                                        If CCount < UBound(LLen) Then
                                            LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 10))
                                        End If
                                    Else
                                        If TNegBLFlag = 0 Then
                                            LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 8))
                                        Else
                                            If NJF = 4 Then
                                        
                                                Pos1 = InStr(TPos + 2, Getstring, ")", vbBinaryCompare)
                                                Pos2 = InStr(TPos + 2, Getstring, ":", vbBinaryCompare)
                                                Pos3 = InStr(TPos + 2, Getstring, ",", vbBinaryCompare)
                                                Pos4 = InStr(TPos + 2, Getstring, "[", vbBinaryCompare)
                                                If Pos1 = 0 Then Pos1 = 10000000000#
                                                If Pos2 = 0 Then Pos2 = 10000000000#
                                                If Pos3 = 0 Then Pos3 = 10000000000#
                                                If Pos4 = 0 Then Pos4 = 10000000000#
                                                If Pos1 < Pos2 And Pos1 < Pos3 And Pos1 < Pos4 Then
                                                    pos5 = Pos1
                                                ElseIf Pos2 < Pos1 And Pos2 < Pos3 And Pos2 < Pos4 Then
                                                    pos5 = Pos2
                                                ElseIf Pos3 < Pos2 And Pos3 < Pos1 And Pos3 < Pos4 Then
                                                    pos5 = Pos3
                                                ElseIf Pos4 < Pos2 And Pos4 < Pos1 And Pos4 < Pos3 Then
                                                    pos5 = Pos4
                                                End If
                                                XX = Mid$(Getstring, TPos + 2, pos5 - TPos - 2)
                                                LLen(CCount) = val(Mid$(Getstring, TPos + 2, pos5 - TPos - 2))
                                                
                                                
                                               ' LLen(CCount) = Val(Mid$(Getstring, TPos + 2, 8))
                                            Else
                                                LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                            End If
                                        End If
                                    End If
                                    
                                    PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                Else
    
                                    If NJF = 3 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
                                        If CCount <= UBound(LLen, 1) Then
                                            LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                        End If
                                    
                                    ElseIf NJF = 4 Then
                                        If CCount <= UBound(LLen, 1) Then
                                            Pos1 = InStr(TPos + 2, Getstring, ")", vbBinaryCompare)
                                            Pos2 = InStr(TPos + 2, Getstring, ":", vbBinaryCompare)
                                            Pos3 = InStr(TPos + 2, Getstring, ",", vbBinaryCompare)
                                            Pos4 = InStr(TPos + 2, Getstring, "[", vbBinaryCompare)
                                            If Pos1 = 0 Then Pos1 = 10000000000#
                                            If Pos2 = 0 Then Pos2 = 10000000000#
                                            If Pos3 = 0 Then Pos3 = 10000000000#
                                            If Pos4 = 0 Then Pos4 = 10000000000#
                                            If Pos1 < Pos2 And Pos1 < Pos3 And Pos1 < Pos4 Then
                                                pos5 = Pos1
                                            ElseIf Pos2 < Pos1 And Pos2 < Pos3 And Pos2 < Pos4 Then
                                                pos5 = Pos2
                                            ElseIf Pos3 < Pos2 And Pos3 < Pos1 And Pos3 < Pos4 Then
                                                pos5 = Pos3
                                            ElseIf Pos4 < Pos2 And Pos4 < Pos1 And Pos4 < Pos3 Then
                                                pos5 = Pos4
                                            End If
                                            XX = Mid$(Getstring, TPos + 2, pos5 - TPos - 2)
                                            LLen(CCount) = val(Mid$(Getstring, TPos + 2, pos5 - TPos - 2))
                                        End If
                                    
                                    
                                    Else
                                        If CCount <= UBound(LLen, 1) Then
                                            XX = Mid$(Getstring, TPos + 2, 7)
                                            If Mid$(Getstring, TPos + 8, 1) <> ";" And Mid$(Getstring, TPos + 8, 1) <> "," And Mid$(Getstring, TPos + 8, 1) <> ")" Then
                                                LLen(CCount) = val(Mid$(Getstring, TPos + 2, 7))
                                            Else
                                                LLen(CCount) = val(Mid$(Getstring, TPos + 2, 6))
                                            End If
                                        End If
                                    End If
                                    'XX = Distance(1, 2)
                                    'xxx = DLen(CCount)
                                    If CCount > UBound(PNodeStr, 1) Then
                                        ReDim Preserve PNodeStr(CCount)
                                    End If
                                    PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                End If
    
                            Else
                            
                            
                                LLen(CCount) = 0
                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                            End If
                            If CCount <= UBound(LLen, 1) Then
                                If LLen(CCount) < 0 And TNegBLFlag = 0 Then
                                    LLen(CCount) = 0
                                End If
                            End If
                            Exit Do
                        End If
                        
                        
                    ElseIf Treebyte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                        
                        PosP = InStr(TPos, Getstring, ":", vbBinaryCompare)
                        CSeq = val(Mid$(Getstring, TPos + 1, PosP - TPos - 1))
                        'XX = Mid$(GetString, TPos + 1, PosP - TPos - 1)
                        '203,204,205,206,211,207,208,210,209,212,220,217,218,213,214,215,219,216
                        If SCount <= UBound(NodeDepth, 2) And CCount <= UBound(NodeDepth, 1) Then
                            NodeDepth(CCount, SCount) = CSeq
                        End If
                        If CSeq <= UBound(Tracer, 1) And CCount <= UBound(Tracer, 2) Then
                            Tracer(CSeq, CCount) = 1
                        End If
                        SCount = SCount + 1
                        If CSeq <= UBound(Done, 1) Then
                            If Done(CSeq) = 0 Then
                                Done(CSeq) = 1
        
                                If Treebyte(PosP) = 45 Then  '-
        
                                    If NJF = 3 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
                                        
                                        SeqXPos(CSeq) = val(Mid$(Getstring, PosP, 9))
                                        If TNegBLFlag = 0 And SeqXPos(CSeq) < 0 Then
                                            SeqXPos(CSeq) = 0
                                            NameXPos(CSeq) = 0
                                        Else
                                            NameXPos(CSeq) = SeqXPos(CSeq)
                                        End If
                                    ElseIf NJF = 4 Then
                                        Pos1 = InStr(PosP + 1, Getstring, ")", vbBinaryCompare)
                                        Pos2 = InStr(PosP + 1, Getstring, ":", vbBinaryCompare)
                                        Pos3 = InStr(PosP + 1, Getstring, ",", vbBinaryCompare)
                                        Pos4 = InStr(PosP + 1, Getstring, "[", vbBinaryCompare)
                                        If Pos1 = 0 Then Pos1 = 10000000000#
                                        If Pos2 = 0 Then Pos2 = 10000000000#
                                        If Pos3 = 0 Then Pos3 = 10000000000#
                                        If Pos4 = 0 Then Pos4 = 10000000000#
                                        If Pos1 < Pos2 And Pos1 < Pos3 And Pos1 < Pos4 Then
                                            pos5 = Pos1
                                        ElseIf Pos2 < Pos1 And Pos2 < Pos3 And Pos2 < Pos4 Then
                                            pos5 = Pos2
                                        ElseIf Pos3 < Pos2 And Pos3 < Pos1 And Pos3 < Pos4 Then
                                            pos5 = Pos3
                                        ElseIf Pos4 < Pos2 And Pos4 < Pos1 And Pos4 < Pos3 Then
                                            pos5 = Pos4
                                        End If
                                        x = x
                                        XX = Mid$(Getstring, PosP, (pos5 - PosP - 1))
                                        SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, pos5 - PosP - 1))
                                        If TNegBLFlag = 0 And SeqXPos(CSeq) < 0 Then
                                            SeqXPos(CSeq) = 0
                                            NameXPos(CSeq) = 0
                                        Else
                                            NameXPos(CSeq) = SeqXPos(CSeq)
                                        End If
                                    Else
                                        
                                        If TNegBLFlag = 1 Then
                                            SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                        Else
                                            SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                                        End If
                                        NameXPos(CSeq) = 0
                                        
                                    End If
        
                                Else
        
                                    If NJF = 3 Or NJF = 0 Or (NJF = 1 And F2TreeIndex = 3) Then
                                        XX = Mid$(Getstring, PosP + 1, 8)
                                        SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                        x = x
                                        NameXPos(CSeq) = SeqXPos(CSeq)
                                    ElseIf NJF = 4 Then
                                        
                                        Pos1 = InStr(PosP + 1, Getstring, ")", vbBinaryCompare)
                                        Pos2 = InStr(PosP + 1, Getstring, ":", vbBinaryCompare)
                                        Pos3 = InStr(PosP + 1, Getstring, ",", vbBinaryCompare)
                                        Pos4 = InStr(PosP + 1, Getstring, "[", vbBinaryCompare)
                                        If Pos1 = 0 Then Pos1 = 10000000000#
                                        If Pos2 = 0 Then Pos2 = 10000000000#
                                        If Pos3 = 0 Then Pos3 = 10000000000#
                                        If Pos4 = 0 Then Pos4 = 10000000000#
                                        If Pos1 < Pos2 And Pos1 < Pos3 And Pos1 < Pos4 Then
                                            pos5 = Pos1
                                        ElseIf Pos2 < Pos1 And Pos2 < Pos3 And Pos2 < Pos4 Then
                                            pos5 = Pos2
                                        ElseIf Pos3 < Pos2 And Pos3 < Pos1 And Pos3 < Pos4 Then
                                            pos5 = Pos3
                                        ElseIf Pos4 < Pos2 And Pos4 < Pos1 And Pos4 < Pos3 Then
                                            pos5 = Pos4
                                        End If
                                        x = x
                                        'XX = Mid$(Getstring, PosP + 1, (pos5 - PosP - 1))
                                        SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, pos5 - PosP - 1))
                                        
                                        NameXPos(CSeq) = SeqXPos(CSeq)
                                    Else
                                        SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 7))
                                        NameXPos(CSeq) = SeqXPos(CSeq)
                                    End If
        
                                End If
        
                            End If
                        End If
    
                    End If
    
                    TPos = TPos + 1
                Loop
    
            End If
    
            LPos = LPos + 1
            
        Loop
    
    
    
    
    
    'store nodedepth so that boostrap values can be put into NHSTRING
    Dim NHNodeDepth() As Long, CP() As Long
    ReDim NHNodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), CP(NumberOfSeqs + 1)
    'For X = 0 To NumberOfSeqs + 1
    '
    '    For Y = 0 To NumberOfSeqs + 1
    '
    '
    '            NHNodeDepth(Y, Y) = -1
    '
    '
    '    Next Y
    'Next X
    ''For X = 0 To NumberOfSeqs + 1
    '
    '    For Y = 0 To NumberOfSeqs + 1
    '
    '        If Tracer(X, Y) = 1 Then
    '            NHNodeDepth(Y, CP(Y)) = X
    '            CP(Y) = CP(Y) + 1
    '        End If
    '    Next Y
    '    X = X
    'Next X
    For x = 0 To NumberOfSeqs + 1
    
        For Y = 0 To NumberOfSeqs + 1
    
            
                NHNodeDepth(x, Y) = NodeDepth(x, Y)
                
        Next Y
        
    Next x
    'Get treedistances
    Dim LongDist As Double, CDist As Double, CurS As Long, LongSeq(1) As Long, TreeD() As Single, SepBranch() As Integer, lX As Byte
    
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    SS = Abs(GetTickCount)
    For x = 0 To NumberOfSeqs
        For Y = 0 To NumberOfSeqs
            If NodeDepth(x, Y) > -1 Then
                If NodeDepth(x, Y) <= UBound(SepBranch, 2) Then
                    SepBranch(x, (NodeDepth(x, Y))) = 1
                End If
            Else
                Exit For
            End If
        Next Y
    Next x
    EE = gettickcpunt
    TT = EE - SS
    
    ReDim TreeD(NumberOfSeqs, NumberOfSeqs)
     
     If x = x Then
        Dummy = MakeTreeD(UBound(TreeD, 1), UBound(NodeDepth, 1), UBound(SepBranch, 1), NumberOfSeqs, LLen(0), TreeD(0, 0), SeqXPos(0), NodeDepth(0, 0), SepBranch(0, 0))
        x = x
     Else
        'Do terminal branch lengths
        For x = 0 To NumberOfSeqs
            For Y = x + 1 To NumberOfSeqs
                TreeD(x, Y) = TreeD(x, Y) + SeqXPos(x) + SeqXPos(Y)
                TreeD(Y, x) = TreeD(x, Y)
            Next Y
        Next x
        'Add internal branch lengths
        
        
        
        'port this to c++
    
   
    
        For x = 0 To NumberOfSeqs
            For Z = 0 To NumberOfSeqs
                If SepBranch(x, Z) = 0 Then
                    For Y = 0 To NumberOfSeqs
                        If NodeDepth(x, Y) > -1 Then
                            CurS = NodeDepth(x, Y)
                            If CurS <= UBound(TreeD, 1) Then
                                
                                TreeD(CurS, Z) = TreeD(CurS, Z) + LLen(x)
                                TreeD(Z, CurS) = TreeD(CurS, Z) 'TreeD(Z, CurS) + LLen(X)
                                       
                            End If
                        Else
                            Exit For
                        End If
                    Next Y
                End If
            Next Z
        Next x
    End If
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    '8 seconds for 1300 nt sequence, 0.5 seconds in c++, 0.313
    
    
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
            If LongDist < TreeD(x, Y) Then
                LongDist = TreeD(x, Y)
                LongSeq(0) = x
                LongSeq(1) = Y
            End If
        Next Y
    Next x
    LongDist = LongDist / 2
    
    
    'find the branch within which the midpoint falls
    lX = 0
    CDist = SeqXPos(LongSeq(0))
    x = -LongSeq(0) - 1
    If CDist < LongDist Then
        For x = NumberOfSeqs To 0 Step -1
            
            If SepBranch(x, LongSeq(0)) = 1 And SepBranch(x, LongSeq(1)) = 0 Then 'ie sequences are separated by this branch
                
                CDist = CDist + LLen(x)
                If CDist > LongDist Then
                    Exit For
                End If
            End If
        Next x
        
        If CDist < LongDist Then
            lX = 1
            x = -LongSeq(1) - 1
            CDist = SeqXPos(LongSeq(1))
            If CDist < LongDist Then
                For x = NumberOfSeqs To 0 Step -1
                    If SepBranch(x, LongSeq(1)) = 1 And SepBranch(x, LongSeq(0)) = 0 Then 'ie sequences are separated by this branch
                    
                        CDist = CDist + LLen(x)
                        If CDist > LongDist Then
                            Exit For
                        End If
                    End If
                Next x
            End If
            
        End If
        x = x
    End If
    
    Dim TempNodeDepth() As Long, TempLLen() As Single, TempDLen() As Single, TNode As Long, CNodeX As Long, XCnt As Long
    ReDim TempNodeDepth(NumberOfSeqs + 2, NumberOfSeqs + 2), TempLLen(NumberOfSeqs + 2), TempDLen(NumberOfSeqs + 2)
    
    TNode = x
    
    Dim oSepBranch() As Integer
    For x = 0 To NumberOfSeqs + 1
        For Y = 0 To NumberOfSeqs + 1
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    
    Dim RLLen() As Long
    ReDim RLLen(NextNo * 2)
    'If TNode < 0 Then TNode = Abs(TNode + 1)
    If TNode < 0 Then  'ie the midpoint is in a terminal branch of sequence abs(x)
        TNode = Abs(TNode + 1)
        'If X = 12345 Then
        For x = NumberOfSeqs To 0 Step -1 'moving through the branches from tips till the base
            If SepBranch(x, TNode) = 1 Then 'find the first clade with this sequence
'                If x = 0 And x = 12345 Then
'                    TempLLen(1) = 0
'                    SeqXPos(TNode) = LongDist
'                    NameXPos(TNode) = LongDist
'                    For Z = 0 To NumberOfSeqs
'                        If Z <> TNode Then
'                            TempLLen(Z) = TempLLen(Z) + SeqXPos(TNode) - LongDist
'                        End If
'                    Next Z
'                Else
                    For Z = x To 1 Step -1 'move from this clade through to the base of the tree
                        TempLLen(2 + x - Z) = LLen(Z)
                        TempDLen(2 + x - Z) = DLen(Z)
                        RLLen(Z) = 2 + x - Z
                        Cnt = 0
                        If SepBranch(Z, TNode) = 1 Then
                            For Y = 0 To NumberOfSeqs
                            
                                If SepBranch(Z, Y) = 0 Then
                                    TempNodeDepth(2 + x - Z, Cnt) = Y
                                    Cnt = Cnt + 1
                                End If
                                
                            Next Y
                           
                        Else
                            For Y = 0 To NumberOfSeqs
                            
                                If SepBranch(Z, Y) = 1 Then
                                    TempNodeDepth(2 + x - Z, Cnt) = Y
                                    Cnt = Cnt + 1
                                End If
                            Next Y
                        End If
                        For Y = Cnt To NumberOfSeqs
                            TempNodeDepth(2 + x - Z, Y) = -1
                        Next Y
                    Next Z
                    TempLLen(1) = 0 'SeqXPos(TNode) - LongDist
                    'For Z = 2 To NumberOfSeqs
                    '    TempLLen(Z) = TempLLen(Z) + SeqXPos(TNode) - LongDist
                    'Next Z
                    'TempLLen(0) = LongDist * 5
                    SeqXPos(TNode) = LongDist
                    NameXPos(TNode) = LongDist
                'End If
                'TempLLen(0) = 0
                
                
                If x > 1 Then
                    XCnt = 0
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If TempNodeDepth(2, Y) = -1 Then Exit For
                        If Y <> TNode Or NumberOfSeqs > 3 Then
                            TempNodeDepth(1, Y) = TempNodeDepth(2, Y)
                            Cnt = Cnt + 1
                        End If
                    Next Y
                    If Cnt < NumberOfSeqs Then
                    
                        For Y = 0 To NumberOfSeqs
                            If NodeDepth(x, Y) <> TNode Then
                                If NodeDepth(x, Y) = -1 Then Exit For
                                If Cnt <= UBound(TempNodeDepth, 2) Then
                                    TempNodeDepth(1, Cnt) = NodeDepth(x, Y)
                                    Cnt = Cnt + 1
                                
                                End If
                            End If
                        Next Y
                        
                        For Y = Cnt To NumberOfSeqs
                            TempNodeDepth(1, Cnt) = -1
                        Next Y
                    End If
                Else
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If Y <> TNode Or NumberOfSeqs > 3 Then
                            TempNodeDepth(1, Cnt) = Y
                            Cnt = Cnt + 1
                        End If
                        
                    Next Y
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(1, Cnt) = -1
                    Next Y
                End If
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(0, Y) = TempNodeDepth(1, Y)
                Next Y
                'XX = TempNodeDepth(0, 0)
                TempNodeDepth(0, NumberOfSeqs) = TNode
                Exit For
            Else
                
                TempLLen(x + 1) = LLen(x)
                TempDLen(x + 1) = DLen(x)
                RLLen(x) = x + 1
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
                Next Y
            End If
            
            
        Next x
        TNode = 0
        
    Else   'it is in internal branch x
        TempLLen(2) = CDist - LongDist
        TempLLen(1) = LLen(TNode) - TempLLen(2)
        TempLLen(0) = LLen(TNode) - TempLLen(2)
        TempDLen(1) = DLen(TNode)
        TempDLen(0) = DLen(TNode)
        RLLen(TNode) = 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If NodeDepth(0, x) <= UBound(SepBranch, 2) And NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 1 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        For x = 0 To NumberOfSeqs
            If NodeDepth(0, x) <= UBound(SepBranch, 2) And NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                Else
                    Exit For
                End If
            End If
        Next x
        
        For x = NumberOfSeqs To 0 Step -1
            If NodeDepth(0, x) <= UBound(SepBranch, 2) And NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                Else
                    Exit For
                End If
            End If
        Next x
        
        
        'TempNodeDepth(0, Cnt) = NumberOfSeqs + 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If TempNodeDepth(0, x) <= UBound(SepBranch, 2) And TempNodeDepth(0, x) > -1 Then
                If SepBranch(TNode, TempNodeDepth(0, x)) = 0 Then
                    TempNodeDepth(2, Cnt) = TempNodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(2, Y) = -1
        Next Y
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If TempNodeDepth(0, x) <= UBound(SepBranch, 2) And TempNodeDepth(0, x) > -1 Then
                If SepBranch(TNode, TempNodeDepth(0, x)) = 1 Then
                    TempNodeDepth(1, Cnt) = TempNodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        TempNodeDepth(1, Cnt) = NumberOfSeqs + 1
        Cnt = Cnt + 1
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(1, Y) = -1
        Next Y
        
        XCnt = TNode + 1
        YCnt = 3
        For x = TNode - 1 To 1 Step -1
            If UBound(SepBranch, 2) >= NodeDepth(TNode, 0) Then
            
            
            If SepBranch(x, NodeDepth(TNode, 0)) = 0 Then
                TempLLen(XCnt) = LLen(x)
                TempDLen(XCnt) = DLen(x)
                RLLen(x) = XCnt
                Cnt = 0
                For Y = 0 To NumberOfSeqs
                    If TempNodeDepth(0, Y) <= UBound(SepBranch, 2) And TempNodeDepth(0, Y) > -1 Then
                        If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                            TempNodeDepth(XCnt, Cnt) = TempNodeDepth(0, Y)
                            Cnt = Cnt + 1
                        End If
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(XCnt, Y) = -1
                Next Y
                XCnt = XCnt - 1
            Else
                Cnt = 0
                TempLLen(YCnt) = LLen(x)
                TempDLen(YCnt) = DLen(x)
                RLLen(x) = YCnt
                For Y = 0 To NumberOfSeqs
                    If TempNodeDepth(0, Y) <= UBound(SepBranch, 2) And TempNodeDepth(0, Y) > -1 Then
                        If SepBranch(x, TempNodeDepth(0, Y)) = 0 Then
                            TempNodeDepth(YCnt, Cnt) = TempNodeDepth(0, Y)
                            Cnt = Cnt + 1
                        End If
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(YCnt, Y) = -1
                Next Y
                YCnt = YCnt + 1
            End If
            End If
        Next x
        For x = TNode + 1 To NumberOfSeqs
            TempLLen(x + 1) = LLen(x)
            TempDLen(x + 1) = DLen(x)
            RLLen(x) = x + 1
            For Y = 0 To NumberOfSeqs
                TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
            Next Y
        
        Next x
       
        
        
    End If
    
   
    
    'Rearrange tempnodedepth so that 0-nextno run with the largest to smallest numbers of entries
    Dim ttNodeDepth() As Long, NumEnt() As Long, Maxent As Long, WinEnt As Long, ttLLen(), ttDLen()
    ReDim NumEnt(NumberOfSeqs), ttLLen(NumberOfSeqs), ttDLen(NumberOfSeqs)
    ReDim ttNodeDepth(NumberOfSeqs, NumberOfSeqs)
    For x = 0 To NumberOfSeqs
        NumEnt(x) = 0
        For Y = 0 To NumberOfSeqs
            If TempNodeDepth(x, Y) > -1 Then
                NumEnt(x) = NumEnt(x) + 1
            End If
        Next Y
    Next x
    For Y = 0 To NumberOfSeqs
        Maxent = -1
        For x = 0 To NumberOfSeqs
            If NumEnt(x) > Maxent Then
                Maxent = NumEnt(x)
                WinEnt = x
            End If
        Next x
        For x = 0 To NumberOfSeqs
            ttNodeDepth(Y, x) = TempNodeDepth(WinEnt, x)
            
        Next x
        ttLLen(Y) = TempLLen(WinEnt)
        ttDLen(Y) = TempDLen(WinEnt)
        NumEnt(WinEnt) = -1
       ' RLLen(WinEnt) = Y
    Next Y
    For x = 0 To NumberOfSeqs
        TempLLen(x) = ttLLen(x)
        TempDLen(x) = ttDLen(x)
        For Y = 0 To NumberOfSeqs
            TempNodeDepth(x, Y) = ttNodeDepth(x, Y)
        Next Y
    Next x
    
    ReDim oSepBranch(NumberOfSeqs + 2)
    If TNode > -1 Then
        For x = 0 To NumberOfSeqs
            oSepBranch(x) = SepBranch(TNode, x) '2,3,4,5,6,10,11,12,17,19,20
        Next x
    End If
    
    NumberOfSeqs = NumberOfSeqs + 1
    Dim LongHold() As Long
    Dim DoneOne() As Byte, tOrder() As Long
    ReDim DoneOne(NumberOfSeqs), tOrder(NumberOfSeqs + 1), LongHold(NumberOfSeqs + 1)
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    For x = 0 To NumberOfSeqs - 1
        For Y = 0 To NumberOfSeqs - 1
            If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= UBound(SepBranch, 2) Then
                SepBranch(x, TempNodeDepth(x, Y)) = 1
            Else
                Exit For
            End If
        Next Y
    Next x
    
    Cnt = 0
    Redo = -2
    If TNode > -1 Then
        For A = 0 To 1
            First = -1
            Target = A
            For Z = NumberOfSeqs To 0 Step -1
                cnn = 0
                If TempNodeDepth(Z, 0) > -1 And TempNodeDepth(Z, 0) <= UBound(DoneOne, 1) Then
                    
                    If DoneOne(TempNodeDepth(Z, 0)) = 0 Then
                        Redo = -2
                        First = TempNodeDepth(Z, 0)
                        
                        Last = First
                        'LastX = -1
                        For x = Z To 0 Step -1
                            If x = 16 Then
                                x = x
                            End If
                            If SepBranch(x, First) = 1 Then
                                Add = 0
                                For Y = 0 To NumberOfSeqs
                                    
                                    If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                        If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                            If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                Add = Add + 1
                                                If Add > 2 Then Exit For
                                            End If
                                        End If
                                    End If
                                    
                                Next Y
                                If Add <= 2 Then
                                    For Y = 0 To NumberOfSeqs
                                        
                                        If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                            If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                    tOrder(Cnt) = TempNodeDepth(x, Y)
                                                    
                                                    DoneOne(TempNodeDepth(x, Y)) = 1
                                                    
                                                    Cnt = Cnt + 1
                                                End If
                                            End If
                                        End If
                                    Next Y
                                ElseIf x > 0 Then
                                    ReDim LongHold(NumberOfSeqs + 1)
                                    XCnt = 0
                                    For Y = 0 To NumberOfSeqs
                                            
                                            If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                                If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                    If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                        LongHold(XCnt) = TempNodeDepth(x, Y)
                                                        XCnt = XCnt + 1
                                                        
                                                    End If
                                                End If
                                            End If
                                    Next Y
                                    GoOn = 0
                                    For Y = NumberOfSeqs To 0 Step -1
                                        For b = 0 To XCnt - 1
                                            If SepBranch(Y, LongHold(b)) = 1 Then
                                                GoOn = 1
                                                Exit For
                                            End If
                                        Next b
                                        If GoOn = 1 Then Exit For
                                    Next Y
                                    If Y > x And First <> LongHold(b) And cnn < NumberOfSeqs Then
                                        First = LongHold(b)
                                        x = Y + 1
                                        cnn = cnn + 1
                                    End If
                                    'Exit For
                                End If
                            
                            End If
                        Next x
                        cnn = 0
                        x = x
                        'If First <> Last Then
                        '    Z = Z + 1
                        '    Redo = tOrder(0)
                        'End If
                    End If
                End If
                If Cnt > NumberOfSeqs + 1 Then Exit For
                
                
            Next Z
        Next A
    End If
    'XX = originalname(TempNodeDepth(0, 0))
    
    tOrder(NumberOfSeqs + 1) = NumberOfSeqs + 1
    
    For x = 0 To NumberOfSeqs
        TempNodeDepth(0, x) = tOrder(x) '10,4,0,2 '25,0,24,30,31,32,29,26,27,28,23,20,21,1,2,3,4,5,6,7,17,16,19,18,15,13,14,12,9,10,8,11,33,0,0
        '22?
    Next x
    For x = 0 To NumberOfSeqs
        If TempNodeDepth(0, x) = 0 Then
            For Y = x + 1 To NumberOfSeqs
                If TempNodeDepth(0, Y) = 0 Then
                    For Z = 0 To NumberOfSeqs
                        If DoneOne(Z) = 0 Then
                            DoneOne(Z) = 1
                            TempNodeDepth(0, Y) = Z
                            Exit For
                        End If
                    Next Z
                End If
            Next Y
            Exit For
        End If
    Next x
    For x = 1 To NumberOfSeqs
        ReDim tOrder(NumberOfSeqs + 1)
        Cnt = 0
        For Y = 0 To NumberOfSeqs - 1
            If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                tOrder(Cnt) = TempNodeDepth(0, Y)
                Cnt = Cnt + 1
            
            End If
            
        Next Y
        For Y = 0 To Cnt - 1
            TempNodeDepth(x, Y) = tOrder(Y)
        Next Y
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    
    
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), LLen(NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs
        LLen(x) = TempLLen(x)
        DLen(x) = TempDLen(x)
        For Y = 0 To NumberOfSeqs
            
            NodeDepth(x, Y) = TempNodeDepth(x, Y)
        Next Y
    Next x
    
    For x = 0 To NumberOfSeqs
        NodeDepth(x, NumberOfSeqs) = -1
        NodeDepth(x, NumberOfSeqs + 1) = -1
    Next x
    LLen(0) = 0
    NodeDepth(0, NumberOfSeqs) = NumberOfSeqs
    'Dummy = TreeToArray(NameLen, NumberOfSeqs, LTree, T2Holder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0))
    'NumberOfSeqs = NumberOfSeqs + 1
    
    'work out y-positions of all the nodes.
    ReDim SeqYPos(NumberOfSeqs + 1)
    ReDim tSeqYPos(NumberOfSeqs + 1)
    ReDim NodeYPos(NumberOfSeqs + 1)

    For x = 0 To NumberOfSeqs
        SeqYPos(NodeDepth(0, x)) = x
        'Exit Sub
        tSeqYPos(NodeDepth(0, x)) = x
    Next 'X
    'SeqYPos(24) = 20
    'ccount = the number of bracket pairs (ie internal branches) in the tree
    ' Nodedepth - element 1=bracket pair,2=sequence order
    For x = CCount + 1 To 0 Step -1


        For Y = 0 To NumberOfSeqs + 1
            If x <= UBound(NodeDepth, 1) Then
                If NodeDepth(x, Y) = -1 Or NodeDepth(x, Y) = NumberOfSeqs Then Exit For
            End If
        Next 'Y

        Y = Y - 1
        If Y < 0 Then Exit For
        If x <= UBound(NodeDepth, 1) Then
            If NodeDepth(x, 0) < 0 Then
                NodeDepth(x, 0) = 0
            End If
        End If
        If x <= UBound(NodeYPos, 1) Then
            NodeYPos(x) = tSeqYPos(NodeDepth(x, 0)) + (tSeqYPos(NodeDepth(x, Y)) - tSeqYPos(NodeDepth(x, 0))) / 2
        End If
        'Exit Sub
        If x <= UBound(NodeDepth, 1) Then
            tSeqYPos(NodeDepth(x, 0)) = NodeYPos(x)
            tSeqYPos(NodeDepth(x, Y)) = NodeYPos(x)
        End If
    Next 'X
'Exit Sub
   ' NodeYPos(0) = 1
    NodeYPos(0) = NodeYPos(1)

   ' NodeYPos(x) = 20
    'work out x positions
    ReDim NodeXPos(NumberOfSeqs + 1)
    
    SS = Abs(GetTickCount) 'This code MUST be ported to c++ - it accounts for >50% the execution time for fastnj trees
    
    If x = x Then
        ReDim Done(NumberOfSeqs + 1)
        Dummy = GetSeqXPos(UBound(NodeDepth, 1), UBound(NodeDepth, 2), CCount, NumberOfSeqs, NodeDepth(0, 0), Done(0), NodeXPos(0), LLen(0), SeqXPos(0), NameXPos(0))
        x = x
        For x = 0 To CCount + 1
            If LLen(x) > 0 Then
                Exit For
            End If
        Next x
        If x = CCount + 2 Then
            If BSTreeStrat = 4 And CycleFlag = 0 Then 'this is needed if raxmlpthreads has failed to run - it reruns with the normal version of raxml
                CycleFlag = CycleFlag + 1
                GoTo RedoRaxML
            End If
            MsgBox ("An error was encountered during tree construction.")
            
            XX = CurDir
            AbortFlag = 1
            Form2.SSPanel1(0).Enabled = True
            Form2.SSPanel1(1).Enabled = True
            Form2.SSPanel1(2).Enabled = True
            Form2.SSPanel1(3).Enabled = True
            Form1.ProgressBar1 = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            TBSReps = oReps
            Erase ETSeqNum
            CurrentlyRunningFlag = 0
            Exit Sub
            
        End If
    Else
    
        For x = 0 To CCount + 1
            ReDim Done(NumberOfSeqs + 1)
    
            For Y = CCount + 1 To x Step -1
                If Y <= UBound(NodeDepth, 1) Then
                    For Z = 0 To NumberOfSeqs
                        If NodeDepth(x, Z) = -1 Then Exit For
                        If NodeDepth(x, Z) = NodeDepth(Y, 0) Then
                            NodeXPos(Y) = NodeXPos(Y) + LLen(x)
                            A = 0
                            'If A <= UBound(NodeDepth, 2) Then
                                Do Until NodeDepth(Y, A) = -1
            
                                    If Done(NodeDepth(Y, A)) = 0 Then
                                            
                                            SeqXPos(NodeDepth(Y, A)) = SeqXPos(NodeDepth(Y, A)) + LLen(x) '0,1,8
                                            
                                        If LLen(x) > 0 Then
                                            NameXPos(NodeDepth(Y, A)) = NameXPos(NodeDepth(Y, A)) + LLen(x)
                                        End If
                                        Done(NodeDepth(Y, A)) = 1
                                    End If
            
                                    A = A + 1
                                    If A > UBound(NodeDepth, 2) Then Exit Do
                                    
                                Loop
                            'End If
                            Exit For
                        End If
                    
                    Next 'Z
                End If
            Next 'Y
    
        Next 'X
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS '46.203 for run9'0.094 for run 9
    x = x
'For X = 0 To NumberOfSeqs
'    XX = NameXPos(X) '0.0407,'0.0305,0.0396,0.0407,0.0317,0.006507, 0.01716,0.0266,0.0274,0.0306,0.0317,0.0306,0.0219,0
'Next X
    ' Find sequences branching from root node
    'obviosuly node 1 branches so look for largest xpos of sequences not on node 1
    ReDim Outside(NumberOfSeqs + 1)
    'Outie = NumberOfSeqs
    For x = 0 To NumberOfSeqs
        NotFound = 0

        For Y = 0 To NumberOfSeqs

            If NodeDepth(1, Y) = x Then
                NotFound = 1
                Exit For
            End If

        Next 'Y

        If NotFound = 0 Then
            Outside(x) = 1 '0,0,0,1,0,0,1,0,0,0,0,0,0,1
        Else
            Outside(x) = 0
        End If

    Next 'X

    Outside(NumberOfSeqs) = 2
    MPosO = -100
    MPosI = -100

    For x = 0 To NumberOfSeqs

        If Outside(x) = 0 Then

            If SeqXPos(x) > MPosI Then
                MPosI = SeqXPos(x)
            End If

        ElseIf Outside(x) = 1 Then

            If SeqXPos(x) > MPosO Then
                MPosO = SeqXPos(x)
            End If

        End If

    Next 'X
    If Outie > UBound(SeqXPos, 1) Then
        DistanceFlag = 0
        Call GetOutie
    End If
    If Outie <= UBound(SeqXPos, 1) Then
        If SeqXPos(Outie) > MPosO * 1.00000000001 Then
            MPosO = SeqXPos(Outie)
            OutFlag = 2
        Else
            OutFlag = 1
        End If
    Else
        OutFlag = 1
    End If
    'OutsideAdjust = (MPosI - MPosO) / 2
    OutsideAdjust = 0
    Lowest = 100
    NodeXPos(NumberOfSeqs + 1) = NodeXPos(0)
    
    For x = 0 To NumberOfSeqs

        If NodeDepth(x, 0) > -1 Then

            If Outside(NodeDepth(x, 0)) <> OutFlag Then
                NodeXPos(x) = NodeXPos(x) - OutsideAdjust
            Else
                NodeXPos(x) = NodeXPos(x) + OutsideAdjust
            End If

            If NodeXPos(x) < Lowest Then Lowest = NodeXPos(x)
        End If

    Next 'X
   
    
    For x = 0 To NumberOfSeqs

        If Outside(x) <> OutFlag Then
            SeqXPos(x) = SeqXPos(x) - OutsideAdjust
        Else
            SeqXPos(x) = SeqXPos(x) + OutsideAdjust
        End If

        If SeqXPos(x) < Lowest Then Lowest = SeqXPos(x) 'this is dumb because seqxpos(numberofseqs) is always 0
    Next 'X

    If Lowest < 0 Then
        TotalAdjust = -Lowest

        For x = 1 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) + TotalAdjust
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) + TotalAdjust
            NameXPos(x) = NameXPos(x) + TotalAdjust
        Next 'X

    ElseIf x = x Then
        TotalAdjust = 1
        For x = 0 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) - Lowest
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) - Lowest
            NameXPos(x) = NameXPos(x) - Lowest
        Next 'X
    End If

    MaxXPos = 0

    For x = 0 To NumberOfSeqs

        If SeqXPos(x) > MaxXPos Then MaxXPos = SeqXPos(x)
    Next 'X

    ReDim NameWidth(NumberOfSeqs)
    If MaxXPos = 0 Then
        AbortFlag = 1
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        Form1.ProgressBar1 = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
        TBSReps = oReps
        Erase ETSeqNum
        CurrentlyRunningFlag = 0
        Exit Sub
    End If
    DrawXAdjust = (Form2.Picture2(0).ScaleWidth - 70) / (MaxXPos)
    DrawYAdjust = 14
    
    ReDim NodePath(NumberOfSeqs + 1, NumberOfSeqs + 1)

    For x = 0 To NumberOfSeqs

        For Y = 0 To NumberOfSeqs
            NodePath(x, Y) = -1
            
        Next 'Y

    Next 'X
    
    ReDim CxAdd(NumberOfSeqs)
    XX = UBound(NodePath, 1)
    GoOn = 1
    For x = 0 To NumberOfSeqs
        
        For Y = 0 To NumberOfSeqs

            If NodeDepth(x, Y) = -1 Then Exit For
            If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                
            
            'If DoneLine(NodeDepth(X, Y), CxAdd(NodeDepth(X, Y))) = 0 Then
                NodePath(NodeDepth(x, Y), CxAdd(NodeDepth(x, Y))) = x
            '    DoneLine(NodeDepth(X, Y), CxAdd(NodeDepth(X, Y))) = 1
            'Else
            '    X = X
            'End If
            
                CxAdd(NodeDepth(x, Y)) = CxAdd(NodeDepth(x, Y)) + 1 '0
                '0 0,
                '1
                '2 0,
                '3
                '4 0,
                '5
                '6
                '7
                '8
                '9
                '10 0,
                '11 0,
                '12
                '13
                '0 - 10,4,2,0,11,9,1,8,7,12,5,0,0,13
                '1 - 10,4,0,2,11,9,1,8,7,12,5,0,0
                '2 - 0,2,1,0,0,7,8,9,10,11,6
                '3 - 10,4,0,2,11,9,1,8,7,12,0,0
                '4 - 10,4,0,2,11,9,1,8,7,0,0
                '5 - 10,4
                'XX = CxAdd(0)
            Else
                GoOn = 0
                Exit For
                
            End If
        Next 'Y
        If GoOn = 0 Then
            ReDim CxAdd(NumberOfSeqs)
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    NodeDepth(A, b) = NHNodeDepth(A, b)
                Next b
            Next A
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    If NodeDepth(A, b) = -1 Then Exit For
                    If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                        
                    
                   
                        NodePath(NodeDepth(A, b), CxAdd(NodeDepth(A, b))) = A
                    
                    
                        CxAdd(NodeDepth(A, b)) = CxAdd(NodeDepth(A, b)) + 1
                        
                        
                    Else
                        Exit For
                    End If
                Next b
            Next A
            Exit For
        End If

    Next 'X

    
    If (NJF <> 3 And TBSReps < 2) Or (NJF = 3 And BSupTest = 0 And TBSReps < 2) Or ((NJF = 3 Or (NJF = 1 And F2TreeIndex = 3)) And BSTreeStrat = 4) Or (NJF = 3 And BSTreeStrat = 5) Or NJF = 0 Then

        If TBSReps < 2 And ((NJF = 1 And F2TreeIndex <> 3) Or NJF = 2) Then
            Form1.ProgressBar1.Value = 90
            Call UpdateF2Prog
        ElseIf NJF <> 0 Then
            Form1.ProgressBar1.Value = 99
            Call UpdateF2Prog
        End If
        'Dim DXY(numberofseqs, numberofseqs)
        
        'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=string,1 = line,2 = box)
        'D = coordinates/sequence number/colour etc - (0 = startX ccord, 1=startY coord, 2 = endX ccord, 3=endY coord, 4 = colour;
        'E = element number
        
        ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
        
        A = -1: b = -1
        
        
        For x = 0 To UBound(NodeXY, 2)
            NodeXY(NHFlag, x, 0) = -1
            NodeXY(NHFlag, x, 1) = -1
        Next x
        
        
        
        SS = Abs(GetTickCount)
        ReDim NodeMaxRep(NumberOfSeqs + 10, 1)
        ReDim NodeFind(NumberOfSeqs + 2, NumberOfSeqs + 2)
        'XX = UBound(NodeXY, 2)
        UBNXY2 = UBound(NodeXY, 2)
        For x = 0 To NumberOfSeqs + 1
            'For Y = 0 To NumberOfSeqs
            '    NodeFind(X, Y) = 0
            'Next Y
            
            NodeMaxRep(x, 0) = 0
            NodeMaxRep(x, 1) = 0
            If x <= UBNXY2 Then
                NodeXY(NHFlag, x, 0) = 10 + NodeXPos(x) * DrawXAdjust
                NodeXY(NHFlag, x, 1) = 10 + NodeYPos(x) * DrawYAdjust
            End If
        Next x
        
       ' For X = 0 To NumberOfSeqs + 1
       '     NodeXY(NHFlag, X, 0) = 10 + NodeXPos(X) * DrawXAdjust
       '     NodeXY(NHFlag, X, 1) = 10 + NodeYPos(X) * DrawYAdjust
       ' Next X
        
        Dim TreeRY() As Integer, DoneY() As Byte
        ReDim TreeRY(NumberOfSeqs + 1), DoneY(NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 0 To NumberOfSeqs
                If NodeDepth(x, Y) > -1 Then
                    If DoneY(NodeDepth(x, Y)) = 0 Then
                        DoneY(NodeDepth(x, Y)) = 1
                        TreeRY(Y) = x
                    End If
                Else
                    Exit For
                End If
            Next Y
        Next x
        
        If x = 1234 Then
            Dummy = FillNodeMaxRep(F2TreeIndex, UBound(NodeMaxRep, 1), NumberOfSeqs, UBound(NodeFind, 1), UBound(NodeDepth, 1), UBound(TreeRY, 1), UBound(TreeTraceSeqs, 2), UBound(TreeTrace, 1), UBound(SeqCoverage, 1), NodeMaxRep(0, 0), NodeFind(0, 0), TreeRY(0), NodeDepth(0, 0), SeqCoverage(0), TreeTraceSeqs(0, 0), TreeTrace(0))
            
        Else
            
            If DebuggingFlag < 2 Then On Error Resume Next
            UBY = 0: UBX = 0: UB = 0
            UBY = UBound(TreeTraceSeqs, 2)
            UBX = UBound(TreeTraceSeqs, 1)
            UB = UBound(SeqCoverage, 1)
            On Error GoTo 0
            'If F2TreeIndex = 2 Then
            '    X = X
            'End If
            For x = 0 To NumberOfSeqs + 1
                For Y = 0 To NumberOfSeqs + 1
                    If NodeDepth(x, Y) > -1 Then
                        If F2TreeIndex = 0 Or (F2TreeIndex = 3 And (NJF = 0 Or NJF = 1)) Then
                            NodeFind(x, NodeDepth(x, Y)) = 1
                            'If UB >= NodeDepth(X, Y) Then
                            '    If NodeMaxRep(X, 0) < SeqCoverage(NodeDepth(X, Y)) Then NodeMaxRep(X, 0) = SeqCoverage(NodeDepth(X, Y))
                            '    If NodeMaxRep(X, 1) < SeqCoverage(NodeDepth(X, Y)) Then NodeMaxRep(X, 1) = SeqCoverage(NodeDepth(X, Y))
                            'End If
                        Else
                            
                            
                            If NodeDepth(x, Y) <= UBY And UBX > 0 Then
                                If TreeTrace(TreeTraceSeqs(1, NodeDepth(x, Y))) <= UBound(NodeFind, 2) Then
                                    NodeFind(x, TreeTrace(TreeTraceSeqs(1, NodeDepth(x, Y)))) = 1
                                    'If NodeMaxRep(NHFlag, X, TreeTrace(TreetraceSeqs(1, NodeDepth(X, Y)))) < SeqCoverage(TreeTrace(TreetraceSeqs(1, NodeDepth(X, Y)))) Then
                                    '    NodeMaxRep(NHFlag, X, TreeTrace(TreetraceSeqs(1, NodeDepth(X, Y)))) = SeqCoverage(TreeTrace(TreetraceSeqs(1, NodeDepth(X, Y))))
                                    'End If
                                   ' u = 0
                                   ' For G = 0 To Y
                                   '     If NodeDepth(X, G) = TreeRY(X) Then u = 1
                                   ' Next G
                                  '
                                  '
                                  '  If TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y))) <= UB Then
                                  '      If u = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                  '
                                  '          If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y)))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y))))
                                  '      Else
                                  '          If NodeMaxRep(X, 1) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y)))) Then NodeMaxRep(X, 1) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y))))
                                  '      End If
                                  '  End If
                                End If
                            End If
                        End If
                    Else
                        Exit For
                    End If
                Next Y
            
            Next x
        End If
        
        EE = Abs(GetTickCount)
        TT = EE - SS '0.062 for run 9
        x = x
        Dim SeqCoverageX() As Single
        
        If x = 12345 Then 'F2TreeIndex <> 0 And (F2TreeIndex <> 3 Or NJF <> 3 Or BSTreeStrat <> 4) And (NJF <> 1 And F2TreeIndex <> 3) Then
            ReDim SeqCoverageX(NumberOfSeqs)
            For x = 0 To NumberOfSeqs - 1
                SeqCoverageX(x) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, x)))
            Next x
        Else
            ReDim SeqCoverageX(NumberOfSeqs)
            For x = 0 To NumberOfSeqs - 1
                SeqCoverageX(x) = SeqCoverage(x)
            Next x
        End If
        
        ReDim NodeMaxRep(NumberOfSeqs, 1)
        'If F2TreeIndex <> 0 Then
            For x = 0 To NumberOfSeqs - 1 '+ 1 'skip1 because  this is the root node?
                'If X = 20 Then
                '    X = X
                'End If
                For Y = 0 To CxAdd(x) - 1
                    GoOn = 1
                    If DebuggingFlag < 2 Then On Error Resume Next
                    If SeqCoverageX(x) < 0 Then
                        GoOn = 0
                    End If
                    On Error GoTo 0
                    If GoOn = 1 Then
                        If NodeMaxRep(NodePath(x, Y), 0) < SeqCoverageX(x) Then NodeMaxRep(NodePath(x, Y), 0) = SeqCoverageX(x)
                    End If
                    'If NodeFind(X, TreeTrace(TreeTraceSeqs(1, Y))) = 1 Then
                    '    If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y)))
                    'ElseIf NodeFind(X, Y) = 0 Then
                    '    If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y)))
                    'End If
                Next Y
            Next x
       ' End If
        'XX = NodeMaxRep(20, 0)
        'NodeMaxRep(4, 0) = 0.1
        Call WriteNodeFind(NodeFind(), NHFlag)
        
        ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
        
         Dim BkRx As Double, BkGx As Double, BkBx As Double
    
        BkRx = BkR - 10
        BkGx = BkG - 10
        BkBx = BkB - 10
        UBX = UBound(NodeMaxRep, 1)
        A = -1: b = -1
        
        
        
        
        For x = 0 To NumberOfSeqs - 1
'XX = TYF2
         '   If NodeMaxRep(X, 0) < 1 Then
         '       X = X
         '   End If
            For Y = 0 To NumberOfSeqs - 2

                If NodePath(x, Y + 1) > -1 Then
                    
                    If DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 0 Then
                        DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 1
                        A = A + 1
                    
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        
                        If x <= UBX Then
                            TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y), 0), BkGx - BkGx * NodeMaxRep(NodePath(x, Y), 0), BkBx - BkBx * NodeMaxRep(NodePath(x, Y), 0))
                        Else
                            x = x
                        End If
                        
                        A = A + 1
                        If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 4, 1, 4, UBound(TreeDraw, 5) + NextNo)
                        End If
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y + 1)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        If x <= UBX Then
                            TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y), 0), BkGx - BkGx * NodeMaxRep(NodePath(x, Y), 0), BkBx - BkBx * NodeMaxRep(NodePath(x, Y), 0))
                        Else
                            x = x
                        End If
                    Else
                        x = x
                    End If
                ElseIf NodePath(x, Y) > -1 Then
                    A = A + 1
                    'XX = UBound(TreeDraw, 5)
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 4, 1, 4, UBound(TreeDraw, 5) + NextNo)
                        End If
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + SeqYPos(x) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + SeqXPos(x) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If
                    XCord(NJF, F2TreeIndex, x) = NameXPos(x) * DrawXAdjust + 15 + 1
                    YCord(NJF, F2TreeIndex, x) = (SeqYPos(x) * DrawYAdjust + 4)
                    RYCord(NJF, F2TreeIndex, SeqYPos(x)) = x
                    
                    
                    b = b + 1
                    TreeDraw(F2TreeIndex, NJF, 0, 0, b) = XCord(NJF, F2TreeIndex, x)
                    TreeDraw(F2TreeIndex, NJF, 0, 1, b) = YCord(NJF, F2TreeIndex, x)
                    TreeDraw(F2TreeIndex, NJF, 0, 2, b) = x
                    TreeDraw(F2TreeIndex, NJF, 0, 3, b) = -1
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If

                    Exit For
                End If

            Next 'Y

        Next 'X

        
        Form2.Picture2(0).FontSize = 8.25
        ScaleValD = 0.1

        If ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2 Then

            Do While ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2
                ScaleValD = ScaleValD / 2
            Loop

        End If
        
        A = A + 1
        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 5
        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = ((NextNo + 2) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = (NextNo + 2) * DrawYAdjust
        
        ScaleVal = ScaleValD
        ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
        
        b = b + 1
        TreeDraw(F2TreeIndex, NJF, 0, 0, b) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
        TreeDraw(F2TreeIndex, NJF, 0, 1, b) = (NextNo + 2.5) * DrawYAdjust
        TreeDraw(F2TreeIndex, NJF, 0, 2, b) = -1
        TreeDraw(F2TreeIndex, NJF, 0, 3, b) = -ScaleValD * 10000
        
    ElseIf TBSReps > 1 And NJF = 2 Then 'if necessary do BS replicates for fitch trees
        Form1.ProgressBar1.Value = 20
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infile"

        
        Name "outfilex2" As "infile"
        

        On Error GoTo 0
        
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '   Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, BSRndNumSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "l"
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "m"
            Print #1, TBSReps
            Print #1, "3"
            'Print #1, j
            Print #1, "2"
            Print #1, "3"
            Print #1, "y"
        

        Close #1
        
        

        If AbortFlag = 1 Then
            Form2.SSPanel1(0).Enabled = True
            Form2.SSPanel1(1).Enabled = True
            Form2.SSPanel1(2).Enabled = True
            Form2.SSPanel1(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            TBSReps = oReps
            Erase ETSeqNum
            CurrentlyRunningFlag = 0
            Exit Sub
        End If

        BatIndex = 0
        Form1.ProgressBar1.Value = 60
        Form1.SSPanel1.Caption = "Making trees"
        PBStart = Form1.ProgressBar1.Value
        Call UpdateF2Prog
        PBTarget = 90
        BatIndex = 6
       ' Do
        ShellAndClose "neighbor.bat", 0
        
    
        If AbortFlag = 1 Then
              Form2.SSPanel1(0).Enabled = True
            Form2.SSPanel1(1).Enabled = True
            Form2.SSPanel1(2).Enabled = True
            Form2.SSPanel1(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            TBSReps = oReps
            Erase ETSeqNum
            CurrentlyRunningFlag = 0
            Exit Sub
        End If

        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infile"
        Name "outtree" As "infile"
        On Error GoTo 0
        x = x
    End If
    
    If (((NJF = 1 And F2TreeIndex <> 3) Or NJF = 2) And TBSReps >= 2) Or NJF = 4 Or ((NJF = 3 Or (NJF = 1 And F2TreeIndex = 3)) And (BSupTest < 0 Or TBSReps >= 2 Or BSTreeStrat = 5)) Or NJF = 0 Then
        'find the outgroup position in tree 0
        
        'THIS SHOULD ALWAYS BE NEXTNO+1 IF INITIAL OUTGROUPING WAS MADE
    
         
        'Pos = InStr(1, NHString(NHFlag), "S", vbBinaryCompare)
        'LastPos = Pos + 1
        
        
        
        'NLen = CInt(Log10(Nextno + 1)) + 1
        'numb = 0
        'Do While Pos > 0
        '    xxxx = Mid$(NHString(NHFlag), Pos + 1, NLen)
        '    If Val(Mid$(NHString(NHFlag), Pos + 1, NLen)) = Outie Then
        '        toutie = numb + 1
        '        Exit Do
         '   Else
        '        numb = numb + 1
        '    End If
        '    Pos = InStr(LastPos, NHString(NHFlag), "S", vbBinaryCompare)
        '    'Exit Sub
        '    LastPos = Pos + 1
        '
        '
         'Loop
        toutie = NextNo + 1
        If NJF = 4 Or NJF = 0 Or (NJF = 3 And BSTreeStrat = 5) Then
        
        Else
            Form1.SSPanel1.Caption = "Making Consensus"
            Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
            If Dir("infile") = "" Then
                x = x
                Sleep 100
                DoEvents
            End If
            ShellAndClose "consense.bat >NUL", 0
    'Loop
            If DebuggingFlag < 2 Then On Error Resume Next
            If Dir("outfile") <> "" Then
                Name "outfile" As "outfilex"
            End If
            FF = FreeFile
            Open "treefile" For Input As #FF
            xxz = 0
            xxz = LOF(FF)
            If xxz = 0 Then 'something went wrong with consense
                Close #FF
                'retry with a different root
                Call MakeConsenseFiles(0)
                If Dir("infile") <> "" Then
                
                End If
                On Error Resume Next
                Kill "outfilex"
                On Error GoTo 0
                ShellAndClose "consense.bat >NUL", 0
                Name "outfile" As "outfilex"
            
                FF = FreeFile
                Open "treefile" For Input As #FF
                xxz = 0
                xxz = LOF(FF)
                If xxz = 0 Then
                    Close #FF
                    FF = FreeFile
                    If DebuggingFlag < 2 Then On Error Resume Next
                    Open "consense.bat" For Output As #FF
                    Print #FF, "consenseb <optfilec"
                    'Print #FF, "rename outfile outfilex"
                    'Print #FF, "del consense.bat"
                    Close #FF
                    On Error GoTo 0
                    If DebuggingFlag < 2 Then On Error Resume Next
                    KillFile "outfile"
                    KillFile "intree"
                    KillFile "treefile"
                    KillFile "outtree"
                    Name "infile" As "intree"
                    'Kill consense.bat
                    
                    On Error GoTo 0
                    Open "optfilec" For Output As #FF
                    
                    Print #FF, "o"
                    Print #FF, "1"
                    Print #FF, "2"
                    Print #FF, "1"
                    Print #FF, "y"
                    Print #FF, Chr(13)
                    Close #FF
                    If Dir("infile") <> "" Then
                
                End If
                    ShellAndClose "consense.bat >NUL", 0
                    If DebuggingFlag < 2 Then On Error Resume Next
                    Kill "outfilex"
                    Name "outfile" As "outfilex"
                    'try to use consenseb
                    Name "outtree" As "treefile"
                    Open "treefile" For Input As #FF
                    xxf = 0
                    xxf = LOF(FF)
                    
                    On Error GoTo 0
                    
                    
                    
                        If xxf = 0 Then
                            If CLine = "" Or CLine = " " Then
                                MsgBox ("Something has gone wrong with the phylip component 'consense.exe.'  You could try replacing the existing version of the file consense.exe with a newer version (if one exists) or you could try drawing a tree with either a different number of bootstrap replicates or a different tree drawing method.")
                            End If
                            AbortFlag = 1
                            Close #FF
                        Else
                            AbortFlag = 0
                            x = x
                        End If
                   
                End If
            End If
            Close #FF
        End If
        
        
        On Error GoTo 0
        If AbortFlag = 1 Then
            Form2.SSPanel1(0).Enabled = True
            Form2.SSPanel1(1).Enabled = True
            Form2.SSPanel1(2).Enabled = True
            Form2.SSPanel1(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            TBSReps = oReps
            Erase ETSeqNum
            CurrentlyRunningFlag = 0
            Exit Sub
        End If
        If NJF <> 0 Then
            Form1.ProgressBar1.Value = 95
            Call UpdateF2Prog
        Else
            If BusyWithTreeFlag = 0 Then
                Form1.ProgressBar1.Value = 95
                Call UpdateF2Prog
            End If
        End If
        'Open treefile and read in the tree and bootstrap values.
        If NJF = 2 Or (NJF = 1 And F2TreeIndex <> 3) Or ((NJF = 3 Or (NJF = 1 And F2TreeIndex = 3)) And TBSReps > 1 And BSTreeStrat = 4) Then
            
            Call ReadTreeFile(NextNo, 0, 0, "treefile", Getstring, Treebyte())
        
        
            Call MakeBootDepth(TBSReps, NumberOfSeqs, Getstring, LLen(), BootDepth(), Treebyte())
            Dim RevC() As Long
            Call MakeDLen(NumberOfSeqs - 1, DLen(), LLen(), NHNodeDepth(), NodeDepth(), BootDepth(), RevC())
            totbs = 0
            XX = UBound(DLen, 1)
            For x = 0 To XX
                totbs = totbs + DLen(x) '11210,11355,11420,11525,11715,11790,12045
                '14660
                '38.177
                '11835
                '27.14
            Next x
            OldBoot = totbs
            XX = (totbs / NumberOfSeqs) '28.817,29.27,29.51,29.857, 30.428, 30.703,31.53
        ElseIf NJF = 3 Or (NJF = 1 And F2TreeIndex = 3) Or NJF = 0 Then
            If NJF = 0 Then
                For x = 0 To NumberOfSeqs
                    DLen(x) = DLen(x) * 100
                Next x
            ElseIf BSTreeStrat = 5 Or ((BSupTest = 2 Or BSupTest = 1) And BSTreeStrat <> 4) Then
                'For X = 0 To NumberOfSeqs
                '    DLen(X) = (DLen(X) / TBSReps) * 100
                'Next X
            ElseIf BSupTest = 0 Or BSTreeStrat = 3 Then
                For x = 0 To NumberOfSeqs
                    DLen(x) = (DLen(x) / TBSReps) * 100
                Next x
            Else
                'For X = 0 To NumberOfSeqs
                '    DLen(X) = DLen(X) * 100
                'Next X
            End If
        ElseIf NJF = 4 Then
            
            For x = 0 To NumberOfSeqs
                DLen(x) = CInt(DLen(x) * 1000) / 1000
                'DLen(0) = DLen(0) / 100
            Next x
        End If
        
        'Check to make sure that there is something in dlen - for vista and win 7 notjhing in dlen could indicate that the program has not been run with administrator rights
        If TBSReps > 1 Or NJF = 4 Then
            GoOn = 0
            For x = 0 To NumberOfSeqs - 1
                If DLen(x) > 0 Then
                    GoOn = 1
                    Exit For
                End If
            Next x
            If GoOn = 0 And NumberOfSeqs > 3 Then
                
                Response = MsgBox("I am unable to give you any indication of branch support in any trees that I draw because I have not been given administrator access to your computer. I need administrator access in order to shell to external programs (something I need to do to calculate degrees of branch support). Go to the RDP4 web page (http://web.cbio.uct.ac.za/~darren/rdp.html) for simple instructions on how you can run RDP4 with administrator access.", 0, "RDP Warning")

            End If
        End If
        
        'DLen(1) = 50
        Dim LastOpen As Long, LastX As Long
        
        
        
        'Add in bootstrap replicates for NJ, LS and raxml trees
        If (NJF = 1 And F2TreeIndex <> 3) Or NJF = 2 Or ((NJF = 3 Or (NJF = 1 And F2TreeIndex = 3)) And TBSReps > 1 And BSTreeStrat = 4) Then
            'NHString
            Do
                LastOpen = 0
    
                For x = 0 To NumberOfSeqs
    
                    If PNodeStr(x) > LastOpen Then
                        LastOpen = PNodeStr(x)
                        LastX = x
                    End If
    
                Next 'X
                
                If LastOpen > 0 Then
                    'XX = RLLen(LastX)
                    
                    'If RevC(LastX) > 0 And LastOpen <= Len(NHString(NHFlag)) Then 'DLen(RevC(LastX)) > 0 Then ' this used to be dlen but it messed up the nhstring
                    If LastOpen <= Len(NHString(NHFlag)) Then  'DLen(RevC(LastX)) > 0 Then ' this used to be dlen but it messed up the nhstring
                        'XX = Right$(NHString(NHFlag), Len(NHString(NHFlag)) - (LastOpen))
                        NHString(NHFlag) = Left$(NHString(NHFlag), LastOpen) + Trim$(CStr(RevC(LastX))) + Right$(NHString(NHFlag), Len(NHString(NHFlag)) - (LastOpen))
                        'XX = Right$(NHString(NHFlag), Len(NHString(NHFlag)) - (LastOpen))
                       
'                        Open "tester.tre" For Output As #1
'                            Print #1, NHString(6)
'                        Close #1
'                        X = X
                    Else
                        x = x
                    End If
                    PNodeStr(LastX) = -1
                Else
                    Exit Do
                End If
    
            Loop
            
            '0=334-0-11/15
            '1=304-100-1/5
            '2=265-93-2
            '3=106-66-8
            '4=87-35-10/9
            '5=68-63-3
            '6=49-82-4
            '7=30-0-11/15
            '8=257-79-5
            '9=249-83-6
            '10=150-87-13
            '11=241-100-1/5
            '12=182-94-7
            '13=233-35-10/9
            '14=214-29-12
            '15=296-63-14
            
            
            '2-2
            '3-8
            '4-9
            '5-3
            '6-4
            '8-5
            '9-6
            '10-13
            '11-1
            '12-7
            '13-11
            '14-12
            '15-14
            '16-15
            '17-0
            '16-16
            '17-17
            
            'Replace token names
            'If NJF = 1 Then
                Call ReplaceNames(OriginalName(), NumberOfSeqs, NHString(NHFlag))
            'End If
        End If
        

        
        If NJF <> 0 Then
            Form1.ProgressBar1.Value = 100
            Call UpdateF2Prog
        Else
            If BusyWithTreeFlag = 0 Then
                Form1.ProgressBar1.Value = 100
                Call UpdateF2Prog
            End If
        
        End If
        
        
        
        
       'Treedraw(A,B,C,D,E)
        'A = treenumber (0-3)
        'B = treetype (0-3)
        'C = datatype (0=sequencename,1 = line)
        'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = bs value)
        'E = element number
        
        
        
        'This is used to track nodes in the tree
        ReDim NodeMaxRep(NumberOfSeqs + 10, 1)
        If NumberOfSeqs > PermNextno And NumberOfSeqs > NextNo Then
            ReDim NodeFind(NumberOfSeqs + 2, NumberOfSeqs + 2)
        ElseIf PermNextno > NextNo Then
            ReDim NodeFind(PermNextno + 2, PermNextno + 2)
        Else
            ReDim NodeFind(NextNo + 2, NextNo + 2)
        End If
        x = NextNo
        If x = x Then
            Dummy = EmptyNodeFind(NumberOfSequences + 1, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
            
        Else
        
            For x = 0 To NumberOfSeqs + 1
                For Y = 0 To NumberOfSeqs
                    NodeFind(x, Y) = 0
                Next Y
                NodeMaxRep(x, 0) = 0
                NodeMaxRep(x, 1) = 0
            Next x
        End If
        UBNXY2 = UBound(NodeXY, 2)
       For x = 0 To NumberOfSeqs + 1
            If x <= UBNXY2 Then
                NodeXY(NHFlag, x, 0) = 10 + NodeXPos(x) * DrawXAdjust
                NodeXY(NHFlag, x, 1) = 10 + NodeYPos(x) * DrawYAdjust
            End If
        Next x
        
        'Dim TreeRY() As Integer, DoneY() As Byte
        ReDim TreeRY(NumberOfSeqs + 1), DoneY(NumberOfSeqs + 1)
        For x = 0 To NumberOfSeqs
            For Y = 0 To NumberOfSeqs
                If NodeDepth(x, Y) > -1 Then
                    If DoneY(NodeDepth(x, Y)) = 0 Then
                        DoneY(NodeDepth(x, Y)) = 1
                        TreeRY(Y) = x
                    End If
                Else
                    Exit For
                End If
            Next Y
        Next x
        
        If x = 2345 Then
            Dummy = FillNodeMaxRep(F2TreeIndex, UBound(NodeMaxRep, 1), NumberOfSeqs, UBound(NodeFind, 1), UBound(NodeDepth, 1), UBound(TreeRY, 1), UBound(TreeTraceSeqs, 2), UBound(TreeTrace, 1), UBound(SeqCoverage, 1), NodeMaxRep(0, 0), NodeFind(0, 0), TreeRY(0), NodeDepth(0, 0), SeqCoverage(0), TreeTraceSeqs(0, 0), TreeTrace(0))
            
        Else
            'SeqCoverage(9) = 0.1
            'SeqCoverage(13) = 0.1
            'SeqCoverage(14) = 0.1
            If DebuggingFlag < 2 Then On Error Resume Next
            UBY = 0: UBX = 0: UB = 0
            UBY = UBound(TreeTraceSeqs, 2)
            UBX = UBound(TreeTraceSeqs, 1)
            UB = UBound(SeqCoverage, 1)
            On Error GoTo 0
            For x = 0 To NumberOfSeqs + 1
                For Y = 0 To NumberOfSeqs + 1
                    If NodeDepth(x, Y) > -1 Then
                        If F2TreeIndex = 0 Or (F2TreeIndex = 3 And (NJF = 0 Or NJF = 1)) Then
                            NodeFind(x, NodeDepth(x, Y)) = 1
                            'If UB >= NodeDepth(X, Y) Then
                            '    If NodeMaxRep(X, 0) < SeqCoverage(NodeDepth(X, Y)) Then NodeMaxRep(X, 0) = SeqCoverage(NodeDepth(X, Y)) 'seqcoverage needs to be modified to account for the rooting node?
                            '    If NodeMaxRep(X, 1) < SeqCoverage(NodeDepth(X, Y)) Then NodeMaxRep(X, 1) = SeqCoverage(NodeDepth(X, Y))
                            'End If
                        Else
                            
                            
                            If NodeDepth(x, Y) <= UBY Then
                                If TreeTrace(TreeTraceSeqs(1, NodeDepth(x, Y))) <= UBound(NodeFind, 2) Then
                                    NodeFind(x, TreeTrace(TreeTraceSeqs(1, NodeDepth(x, Y)))) = 1
                                   'find out whether "y" is on the upper or lower branch
                                   ' u = 0
                                   ' For G = 0 To Y
                                   '     If NodeDepth(X, G) = TreeRY(X) Then
                                   '         u = 1
                                   '         Exit For
                                   '     End If
                                   ' Next G
                                  '
                                  '
                                  '  If NodeDepth(X, Y) <= UB Or X = X Then
                                  '      If u = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                  '
                                  '          If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y)))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y))))
                                  '      Else
                                  '          If NodeMaxRep(X, 1) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y)))) Then NodeMaxRep(X, 1) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, NodeDepth(X, Y))))
                                  '      End If
                                  '  Else
                                  '      X = X
                                  '  End If
                                End If
                            End If
                        End If
                    Else
                        Exit For
                    End If
                Next Y
            
            Next x
        End If
        
        
        
      '  SeqCoverage(TreeTrace(TreeTraceSeqs(1, 2))) = 0.1
      '  SeqCoverage(TreeTrace(TreeTraceSeqs(1, 3))) = 0.1
      '  SeqCoverage(TreeTrace(TreeTraceSeqs(1, 4))) = 0.1
      '  SeqCoverage(TreeTrace(TreeTraceSeqs(1, 5))) = 0.1
        
        'Dim SeqCoverageX() As Single
        
        If F2TreeIndex <> 0 And x = 12345 Then
            ReDim SeqCoverageX(NumberOfSeqs)
            For x = 0 To NumberOfSeqs - 1
                SeqCoverageX(x) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, x)))
            Next x
        Else
            ReDim SeqCoverageX(NumberOfSeqs)
            For x = 0 To NumberOfSeqs - 1
                SeqCoverageX(x) = SeqCoverage(x)
            Next x
        End If
        
        ReDim NodeMaxRep(NumberOfSeqs, 1)
        'If F2TreeIndex <> 0 Then
            For x = 0 To NumberOfSeqs - 1 '+ 1 'skip1 because  this is the root node?
                'If X = 20 Then
                '    X = X
                'End If
                For Y = 0 To CxAdd(x) - 1
                    
                    If NodeMaxRep(NodePath(x, Y), 0) < SeqCoverageX(x) Then NodeMaxRep(NodePath(x, Y), 0) = SeqCoverageX(x)
                    'If NodeFind(X, TreeTrace(TreeTraceSeqs(1, Y))) = 1 Then
                    '    If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y)))
                    'ElseIf NodeFind(X, Y) = 0 Then
                    '    If NodeMaxRep(X, 0) < SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y))) Then NodeMaxRep(X, 0) = SeqCoverage(TreeTrace(TreeTraceSeqs(1, Y)))
                    'End If
                Next Y
            Next x
       ' End If
        'XX = NodeMaxRep(20, 0)
        'NodeMaxRep(4, 0) = 0.1
        Call WriteNodeFind(NodeFind(), NHFlag)
        
        ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
        
         'Dim BkRx As Double, BkGx As Double, BkBx As Double
    
        BkRx = BkR - 10
        BkGx = BkG - 10
        BkBx = BkB - 10
        UBX = UBound(NodeMaxRep, 1)
        A = -1: b = -1
        
        
        
        
        For x = 0 To NumberOfSeqs - 1
'XX = TYF2
         '   If NodeMaxRep(X, 0) < 1 Then
         '       X = X
         '   End If
            For Y = 0 To NumberOfSeqs - 2

                If NodePath(x, Y + 1) > -1 Then
                    
                    If DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 0 Then
                        DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 1
                        A = A + 1
                    
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        
                        If x <= UBX Then
                            TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y), 0), BkGx - BkGx * NodeMaxRep(NodePath(x, Y), 0), BkBx - BkBx * NodeMaxRep(NodePath(x, Y), 0))
                        Else
                            x = x
                        End If
                        
                        A = A + 1
                        If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 4, 1, 4, UBound(TreeDraw, 5) + NextNo)
                        End If
                        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y + 1)) * DrawXAdjust
                        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                        If x <= UBX Then
                            TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y), 0), BkGx - BkGx * NodeMaxRep(NodePath(x, Y), 0), BkBx - BkBx * NodeMaxRep(NodePath(x, Y), 0))
                        Else
                            x = x
                        End If
                    Else
                        x = x
                    End If
                ElseIf NodePath(x, Y) > -1 Then
                    A = A + 1
                    'XX = UBound(TreeDraw, 5)
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                            ReDim Preserve TreeDraw(3, 4, 1, 4, UBound(TreeDraw, 5) + NextNo)
                        End If
                    TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 1, A) = 10 + SeqYPos(x) * DrawYAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 10 + SeqXPos(x) * DrawXAdjust
                    TreeDraw(F2TreeIndex, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If
                    XCord(NJF, F2TreeIndex, x) = NameXPos(x) * DrawXAdjust + 15 + 1
                    YCord(NJF, F2TreeIndex, x) = (SeqYPos(x) * DrawYAdjust + 4)
                    RYCord(NJF, F2TreeIndex, SeqYPos(x)) = x
                    
                    
                    b = b + 1
                    TreeDraw(F2TreeIndex, NJF, 0, 0, b) = XCord(NJF, F2TreeIndex, x)
                    TreeDraw(F2TreeIndex, NJF, 0, 1, b) = YCord(NJF, F2TreeIndex, x)
                    TreeDraw(F2TreeIndex, NJF, 0, 2, b) = x
                    TreeDraw(F2TreeIndex, NJF, 0, 3, b) = -1
                    If x <= UBX Then
                        TreeDraw(F2TreeIndex, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverageX(x), BkGx - BkGx * SeqCoverageX(x), BkBx - BkBx * SeqCoverageX(x))
                    Else
                        x = x
                    End If

                    Exit For
                End If

            Next 'Y

        Next 'X


        For x = 1 To NumberOfSeqs - 2
            
            If DLen(x) > 0 Then
                
                b = b + 1
                TreeDraw(F2TreeIndex, NJF, 0, 0, b) = NodeXPos(x) * DrawXAdjust + 10
                TreeDraw(F2TreeIndex, NJF, 0, 1, b) = (NodeYPos(x) * DrawYAdjust + 3 + 3)
                TreeDraw(F2TreeIndex, NJF, 0, 2, b) = -1
                TreeDraw(F2TreeIndex, NJF, 0, 3, b) = DLen(x)
                
            End If

        Next 'X
        
        
       
        
        
        Form2.Picture2(0).FontSize = 8.25
        
        ScaleValD = 0.1
        
        If (ScaleValD * DrawXAdjust) > (Form2.Picture2(0).ScaleWidth / 2) Then

            Do While ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2
                ScaleValD = ScaleValD / 2
            Loop

        End If

        
        A = A + 1
        TreeDraw(F2TreeIndex, NJF, 1, 0, A) = 5
        TreeDraw(F2TreeIndex, NJF, 1, 1, A) = ((NextNo + 2) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
        TreeDraw(F2TreeIndex, NJF, 1, 3, A) = (NextNo + 2) * DrawYAdjust
        
        ScaleVal = ScaleValD
        ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
        
        b = b + 1
        TreeDraw(F2TreeIndex, NJF, 0, 0, b) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
        TreeDraw(F2TreeIndex, NJF, 0, 1, b) = ((NextNo + 2.5) * DrawYAdjust)
        TreeDraw(F2TreeIndex, NJF, 0, 2, b) = -1
        TreeDraw(F2TreeIndex, NJF, 0, 3, b) = -ScaleValD * 10000
        If NJF <> 0 Or (NJF = 0 And BusyWithTreeFlag = 0) Then
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog
        End If
    Else
        
        Call ReplaceNames(OriginalName(), NumberOfSeqs, NHString(NHFlag))
    End If 'finished replicates
    
    
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB()) 'treedrawb allows quicker access during tree drawing
    
    
    TDLen(F2TreeIndex, NJF, 1) = A
    TDLen(F2TreeIndex, NJF, 0) = b
    TDLen(F2TreeIndex, NJF, 2) = Form2.Picture2(0).ScaleWidth
    
    TreeDrawColBakFlag(F2TreeIndex) = 0
    'Call treedrawing(0,0,treeblocksl(), TBLLen, 0, originalname(), 0, F2TreeIndex, NJF, treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.picture2(0))
    If NJF <> 0 Or (NJF = 0 And BusyWithTreeFlag = 0) Then
        Form2.SSPanel3.Caption = ""
        Form2.ProgressBar1 = 0
    End If
    
    DoneTree(NJF, F2TreeIndex) = 1
    

    'Store info for making a metafile
    If NextNo > UBound(NodePath, 2) Then Call ModNextno
    If UBound(SNodeXPos, 2) < NextNo Then
        ReDim Preserve SNodeXPos(UBound(SNodeXPos, 1), NextNo + 1)
    End If
    If UBound(SNodeYPos, 2) < NextNo Then
        ReDim Preserve SNodeYPos(UBound(SNodeYPos, 1), NextNo + 1)
    End If
    If UBound(SSeqXPos, 2) < NextNo Then
        ReDim Preserve SSeqXPos(UBound(SSeqXPos, 1), NextNo + 1)
    End If
    If UBound(SSeqYPos, 2) < NextNo Then
        ReDim Preserve SSeqYPos(UBound(SSeqYPos, 1), NextNo + 1)
    End If
    If UBound(SDLen, 2) < NextNo Then
        ReDim Preserve SDLen(UBound(SDLen, 1), NextNo + 1)
    End If
    For x = 0 To NextNo

        If x <= UBound(NodeXPos, 1) Then
            SNodeXPos(NHFlag, x) = NodeXPos(x)
        End If
        If x <= UBound(NodeYPos, 1) Then
            SNodeYPos(NHFlag, x) = NodeYPos(x)
        End If
        If x <= UBound(SeqXPos, 1) Then
            SSeqXPos(NHFlag, x) = SeqXPos(x)
        End If
        If x <= UBound(SeqYPos, 1) Then
            SSeqYPos(NHFlag, x) = SeqYPos(x)
        End If
        If x <= UBound(DLen, 1) Then
            SDLen(NHFlag, x) = DLen(x)
        End If
    Next 'X
    
    Call WritesNodePath(NodePath(), NHFlag)
    
    If DebuggingFlag < 2 Then On Error Resume Next
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
    Form2.SSPanel1(0).Enabled = True
    Form2.SSPanel1(1).Enabled = True
    Form2.SSPanel1(2).Enabled = True
    Form2.SSPanel1(3).Enabled = True
    
    Form1.SSPanel6(1).Enabled = True
    Form2.Picture2(0).Enabled = True
    
    Form2.Command2.Enabled = False
     TBSReps = oReps
     Erase ETSeqNum
     CurrentlyRunningFlag = 0
End Sub
Public Sub AutoFindGenes()

    Dim MaxFrame() As Double, MaxFrame2() As Double, Frames() As Long, Frames2() As Single, ConsFrames() As Double, ConsFrames2() As Double, RevComp() As Integer, MarkStops() As Byte, DistStops, CN As Long
    ReDim MaxFrame2(1, Len(StrainSeq(0)), NextNo), MaxFrame(1, Len(StrainSeq(0)), NextNo), ConsFrames(1, Len(StrainSeq(0))), ConsFrames2(1, Len(StrainSeq(0))), Frames(6, Len(StrainSeq(0)), NextNo), Frames2(6, Len(StrainSeq(0)), NextNo), RevComp(Len(StrainSeq(0)), NextNo), MarkStops(6, Len(StrainSeq(0)), NextNo)
    'make revcomp
    
    For x = 0 To NextNo
        Z = 1
        For Y = Len(StrainSeq(0)) To 1 Step -1
            If SeqNum(Y, x) = 66 Then
                RevComp(Z, x) = 85
            ElseIf SeqNum(Y, x) = 68 Then
                RevComp(Z, x) = 72
            ElseIf SeqNum(Y, x) = 72 Then
                RevComp(Z, x) = 68
            ElseIf SeqNum(Y, x) = 85 Then
                RevComp(Z, x) = 66
            Else
                RevComp(Z, x) = 46
            End If
            Z = Z + 1
        Next Y
    Next x
    
    
 'make sure the revcomp is correct
If x = x Then
    Open "test.fas" For Output As #1
    Dim TS As String
    For x = 0 To NextNo
       TS = ""
       For Y = 1 To Len(StrainSeq(x))
           If RevComp(Y, x) = 66 Then
               TS = TS + "A"
           ElseIf RevComp(Y, x) = 68 Then
               TS = TS + "C"
           ElseIf RevComp(Y, x) = 72 Then
               TS = TS + "G"
           ElseIf RevComp(Y, x) = 85 Then
               TS = TS + "T"
           Else
               TS = TS + "-"
           End If
       Next Y
       Print #1, ">" + StraiName(x)
       Print #1, TS
    Next x
    Close #1
End If
    
'First do forward frames
Call MarkStopCodons(0, SeqNum(), MarkStops())
'Then reverse ones
Call MarkStopCodons(3, RevComp(), MarkStops())

Dim LenORF As Long, LastStop As Long

Call MapORFLen(0, SeqNum(), MarkStops(), Frames())

Call MapORFLen(3, RevComp(), MarkStops(), Frames())
'Work out antibiasing Adjustment
Dim ABias() As Double
ReDim ABias(NextNo)



For x = 0 To NextNo
    For Y = x + 1 To NextNo
        If Distance(x, Y) < MinDist Then MinDist = Distance(x, Y)
    Next Y
Next x
MinDist = 1 - MinDist

'Open "test.csv" For Output As #1
For x = 0 To NextNo
    For Y = 0 To NextNo
        ABias(x) = ABias(x) + (1 - Distance(x, Y)) / MinDist
    Next Y
    ABias(x) = ABias(x) / (NextNo - 1)
'    Print #1, ABias(X)
Next x

If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If

'Close #1
Dim TotABias As Double
TotABias = 0
For x = 0 To NextNo
    TotABias = TotABias + ABias(x)
Next x
For x = 0 To NextNo
    ABias(x) = ABias(x) / TotABias
Next x

Dim MHS As Double
MHS = 0
For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
    
        For Z = 0 To 2
            MaxFrame(0, Y, x) = MaxFrame(0, Y, x) + Frames(Z, Y, x) * ABias(x)
        Next Z
        ConsFrames(0, Y) = ConsFrames(0, Y) + MaxFrame(0, Y, x)
        If MHS < ConsFrames(0, Y) Then MHS = ConsFrames(0, Y)
        b = Len(StrainSeq(0)) - Y + 1
        If b = 800 Then
            x = x
        End If
        For Z = 3 To 5
            MaxFrame(1, b, x) = MaxFrame(1, b, x) + Frames(Z, Y, x) * ABias(x)
        Next Z
        ConsFrames(1, b) = ConsFrames(1, b) + MaxFrame(1, b, x)
        If MHS < ConsFrames(1, b) Then MHS = ConsFrames(1, b)
    Next Y
Next x

Form1.Picture7.AutoRedraw = True
Form1.Picture7.Picture = LoadPicture()
Form1.Picture7.ScaleMode = 3
Dim XAdj As Double, ColX As Byte
XAdj = Len(StrainSeq(0)) / (Form1.Picture7.ScaleWidth - 100)
For x = 1 To Len(StrainSeq(0))
    ColX = (ConsFrames(0, x) / MHS) * 255
    Form1.Picture7.Line (x / XAdj, 10)-(x / XAdj, 20), RGB(ColX, ColX, ColX)
    ColX = (ConsFrames(1, x) / MHS) * 255
    Form1.Picture7.Line (x / XAdj, 30)-(x / XAdj, 40), RGB(ColX, ColX, ColX)
Next x




Form1.Picture7.Refresh

Dim UFrame() As Double, CodonPos(2) As Long, NDiff As Long, NumSyn(4, 4, 4) As Double


ReDim UFrame(1, Len(StrainSeq(0)))




Call CalcDNDS(0, SeqNum(), UFrame)

Call CalcDNDS(1, RevComp(), UFrame)



Call MapORFDNDS(0, SeqNum(), MarkStops(), Frames2(), UFrame())
Call MapORFDNDS(3, RevComp(), MarkStops(), Frames2(), UFrame())



Dim LowS As Double, MHSX As Double, MinX As Double

MHSX = 0
MinX = 100000
For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        If Y = 165 Then
            x = x
        End If
        LowS = 10000000
        For Z = 0 To 2
            If Frames2(Z, Y, x) > 0 And Frames2(Z, Y, x) < LowS Then
                LowS = Frames2(Z, Y, x) 'MaxFrame2(0, Y, X) = MaxFrame2(0, Y, X) + (1 / Frames2(Z, Y, X)) * ABias(X)
            End If
        Next Z
        If LowS < 10000 Then
            ConsFrames2(0, Y) = ConsFrames2(0, Y) + LowS * ABias(x)
        
            If MHSX < ConsFrames2(0, Y) Then MHSX = ConsFrames2(0, Y)
            If MinX > ConsFrames2(0, Y) Then MinX = ConsFrames2(0, Y)
        End If
        b = Len(StrainSeq(0)) - Y + 1
        LowS = 1000000
        For Z = 3 To 5
            If Frames2(Z, Y, x) > 0 And Frames2(Z, Y, x) < LowS Then
                LowS = Frames2(Z, Y, x)
            End If
        Next Z
        If LowS < 10000 Then
            ConsFrames2(1, b) = ConsFrames2(1, b) + LowS * ABias(x)
            If MHSX < ConsFrames2(1, b) Then MHSX = ConsFrames2(1, b)
            If MinX > ConsFrames2(1, b) Then MinX = ConsFrames2(1, b)
        End If
    Next Y
Next x

Form1.Picture7.AutoRedraw = True

Form1.Picture7.ScaleMode = 3

XAdj = Len(StrainSeq(0)) / (Form1.Picture7.ScaleWidth - 100)
For x = 1 To Len(StrainSeq(0))
    ColX = 255 - ((ConsFrames2(0, x) - MinX) / (MHSX - MinX)) * 255
    Form1.Picture7.Line (x / XAdj, 50)-(x / XAdj, 60), RGB(ColX, ColX, ColX)
    ColX = 255 - ((ConsFrames2(1, x) - MinX) / (MHSX - MinX)) * 255
    Form1.Picture7.Line (x / XAdj, 70)-(x / XAdj, 80), RGB(ColX, ColX, ColX)
Next x

If x = x Then
    Dim Frames3() As Double
    ReDim Frames3(6, Len(StrainSeq(0)), NextNo)
    
        For x = 0 To NextNo
            For Y = 1 To Len(StrainSeq(0))
                For Z = 0 To 5
                    If Y = 165 Then
                        x = x
                    End If
                    If Frames2(Z, Y, x) > 0 And Frames2(Z, Y, x) < 1 Then
                        Frames3(Z, Y, x) = (Frames(Z, Y, x) * (1 - Frames2(Z, Y, x)))
                    
                    End If
                Next Z
            Next Y
        Next x
    
    
    
    ReDim MaxFrame(1, Len(StrainSeq(0)), NextNo), ConsFrames(1, Len(StrainSeq(0)))
        'make revcomp
    MHS = 0
    
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            MHSX = 0
            For Z = 0 To 2
                If MHSX < Frames3(Z, Y, x) Then MHSX = Frames3(Z, Y, x)
            Next Z
            ConsFrames(0, Y) = ConsFrames(0, Y) + MHSX
            If MHS < ConsFrames(0, Y) Then MHS = ConsFrames(0, Y)
            b = Len(StrainSeq(0)) - Y + 1
            
            HSX = 0
            For Z = 3 To 5
                If MHSX < Frames3(Z, Y, x) Then MHSX = Frames3(Z, Y, x)
            Next Z
            ConsFrames(1, b) = ConsFrames(1, b) + MHSX
            If MHS < ConsFrames(1, b) Then MHS = ConsFrames(1, b)
        Next Y
    Next x
    
    Form1.Picture7.AutoRedraw = True
    Form1.Picture7.ScaleMode = 3
    MHS = 0
    MinX = 10000000
    For x = 1 To Len(StrainSeq(0))
        For Y = 0 To 1
            ConsFrames(Y, x) = Log10(ConsFrames(Y, x))
            If ConsFrames(Y, x) > MHS Then MHS = ConsFrames(Y, x)
            If ConsFrames(Y, x) < MinX Then MinX = ConsFrames(Y, x)
        Next Y
    Next x
    For x = 1 To Len(StrainSeq(0))
        ColX = ((ConsFrames(0, x) - MinX) / (MHS - MinX)) * 255
        Form1.Picture7.Line (x / XAdj, 90)-(x / XAdj, 100), RGB(ColX, ColX, ColX)
        ColX = ((ConsFrames(1, x) - MinX) / (MHS - MinX)) * 255
        Form1.Picture7.Line (x / XAdj, 110)-(x / XAdj, 120), RGB(ColX, ColX, ColX)
    Next x

Else

    For x = 1 To Len(StrainSeq(0))
        For Y = 0 To 1
            ConsFrames(Y, x) = ConsFrames(Y, x) / ConsFrames2(Y, x)
        Next Y
    Next x
    MHS = 0
    MinX = 10000000
    For x = 1 To Len(StrainSeq(0))
        For Y = 0 To 1
            ConsFrames(Y, x) = Log10(ConsFrames(Y, x))
            If ConsFrames(Y, x) > MHS Then MHS = ConsFrames(Y, x)
            If ConsFrames(Y, x) < MinX Then MinX = ConsFrames(Y, x)
        Next Y
    Next x
    For x = 1 To Len(StrainSeq(0))
        ColX = ((ConsFrames(0, x) - MinX) / (MHS - MinX)) * 255
        Form1.Picture7.Line (x / XAdj, 90)-(x / XAdj, 100), RGB(ColX, ColX, ColX)
        ColX = ((ConsFrames(1, x) - MinX) / (MHS - MinX)) * 255
        Form1.Picture7.Line (x / XAdj, 110)-(x / XAdj, 120), RGB(ColX, ColX, ColX)
    Next x
End If

'Dim WinSize As Long, UFrameSmooth() As Double, MaxV As Double, MinV As Double
'ReDim UFrameSmooth(1, Len(StrainSeq(0)))
'MaxV = 0
'MinV = 100000
'WinSize = 100


'Call MakeUframeSmooth(0, WinSize, MaxV, MinV, UFrame(), UFrameSmooth())
'Call MakeUframeSmooth(1, WinSize, MaxV, MinV, UFrame(), UFrameSmooth())

Dim Frames4() As Long
ReDim Frames4(6, Len(StrainSeq(0)), NextNo)
'Find supported URFs & ORFs in each and every sequence
Call FindORF(0, Frames(), Frames4(), SeqNum())
Call FindORF(3, Frames(), Frames4(), RevComp())


ReDim MaxFrame(1, Len(StrainSeq(0)), NextNo), ConsFrames(1, Len(StrainSeq(0)))
MHS = 0
For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
    
        For Z = 0 To 2
            MaxFrame(0, Y, x) = MaxFrame(0, Y, x) + Frames4(Z, Y, x) * ABias(x)
        Next Z
        ConsFrames(0, Y) = ConsFrames(0, Y) + MaxFrame(0, Y, x)
        If MHS < ConsFrames(0, Y) Then MHS = ConsFrames(0, Y)
        b = Len(StrainSeq(0)) - Y + 1
        If b = 800 Then
            x = x
        End If
        For Z = 3 To 5
            MaxFrame(1, b, x) = MaxFrame(1, b, x) + Frames4(Z, Y, x) * ABias(x)
        Next Z
        ConsFrames(1, b) = ConsFrames(1, b) + MaxFrame(1, b, x)
        If MHS < ConsFrames(1, b) Then MHS = ConsFrames(1, b)
    Next Y
Next x


For x = 1 To Len(StrainSeq(0))
    ColX = (ConsFrames(0, x) / MHS) * 255
    Form1.Picture7.Line (x / XAdj, 130)-(x / XAdj, 140), RGB(ColX, ColX, ColX)
    ColX = (ConsFrames(1, x) / MHS) * 255
    Form1.Picture7.Line (x / XAdj, 150)-(x / XAdj, 160), RGB(ColX, ColX, ColX)
Next x

'For X = 1 To Len(StrainSeq(0))
'    ColX = ((UFrameSmooth(0, X) - MinV) / (MaxV - MinV)) * 255
'    Form1.Picture7.Line (X / XAdj, 50)-(X / XAdj, 60), RGB(ColX, ColX, ColX)
'    ColX = ((UFrameSmooth(1, X) - MinV) / (MaxV - MinV)) * 255
'    Form1.Picture7.Line (X / XAdj, 70)-(X / XAdj, 80), RGB(ColX, ColX, ColX)
'Next X

Form1.Picture7.Refresh



Dim MaxSize As Long, DoneFrame() As Byte, StartZ As Byte, StartY As Long, StartX As Long, EndY As Long, SeqList() As Long, SeqListLen As Long
ReDim DoneFrame(5, Len(StrainSeq(0)), NextNo)
MaxSize = 0
GoOn = 1

Dim Valid As Long, Match As Long, MaxFrameX As Long, WinFrameX
ReDim DoneFrame(5, Len(StrainSeq(0)), NextNo)
Do While GoOn = 1
    GoOn = 0
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            For Z = 0 To 2
                If Frames(Z, Y, x) > MaxSize And DoneFrame(Z, Y, x) = 0 Then
                    MaxSize = Frames(Z, Y, x)
                    StartX = x
                    StartY = Y
                    StartZ = Z
                    GoOn = 1
                    
                ElseIf Frames(Z, Y, x) = MaxSize And x = StartX Then
                    EndY = Y
                End If
            Next Z
        
        Next Y
    
    Next x
    
    
    If StartY = 1 And EndY = Len(StrainSeq(0)) Then
        For Y = 1 To Len(StrainSeq(0))
            If Frames(StartZ, Y, StartX) <> MaxSize Then
                Exit For
            End If
        Next Y
        EndY = Y - 1
        For Y = Len(StrainSeq(0)) To 1 Step -1
            If Frames(StartZ, Y, StartX) <> MaxSize Then
                Exit For
            End If
        Next Y
        StartY = Y + 1
    End If
    'check for >50% identity with the top hit.
    
    
    ReDim SeqList(3, NextNo)
    SeqListLen = 0
    For x = 0 To NextNo
        Match = 0
        Valid = 0
        MaxFrameX = 0
        If StartY < EndY Then
            
            For Y = StartY To EndY
               
               If SeqNum(Y, x) > 50 And SeqNum(Y, StartX) > 50 Then
                    Valid = Valid + 1
                    If SeqNum(Y, x) = SeqNum(Y, StartX) Then
                        Match = Match + 1
                    End If
               End If
               For A = 0 To 5
                    If MaxFrameX < Frames(A, Y, x) And DoneFrame(A, Y, x) = 0 Then
                        MaxFrameX = Frames(A, Y, x)
                        WinFrameX = A
                        
                    End If
               Next A
            Next Y
        Else
            For Y = 1 To EndY
                If SeqNum(Y, x) > 50 And SeqNum(Y, StartX) > 50 Then
                    Valid = Valid + 1
                    If SeqNum(Y, x) = SeqNum(Y, StartX) Then
                        Match = Match + 1
                    End If
               End If
               For A = 0 To 5
                    If MaxFrameX < Frames(A, Y, x) And DoneFrame(A, Y, x) = 0 Then
                        MaxFrameX = Frames(A, Y, x)
                        WinFrameX = A
                        
                    End If
               Next A
            Next Y
            
            For Y = StartY To Len(StrainSeq(0))
                If SeqNum(Y, x) > 50 And SeqNum(Y, StartX) > 50 Then
                    Valid = Valid + 1
                    If SeqNum(Y, x) = SeqNum(Y, StartX) Then
                        Match = Match + 1
                    End If
               End If
               For A = 0 To 5
                    If MaxFrameX < Frames(A, Y, x) And DoneFrame(A, Y, x) = 0 Then
                        MaxFrameX = Frames(A, Y, x)
                        WinFrameX = A
                        
                    End If
               Next A
            Next Y
        End If
        
        If (Match / Valid) > 0.5 Then
            SeqList(0, SeqListLen) = x
            SeqListLen = SeqListLen + 1
            For Y = 1 To Len(StrainSeq(0))
                If Frames(WinFrameX, Y, x) = MaxFrameX Then
                    SeqList(1, SeqListLen) = Y
                    Exit For
                End If
            Next Y
            If Y > 1 Then ' the real beginning has been found
                For Y = Y + 1 To Len(StrainSeq(0))
                    If Frames(WinFrameX, Y, x) <> MaxFrameX Then
                        SeqList(2, SeqListLen) = Y - 1
                        Exit For
                    End If
                Next Y
                For Y = SeqList(1, SeqListLen) To SeqList(2, SeqListLen)
                    
                Next Y
            Else
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If Frames(WinFrameX, Y, x) <> MaxFrameX Then
                        SeqList(1, SeqListLen) = Y + 1
                        Exit For
                    End If
                Next Y
                For Y = 1 To Len(StrainSeq(0))
                    If Frames(WinFrameX, Y, x) <> MaxFrameX Then
                        SeqList(2, SeqListLen) = Y - 1
                        Exit For
                    End If
                Next Y
            End If
            If SeqList(2, SeqListLen) > SeqList(1, SeqListLen) Then
                For Y = SeqList(1, SeqListLen) To SeqList(2, SeqListLen)
                    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                    'This is where I should pull out the sequences for re alignment
                    '''''''''''''''''''''''''''''''''''''''''''''''''''''''
                    DoneFrame(WinFrameX, Y, x) = 1
                Next Y
            End If
        End If
        
    Next x
    
    
    x = x
Loop


End Sub
Public Sub FindORF(StartD, Frames() As Long, Frames4() As Long, SeqNum() As Integer)


Dim NucNum As Long, NTS(2), MarkGeneFlag As Long, StartORF As Long
For x = 0 To NextNo
    For Z = StartD To StartD + 1
        MarkGeneFlag = 0
        For Y = 1 To Len(StrainSeq(0))
                If Y = 156 Then
                    x = x
                End If
                If Frames(Z, Y, x) > 0 And SeqNum(Y, x) > 50 Then
                    A = Y
                    NucNum = 0
                    Do While Frames(Z, Y, x) = Frames(Z, A, x)
                        If SeqNum(A, x) > 50 Then
                            NTS(NucNum) = Nucs(SeqNum(A, x))
                            If NucNum = 2 Then
                                If NTS(0) = 1 And NTS(1) = 4 And NTS(2) = 3 Then 'i.e. its an ATG
                                    If A = 161 Then
                                        x = x
                                    End If
                                    MarkGeneFlag = 1
                                    A = A + 1
                                    Exit Do
                                End If
                                NucNum = 0
                            Else
                                NucNum = NucNum + 1
                            End If
                        End If
                        
                        
                        A = A + 1
                        If A > Len(StrainSeq(0)) Then Exit Do
                    Loop
                    If MarkGeneFlag = 1 Then
                        LenORF = 3 ' (i.e. the ATG is the first codon)
                        StartORF = A - 3
                        'XX = SeqNum(StartORF + 2, X)
                        Do While Frames(Z, Y, x) = Frames(Z, A, x)
                            LenORF = LenORF + 1
                            
                            
                            A = A + 1
                            If A = Len(StrainSeq(0)) Then A = 1
                        Loop
                        For b = StartORF To A - 1
                            Frames4(Z, b, x) = LenORF
                        Next b
                        If A >= Y Then
                            Y = A - 1
                        Else
                            Y = Len(StrainSeq(0))
                        End If
                        
                        MarkGeneFlag = 0
                    End If
                End If
            
        Next Y
    Next Z
Next x



End Sub
Public Sub MapORFLen(OffsetX, SeqNum() As Integer, MarkStops() As Byte, Frames() As Long)

For Z = OffsetX To OffsetX + 2
    For x = 0 To NextNo
        LenORF = 0
        LastStop = 0
        For Y = 1 To Len(StrainSeq(0)) * 2
            If Y > Len(StrainSeq(0)) Then
                b = Y - Len(StrainSeq(0))
                
            Else
                b = Y
            End If
            If MarkStops(Z, b, x) = 0 Then ' no stop detected
                If SeqNum(b, x) > 50 Then ' it is a nucleotide
                    LenORF = LenORF + 1
                End If
            Else
                For A = LastStop + 1 To Y - 1
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                        
                    Else
                        b = A
                    End If
                    Frames(Z, b, x) = LenORF
                Next A
                LastStop = Y
                LenORF = 0
                If Y > Len(StrainSeq(0)) Then Exit For
            End If
        Next Y
    Next x
Next Z

End Sub
Public Sub MapORFDNDS(OffsetX, SeqNum() As Integer, MarkStops() As Byte, Frames2() As Single, UFrame() As Double)

Dim DirectionX As Byte, TotDNDS As Double, CodonPos As Byte
If OffsetX = 0 Then DirectionX = 0
If OffsetX = 3 Then DirectionX = 1


For Z = OffsetX To OffsetX + 2
    CodonPos = 0
    For x = 0 To NextNo
        LenORF = 0
        LastStop = 0
        TotDNDS = 0
        For Y = 1 To Len(StrainSeq(0)) * 2
            If Y = 165 Then
                x = x
            End If
            If Y > Len(StrainSeq(0)) Then
                b = Y - Len(StrainSeq(0))
                
            Else
                b = Y
            End If
            If MarkStops(Z, b, x) = 0 Then ' no stop detected
                If SeqNum(b, x) > 50 Then ' it is a nucleotide
                    If CodonPos = 0 And b = 165 Then
                        x = x
                    End If
                    If UFrame(DirectionX, b) > 0 And CodonPos = 0 Then
                        LenORF = LenORF + 1
                        TotDNDS = TotDNDS + UFrame(DirectionX, b)
                    End If
                    CodonPos = CodonPos + 1
                    If CodonPos = 3 Then CodonPos = 0
                End If
            Else
                For A = LastStop + 1 To Y - 1
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                        
                    Else
                        b = A
                    End If
                    If LenORF > 0 Then
                        Frames2(Z, b, x) = TotDNDS / LenORF
                    Else
                        Frames2(Z, b, x) = 1
                    End If
                    
                    x = x
                Next A
                LastStop = Y
                LenORF = 0
                TotDNDS = 0
                If Y > Len(StrainSeq(0)) Then Exit For
            End If
        Next Y
    Next x
Next Z

End Sub
Public Sub MakeUframeSmooth(Direction, WinSize, MaxV, Minv, UFrame() As Double, UFrameSmooth() As Double)

Dim Totvalid As Long, Totscore As Double

For x = 1 To Len(StrainSeq(0))
    Totscore = 0
    Totvalid = 0
    
    For Y = x - WinSize / 2 To x + WinSize / 2
        If Y < 1 Then
            A = Len(StrainSeq(0)) + Y
        ElseIf Y > Len(StrainSeq(0)) Then
            A = Y - Len(StrainSeq(0))
        Else
            A = Y
        End If
        If UFrame(0, A) > 0 Then
            Totvalid = Totvalid + 1
            Totscore = Totscore + UFrame(0, A)
        End If
    Next Y
    
    If Direction = 1 Then
        Z = Len(StrainSeq(0)) - x + 1
    Else
        Z = x
    End If
    If Totvalid > 0 Then
        UFrameSmooth(Direction, Z) = Totscore / Totvalid
    Else
        UFrameSmooth(Direction, Z) = 1
    End If
    If UFrameSmooth(Direction, Z) > MaxV Then MaxV = UFrameSmooth(Direction, Z)
    If UFrameSmooth(Direction, Z) < Minv Then Minv = UFrameSmooth(Direction, Z)
Next x

End Sub


Public Sub CalcDNDS(Direction, SeqNum() As Integer, UFrame() As Double)


For Y = 1 To Len(StrainSeq(0)) - 2
    'If Y = 165 Then
    '    X = X
    'End If
    Dim DoneOne() As Byte, CodonPos(2) As Long, NDiff As Long, pSyn As Double, pnSyn As Double, Syn As Double, nSyn As Double, NumSyn(4, 4, 4) As Double, P1 As Byte, P2 As Byte, P3 As Byte, Q1 As Byte, Q2 As Byte, Q3 As Byte
    ReDim DoneOne(4, 4, 4, 4, 4, 4)
    Syn = 0
    nSyn = 0
    pSyn = 0
    pnSyn = 0
    For A = 0 To NextNo
        
        For b = A + 1 To NextNo
            
                If SeqNum(Y, A) > 50 And SeqNum(Y + 1, A) > 50 And SeqNum(Y + 2, A) > 50 Then
                    If SeqNum(Y, b) > 50 And SeqNum(Y + 1, b) > 50 And SeqNum(Y + 2, b) > 50 Then
                        'check if these is just 1 difference between these
                        NDiff = 0
                        P1 = SeqNum(Y, A)
                        P2 = SeqNum(Y + 1, A)
                        P3 = SeqNum(Y + 2, A)
                        Q1 = SeqNum(Y, b)
                        Q2 = SeqNum(Y + 1, b)
                        Q3 = SeqNum(Y + 2, b)
                        If P1 <> Q1 Then NDiff = NDiff + 1
                        If P2 <> Q2 Then NDiff = NDiff + 1
                        If P3 <> Q3 Then NDiff = NDiff + 1
                        If NDiff = 1 Then
                            
                            
                            P1 = Nucs(P1)
                            P2 = Nucs(P2)
                            P3 = Nucs(P3)
                            Q1 = Nucs(Q1)
                            Q2 = Nucs(Q2)
                            Q3 = Nucs(Q3)
                            If DoneOne(P1, P2, P3, Q1, Q2, Q3) = 0 Then
                                If Trans(P1, P2, P3) = Trans(Q1, Q2, Q3) Then
                                    Syn = Syn + 1
                                Else
                                    nSyn = nSyn + 1
                                End If
                                pSyn = pSyn + (PropSynMuts(P1, P2, P3) + PropSynMuts(Q1, Q2, Q3)) / 2
                                pnSyn = pnSyn + (1 - (PropSynMuts(P1, P2, P3) + PropSynMuts(Q1, Q2, Q3)) / 2)
                                DoneOne(P1, P2, P3, Q1, Q2, Q3) = 1
                                DoneOne(Q1, Q2, Q3, P1, P2, P3) = 1
                            End If
                        End If
                    End If
                End If
            
        Next b
    Next A
    If Syn + nSyn > 0 Then
        pSyn = Syn / pSyn
        pnSyn = nSyn / pnSyn
        If pSyn > 0 Then
            UFrame(Direction, Y) = pnSyn / pSyn
            If UFrame(Direction, Y) = 0 Then UFrame(Direction, Y) = 0.0000001
        Else
            UFrame(Direction, Y) = 1
        End If
        
    End If
    Form1.ProgressBar1.Value = Y / Len(StrainSeq(0)) * 100
    Call UpdateF2Prog
Next Y


End Sub
Public Sub MarkStopCodons(StartFrame, SeqNum() As Integer, MarkStops() As Byte)

Dim Z As Long, x As Long, Y As Long, A As Long, b As Long, CodonX(2) As Integer
    For Z = 0 To 2
        For x = 0 To NextNo
            For Y = 1 + Z To Len(StrainSeq(0))
                'find next three nts
                A = Y
                CN = 0
                Do While A < Len(StrainSeq(0))
                    If SeqNum(A, x) > 50 Then
                        CodonX(CN) = Nucs(SeqNum(A, x))
                        CN = CN + 1
                        
                        If CN > 2 Then
                            
                            Exit Do
                        End If
                    End If
                    A = A + 1
                Loop
                If CN < 3 Then
                    Exit For
                Else
                    If Trans(CodonX(0), CodonX(1), CodonX(2)) = "*" Then
                        For b = Y To A
                            MarkStops(StartFrame + Z, b, x) = 1
                        Next b
                    End If
                    Y = A
                End If
            Next Y
        Next x
    Next Z

End Sub
Public Sub GetTaskBarSize(Height As Long, Width As Long)
    Dim ABD As APPBARDATA

    SHAppBarMessage ABM_GETTASKBARPOS, ABD

    Width = ABD.RC.Right - ABD.RC.Left
    Height = ABD.RC.Bottom - ABD.RC.Top

End Sub

Public Sub MCXoverDORDP(S1, s2, S3, BPosX As Long, EPosX As Long)


'MAXCHI scan used to check results of other methods via form1.combo1 next to the plot display.
Dim XPosDiff() As Long, XDiffPos() As Long
Dim TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, Spos As Long, Epos As Long, step As Long, LSeq As Long, Last As Long, NumSites As Long, NumPairs As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double
Dim Seq1 As Long, Seq2 As Long, Seq3 As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, DummyX As Long

Seq1 = S1
Seq2 = s2
Seq3 = S3

NumSites = Len(StrainSeq(0))
step = MCSteplen
Last = NumSites

oSeq1 = Seq1
oSeq2 = Seq2
oSeq3 = Seq3
   
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)

LenXoverSeq = 0

'This could be speeded up with better nesting
LenXoverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))

If LenXoverSeq < 2 Then Exit Sub

oMCWinSize = MCWinSize
oMCWinfract = MCWinFract

BE = BPosX
EN = EPosX

XPosDiff(Len(StrainSeq(0))) = LenXoverSeq

If BE < EN Then
    MCWinSize = XPosDiff(EN) - XPosDiff(BE) + 1
Else
    MCWinSize = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE)) + 1
End If

'mcwinsize = 980

MCWinSize = MCWinSize * 2


    
'there may be a problem with mcwinsize - ie it may be either 1 to low or too high - it is probably a rounding problem

WindowWidth = MCWinSize
HWindowWidth = CLng(WindowWidth / 2)
    
If HWindowWidth > LenXoverSeq / 2 Then
    HWindowWidth = LenXoverSeq - HWindowWidth + 1
    If HWindowWidth < 3 Then
        HWindowWidth = LenXoverSeq / 2
    End If
End If


If HWindowWidth < 4 Then Exit Sub

Spos = -HWindowWidth
Epos = LenXoverSeq + HWindowWidth

'9 OF 32
'HWindowWidth = 7

Dim Winscores() As Long
Dim Scores() As Byte

ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'5,490,1652,9594,19,16,8,0,0,0,0
'scores(9594,2),xdiffpos(9794),seqnum(9594,24),winscores(10574,2)
XX = UBound(Winscores, 1)

'Open "test.csv" For Output As #1
'For X = 0 To Len(StrainSeq(0))
'Print #1, SeqNum(X, 16)
'Next X
'Close #1

'Exit Sub

DummyX = WinScoreCalc(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0), SeqNum(0, 0), Winscores(0, 0))

Erase Scores

'This could be speeded up with better nesting
ReDim Chivals(Len(StrainSeq(0)), 2)
MChi = CalcChiValsP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))

Erase Winscores

If MCFlag = 0 Then
    lPrb = (LowestProb / MCCorrection)
Else
    lPrb = LowestProb
End If

MChi = ChiPVal(MChi) * (LenXoverSeq / (HWindowWidth)) * 3

MChi = -Log10(MChi)

MCMinChiP = MChi
    

If MCMinChiP < -Log10((LowestProb / MCCorrection)) Then MCMinChiP = -Log10(LowestProb / MCCorrection)

MChi = MCMinChiP

For x = 0 To 2
    For Y = 0 To LenXoverSeq
        If CLng(pMCWinSize / 2) > HWindowWidth Then
            Chivals(Y, x) = ChiPVal(Chivals(Y, x)) * (LenXoverSeq / (HWindowWidth)) * 3
        Else
            Chivals(Y, x) = ChiPVal(Chivals(Y, x)) * (LenXoverSeq / (CLng(pMCWinSize / 2))) * 3
        End If
        If Chivals(Y, x) > 1 Then Chivals(Y, x) = 1
    Next Y
Next x

If XDiffPos(0) = 0 Then XDiffPos(0) = XDiffPos(1)

Chivals(LenXoverSeq, 0) = Chivals(0, 0)
Chivals(LenXoverSeq, 1) = Chivals(0, 1)
Chivals(LenXoverSeq, 2) = Chivals(0, 2)


Dim TB As Long, TE As Long

If BPosX - 20 < 0 Then
    TB = BPosX - 20 + Len(StrainSeq(0))
Else
    TB = BPosX - 20
End If

If EPosX + 20 > Len(StrainSeq(0)) Then
    TE = EPosX + 20 - Len(StrainSeq(0))
Else
    TE = EPosX + 20
End If

Dim Z As Long, MinPA As Double, MinPA2 As Double

MinPA = 1
MinPA2 = 1

If XPosDiff(TB) = 0 Then
    If TB < Len(StrainSeq(0)) / 2 Then
        BT = 1
    Else
        BT = LenXoverSeq
    End If
Else
    BT = XPosDiff(TB) - 1
End If

If XPosDiff(TE) >= LenXoverSeq Then
    ET = 1
Else
    ET = XPosDiff(TE) + 1
End If

Dim DE As Long, DB As Long
    If ET > BT Then
        
        For x = BT To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
            
                
            
                If Abs(XPosDiff(TB) - x) < Abs((LenXoverSeq - x) + XPosDiff(TB)) Then
                    DB = Abs(XPosDiff(TB) - x)
                Else
                    DB = Abs((LenXoverSeq - x) + XPosDiff(TB))
                End If
                
                If Abs(XPosDiff(TE) - x) < Abs((LenXoverSeq - x) + XPosDiff(TE)) Then
                    DE = Abs(XPosDiff(TE) - x)
                Else
                    DE = Abs((LenXoverSeq - x) + XPosDiff(TE))
                End If
                
                For Z = 0 To 2
                    
                    
                    
                    If Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X

    Else

        For x = BT To LenXoverSeq 'ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
                XX = XX
                If Abs(XPosDiff(TB) - x) < Abs((LenXoverSeq - x) + XPosDiff(TB)) Then
                    DB = Abs(XPosDiff(TB) - x)
                Else
                    DB = Abs((LenXoverSeq - x) + XPosDiff(TB))
                End If
                
                If Abs(XPosDiff(TE) - x) < Abs((LenXoverSeq - x) + XPosDiff(TE)) Then
                    DE = Abs(XPosDiff(TE) - x)
                Else
                    DE = Abs((LenXoverSeq - x) + XPosDiff(TE))
                End If
                
                For Z = 0 To 2
                    
                    If Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X
        For x = 1 To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
                
                
                
                If Abs(XPosDiff(TB) - x) < Abs((LenXoverSeq - XPosDiff(TB) + x)) Then
                    DB = Abs(XPosDiff(TB) - x)
                Else
                    DB = Abs((LenXoverSeq - XPosDiff(TB) + x))
                End If
                
                If Abs(XPosDiff(TE) - x) < Abs((LenXoverSeq - XPosDiff(TE) + x)) Then
                    DE = Abs(XPosDiff(TE) - x)
                Else
                    DE = Abs((LenXoverSeq - XPosDiff(TE) + x))
                End If
                
                For Z = 0 To 2

                    If Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X

    End If

Erase Chivals
'Dim ProbTest As String
ProbY = 1

Dim POrder() As Double

ReDim POrder(3)



If MinPA <= MinPA2 Then
    POrder(0) = MinPA
    POrder(1) = MinPA2
    POrder(2) = XP1
    POrder(3) = XP2
Else
    POrder(0) = MinPA2
    POrder(1) = MinPA
    POrder(2) = XP2
    POrder(3) = XP1
End If

MCWinSize = oMCWinSize
MCWinFract = oMCWinfract

Seq1 = oSeq1
Seq2 = oSeq2
Seq3 = oSeq3

If x = 12345 Then
    If XDiffPos(XPosDiff(XP1) + 2) = 0 Then
        BPosX = 1
    Else
        xt = XDiffPos(XPosDiff(XP1) + 2)
        XP1 = XDiffPos(XPosDiff(XP1) + 1)
        BPosX = XP1 + CLng((xt - XP1) / 2)
        
    
    End If
    
    If XDiffPos(XPosDiff(XP2) + 1) = 0 Then
        EPosX = Len(StrainSeq(0))
    Else
        xt = XDiffPos(XPosDiff(XP2) + 1)
        EPosX = XP2 + CLng((xt - XP2) / 2)
    End If
    
    'BPosX = XP1
    
    'Call CheckEndsVB(0,0,MCWinSize / 2, EWarn, LenXOverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
    'Call CheckEndsVB(0,0,MCWinSize / 2, BWarn, LenXOverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())

Else
    If XDiffPos(XPosDiff(XP1) + 2) = 0 Then
        BPosX = 1
    Else
        BPosX = XDiffPos(XPosDiff(XP1) + 2)
    End If
    EPosX = XP2
    Call CentreBP(0, 0, Seq1, Seq2, Seq3, BPosX, EPosX, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
x = x
End If
'EPosX = XP2

End Sub
Public Sub AssociationTest()
Dim Pos1, Pos2, PlantNo() As Long, PlantName() As String, TotPlant, TempName As String, ExpMat() As Double
ReDim PlantName(PermNextno), PlantNo(PermNextno)
Dim ChivalMat() As Double, CP1 As Long, CP2 As Long
Dim DiffPos() As Long, DiffPosR() As Long, LSSeq As Long, P1Tot, P2Tot, ChimCyc As Long
ReDim DiffPos(Len(StrainSeq(0))), DiffPosR(Len(StrainSeq(0)))
For x = 0 To PermNextno
    PlantNo(x) = -1
Next x
ChimCyc = 10000
TotPlant = 0
For x = 0 To PermNextno
    Pos1 = InStr(1, OriginalName(x), "Plant_", vbTextCompare)
    If Pos1 > 0 Then
        Pos2 = InStr(Pos1 + 6, OriginalName(x), "_", vbTextCompare)
        TempName = Mid$(OriginalName(x), Pos1 + 6, Pos2 - (Pos1 + 6))
        x = x
        For Y = 0 To TotPlant
            If PlantName(Y) = TempName Then
                PlantNo(x) = Y
                Exit For
            ElseIf PlantName(Y) = "" Then
                PlantName(Y) = TempName
                PlantNo(x) = TotPlant
                TotPlant = TotPlant + 1
                Exit For
            End If
        Next Y
    End If
Next x
TotPlant = TotPlant - 1



'Exit Sub
LSSeq = 0
P1Tot = 0
P2Tot = 0
For x = 1 To Len(StrainSeq(0))
    DiffPosR(x) = LSSeq
    If SeqNum(x, 0) <> SeqNum(x, 1) Then
        If SeqNum(x, 0) <> 46 And SeqNum(x, 1) <> 46 Then
            
            LSSeq = LSSeq + 1
            
            DiffPos(LSSeq) = x
            DiffPosR(x) = LSSeq
            For Y = 2 To NextNo
                If SeqNum(x, 0) = SeqNum(x, Y) Then
                    P1Tot = P1Tot + 1
                ElseIf SeqNum(x, 1) = SeqNum(x, Y) Then
                    P2Tot = P2Tot + 1
                End If
            Next Y
        End If
        
    End If
    
Next x

'make the mutation matrix
Dim MutArray() As Byte
ReDim MutArray(LSSeq, NextNo)
For x = 1 To LSSeq
    CP = DiffPos(x)
    For Y = 2 To NextNo
        If SeqNum(CP, Y) <> SeqNum(CP, 0) And SeqNum(CP, Y) <> SeqNum(CP, 1) Then
            MutArray(x, Y) = 1
        End If
    Next Y
Next x

'Make a count of all the breakpoint positions
Dim BPSeqs()
ReDim BPSeqs(TotPlant, 1, Len(StrainSeq(0)))

For x = 1 To SEventNumber
    A = BestEvent(x, 0)
    b = BestEvent(x, 1)
    BE = DiffPosR(XoverList(A, b).Beginning)
    EN = DiffPosR(XoverList(A, b).Ending)
    RecS = XoverList(A, b).Daughter
    MapX = XoverList(A, b).MajorP
    MipX = XoverList(A, b).MinorP
    If MapX = 0 Then
        BPSeqs(PlantNo(RecS), 0, BE) = 1
        BPSeqs(PlantNo(RecS), 1, EN) = 1
    
    End If
Next x
Dim BPNum As Long, BPCount() As Long, ContainBP() As Long

ReDim BPCount(TotPlant, 1, Len(StrainSeq(0)))
For x = 0 To TotPlant
    For Y = 1 To Len(StrainSeq(0))
        If BPSeqs(x, 0, Y) = 1 Then
            BPNum = BPNum + 1
            BPCount(x, 0, Y) = BPNum
        End If
        If BPSeqs(x, 1, Y) = 1 Then
            BPNum = BPNum + 1
            BPCount(x, 1, Y) = BPNum
        End If
    Next Y
Next x

ReDim ContainBP(PermNextno, BPNum)

For A = 2 To PermNextno
    For b = 1 To CurrentXOver(A)
        BE = DiffPosR(XoverList(A, b).Beginning)
        EN = DiffPosR(XoverList(A, b).Ending)
        RecS = XoverList(A, b).Daughter
        MapX = XoverList(A, b).MajorP
        MipX = XoverList(A, b).MinorP
        If MapX = 0 Then
            ContainBP(RecS, BPCount(PlantNo(RecS), 0, BE)) = 1
            ContainBP(RecS, BPCount(PlantNo(RecS), 1, EN)) = 1
        
        End If
    Next b
Next A


ReDim ChivalMat(LSSeq, LSSeq, 3)
For x = 1 To LSSeq
    CP1 = DiffPos(x)
    For Y = x + 1 To LSSeq
        CP2 = DiffPos(Y)
        
        
       
            For Z = 2 To NextNo
                
                If SeqNum(CP1, Z) = SeqNum(CP1, 0) And SeqNum(CP2, Z) = SeqNum(CP2, 0) Then
                    ChivalMat(x, Y, 0) = ChivalMat(x, Y, 0) + 1 '0-0
                ElseIf SeqNum(CP1, Z) = SeqNum(CP1, 0) And SeqNum(CP2, Z) = SeqNum(CP2, 1) Then
                    ChivalMat(x, Y, 1) = ChivalMat(x, Y, 1) + 1 '0-1
                ElseIf SeqNum(CP1, Z) = SeqNum(CP1, 1) And SeqNum(CP2, Z) = SeqNum(CP2, 0) Then
                    ChivalMat(x, Y, 2) = ChivalMat(x, Y, 2) + 1 '1-0
                ElseIf SeqNum(CP1, Z) = SeqNum(CP1, 1) And SeqNum(CP2, Z) = SeqNum(CP2, 1) Then
                    ChivalMat(x, Y, 3) = ChivalMat(x, Y, 3) + 1 '1-1
                End If
                 x = x
            Next Z
        
        x = x
    Next Y
Next x
'do chival calculations
Dim Chivals() As Double, TempBetter() As Long, TempMat() As Long, TotC As Double, ExpHom As Double, ExpHet As Double
ReDim Chivals(15, LSSeq, LSSeq), TempBetter(1, 15, LSSeq, LSSeq)
ReDim ExpMat(3)
For x = 1 To LSSeq
    For Y = x + 1 To LSSeq
    If x = 1 And Y = 9 Then
        x = x
    End If
        '1=1000
'2=0100
'3=0010
'4=0001
'5=1100
'6=1010
'7=1001
'8=0110
'9=0101
'10=0011
'11=0111
'12=1011
'13=1101
'14=1110

        'XX = PermNextNo
        TotC = ChivalMat(x, Y, 0) + ChivalMat(x, Y, 3) + ChivalMat(x, Y, 1) + ChivalMat(x, Y, 2)
        Chivals(1, x, Y) = ChivalMat(x, Y, 0) / TotC '1000
        Chivals(2, x, Y) = ChivalMat(x, Y, 1) / TotC '0100
        Chivals(3, x, Y) = ChivalMat(x, Y, 3) / TotC '0010
        Chivals(4, x, Y) = ChivalMat(x, Y, 2) / TotC '0001
        
        Chivals(5, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 1)) / TotC '1100
        Chivals(6, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 3)) / TotC '1010
        Chivals(7, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 2)) / TotC '1001
        Chivals(8, x, Y) = (ChivalMat(x, Y, 1) + ChivalMat(x, Y, 3)) / TotC '0110
        Chivals(9, x, Y) = (ChivalMat(x, Y, 1) + ChivalMat(x, Y, 2)) / TotC '0101
        Chivals(10, x, Y) = (ChivalMat(x, Y, 2) + ChivalMat(x, Y, 3)) / TotC '0011
        
        Chivals(11, x, Y) = (ChivalMat(x, Y, 1) + ChivalMat(x, Y, 2) + ChivalMat(x, Y, 3)) / TotC '0111
        Chivals(12, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 2) + ChivalMat(x, Y, 3)) / TotC '1011
        Chivals(13, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 1) + ChivalMat(x, Y, 2)) / TotC '1101
        Chivals(14, x, Y) = (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 1) + ChivalMat(x, Y, 3)) / TotC '1110
        
         ExpMat(0) = ((ChivalMat(x, Y, 0) + ChivalMat(x, Y, 1)) / TotC) * (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 2))
         ExpMat(1) = ((ChivalMat(x, Y, 0) + ChivalMat(x, Y, 1)) / TotC) * (ChivalMat(x, Y, 1) + ChivalMat(x, Y, 3))
         ExpMat(2) = ((ChivalMat(x, Y, 2) + ChivalMat(x, Y, 3)) / TotC) * (ChivalMat(x, Y, 0) + ChivalMat(x, Y, 2))
         ExpMat(3) = ((ChivalMat(x, Y, 2) + ChivalMat(x, Y, 3)) / TotC) * (ChivalMat(x, Y, 1) + ChivalMat(x, Y, 3))
        
        If ExpMat(0) > 0 And ExpMat(1) > 0 And ExpMat(2) > 0 And ExpMat(3) > 0 Then
            Chivals(15, x, Y) = (ChivalMat(x, Y, 0) - ExpMat(0)) ^ 2 / ExpMat(0)
            Chivals(15, x, Y) = Chivals(15, x, Y) + (ChivalMat(x, Y, 1) - ExpMat(1)) ^ 2 / ExpMat(1)
            Chivals(15, x, Y) = Chivals(15, x, Y) + (ChivalMat(x, Y, 2) - ExpMat(2)) ^ 2 / ExpMat(2)
            Chivals(15, x, Y) = Chivals(15, x, Y) + (ChivalMat(x, Y, 3) - ExpMat(3)) ^ 2 / ExpMat(3)
            Chivals(15, Y, x) = Chivals(15, x, Y)
        Else
            Chivals(15, x, Y) = 0
            Chivals(Y, x) = 0
        End If
        x = x
    Next Y
Next x


Dim aDataset() As Byte
ReDim aDataset(LSSeq, PermNextno)

For Y = 2 To NextNo
    For x = 1 To LSSeq
        CP1 = DiffPos(x)
        If SeqNum(CP1, Y) = SeqNum(CP1, 0) Then
            aDataset(x, Y) = 1
        ElseIf SeqNum(CP1, Y) = SeqNum(CP1, 1) Then
            aDataset(x, Y) = 2
        End If
    Next x
Next Y
'Make actual Dataset



'Exit Sub
Dim PermX As Long, DoneBP() As Long, NewPos As Long, TempDataset() As Byte, LenBP As Long, NBP(3), BEX, EPX, TP1Tot As Long, TP2Tot As Long
Rnd (-BSRndNumSeed)
For PermX = 1 To ChimCyc
    ReDim DoneBP(BPNum)
    ReDim TempDataset(Len(StrainSeq(0)), NextNo)
    sncyc = 0
    
    
    If x = x Then
        For x = 0 To TotPlant
            NewPos = Int((LSSeq * Rnd) + 1)
            
            For A = 0 To PermNextno
                
                If PlantNo(A) = x Then
                    For Y = 1 To LSSeq
                        Z = Y + NewPos
                        If Z > LSSeq Then Z = Z - LSSeq
                        TempDataset(Z, A) = aDataset(Y, A)
                    Next Y
                End If
            Next A
        Next x
    ElseIf x = 100000000 Then
    'randomise breakpoints per plant
        
        For x = 0 To TotPlant
            NewPos = Int((LSSeq * Rnd) + 1)
            NewPos = 8
            For A = 0 To PermNextno
                If A = 126 Then
                    x = x
                End If
                For b = 1 To CurrentXOver(A)
                    BE = DiffPosR(XoverList(A, b).Beginning)
                    EN = DiffPosR(XoverList(A, b).Ending)
                    If BE = EN Then BE = BE + 1
                    
                    RecS = XoverList(A, b).Daughter
                    If PlantNo(RecS) = x Then
                        
                        MapX = XoverList(A, b).MajorP
                        MipX = XoverList(A, b).MinorP
                        
                        If MapX = 0 Then
                            fillx = 2
                        Else
                            fillx = 1
                        End If
                        NBP(0) = BE + NewPos - 1
                        NBP(1) = BE + NewPos
                        NBP(2) = EN + NewPos
                        NBP(3) = EN + NewPos + 1
                        'Exit Sub
                        For Z = 0 To 3
                            If NBP(Z) < 1 Then
                                NBP(Z) = LSSeq + NBP(Z)
                            ElseIf NBP(Z) > LSSeq Then
                                NBP(Z) = NBP(Z) - LSSeq
                            End If
                        Next Z
                        A = A
                        If NBP(1) <= NBP(2) Then
                            For Z = NBP(1) To NBP(2)
                                AP = Z - NewPos
                                If AP < 1 Then AP = LSSeq + AP
                                If AP > LSSeq Then AP = AP - LSSeq
                                If SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 0) Then
                                    TempDataset(Z, RecS) = 1
                                ElseIf SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 1) Then
                                    TempDataset(Z, RecS) = 2
                                End If
                            Next Z
                        Else
                            For Z = NBP(1) To LSSeq
                                
                                AP = Z - NewPos
                                If AP < 1 Then AP = LSSeq + AP
                                If AP > LSSeq Then AP = AP - LSSeq
                                If SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 0) Then
                                    TempDataset(Z, RecS) = 1
                                ElseIf SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 1) Then
                                    TempDataset(Z, RecS) = 2
                                End If
                            Next Z
                            For Z = 1 To NBP(2)
                                
                                AP = Z - NewPos
                                If AP < 1 Then AP = LSSeq + AP
                                If AP > LSSeq Then AP = AP - LSSeq
                                If SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 0) Then
                                    TempDataset(Z, RecS) = 1
                                ElseIf SeqNum(DiffPos(AP), RecS) = SeqNum(DiffPos(AP), 1) Then
                                    TempDataset(Z, RecS) = 2
                                End If
                            Next Z
                        End If
                    End If
                Next b
            Next A
        Next x
    Else
    'try to randomise breakpoints in pairs
        For A = 0 To PermNextno
          
            For b = 1 To CurrentXOver(A)
                BE = DiffPosR(XoverList(A, b).Beginning)
                EN = DiffPosR(XoverList(A, b).Ending)
                RecS = XoverList(A, b).Daughter
                MapX = XoverList(A, b).MajorP
                MipX = XoverList(A, b).MinorP
                If MapX = 0 Then
                    BEX = BPCount(PlantNo(RecS), 0, BE)
                    EPX = BPCount(PlantNo(RecS), 1, EN)
                
                End If
                
                
                If (DoneBP(BPX) = 0 Or DoneBP(EPX) = 0) And MapX = 0 Then
                    
                    
                    If BE < EN Then
                        LenBP = EN - BE
                    Else
                        LenBP = LSSeq - BE + EN
                    End If
                    NCyc = 0
                    Do
                        GoOn = 1
                        NewPos = Int((LSSeq * Rnd) + 1)
                        'check whether other sequences in the dataset contain this bp
                        NBP(0) = NewPos - 1
                        NBP(1) = NewPos
                        NBP(2) = NewPos + LenBP
                        NBP(3) = NewPos + LenBP + 1
                        For x = 0 To 3
                            If NBP(x) < 1 Then
                                NBP(x) = LSSeq + NBP(x)
                            ElseIf NBP(x) > LSSeq Then
                                NBP(x) = NBP(x) - LSSeq
                            End If
                        Next x
                        If NBP(0) < NBP(3) Then
                            For x = NBP(0) To NBP(3)
                                If TempDataset(x, RecS) <> 0 Then
                                    GoOn = 0
                                    Exit For
                                End If
                            Next x
                        Else
                            For x = NBP(0) To LSSeq
                                If TempDataset(x, RecS) <> 0 Then
                                    GoOn = 0
                                    Exit For
                                End If
                            Next x
                            If GoOn = 1 Then
                                For x = 1 To NBP(3)
                                    If TempDataset(x, RecS) <> 0 Then
                                        GoOn = 0
                                        Exit For
                                    End If
                                Next x
                            End If
                        End If
                        If GoOn = 1 Then Exit Do 'ie the permuted event is OK
                        NCyc = NCyc + 1
                        If NCyc > 100 Then
                           ' sncyc = sncyc + 1
                           ' If sncyc > 100 Then
                           '     sncyc = 0
                                Exit Do
                           ' End If
                           ' A = A - 1
                           ' Exit For
                        End If
                    Loop
                    
                    
                    TempDataset(NBP(0), RecS) = 1
                    TempDataset(NBP(1), RecS) = 2
                    TempDataset(NBP(2), RecS) = 2
                    TempDataset(NBP(3), RecS) = 1
                    XX = BE
                    XX = EN
                    For x = 0 To PermNextno
                        If x <> RecS Then
                            If ContainBP(x, BEX) = 1 And DoneBP(BEX) = 0 Then
                                TempDataset(NBP(0), x) = 1
                                TempDataset(NBP(1), x) = 2
                            End If
                            If ContainBP(x, EPX) = 1 And DoneBP(EPX) = 0 Then
                                TempDataset(NBP(2), x) = 2
                                TempDataset(NBP(3), x) = 1
                            End If
                        End If
                    Next x
                    DoneBP(BEX) = 1
                    DoneBP(EPX) = 1
                End If
            Next b
            x = x
        Next A
    End If
    If x = 12345678 Then
        For x = 2 To NextNo
            For Y = 1 To LSSeq
                If TempDataset(Y, x) <> 0 Then
                    Exit For
                End If
            Next Y
            If Y < LSSeq Then
                StartPos = Y
                curval = TempDataset(Y, x)
                Do
                    If TempDataset(Y, x) = 0 Then
                        TempDataset(Y, x) = curval
                    Else
                        curval = TempDataset(Y, x)
                    End If
                    
                    Y = Y + 1
                    If Y = StartPos Then Exit Do
                    If Y > LSSeq Then
                        Y = 1
                        x = x
                    End If
                    If Y = StartPos Then Exit Do
                    
                Loop
            Else
                If Distance(x, 0) > Distance(x, 1) Then
                    For Y = 1 To LSSeq
                        TempDataset(Y, x) = 1
                    Next Y
                    
                    
                Else
                    For Y = 1 To LSSeq
                        TempDataset(Y, x) = 2
                    Next Y
                End If
            
            End If
        Next x
        'Add in mutations
        AA = 0
        For x = 2 To NextNo
            For Y = 1 To LSSeq
                If MutArray(Y, x) = 1 Then
                    TempDataset(Y, x) = 0
                    AA = AA + 1
                End If
            Next Y
        Next x
    End If
    
    'use this to test that the permutations have been properly made
    If x = 123445567 Then
         TP1Tot = 0
         TP2Tot = 0
         Dim xR As Long, S As Long, M As Long, n As Long
         For x = 2 To NextNo
             S = 0
             xR = 0
             For Y = 1 To LSSeq
                 If TempDataset(Y, x) = 1 Then
                     TP1Tot = TP1Tot + 1
                     xR = xR + 1
                     x = x
                 ElseIf TempDataset(Y, x) = 2 Then
                     S = S + 1
                     TP2Tot = TP2Tot + 1
                 End If
                 
             Next Y
             M = 0
             n = 0
             For Y = 1 To Len(StrainSeq(0))
                 If SeqNum(Y, 0) <> 46 And SeqNum(Y, 1) <> 46 Then
                     If SeqNum(Y, 0) <> SeqNum(Y, 1) Then
                         If SeqNum(Y, 0) = SeqNum(Y, x) Then
                             M = M + 1
                         ElseIf SeqNum(Y, 1) = SeqNum(Y, x) Then
                             n = n + 1
                         End If
                     End If
                 End If
             Next Y
             If M <> xR Or n <> S Then
                 x = x
             End If
             x = x
             'Exit Sub
         Next x
        
         If TP1Tot <> P1Tot Then '65708
             Yy = TP1Tot + TP2Tot
             ZZ = P1Tot + P2Tot
             CC = P1Tot - TP1Tot
             DD = P2Tot - TP2Tot
             
             jj = Yy - ZZ
             x = x
             'Exit Sub
         End If
    End If
    'make matrix for this permutation
    Dim ChVal As Double
    
    For x = 1 To LSSeq - 1
        CP1 = DiffPos(x)
        For Y = x + 1 To LSSeq
            CP2 = DiffPos(Y)
            ReDim TempMat(4)
            
            If x = x Then
                Dummy = FillTempDataset(x, Y, NextNo, Len(StrainSeq(0)), TempDataset(0, 0), TempMat(0))
            Else
                For Z = 2 To NextNo
                    If TempDataset(x, Z) = 1 And TempDataset(Y, Z) = 1 Then
                        TempMat(0) = TempMat(0) + 1
                        
                    ElseIf TempDataset(x, Z) = 1 And TempDataset(Y, Z) = 2 Then
                        TempMat(1) = TempMat(1) + 1
                    ElseIf TempDataset(x, Z) = 2 And TempDataset(Y, Z) = 1 Then
                        TempMat(2) = TempMat(2) + 1
                        
                    ElseIf TempDataset(x, Z) = 2 And TempDataset(Y, Z) = 2 Then
                        TempMat(3) = TempMat(3) + 1
                        
                    End If
                    'if
                Next Z
            End If
            x = x
            
            
            '*****************************************************
            
            'Be careful with the cell encoding - stupidly, this is initially
            'done in ChivalMat as 2= bottom left and 3=bottom right
            'but then I idiotically change it in Chivals to 2= bottom right and 3=bottom left
            '
            
            '******************************************************
            
            
            'calc chival and compare with the chival from thereal dataset - if it is higher add one to the appropriate cell of tempbetter
            Dim TVal As Double
            ReDim ExpMat(3)
            TotC = TempMat(0) + TempMat(1) + TempMat(2) + TempMat(3)
            
            'If X = X Then
                XX = PermX
                TVal = TempMat(0) / TotC
                If TVal >= Chivals(1, x, Y) Then
                    TempBetter(1, 1, x, Y) = TempBetter(1, 1, x, Y) + 1
                End If
                If TVal <= Chivals(1, x, Y) Then
                    TempBetter(0, 1, x, Y) = TempBetter(0, 1, x, Y) + 1
                End If
                
                TVal = TempMat(1) / TotC
                If TVal >= Chivals(2, x, Y) Then
                    TempBetter(1, 2, x, Y) = TempBetter(1, 2, x, Y) + 1
                End If
                If TVal <= Chivals(2, x, Y) Then
                    TempBetter(0, 2, x, Y) = TempBetter(0, 2, x, Y) + 1
                End If
                
                TVal = TempMat(3) / TotC
                If TVal >= Chivals(3, x, Y) Then
                    TempBetter(1, 3, x, Y) = TempBetter(1, 3, x, Y) + 1
                End If
                If TVal <= Chivals(3, x, Y) Then
                    TempBetter(0, 3, x, Y) = TempBetter(0, 3, x, Y) + 1
                End If
                
                TVal = TempMat(2) / TotC
                If TVal >= Chivals(4, x, Y) Then
                    TempBetter(1, 4, x, Y) = TempBetter(1, 4, x, Y) + 1
                End If
                If TVal <= Chivals(4, x, Y) Then
                    TempBetter(0, 4, x, Y) = TempBetter(0, 4, x, Y) + 1
                End If
                
                
                TVal = (TempMat(0) + TempMat(1)) / TotC
                If TVal >= Chivals(5, x, Y) Then
                    TempBetter(1, 5, x, Y) = TempBetter(1, 5, x, Y) + 1
                End If
                If TVal <= Chivals(5, x, Y) Then
                    TempBetter(0, 5, x, Y) = TempBetter(0, 5, x, Y) + 1
                End If
                
                TVal = (TempMat(0) + TempMat(3)) / TotC
                If TVal >= Chivals(6, x, Y) Then
                    TempBetter(1, 6, x, Y) = TempBetter(1, 6, x, Y) + 1
                End If
                If TVal <= Chivals(6, x, Y) Then
                    TempBetter(0, 6, x, Y) = TempBetter(0, 6, x, Y) + 1
                End If
                
                TVal = (TempMat(0) + TempMat(2)) / TotC
                If TVal >= Chivals(7, x, Y) Then
                    TempBetter(1, 7, x, Y) = TempBetter(1, 7, x, Y) + 1
                End If
                If TVal <= Chivals(7, x, Y) Then
                    TempBetter(0, 7, x, Y) = TempBetter(0, 7, x, Y) + 1
                End If
                
                TVal = (TempMat(1) + TempMat(3)) / TotC
                If TVal >= Chivals(8, x, Y) Then
                    TempBetter(1, 8, x, Y) = TempBetter(1, 8, x, Y) + 1
                End If
                If TVal <= Chivals(8, x, Y) Then
                    TempBetter(0, 8, x, Y) = TempBetter(0, 8, x, Y) + 1
                End If
                
                TVal = (TempMat(1) + TempMat(2)) / TotC
                If TVal >= Chivals(9, x, Y) Then
                    TempBetter(1, 9, x, Y) = TempBetter(1, 9, x, Y) + 1
                End If
                If TVal <= Chivals(9, x, Y) Then
                    TempBetter(0, 9, x, Y) = TempBetter(0, 9, x, Y) + 1
                End If
                
                TVal = (TempMat(2) + TempMat(3)) / TotC
                If TVal >= Chivals(10, x, Y) Then
                    TempBetter(1, 10, x, Y) = TempBetter(1, 10, x, Y) + 1
                End If
                If TVal <= Chivals(10, x, Y) Then
                    TempBetter(0, 10, x, Y) = TempBetter(0, 10, x, Y) + 1
                End If
                
                TVal = (TempMat(1) + TempMat(2) + TempMat(3)) / TotC
                If TVal >= Chivals(11, x, Y) Then
                    TempBetter(1, 11, x, Y) = TempBetter(1, 11, x, Y) + 1
                End If
                If TVal <= Chivals(11, x, Y) Then
                    TempBetter(0, 11, x, Y) = TempBetter(0, 11, x, Y) + 1
                End If
                
                TVal = (TempMat(0) + TempMat(2) + TempMat(3)) / TotC
                If TVal >= Chivals(12, x, Y) Then
                    TempBetter(1, 12, x, Y) = TempBetter(1, 12, x, Y) + 1
                End If
                If TVal <= Chivals(12, x, Y) Then
                    TempBetter(0, 12, x, Y) = TempBetter(0, 12, x, Y) + 1
                End If
                
                TVal = (TempMat(0) + TempMat(1) + TempMat(2)) / TotC
                If TVal >= Chivals(13, x, Y) Then
                    TempBetter(1, 13, x, Y) = TempBetter(1, 13, x, Y) + 1
                End If
                If TVal <= Chivals(13, x, Y) Then
                    TempBetter(0, 13, x, Y) = TempBetter(0, 13, x, Y) + 1
                End If
                
                TVal = (TempMat(0) + TempMat(1) + TempMat(3)) / TotC
                If TVal >= Chivals(14, x, Y) Then
                    TempBetter(1, 14, x, Y) = TempBetter(1, 14, x, Y) + 1
                End If
                If TVal <= Chivals(14, x, Y) Then
                    TempBetter(0, 14, x, Y) = TempBetter(0, 14, x, Y) + 1
                End If
                
                
            'Else 'contingency table test
            
                    ExpMat(0) = ((TempMat(0) + TempMat(1)) / TotC) * (TempMat(0) + TempMat(2))
                    ExpMat(1) = ((TempMat(0) + TempMat(1)) / TotC) * (TempMat(1) + TempMat(3))
                    ExpMat(2) = ((TempMat(2) + TempMat(3)) / TotC) * (TempMat(0) + TempMat(2))
                    ExpMat(3) = ((TempMat(2) + TempMat(3)) / TotC) * (TempMat(1) + TempMat(3))
                    
                    
                   If ExpMat(0) > 0 And ExpMat(1) > 0 And ExpMat(2) > 0 And ExpMat(3) > 0 Then
                       ChVal = (TempMat(0) - ExpMat(0)) ^ 2 / ExpMat(0)
                       ChVal = ChVal + (TempMat(3) - ExpMat(3)) ^ 2 / ExpMat(3)
                       ChVal = ChVal + (TempMat(1) - ExpMat(1)) ^ 2 / ExpMat(1)
                       ChVal = ChVal + (TempMat(2) - ExpMat(2)) ^ 2 / ExpMat(2)
                       x = x
                   Else
                       ChVal = 0
                   End If
                
                   If ChVal >= Chivals(15, x, Y) Then
                       
                       TempBetter(0, 15, x, Y) = TempBetter(0, 15, x, Y) + 1
                       TempBetter(0, 15, Y, x) = TempBetter(0, 15, x, Y)
                  
                   End If
            'End If
        Next Y
    Next x
    Form1.ProgressBar1.Value = (PermX / ChimCyc) * 100
    Form1.SSPanel1.Caption = Str(PermX) + " of" + Str(ChimCyc) + " permutations completed"
    Call UpdateF2Prog
    Form1.Refresh
    DoEvents
    
Next PermX
ZZ = 0
ChDrive App.Path
ChDir App.Path

Dim ToString As String
Open "P-ValTest.csv" For Output As #1
Print #1, "pos1,pos2,2X2 Contingency test, m1000,m0100,m0010,m0001,m1100,m1010,m1001,m0110,m0101,m0011,m0111,m1011,m1101,m1110,l1000,l0100,l0010,l0001,l1100,l1010,l1001,l0110,l0101,l0011,l0111,l1011,l1101,l1110,"
For x = 1 To LSSeq - 1
    
    For Y = x + 1 To LSSeq
        ToString = Str(DiffPos(x)) + "," + Str(DiffPos(Y)) + ","
        ToString = ToString + Str(TempBetter(0, 15, x, Y) / ChimCyc) + ","
        For Z = 0 To 1
        
            For A = 1 To 14
                'If TempBetter(Z, A, X, Y) <= 5 Then
                   ToString = ToString + Str(TempBetter(Z, A, x, Y) / ChimCyc) + ","
                   
                   
                   ' XX = Chivals(X, Y) '20-212,20-213,21-212,21-213,23-212,213:  89-112 interacting with 1316-1318
                    
               ' End If
            Next A
        Next Z
        Print #1, ToString
    Next Y
Next x

lowx = 0
highx = 0
Close #1
Target = LSSeq * (LSSeq - 1)
Target = Target / 2

For A = 1 To 15
    For Z = 0 To 1
    lowx = 0
    highx = 0
    ZZ = 0
        For x = 1 To LSSeq - 1
        
            For Y = x + 1 To LSSeq
            ZZ = ZZ + 1
                If TempBetter(Z, A, x, Y) <= 10 Then
                       lowx = lowx + 1
                       
                 ElseIf TempBetter(Z, A, x, Y) >= ChimCyc - 10 Then
                 
                     highx = highx + 1
                        
                 End If
               
            Next Y
            
        Next x
        XX = (lowx / Target)
        XX = (highx / Target)
        If lowx = Target Or highx = Target Then
            x = x
        End If
    Next Z
 Next A

x = x
Yy = ZZ / ((LSSeq * (LSSeq - 1)) / 2) '0.17,0.11,0.0004,0.17,0.07,0.06,0.001,0.04,0.08
'0.07,0.08,0.08,0.07,0.24,0.13,0.13,0.24,0.07,0.08,0,0.07
'0.11,0.17,0.17,0.0004,0.04,0.001,0.58,0.07
x = x
x = x
Exit Sub



Dim NDiff As Long, Diffs() As Long, ArrayX(4, 4) As Long, Done()

For Y = 1 To Len(StrainSeq(0))
    ReDim Diffs(255)
    GoOn = 0
    For x = 4 To NextNo
        If Diffs(SeqNum(Y, x)) = 0 Then
            Diffs(SeqNum(Y, x)) = 1
            If SeqNum(Y, x) <> SeqNum(Y, 2) Then
                If SeqNum(Y, 2) = SeqNum(Y, 3) Then
                    NDiff = NDiff + 1
                    GoOn = 1
                End If
            End If
        End If
    Next x
    
    If GoOn = 1 Then
        ReDim Done(255)
        For x = 60 To 90
            If Diffs(x) > 0 Then
                If SeqNum(Y, 2) = 66 Then
                    If x = 66 Then
                        
                    ElseIf x = 68 Then
                        ArrayX(1, 2) = ArrayX(1, 2) + 1
                        
                    ElseIf x = 72 Then
                        ArrayX(1, 3) = ArrayX(1, 3) + 1
                    ElseIf x = 85 Then
                        ArrayX(1, 4) = ArrayX(1, 4) + 1
                    End If
                ElseIf SeqNum(Y, 2) = 68 Then
                    If x = 66 Then
                        ArrayX(2, 1) = ArrayX(2, 1) + 1
                    ElseIf x = 68 Then
                        
                    ElseIf x = 72 Then
                        ArrayX(2, 3) = ArrayX(2, 3) + 1
                    ElseIf x = 85 Then
                        ArrayX(2, 4) = ArrayX(2, 4) + 1
                    End If
                ElseIf SeqNum(Y, 2) = 72 Then
                    If x = 66 Then
                        ArrayX(3, 1) = ArrayX(3, 1) + 1
                    ElseIf x = 68 Then
                        ArrayX(3, 2) = ArrayX(3, 2) + 1
                    ElseIf x = 72 Then
                       
                    ElseIf x = 85 Then
                        ArrayX(3, 4) = ArrayX(3, 4) + 1
                    End If
                ElseIf SeqNum(Y, 2) = 85 Then
                    If x = 66 Then
                        ArrayX(4, 1) = ArrayX(4, 1) + 1
                    ElseIf x = 68 Then
                        ArrayX(4, 2) = ArrayX(4, 2) + 1
                    ElseIf x = 72 Then
                        ArrayX(4, 3) = ArrayX(4, 3) + 1
                    ElseIf x = 85 Then
                        
                    End If
                End If
            End If
        Next x
    End If
    x = x
Next Y
XX = ArrayX(1, 2)
XX = ArrayX(1, 3)
XX = ArrayX(1, 4)
XX = ArrayX(2, 1)
XX = ArrayX(2, 3)
XX = ArrayX(2, 4)
XX = ArrayX(3, 1)
XX = ArrayX(3, 2)
XX = ArrayX(3, 4)
XX = ArrayX(4, 1)
XX = ArrayX(4, 2)
XX = ArrayX(4, 3)
End Sub
Public Sub MakeNoGood()
Dim NoGood() As Byte
NumRecs = 50
NumPerms = 100

ReDim NoGood(NumRecs, NumPerms)
ReDim OriginalName(200), StrainSeq(200)
For x = 1 To NumRecs
    NextNo = -1
    With Form1.CommonDialog1
    
        .MaxFileSize = 32000
        .FLAGS = cdlOFNAllowMultiselect + cdlOFNExplorer
        .FileName = ""
        .DefaultExt = "*.*"
        .Filter = "All Files (*.*)|*.*|RDP Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq|Extended multiple FASTA file (*.xmfa)|*.seq|FASTA Multiple Alignment Format (*.fas)"
        .Action = 1 'Specify that the "open file" action is required.
        FName$ = .FileName  'Stores selected file name in the
        FNameII = .FileTitle
        
    End With


    NF = FreeFile
    
    Open FName$ For Binary Access Read As #NF
    
    RLFlag = 0
    OldSeqFile = SeqFile
    GlobalMemoryStatus MemSit
    
    WholeFileFlag = 1
    
    
    SeqFile = String$(LOF(NF), " ")
    Get #NF, 1, SeqFile
    
    
    Close #NF
    Call LoadFASTA
    ReDim SeqSpaces(Len(StrainSeq(0)) + 2, NextNo)
    ReDim SeqNum(Len(StrainSeq(0)), NextNo + 1)
    For Z = 0 To NextNo
        Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, Z), StrainSeq(Z), SeqSpaces(0, Z))
    Next ''X
    Dim Tallys()
    ReDim Tallys(1, NextNo)
    For Y = 2 To NextNo
        For Z = 1 To Len(StrainSeq(0))
            
            If SeqNum(Z, 0) <> SeqNum(Z, 1) Then
                If SeqNum(Z, Y) = SeqNum(Z, 0) Then
                    Tallys(0, Y) = Tallys(0, Y) + 1
                Else
                    Tallys(1, Y) = Tallys(1, Y) + 1
                End If
            End If
        Next Z
        
    Next Y
    For Y = 3 To NextNo
        If (Tallys(0, Y) - 1 > Tallys(0, 2) Or Tallys(0, Y) + 1 < Tallys(0, 2)) Or (Tallys(1, Y) - 1 > Tallys(1, 2) Or Tallys(1, Y) + 1 < Tallys(1, 2)) Then
            NoGood(x, Y - 2) = 1
        End If
    Next Y
    x = x
Next x
Dim oDir As String
oDir = CurDir
ChDir App.Path
ChDrive App.Path
Open "NoGood.txt" For Output As #1
For x = 1 To NumRecs
    For Y = 0 To NumPerms
        Print #1, Str(NoGood(x, Y))
    Next Y

Next x
Close #1

ChDir oDir
ChDrive oDir

End Sub
Public Sub TestSSDisrupt()

Dim oDir As String, NumRecs As Long, Disrupts() As Long, NumPerms As Long, TS As String, FF As Long, SkipThis() As Byte, FullPerms As Long
NumRecs = 50
NumPerms = 100
FullPerms = 1000000

oDir = CurDir
ChDir App.Path
ChDrive App.Path
Dim NoGood() As Byte
ReDim NoGood(NumRecs, NumPerms)
FL = 0
If DebuggingFlag < 2 Then On Error Resume Next

Open "NoGood.txt" For Input As #1
FL = LOF(1)
On Error GoTo 0

If FL > 0 Then

    For x = 1 To NumRecs
        For Y = 0 To NumPerms
            Input #1, NoGood(x, Y)
        Next Y
    
    Next x
End If
Close #1

ChDir oDir
ChDrive oDir

oDir = CurDir




With Form1.CommonDialog1
    
    .MaxFileSize = 32000
    .FLAGS = cdlOFNAllowMultiselect + cdlOFNExplorer
    .FileName = ""
    .DefaultExt = "*.*"
    .Filter = "All Files (*.*)|*.*|RDP Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq|Extended multiple FASTA file (*.xmfa)|*.seq|FASTA Multiple Alignment Format (*.fas)"
    .Action = 1 'Specify that the "open file" action is required.
    FName$ = .FileName  'Stores selected file name in the
    FNameII = .FileTitle
    
End With






FF = FreeFile
ReDim Disrupts(3, NumRecs, NumPerms), SkipThis(NumRecs)
For x = 1 To NumRecs
    TS = "rec" + Trim(Str(x)) + ".csv"
    If DebuggingFlag < 2 Then On Error Resume Next
    FL = 0
    Open TS For Input As #FF
    FL = LOF(FF)
    On Error GoTo 0
    If FL > 0 Then
        For Y = 0 To NumPerms
            For Z = 0 To 2
                Input #FF, Disrupts(Z, x, Y)
                x = x
            Next Z
            Disrupts(3, x, Y) = Disrupts(0, x, Y) + Disrupts(1, x, Y) 'The missing interaction + extra interaction category
        Next Y
    
        Close #FF
    Else
        SkipThis(x) = 1
        'If DebuggingFlag < 2 Then On Error Resume Next
        Close #FF
        'Kill TS
        'On Error GoTo 0
    End If
Next x


'Work out real disrupt sum
Dim DisruptSums() As Long, MyRnd As Long
ReDim DisruptSums(3, FullPerms)
For x = 1 To NumRecs
    If SkipThis(x) = 0 Then
        For Y = 0 To 3
            DisruptSums(Y, 0) = DisruptSums(Y, 0) + Disrupts(Y, x, 0)
        Next Y
    End If
Next x
Rnd (-BSRndNumSeed)
For x = 1 To FullPerms
    For Y = 1 To NumRecs
        If SkipThis(Y) = 0 Then
            
            Do
                
                MyRnd = Int(((NumPerms + 1) * Rnd) + 1) - 1
                'If MyRnd = 6 Then
                '    X = X
                'End If
                'XX = NoGood(1, 6)
                If NoGood(Y, MyRnd) = 0 Then
                
                    For Z = 0 To 3
                        DisruptSums(Z, x) = DisruptSums(Z, x) + Disrupts(Z, Y, MyRnd)
                    Next Z
                    Exit Do
                End If
            Loop
        End If
    Next Y
    Form1.ProgressBar1 = (x / FullPerms) * 100
    Call UpdateF2Prog
Next x

Dim PVals() As Double

ReDim PVals(3)
For x = 1 To FullPerms
    For Z = 0 To 3
        If DisruptSums(Z, 0) >= DisruptSums(Z, x) Then PVals(Z) = PVals(Z) + 1
    Next Z
Next x

'Interaction in bith parents disrupted
PVals(0) = PVals(0) / FullPerms 'All:0.000024; Fit:0.000078; Unfit:0.014873
'interaction in recombinants created
PVals(1) = PVals(1) / FullPerms 'All:0.004939; Fit:0.03691; Unfit:0.030561
'interaction in either parent disrupted
PVals(2) = PVals(2) / FullPerms 'All:0.10562; Fit:0.038898; Unfit:0.452456
'interactions both dirupted and constructed
PVals(3) = PVals(3) / FullPerms 'All:0.00171; Fit:0.018002; Unfit:0.019124
x = x


End Sub
Public Sub ssDNASCHEMA()
Dim RootDir As String, MaxVal As Long, Matrix() As Long, MatName() As String, PairedMap() As Long, ParentMat() As Long
ReDim PairedMap(Len(StrainSeq(0)), 5) '0 = paired sites in 1 OR 2, 1 =paired sites in 1, 2 = pairdsites in 2, 3 = pairdsites in 1 not 2, 4 = pairedsites in 2 not 1, 5 = pairedsites in 1 AND 2
ReDim MatName(1)
ReDim ParentMat(1, Len(StrainSeq(0)), Len(StrainSeq(0)))



With Form1.CommonDialog1
    .MaxFileSize = 32000
    .FLAGS = cdlOFNAllowMultiselect + cdlOFNExplorer
    .FileName = ""
    .DefaultExt = "*.*"
    .Filter = "All Files (*.*)|*.*|RDP Project Files (*.rdp)|*.rdp|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|FASTA Multiple Alignment Format (*.fas)|*.fas|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq|Extended multiple FASTA file (*.xmfa)|*.seq|FASTA Multiple Alignment Format (*.fas)"
    .Action = 1 'Specify that the "open file" action is required.
    FName$ = .FileName  'Stores selected file name in the
    FNameII = .FileTitle
    
End With

MatName(0) = "parent_1_matrix.txt"
MatName(1) = "parent_2_matrix.txt"
SS = Abs(GetTickCount)
Dim DirNum As Long, NextDir As String


RootDir = CurDir
For x = Len(RootDir) To 1 Step -1
    If Mid$(RootDir, x, 1) = "\" Then
        RootDir = Left(RootDir, x)
        Exit For
    End If
Next x
'Exit Sub
For DirNum = 1 To 50
    Form1.ProgressBar1.Value = 100 * (DirNum / 50)
    Call UpdateF2Prog
    NextDir = RootDir + Trim(Str(DirNum))
    ChDir NextDir
    ChDrive NextDir
    For x = 0 To 1
        
        
        Call LoadSSMatrix(Matrix(), MatName(x), Len(StrainSeq(0)))
        For Y = 1 To Len(StrainSeq(0))
            For Z = 1 To Len(StrainSeq(0))
                If MaxVal < Matrix(Z, Y) Then
                    MaxVal = Matrix(Z, Y)
                End If
            Next Z
        Next Y
        For Y = 1 To Len(StrainSeq(0))
            For Z = 1 To Len(StrainSeq(0))
                ParentMat(x, Z, Y) = CLng((Matrix(Z, Y) / MaxVal) * 100)
            Next Z
        Next Y
        x = x
    Next x
    EE = Abs(GetTickCount)
    TT = EE - SS '13.2981,9.078, 8.094
    'now read in the other matrices
    Dim TempS As String, DisruptionS() As Long
    ReDim DisruptionS(100, 2)
    For x = 0 To 100
        TempS = Trim(Str(x)) + "_matrix.txt"
        Call LoadSSMatrix(Matrix(), TempS, Len(StrainSeq(0)))
        
        For Y = 1 To Len(StrainSeq(0))
            For Z = Y + 1 To Len(StrainSeq(0))
                'find missing interactions
                If ParentMat(0, Z, Y) > 0 And ParentMat(1, Z, Y) > 0 And Matrix(Z, Y) = 0 Then
                    DisruptionS(x, 0) = DisruptionS(x, 0) + 1
                    
                End If
                'find "extra" interactions
                If ParentMat(0, Z, Y) = 0 And ParentMat(1, Z, Y) = 0 And Matrix(Z, Y) > 0 Then
                    DisruptionS(x, 1) = DisruptionS(x, 1) + 1
                End If
                'interaction in either parent missing in the recombinant
                If ParentMat(0, Z, Y) > 0 Or ParentMat(1, Z, Y) > 0 And Matrix(Z, Y) = 0 Then
                    DisruptionS(x, 2) = DisruptionS(x, 2) + 1
                End If
            Next Z
        Next Y
        x = x
        
        Form1.ProgressBar1 = x
        Call UpdateF2Prog
        Form1.Refresh
    Next x '
     Form1.ProgressBar1 = 0
     Call UpdateF2Prog
    ChDir RootDir
    ChDrive RootDir
    Open "rec" + Trim(Str(DirNum)) + ".csv" For Output As #1
    For x = 0 To 100
        
            Print #1, Trim(Str(DisruptionS(x, 0))) + "," + Trim(Str(DisruptionS(x, 1))) + "," + Trim(Str(DisruptionS(x, 2)))
        
    
    Next x
    Close #1
    
Next DirNum
x = x

End Sub
Public Sub MakeHostBPCount(IntervalMap() As Long, SiteCatMap() As Long, BanCats() As Byte, BreakDist() As Long, DoneMap() As Byte, HostBPCount() As Long, KeepTrack, CountPos, TraceHost() As Long)

Dim CurHost As Long, NumSites As Long, MapPos As Long, Bx As Long, P1 As Long, P2 As Long
ReDim DoneMap(CountPos, KeepTrack), HostBPCount(KeepTrack), BreakDist(Len(StrainSeq(0)))

ZZ = 0
'Also record how many breakpoints per "host"
For Y = 0 To NextNo
    P1 = XoverList(Y, 1).MajorP
    P2 = XoverList(Y, 1).MinorP
    
    For x = 1 To CurrentXOver(Y)
        If XoverList(Y, x).MajorP = P1 Then
            For Z = 0 To 1
                If Z = 0 Then
                    Bx = XoverList(Y, x).Beginning
                Else
                    Bx = XoverList(Y, x).Ending
                End If
                'count how many sites around the breakpoint are identical between the parents
                NumSites = 0
                MapPos = IntervalMap(Bx)
                CurHost = TraceHost(Y)
                If SiteCatMap(Bx) > -1 Then
                    If DoneMap(MapPos, CurHost) = 0 Then 'make sure this bp hasn't been counted before in this host
                        DoneMap(MapPos, CurHost) = 1
                        NumSites = SiteCatMap(Bx)
                        If BanCats(NumSites) = 0 Then
                            BreakDist(NumSites) = BreakDist(NumSites) + 1
                            HostBPCount(TraceHost(Y)) = HostBPCount(TraceHost(Y)) + 1
                            ZZ = ZZ + 1
                        End If
                    End If
                End If
            Next Z
        End If
    Next x
Next Y

End Sub

Public Sub MakeSiteCatMap(SiteCatMap() As Long, AllowgapFlag)

Dim CountSites As Long, ExtraSites As Long

ReDim SiteCatMap(Len(StrainSeq(0)))
For x = 1 To Len(StrainSeq(0))
    
    If SeqNum(x, 0) <> SeqNum(x, 1) Then 'start at first difference then loop back around
        
        
            CountSites = 0
            ExtraSites = 0
            SiteCatMap(x) = 0
            For Y = x + 1 To Len(StrainSeq(0)) * 2
                If Y > Len(StrainSeq(0)) Then
                    A = Y - Len(StrainSeq(0))
                Else
                    A = Y
                End If
                If SeqNum(A, 0) <> SeqNum(A, 1) Then
                    Exit For
                Else
                    If SeqNum(A, 0) > 50 Then
                        CountSites = CountSites + 1
                    Else
                       ExtraSites = ExtraSites + 1
                    End If
                End If
            Next Y
            x = Y - 1
            'Y = Z
            'Do
            For Y = x To (x + 1 - (CountSites + ExtraSites)) Step -1
                If Y > Len(StrainSeq(0)) Then
                    A = Y - Len(StrainSeq(0))
                Else
                    A = Y
                End If
                If (SeqNum(A, 0) > 50 And SeqNum(A, 1) > 50) Or AllowgapFlag = 1 Then
        
                    SiteCatMap(A) = CountSites
                Else
                    SiteCatMap(A) = -1
                End If
            Next Y
            'Loop
            If Y > Len(StrainSeq(0)) Then Exit For
        
    End If
Next x
'XX = SiteCatMap(3)
End Sub
Public Sub MakeIntervalMap(CountPos As Long, IntervalMap() As Long)
Dim LastGood As Byte
CountPos = -1
ReDim IntervalMap(Len(StrainSeq(0)))
For Y = 1 To Len(StrainSeq(0))
    
    If SeqNum(Y, 0) <> SeqNum(Y, 1) Then Exit For
    IntervalMap(Y) = -1
Next Y
For x = Y To Len(StrainSeq(0))
    
    If SeqNum(x, 0) <> SeqNum(x, 1) Then
        CountPos = CountPos + 1
        LastGood = 0
    ElseIf x > 0 Then
        If SeqNum(x - 1, 0) <> SeqNum(x - 1, 1) Then
            CountPos = CountPos + 1
            If SeqNum(x, 0) > 50 Then
                LastGood = 1
            End If
        ElseIf (SeqNum(x - 1, 0) < 50 And SeqNum(x - 1, 1) < 50) Then
            If LastGood = 0 Then
                CountPos = CountPos + 1
                LastGood = 1
            End If
        End If
    End If
    IntervalMap(x) = CountPos
Next x
For x = 0 To Len(StrainSeq(0))
    If IntervalMap(x) = -1 Then
        IntervalMap(x) = CountPos
    End If

Next x


End Sub
Public Sub GetPlantNums(KeepTrack As Long, TraceHost() As Long)

Dim Indicator() As String, DoneThis() As Byte, MarkName() As String


ReDim TraceHost(NextNo)
KeepTrack = PermPlantCount
For x = 0 To NextNo
    TraceHost(x) = PermPlantNum(x)
    
Next x
Exit Sub
ReDim Indicator(NextNo)
NumPlants = 0
For x = 2 To NextNo
    Pos = InStr(1, OriginalName(x), "_", vbBinaryCompare)
    NPos = InStr(Pos + 1, OriginalName(x), "_", vbBinaryCompare)
    If NPos > 0 Then
        Indicator(x) = Mid$(OriginalName(x), Pos + 1, NPos - (Pos + 1))
    Else
        Indicator(x) = "QWERTY"
    End If
Next x


ReDim DoneThis(NextNo), MarkName(NextNo)

KeepTrack = -1
For x = 2 To NextNo
    If DoneThis(x) = 0 Then
        DoneThis(x) = 1
        KeepTrack = KeepTrack + 1
        TraceHost(x) = KeepTrack
        MarkName(KeepTrack) = Indicator(x)
        If MarkName(KeepTrack) = "QWERTY" Then
            For Y = x + 1 To NextNo
                
                DoneThis(Y) = 1
                TraceHost(Y) = KeepTrack
                
            Next Y
        Else
            For Y = x + 1 To NextNo
                If Indicator(x) = Indicator(Y) Then
                    DoneThis(Y) = 1
                    TraceHost(Y) = KeepTrack
                End If
            Next Y
        End If
    End If
Next x
x = x
End Sub
Public Sub SecondaryStructure()


Dim MaxVal As Long, Matrix() As Long, MatName() As String, PairedMap() As Long, ParentMat() As Long
ReDim PairedMap(Len(StrainSeq(0)), 11) '0 = paired sites in 1 OR 2, 1 =paired sites in 1, 2 = pairdsites in 2, 3 = pairdsites in 1 not 2, 4 = pairedsites in 2 not 1, 5 = pairedsites in 1 AND 2
ReDim MatName(1)
ReDim ParentMat(1, Len(StrainSeq(0)), Len(StrainSeq(0)))
MatName(0) = "parent_1.txt"
MatName(1) = "parent_2.txt"
oDir = CurDir
ChDrive App.Path
ChDir App.Path

For x = 0 To 1
    Call LoadSSMatrix(Matrix(), MatName(x), Len(StrainSeq(0)))
    'find the max
    MaxVal = 0
    
    For Y = 1 To Len(StrainSeq(0))
        For Z = 1 To Len(StrainSeq(0))
            If MaxVal < Matrix(Z, Y) Then
                MaxVal = Matrix(Z, Y)
            End If
        Next Z
    Next Y
    
    For Y = 1 To Len(StrainSeq(0))
        For Z = 1 To Len(StrainSeq(0))
            ParentMat(x, Z, Y) = CLng((Matrix(Z, Y) / MaxVal) * 100)
            
        Next Z
    Next Y
    x = x
Next x



For Y = 1 To Len(StrainSeq(0))
    
    For x = 1 To Len(StrainSeq(0))
        PairedMap(Y, 0) = PairedMap(Y, 0) + ParentMat(0, x, Y) + ParentMat(1, x, Y) 'is it paired in parent 1 or parent 2
        PairedMap(Y, 1) = PairedMap(Y, 1) + ParentMat(0, x, Y) 'is it paired in parent 1
        PairedMap(Y, 2) = PairedMap(Y, 2) + ParentMat(1, x, Y) 'is it paired in parent 2
        
    
    Next x
    x = x
    'if pairedmap(y,0) <20 then pairedmap(y,0)
Next Y
For Y = 1 To Len(StrainSeq(0))
    If PairedMap(Y, 1) > 80 And PairedMap(Y, 2) < 20 Then PairedMap(Y, 3) = PairedMap(Y, 1) - 80 ' is it paire din parent 1 and not in parent 2
    'If PairedMap(Y, 1) > PairedMap(Y, 2) Then PairedMap(Y, 3) = PairedMap(Y, 1) - PairedMap(Y, 2)
    If PairedMap(Y, 2) > 80 And PairedMap(Y, 1) < 20 Then PairedMap(Y, 4) = PairedMap(Y, 2) - 80 ' is it paired in parent 2 and not in parent1
    'If PairedMap(Y, 2) > PairedMap(Y, 1) Then PairedMap(Y, 4) = PairedMap(Y, 2) - PairedMap(Y, 1)
    'If PairedMap(Y, 2) > 50 And PairedMap(Y, 1) > 50 Then PairedMap(Y, 5) = PairedMap(Y, 5) + PairedMap(Y, 2) + PairedMap(Y, 1) - 100
    If Abs((PairedMap(Y, 1) - PairedMap(Y, 2))) >= 60 Then
        PairedMap(Y, 5) = PairedMap(Y, 5) + Abs(PairedMap(Y, 1) - PairedMap(Y, 2))
    End If
Next Y


'Do a smoothing window

Dim SmoothLen As Long
SmoothLen = 50
For x = 1 To Len(StrainSeq(0))
    For Y = x - SmoothLen / 2 To x + SmoothLen / 2
        If Y < 1 Then
            Z = Y + Len(StrainSeq(0))
        ElseIf Y > Len(StrainSeq(0)) Then
            Z = Y - Len(StrainSeq(0))
        Else
            Z = Y
        End If
        PairedMap(x, 11) = PairedMap(x, 11) + PairedMap(Z, 0) 'parent 1 or parent 2
        PairedMap(x, 6) = PairedMap(x, 6) + PairedMap(Z, 1) 'parent 1
        PairedMap(x, 7) = PairedMap(x, 7) + PairedMap(Z, 2) 'parent 2
        PairedMap(x, 8) = PairedMap(x, 8) + PairedMap(Z, 3) 'parent 1 not parent 2
        PairedMap(x, 9) = PairedMap(x, 9) + PairedMap(Z, 4) 'parent 2 not parent 1
        PairedMap(x, 10) = PairedMap(x, 10) + PairedMap(Z, 5) 'different between parent 1 and 2
    Next Y
    PairedMap(x, 6) = PairedMap(x, 6) / SmoothLen
    PairedMap(x, 7) = PairedMap(x, 7) / SmoothLen
    PairedMap(x, 8) = PairedMap(x, 8) / SmoothLen
    PairedMap(x, 9) = PairedMap(x, 9) / SmoothLen
    PairedMap(x, 10) = PairedMap(x, 10) / SmoothLen
    PairedMap(x, 11) = PairedMap(x, 11) / SmoothLen
Next x

XX = CurDir
For x = 0 To 11
    Open "SiteSet" + Trim(Str(x)) For Output As #1
    For Y = 1 To Len(StrainSeq(0))
        Print #1, PairedMap(Y, x)
    Next Y
    Close #1
Next x

ChDrive oDir
ChDir oDir

End Sub

Public Sub LoadSSMatrix(Matrix() As Long, FNameX As String, DLen As Long)
Dim oDir As String, FF As Long, MaxString As String, TS As String, Pos As Long, LPos As Long, Z As Long

ReDim Matrix(DLen, DLen)




XX = CurDir
If x = 12345 Then

    FF = FreeFile
    Open FNameX For Input As FF
    
    
    
    Pos = -1
    LPos = 1
    For Y = 1 To DLen - 1
        For x = 1 To DLen - 1
            
            Input #1, Matrix(x, Y)
            'If X > DLen - 20 And Y = 4 Then
            '    X = X
            'End If
            'If Matrix(X, Y) = 15 Then
            '    X = X
            'End If
        Next x
    Next Y
    Close #FF
Else
    FF = FreeFile
    Open FNameX For Binary As FF
    Dim BinHold() As Byte
    ReDim BinHold(LOF(FF))
    MaxString = String(LOF(FF), " ")
    Get #FF, , MaxString
    Close #FF
    SS = Abs(GetTickCount)
    
    Pos = -1
    LPos = 1
    
    For Y = 1 To DLen - 1
        For x = 1 To DLen - 1
            Pos = InStr(LPos, MaxString, ",", vbBinaryCompare)
            If x > Y Then 'Pos > 0 Then
                
                'If Mid$(MaxString, LPos, 1) <> 0 Then
                Z = Pos - LPos
                TS = Mid$(MaxString, LPos, Z)
                If TS <> "0" Then
                
                    Matrix(x, Y) = val(TS)
                    Matrix(Y, x) = Matrix(x, Y)
                
            
                End If
                'If Matrix(X, Y) > 0 Then
                '    X = X
                'End If
            'Else
            '    Exit For
                
            End If
            LPos = Pos + 1
            'Line Input #FF, ODir
            'Input #1, Matrix(X, Y)
            'If X > DLen - 20 And Y = 4 Then
            '    X = X
            'End If
            'If Matrix(X, Y) = 15 Then
            '    X = X
            'End If
        Next x
    Next Y
    EE = Abs(GetTickCount)
    TT = EE - SS '4031,3906,3687,3656,3625,2766,1469
    x = x
End If

'Close #1
If x = 123345 Then
    For Y = 1 To DLen - 1
        For x = 1 To DLen - 1
            If Matrix(x, Y) <> Matrix(Y, x) Then
                x = x
            End If
            If Matrix(x, Y) > 0 Then
                x = x
            End If
        Next x
    Next Y
End If
x = x

End Sub



Public Sub ReformatFile(NF, TempString As String, SaveFlag)
    Dim LastPos As Long, Pos As Long, SS As Long, LS As Long
    Close #NF
    LastPos = 1
    Form1.SSPanel1.Caption = "Reformatting sequence file"
XX = Len(TempString)
    Do
        Pos = InStr(LastPos, TempString, Chr$(10), vbBinaryCompare)

        If Pos > 0 Then
            'XX = Mid$(TempString, Pos + 1, 1)
            If Pos + 1 <= Len(TempString) Then
                If Mid$(TempString, Pos + 1, 1) <> Chr$(13) Then
                'XX = Mid$(TempString, Pos + 1, 1)
                    Mid$(TempString, Pos, 1) = Chr$(13)
                End If
            Else
                 Mid$(TempString, Pos, 1) = Chr$(13) 'TempString = TempString + Chr$(13)
            End If
            'SS = abs(gettickcount)
            
            LastPos = Pos + 2
'            Form1.ProgressBar1.Value = (LastPos / (Len(TempString) + 2)) * 100
'            Call UpdateF2Prog
'            SS = abs(gettickcount)
'            If Abs(SS - LS) > 100 Then
'                LS = SS
'                Form1.ProgressBar1.Value = (LastPos / (Len(TempString) + 2)) * 100
'                Call UpdateF2Prog
'           '     DoEvents
'            End If
        Else
            Exit Do
        End If
        
            
    Loop
    'XX = InStr(1, TempString, Chr(10), vbBinaryCompare)
    Open "tempfile" For Output As #NF
    SaveFlag = 1
    Print #NF, TempString
    Close #NF
    Open "tempfile" For Input Access Read As #NF
    Line Input #NF, TempString
    
    
End Sub
Public Sub BreakSimilarity()

Dim BreakDist() As Long, DoneBreak() As Byte, P1 As Long, P2 As Long, Bx As Long, AllowgapFlag As Byte



'Only want to allow one breakpoint per interval per plant tested


AllowgapFlag = 0 '1 if its OK for breakpoinst to fall at sites where there are gapss in one of the parental sequences


'sort out plant numbers
Dim TraceHost() As Long, KeepTrack As Long
Call GetPlantNums(KeepTrack, TraceHost())


Dim IntervalMap() As Long, CountPos As Long
Call MakeIntervalMap(CountPos, IntervalMap())




'Make a site category map
Dim SiteCatMap() As Long
Call MakeSiteCatMap(SiteCatMap(), AllowgapFlag)

Dim BanCats() As Byte
ReDim BanCats(Len(StrainSeq(0)))


'Use these to ban certain breakpoint categories
'BanCats(0) = 1
'BanCats(1) = 1
'BanCats(41) = 1

'Now make a plant specific "donemap" and actual breakpoint distribution
Dim DoneMap() As Byte, MapPos As Long, CurHost As Long, SiteCat() As Long, HostBPCount() As Long

Call MakeHostBPCount(IntervalMap(), SiteCatMap(), BanCats(), BreakDist(), DoneMap(), HostBPCount(), KeepTrack, CountPos, TraceHost())



'Find Maxcats
Dim MaxCats As Long
MaxCats = 0
For x = 0 To Len(StrainSeq(0))
    If SiteCatMap(x) > MaxCats Then MaxCats = SiteCatMap(x)
Next x


'Make simulations
Dim PermBreaks() As Single, MyValue As Long, TempBreaks() As Long, PermNum As Long, Maybe As Long, PermDoneMap() As Byte, SiteCatX
PermNum = 100000

ReDim PermBreaks(1, MaxCats)



Rnd (-BSRndNumSeed)
Dim SimDist() As Single
ReDim SimDist(MaxCats)
For Z = 1 To PermNum
    ZZ = 0
    ReDim PermDoneMap(Len(StrainSeq(0)), KeepTrack)
    ReDim TempBreaks(MaxCats)
    For x = 0 To KeepTrack
        For Y = 1 To HostBPCount(x)
            Do
                Maybe = Int((Len(StrainSeq(0)) * Rnd) + 1)
                SiteCatX = SiteCatMap(Maybe)
                If SiteCatX > -1 Then
                    If BanCats(SiteCatX) = 0 Then
                        MapPos = IntervalMap(Maybe)
                        If PermDoneMap(MapPos, x) = 0 Then
                            PermDoneMap(MapPos, x) = 1
                            ZZ = ZZ + 1
                            Exit Do
                        End If
                    End If
                End If
            Loop
            TempBreaks(SiteCatX) = TempBreaks(SiteCatX) + 1
        Next Y
    Next x
    
    For x = 0 To MaxCats
        If TempBreaks(x) <= BreakDist(x) Then
            PermBreaks(0, x) = PermBreaks(0, x) + 1
            
        End If
        If TempBreaks(x) >= BreakDist(x) Then
            PermBreaks(1, x) = PermBreaks(1, x) + 1
        End If
    Next x
    For x = 0 To MaxCats
        SimDist(x) = SimDist(x) + TempBreaks(x)
    Next x
    Form1.ProgressBar1.Value = (Z / PermNum) * 100
    Call UpdateF2Prog
Next Z
Dim NumSitesInCat() As Long
ReDim NumSitesInCat(MaxCats)
For x = 2 To Len(StrainSeq(0))
    
    'If X = 1438 Then
    '    X = X
    'End If
    If IntervalMap(x) <> IntervalMap(x - 1) Then
        SiteCatX = SiteCatMap(x)
        If SiteCatX = 11 Then
           x = x
        End If
        If SiteCatX > -1 Then
            NumSitesInCat(SiteCatX) = NumSitesInCat(SiteCatX) + 1
        End If
    End If
    
Next x


For x = 0 To MaxCats
    SimDist(x) = SimDist(x) / PermNum
    PermBreaks(0, x) = PermBreaks(0, x) / PermNum
    PermBreaks(1, x) = PermBreaks(1, x) / PermNum
Next x


Dim TotNucsInCat() As Long, GapSitesExcluded As Long
ReDim TotNucsInCat(MaxCats)
For x = 1 To Len(StrainSeq(0))
    SiteCatX = SiteCatMap(x)
    If SiteCatMap(x) = 29 Then 'And SiteCatMap(X + 10) = 11 Then
        x = x
    End If
    If SiteCatX > -1 Then
        TotNucsInCat(SiteCatX) = TotNucsInCat(SiteCatX) + 1
    Else
        GapSitesExcluded = GapSitesExcluded + 1
    End If
Next x


For x = 1 To MaxCats
    If NumSitesInCat(x) <> TotNucsInCat(x) / x Then
        NumSitesInCat(x) = TotNucsInCat(x) / x
    End If

Next x

'For X = 1 To Len(StrainSeq(0))
'    If SiteCatMap(X) = 11 Then
'        If SeqNum(X, 0) < 50 Or SeqNum(X, 1) < 50 Then
'            X = X
'        End If
'
'    End If
'Next X


oDir = CurDir
ChDrive App.Path
ChDir App.Path


Open "breakdist.csv" For Output As #1
Print #1, "Identical tract length, Number of tracts this length, Number of sites in these tracts,Number of observed breakpoints, Number of expected breakpoints, probability of not more than expected, probability of not less than expected"
For x = 0 To MaxCats
    Print #1, Trim(Str(x)) + "," + Trim(Str(NumSitesInCat(x))) + "," + Trim(Str(TotNucsInCat(x))) + "," + Trim(Str(BreakDist(x))) + "," + Trim(Str(SimDist(x))) + "," + Trim(Str(1 - PermBreaks(0, x))) + "," + Trim(Str(1 - PermBreaks(1, x)))
Next x
Print #1, "Sites excluded (usually because they contained gaps)=," + Str(GapSitesExcluded)

Close #1
ChDrive oDir
ChDir oDir
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub
Public Sub MFETests()
oDir = CurDir
ChDrive App.Path + "\mfe"
ChDir App.Path + "\mfe"
Dim NumFilesX As Long, StringX As String, StringY As String, MFEVals() As Double, NumPerms As Long, MaxAlt As Long, NumAlt() As Long, ParVals() As Double, ParAlt() As Long, PermCounter As Long
Dim PermNo As Long, RestrictedFlag As Byte, Restricted() As Long

NumFilesX = 50: NumPerms = 100: MaxAlt = 30
PermNo = 100000





ReDim MFEVals(NumFilesX, NumPerms, MaxAlt), ParVals(1, MaxAlt) 'maxalt= the max number of possible alternative structures
ReDim NumAlt(NumFilesX, NumPerms), ParAlt(1)
RestrictedFlag = 0
ReDim Restricted(NumFilesX)
If RestrictedFlag = 1 Then 'i.e. only some of the files are looked at
    For x = 0 To NumFilesX
        Restricted(x) = 0
    Next x
    Restricted(2) = 1
    Restricted(5) = 1
    Restricted(8) = 1
    Restricted(9) = 1
    Restricted(10) = 1
    Restricted(12) = 1
    Restricted(18) = 1
    Restricted(23) = 1
    Restricted(27) = 1
    Restricted(29) = 1
    Restricted(35) = 1
    Restricted(40) = 1
    Restricted(43) = 1
    Restricted(46) = 1
    Restricted(48) = 1
    'Restricted(51) = 1
    'Restricted(53) = 1
    'Restricted(54) = 1
End If


For x = 1 To NumFilesX
    If Restricted(x) = 0 Then
        If DebuggingFlag < 2 Then On Error Resume Next
    
        Open Trim(Str(x)) For Input As #1
        LF = 0
        LF = LOF(1)
        On Error GoTo 0
        If LF > 0 Then
            Do While Not EOF(1)
                 Input #1, StringX
                
                 'XX = Len(StringX)
                
                 If Len(StringX) > LOF(1) / 2 Then
                     LPos = 1
                     Close #1
                     Do
                         Pos = InStr(LPos, StringX, Chr(10), vbBinaryCompare)
                         If Pos > 0 Then
                             Mid$(StringX, Pos, 2) = Chr(13) + Chr(10)
                             LPos = Pos + 2
                         Else
                             Exit Do
                         End If
                         'redim
                     x = x
                     Loop
                     Open Trim(Str(x)) For Output As #1
                         Print #1, StringX
                     Close #1
                     Open Trim(Str(x)) For Input As #1
                     Line Input #1, StringX
                     XX = Len(StringX)
                    Input #1, StringX ' plant name
                 End If
                 
                 
                 Pos = InStr(1, StringX, Chr(9), vbBinaryCompare)
                 StringX = Right(StringX, Len(StringX) - Pos)
                 If StringX = "" Then Exit Do
                 Pos = InStr(1, StringX, Chr(9), vbBinaryCompare)
                 StringY = Left(StringX, Pos - 1)
                 StringX = Right(StringX, Len(StringX) - Pos)
                 If StringX = "" Then Exit Do
                 'Input #1, StringX 'virus name
                 
                 If StringY <> "parent_1" And StringY <> "parent_2" Then
                     PermCounter = val(StringY)
                     Pos = InStr(1, StringX, Chr(9), vbBinaryCompare)
                     
                     StringX = Right(StringX, Len(StringX) - Pos)
                     
                     
                     NumAlt(x, PermCounter) = NumAlt(x, PermCounter) + 1
                     If NumAlt(x, PermCounter) > MaxAlt Then NumAlt(x, PermCounter) = MaxAlt
                     MFEVals(x, PermCounter, NumAlt(x, PermCounter)) = val(StringX)
                     x = x
                 ElseIf ParAlt(0) = 0 Or ParAlt(1) = 0 Then
                     If StringY = "parent_1" Then
                         Pos = InStr(1, StringX, Chr(9), vbBinaryCompare)
                        
                         StringX = Right(StringX, Len(StringX) - Pos)
                         ParAlt(0) = ParAlt(0) + 1
                         ParVals(0, ParAlt(0)) = val(StringX)
                         x = x
                     ElseIf StringY = "parent_2" Then
                         Pos = InStr(1, StringX, Chr(9), vbBinaryCompare)
                         
                         StringX = Right(StringX, Len(StringX) - Pos)
                         ParAlt(1) = ParAlt(1) + 1
                         ParVals(1, ParAlt(1)) = val(StringX)
                     End If
                 End If
            Loop
        End If
        Close #1
        Form1.ProgressBar1 = (x / NumFilesX) * 100
        Call UpdateF2Prog
    End If
Next x
'test for mfe

Dim ParMFE(1) As Double, CurPerm As Long, RealMFE As Double, CurLow As Double, PermScores As Double, SumScores As Double, NumSmaller As Double, PVal As Double
SumScores = 0
NumSmaller = 0
For x = 1 To NumFilesX
    If Restricted(x) = 0 Then
        CurLow = 100000
        For Y = 1 To NumAlt(x, 0)
            If MFEVals(x, 0, Y) < CurLow Then CurLow = MFEVals(x, 0, Y)
        Next Y
        If CurLow < 100000 Then
            SumScores = SumScores + CurLow
        End If
    End If
Next x
SumScores = SumScores / NumFilesX

Rnd (-BSRndNumSeed)
NumSmaller = 0
For P = 1 To PermNo
    PermScores = 0
    For x = 1 To NumFilesX
        If Restricted(x) = 0 Then
            CurPerm = Int((NumPerms * Rnd) + 1)
            
            CurLow = 100000
            For Y = 1 To NumAlt(x, CurPerm)
                If MFEVals(x, CurPerm, Y) < CurLow Then CurLow = MFEVals(x, CurPerm, Y)
            Next Y
            If CurLow < 100000 Then
                PermScores = PermScores + CurLow
            End If
        End If
    Next x
    PermScores = PermScores / NumFilesX
    If PermScores <= SumScores Then NumSmaller = NumSmaller + 1
Next P
PVal = NumSmaller / PermNo '0.21092 focusing on all' 0.11828 focusing on the fit ones; 0.47118 focusing on unfit ones

For x = 0 To 1
    ParMFE(x) = 0
    CurLow = 100000
    For Y = 1 To ParAlt(x)
        If ParVals(x, Y) < CurLow Then CurLow = ParVals(x, Y)
    Next Y
    If CurLow < 100000 Then
        ParMFE(x) = CurLow
    End If
Next x

Dim Diffval As Double

SumScores = 0
NumSmaller = 0
For x = 1 To NumFilesX
    If Restricted(x) = 0 Then
        CurLow = 100000
        For Y = 1 To NumAlt(x, 0)
            Diffval = Abs(Abs(MFEVals(x, 0, Y)) - Abs(ParMFE(0)))
            If Diffval < CurLow Then CurLow = Diffval
            Diffval = Abs(Abs(MFEVals(x, 0, Y)) - Abs(ParMFE(1)))
            If Diffval < CurLow Then CurLow = Diffval
        Next Y
        If CurLow < 100000 Then
            SumScores = SumScores + CurLow
        End If
    End If
Next x
SumScores = SumScores / NumFilesX

Rnd (-BSRndNumSeed)

For P = 1 To PermNo
    PermScores = 0
    For x = 1 To NumFilesX
        If Restricted(x) = 0 Then
            CurPerm = Int((NumPerms * Rnd) + 1)
            CurLow = 100000
            For Y = 1 To NumAlt(x, CurPerm)
                Diffval = Abs(Abs(MFEVals(x, CurPerm, Y)) - Abs(ParMFE(0)))
                If Diffval < CurLow Then CurLow = Diffval
                Diffval = Abs(Abs(MFEVals(x, CurPerm, Y)) - Abs(ParMFE(1)))
                If Diffval < CurLow Then CurLow = Diffval
                'If MFEVals(X, CurPerm, Y) < CurLow Then CurLow = MFEVals(X, CurPerm, Y)
            Next Y
            If CurLow < 100000 Then
                PermScores = PermScores + CurLow
            End If
        End If
    Next x
    PermScores = PermScores / NumFilesX
    If PermScores <= SumScores Then NumSmaller = NumSmaller + 1
    Form1.ProgressBar1.Value = (P / PermNo) * 100
    Call UpdateF2Prog
Next P
PVal = NumSmaller / PermNo '0.77359 focusing on all, 0.96709 focusing on the fit ones, 0.2898 focusing on unfit ones.
x = x



'test for change in mfe
ChDrive oDir
ChDir oDir
End Sub

Public Sub MutFreqs()

Dim MFreqs(13) As Long, ConvNuc(255, 255) As Byte, CCode As Byte, Done(255) As Byte


ConvNuc(66, 68) = 0 'a->c = 0
ConvNuc(66, 72) = 1 'a->g = 1
ConvNuc(66, 85) = 2 'a->t = 2
ConvNuc(68, 66) = 3 'c->a = 3
ConvNuc(68, 72) = 4 'c->g = 4
ConvNuc(68, 85) = 5 'c->t = 5
ConvNuc(72, 66) = 6 'g->a = 6
ConvNuc(72, 68) = 7 'g->c = 7
ConvNuc(72, 85) = 8 'g->t = 8
ConvNuc(85, 66) = 9 't->a = 9
ConvNuc(85, 68) = 10 't->c = 10
ConvNuc(85, 72) = 11 't->g = 11
'ins =12
'del =13

For x = 1 To Len(StrainSeq(0))
    XX = SeqNum(x, 0) 'a=66,c=68,g=72,t=85
    'if
    Done(66) = 0
    Done(68) = 0
    Done(72) = 0
    Done(85) = 0
    For Y = 2 To NextNo
        If SeqNum(x, 0) > 50 And SeqNum(x, 1) > 50 Then
            If SeqNum(x, Y) <> SeqNum(x, 1) And SeqNum(x, Y) <> SeqNum(x, 0) Then
                Done(SeqNum(x, Y)) = 1
                    
                
            End If
        End If
    Next Y
    If SeqNum(x, 1) = SeqNum(x, 0) Then
        If Done(66) = 1 Then
            CCode = ConvNuc(SeqNum(x, 0), 66)
            MFreqs(CCode) = MFreqs(CCode) + 1
        End If
        If Done(68) = 1 Then
            CCode = ConvNuc(SeqNum(x, 0), 68)
            MFreqs(CCode) = MFreqs(CCode) + 1
        End If
        If Done(72) = 1 Then
            CCode = ConvNuc(SeqNum(x, 0), 72)
            MFreqs(CCode) = MFreqs(CCode) + 1
        End If
        If Done(85) = 1 Then
            CCode = ConvNuc(SeqNum(x, 0), 85)
            MFreqs(CCode) = MFreqs(CCode) + 1
        End If
    End If
Next x

  oDir = CurDir
    ChDrive App.Path
    ChDir App.Path

Open "MutationFreqs.csv" For Append As #1
Print #1, ""
Print #1, "A->C," + Trim(Str(MFreqs(0)))
Print #1, "A->G," + Trim(Str(MFreqs(1)))
Print #1, "A->T," + Trim(Str(MFreqs(2)))
Print #1, "C->A," + Trim(Str(MFreqs(3)))
Print #1, "C->G," + Trim(Str(MFreqs(4)))
Print #1, "C->T," + Trim(Str(MFreqs(5)))
Print #1, "G->A," + Trim(Str(MFreqs(6)))
Print #1, "G->C," + Trim(Str(MFreqs(7)))
Print #1, "G->T," + Trim(Str(MFreqs(8)))
Print #1, "T->A," + Trim(Str(MFreqs(9)))
Print #1, "T->C," + Trim(Str(MFreqs(10)))
Print #1, "T->G," + Trim(Str(MFreqs(11)))

Close #1

  
    ChDrive oDir
    ChDir oDir
End Sub
Public Function EnoughDetect(Seqno, RecNo)

'Have enough methods detected the event?
GoOn = 0
If ConsensusProg > 0 Then
    CNum = 1
    For Z = 0 To AddNum - 1
        If XoverList(Seqno, RecNo).ProgramFlag <> Z And XoverList(Seqno, RecNo).ProgramFlag <> Z + AddNum And Confirm(SuperEventList(XoverList(Seqno, RecNo).Eventnumber), Z) > 0 Then
            CNum = CNum + 1
        End If
    Next
    If CNum > ConsensusProg Then GoOn = 1
Else
    GoOn = 1
End If
EnoughDetect = GoOn
End Function
Public Sub DrawPADREU()








Exit Sub

'The code below is for PADRE
Form1.SSPanel1.Caption = "Making UPGMA with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
If DoneTree(3, 3) = 0 Or x = x Then
    Call PADREUPGMA
    DoneTree(3, 3) = 1
    CurTree(3) = 3
End If
'CurTree(F2TreeIndex) = 2
'ExtraDx = DoTreeColour(Form2.Picture2(3), 2, 3)
'Call DoTreeLegend(TNum, TType,treeblocksl(), TBLLen, Form2.Picture2(3), 0, 14)
'Call treedrawing(0,0,treeblocksl(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(3))

Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
End Sub
Public Sub DrawPADREML()


Exit Sub
'The code below is for PADRE
Form1.SSPanel1.Caption = "Making ML tree with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
If DoneTree(4, 3) = 0 Then
    Call PADREML("", 0)
    DoneTree(4, 3) = 1
    CurTree(3) = 4
End If
'CurTree(F2TreeIndex) = 2
'ExtraDx = DoTreeColour(Form2.Picture2(3), 2, 3)
'Call DoTreeLegend(TNum, TType,treeblocksl(), TBLLen, Form2.Picture2(3), 0, 14)
'Call treedrawing(0,0,treeblocksl(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(3))

Form2.Label1(3).Caption = "PADRE Network Based on ML tree"
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
End Sub
Public Sub ScrollToVSPos(VS As VScrollBar, OldVal As Long, NewVal As Long)
Dim CurPos As Long
CurPos = OldVal
Do While CurPos <> NewVal

    CurPos = CLng(CurPos + (NewVal - CurPos) / 5)
    VS.Value = CurPos
    If CurPos > NewVal - 3 And CurPos < NewVal + 3 Then Exit Do
Loop


End Sub
Public Sub GoToThis2(Redraw, XP, YP, PermXVal As Single, PermYVal As Single)

Dim Y As Long, Z As Long, GoOn As Long
'Does the same as gotothis1 but avoids directly calling form1 events.
exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP
RecSeq = XP
PAVal = YP
Dim oPointer As Long
oPointer = Screen.MousePointer
If Screen.MousePointer <> 11 Then
    Screen.MousePointer = 11
End If

If ReassortmentFlag = 0 Then
    Form1.SSPanel1.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
Else
    Form1.SSPanel1.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
    Form2.SSPanel3.Caption = "Going to recombination/reassortment event " + Trim(Str(SuperEventList(XoverList(RelX, RelY).Eventnumber)))
End If
Form1.Refresh: Form2.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState

XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
If PermXVal = 0 And PermYVal = 0 Then 'ie find proper values
    
    
    Dim XS As Long
    If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
        XS = CInt((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    Else
        If XoverList(XP, YP).Ending > 12 * XPicAddjust Then
            XS = (1 + (XoverList(XP, YP).Ending - 1) / 2) * XPicAddjust + 10
        Else
            XS = (XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * XPicAddjust + 10
        End If
    End If
    If XS > UBound(PermArray, 1) Then XS = UBound(PermArray, 1)
    Dim GGx As Long
    For Y = 0 To UBound(PermArray, 2)

        If PermArray(0, Y) = XP Then
            
            For Z = Y + 2 To UBound(PermArray, 2)
                If PermArray(0, Z) = -(XP + 1) Then
                    'failed to find the "right" event
                    'so look for another example
                    EV = SuperEventList(XoverList(XP, YP).Eventnumber)
                    For GGx = Y + 2 To UBound(PermArray, 2)
                        'XX = PermArray(0, Y)
                        If PermArray(0, GGx) = -(XP + 1) Then
                            Exit Sub
                        End If
                        
                        If PermArray(XS, GGx) > 0 Then
                            If SuperEventList(XoverList(XP, PermArray(XS, GGx)).Eventnumber) = EV Then
                                PermYVal = (GGx * 12 + 3) * SpaceAdjust
                                GoOn = 1
                                Exit For
                            End If
                        End If
                        
'                        If PermArray(XS, g) = YP Then
'                            PermYVal = (g * 12 + 3) * SpaceAdjust
'                            GoOn = 1
'                            Exit For
'                        End If
'                        'Exit Sub
                        
                    Next GGx
                    
                    
                    
                    Exit For
                    
                End If
                
                If PermArray(XS, Z) = YP Then
                    PermYVal = (Z * 12 + 3) * SpaceAdjust
                    GoOn = 1
                    Exit For
                End If
                'Exit Sub
                
            Next Z
            'GoOn = 1
            Exit For
        End If
    Next Y

End If

Seq1 = XoverList(RelX, RelY).MajorP
Seq2 = XoverList(RelX, RelY).MinorP
Seq3 = XoverList(RelX, RelY).Daughter
Dim NewVal As Long, OldVal As Long
OldVal = Form1.VScroll2.Value
If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) < Form1.VScroll2.Max Then
    If CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj) > 0 Then
        NewVal = CLng((PermYVal - Form1.Picture6.ScaleHeight / 2) / F1VS2Adj)
        'CLng((y - Picture6.ScaleHeight / 2) / F1VS2Adj)
    Else
        NewVal = 0
    End If
Else
    If Form1.VScroll2.Max > 0 Then
        NewVal = Form1.VScroll2.Max
    Else
        NewVal = 0
    End If
End If
'VScroll2.Value = (PermYVal) / Picture6.ScaleHeight * VScroll2.Max  ' - Picture5.ScaleHeight ' / 12
If ButtonRepress = 1 Then
    Call ScrollToVSPos(Form1.VScroll2, OldVal, NewVal)
Else
    Form1.VScroll2.Value = NewVal
End If
PermXVal = 6 + CLng(XoverList(RelX, RelY).Beginning * XPicAddjust)
'XX = SuperEventList(XOverList(RelX, RelY).Eventnumber)

ProxButton = 0: ProxShift = 1: ProxX = PermXVal: ProxY = (PermYVal - Form1.VScroll2.Value)

'Form1.Timer2.Interval = 0
'Form1.Enabled = True
'Form1.Timer2.Enabled = True

'Form1.Timer2.Enabled = False
'Form1.Enabled = False
'X = X
'Form1.Timer2.Enabled = False
'Call Picture6_MouseMove(0, 1, PermXVal, (PermYVal - VScroll2.Value))

If Redraw = 1 Then
    
    F2ontop = 1
    If DontRedoQuickDistFlag = 0 Then
        If Form1.HScroll1.Value = Form1.HScroll1.Min Then
            H1C = 1
            DontDoH1Inc = 1
            Form1.HScroll1.Value = Form1.HScroll1.Min + 1
            H1C = 0
            DontDoH1Inc = 1
            Form1.HScroll1.Value = Form1.HScroll1.Min
            DontDoH1Inc = 0
        ElseIf Form1.HScroll1.Value < Form1.HScroll1.Max Then
            H1C = 1
            DontDoH1Inc = 1
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
            H1C = 0
            DontDoH1Inc = 1
            If Form1.HScroll1.Value > 0 Then
                Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            End If
            DontDoH1Inc = 0
        Else
            H1C = 1
            DontDoH1Inc = 1
            If Form1.HScroll1.Value > 0 Then
                Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            End If
            H1C = 0
            DontDoH1Inc = 1
            If Form1.HScroll1.Value < Form1.HScroll1.Max Then
                Form1.HScroll1.Value = Form1.HScroll1.Value + 1
            End If
            DontDoH1Inc = 0
        End If
    End If
    F2ontop = 0
    ButtonRepress = ButtonRepress + 1
'    SS = Abs(GetTickCount)
    Call SchemDown(1)
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X
    If ColDistInFile = 1 Then
        If FubValidInFile = 1 And DontRedoQuickDistFlag = 0 Then
            'redim SubValid(0,0)
            
            ReDim SubDiffs(0, 0)
            'redim sMat(0,0)
            ReDim FubValid(0, 0)
            'Erase FMat
        End If
        
        ReDim ColDist2(0)
        Form1.Timer7(1).Enabled = False
    End If
    '7.379,7.254,7.301
End If
'  XX = Form1.Command3.Enabled

'XX = Form1.Command3.Enabled

If Screen.MousePointer <> oPointer Then
    Screen.MousePointer = oPointer
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
End If

Form1.Timer1.Enabled = True
End Sub
Public Sub MakeSummary()
Dim Dummy As Long, Y As Long, A As Long, x As Long, lP As Single, AA As Long, VS4Offset As Long, CurE As Long, tCurE As Long, CoRec As Long, P2TextHeight As Single, P2TextWidth As Single, CurrY As Long, StringWidth As Single, TString As String
Dim MetPos As Single, Epos As Single, NPos As Single, Recpos As Single, MajPos As Single, MinPos As Single
Dim RMPos(13) As Single, F1P2SH As Long, F1P32SH As Long, STPY As Long, CurrX As Long, BE0 As Long, BE1 As Long, CharWid As Long, MaxChars As Long
Dim MaxTextWidth As Single, XOA As Long, XOO As Long, MaP As Long, Dag As Long, MiP As Long
Dim MNum As Long, SENum As Long, SWM As Single, SWP As Single
Dim XS As Long
Dim RangeEventsS As Long, RangeEventsE As Long
Dim hdc As Long

Dim F1P2SW As Long, F1P2SWt4 As Long
If CurrentlyRunningFlag = 1 Then
    Exit Sub
ElseIf SEventNumber = 0 Then
    Exit Sub
End If


Form1.Picture2.Top = 0
VS4Scrolling = 1

F1P2SH = Form1.Picture2.ScaleHeight
F1P32SH = Form1.Picture32.ScaleHeight
STPY = Screen.TwipsPerPixelY

If F1P2SH < (F1P32SH / STPY) Then F1P2SH = (F1P32SH / STPY)

If RelX > 0 Or RelY > 0 Then
    CurE = SuperEventList(XoverList(RelX, RelY).Eventnumber)
Else
    CurE = -1
End If

If PAVal > UBound(XoverList, 2) Then Exit Sub

If RecSeq > 0 Or PAVal > 0 Then
    If PAVal > 0 Then
        tCurE = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
    Else
        tCurE = -1
    End If
Else
    tCurE = -1
End If

Epos = 2.5
NPos = 10
Recpos = 25
MajPos = 45
MinPos = 65
MetPos = 89.5

RMPos(0) = 80
RMPos(1) = 83.25
RMPos(2) = 86.5
RMPos(3) = 89.75
RMPos(4) = 93
RMPos(5) = 96.25
RMPos(8) = 99.5

With Form1.SSPanel16
    If .Caption <> "Overview" Then
        .BackColor = 0
        .ForeColor = Form1.BackColor
        .FontSize = 13
        .Font.Bold = True
        .Caption = "Overview"
    End If
End With

Form1.Picture2.Picture = LoadPicture()
Form1.Picture2.ScaleMode = 3
Form1.Picture2.CurrentY = 0
P2TextHeight = Form1.Picture2.TextHeight(AA) + 2
P2TextWidth = (((Form1.Picture32.ScaleWidth) / Screen.TwipsPerPixelX) - 10) / 100

MaxTextWidth = 19.5 * P2TextWidth

If P2TextHeight > 15 Then P2TextHeight = 15
Dim TestMax As Long
If ((SEventNumber + 5) * P2TextHeight - (F1P32SH / STPY)) > 0 Then
    TestMax = ((SEventNumber + 5) * P2TextHeight - (F1P32SH / STPY))
    If TestMax > 32000 Then
        V4Adj = 32000 / TestMax
        TestMax = 32000
    Else
        V4Adj = 1
    End If
    Form1.VScroll4.Enabled = True
Else
    If Form1.VScroll4.Max <> 0 Then
        Form1.VScroll4.Max = 0
        TestMax = 0
    End If
End If

If TestMax <> Form1.VScroll4.Max Then Form1.VScroll4.Max = TestMax

Form1.Picture2.AutoRedraw = True
If V4Adj = 0 Then V4Adj = 1
VS4Offset = Form1.VScroll4.Value / V4Adj

CurrY = -VS4Offset + P2TextHeight + 15

ReDim FoundMethods(SEventNumber, 20)

RangeEventsS = CLng(VS4Offset / P2TextHeight)
RangeEventsE = RangeEventsS + ((F1P32SH / Screen.TwipsPerPixelX) / P2TextHeight)
If RangeEventsE > SEventNumber Then RangeEventsE = SEventNumber
If RangeEventsS <= 0 Then RangeEventsS = 1
lP = -Log(LowestProb) / Log(10)



F1P2SW = Form1.Picture2.ScaleWidth
F1P2SWt4 = F1P2SW * 4
hdc = Form1.Picture2.hdc
CharWid = Form1.Picture2.TextWidth("I")
MaxChars = Int((MaxTextWidth / CharWid))
With Form1.Picture2
    If PrintCharLenFlag = 0 Then
        'SS = Abs(GetTickCount)
        'For Y = 1 To 100
        For x = 0 To PermNextno
            TString = Left(OriginalName(x), MaxChars)
            Do
                If .TextWidth(TString) > MaxTextWidth Then
                    TString = Left(TString, Len(TString) - 1)
                Else
                    Exit Do
                End If
    
            Loop
            PrintCharLen(x) = Len(TString)
        Next x
        'Next Y
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X
        PrintCharLenFlag = 1
    End If
End With
XS = RangeEventsS - 2
x = RangeEventsS - 1
SWM = Form1.Picture2.TextWidth("-") / 2
SWP = Form1.Picture2.TextWidth("+") / 2



If ReassortmentFlag = 1 Then
     UB = -1
     On Error Resume Next
     UB = UBound(RBPPos, 1)
     On Error GoTo 0
     If UB < RBPNum Then
         ReDim Preserve RBPPos(RBPNum)
     End If
     Dim Segbound() As Byte
     ReDim Segbound(Len(StrainSeq(0)))
     For x = 0 To RBPNum
         'XX = UBound(RBPPos, 1)
         tBP = RBPPos(x)
         Segbound(RBPPos(x)) = 1
     Next x
End If



XS = RangeEventsS - 2
x = RangeEventsS - 1

On Error Resume Next
UB = -1
UB = UBound(BestEvent, 1)
If UB < 1 Then Exit Sub
On Error GoTo 0
Dim NotRA As Byte, BEEFlag As Byte

Do While x <= RangeEventsE
    XS = XS + 1
    
    
    
    If x > 0 Then
        BEEFlag = 0
        NotRA = 1
        BE0 = BestEvent(x, 0): BE1 = BestEvent(x, 1)
        If BE1 > -1 Then
            
            If ReassortmentFlag = 1 Then
    
                If Segbound(XoverList(BE0, BE1).Beginning) = 1 Or Segbound(XoverList(BE0, BE1).Ending) = 1 Then
                    NotRA = 0
                End If
                
            End If
            
            
            XOA = XoverList(BE0, BE1).Accept
            'If XOA = 3 Then
            '    X = X
            'End If
            If QvRFlag = 1 Then
                For A = 0 To NextNo
                    If Daught(x, A) = 1 Then
                        If ReferenceList(A) > 0 Then
                            XOA = 3
                        End If
                    End If
                Next A
            End If
            XOO = XoverList(BE0, BE1).OutsideFlag
            CurrY = -VS4Offset + 15 + XS * (P2TextHeight)
            With Form1.Picture2
            
                Form1.Picture2.CurrentY = CurrY
                
                
                'make the background lines
                If BE0 = 0 And BE1 = 0 Then
                    If (XS + 1) / 2 = CLng((XS + 1) / 2) Then
                         '
                         Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY + 11), BackColours, BF
                    End If
                Else
                    For Y = 0 To AddNum - 1
                        If ConfirmP(x, Y) > lP Or Confirm(x, Y) > 1 Then
                            FoundMethods(x, Y) = 1
                        End If
                    Next Y
                    
                    .FontBold = False
                    
                    If (XS + 1) / 2 = CLng((XS + 1) / 2) Then
                        Form1.Picture2.Line (0, .CurrentY - 1)-(F1P2SWt4, .CurrentY + 11), BackColours, BF
                    End If
                    
                    If x = CurE Then
                        Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY + 11), RGB(255, 255, 196), BF
                    ElseIf x = tCurE Then
                        Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY + 11), RGB(220, 220, 176), BF
                    Else
                        .ForeColor = 0
                    End If
                    
                    If BE1 <> -1 Then
                        If XOA = 1 Then
                            Form1.Picture2.Line (0, CurrY - 1)-(F1P2SW - 2, CurrY + 11), RGB(255, 0, 0), B
                        End If
                    End If
                    
                    'print the event number
                    TString = Trim(Str(x))
                    StringWidth = .TextWidth(TString) / 2
                    CurrX = 5 + P2TextWidth * Epos - StringWidth
                    If BE1 <> -1 Then
                        If XOA = 2 Then
                            .ForeColor = HalfColour
                        ElseIf XOA = 3 And QvRFlag = 1 Then
                            .ForeColor = RGB(255, 128, 0)
                        Else
                            .ForeColor = 0
                        End If
                    End If
                    
                    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                    
                    
                    'print the number of corecombinants
                    CoRec = 0
                    'XX = UBound(Daught, 1)
                    'XX = UBound(Daught, 1)
                    'Get #FF, , ExcludedEventNum

                    If x = x Then
'                        If X = 245 Then
'                            X = X
'                        End If
                        If ExcludedEventNum > 0 Then
                                    
                            If UBound(ELLite, 2) = 0 Then
                                Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
                            End If
                            CoRec = SumEventCount(x)
                        Else
                            CoRec = GetCoRec(x, PermNextno, UBound(Daught, 1), Daught(0, 0))
                        End If
                        
                    ElseIf x = 123456789 Then
                        'XX = NextNo
                        'If CurE = X And ExcludedEventNum > 0 Then
                        '    CoRec = GetCoRec(X, UBound(Daught, 2), UBound(Daught, 1), Daught(0, 0))
                        'Else
                            CoRec = GetCoRec(x, PermNextno, UBound(Daught, 1), Daught(0, 0))
                            
                            If ExcludedEventNum > 0 Then
                                If UBound(ELLite, 2) = 0 Then
                                    
                                    Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
                                End If
                                If x = 123456 Then
                                    CoRec = CoRec + AddExcludesToCoRec(x, UBound(ELLite, 2), UBound(ELLite, 1), UBound(Daught, 1), ELLite(0, 0), Daught(0, 0))
                                Else
                                    For Y = 0 To UBound(ELLite, 2)
                                        If ELLite(3, Y) <= UBound(Daught, 2) Then
                                            If x = Abs(ELLite(1, Y)) And Daught(x, ELLite(3, Y)) > 0 Then
                                                CoRec = CoRec + 1
                                            End If
                                        End If
                                    Next Y
                                    CoRec = CoRec - 1
                                End If
                            End If
                        'End If
                    Else
                        For Y = 0 To PermNextno
                            If Daught(x, Y) <> 0 Then
                                CoRec = CoRec + 1
                            End If
                        Next Y
                    End If
                    
                    TString = Trim(Str(CoRec))
                    StringWidth = .TextWidth(TString) / 2
                    CurrX = 5 + P2TextWidth * NPos - StringWidth
                    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                        
                     If UBound(PrintCharLen, 1) < UBound(OriginalName, 1) Then
                        ReDim Preserve PrintCharLen(UBound(OriginalName, 1))
                     End If
                    'print the recombinant name
                    Dim DCV1 As Long, DCV2 As Long, DCV3 As Long, DCV4 As Long
                    DCV1 = 0: DCV2 = 0: DCV3 = 0: DCV4 = 0
                    Call SplitP(-XoverList(BE0, BE1).BeginP, DCV1, DCV2)
                    Call SplitP(-XoverList(BE0, BE1).EndP, DCV3, DCV4)
'                    If x = 92 Then
'                        x = x
'                    End If
                    If XoverList(BE0, BE1).BeginP < 0 And XoverList(BE0, BE1).Daughter = DCV2 Then
                        TString = Left(FullOName(DCV1), PrintCharLen(BE0))
                    ElseIf XoverList(BE0, BE1).EndP < 0 And XoverList(BE0, BE1).Daughter = DCV4 Then
                        TString = Left(FullOName(DCV3), PrintCharLen(BE0))
                    Else
                        TString = Left(OriginalName(BE0), PrintCharLen(BE0))
                    End If
    '                TString = Left(TString, (MaxTextWidth / .TextWidth(TString)) * Len(TString))
    '                Do
    '                    If .TextWidth(TString) > MaxTextWidth Then
    '                        TString = Left(TString, Len(TString) - 1)
    '                    Else
    '                        Exit Do
    '                    End If
    '
    '                Loop
                    
                    If BE1 <> -1 Then
                        If x = CurE Then
                            If ReassortmentFlag = 1 Then
                                If NotRA = 1 Then
                                    .ForeColor = RGB(255, 0, 0)
                                Else
                                    .ForeColor = RGB(255, 128, 0)
                                End If
                            Else
                                .ForeColor = RGB(255, 0, 0)
                            End If
                        ElseIf XOA = 2 Then
                            .ForeColor = HalfColour
                        ElseIf XOA = 3 And QvRFlag = 1 Then
                            .ForeColor = RGB(255, 128, 0)
                        Else
                            If ReassortmentFlag = 1 Then
                                If NotRA = 1 Then
                                    .ForeColor = RGB(196, 0, 0)
                                Else
                                    .ForeColor = RGB(196, 128, 0)
                                End If
                            Else
                                .ForeColor = 0
                            End If
                        End If
                    Else
                        If x = CurE Then
                            If ReassortmentFlag = 1 Then
                                If NotRA = 1 Then
                                    .ForeColor = RGB(255, 0, 0)
                                Else
                                    .ForeColor = RGB(255, 128, 0)
                                End If
                            Else
                                .ForeColor = RGB(255, 0, 0)
                            End If
                        Else
                            If ReassortmentFlag = 1 Then
                                If NotRA = 1 Then
                                    .ForeColor = RGB(196, 0, 0)
                                Else
                                    .ForeColor = RGB(196, 128, 0)
                                End If
                            Else
                                .ForeColor = 0
                            End If
                        End If
                    End If
                    
                    .CurrentY = CurrY
                    StringWidth = .TextWidth(TString) / 2
                    CurrX = 5 + P2TextWidth * Recpos - StringWidth
                    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                    
                    
                    
                    
                    
                    'Print the major parent name
                    If BE1 <> -1 Then
                        If x = CurE Then
                            .ForeColor = RGB(0, 200, 0)
                        ElseIf XOA = 2 Then
                        
                            .ForeColor = HalfColour
                        ElseIf XOA = 3 And QvRFlag = 1 Then
                            .ForeColor = RGB(255, 128, 0)
                        Else
                            .ForeColor = 0
                        End If
'                        If X = 159 Then
'                            X = X
'                        End If
                        If XOO = 0 Or XOO = 2 Then
                            MaP = XoverList(BE0, BE1).MajorP
                            If XoverList(BE0, BE1).BeginP < 0 And MaP = DCV2 Then
                                TString = Left(FullOName(DCV1), PrintCharLen(BE0))
                            ElseIf XoverList(BE0, BE1).EndP < 0 And MaP = DCV4 Then
                                TString = Left(FullOName(DCV3), PrintCharLen(BE0))
                            Else
                                If MaP <= UBound(OriginalName, 1) Then
                                    TString = Left(OriginalName(MaP), PrintCharLen(MaP))
                                End If
                            End If
'                            If XoverList(BE0, BE1).BeginP < 0 And MaP = Int(Abs(XoverList(BE0, BE1).BeginP) - 1) Then
'                                TString = Left(FullOName(XoverList(BE0, BE1).EndP), PrintCharLen(BE0))
'                            ElseIf XoverList(BE0, BE1).EndP < 0 And MaP = Int(Abs(XoverList(BE0, BE1).EndP) - 1) Then
'                                TString = Left(FullOName(XoverList(BE0, BE1).EndP), PrintCharLen(BE0))
'                            Else
'                                TString = Left(OriginalName(MaP), PrintCharLen(MaP))
'                            End If
                        Else
                            If .ForeColor <> HalfColour Then
                                .ForeColor = 0
                            End If
                            TString = "Unknown"
                        End If
                    Else
                        If x = CurE Then
                            .ForeColor = RGB(0, 200, 0)
                        Else
                            .ForeColor = 0
                        End If
                    
                        
                        If .ForeColor <> HalfColour Then
                            .ForeColor = 0
                        End If
                        TString = "Unknown"
                    End If
                    
                    
    '                TString = Left(TString, (MaxTextWidth / .TextWidth(TString)) * Len(TString))
    '                Do
    '                    If .TextWidth(TString) > MaxTextWidth Then
    '                        TString = Left(TString, Len(TString) - 1)
    '                    Else
    '                        Exit Do
    '                    End If
    '
    '                Loop
    
                    StringWidth = .TextWidth(TString) / 2
                    CurrX = 5 + P2TextWidth * MajPos - StringWidth
                    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                    
                    'Print the minor parent name
                    If BE1 <> -1 Then
                        If x = CurE Then
                            .ForeColor = RGB(0, 0, 255)
                        ElseIf XOA = 2 Then
                            .ForeColor = HalfColour
                        ElseIf XOA = 3 And QvRFlag = 1 Then
                            .ForeColor = RGB(255, 128, 0)
                        Else
                            .ForeColor = 0
                        End If
                    
                        If XOO = 0 Or XOO = 1 Then
                            MiP = XoverList(BE0, BE1).MinorP
                            If XoverList(BE0, BE1).BeginP < 0 And MiP = DCV2 Then
                                TString = Left(FullOName(DCV1), PrintCharLen(BE0))
                            ElseIf XoverList(BE0, BE1).EndP < 0 And MiP = DCV4 Then
                                TString = Left(FullOName(DCV3), PrintCharLen(BE0))
                            Else
                                If MiP <= UBound(OriginalName) Then
                                    TString = Left(OriginalName(MiP), PrintCharLen(MiP))
                                End If
                            End If
'                            If XoverList(BE0, BE1).BeginP < 0 And MiP = Int(Abs(XoverList(BE0, BE1).BeginP) - 1) Then
'                                TString = Left(FullOName(XoverList(BE0, BE1).EndP), PrintCharLen(BE0))
'                            ElseIf XoverList(BE0, BE1).EndP < 0 And MiP = Int(Abs(XoverList(BE0, BE1).EndP) - 1) Then
'                                TString = Left(FullOName(XoverList(BE0, BE1).EndP), PrintCharLen(BE0))
'                            Else
'                                TString = Left(OriginalName(MiP), PrintCharLen(MiP))
'                            End If
                        Else
                            If .ForeColor <> HalfColour Then
                                .ForeColor = 0
                            End If
                            TString = "Unknown"
                        End If
                    Else
                        If x = CurE Then
                            .ForeColor = RGB(0, 0, 255)
                        Else
                            .ForeColor = 0
                        End If
                    
                        
                        If .ForeColor <> HalfColour Then
                            .ForeColor = 0
                        End If
                        TString = "Unknown"
                    End If
    '                TString = Left(TString, (MaxTextWidth / .TextWidth(TString)) * Len(TString))
    '                Do
    '                    If .TextWidth(TString) > MaxTextWidth Then
    '                        TString = Left(TString, Len(TString) - 1)
    '                    Else
    '                        Exit Do
    '                    End If
    '
    '                Loop
                    
                    'print the found with methods +s and -s
                    StringWidth = .TextWidth(TString) / 2
                    CurrX = 5 + P2TextWidth * MinPos - StringWidth
                    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                    
                    If BE1 <> -1 Then
                        If XOA = 2 Then
                            .ForeColor = HalfColour
                        ElseIf XOA = 3 And QvRFlag = 1 Then
                            .ForeColor = RGB(255, 128, 0)
                        Else
                            .ForeColor = 0
                        End If
                    Else
                        .ForeColor = 0
                    End If
                    
                    For Y = 0 To 8
                        If FoundMethods(x, Y) = 1 Or FoundMethods(x, Y + AddNum) = 1 Then
                            TString = "+"
                            StringWidth = SWP
                        Else
                            TString = "-"
                            StringWidth = SWM
                        End If
                        If RMPos(Y) > 0 Then
                            'StringWidth = .TextWidth(TString) / 2
                            CurrX = 5 + P2TextWidth * RMPos(Y) - StringWidth
                            Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
                        End If
                    Next Y
                
                End If
            End With
        End If
    End If
    x = x + 1
Loop
'Exit Sub
If RangeEventsE = SEventNumber Then
    CurrY = Form1.Picture2.CurrentY + Form1.Picture2.TextHeight("A") + 2
    Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY), RGB(0, 0, 0)
End If


CurrY = 0
Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY + P2TextHeight * 2), BackColours, BF


Form1.Picture2.CurrentY = CurrY

Form1.Picture2.ForeColor = RGB(0, 0, 0)

MaxTextWidth = 7.5 * P2TextWidth
TString = "Event"
StringWidth = Form1.Picture2.TextWidth(TString) / 2
If StringWidth * 2 > MaxTextWidth Then
    TString = "Evnt"
    StringWidth = Form1.Picture2.TextWidth(TString) / 2
End If
CurrX = 5 + P2TextWidth * Epos - StringWidth

Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))


MaxTextWidth = 7.5 * P2TextWidth

TString = "Found"
StringWidth = Form1.Picture2.TextWidth(TString) / 2
If StringWidth * 2 > MaxTextWidth Then
    TString = "Fnd"
    StringWidth = Form1.Picture2.TextWidth(TString) / 2
    
End If
CurrX = 5 + P2TextWidth * NPos - StringWidth
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

'FMaxTextWidth = 20 * P2TextWidthf
Form1.Picture2.CurrentY = CurrY

If ReassortmentFlag = 0 Then
    StringWidth = Form1.Picture2.TextWidth("Recombinant") / 2
    'MaxTextWidth = 19.5 * P2TextWidth
    TString = "Recombinant"
    If StringWidth * 2 > MaxTextWidth Then
        TString = "Recomb."
        StringWidth = Form1.Picture2.TextWidth(TString) / 2
        
    End If
Else
    StringWidth = Form1.Picture2.TextWidth("Recombinant/") / 2
    'MaxTextWidth = 19.5 * P2TextWidth
    Form1.Picture2.ForeColor = RGB(196, 0, 0)
    TString = "Recombinant/"
    If StringWidth * 2 > MaxTextWidth Then
        TString = "Recomb./"
        StringWidth = Form1.Picture2.TextWidth(TString) / 2
        
    End If
End If

CurrX = 5 + P2TextWidth * Recpos - StringWidth
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

Form1.Picture2.ForeColor = RGB(0, 0, 0)


StringWidth = Form1.Picture2.TextWidth("Major") / 2
CurrX = 5 + P2TextWidth * MajPos - StringWidth
TString = "Major"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("Minor") / 2
CurrX = 5 + P2TextWidth * MinPos - StringWidth
TString = "Minor"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("Detection methods") / 2
CurrX = 5 + P2TextWidth * MetPos - StringWidth
TString = "Detection methods"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
CurrY = Form1.Picture2.CurrentY

CurrY = Form1.Picture2.TextHeight("A") + 2
'CurrY = Form1.Picture2.CurrentY
TString = "number"
StringWidth = Form1.Picture2.TextWidth(TString) / 2
If 5 + P2TextWidth * Epos - StringWidth < 0 Then
    TString = "no."
    StringWidth = Form1.Picture2.TextWidth(TString) / 2
    If 5 + P2TextWidth * Epos - StringWidth < 0 Then
        TString = "#"
        StringWidth = Form1.Picture2.TextWidth(TString) / 2
    End If
End If
CurrX = 5 + P2TextWidth * Epos - StringWidth
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))



TString = "in"
StringWidth = Form1.Picture2.TextWidth(TString) / 2
CurrX = 5 + P2TextWidth * NPos - StringWidth
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

'Form1.Picture2.CurrentY = CurrY
'StringWidth = Form1.Picture2.TextWidth("(# of others)") / 2
'Form1.Picture2.CurrentX = 5 + P2TextWidth * Recpos - StringWidth
'TString = "(# of others)"
'Dummy = TextOut(hDC, Form1.Picture2.CurrentX, Form1.Picture2.CurrentY, TString, Len(TString))

If ReassortmentFlag = 1 Then
    'Form1.Picture2.CurrentY = CurrY
    StringWidth = Form1.Picture2.TextWidth("Reassortant") / 2
    MaxTextWidth = 19.5 * P2TextWidth
    TString = "Reassortant"
    If StringWidth * 2 > MaxTextWidth Then
        TString = "Reassort."
        StringWidth = Form1.Picture2.TextWidth(TString) / 2
        
    End If
    CurrX = 5 + P2TextWidth * Recpos - StringWidth
    Form1.Picture2.ForeColor = RGB(196, 96, 0)
    Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))
    Form1.Picture2.ForeColor = RGB(0, 0, 0)
End If




StringWidth = Form1.Picture2.TextWidth("parent") / 2
CurrX = 5 + P2TextWidth * MajPos - StringWidth
TString = "parent"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("parent") / 2
CurrX = 5 + P2TextWidth * MinPos - StringWidth
TString = "parent"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))


StringWidth = Form1.Picture2.TextWidth("R") / 2
CurrX = 5 + P2TextWidth * RMPos(0) - StringWidth
TString = "R"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("G") / 2
CurrX = 5 + P2TextWidth * RMPos(1) - StringWidth
TString = "G"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("B") / 2
CurrX = 5 + P2TextWidth * RMPos(2) - StringWidth
TString = "B"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("M") / 2
CurrX = 5 + P2TextWidth * RMPos(3) - StringWidth
TString = "M"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))


StringWidth = Form1.Picture2.TextWidth("C") / 2
CurrX = 5 + P2TextWidth * RMPos(4) - StringWidth
TString = "C"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))



StringWidth = Form1.Picture2.TextWidth("S") / 2
CurrX = 5 + P2TextWidth * RMPos(5) - StringWidth
TString = "S"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

StringWidth = Form1.Picture2.TextWidth("T") / 2
CurrX = 5 + P2TextWidth * RMPos(8) - StringWidth
TString = "T"
Dummy = TextOut(hdc, CurrX, CurrY, TString, Len(TString))

CurrY = (Form1.Picture2.TextHeight("A") + 2) * 2

Form1.Picture2.Line (0, CurrY - 1)-(F1P2SWt4, CurrY), RGB(0, 0, 0)

If Form1.Command13(2).Caption <> "Recombination Info" Then
    Form1.Command13(2).Caption = "Recombination Info"
End If
Form1.Picture2.Refresh
'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X
VS4Scrolling = 0
End Sub

Public Sub GotoNxt()
Dim x As Long, SEN As Long, Cycle As Long, GoOn As Long, Y As Long, Z As Long, A As Long
F2ontop = 1
Form1.Enabled = False
'Form2.SSPanel2.Enabled = False
If F2C8Press = 0 Then
    Form2.Picture2(0).Enabled = False
    Form2.Picture2(1).Enabled = False
    Form2.Picture2(2).Enabled = False
    Form2.Picture2(3).Enabled = False
End If
MenuUpFlag = 0
Dim HiProb As Double, LoProb As Double, XP As Long, YP As Long
Dim AcProg() As Byte
ReDim AcProg(AddNum * 2)
For x = 0 To AddNum - 1
    If DoScans(0, x) = 1 Then AcProg(x) = 1: AcProg(x + AddNum) = 1
    
Next x

Form1.Timer1.Enabled = False

If RelX = 0 And RelY = 0 Then
    SEN = 0
Else
    SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
End If
Dim GotoAny As Long
GotoAny = 1
If ClickedInTreeFlag = 0 Then
    For x = 1 To SEventNumber
        XP = BestEvent(x, 0)
        YP = BestEvent(x, 1)
        If XoverList(XP, YP).Accept = 0 Then
            PN = 0
            For Y = 0 To AddNum - 1
                If Confirm(x, Y) > 0 Then PN = PN + 1
                
            Next Y
            If PN > ConsensusProg Then
                GotoAny = 0
                Exit For
            End If
            
        End If
    Next x
End If

Cycle = 0
RedoFind:

Do
    SEN = SEN + 1
    
    If SEventNumber < SEN Then
        SEN = 1
        Cycle = Cycle + 1
        If Cycle = 2 Then
        
            
            Form1.Timer1.Enabled = True
            'XX = Form1.Command3.Enabled
            Form1.Enabled = True
            Exit Sub
        End If
    End If
    
    XP = BestEvent(SEN, 0)
    YP = BestEvent(SEN, 1)
    If YP < 0 Or (XP = 0 And YP = 0) Then
        GoTo RedoFind
    End If
    GoOn = 0
    If XoverList(XP, YP).Accept = 0 Or GotoAny = 1 Then
        GoOn = 1
    Else
        If XoverList(XP, YP).Accept = 1 Then
            If Form1.SkipAcceptedMnu.Checked = False Or ClickedInTreeFlag = 1 Then
                GoOn = 1
            
            End If
        Else
            If Form1.SkipRejectedMnu.Checked = False Or ClickedInTreeFlag = 1 Then
                GoOn = 1
            
            End If
        End If
    End If
    If GoOn = 1 Then
        PN = 0
        For x = 0 To AddNum - 1
            If Confirm(SEN, x) > 0 Then PN = PN + 1
            
        Next x
        If PN > ConsensusProg Then
            
            Exit Do
        End If
    End If
    
Loop





'Find position of the region on the screen (in picture6)
XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))

Dim XS As Long
If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
    XS = CLng((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
Else
    'XS = CInt((1 + (XOverList(XP, YP).Ending - 1) / 2) * AdjArrayPos)
    XS = 1 'CInt((XOverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XOverList(XP, YP).Beginning) / 2) * AdjArrayPos)
    'If XOverList(XP, YP).Ending > (12 * XPicAddjust) Then
    '    XS = (1 + (XOverList(XP, YP).Ending - 1) / 2) * AdjArrayPos
    'Else
    '    XS = (XOverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XOverList(XP, YP).Beginning) / 2) * AdjArrayPos
    'End If
End If

If XS = UBound(PermArray, 1) Then XS = XS - 1

GoOn = 0
For Y = 0 To UBound(PermArray, 2)

    If PermArray(0, Y) = XP Then
        '275
        For Z = Y + 2 To UBound(PermArray, 2)
            If PermArray(0, Z) = -(XP + 1) Then
                If XS = 1 Then
                    XS = 2
                End If
                For A = Y + 2 To UBound(PermArray, 2)
                    If PermArray(0, A) = -(XP + 1) Then
                        Exit For
                    End If
                    If PermArray(XS, A) = YP Then ' Or PermArray(XS + 1, A) = YP Then
                        GoOn = 1
                        Exit For
                    End If
                Next A
                
                If GoOn = 0 Then
                    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
                    LoProb = XoverList(XP, YP).Probability
                    HiProb = 1
                    'Exit Sub
                    GoTo RedoFind
                End If
                
            End If
            
            If PermArray(XS, Z) = YP Or PermArray(XS + 1, Z) = YP Then
                PermYVal = (Z * 12 + 3) * SpaceAdjust
                GoOn = 1
                Exit For
            End If
            'Exit Sub
            
        Next Z
        'GoOn = 1
        Exit For
    End If
Next Y

If GoOn = 0 Then
    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
    LoProb = XoverList(XP, YP).Probability
    HiProb = 1
    'XOverList(XP, YP).Accept = 2
    GoTo RedoFind
    
End If

exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP
RecSeq = XP
PAVal = YP
If PAVal < 0 Then
            x = x
        End If
If XP > 0 Or YP > 0 Then
    Call GoToThis2(1, XP, YP, PermXVal, PermYVal)
    
End If



Form1.Enabled = True
'Form2.SSPanel2.Enabled = True
If F2C8Press = 0 Then
    Form2.Picture2(0).Enabled = True
    Form2.Picture2(1).Enabled = True
    Form2.Picture2(2).Enabled = True
    Form2.Picture2(3).Enabled = True
End If
F2ontop = 2
Form1.Enabled = False
Form1.Enabled = True
F2ontop = 0

Form2.ZOrder
Form1.Refresh

End Sub

Public Sub GotoPrev()


'Form2.SSPanel2.Enabled = False
If F2C8Press = 0 Then
    Form2.Picture2(0).Enabled = False
    Form2.Picture2(1).Enabled = False
    Form2.Picture2(2).Enabled = False
    Form2.Picture2(3).Enabled = False
End If
F2ontop = 1
Form1.Enabled = False

MenuUpFlag = 0
Dim HiProb As Double, LoProb As Double, XP As Long, YP As Long
Dim AcProg() As Byte
ReDim AcProg(AddNum * 2)
For x = 0 To AddNum - 1
    If DoScans(0, x) = 1 Then AcProg(x) = 1: AcProg(x + AddNum) = 1
    
Next x



Form1.Timer1.Enabled = False

If RelX = 0 And RelY = 0 Then
    SEN = SEventNumber
Else
    SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
End If
Cycle = 0
RedoFind:

Do
    SEN = SEN - 1
    
    If SEN < 1 Then
        SEN = SEventNumber
        Cycle = Cycle + 1
        If Cycle = 2 Then
            Timer1.Enabled = True
            Exit Sub
        End If
    End If
    
    XP = BestEvent(SEN, 0)
    YP = BestEvent(SEN, 1)
    If XP = 0 And YP = 0 Then GoTo RedoFind
    GoOn = 0
    XX = SuperEventList(XoverList(XP, YP).Eventnumber)
    If SuperEventList(XoverList(XP, YP).Eventnumber) <> SEN Then
        SuperEventList(XoverList(XP, YP).Eventnumber) = SEN
    End If
    If XoverList(XP, YP).Accept = 0 Then
        GoOn = 1
    Else
        If XoverList(XP, YP).Accept = 1 Then
            If Form1.SkipAcceptedMnu.Checked = False Then
                GoOn = 1
            
            End If
        Else
            If Form1.SkipRejectedMnu.Checked = False Then
                GoOn = 1
            
            End If
        End If
    End If
    If GoOn = 1 Then
        PN = 0
        For x = 0 To AddNum - 1
            If Confirm(SEN, x) > 0 Then PN = PN + 1
            
        Next x
        If PN > ConsensusProg Then
            Exit Do
        End If
    End If
    
Loop




'Find position of the region on the screen (in picture6)
XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
Dim XS As Long
If XoverList(XP, YP).Beginning < XoverList(XP, YP).Ending Then
    XS = CInt((XoverList(XP, YP).Beginning + (XoverList(XP, YP).Ending - XoverList(XP, YP).Beginning) / 2) * AdjArrayPos)
Else
    If XoverList(XP, YP).Ending > 12 * XPicAddjust Then
        XS = (1 + (XoverList(XP, YP).Ending - 1) / 2) * XPicAddjust + 10
    Else
        XS = (XoverList(XP, YP).Beginning + (Len(StrainSeq(0)) - XoverList(XP, YP).Beginning) / 2) * XPicAddjust + 10
    End If
End If

If XS = UBound(PermArray, 1) Then XS = XS - 1

GoOn = 0
For Y = 0 To UBound(PermArray, 2)

    If PermArray(0, Y) = XP Then
        
        For Z = Y + 2 To UBound(PermArray, 2)
            If PermArray(0, Z) = -(XP + 1) Then
                XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
                LoProb = XoverList(XP, YP).Probability
                HiProb = 1
                'Exit Sub
                GoTo RedoFind
                
            End If
            
            If PermArray(XS, Z) = YP Or PermArray(XS + 1, Z) = YP Then
                PermYVal = (Z * 12 + 3) * SpaceAdjust
                GoOn = 1
                Exit For
            End If
            'Exit Sub
            
        Next Z
        'GoOn = 1
        Exit For
    End If
Next Y

If GoOn = 0 Then
    XoverList(XP, YP).Probability = XoverList(XP, YP).Probability * 0.99999999
    LoProb = XoverList(XP, YP).Probability
    HiProb = 1
    'XOverList(XP, YP).Accept = 2
    GoTo RedoFind
    
End If

exRelX = RelX
exRely = RelY
RelX = XP
RelY = YP
RecSeq = XP
PAVal = YP
If PAVal < 0 Then
            x = x
        End If
If XP > 0 Or YP > 0 Then
    Call GoToThis2(1, XP, YP, PermXVal, PermYVal)
End If



'Form2.SSPanel2.Enabled = True
If F2C8Press = 0 Then
    Form2.Picture2(0).Enabled = True
    Form2.Picture2(1).Enabled = True
    Form2.Picture2(2).Enabled = True
    Form2.Picture2(3).Enabled = True
End If
Form1.Enabled = True


F2ontop = 2
Form1.Enabled = False
Form1.Enabled = True
F2ontop = 0
Form2.ZOrder
Form1.Refresh


End Sub
Public Sub DrawML5(PictureBoxX As PictureBox, TreeStrat)
Form1.SSPanel1.Caption = "Making ML tree with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
If TreeStrat = 5 Then
    If DoneTree(2, 3) = 0 Then
        Call DoBigTree(TreeStrat)
        DoneTree(2, 3) = 1
        
    End If
ElseIf TreeStrat = 4 Then
    If DoneTree(4, 3) = 0 Then
        Call DoBigTree(TreeStrat)
        DoneTree(4, 3) = 1
        
    End If
End If
If TreeStrat = 5 Then
    CurTree(3) = 2
    TType = 2
ElseIf TreeStrat = 4 Then
    CurTree(3) = 4
    TType = 4
End If
ExtraDX = DoTreeColour(Form2.Picture2(3), CurTree(3), 3)
TNum = 3




ExtraDX = DoTreeColour(Form2.Picture2(3), 0, 3)
                
Index = 3
Dim tTYF As Double, TYFM As Integer
Call ModOffsets(8.25, Form2.Picture2(Index), tTYF, TYFM)
otTYF = tTYF
With Form2.VScroll1(Index)
    VSMax = .Max
    If VSMax <= 0 Then .Value = 0
    
    OVx = (.Value / .Max)
    If OVx < 0 Then OVx = 0
     
    OV = .Value
    OM = VSMax
    
    If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
        VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
    Else
        VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
    End If
    If OM = 0 Then OM = 1
    If VSMax > 32000 Then
        F2VSScaleFactor(Index) = VSMax / 32000
        VSMax = 32000
    Else
        F2VSScaleFactor(Index) = 1
    End If
    
    
    If VSMax > 0 Then
        .Max = VSMax
        If OVx * VSMax < VSMax Then
            .Value = (OVx * (VSMax)) '0.168, 12967 ' - 200)) '(.Value / (OM / VSMax))
            
        ElseIf VSMax > 0 Then
            .Value = VSMax
        End If
        
        If .Value > VSMax Then .Value = VSMax
        
        If VSMax <= 0 Then
            .Enabled = False
        Else
            .LargeChange = Form2.Picture2(Index).ScaleHeight
            .Enabled = True
        End If
    End If
    
End With



Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, Form2.Picture2(3), 0, 14)
Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), PictureBoxX)
TreeImage(3) = 1
Form2.Label1(3).Caption = "ML tree (GTRCAT) with recombinant regions separated"
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
End Sub
Public Sub DrawFastNJ5(PictureBoxX As PictureBox)
Form1.SSPanel1.Caption = "Making FastNJ tree with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
'DoneTree(1, 3) = 0

If DoneTree(1, 3) = 0 Then '1 here signifies that it goes in the NJ slot
    Call DoBigFastNJ
    DoneTree(1, 3) = 1
    
End If
CurTree(3) = 1
ExtraDX = DoTreeColour(Form2.Picture2(3), 1, 3) '1 here signifies that it goes in the NJ slot
TNum = 3
TType = 1
Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, Form2.Picture2(3), 0, 14)
Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), PictureBoxX)

Form2.Label1(3).Caption = "FastNJ tree with recombinant regions separated"
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
End Sub
Public Sub DrawML7(PictureBoxX As PictureBox)
Form1.SSPanel1.Caption = "Making ML tree with recombinant regions removed"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
'DoneTree(1, 3) = 0

If DoneTree(1, 3) = 0 Then '1 here signifies that it goes in the NJ slot
    Call DoRecFreeMLTree
    DoneTree(1, 3) = 1
    If PictureBoxX = Form1.Picture16 Then
        Form1.SSPanel6(1).Visible = True
        Form1.SSPanel6(0).Visible = False
        Form1.SSPanel6(2).Visible = False
    End If
End If
TreeTypeFlag = 3
CurTree(3) = 1
TNum = 3
TType = 1
CTF = 1
TreeImage(3) = 1
ExtraDX = DoTreeColour(Form2.Picture2(3), 1, 3) '1 here signifies that it goes in the NJ slot

Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, Form2.Picture2(3), 0, 14)
Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), PictureBoxX)


Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog

If PictureBoxX = Form1.Picture16 Then
    
    Form1.Label14.Caption = "ML (GTRCAT) tree with recombinant regions removed"
Else
    Form2.Label1(3).Caption = "ML (GTRCAT) tree with recombinant regions removed"
End If


End Sub

Public Sub DrawML6(PictureBoxX As PictureBox, TreeStrat)
Form1.SSPanel1.Caption = "Making ML tree with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog

Screen.MousePointer = 11
If DoneTree(2, 3) = 0 And TreeStrat = 5 Then
    Call DoBigTree(TreeStrat)
    DoneTree(2, 3) = 1
    ExtraDX = DoTreeColour(Form1.Picture16, 2, 3)
    TNum = 3
    TType = 2
    TreeTypeFlag = 3
    CTF = 2
    TreeImage(3) = 1
ElseIf DoneTree(2, 3) = 1 And TreeStrat = 5 Then
    TNum = 3
    TType = 2
    TreeTypeFlag = 3
    CTF = 2
    TreeImage(3) = 1
ElseIf DoneTree(4, 3) = 0 And TreeStrat = 4 Then
    Call DoBigTree(TreeStrat)
    DoneTree(4, 3) = 1
    ExtraDX = DoTreeColour(Form1.Picture16, 4, 3)
    TNum = 3
    TType = 4
    TreeTypeFlag = 3
    CTF = 4
    CurTree(3) = 4
    TreeImage(3) = 1
ElseIf DoneTree(4, 3) = 1 And TreeStrat = 4 Then
    
    TNum = 3
    TType = 4
    TreeTypeFlag = 3
    CTF = 4
    CurTree(3) = 4
    TreeImage(3) = 1
End If
'XX = UBound(MissingData, 1)

Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, PictureBoxX, 0, 14)
Call TreeDrawing(0, 1, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form1.VScroll1.Value, TNum, TType, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form1.Picture16)


OVy = VSC1NC
    VSC1NC = 1
    Dim otTYF As Double, TYFM As Integer
    Call ModOffsets(8.25, Form1.Picture16, otTYF, TYFM)
    With Form1.VScroll1
        If .Max <= 0 Then .Value = 0
        OV = .Value
        OM = .Max
        OVx = OV / OM
        
        If TDLen(TreeTypeFlag, CTF, 1) > 0 Then
        
            VSMax = -Form1.Picture16.ScaleHeight + ((TreeDraw(TNum, TType, 1, 1, TDLen(TNum, TType, 1)) + 1) * otTYF) + 200
        Else
            VSMax = -Form1.Picture16.ScaleHeight + ((TreeDraw(TNum, TType, 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
        End If
        If OM = 0 Then OM = 1
        If VSMax > 32000 Then
            F2VSScaleFactor(TreeTypeFlag) = VSMax / 32000
            VSMax = 32000
        Else
            F2VSScaleFactor(TreeTypeFlag) = 1
        End If
        
        .Max = VSMax '-Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
        If .Max > 0 And OM > 0 Then
            If OVx * VSMax <= .Max Then
                .Value = OVx * VSMax
            ElseIf .Max > 0 Then
                .Value = .Max
            End If
        End If
        If .Max <= 0 Then
            .Enabled = False
        Else
            .LargeChange = Form1.Picture9.ScaleHeight
            .Enabled = True
        End If
        
    End With
    VSC1NC = OVy

Screen.MousePointer = 0
Form1.Label14.Caption = "ML tree (GTRCAT) with recombinant regions separated"
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
Form1.SSPanel6(1).Visible = True
Form1.SSPanel6(0).Visible = False
Form1.SSPanel6(2).Visible = False
x = x
End Sub

Public Sub DrawUPGMA5()


'Force use of raxml



Form1.SSPanel1.Caption = "Making FastNJ tree with recombinant regions separated"
Form1.ProgressBar1.Value = 10
Call UpdateF2Prog
If DoneTree(1, 3) = 0 Then
    Call DoBigTreeUPGMA
    DoneTree(1, 3) = 1
End If
CurTree(3) = 1
ExtraDX = DoTreeColour(Form2.Picture2(3), 1, 3)
TNum = 3
TType = 1
Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, Form2.Picture2(3), 0, 14)
Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(3))

'Call treedrawing(0,0,treeblocksl(), TBLLen, 1, OriginalName(), -Form2.VScroll1(F2TreeIndex).Value, F2TreeIndex, 1, treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(F2TreeIndex))

Form2.Label1(3).Caption = "UPGMA tree with recombinant regions separated"
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog

End Sub
Public Sub DoBigTree(xBStreeStrat)
    
    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, NameXPos() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim ScaleValD As Double, tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, ColTotals() As Single
    
    Dim TIndexX As Byte, DoneLine() As Byte, OrderArray() As Byte, SHolder() As Byte, Treebyte() As Byte
    
    Dim NHFlag As Integer, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NameLen As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer, FF As Integer, Scratch() As Integer, bttSeqNum() As Integer
    
    Dim YCnt As Long, LS As Long, oReps As Long, A As Long, b As Long, NLen As Long, PNodeStr() As Long, LSeq As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Cnt As Long, SP As Long, DEN() As Long, LTree As Long, NumberOfSeqs As Long

    'xBStreeStrat = 5 'BSTreeStrat this forces fasttree
    
    Dim TempName() As String
    ReDim TempName(NextNo)
    
    
    
    TIndexX = 3 'i.e.  otrees drawn taking account of recombination
    If xBStreeStrat = 5 Then
        NJF = 2 ' put it into the LS slot
    ElseIf xBStreeStrat = 4 Then
        NJF = 4
    End If
    
    For x = 0 To NextNo
        TempName(x) = OriginalName(x)
        Do
            Pos = InStr(1, TempName(x), ",", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
            
        Loop
        Do
            Pos = InStr(1, TempName(x), "(", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ")", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ":", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "[", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "]", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ";", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ".", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "_", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
    Next x
    oNextno = NextNo
    Dim TempName2() As String
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    If xBStreeStrat >= 4 Then
        Call SaveAlign("infile.fas", 2, TempName(), 17)
    Else
        Call SaveAlign("infile.phy", 2, TempName(), 17)
    End If
    
    
    
    
    Form1.ProgressBar1.Value = 15
    Form1.SSPanel1.Caption = "Making ML tree with recombinant regions separated"
    Call UpdateF2Prog
    tNextno = NextNo
    NumberOfSeqs = tNextno
    If NextNo = -1 Then
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        TBSReps = oReps
        Exit Sub
    End If
    ReDim TempName2(NextNo)
    ReDim Preserve OriginalName(NextNo)
    For x = 0 To NextNo
        TempName2(x) = OriginalName(x)
        OriginalName(x) = TempName(x)
    Next x
    x = x
    
    Dim STraceA() As Long, SeqSave() As Integer
    NumSeqs = NextNo
    ReDim BigTreeTraceEventU(NextNo)
    ReDim STraceA(NextNo)
    
    
    ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqSave
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        
    Else
        For x = 0 To PermNextno
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, x) = PermSeqNum(Y, x)
            Next Y
        Next x
    End If
    
    
    
    
  
    
    ReDim BigTreeName(NextNo)
    For x = 0 To NextNo
        BigTreeName(x) = TempName(x)
        'XX = BigTreeName(43)
    Next x
    
    
    Dim OutString As String
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    If xBStreeStrat < 3 Then  'i.e. use phyml3
        OutString = ""
        OutString = "PhyML_3.0_win32.exe -i infile.phy "
        
        If x = x Then ' for now just do no branch tests
        'BSupTest = -1
            OutString = OutString + " -b 0"
        Else
            If BSupTest = 0 And TBSReps <= 1 Then
              OutString = OutString + " -b 0"
            ElseIf BSupTest = 0 Then
              OutString = OutString + " -b " + Trim(Str(TBSReps))
            ElseIf BSupTest = 1 Then 'approximate lr test returning aLRT stats
              OutString = OutString + " -b -1"
            ElseIf BSupTest = 2 Then  'approximate lr test returning chi square based stats
              OutString = OutString + " -b -2"
            ElseIf BSupTest = 3 Then 'sh-like branch support test
              OutString = OutString + " -b -3"
            End If
        End If
        'Substitution model
        If TPModel = 0 Then
              OutString = OutString + " -m JC69"
        ElseIf TPModel = 1 Then
              OutString = OutString + " -m K80"
        ElseIf TPModel = 6 Then
              OutString = OutString + " -m HKY85"
        ElseIf TPModel = 2 Then
              OutString = OutString + " -m F81"
        ElseIf TPModel = 3 Then
              OutString = OutString + " -m F84"
        ElseIf TPModel = 4 Then
              OutString = OutString + " -m TN93"
        ElseIf TPModel = 5 Then
              OutString = OutString + " -m GTR"
        End If
        'tvrat
        If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
              If TPTVRat > 0 Then
                    OutString = OutString + " -t " + Trim(Str(TPTVRat * 2))
              Else
                    OutString = OutString + "-t e "
              End If
        ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
          OutString = OutString + "-t 1.0"
        End If
        
        'proportion invariable sites
        If TPInvSites < 1 Then
          OutString = OutString + " -v " + Trim(Str(TPInvSites))
        Else
          OutString = OutString + " -v e "
        End If
        
        'number rate categories
         OutString = OutString + " -c " + Trim(Str(TPGamma))
        'gamma correction
         'If TPGamma > 1 Then
        If TPAlpha = 0 Then
            OutString = OutString + " -a e " ' " 1.0"
        Else
            OutString = OutString + " -a " + Trim(Str(TPAlpha))
        End If
        'xbstreestrat = 0
        If xBStreeStrat = 0 Then
            OutString = OutString + " -s NNI "
        ElseIf xBStreeStrat = 1 Then
            OutString = OutString + " -s SPR "
        ElseIf xBStreeStrat = 2 Then
            OutString = OutString + " -s BEST "
        End If
        
        OutString = OutString + " --no_memory_check"
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 4
    ElseIf xBStreeStrat = 3 Then  'phyml1
                
        OutString = "phyml_win32.exe infile.phy 0 s 1"
      ' BS reps
        If TBSReps <= 1 Then
          OutString = OutString + " 0"
        Else
          OutString = OutString + " " + "0" 'Trim(Str(TBSReps))
        End If
        'Substitution model
        
        If TPModel = 0 Then
              OutString = OutString + " K2P"
        ElseIf TPModel = 1 Then
              OutString = OutString + " K2P"
        ElseIf TPModel = 6 Then
              OutString = OutString + " HKY"
        ElseIf TPModel = 2 Then
              OutString = OutString + " F81"
        ElseIf TPModel = 3 Then
              OutString = OutString + " F84"
        ElseIf TPModel = 4 Then
              OutString = OutString + " TN93"
        ElseIf TPModel = 5 Then
              OutString = OutString + " GTR"
        End If
        'tvrat
        If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
              If TPTVRat > 0 Then
                    OutString = OutString + Str(TPTVRat * 2)
              Else
                    OutString = OutString + " e"
              End If
        ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
          OutString = OutString + " 1.0"
        End If
        'proportion invariable sites
        If TPInvSites < 1 Then
          OutString = OutString + Str(TPInvSites)
        Else
          OutString = OutString + " e"
        End If
        'number rate categories
         OutString = OutString + Str(TPGamma)
        'gamma correction
         'If TPGamma > 1 Then
              If TPAlpha = 0 Then
                  OutString = OutString + " e" ' " 1.0"
              Else
                  OutString = OutString + Str(TPAlpha)
              End If
         'End If
        'starting tree
        OutString = OutString + " BIONJ y y"
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 4
    ElseIf xBStreeStrat = 5 Then 'FastTree
        OutString = "FastTree -gtr -nt -nosupport -pseudo infile.fas > treefile" '
        Print #1, OutString
    ElseIf xBStreeStrat = 4 Then 'RAxML
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "RAxML_info.treefile"
        KillFile "RAxML_parsimonyTree.treefile"
        KillFile "RAxML_log.treefile"
        KillFile "RAxML_result.treefile"
        KillFile "RAxML_bestTree.treefile"
        KillFile "RAxML_bootstrap.treefile"
        On Error GoTo 0
        
        
        Dim SysInfo As SYSTEM_INFO
        GetSystemInfo SysInfo
        Dim Outstring2 As String
        OutString = ""
        Dim NumProc As Long
        NumProc = SysInfo.dwNumberOrfProcessors
        If NumProc > 4 Then NumProc = 4
        If NumProc > 2 Then  'for some reason pthreads crashes/does not give a tree
            'OutString = "raxmlHPC-PTHREADS -s infile -p 123 -n treefile -m GTRCAT -T " + Trim(Str(SysInfo.dwNumberOrfProcessors))
            OutString = "raxmlHPC-PTHREADS -s infile.fas -p 1234.phy -n treefile -m GTRCAT -T " + Trim(Str(NumProc - 1))
        Else
            'OutString = "raxmlHPC -s infile -p 123 -n treefile -m GTRCAT"
            OutString = "raxmlHPC -s infile.fas -p 1234.phy -n treefile -m GTRCAT -U"
        End If
        
        
        'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 4"
        
        'only max parsimony tree
        'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 2"
        
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 53
    End If
    
    
    Close #1
    Open "1.txt" For Output As #1
        Print #1, OutString
   
    Close #1
    On Error GoTo 0
    SS = Abs(GetTickCount)
    XX = CurDir
    If xBStreeStrat = 5 Then
        Dummy = GetCommandOutput("dnadist.bat", 7, True, True)
    ElseIf xBStreeStrat <> 4 Then
        Call GetCommandOutput(OutString, 6, True, True)
    Else
        SS = Abs(GetTickCount)
        ShellAndClose "dnadist.bat", 0
        EE = Abs(GetTickCount)
        TT = EE - SS
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS '57 with fasttree, 1021 raxml without pthreads, 839 seconds with pthreads
    x = x
    Dim Getstring As String
    
    NumberOfSeqs = tNextno
    If xBStreeStrat = 5 Then
        Call ReadTreeFile(NumberOfSeqs, 0, 0, "treefile", Getstring, Treebyte())
    ElseIf xBStreeStrat <> 4 Then
        Call ReadTreeFile(NumberOfSeqs, 0, 0, "infile.phy_phyml_tree.txt", Getstring, Treebyte())
    Else
        Call ReadTreeFile(NumberOfSeqs, 0, 0, "RAxML_bestTree.treefile", Getstring, Treebyte())
        If FileLen("RAxML_bestTree.treefile") = 0 Then
            'X = X
            Call ReadTreeFile(NumberOfSeqs, 0, 0, "RAxML_parsimonyTree.treefile", Getstring, Treebyte())
            x = x
        End If
        
        
    End If
    If xBStreeStrat = 4 Then
        NHString(34) = Getstring
    Else
        NHString(33) = Getstring
    End If
    F2TreeIndex = 3
    CTF = 2
    If xBStreeStrat = 4 Then
        Call ReplaceNames(BigTreeName(), NumberOfSeqs, NHString(34))
    ElseIf xBStreeStrat = 5 Then
        Call ReplaceNames(BigTreeName(), NumberOfSeqs, NHString(33))
    End If
    If UBound(XCord, 3) < NumberOfSeqs + 2 Then
        ReDim Preserve XCord(4, 3, NumberOfSeqs + 2)
        ReDim Preserve YCord(4, 3, NumberOfSeqs + 2)
        ReDim Preserve RYCord(4, 3, NumberOfSeqs + 2)
    End If
    
    LPos = 0
    'xxx = CurDir
    Dim ZPos As Long, SSCount As Long
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)
    ReDim NodeDepth2(NumberOfSeqs + 1, NumberOfSeqs + 1)
    For x = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(x, Y) = -1
            NodeDepth2(x, Y) = -1
        Next 'Y

    Next 'X
    ReDim DLen(NumberOfSeqs + 1)
    ReDim PNodeStr((NumberOfSeqs + 1) * 2)
    
    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim NameXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    Dim Tracer() As Long
    ReDim Tracer(NumberOfSeqs + 1, NumberOfSeqs + 1)
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    
    Do While LPos < Len(Getstring)
        mZNo = 0
        lZNo = 0
        ZNo = NumberOfSeqs + 1
        
        ' This collects:
        '(1) internal branch lengths (put into llen)
        '(2) terminal branch lnegths (put into seqxpos)
        '(3) positions of ")" in the encoded tree so that bootstrap values can be added later
        '(4) bracket pairs in which sequences are found (stored in Nodedepth - element 1=bracket pair,2=sequence order)
        If Treebyte(LPos - 1) = 40 Then '(
            'find the matching )
            
            If CCount > -1 Then
                lZNo = ZNo
                If ZNo + 1 <= mZNo Then
                    ZNo = mZNo + 1
                Else
                    ZNo = ZNo + 1
                End If
                
                
            End If
            CCount = CCount + 1
            
            DCount = 1
            SCount = 0
            TPos = LPos + 1

            Do

                If Treebyte(TPos - 1) = 40 Then '(
                    DCount = DCount + 1
                    
                    
                ElseIf Treebyte(TPos - 1) = 41 Then ')
                    
                    
                    
                    DCount = DCount - 1

                    If DCount = 0 Then ' Matching ) found - find branch len associated with this subtree
                        If NJF = 3 Or NJF = 4 Then 'for ml and bayes trees
                            If Treebyte(TPos) <> 58 Then
                                Xpos = TPos + 1
                                Do While Xpos < Len(Getstring)
                                    If Treebyte(Xpos) = 58 Then
                                        Exit Do
                                    End If
                                    Xpos = Xpos + 1
                                Loop
                                If Xpos < Len(Getstring) Then
                                    
                                    DLen(CCount) = val(Mid$(Getstring, TPos + 1, (Xpos - TPos)))
                                    
                                Else
                                    DLen(CCount) = 0
                                End If
                                TPos = Xpos
                            Else
                                DLen(CCount) = 0
                            End If
                        End If
                        If Treebyte(TPos) = 58 Then ':

                            If Treebyte(TPos + 1) = 45 Then '-

                                If NJF = 3 Or NJF = 4 Then
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 10))
                                Else
                                    If TNegBLFlag = 0 Then
                                        LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 8))
                                    Else
                                        LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                    End If
                                End If

                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                            Else

                                If NJF = 3 Or NJF = 4 Then
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                Else
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 7))
                                End If
                                
                                'xxx = DLen(CCount)
                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                
                            End If

                        Else
                        
                        
                            LLen(CCount) = 0
                            PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                        End If
                        
                        x = x
                        
                        Exit Do
                    End If
                    
                    
                ElseIf Treebyte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                    
                    PosP = InStr(TPos, Getstring, ":", vbBinaryCompare)
                    CSeq = val(Mid$(Getstring, TPos + 1, PosP - TPos - 1))
                    'XX = Mid$(Getstring, TPos + 1 - 5, PosP - TPos - 1 + 10)
                    '203,204,205,206,211,207,208,210,209,212,220,217,218,213,214,215,219,216
                    
                    NodeDepth(CCount, SCount) = CSeq
                    XX = UBound(Tracer, 1)
                    'Exit Sub
                    Tracer(CSeq, CCount) = 1
                    SCount = SCount + 1
                    
                    If Done(CSeq) = 0 Then
                        Done(CSeq) = 1

                        If Treebyte(PosP) = 45 Then  '-

                            If NJF = 3 Or NJF = 4 Then
                                
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 9))
                                NameXPos(CSeq) = 0
                            Else
                                
                                If TNegBLFlag = 1 Then
                                    SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                Else
                                    SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                                End If
                                NameXPos(CSeq) = 0
                                
                            End If

                        Else

                            If NJF = 3 Or NJF = 4 Then
                                
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                
                                NameXPos(CSeq) = SeqXPos(CSeq)
                                
                            Else
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 7))
                                NameXPos(CSeq) = SeqXPos(CSeq)
                            End If

                        End If

                    End If

                End If

                TPos = TPos + 1
            Loop

        End If

        LPos = LPos + 1
        
    Loop
    
    'store nodedepth so that boostrap values can be put into NHSTRING
    Dim NHNodeDepth() As Long, CP() As Long
    ReDim NHNodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), CP(NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs + 1
    
        For Y = 0 To NumberOfSeqs + 1
    
            
                NHNodeDepth(x, Y) = NodeDepth(x, Y)
                
        Next Y
        
    Next x
    'Get treedistances
    Dim LongDist As Double, CDist As Double, CurS As Long, LongSeq(1) As Long, TreeD() As Single, SepBranch() As Integer, lX As Byte
    
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    
    For x = 0 To NumberOfSeqs
        For Y = 0 To NumberOfSeqs
            If NodeDepth(x, Y) > -1 Then
                SepBranch(x, (NodeDepth(x, Y))) = 1
            End If
        Next Y
    Next x
    
    
    ReDim TreeD(NumberOfSeqs, NumberOfSeqs)
    
    Dummy = MakeTreeD(UBound(TreeD, 1), UBound(NodeDepth, 1), UBound(SepBranch, 1), NumberOfSeqs, LLen(0), TreeD(0, 0), SeqXPos(0), NodeDepth(0, 0), SepBranch(0, 0))
    
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
            If LongDist < TreeD(x, Y) Then
                LongDist = TreeD(x, Y)
                LongSeq(0) = x
                LongSeq(1) = Y
            End If
        Next Y
    Next x
    LongDist = LongDist / 2
    
    
    lX = 0
    CDist = SeqXPos(LongSeq(0))
    x = -LongSeq(0) - 1
    If CDist < LongDist Then
        For x = NumberOfSeqs To 0 Step -1
            
            If SepBranch(x, LongSeq(0)) = 1 And SepBranch(x, LongSeq(1)) = 0 Then 'ie sequences are separated by this branch
                
                CDist = CDist + LLen(x)
                If CDist > LongDist Then
                    Exit For
                End If
            End If
        Next x
        
        If CDist < LongDist Then
            lX = 1
            x = -LongSeq(1) - 1
            CDist = SeqXPos(LongSeq(1))
            If CDist < LongDist Then
                For x = NumberOfSeqs To 0 Step -1
                    If SepBranch(x, LongSeq(1)) = 1 And SepBranch(x, LongSeq(0)) = 0 Then 'ie sequences are separated by this branch
                    
                        CDist = CDist + LLen(x)
                        If CDist > LongDist Then
                            Exit For
                        End If
                    End If
                Next x
            End If
            
        End If
    End If
    
    Dim TempNodeDepth() As Long, TempLLen() As Single, TempDLen() As Single, TNode As Long, CNodeX As Long, XCnt As Long
    ReDim TempNodeDepth(NumberOfSeqs + 2, NumberOfSeqs + 2), TempLLen(NumberOfSeqs + 2), TempDLen(NumberOfSeqs + 2)
    TNode = x
    Dim oSepBranch() As Integer
    For x = 0 To NumberOfSeqs + 1
        For Y = 0 To NumberOfSeqs + 1
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    Dim RLLen() As Long
    ReDim RLLen(NumberOfSeqs * 2)
    If TNode < 0 Then 'ie the midpoint is in a terminal branch of sequence abs(x)
        TNode = Abs(TNode + 1)
        
        For x = NumberOfSeqs To 0 Step -1
            If SepBranch(x, TNode) = 1 Then
                
                For Z = x To 1 Step -1
                    TempLLen(2 + x - Z) = LLen(Z)
                    TempDLen(2 + x - Z) = DLen(Z)
                    RLLen(Z) = 2 + x - Z
                    Cnt = 0
                    If SepBranch(Z, TNode) = 1 Then
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 0 Then
                                TempNodeDepth(2 + x - Z, Cnt) = Y
                                Cnt = Cnt + 1
                            End If
                            
                        Next Y
                    Else
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 1 Then
                                TempNodeDepth(2 + x - Z, Cnt) = Y
                                
                                Cnt = Cnt + 1
                            End If
                        Next Y
                    End If
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(2 + x - Z, Y) = -1
                    Next Y
                Next Z
                TempLLen(1) = SeqXPos(TNode) - LongDist
                SeqXPos(TNode) = LongDist
                NameXPos(TNode) = LongDist
                If x > 1 Then
                    XCnt = 0
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If TempNodeDepth(2, Y) = -1 Then Exit For
                        'If Y <> TNode Then
                            TempNodeDepth(1, Y) = TempNodeDepth(2, Y)
                            Cnt = Cnt + 1
                        'End If
                    Next Y
                    If Cnt < NumberOfSeqs Then
                    
                        For Y = 0 To NumberOfSeqs
                            If NodeDepth(x, Y) <> TNode Then
                                If NodeDepth(x, Y) = -1 Then Exit For
                                TempNodeDepth(1, Cnt) = NodeDepth(x, Y)
                                Cnt = Cnt + 1
                            End If
                        Next Y
                        
                        For Y = Cnt To NumberOfSeqs
                            TempNodeDepth(1, Cnt) = -1
                        Next Y
                    End If
                Else
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        'If Y <> TNode Then
                            TempNodeDepth(1, Cnt) = Y
                            Cnt = Cnt + 1
                        'End If
                        
                    Next Y
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(1, Cnt) = -1
                    Next Y
                End If
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(0, Y) = TempNodeDepth(1, Y)
                Next Y
                TempNodeDepth(0, NumberOfSeqs) = TNode
                Exit For
            Else
                TempLLen(x + 1) = LLen(x)
                TempDLen(x + 1) = DLen(x)
                RLLen(x) = x + 1
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
                Next Y
            End If
            
            
        Next x
        TNode = 0
        
    Else   'it is in internal branch x
        TempLLen(2) = CDist - LongDist
        TempLLen(1) = LLen(TNode) - TempLLen(2)
        TempLLen(0) = LLen(TNode) - TempLLen(2)
        TempDLen(1) = DLen(TNode)
        TempDLen(0) = DLen(TNode)
        RLLen(TNode) = 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 1 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        For x = 0 To NumberOfSeqs
            If NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                Else
                    Exit For
                End If
            End If
        Next x
        
        For x = NumberOfSeqs To 0 Step -1
            If NodeDepth(0, x) > -1 Then
                If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                    TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                    Cnt = Cnt + 1
                Else
                    Exit For
                End If
            End If
        Next x
        
        
        'TempNodeDepth(0, Cnt) = NumberOfSeqs + 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If TempNodeDepth(0, x) > -1 Then
                If SepBranch(TNode, TempNodeDepth(0, x)) = 0 Then
                    TempNodeDepth(2, Cnt) = TempNodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(2, Y) = -1
        Next Y
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If TempNodeDepth(0, x) > -1 Then
                If SepBranch(TNode, TempNodeDepth(0, x)) = 1 Then
                    TempNodeDepth(1, Cnt) = TempNodeDepth(0, x)
                    Cnt = Cnt + 1
                End If
            End If
        Next x
        TempNodeDepth(1, Cnt) = NumberOfSeqs + 1
        Cnt = Cnt + 1
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(1, Y) = -1
        Next Y
        
        XCnt = TNode + 1
        YCnt = 3
        For x = TNode - 1 To 1 Step -1
            
            If SepBranch(x, NodeDepth(TNode, 0)) = 0 Then
                TempLLen(XCnt) = LLen(x)
                TempDLen(XCnt) = DLen(x)
                RLLen(x) = XCnt
                Cnt = 0
                For Y = 0 To NumberOfSeqs
                    If TempNodeDepth(0, Y) > -1 Then
                        If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                            TempNodeDepth(XCnt, Cnt) = TempNodeDepth(0, Y)
                            Cnt = Cnt + 1
                        End If
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(XCnt, Y) = -1
                Next Y
                XCnt = XCnt - 1
            Else
                Cnt = 0
                TempLLen(YCnt) = LLen(x)
                TempDLen(YCnt) = DLen(x)
                RLLen(x) = YCnt
                For Y = 0 To NumberOfSeqs
                    If TempNodeDepth(0, Y) > -1 Then
                        If SepBranch(x, TempNodeDepth(0, Y)) = 0 Then
                            TempNodeDepth(YCnt, Cnt) = TempNodeDepth(0, Y)
                            Cnt = Cnt + 1
                        End If
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(YCnt, Y) = -1
                Next Y
                YCnt = YCnt + 1
            End If
            
        Next x
        For x = TNode + 1 To NumberOfSeqs
            TempLLen(x + 1) = LLen(x)
            TempDLen(x + 1) = DLen(x)
            RLLen(x) = x + 1
            For Y = 0 To NumberOfSeqs
                TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
            Next Y
        Next x
        
    End If
    
    'Rearrange tempnodedepth so that 0-nextno run with the largest to smallest numbers of entries
    Dim ttNodeDepth() As Long, NumEnt() As Long, Maxent As Long, WinEnt As Long, ttLLen(), ttDLen()
    ReDim NumEnt(NumberOfSeqs), ttLLen(NumberOfSeqs), ttDLen(NumberOfSeqs)
    ReDim ttNodeDepth(NumberOfSeqs, NumberOfSeqs)
    For x = 0 To NumberOfSeqs
        NumEnt(x) = 0
        For Y = 0 To NumberOfSeqs
            If TempNodeDepth(x, Y) > -1 Then
                NumEnt(x) = NumEnt(x) + 1
            End If
        Next Y
    Next x
    For Y = 0 To NumberOfSeqs
        Maxent = -1
        For x = 0 To NumberOfSeqs
            If NumEnt(x) > Maxent Then
                Maxent = NumEnt(x)
                WinEnt = x
            End If
        Next x
        For x = 0 To NumberOfSeqs
            ttNodeDepth(Y, x) = TempNodeDepth(WinEnt, x)
            
        Next x
        ttLLen(Y) = TempLLen(WinEnt)
        ttDLen(Y) = TempDLen(WinEnt)
        NumEnt(WinEnt) = -1
       ' RLLen(WinEnt) = Y
    Next Y
    For x = 0 To NumberOfSeqs
        TempLLen(x) = ttLLen(x)
        TempDLen(x) = ttDLen(x)
        For Y = 0 To NumberOfSeqs
            TempNodeDepth(x, Y) = ttNodeDepth(x, Y)
        Next Y
    Next x
    
    ReDim oSepBranch(NumberOfSeqs + 2)
    If TNode > -1 Then
        For x = 0 To NumberOfSeqs
            oSepBranch(x) = SepBranch(TNode, x) '2,3,4,5,6,10,11,12,17,19,20
        Next x
    End If
    
    
    NumberOfSeqs = NumberOfSeqs + 1
    Dim LongHold() As Long
    Dim DoneOne() As Byte, tOrder() As Long
    
    
    ReDim DoneOne(NumberOfSeqs), tOrder(NumberOfSeqs + 1), LongHold(NumberOfSeqs + 1)
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    
    For x = 0 To NumberOfSeqs - 1
        For Y = 0 To NumberOfSeqs - 1
            If TempNodeDepth(x, Y) > -1 Then
                SepBranch(x, TempNodeDepth(x, Y)) = 1
            Else
                Exit For
            End If
        Next Y
    Next x
    
    Cnt = 0
    Redo = -2
    If TNode > -1 Then
        For A = 0 To 1
            First = -1
            Target = A
            For Z = NumberOfSeqs To 0 Step -1
                If TempNodeDepth(Z, 0) > -1 Then
                    If DoneOne(TempNodeDepth(Z, 0)) = 0 Then
                        Redo = -2
                        First = TempNodeDepth(Z, 0)
                        
                        Last = First
                        For x = Z To 0 Step -1
                            If SepBranch(x, First) = 1 Then
                                Add = 0
                                For Y = 0 To NumberOfSeqs
                                    
                                    If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                        If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                            If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                Add = Add + 1
                                                If Add > 2 Then Exit For
                                            End If
                                        End If
                                    End If
                                    
                                Next Y
                                If Add <= 2 Then
                                    For Y = 0 To NumberOfSeqs
                                        
                                        If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                            If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                    tOrder(Cnt) = TempNodeDepth(x, Y)
                                                    
                                                    DoneOne(TempNodeDepth(x, Y)) = 1
                                                    
                                                    Cnt = Cnt + 1
                                                End If
                                            End If
                                        End If
                                    Next Y
                                ElseIf x > 0 Then
                                    ReDim LongHold(NumberOfSeqs + 1)
                                    XCnt = 0
                                    For Y = 0 To NumberOfSeqs
                                            
                                            If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                                If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                    If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                        LongHold(XCnt) = TempNodeDepth(x, Y)
                                                        XCnt = XCnt + 1
                                                        
                                                    End If
                                                End If
                                            End If
                                    Next Y
                                    GoOn = 0
                                    For Y = NumberOfSeqs To 0 Step -1
                                        For b = 0 To XCnt - 1
                                            If SepBranch(Y, LongHold(b)) = 1 Then
                                                GoOn = 1
                                                Exit For
                                            End If
                                        Next b
                                        If GoOn = 1 Then Exit For
                                    Next Y
                                    If Y > x And First <> LongHold(b) Then
                                        First = LongHold(b)
                                        x = Y + 1
                                    End If
                                End If
                            
                            End If
                        Next x
                    End If
                End If
                If Cnt > NumberOfSeqs + 1 Then Exit For
                
            Next Z
        Next A
    End If
    
    tOrder(NumberOfSeqs + 1) = NumberOfSeqs + 1
    
    For x = 0 To NumberOfSeqs
        TempNodeDepth(0, x) = tOrder(x)
    Next x
    For x = 0 To NumberOfSeqs
        If TempNodeDepth(0, x) = 0 Then
            For Y = x + 1 To NumberOfSeqs
                If TempNodeDepth(0, Y) = 0 Then
                    For Z = 0 To NumberOfSeqs
                        If DoneOne(Z) = 0 Then
                            DoneOne(Z) = 1
                            TempNodeDepth(0, Y) = Z
                            Exit For
                        End If
                    Next Z
                End If
            Next Y
            Exit For
        End If
    Next x
    For x = 1 To NumberOfSeqs
        ReDim tOrder(NumberOfSeqs + 1)
        Cnt = 0
        For Y = 0 To NumberOfSeqs - 1
            If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                tOrder(Cnt) = TempNodeDepth(0, Y)
                Cnt = Cnt + 1
            
            End If
            
        Next Y
        For Y = 0 To Cnt - 1
            TempNodeDepth(x, Y) = tOrder(Y)
        Next Y
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    
    
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), LLen(NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs
        LLen(x) = TempLLen(x)
        DLen(x) = TempDLen(x)
        For Y = 0 To NumberOfSeqs
            
            NodeDepth(x, Y) = TempNodeDepth(x, Y)
        Next Y
    Next x
    
    For x = 0 To NumberOfSeqs
        NodeDepth(x, NumberOfSeqs) = -1
        NodeDepth(x, NumberOfSeqs + 1) = -1
    Next x
    LLen(0) = 0
    NodeDepth(0, NumberOfSeqs) = NumberOfSeqs
    
    'work out y-positions of all the nodes.
    ReDim SeqYPos(NumberOfSeqs + 1)
    ReDim tSeqYPos(NumberOfSeqs + 1)
    ReDim NodeYPos(NumberOfSeqs + 1)

    For x = 0 To NumberOfSeqs
        SeqYPos(NodeDepth(0, x)) = x
        tSeqYPos(NodeDepth(0, x)) = x
    Next 'X
    'ccount = the number of bracket pairs (ie internal branches) in the tree
    ' Nodedepth - element 1=bracket pair,2=sequence order
    For x = CCount + 1 To 0 Step -1


        For Y = 0 To NumberOfSeqs + 1

            If NodeDepth(x, Y) = -1 Or NodeDepth(x, Y) = NumberOfSeqs Then Exit For
        Next 'Y

        Y = Y - 1
        If Y < 0 Then Exit For
        If NodeDepth(x, 0) < 0 Then
            NodeDepth(x, 0) = 0
        End If
        NodeYPos(x) = tSeqYPos(NodeDepth(x, 0)) + (tSeqYPos(NodeDepth(x, Y)) - tSeqYPos(NodeDepth(x, 0))) / 2
        tSeqYPos(NodeDepth(x, 0)) = NodeYPos(x)
        tSeqYPos(NodeDepth(x, Y)) = NodeYPos(x)
    Next 'X
    
    NodeYPos(0) = NodeYPos(1)
    
    'work out x positions
    ReDim NodeXPos(NumberOfSeqs + 1)

   ReDim Done(NumberOfSeqs + 1)
   Dummy = GetSeqXPos(UBound(NodeDepth, 1), UBound(NodeDepth, 2), CCount, NumberOfSeqs, NodeDepth(0, 0), Done(0), NodeXPos(0), LLen(0), SeqXPos(0), NameXPos(0))
    
    ' Find sequences branching from root node
    'obviosuly node 1 branches so look for largest xpos of sequences not on node 1
    ReDim Outside(NumberOfSeqs + 1)
    'Outie = NumberOfSeqs
    For x = 0 To NumberOfSeqs
        NotFound = 0

        For Y = 0 To NumberOfSeqs

            If NodeDepth(1, Y) = x Then
                NotFound = 1
                Exit For
            End If

        Next 'Y

        If NotFound = 0 Then
            Outside(x) = 1 '0,0,0,1,0,0,1,0,0,0,0,0,0,1
        Else
            Outside(x) = 0
        End If

    Next 'X

    Outside(NumberOfSeqs) = 2
    MPosO = -100
    MPosI = -100

    For x = 0 To NumberOfSeqs

        If Outside(x) = 0 Then

            If SeqXPos(x) > MPosI Then
                MPosI = SeqXPos(x)
            End If

        ElseIf Outside(x) = 1 Then

            If SeqXPos(x) > MPosO Then
                MPosO = SeqXPos(x)
            End If

        End If

    Next 'X
    If Outie > UBound(SeqXPos, 1) Then
        DistanceFlag = 0
        Call GetOutie
    End If
    If SeqXPos(Outie) > MPosO * 1.00000000001 Then
        MPosO = SeqXPos(Outie)
        OutFlag = 2
    Else
        OutFlag = 1
    End If

    'OutsideAdjust = (MPosI - MPosO) / 2
    OutsideAdjust = 0
    Lowest = 100
    NodeXPos(NumberOfSeqs + 1) = NodeXPos(0)
    If OutsideAdjust > 0 Or x = x Then
        For x = 0 To NumberOfSeqs
    
            If NodeDepth(x, 0) > -1 Then
    
                If Outside(NodeDepth(x, 0)) <> OutFlag Then
                    NodeXPos(x) = NodeXPos(x) - OutsideAdjust
                Else
                    NodeXPos(x) = NodeXPos(x) + OutsideAdjust
                End If
    
                If NodeXPos(x) < Lowest Then Lowest = NodeXPos(x)
            End If
    
        Next 'X
    End If
    
    For x = 0 To NumberOfSeqs

        If Outside(x) <> OutFlag Then
            SeqXPos(x) = SeqXPos(x) - OutsideAdjust
        Else
            SeqXPos(x) = SeqXPos(x) + OutsideAdjust
        End If

        If SeqXPos(x) < Lowest Then Lowest = SeqXPos(x) 'this is dumb because seqxpos(numberofseqs) is always 0
    Next 'X

    If Lowest < 0 Then
        TotalAdjust = -Lowest

        For x = 1 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) + TotalAdjust
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) + TotalAdjust
            NameXPos(x) = NameXPos(x) + TotalAdjust
        Next 'X

    Else
        TotalAdjust = 1
        For x = 0 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) - Lowest
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) - Lowest
            NameXPos(x) = NameXPos(x) - Lowest
        Next 'X
    End If

    MaxXPos = 0

    For x = 0 To NumberOfSeqs

        If SeqXPos(x) > MaxXPos Then MaxXPos = SeqXPos(x)
    Next 'X

    ReDim NameWidth(NumberOfSeqs)
    If MaxXPos = 0 Then
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        TBSReps = oReps
        Exit Sub
    End If
    DrawXAdjust = (Form2.Picture2(0).ScaleWidth - 70) / (MaxXPos)
    DrawYAdjust = 14
    
    ReDim NodePath(NumberOfSeqs + 1, NumberOfSeqs + 1)
    ReDim SNodePathX(NumberOfSeqs + 1, NumberOfSeqs + 1)
    For x = 0 To NumberOfSeqs

        For Y = 0 To NumberOfSeqs
            NodePath(x, Y) = -1
            SNodePathX(x, Y) = -1
        Next 'Y

    Next 'X
    
    ReDim CxAdd(NumberOfSeqs)
    XX = UBound(NodePath, 1)
    GoOn = 1
    For x = 0 To NumberOfSeqs
        
        For Y = 0 To NumberOfSeqs

            If NodeDepth(x, Y) = -1 Then Exit For
            If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                
                NodePath(NodeDepth(x, Y), CxAdd(NodeDepth(x, Y))) = x
                CxAdd(NodeDepth(x, Y)) = CxAdd(NodeDepth(x, Y)) + 1 '0
            Else
                GoOn = 0
                Exit For
                
            End If
        Next 'Y
        If GoOn = 0 Then
            ReDim CxAdd(NumberOfSeqs)
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    NodeDepth(A, b) = NHNodeDepth(A, b)
                Next b
            Next A
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    If NodeDepth(A, b) = -1 Then Exit For
                    If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                        NodePath(NodeDepth(A, b), CxAdd(NodeDepth(A, b))) = A
                        CxAdd(NodeDepth(A, b)) = CxAdd(NodeDepth(A, b)) + 1
                    Else
                        Exit For
                    End If
                Next b
            Next A
            Exit For
        End If

    Next 'X
    'Exit Sub
    Dim NodeMaxRep() As Single
    ReDim NodeMaxRep(NumberOfSeqs)
    
    For x = 0 To NumberOfSeqs - 1
        
        NodeMaxRep(x) = 0
        
    Next x
    If x = x Then
        Dim DoesXContainZ() As Integer
        ReDim DoesXContainZ(NumberOfSeqs, NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 0 To NumberOfSeqs + 1
                If NodeDepth(x, Y) > -1 Then
                    DoesXContainZ(x, NodeDepth(x, Y)) = 1
                Else
                    Exit For
                End If
            Next Y
        
        
        Next x
        
        
        For Z = 0 To NumberOfSeqs - 1
            If Z <= UBound(SeqCoverage, 1) Then
                For x = 0 To NumberOfSeqs
                    If DoesXContainZ(x, Z) = 1 Then
                        If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                    End If
                Next x
            End If
        Next Z
    Else
        For Z = 0 To NumberOfSeqs - 1
            For x = 0 To NumberOfSeqs
                
                For Y = 0 To NumberOfSeqs + 1
                    If NodeDepth(x, Y) > -1 Then
                        If NodeDepth(x, Y) = Z Then
                        'XX = UBound(SeqCoverage, 1)
                                If Z <= UBound(SeqCoverage, 1) Then
                                    If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                                    If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                                End If
                            
                            Exit For
                        End If
                    Else
                        Exit For
                    End If
                Next Y
            
            Next x
        Next Z
    
    
    
    End If
    
    
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
    
    
    BkRx = BkR - 5
    BkGx = BkG - 5
    BkBx = BkB - 5
    
    ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
    
    A = -1: b = -1
    
    
    For x = 0 To NumberOfSeqs - 1
        If x = 3 Then
            x = x
        End If
        For Y = 0 To NumberOfSeqs - 2

            If NodePath(x, Y + 1) > -1 Then
                If DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 0 Then
                    
                    DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 1
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                        Pos = UBound(TreeDraw, 5) + 100
                        ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                    End If
                    
                    TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB((BkRx - BkRx * NodeMaxRep(NodePath(x, Y + 1))), BkGx - BkGx * NodeMaxRep(NodePath(x, Y + 1)), BkBx - BkBx * NodeMaxRep(NodePath(x, Y + 1)))
                    
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                        Pos = UBound(TreeDraw, 5) + 100
                        ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                    End If
                    
                    TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y + 1)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y + 1)), BkGx - BkGx * NodeMaxRep(NodePath(x, Y + 1)), BkBx - BkBx * NodeMaxRep(NodePath(x, Y + 1)))
                Else
                    x = x
                End If
            ElseIf NodePath(x, Y) > -1 Then
                A = A + 1
                If A > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                If x <= UBound(SeqCoverage, 1) Then
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverage(x), BkGx - BkGx * SeqCoverage(x), BkBx - BkBx * SeqCoverage(x))
                Else
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(255, 255, 255)
                End If
                A = A + 1
                
                If A > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + SeqYPos(x) * DrawYAdjust
                TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + SeqXPos(x) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                If x <= UBound(SeqCoverage, 1) Then
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverage(x), BkGx - BkGx * SeqCoverage(x), BkBx - BkBx * SeqCoverage(x))
                Else
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(255, 255, 255)
                End If
                
                XCord(NJF, TIndexX, x) = NameXPos(x) * DrawXAdjust + 15 + 1
                YCord(NJF, TIndexX, x) = (SeqYPos(x) * DrawYAdjust + 4)
                
                RYCord(NJF, TIndexX, SeqYPos(x)) = x
                
                b = b + 1
                If b > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 0, 0, b) = XCord(NJF, TIndexX, x)
                TreeDraw(TIndexX, NJF, 0, 1, b) = YCord(NJF, TIndexX, x)
                TreeDraw(TIndexX, NJF, 0, 2, b) = x
                TreeDraw(TIndexX, NJF, 0, 3, b) = -1
                Exit For
            End If

        Next 'Y

    Next 'X

    
    Form2.Picture2(0).FontSize = 8.25
    ScaleValD = 0.1

    If ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2 Then

        Do While ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2
            ScaleValD = ScaleValD / 2
        Loop

    End If
    
    A = A + 1
    TreeDraw(TIndexX, NJF, 1, 0, A) = 5
    TreeDraw(TIndexX, NJF, 1, 1, A) = ((NumberOfSeqs + 2) * DrawYAdjust)
    TreeDraw(TIndexX, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
    TreeDraw(TIndexX, NJF, 1, 3, A) = (NumberOfSeqs + 2) * DrawYAdjust
    
    ScaleVal = ScaleValD
    ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
    
    b = b + 1
    TreeDraw(TIndexX, NJF, 0, 0, b) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
    TreeDraw(TIndexX, NJF, 0, 1, b) = (NumberOfSeqs + 2.5) * DrawYAdjust
    TreeDraw(TIndexX, NJF, 0, 2, b) = -1
    TreeDraw(TIndexX, NJF, 0, 3, b) = -ScaleValD * 10000
    
    
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB()) 'treedrawb allows quicker access during tree drawing
    
    CurTree(3) = 3
'TDLen(3, 4, 2)
    TDLen(TIndexX, NJF, 1) = A
    TDLen(TIndexX, NJF, 0) = b
    TDLen(TIndexX, NJF, 2) = Form2.Picture2(0).ScaleWidth
    
    BigTreeNextno = NumberOfSeqs - 1
    ReDim BigTreeName(NumberOfSeqs - 1)
    For x = 0 To NumberOfSeqs - 1
        BigTreeName(x) = TempName(x)
        
    Next x
    
    
End Sub
Public Sub ResetMaxPVCO(NextNo As Long)
    Dim x As Long, Y As Long
    ReDim DonePVCO(AddNum - 1, NextNo)
    ReDim StoreLPV(AddNum - 1, NextNo)
    '@
    For x = 0 To AddNum - 1
        For Y = 0 To NextNo
            StoreLPV(x, Y) = 1
            DonePVCO(x, Y) = -1
        Next Y
    Next x
    
End Sub


Public Sub DoBigFastNJ()
    
    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, NameXPos() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim ScaleValD As Double, tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, ColTotals() As Single
    
    Dim TIndexX As Byte, DoneLine() As Byte, OrderArray() As Byte, SHolder() As Byte, Treebyte() As Byte
    
    Dim NHFlag As Integer, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NameLen As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer, FF As Integer, Scratch() As Integer, bttSeqNum() As Integer
    
    Dim xBStreeStrat As Long, YCnt As Long, LS As Long, oReps As Long, A As Long, b As Long, NLen As Long, PNodeStr() As Long, LSeq As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Cnt As Long, SP As Long, DEN() As Long, LTree As Long, NumberOfSeqs As Long

    xBStreeStrat = 5 'BSTreeStrat this forces fasttree
    
    Dim TempName() As String
    ReDim TempName(NextNo)
    
    
    
    TIndexX = 3 'i.e.  otrees drawn taking account of recombination
    NJF = 1 ' put it into the NJ slot
    
    For x = 0 To NextNo
        TempName(x) = OriginalName(x)
        Do
            Pos = InStr(1, TempName(x), ",", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
            
        Loop
        Do
            Pos = InStr(1, TempName(x), "(", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ")", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ":", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "[", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "]", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ";", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ".", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "_", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
    Next x
    oNextno = NextNo
    Dim TempName2() As String
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    'If xBStreeStrat = 5 Then
        Call SaveAlign("infile.fas", 3, TempName(), 17)
    'Else
    '    Call SaveAlign("infile.phy", 2, TempName(), 17)
    'End If
    
    x = x
    
    tNextno = NextNo
    NumberOfSeqs = tNextno
    ReDim TempName2(NextNo)
    ReDim Preserve OriginalName(NextNo)
    For x = 0 To NextNo
        TempName2(x) = OriginalName(x)
        OriginalName(x) = TempName(x)
    Next x
    x = x
    
    Dim STraceA() As Long, SeqSave() As Integer
    NumSeqs = NextNo
    'ReDim BigTreeTraceEventU(Nextno)
    
    ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqSave
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        
    Else
        For x = 0 To PermNextno
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, x) = PermSeqNum(Y, x)
            Next Y
        Next x
    End If
   
    
    ReDim BigTreeNameU(NextNo)
    For x = 0 To NextNo
        BigTreeNameU(x) = TempName(x)
        
    Next x
    
    
    
    
    
    Dim OutString As String
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    If xBStreeStrat < 3 And x = 12345678 Then 'i.e. use phyml3
        OutString = ""
        OutString = "PhyML_3.0_win32.exe -i infile.phy "
        
        If x = x Then ' for now just do no branch tests
        'BSupTest = -1
            OutString = OutString + " -b 0"
        Else
            If BSupTest = 0 And TBSReps <= 1 Then
              OutString = OutString + " -b 0"
            ElseIf BSupTest = 0 Then
              OutString = OutString + " -b " + Trim(Str(TBSReps))
            ElseIf BSupTest = 1 Then 'approximate lr test returning aLRT stats
              OutString = OutString + " -b -1"
            ElseIf BSupTest = 2 Then  'approximate lr test returning chi square based stats
              OutString = OutString + " -b -2"
            ElseIf BSupTest = 3 Then 'sh-like branch support test
              OutString = OutString + " -b -3"
            End If
        End If
        'Substitution model
        If TPModel = 0 Then
              OutString = OutString + " -m JC69"
        ElseIf TPModel = 1 Then
              OutString = OutString + " -m K80"
        ElseIf TPModel = 6 Then
              OutString = OutString + " -m HKY85"
        ElseIf TPModel = 2 Then
              OutString = OutString + " -m F81"
        ElseIf TPModel = 3 Then
              OutString = OutString + " -m F84"
        ElseIf TPModel = 4 Then
              OutString = OutString + " -m TN93"
        ElseIf TPModel = 5 Then
              OutString = OutString + " -m GTR"
        End If
        'tvrat
        If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
              If TPTVRat > 0 Then
                    OutString = OutString + " -t " + Trim(Str(TPTVRat * 2))
              Else
                    OutString = OutString + "-t e "
              End If
        ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
          OutString = OutString + "-t 1.0"
        End If
        
        'proportion invariable sites
        If TPInvSites < 1 Then
          OutString = OutString + " -v " + Trim(Str(TPInvSites))
        Else
          OutString = OutString + " -v e "
        End If
        
        'number rate categories
         OutString = OutString + " -c " + Trim(Str(TPGamma))
        'gamma correction
         'If TPGamma > 1 Then
        If TPAlpha = 0 Then
            OutString = OutString + " -a e " ' " 1.0"
        Else
            OutString = OutString + " -a " + Trim(Str(TPAlpha))
        End If
        'xbstreestrat = 0
        If xBStreeStrat = 0 Then
            OutString = OutString + " -s NNI "
        ElseIf xBStreeStrat = 1 Then
            OutString = OutString + " -s SPR "
        ElseIf xBStreeStrat = 2 Then
            OutString = OutString + " -s BEST "
        End If
        
        OutString = OutString + " --no_memory_check"
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 4
    ElseIf xBStreeStrat = 3 And x = 12345678 Then 'phyml1
                
        OutString = "phyml_win32.exe infile.phy 0 s 1"
      ' BS reps
        If TBSReps <= 1 Then
          OutString = OutString + " 0"
        Else
          OutString = OutString + " " + "0" 'Trim(Str(TBSReps))
        End If
        'Substitution model
        
        If TPModel = 0 Then
              OutString = OutString + " K2P"
        ElseIf TPModel = 1 Then
              OutString = OutString + " K2P"
        ElseIf TPModel = 6 Then
              OutString = OutString + " HKY"
        ElseIf TPModel = 2 Then
              OutString = OutString + " F81"
        ElseIf TPModel = 3 Then
              OutString = OutString + " F84"
        ElseIf TPModel = 4 Then
              OutString = OutString + " TN93"
        ElseIf TPModel = 5 Then
              OutString = OutString + " GTR"
        End If
        'tvrat
        If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
              If TPTVRat > 0 Then
                    OutString = OutString + Str(TPTVRat * 2)
              Else
                    OutString = OutString + " e"
              End If
        ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
          OutString = OutString + " 1.0"
        End If
        'proportion invariable sites
        If TPInvSites < 1 Then
          OutString = OutString + Str(TPInvSites)
        Else
          OutString = OutString + " e"
        End If
        'number rate categories
         OutString = OutString + Str(TPGamma)
        'gamma correction
         'If TPGamma > 1 Then
              If TPAlpha = 0 Then
                  OutString = OutString + " e" ' " 1.0"
              Else
                  OutString = OutString + Str(TPAlpha)
              End If
         'End If
        'starting tree
        OutString = OutString + " BIONJ y y"
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 4
    ElseIf x = x Then 'FastTree
        'OutString = "FastTree -gtr -nt -nosupport -pseudo infile.fas > treefile" '
        
        'If PseudoFlag = 1 Then
            OutString = "FastTree -nt -nome -noml -boot 50 -fastest -pseudo infile.fas > treefile" 'This is the fastNJ option
        'Else
        '    OutString = "FastTree -nt -nome -noml -boot 50 -fastest infile > treefile" 'This is the fastNJ option
        'End If
        
        Print #1, OutString
    ElseIf xBStreeStrat = 4 And x = 12345678 Then 'RAxML
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "RAxML_info.treefile"
        KillFile "RAxML_parsimonyTree.treefile"
        KillFile "RAxML_log.treefile"
        KillFile "RAxML_result.treefile"
        KillFile "RAxML_bestTree.treefile"
        KillFile "RAxML_bootstrap.treefile"
        On Error GoTo 0
        OutString = "raxmlHPC -s infile -p 1234.phy -t treefilea -n treefile -m GTRCAT"
        'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 4"
        
        'only max parsimony tree
        'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 2"
        
        Print #1, OutString
        'Print #1, "del treefile"
            
        'Print #1, "rename infile.phy_phyml_tree.txt treefile "
        BatIndex = 53
    End If
    
    
    Close #1
    On Error GoTo 0
    SS = Abs(GetTickCount)
    'If xBStreeStrat = 5 Then
        Dummy = GetCommandOutput("dnadist.bat", 8, True, True)
    EE = Abs(GetTickCount)
    TT = EE - SS '53.291 to make tree with 2768 sequences for run9
    x = x
    XX = NextNo
    'ElseIf xBStreeStrat <> 4 Then
    '    Call GetCommandOutput(OutString, 6, True, True)
    'Else
    '    SS = Abs(GetTickCount)
    '    ShellAndClose "dnadist.bat", 0
    '    EE = Abs(GetTickCount)
    '    TT = EE - SS
    'End If
    'X = X
    Dim Getstring As String
    
    NumberOfSeqs = tNextno
    
    SS = Abs(GetTickCount)
   ' If xBStreeStrat = 5 Then
        Call ReadTreeFile(NumberOfSeqs, 0, 0, "treefile", Getstring, Treebyte())
   ' ElseIf xBStreeStrat <> 4 Then
   '     Call ReadTreeFile(NumberOfSeqs, 0, 0, "infile.phy_phyml_tree.txt", Getstring, Treebyte())
   ' Else
   '     Call ReadTreeFile(NumberOfSeqs, 0, 0, "RAxML_bestTree.treefile", Getstring, Treebyte())
   '     If FileLen("RAxML_bestTree.treefile") = 0 Then
   '         'X = X
   '         Call ReadTreeFile(NumberOfSeqs, 0, 0, "RAxML_parsimonyTree.treefile", Getstring, Treebyte())
   '         X = X
   '     End If
   '
   '
   ' End If
    NHString(31) = Getstring
    F2TreeIndex = 3
    CTF = 1
    EE = Abs(GetTickCount)
    TT = EE - SS '11.547'13.938
    SS = Abs(GetTickCount)
    'Call ReplaceNames(OriginalName(), NumberOfSeqs, NHString(32))
    EE = Abs(GetTickCount)
    TT = EE - SS '0
    
    If UBound(XCord, 3) < NumberOfSeqs + 2 Then
        ReDim Preserve XCord(4, 3, NumberOfSeqs + 2)
        ReDim Preserve YCord(4, 3, NumberOfSeqs + 2)
        ReDim Preserve RYCord(4, 3, NumberOfSeqs + 2)
    End If
    
    LPos = 0
    'xxx = CurDir
    Dim ZPos As Long, SSCount As Long
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)
    ReDim NodeDepth2(NumberOfSeqs + 1, NumberOfSeqs + 1)
    For x = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(x, Y) = -1
            NodeDepth2(x, Y) = -1
        Next 'Y

    Next 'X
    ReDim DLen(NumberOfSeqs + 1)
    ReDim PNodeStr((NumberOfSeqs + 1) * 2)
    
    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim NameXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    Dim Tracer() As Long
    ReDim Tracer(NumberOfSeqs + 1, NumberOfSeqs + 1)
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    
    Do While LPos < Len(Getstring)
        mZNo = 0
        lZNo = 0
        ZNo = NumberOfSeqs + 1
        
        ' This collects:
        '(1) internal branch lengths (put into llen)
        '(2) terminal branch lnegths (put into seqxpos)
        '(3) positions of ")" in the encoded tree so that bootstrap values can be added later
        '(4) bracket pairs in which sequences are found (stored in Nodedepth - element 1=bracket pair,2=sequence order)
        If Treebyte(LPos - 1) = 40 Then '(
            'find the matching )
            
            If CCount > -1 Then
                lZNo = ZNo
                If ZNo + 1 <= mZNo Then
                    ZNo = mZNo + 1
                Else
                    ZNo = ZNo + 1
                End If
                
                
            End If
            CCount = CCount + 1
            
            DCount = 1
            SCount = 0
            TPos = LPos + 1

            Do

                If Treebyte(TPos - 1) = 40 Then '(
                    DCount = DCount + 1
                    
                    
                ElseIf Treebyte(TPos - 1) = 41 Then ')
                    
                    
                    
                    DCount = DCount - 1

                    If DCount = 0 Then ' Matching ) found - find branch len associated with this subtree
                        If x = x Then 'NJF = 3 Or NJF = 4 Then 'for ml and bayes trees
                            If Treebyte(TPos) <> 58 Then
                                Xpos = TPos + 1
                                Do While Xpos < Len(Getstring)
                                    If Treebyte(Xpos) = 58 Then
                                        Exit Do
                                    End If
                                    Xpos = Xpos + 1
                                Loop
                                If Xpos < Len(Getstring) Then
                                    
                                    DLen(CCount) = val(Mid$(Getstring, TPos + 1, (Xpos - TPos)))
                                    x = x
                                Else
                                    DLen(CCount) = 0
                                End If
                                TPos = Xpos
                            Else
                                DLen(CCount) = 0
                            End If
                        End If
                        If Treebyte(TPos) = 58 Then ':

                            If Treebyte(TPos + 1) = 45 Then '-

                                If NJF = 3 Or NJF = 4 Then
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 10))
                                Else
                                    If TNegBLFlag = 0 Then
                                        LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 8))
                                    Else
                                        LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                    End If
                                End If

                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                            Else

                                If NJF = 3 Or NJF = 4 Then
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                Else
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 7))
                                End If
                                
                                'xxx = DLen(CCount)
                                PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                                
                            End If

                        Else
                        
                        
                            LLen(CCount) = 0
                            PNodeStr(CCount) = TPos 'this is used for adding bootstrap values to NHstring
                        End If
                        
                        x = x
                        
                        Exit Do
                    End If
                    
                    
                ElseIf Treebyte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                    
                    PosP = InStr(TPos, Getstring, ":", vbBinaryCompare)
                    CSeq = val(Mid$(Getstring, TPos + 1, PosP - TPos - 1))
                    'XX = Mid$(GetString, TPos + 1, PosP - TPos - 1)
                    '203,204,205,206,211,207,208,210,209,212,220,217,218,213,214,215,219,216
                    
                    NodeDepth(CCount, SCount) = CSeq
                    XX = UBound(Tracer, 2)
                    'Exit Sub
                    Tracer(CSeq, CCount) = 1
                    SCount = SCount + 1
                    
                    If Done(CSeq) = 0 Then
                        Done(CSeq) = 1

                        If Treebyte(PosP) = 45 Then  '-

                            If NJF = 3 Or NJF = 4 Then
                                
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 9))
                                NameXPos(CSeq) = 0
                            Else
                                
                                If TNegBLFlag = 1 Then
                                    SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                Else
                                    SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                                End If
                                NameXPos(CSeq) = 0
                                
                            End If

                        Else

                            If NJF = 3 Or NJF = 4 Then
                                
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 8))
                                
                                NameXPos(CSeq) = SeqXPos(CSeq)
                                
                            Else
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 7))
                                NameXPos(CSeq) = SeqXPos(CSeq)
                            End If

                        End If

                    End If

                End If

                TPos = TPos + 1
            Loop

        End If

        LPos = LPos + 1
        
    Loop
    
    'store nodedepth so that boostrap values can be put into NHSTRING
    Dim NHNodeDepth() As Long, CP() As Long
    ReDim NHNodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), CP(NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs + 1
    
        For Y = 0 To NumberOfSeqs + 1
    
            
                NHNodeDepth(x, Y) = NodeDepth(x, Y)
                
        Next Y
        
    Next x
    'Get treedistances
    Dim LongDist As Double, CDist As Double, CurS As Long, LongSeq(1) As Long, TreeD() As Single, SepBranch() As Integer, lX As Byte
    
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    
    For x = 0 To NumberOfSeqs
        For Y = 0 To NumberOfSeqs
            If NodeDepth(x, Y) > -1 Then
                SepBranch(x, (NodeDepth(x, Y))) = 1
            End If
        Next Y
    Next x
    
    
    ReDim TreeD(NumberOfSeqs, NumberOfSeqs)
    SS = Abs(GetTickCount)
    
    Dummy = MakeTreeD(UBound(TreeD, 1), UBound(NodeDepth, 1), UBound(SepBranch, 1), NumberOfSeqs, LLen(0), TreeD(0, 0), SeqXPos(0), NodeDepth(0, 0), SepBranch(0, 0))
    
    EE = Abs(GetTickCount)
    TT = EE - SS '7.188'10.421'8.422
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
            If LongDist < TreeD(x, Y) Then
                LongDist = TreeD(x, Y)
                LongSeq(0) = x
                LongSeq(1) = Y
            End If
        Next Y
    Next x
    LongDist = LongDist / 2
    
    
    lX = 0
    CDist = SeqXPos(LongSeq(0))
    x = -LongSeq(0) - 1
    If CDist < LongDist Then
        For x = NumberOfSeqs To 0 Step -1
            
            If SepBranch(x, LongSeq(0)) = 1 And SepBranch(x, LongSeq(1)) = 0 Then 'ie sequences are separated by this branch
                
                CDist = CDist + LLen(x)
                If CDist > LongDist Then
                    Exit For
                End If
            End If
        Next x
        
        If CDist < LongDist Then
            lX = 1
            x = -LongSeq(1) - 1
            CDist = SeqXPos(LongSeq(1))
            If CDist < LongDist Then
                For x = NumberOfSeqs To 0 Step -1
                    If SepBranch(x, LongSeq(1)) = 1 And SepBranch(x, LongSeq(0)) = 0 Then 'ie sequences are separated by this branch
                    
                        CDist = CDist + LLen(x)
                        If CDist > LongDist Then
                            Exit For
                        End If
                    End If
                Next x
            End If
            
        End If
    End If
    
    Dim TempNodeDepth() As Long, TempLLen() As Single, TempDLen() As Single, TNode As Long, CNodeX As Long, XCnt As Long
    ReDim TempNodeDepth(NumberOfSeqs + 2, NumberOfSeqs + 2), TempLLen(NumberOfSeqs + 2), TempDLen(NumberOfSeqs + 2)
    TNode = x
    Dim oSepBranch() As Integer
    For x = 0 To NumberOfSeqs + 1
        For Y = 0 To NumberOfSeqs + 1
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    Dim RLLen() As Long
    ReDim RLLen(NumberOfSeqs * 2)
    If TNode < 0 Then 'ie the midpoint is in a terminal branch of sequence abs(x)
        TNode = Abs(TNode + 1)
        
        For x = NumberOfSeqs To 0 Step -1
            If SepBranch(x, TNode) = 1 Then
                
                For Z = x To 1 Step -1
                    TempLLen(2 + x - Z) = LLen(Z)
                    TempDLen(2 + x - Z) = DLen(Z)
                    RLLen(Z) = 2 + x - Z
                    Cnt = 0
                    If SepBranch(Z, TNode) = 1 Then
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 0 Then
                                TempNodeDepth(2 + x - Z, Cnt) = Y
                                Cnt = Cnt + 1
                            End If
                            
                        Next Y
                    Else
                        For Y = 0 To NumberOfSeqs
                        
                            If SepBranch(Z, Y) = 1 Then
                                TempNodeDepth(2 + x - Z, Cnt) = Y
                                
                                Cnt = Cnt + 1
                            End If
                        Next Y
                    End If
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(2 + x - Z, Y) = -1
                    Next Y
                Next Z
                TempLLen(1) = SeqXPos(TNode) - LongDist
                SeqXPos(TNode) = LongDist
                NameXPos(TNode) = LongDist
                If x > 1 Then
                    XCnt = 0
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        If TempNodeDepth(2, Y) = -1 Then Exit For
                        'If Y <> TNode Then
                            TempNodeDepth(1, Y) = TempNodeDepth(2, Y)
                            Cnt = Cnt + 1
                        'End If
                    Next Y
                    If Cnt < NumberOfSeqs Then
                    
                        For Y = 0 To NumberOfSeqs
                            If NodeDepth(x, Y) <> TNode Then
                                If NodeDepth(x, Y) = -1 Then Exit For
                                TempNodeDepth(1, Cnt) = NodeDepth(x, Y)
                                Cnt = Cnt + 1
                            End If
                        Next Y
                        
                        For Y = Cnt To NumberOfSeqs
                            TempNodeDepth(1, Cnt) = -1
                        Next Y
                    End If
                Else
                    Cnt = 0
                    For Y = 0 To NumberOfSeqs
                        'If Y <> TNode Then
                            TempNodeDepth(1, Cnt) = Y
                            Cnt = Cnt + 1
                        'End If
                        
                    Next Y
                    For Y = Cnt To NumberOfSeqs
                        TempNodeDepth(1, Cnt) = -1
                    Next Y
                End If
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(0, Y) = TempNodeDepth(1, Y)
                Next Y
                TempNodeDepth(0, NumberOfSeqs) = TNode
                Exit For
            Else
                TempLLen(x + 1) = LLen(x)
                TempDLen(x + 1) = DLen(x)
                RLLen(x) = x + 1
                For Y = 0 To NumberOfSeqs
                    TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
                Next Y
            End If
            
            
        Next x
        TNode = 0
        
    Else   'it is in internal branch x
        TempLLen(2) = CDist - LongDist
        TempLLen(1) = LLen(TNode) - TempLLen(2)
        TempLLen(0) = LLen(TNode) - TempLLen(2)
        TempDLen(1) = DLen(TNode)
        TempDLen(0) = DLen(TNode)
        RLLen(TNode) = 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If SepBranch(TNode, NodeDepth(0, x)) = 1 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                Cnt = Cnt + 1
            End If
        Next x
        For x = 0 To NumberOfSeqs
            
            If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                Cnt = Cnt + 1
            Else
                Exit For
            End If
        Next x
        
        For x = NumberOfSeqs To 0 Step -1
            If SepBranch(TNode, NodeDepth(0, x)) = 0 Then
                TempNodeDepth(0, Cnt) = NodeDepth(0, x)
                Cnt = Cnt + 1
            Else
                Exit For
            End If
        Next x
        
        
        'TempNodeDepth(0, Cnt) = NumberOfSeqs + 1
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If SepBranch(TNode, TempNodeDepth(0, x)) = 0 Then
                TempNodeDepth(2, Cnt) = TempNodeDepth(0, x)
                Cnt = Cnt + 1
            End If
        Next x
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(2, Y) = -1
        Next Y
        Cnt = 0
        For x = 0 To NumberOfSeqs
            If SepBranch(TNode, TempNodeDepth(0, x)) = 1 Then
                TempNodeDepth(1, Cnt) = TempNodeDepth(0, x)
                Cnt = Cnt + 1
            End If
        Next x
        TempNodeDepth(1, Cnt) = NumberOfSeqs + 1
        Cnt = Cnt + 1
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(1, Y) = -1
        Next Y
        
        XCnt = TNode + 1
        YCnt = 3
        For x = TNode - 1 To 1 Step -1
            
            If SepBranch(x, NodeDepth(TNode, 0)) = 0 Then
                TempLLen(XCnt) = LLen(x)
                TempDLen(XCnt) = DLen(x)
                RLLen(x) = XCnt
                Cnt = 0
                For Y = 0 To NumberOfSeqs
                    If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                        TempNodeDepth(XCnt, Cnt) = TempNodeDepth(0, Y)
                        Cnt = Cnt + 1
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(XCnt, Y) = -1
                Next Y
                XCnt = XCnt - 1
            Else
                Cnt = 0
                TempLLen(YCnt) = LLen(x)
                TempDLen(YCnt) = DLen(x)
                RLLen(x) = YCnt
                For Y = 0 To NumberOfSeqs
                    If SepBranch(x, TempNodeDepth(0, Y)) = 0 Then
                        TempNodeDepth(YCnt, Cnt) = TempNodeDepth(0, Y)
                        Cnt = Cnt + 1
                    End If
                Next Y
                For Y = Cnt To NumberOfSeqs
                    TempNodeDepth(YCnt, Y) = -1
                Next Y
                YCnt = YCnt + 1
            End If
            
        Next x
        For x = TNode + 1 To NumberOfSeqs
            TempLLen(x + 1) = LLen(x)
            TempDLen(x + 1) = DLen(x)
            RLLen(x) = x + 1
            For Y = 0 To NumberOfSeqs
                TempNodeDepth(x + 1, Y) = NodeDepth(x, Y)
            Next Y
        Next x
        
    End If
    
    'Rearrange tempnodedepth so that 0-nextno run with the largest to smallest numbers of entries
    Dim ttNodeDepth() As Long, NumEnt() As Long, Maxent As Long, WinEnt As Long, ttLLen(), ttDLen()
    ReDim NumEnt(NumberOfSeqs), ttLLen(NumberOfSeqs), ttDLen(NumberOfSeqs)
    ReDim ttNodeDepth(NumberOfSeqs, NumberOfSeqs)
    For x = 0 To NumberOfSeqs
        NumEnt(x) = 0
        For Y = 0 To NumberOfSeqs
            If TempNodeDepth(x, Y) > -1 Then
                NumEnt(x) = NumEnt(x) + 1
            End If
        Next Y
    Next x
    For Y = 0 To NumberOfSeqs
        Maxent = -1
        For x = 0 To NumberOfSeqs
            If NumEnt(x) > Maxent Then
                Maxent = NumEnt(x)
                WinEnt = x
            End If
        Next x
        For x = 0 To NumberOfSeqs
            ttNodeDepth(Y, x) = TempNodeDepth(WinEnt, x)
            
        Next x
        ttLLen(Y) = TempLLen(WinEnt)
        ttDLen(Y) = TempDLen(WinEnt)
        NumEnt(WinEnt) = -1
       ' RLLen(WinEnt) = Y
    Next Y
    For x = 0 To NumberOfSeqs
        TempLLen(x) = ttLLen(x)
        TempDLen(x) = ttDLen(x)
        For Y = 0 To NumberOfSeqs
            TempNodeDepth(x, Y) = ttNodeDepth(x, Y)
        Next Y
    Next x
    
    ReDim oSepBranch(NumberOfSeqs + 2)
    If TNode > -1 Then
        For x = 0 To NumberOfSeqs
            oSepBranch(x) = SepBranch(TNode, x) '2,3,4,5,6,10,11,12,17,19,20
        Next x
    End If
    
    
    NumberOfSeqs = NumberOfSeqs + 1
    Dim LongHold() As Long
    Dim DoneOne() As Byte, tOrder() As Long
    
    
    ReDim DoneOne(NumberOfSeqs), tOrder(NumberOfSeqs + 1), LongHold(NumberOfSeqs + 1)
    ReDim SepBranch(NumberOfSeqs, NumberOfSeqs)
    
    For x = 0 To NumberOfSeqs - 1
        For Y = 0 To NumberOfSeqs - 1
            If TempNodeDepth(x, Y) > -1 Then
                SepBranch(x, TempNodeDepth(x, Y)) = 1
            Else
                Exit For
            End If
        Next Y
    Next x
    
    Cnt = 0
    Redo = -2
    If TNode > -1 Then
        For A = 0 To 1
            First = -1
            Target = A
            For Z = NumberOfSeqs To 0 Step -1
                If TempNodeDepth(Z, 0) > -1 Then
                    If DoneOne(TempNodeDepth(Z, 0)) = 0 Then
                        Redo = -2
                        First = TempNodeDepth(Z, 0)
                        
                        Last = First
                        For x = Z To 0 Step -1
                            If SepBranch(x, First) = 1 Then
                                Add = 0
                                For Y = 0 To NumberOfSeqs
                                    
                                    If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                        If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                            If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                Add = Add + 1
                                                If Add > 2 Then Exit For
                                            End If
                                        End If
                                    End If
                                    
                                Next Y
                                If Add <= 2 Then
                                    For Y = 0 To NumberOfSeqs
                                        
                                        If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                            If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                    tOrder(Cnt) = TempNodeDepth(x, Y)
                                                    
                                                    DoneOne(TempNodeDepth(x, Y)) = 1
                                                    
                                                    Cnt = Cnt + 1
                                                End If
                                            End If
                                        End If
                                    Next Y
                                ElseIf x > 0 Then
                                    ReDim LongHold(NumberOfSeqs + 1)
                                    XCnt = 0
                                    For Y = 0 To NumberOfSeqs
                                            
                                            If TempNodeDepth(x, Y) > -1 And TempNodeDepth(x, Y) <= NumberOfSeqs - 1 Then
                                                If oSepBranch(TempNodeDepth(x, Y)) = Target Then
                                                    If DoneOne(TempNodeDepth(x, Y)) = 0 Then
                                                        LongHold(XCnt) = TempNodeDepth(x, Y)
                                                        XCnt = XCnt + 1
                                                        
                                                    End If
                                                End If
                                            End If
                                    Next Y
                                    GoOn = 0
                                    For Y = NumberOfSeqs To 0 Step -1
                                        For b = 0 To XCnt - 1
                                            If SepBranch(Y, LongHold(b)) = 1 Then
                                                GoOn = 1
                                                Exit For
                                            End If
                                        Next b
                                        If GoOn = 1 Then Exit For
                                    Next Y
                                    If Y > x And First <> LongHold(b) Then
                                        First = LongHold(b)
                                        x = Y + 1
                                    End If
                                End If
                            
                            End If
                        Next x
                    End If
                End If
                If Cnt > NumberOfSeqs + 1 Then Exit For
                
            Next Z
        Next A
    End If
    
    tOrder(NumberOfSeqs + 1) = NumberOfSeqs + 1
    
    For x = 0 To NumberOfSeqs
        TempNodeDepth(0, x) = tOrder(x)
    Next x
    For x = 0 To NumberOfSeqs
        If TempNodeDepth(0, x) = 0 Then
            For Y = x + 1 To NumberOfSeqs
                If TempNodeDepth(0, Y) = 0 Then
                    For Z = 0 To NumberOfSeqs
                        If DoneOne(Z) = 0 Then
                            DoneOne(Z) = 1
                            TempNodeDepth(0, Y) = Z
                            Exit For
                        End If
                    Next Z
                End If
            Next Y
            Exit For
        End If
    Next x
    For x = 1 To NumberOfSeqs
        ReDim tOrder(NumberOfSeqs + 1)
        Cnt = 0
        For Y = 0 To NumberOfSeqs - 1
            If SepBranch(x, TempNodeDepth(0, Y)) = 1 Then
                tOrder(Cnt) = TempNodeDepth(0, Y)
                Cnt = Cnt + 1
            
            End If
            
        Next Y
        For Y = 0 To Cnt - 1
            TempNodeDepth(x, Y) = tOrder(Y)
        Next Y
        For Y = Cnt To NumberOfSeqs
            TempNodeDepth(x, Y) = -1
        Next Y
    Next x
    
    
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1), LLen(NumberOfSeqs + 1)
    
    For x = 0 To NumberOfSeqs
        LLen(x) = TempLLen(x)
        DLen(x) = TempDLen(x)
        For Y = 0 To NumberOfSeqs
            
            NodeDepth(x, Y) = TempNodeDepth(x, Y)
        Next Y
    Next x
    
    For x = 0 To NumberOfSeqs
        NodeDepth(x, NumberOfSeqs) = -1
        NodeDepth(x, NumberOfSeqs + 1) = -1
    Next x
    LLen(0) = 0
    NodeDepth(0, NumberOfSeqs) = NumberOfSeqs
    
    'work out y-positions of all the nodes.
    ReDim SeqYPos(NumberOfSeqs + 1)
    ReDim tSeqYPos(NumberOfSeqs + 1)
    ReDim NodeYPos(NumberOfSeqs + 1)

    For x = 0 To NumberOfSeqs
        SeqYPos(NodeDepth(0, x)) = x
        tSeqYPos(NodeDepth(0, x)) = x
    Next 'X
    'ccount = the number of bracket pairs (ie internal branches) in the tree
    ' Nodedepth - element 1=bracket pair,2=sequence order
    For x = CCount + 1 To 0 Step -1


        For Y = 0 To NumberOfSeqs + 1

            If NodeDepth(x, Y) = -1 Or NodeDepth(x, Y) = NumberOfSeqs Then Exit For
        Next 'Y

        Y = Y - 1
        If Y < 0 Then Exit For
        If NodeDepth(x, 0) < 0 Then
            NodeDepth(x, 0) = 0
        End If
        NodeYPos(x) = tSeqYPos(NodeDepth(x, 0)) + (tSeqYPos(NodeDepth(x, Y)) - tSeqYPos(NodeDepth(x, 0))) / 2
        tSeqYPos(NodeDepth(x, 0)) = NodeYPos(x)
        tSeqYPos(NodeDepth(x, Y)) = NodeYPos(x)
    Next 'X
    
    NodeYPos(0) = NodeYPos(1)
    
    'work out x positions
    
    ReDim NodeXPos(NumberOfSeqs + 1)
    SS = Abs(GetTickCount)
    ReDim Done(NumberOfSeqs + 1)
    Dummy = GetSeqXPos(UBound(NodeDepth, 1), UBound(NodeDepth, 2), CCount, NumberOfSeqs, NodeDepth(0, 0), Done(0), NodeXPos(0), LLen(0), SeqXPos(0), NameXPos(0))
    EE = Abs(GetTickCount)
    TT = EE - SS '2.609'3.110'3.031
    x = x
    ' Find sequences branching from root node
    'obviosuly node 1 branches so look for largest xpos of sequences not on node 1
    ReDim Outside(NumberOfSeqs + 1)
    'Outie = NumberOfSeqs
    For x = 0 To NumberOfSeqs
        NotFound = 0

        For Y = 0 To NumberOfSeqs

            If NodeDepth(1, Y) = x Then
                NotFound = 1
                Exit For
            End If

        Next 'Y

        If NotFound = 0 Then
            Outside(x) = 1 '0,0,0,1,0,0,1,0,0,0,0,0,0,1
        Else
            Outside(x) = 0
        End If

    Next 'X

    Outside(NumberOfSeqs) = 2
    MPosO = -100
    MPosI = -100

    For x = 0 To NumberOfSeqs

        If Outside(x) = 0 Then

            If SeqXPos(x) > MPosI Then
                MPosI = SeqXPos(x)
            End If

        ElseIf Outside(x) = 1 Then

            If SeqXPos(x) > MPosO Then
                MPosO = SeqXPos(x)
            End If

        End If

    Next 'X
    If Outie > UBound(SeqXPos, 1) Then
        DistanceFlag = 0
        Call GetOutie
    End If
    If SeqXPos(Outie) > MPosO * 1.00000000001 Then
        MPosO = SeqXPos(Outie)
        OutFlag = 2
    Else
        OutFlag = 1
    End If

    'OutsideAdjust = (MPosI - MPosO) / 2
    OutsideAdjust = 0
    Lowest = 100
    NodeXPos(NumberOfSeqs + 1) = NodeXPos(0)
    If OutsideAdjust > 0 Or x = x Then
        For x = 0 To NumberOfSeqs
    
            If NodeDepth(x, 0) > -1 Then
    
                If Outside(NodeDepth(x, 0)) <> OutFlag Then
                    NodeXPos(x) = NodeXPos(x) - OutsideAdjust
                Else
                    NodeXPos(x) = NodeXPos(x) + OutsideAdjust
                End If
    
                If NodeXPos(x) < Lowest Then Lowest = NodeXPos(x)
            End If
    
        Next 'X
    End If
    
    For x = 0 To NumberOfSeqs

        If Outside(x) <> OutFlag Then
            SeqXPos(x) = SeqXPos(x) - OutsideAdjust
        Else
            SeqXPos(x) = SeqXPos(x) + OutsideAdjust
        End If

        If SeqXPos(x) < Lowest Then Lowest = SeqXPos(x) 'this is dumb because seqxpos(numberofseqs) is always 0
    Next 'X

    If Lowest < 0 Then
        TotalAdjust = -Lowest

        For x = 1 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) + TotalAdjust
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) + TotalAdjust
            NameXPos(x) = NameXPos(x) + TotalAdjust
        Next 'X

    Else
        TotalAdjust = 1
        For x = 0 To NumberOfSeqs
            NodeXPos(x) = NodeXPos(x) - Lowest
        Next 'X

        For x = 0 To NumberOfSeqs
            SeqXPos(x) = SeqXPos(x) - Lowest
            NameXPos(x) = NameXPos(x) - Lowest
        Next 'X
    End If

    MaxXPos = 0

    For x = 0 To NumberOfSeqs

        If SeqXPos(x) > MaxXPos Then MaxXPos = SeqXPos(x)
    Next 'X

    ReDim NameWidth(NumberOfSeqs)
    If MaxXPos = 0 Then
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        TBSReps = oReps
        Exit Sub
    End If
    DrawXAdjust = (Form2.Picture2(0).ScaleWidth - 70) / (MaxXPos)
    DrawYAdjust = 14
    
    ReDim NodePath(NumberOfSeqs + 1, NumberOfSeqs + 1)
    ReDim SNodePathX(NumberOfSeqs + 1, NumberOfSeqs + 1)
    For x = 0 To NumberOfSeqs

        For Y = 0 To NumberOfSeqs
            NodePath(x, Y) = -1
            SNodePathX(x, Y) = -1
        Next 'Y

    Next 'X
    
    ReDim CxAdd(NumberOfSeqs)
    XX = UBound(NodePath, 1)
    GoOn = 1
    For x = 0 To NumberOfSeqs
        
        For Y = 0 To NumberOfSeqs

            If NodeDepth(x, Y) = -1 Then Exit For
            If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                
                NodePath(NodeDepth(x, Y), CxAdd(NodeDepth(x, Y))) = x
                CxAdd(NodeDepth(x, Y)) = CxAdd(NodeDepth(x, Y)) + 1 '0
            Else
                GoOn = 0
                Exit For
                
            End If
        Next 'Y
        If GoOn = 0 Then
            ReDim CxAdd(NumberOfSeqs)
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    NodeDepth(A, b) = NHNodeDepth(A, b)
                Next b
            Next A
            For A = 0 To NumberOfSeqs
        
                For b = 0 To NumberOfSeqs
                    If NodeDepth(A, b) = -1 Then Exit For
                    If CxAdd(NodeDepth(x, Y)) <= UBound(NodeDepth, 2) Then
                        NodePath(NodeDepth(A, b), CxAdd(NodeDepth(A, b))) = A
                        CxAdd(NodeDepth(A, b)) = CxAdd(NodeDepth(A, b)) + 1
                    Else
                        Exit For
                    End If
                Next b
            Next A
            Exit For
        End If

    Next 'X
    'Exit Sub
    Dim NodeMaxRep() As Single
    ReDim NodeMaxRep(NumberOfSeqs)
    
    SS = Abs(GetTickCount)
    
    'port this to c++
    For x = 0 To NumberOfSeqs - 1
        
        NodeMaxRep(x) = 0
        
    Next x
    
    If x = x Then
        Dim DoesXContainZ() As Integer
        ReDim DoesXContainZ(NumberOfSeqs, NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 0 To NumberOfSeqs + 1
                If NodeDepth(x, Y) > -1 Then
                    DoesXContainZ(x, NodeDepth(x, Y)) = 1
                Else
                    Exit For
                End If
            Next Y
        
        
        Next x
        
        
        For Z = 0 To NumberOfSeqs - 1
            If Z <= UBound(SeqCoverage, 1) Then
                For x = 0 To NumberOfSeqs
                    If DoesXContainZ(x, Z) = 1 Then
                        If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                    End If
                Next x
            End If
        Next Z
    Else
        For Z = 0 To NumberOfSeqs - 1
            For x = 0 To NumberOfSeqs
                
                For Y = 0 To NumberOfSeqs + 1
                    If NodeDepth(x, Y) > -1 Then
                        If NodeDepth(x, Y) = Z Then
                        'XX = UBound(SeqCoverage, 1)
                                If Z <= UBound(SeqCoverage, 1) Then
                                    If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                                    If NodeMaxRep(x) < SeqCoverage(Z) Then NodeMaxRep(x) = SeqCoverage(Z)
                                End If
                            
                            Exit For
                        End If
                    Else
                        Exit For
                    End If
                Next Y
            
            Next x
        Next Z
    
    
    
    End If
    
    EE = Abs(GetTickCount)
    TT = EE - SS '33.735'31.016'31.500'0.25
    x = x
    'Treedraw(A,B,C,D,E)
    'A = treenumber (0-3)
    'B = treetype (0-3)
    'C = datatype (0=string,1 = line,2 = box)
    'D = coordinates/sequence number/colour etc - (0 = X ccord, 1=Y coord, 2 = sequence number,3 = colour;
    'E = element number
    
    
    BkRx = BkR - 5
    BkGx = BkG - 5
    BkBx = BkB - 5
    
    ReDim DoneLine(NumberOfSeqs, NumberOfSeqs)
    
    A = -1: b = -1
    
    
    For x = 0 To NumberOfSeqs - 1
        
        For Y = 0 To NumberOfSeqs - 2

            If NodePath(x, Y + 1) > -1 Then
                If DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 0 Then
                    
                    DoneLine(NodePath(x, Y), NodePath(x, Y + 1)) = 1
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                        Pos = UBound(TreeDraw, 5) + 100
                        ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                    End If
                    
                    TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB((BkRx - BkRx * NodeMaxRep(NodePath(x, Y + 1))), BkGx - BkGx * NodeMaxRep(NodePath(x, Y + 1)), BkBx - BkBx * NodeMaxRep(NodePath(x, Y + 1)))
                    
                    A = A + 1
                    If A > UBound(TreeDraw, 5) Then
                        Pos = UBound(TreeDraw, 5) + 100
                        ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                    End If
                    
                    TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y + 1)) * DrawXAdjust
                    TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + NodeYPos(NodePath(x, Y + 1)) * DrawYAdjust
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(NodePath(x, Y + 1)), BkGx - BkGx * NodeMaxRep(NodePath(x, Y + 1)), BkBx - BkBx * NodeMaxRep(NodePath(x, Y + 1)))
                Else
                    x = x
                End If
            ElseIf NodePath(x, Y) > -1 Then
                A = A + 1
                If A > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + NodeYPos(NodePath(x, Y)) * DrawYAdjust
                TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                If x <= UBound(SeqCoverage, 1) Then
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverage(x), BkGx - BkGx * SeqCoverage(x), BkBx - BkBx * SeqCoverage(x))
                Else
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(255, 255, 255)
                End If
                A = A + 1
                
                If A > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 1, 0, A) = 10 + NodeXPos(NodePath(x, Y)) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 1, A) = 10 + SeqYPos(x) * DrawYAdjust
                TreeDraw(TIndexX, NJF, 1, 2, A) = 10 + SeqXPos(x) * DrawXAdjust
                TreeDraw(TIndexX, NJF, 1, 3, A) = 10 + SeqYPos(x) * DrawYAdjust
                If x <= UBound(SeqCoverage, 1) Then
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(BkRx - BkRx * SeqCoverage(x), BkGx - BkGx * SeqCoverage(x), BkBx - BkBx * SeqCoverage(x))
                Else
                    TreeDraw(TIndexX, NJF, 1, 4, A) = RGB(255, 255, 255)
                End If
                
                XCord(NJF, TIndexX, x) = NameXPos(x) * DrawXAdjust + 15 + 1
                YCord(NJF, TIndexX, x) = (SeqYPos(x) * DrawYAdjust + 4)
                
                RYCord(NJF, TIndexX, SeqYPos(x)) = x
                
                b = b + 1
                If b > UBound(TreeDraw, 5) Then
                    Pos = UBound(TreeDraw, 5) + 100
                    ReDim Preserve TreeDraw(3, 4, 1, 4, Pos)
                End If
                TreeDraw(TIndexX, NJF, 0, 0, b) = XCord(NJF, TIndexX, x)
                TreeDraw(TIndexX, NJF, 0, 1, b) = YCord(NJF, TIndexX, x)
                TreeDraw(TIndexX, NJF, 0, 2, b) = x
                TreeDraw(TIndexX, NJF, 0, 3, b) = -1
                Exit For
            End If

        Next 'Y

    Next 'X

    
    Form2.Picture2(0).FontSize = 8.25
    ScaleValD = 0.1

    If ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2 Then

        Do While ScaleValD * DrawXAdjust > Form2.Picture2(0).ScaleWidth / 2
            ScaleValD = ScaleValD / 2
        Loop

    End If
    
    A = A + 1
    TreeDraw(TIndexX, NJF, 1, 0, A) = 5
    TreeDraw(TIndexX, NJF, 1, 1, A) = ((NumberOfSeqs + 2) * DrawYAdjust)
    TreeDraw(TIndexX, NJF, 1, 2, A) = 5 + ScaleValD * DrawXAdjust
    TreeDraw(TIndexX, NJF, 1, 3, A) = (NumberOfSeqs + 2) * DrawYAdjust
    
    ScaleVal = ScaleValD
    ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
    
    b = b + 1
    TreeDraw(TIndexX, NJF, 0, 0, b) = 5 + ((ScaleValD * DrawXAdjust) - ScaleSize) / 2
    TreeDraw(TIndexX, NJF, 0, 1, b) = (NumberOfSeqs + 2.5) * DrawYAdjust
    TreeDraw(TIndexX, NJF, 0, 2, b) = -1
    TreeDraw(TIndexX, NJF, 0, 3, b) = -ScaleValD * 10000
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB()) 'treedrawb allows quicker access during tree drawing
    CurTree(3) = 3
'TDLen(3, 4, 2)
    TDLen(TIndexX, NJF, 1) = A
    TDLen(TIndexX, NJF, 0) = b
    TDLen(TIndexX, NJF, 2) = Form2.Picture2(0).ScaleWidth
    
    BigTreeNextnoU = NumberOfSeqs - 1
    ReDim BigTreeNameU(NumberOfSeqs - 1)
    For x = 0 To NumberOfSeqs - 1
        BigTreeNameU(x) = TempName(x)
        
    Next x
    'NHString(31) = BigTreeNHU
    Call ReplaceNames(BigTreeNameU(), BigTreeNextnoU, NHString(31))
    
End Sub
Public Sub DoBigTreeUPGMA()

    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, NameXPos() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim ScaleValD As Double, tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, ColTotals() As Single
    
    Dim TIndexX As Byte, DoneLine() As Byte, OrderArray() As Byte, SHolder() As Byte, Treebyte() As Byte
    
    Dim NHFlag As Integer, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NameLen As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer, FF As Integer, Scratch() As Integer, bttSeqNum() As Integer
    
    Dim YCnt As Long, LS As Long, oReps As Long, A As Long, b As Long, NLen As Long, PNodeStr() As Long, LSeq As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Cnt As Long, SP As Long, DEN() As Long, LTree As Long, NumberOfSeqs As Long


    
    Dim TempName() As String
    ReDim TempName(NextNo)
    
    
    
    'TIndexX = 3 'i.e.  otrees drawn taking account of recombination
    'NJF = 3 ' put it into the ML slot
    
    For x = 0 To NextNo
        TempName(x) = OriginalName(x)
        Do
            Pos = InStr(1, TempName(x), ",", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
            
        Loop
        Do
            Pos = InStr(1, TempName(x), "(", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ")", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ":", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "[", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "]", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ";", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ".", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "_", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
    Next x
    oNextno = NextNo
    Dim TempName2() As String
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    
    
'Make the sequences for the BigUPGMA
    Dim STraceA() As Long, SeqSave() As Integer
    NumSeqs = NextNo
    ReDim BigTreeTraceEventU(NextNo)
    ReDim STraceA(NextNo)
    For x = 0 To NextNo
        STraceA(x) = x
    Next x
    ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqSave
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        
    Else
        For x = 0 To PermNextno
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, x) = PermSeqNum(Y, x)
            Next Y
        Next x
    End If
    
        
    Dim DoneEv() As Byte, DoneAtAll() As Byte, AddString() As String, AddedC() As Byte, TmpX As Long
    ReDim DoneEv(SEventNumber, NextNo), DoneAtAll(SEventNumber), AddString(NextNo)
    Dim AcceptC(2) As Byte, LNextno As Long
    
    Call MakeAcceptC(7, AcceptC()) 'specifies that the acceptc to make is for the tree with recombinant regions separated.
        
    For A = 1 To SEventNumber
        ReDim AddedC(NextNo)
        x = BestEvent(A, 0)
        Y = BestEvent(A, 1)
        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
            BE = XoverList(x, Y).Beginning
            EN = XoverList(x, Y).Ending
            SE = SuperEventList(XoverList(x, Y).Eventnumber)
            LNextno = NextNo
            For b = 0 To NextNo
                If Daught(A, STraceA(b)) > 0 Then
                    'If STraceA(B) = 10 Then
                    '    X = X
                    'End If
                    
                    'check and make sure the breakpoints are actually splitting up some sequences - if they are not then the sequence must be left as is
                    If BE < EN Then
                        GoOn = 0
                        For x = 1 To BE - 1
                            If SeqSave(x, b) > 50 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next x
                        If GoOn = 0 Then
                            For x = EN + 1 To Len(StrainSeq(0))
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                        End If
                        If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                            GoOn = 0
                            For x = BE To EN
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                        End If
                        
                    Else
                        GoOn = 0
                        For x = EN + 1 To BE - 1
                            If SeqSave(x, b) > 50 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next x
                        
                        If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                            GoOn = 0
                            For x = BE To Len(StrainSeq(0))
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                            If GoOn = 0 Then
                                For x = 1 To EN
                                    If SeqSave(x, b) > 50 Then
                                        GoOn = 1
                                        Exit For
                                    End If
                                Next x
                            End If
                        End If
                    End If
                    
                    
                    If GoOn = 1 Then
                        NextNo = NextNo + 1
                        
                        If A = 1 Or NextNo > UBound(STraceA, 1) Then
                             TmpX = NextNo
                             NextNo = NextNo + 40
                             ReDim Preserve STraceA(NextNo)
                             ReDim Preserve BigTreeTraceEventU(NextNo)
                             ReDim Preserve OriginalName(NextNo), TempName(NextNo), SeqSave(Len(StrainSeq(0)), NextNo)
                             ReDim Preserve AddString(NextNo)
                             NextNo = TmpX
                        End If
                        BigTreeTraceEventU(NextNo) = SE
                        STraceA(NextNo) = STraceA(b)
                        TempName(NextNo) = TempName(STraceA(b)) + "_" + Trim(Str(BE)) + "-" + Trim(Str(EN))
                        If BE < EN Then
                            For Z = BE To EN
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                            For Z = 1 To BE - 1
                                SeqSave(Z, NextNo) = 46
                            Next Z
                            For Z = EN + 1 To Len(StrainSeq(0))
                                SeqSave(Z, NextNo) = 46
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                            For Z = EN + 1 To BE - 1
                                SeqSave(Z, NextNo) = 46
                            Next Z
                            For Z = 1 To EN
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                        End If
                    End If
                End If
            Next b
            x = x
        End If
        'Next Y
    
    
    
    
        If A / 20 = CLng(A / 20) Then
            b = 0
            'Nextno = Nextno - 40
            Do While b <= NextNo
                SLenX = 0
                For Z = 1 To Len(StrainSeq(0))
                    If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                        SLenX = SLenX + 1
                        If SLenX > 50 Then Exit For
                        
                        
                    End If
                Next Z
                If SLenX = 0 Then
                    TempName(b) = TempName(NextNo)
                    STraceA(b) = STraceA(NextNo)
                    If BigTreeTraceEventU(b) = 4 Then
                        x = x
                    End If
                    BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
                    For Z = 0 To Len(StrainSeq(0))
                        SeqSave(Z, b) = SeqSave(Z, NextNo)
                        SeqSave(Z, NextNo) = 46
                    Next Z
                    If AddEventFlag = 1 Then
                        AddString(b) = AddString(NextNo)
                        
                    End If
                    NextNo = NextNo - 1
                    b = b - 1
                End If
                b = b + 1
            Loop
            
        End If
        Form1.ProgressBar1 = (A / SEventNumber) * 5
        Call UpdateF2Prog
    Next A
        'get rid of empties
        
    
    ' For X = 0 To Nextno
    '        If TempName(X) = "M_3545-3730" Then '68,69,70
    '            X = X
    '            SLenX = 0
    '           For Y = 0 To Len(StrainSeq(0))
    '                If SeqSave(Y, X) <> 46 And SeqSave(Y, X) <> 0 Then
    ''                    SLenX = SLenX + 1
    '
    '                Else
    '                    X = X
    '                End If
    '
    '           Next Y
    '            X = X
    '        End If
    '    Next X
    
    b = 0
    'Open "tempDBT.csv" For Output As #1
    'Nextno = Nextno - 40
    'XX = TempName(33)
    'XX = BigTreeTraceEventU(39)
    Do While b <= NextNo
        SLenX = 0
        For Z = 1 To Len(StrainSeq(0))
            If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                SLenX = SLenX + 1
                If SLenX > 50 Then Exit For
                
                
            End If
        Next Z
        
        If SLenX = 0 Then '57,57,57,57,57,57,58
            'Print #1, B
            TempName(b) = TempName(NextNo)
            STraceA(b) = STraceA(NextNo)
            BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
            For Z = 0 To Len(StrainSeq(0))
                SeqSave(Z, b) = SeqSave(Z, NextNo)
                SeqSave(Z, NextNo) = 46
            Next Z
            
            NextNo = NextNo - 1
            b = b - 1
        End If
        b = b + 1
    Loop
    
   ' For X = 0 To Nextno
   '         If TempName(X) = "K_7811-8227" Then '68,69,70
   '            X = X
   '             SLenX = 0
   '            For Y = 0 To Len(StrainSeq(0))
   '                 If SeqSave(Y, X) <> 46 And SeqSave(Y, X) <> 0 Then
   '                     SLenX = SLenX + 1
  '
  '                  Else
  '                      X = X
  '                  End If
   ''
   '            Next Y
   '             X = X
   '         End If
   '    Next X
    
    'Close #1
        
    'For X = 0 To Nextno
    '    For Y = 1 To Len(StrainSeq(0))
    '        If SeqSave(Y, X) = 0 Then
    '            X = X
    '        End If
     '   Next Y
     '
    'Next X
        
   ' Dim ArSize As Long
    ArSize = UBound(STraceA, 1)
    ReDim BigTreeTraceU(ArSize)
    For x = 0 To ArSize
        BigTreeTraceU(x) = STraceA(x)
    Next x
        
    ReDim TempName2(NextNo)
    If UBound(TempName, 1) < NextNo Then
        ReDim Preserve TempName(NextNo)
    End If
    ReDim Preserve OriginalName(NextNo)
    For x = 0 To NextNo
        TempName2(x) = OriginalName(x)
        OriginalName(x) = TempName(x)
    Next x
    
    'use seqsave to draw a upgma
    
    Dim TreeTraceX() As Long, TreeTraceSeqsX() As Long, pNextNo As Long, NodeLength() As Double, TreeX() As Integer, TreeY() As Integer, Decompress() As Long, PermDIffs() As Single, PermValid() As Single, Distance() As Single
    ReDim TreeTraceX(NextNo), TreeTraceSeqsX(1, NextNo)
    
    For x = 0 To NextNo
        TreeTraceX(x) = x
        TreeTraceSeqsX(0, x) = x
        TreeTraceSeqsX(1, x) = x
    Next x
    ReDim NodeFindZ(NextNo + 2, NextNo + 2)
    'ReDim NodeMaxRepZ(Nextno + 2, Nextno + 2)  'stores the max sequence coverage in sequence above this node - used later to shade branches.
    ReDim NodeXYZ(25, NextNo + 2, 1)
    BigTreeNextnoU = NextNo
    ReDim BigTreeNameU(NextNo)
    For x = 0 To NextNo
        BigTreeNameU(x) = TempName(x)
        
    Next x
    'Open "tname.csv" For Output As #1
    'For X = 0 To Nextno
   '
   ' Next X
   ' Close #1
    
    Call UPGMA(TempName(), BigTreeNHU, SeqSave(), CLng(2), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 3)
    pNextNo = NextNo
    Call UPGMADraw(TreeTraceX(), TreeTraceSeqsX(), pNextNo, NodeFindZ(), NodeXYZ(), 1, 3, NextNo, NodeLength(), TreeX(), TreeY())
    NHString(31) = BigTreeNHU
    Erase TreeX
    
    Call ReplaceNames(BigTreeNameU(), BigTreeNextnoU, NHString(31))
    
  NextNo = oNextno
    
End Sub


Public Sub PADREUPGMA()

    Dim MPosO As Double, Lowest As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, NameXPos() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim ScaleValD As Double, tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, ColTotals() As Single
    
    Dim TIndexX As Byte, DoneLine() As Byte, OrderArray() As Byte, SHolder() As Byte, Treebyte() As Byte
    
    Dim NHFlag As Integer, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NameLen As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer, FF As Integer, Scratch() As Integer, bttSeqNum() As Integer
    
    Dim YCnt As Long, LS As Long, oReps As Long, A As Long, b As Long, NLen As Long, PNodeStr() As Long, LSeq As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Cnt As Long, SP As Long, DEN() As Long, LTree As Long, NumberOfSeqs As Long


    
    Dim TempName() As String
    ReDim TempName(NextNo)
    
    
    
    TIndexX = 3 'i.e.  otrees drawn taking account of recombination
    NJF = 3 ' put it into the ML slot
    
    For x = 0 To NextNo
        TempName(x) = OriginalName(x)
        Do
            Pos = InStr(1, TempName(x), ",", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), " ", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
            
        Loop
        Do
            Pos = InStr(1, TempName(x), "(", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ")", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ":", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "[", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "]", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ";", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), ".", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
        Do
            Pos = InStr(1, TempName(x), "_", vbBinaryCompare)
            If Pos > 0 Then
                Mid$(TempName(x), Pos, 1) = "-"
            Else
                Exit Do
            End If
        Loop
    Next x
    oNextno = NextNo
    Dim TempName2() As String
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    
    
'Make the sequences for the BigUPGMA
    Dim STraceA() As Long, SeqSave() As Integer
    NumSeqs = NextNo
    ReDim PADRETraceEventU(NextNo)
    ReDim STraceA(NextNo)
    For x = 0 To NextNo
        STraceA(x) = x
    Next x
    
    If PermSeqNumInFile = 1 Then
        ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqSave
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        ReDim Preserve SeqSave(Len(StrainSeq(0)), NextNo)
    Else
        ReDim SeqSave(Len(StrainSeq(0)), NextNo)
        For x = 0 To PermNextno
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, x) = PermSeqNum(Y, x)
            Next Y
        Next x
    End If
    
        
    Dim DoneEv() As Byte, DoneAtAll() As Byte, AddString() As String, AddedC() As Byte, TmpX As Long
    ReDim DoneEv(SEventNumber, NextNo), DoneAtAll(SEventNumber), AddString(NextNo)
    Dim AcceptC(2) As Byte, LNextno As Long
    
    Call MakeAcceptC(7, AcceptC()) 'specifies that the acceptc to make is for the tree with recombinant regions separated.
        
    For A = 1 To SEventNumber
        ReDim AddedC(NextNo)
        x = BestEvent(A, 0)
        Y = BestEvent(A, 1)
        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
            BE = XoverList(x, Y).Beginning
            EN = XoverList(x, Y).Ending
            SE = SuperEventList(XoverList(x, Y).Eventnumber)
            
            
            
            LNextno = NextNo
            For b = 0 To NextNo
                If Daught(A, STraceA(b)) > 0 Then
                    'check and make sure the breakpoints are actually splitting up some sequences - if they are not then the sequence must be left as is
                    If BE < EN Then
                        GoOn = 0
                        For x = 1 To BE - 1
                            If SeqSave(x, b) > 50 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next x
                        If GoOn = 0 Then
                            For x = EN + 1 To Len(StrainSeq(0))
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                        End If
                        If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                            GoOn = 0
                            For x = BE To EN
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                        End If
                        
                    Else
                        GoOn = 0
                        For x = EN + 1 To BE - 1
                            If SeqSave(x, b) > 50 Then
                                GoOn = 1
                                Exit For
                            End If
                        Next x
                        
                        If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                            GoOn = 0
                            For x = BE To Len(StrainSeq(0))
                                If SeqSave(x, b) > 50 Then
                                    GoOn = 1
                                    Exit For
                                End If
                            Next x
                            If GoOn = 0 Then
                                For x = 1 To EN
                                    If SeqSave(x, b) > 50 Then
                                        GoOn = 1
                                        Exit For
                                    End If
                                Next x
                            End If
                        End If
                    End If
                    
                    
                    If GoOn = 1 Then
                        NextNo = NextNo + 1
                        
                        If A = 1 Or NextNo > UBound(STraceA, 1) Then
                             TmpX = NextNo
                             NextNo = NextNo + 40
                             ReDim Preserve STraceA(NextNo)
                             ReDim Preserve PADRETraceEventU(NextNo)
                             ReDim Preserve OriginalName(NextNo), TempName(NextNo), SeqSave(Len(StrainSeq(0)), NextNo)
                             ReDim Preserve AddString(NextNo)
                             NextNo = TmpX
                        End If
                        PADRETraceEventU(NextNo) = SE
                        STraceA(NextNo) = STraceA(b)
                        
                        
                        TempName(NextNo) = TempName(STraceA(b))
                        If DoneEv(SE, STraceA(b)) = 0 Then
                            
                            If Right$(TempName(STraceA(b)), 1) = "_" Then
                                 TempName(STraceA(b)) = TempName(STraceA(b)) + Trim(Str(SE)) + "_"
                            Else
                                 TempName(STraceA(b)) = TempName(STraceA(b)) + "_" + Trim(Str(SE)) + "_"
                            End If
                           
                            DoneEv(SE, STraceA(b)) = 1
                            
                            If Right$(TempName(NextNo), 1) = "_" Then
                                TempName(NextNo) = TempName(NextNo) + Trim(Str(SE)) + "_"
                            Else
                                TempName(NextNo) = TempName(NextNo) + "_" + Trim(Str(SE)) + "_"
                                
                            End If
                        
                        End If
                                            
                        'TempName(Nextno) = TempName(STraceA(B)) + "_" + Trim(Str(BE)) + "-" + Trim(Str(EN))
                                            
                        If BE < EN Then
                            For Z = BE To EN
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                            For Z = 1 To BE - 1
                                SeqSave(Z, NextNo) = 46
                            Next Z
                            For Z = EN + 1 To Len(StrainSeq(0))
                                SeqSave(Z, NextNo) = 46
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                            For Z = EN + 1 To BE - 1
                                SeqSave(Z, NextNo) = 46
                            Next Z
                            For Z = 1 To EN
                                SeqSave(Z, NextNo) = SeqSave(Z, b)
                                SeqSave(Z, b) = 46
                            Next Z
                        End If
                    End If
                End If
            Next b
        End If
        'Next Y
    
    
    
    
        If A / 20 = CLng(A / 20) Then
            b = 0
            'Nextno = Nextno - 40
            Do While b <= NextNo
                SLenX = 0
                For Z = 1 To Len(StrainSeq(0))
                    If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                        SLenX = SLenX + 1
                        If SLenX > 50 Then Exit For
                        
                        
                    End If
                Next Z
                If SLenX = 0 Then
                    TempName(b) = TempName(NextNo)
                    STraceA(b) = STraceA(NextNo)
                    PADRETraceEventU(b) = PADRETraceEventU(NextNo)
                    For Z = 0 To Len(StrainSeq(0))
                        SeqSave(Z, b) = SeqSave(Z, NextNo)
                        SeqSave(Z, NextNo) = 46
                    Next Z
                    If AddEventFlag = 1 Then
                        AddString(b) = AddString(NextNo)
                        
                    End If
                    NextNo = NextNo - 1
                    b = b - 1
                End If
                b = b + 1
            Loop
            
        End If
        Form1.ProgressBar1 = (A / SEventNumber) * 5
        Call UpdateF2Prog
    Next A
        'get rid of empties
        
    
    ' For X = 0 To Nextno
    '        If TempName(X) = "M_3545-3730" Then '68,69,70
    '            X = X
    '            SLenX = 0
    '           For Y = 0 To Len(StrainSeq(0))
    '                If SeqSave(Y, X) <> 46 And SeqSave(Y, X) <> 0 Then
    ''                    SLenX = SLenX + 1
    '
    '                Else
    '                    X = X
    '                End If
    '
    '           Next Y
    '            X = X
    '        End If
    '    Next X
    
    b = 0
    'Open "tempDBT.csv" For Output As #1
    'Nextno = Nextno - 40
    Do While b <= NextNo
        SLenX = 0
        For Z = 1 To Len(StrainSeq(0))
            If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                SLenX = SLenX + 1
                If SLenX > 50 Then Exit For
                
                
            End If
        Next Z
        If b = 59 Then
            x = x
            XX = TempName(b)
        End If
        If SLenX = 0 Then '57,57,57,57,57,57,58
            'Print #1, B
            TempName(b) = TempName(NextNo)
            STraceA(b) = STraceA(NextNo)
            PADRETraceEventU(b) = PADRETraceEventU(NextNo)
            For Z = 0 To Len(StrainSeq(0))
                SeqSave(Z, b) = SeqSave(Z, NextNo)
                SeqSave(Z, NextNo) = 46
            Next Z
            
            NextNo = NextNo - 1
            b = b - 1
        End If
        b = b + 1
    Loop
    
   ' For X = 0 To Nextno
   '         If TempName(X) = "K_7811-8227" Then '68,69,70
   '            X = X
   '             SLenX = 0
   '            For Y = 0 To Len(StrainSeq(0))
   '                 If SeqSave(Y, X) <> 46 And SeqSave(Y, X) <> 0 Then
   '                     SLenX = SLenX + 1
  '
  '                  Else
  '                      X = X
  '                  End If
   ''
   '            Next Y
   '             X = X
   '         End If
   '    Next X
    
    'Close #1
        
    'For X = 0 To Nextno
    '    For Y = 1 To Len(StrainSeq(0))
    '        If SeqSave(Y, X) = 0 Then
    '            X = X
    '        End If
     '   Next Y
     '
    'Next X
        
   ' Dim ArSize As Long
    ArSize = UBound(STraceA, 1)
    ReDim PADRETraceU(ArSize)
    For x = 0 To ArSize
        PADRETraceU(x) = STraceA(x)
    Next x
        
    ReDim TempName2(NextNo)
    If UBound(TempName, 1) < NextNo Then
        ReDim Preserve TempName(NextNo)
    End If
    ReDim Preserve OriginalName(NextNo)
    For x = 0 To NextNo
        TempName2(x) = OriginalName(x)
        OriginalName(x) = TempName(x)
    Next x
    
    'use seqsave to draw a upgma
    
    Dim TreeTraceX() As Long, TreeTraceSeqsX() As Long, pNextNo As Long, NodeXYZ() As Long, NodeLength() As Double, TreeX() As Integer, TreeY() As Integer, Decompress() As Long, PermDIffs() As Single, PermValid() As Single, Distance() As Single
    ReDim TreeTraceX(NextNo), TreeTraceSeqsX(1, NextNo)
    
    For x = 0 To NextNo
        TreeTraceX(x) = x
        TreeTraceSeqsX(0, x) = x
        TreeTraceSeqsX(1, x) = x
    Next x
    
    
    ReDim NodeXYZ(25, NextNo + 2, 1)
    PADRENextnoU = NextNo
    ReDim PADRENameU(NextNo)
    For x = 0 To NextNo
        PADRENameU(x) = TempName(x)
        
    Next x
    'Open "tname.csv" For Output As #1
    'For X = 0 To Nextno
   '
   ' Next X
   ' Close #1
    Dim PADRENHF As String
    Call UPGMA(TempName2(), PADRENHF, SeqSave(), CLng(3), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 2)
    Erase TreeX
    
    pNextNo = NextNo
    Open "treein.tre" For Output As #1
Print #1, PADRENHF
Close #1

'Open "c:\Users\a043878\Documents\JCreator Pro\MyProjects\Padre-Rad\very-big-tree.tre" For Output As #1

'Open "c:\Users\a043878\Documents\JCreator Pro\MyProjects\Padre-Rad\very-big-tree.tre" For Output As #1
'Print #1, PADRENHF
'Close #1

'c:\Users\a043878\Documents\JCreator Pro\MyProjects\Padre-Rad\very-big-tree.tre"
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "coordinates.txt"
On Error GoTo 0

If DebuggingFlag < 2 Then On Error Resume Next
Open "padre.bat" For Output As #1
'-i <input-file> -o n -m m -r r -s s
Print #1, "java -jar padre2.jar -r r -m m -s s -i treein.tre -o n"
'Print #1, "java -jar padre2.jar -r m -i treein.tre -o n"
'c:\Users\a043878\Documents\JCreator Pro\MyProjects\Padre-Rad\very-big-tree.tre"
'java -jar padre2.jar -r m -i treein.tre -o n
Close #1
On Error GoTo 0

ShellAndClose "padre.bat", 0
Dim EdgeNo As Long, VertexNo As Long, XXX As String

Open "coordinates.txt" For Binary As #1
XXX = String(LOF(1), " ")
Get #1, 1, XXX
Close #1

Open "coordinates2.txt" For Output As #1
Do
    Pos = InStr(1, XXX, Chr(10), vbBinaryCompare)
    If Pos = 0 Then Exit Do
    Mid$(XXX, Pos, 1) = Chr(13)

Loop
Print #1, XXX
Close #1
Open "coordinates2.txt" For Input As #1
Input #1, EdgeNo
Input #1, VertexNo
ReDim MartVertex(1, VertexNo), MartEdge(3, EdgeNo), MartString(EdgeNo)

For x = 1 To EdgeNo
    For Y = 0 To 3
        Input #1, MartEdge(Y, x)
        
    Next Y
Next x

For x = 1 To VertexNo
    For Y = 0 To 1
        Input #1, MartVertex(Y, x)
        
    Next Y
    Input #1, MartString(x)
    
Next x


Close #1

MaxX = 0
MaxY = 0

For x = 1 To EdgeNo
    'For Y = 0 To 3
        If MartEdge(0, x) > MaxX Then MaxX = MartEdge(0, x)
        If MartEdge(2, x) > MaxX Then MaxX = MartEdge(2, x)
        If MartEdge(1, x) > MaxY Then MaxY = MartEdge(1, x)
        If MartEdge(3, x) > MaxY Then MaxY = MartEdge(2, x)
   ' Next Y
Next x
For x = 1 To VertexNo
    
        If MartVertex(0, x) > MaxX Then MaxX = MartVertex(0, x)
        If MartVertex(1, x) > MaxY Then MaxY = MartVertex(1, x)
   
Next x


'dim inPic As PictureBox

xDim = Form2.Picture2(3).ScaleWidth
ydim = (NextNo + 1) * 13 'Form2.Picture2(3).ScaleHeight

XOff = xDim / 20
YOff = 10 'ydim / 20

xDim = xDim - xDim / 10
'ydim = ydim - ydim / 10

XAdj = xDim / MaxX
YAdj = ydim / MaxY
Dim Pict As Long, Pnt As POINTAPI
Form2.Picture2(3).Picture = LoadPicture()

Form2.Picture2(3).ForeColor = RGB(196, 196, 196)


Dim ArcFlag As Byte
For x = 1 To EdgeNo
    'does this edge correspond with a vertix
    For Y = 1 To VertexNo
        
        ArcFlag = 0
        If MartVertex(0, Y) = MartEdge(0, x) And MartVertex(1, Y) = MartEdge(1, x) And Left(MartString(Y), 1) <> "S" Then
            
            ArcFlag = 1
            Exit For
        
            
        End If
    Next Y
    If ArcFlag = 0 Then
        
        Form2.Picture2(3).ForeColor = RGB(0, 0, 0)
        Pict = Form2.Picture2(3).hdc
        Dummy = MoveToEx(Pict, XOff + MartEdge(0, x) * XAdj, YOff + MartEdge(1, x) * YAdj, Pnt)
        Dummy = LineTo(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(1, x) * YAdj)
        Dummy = LineTo(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(3, x) * YAdj)
    Else
        Pict = Form2.Picture2(3).hdc
        Form2.Picture2(3).ForeColor = RGB(196, 196, 196)
        If MartEdge(1, x) < MartEdge(3, x) Then
            If MartEdge(0, x) > MartEdge(2, x) Then
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj))
            Else
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj), (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj))
            End If
        Else
         
            If MartEdge(0, x) > MartEdge(2, x) Then
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj), (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj))
            Else
                
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj))
            End If
            x = x
         ' Form2.Picture2(3).ForeColor = RGB(196, 0, 0)
         ' Dummy = MoveToEx(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), Pnt)
         ' Dummy = LineTo(Pict, (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        'X = X
            Dummy = SetPixelV(Pict, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), RGB(255, 0, 0))
           Dummy = SetPixelV(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(3, x) * YAdj, RGB(0, 0, 255))
           x = x
        End If
        'Dummy = SetPixelV(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), RGB(255, 0, 0))
        'Dummy = SetPixelV(Pict, xoff + MartEdge(2, X) * XAdj, YOff + MartEdge(3, X) * YAdj, RGB(0, 0, 255))
        'Dummy = SetPixelV(Pict, (xoff + (MartEdge(2, X) + (MartEdge(0, X) - MartEdge(2, X)) / 4) * XAdj), (YOff + (MartEdge(1, X) - (MartEdge(1, X) - MartEdge(3, X)) / 4) * YAdj), RGB(0, 255, 0))
        'Pict = Form2.Picture2(3).hdc
        'Form2.Picture2(3).ForeColor = RGB(196, 196, 196)
        'Dummy = Arc(Pict, (xoff + MartEdge(2, X) * XAdj), YOff + MartEdge(1, X) * YAdj, xoff + (MartEdge(0, X)) * XAdj, YOff + (MartEdge(3, X)) * YAdj, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        'Dummy = MoveToEx(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), Pnt)
        'Dummy = LineTo(Pict, (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        x = x
    End If
   
    
    x = x
Next x

Form2.Picture2(3).ForeColor = 0

For x = 1 To VertexNo
    If Left(MartString(x), 1) = "S" Then
        
        'work out the angle relative to the line
        If x = 12345 Then 'use this for the radial tree
            For Y = 1 To EdgeNo
                If MartVertex(0, x) = MartEdge(0, Y) And MartVertex(1, x) = MartEdge(1, Y) Then
                    x = x
                    If MartEdge(1, Y) <> MartEdge(3, Y) Then
                        chx = (MartEdge(0, Y) - MartEdge(2, Y)) / (MartEdge(1, Y) - MartEdge(3, Y))
                    
                        x = x
                        NX = 8 * (chx / (Abs(chx) + 1))
                        NY = 8 * (1 / (Abs(chx) + 1))
                    Else
                        NX = 8
                        NY = 0
                    End If
                    If MartEdge(0, Y) > MartEdge(2, Y) Then
                        NX = Abs(NX)
                    Else
                        NX = Abs(NX) * -1
                    End If
                    If MartEdge(1, Y) > MartEdge(3, Y) Then
                        NY = Abs(NY)
                    Else
                        NY = Abs(NY) * -1
                    End If
                    NX = NX - 3
                    NY = NY - 4
                    x = x
                    Exit For
                End If
            
            Next Y
            Dummy = TextOut(Pict, XOff + MartVertex(0, x) * XAdj + NX, YOff + MartVertex(1, x) * YAdj + NY, Right(MartString(x), Len(MartString(x)) - 1), Len(Right(MartString(x), Len(MartString(x)) - 1)))
        Else
            NX = 5
            NY = -6
            Dummy = TextOut(Pict, XOff + MartVertex(0, x) * XAdj + NX, YOff + MartVertex(1, x) * YAdj + NY, Right(MartString(x), Len(MartString(x)) - 1), Len(Right(MartString(x), Len(MartString(x)) - 1)))
        End If
        Form2.Picture2(3).Refresh
    Else
        'Form2.Picture2(3).PSet (xoff + MartVertex(0, X) * XAdj, YOff + MartVertex(1, X) * YAdj), RGB(255, 0, 0)
    
    End If
Next x
x = x

For x = 0 To NextNo
    OriginalName(x) = TempName2(x)
Next x


ChDrive oDir
ChDir oDir
NextNo = oNextno
    
  NextNo = oNextno
    
End Sub
Public Sub UNIFOLDSets()

'make recombination maps

Dim RecMap() As Long, CurPar, StartPos As Long, TempSU() As String
ReDim RecMap(Len(StrainSeq(0)), NextNo), CurPar(NextNo)
For Y = 1 To Len(StrainSeq(0))
    If SeqNum(Y, 0) <> SeqNum(Y, 1) Then
        GoOn = 1
        For x = 0 To NextNo
            If SeqNum(Y, x) = SeqNum(Y, 0) Then
                CurPar(x) = 1
                RecMap(Y, x) = 1
            ElseIf SeqNum(Y, x) = SeqNum(Y, 1) Then
                CurPar(x) = 2
                RecMap(Y, x) = 2
            Else
                GoOn = 0
                Exit For
            End If
        Next x
        If GoOn = 1 Then Exit For
    End If
Next Y
StartPos = Y
Y = Y + 1



Do While Y <> StartPos
    If SeqNum(Y, 0) = SeqNum(Y, 1) Then
        For x = 0 To NextNo
            RecMap(Y, x) = CurPar(x)
        Next x
    Else
        For x = 0 To NextNo
            If SeqNum(Y, x) = SeqNum(Y, 0) Then
                CurPar(x) = 1
            ElseIf SeqNum(Y, x) = SeqNum(Y, 1) Then
                CurPar(x) = 2
            End If
            RecMap(Y, x) = CurPar(x)
        Next x
    End If
    Y = Y + 1
    If Y > Len(StrainSeq(0)) Then Y = 1
    If Y = StartPos Then Exit Do
    
Loop

'get rid of mutations
For x = 2 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) <> SeqNum(Y, 1) And SeqNum(Y, x) <> SeqNum(Y, 0) Then
            If SeqNum(Y, 0) = SeqNum(Y, 1) Then
                SeqNum(Y, x) = SeqNum(Y, 0)
                Mid(StrainSeq(x), Y, 1) = Mid(StrainSeq(0), Y, 1)
            Else
                If RecMap(Y, x) = 1 Then
                    SeqNum(Y, x) = SeqNum(Y, 0)
                    Mid(StrainSeq(x), Y, 1) = Mid(StrainSeq(0), Y, 1)
                Else
                    SeqNum(Y, x) = SeqNum(Y, 1)
                    Mid(StrainSeq(x), Y, 1) = Mid(StrainSeq(1), Y, 1)
                End If
                'scan forwardandf back to see which parent this part belongs to
            End If
        End If
    Next Y
Next x


'do the permutations that preserve the spacing of breakpoints
Dim DiffPos(), LenSub As Long, DH As Double
ReDim DiffPos(Len(StrainSeq(0)))
x = 1
For Y = 1 To Len(StrainSeq(0))
    If SeqNum(Y, 0) <> SeqNum(Y, 1) Then
        DiffPos(x) = Y
        x = x + 1
    End If
Next Y
LenSub = x - 1

Dim RNum2 As Long, TempS() As String, MyValue As Long, PatchLen() As Long, PatchNum As Long, DonePos() As Long, TempLen As Long, ZZ As Long, Par(1) As String, TUPos() As Long, PPos() As Long, CS As Long
ReDim TempS(100)
ReDim TempSU(100)


Dim LenSub2 As Long

LenSub2 = Z + Y

Rnd (-BSRndNumSeed)
'For X = 14 To Nextno
For x = 47 To NextNo
    If x = x Then
        'first do the easy shuffle
        
        Par(0) = String(Len(StrainSeq(0)), " ")
        Par(1) = String(Len(StrainSeq(0)), " ")
        For Y = 0 To 100
            TempSU(Y) = String(Len(StrainSeq(0)), " ")
        Next Y
        For Y = 0 To 100
            TempS(Y) = StrainSeq(x)
            
            If Y > 0 Then
                MyValue = Int((LenSub * Rnd))
                
                If SeqNum(DiffPos(MyValue), 0) > 50 And SeqNum(DiffPos(MyValue), 1) > 50 Then
                    For A = 1 To LenSub
                        b = A + MyValue
                        If b >= LenSub Then b = b - LenSub
                        If RecMap(DiffPos(b), x) = 1 Then
                            Mid$(TempS(Y), DiffPos(A), 1) = Mid$(StrainSeq(0), DiffPos(A), 1)
                        ElseIf RecMap(DiffPos(b), x) = 2 Then
                            Mid$(TempS(Y), DiffPos(A), 1) = Mid$(StrainSeq(1), DiffPos(A), 1)
                        Else
                            x = x
                        End If
                    Next A
                    'check for unacceptable recmbination breakpoints
                    CS = 0
                    For A = 1 To Len(StrainSeq(0))
                        If Mid$(TempS(Y), A, 1) <> Mid$(StrainSeq(0), A, 1) Or Mid$(TempS(Y), A, 1) <> Mid$(StrainSeq(1), A, 1) Then
                            If Mid$(TempS(Y), A, 1) = Mid$(StrainSeq(0), A, 1) Then
                                If CS = 2 Then
                                    
                                    If MyValue = 0 And x = 12345 Then
                                        x = x
                                    Else
                                    
                                        If Mid$(StrainSeq(0), A, 1) = "-" Or Mid$(StrainSeq(1), A, 1) = "-" Then 'MyValue = 0 Then
                                            If Mid$(StrainSeq(0), A, 1) = "-" Then
                                                'find the end of the deletion
                                                b = A + 1
                                                Do
                                                    If Mid$(StrainSeq(0), b, 1) <> "-" Then Exit Do
                                                    b = b + 1
                                                    If b > Len(StrainSeq(0)) Then Exit For
                                                Loop
                                                If Mid$(StrainSeq(1), A, 1) <> Mid$(StrainSeq(0), b, 1) Then
                                                    CS = 0
                                                    Y = Y - 1
                                                    Exit For
                                                Else
                                                    A = b
                                                End If
                                            Else
                                                b = A + 1
                                                Do
                                                    If Mid$(StrainSeq(1), b, 1) <> "-" Then Exit Do
                                                    b = b + 1
                                                    If b > Len(StrainSeq(0)) Then Exit For
                                                Loop
                                                If Mid$(StrainSeq(0), A, 1) <> Mid$(StrainSeq(1), b, 1) Then
                                                    CS = 0
                                                    Y = Y - 1
                                                    Exit For
                                                Else
                                                    A = b
                                                End If
                                                
                                            End If
                                            x = x
                                        Else
                                            'give a small chance of accepting a single nt breakpoint between 2 polymorphic nucleotide sites.
                                            RNum2 = Int((10 * Rnd))
                                            If RNum2 <> 4 Then
                                                CS = 0
                                                Y = Y - 1
                                                Exit For
                                            Else
                                                CS = 0
                                            End If
                                        End If
                                    End If
                                End If
                                CS = 1
                            Else
                                
                                If CS = 1 Then
                                    
                                    
                                    If MyValue = 0 And x = 12345 Then
                                        x = x
                                    Else
                                    
                                        If Mid$(StrainSeq(0), A, 1) = "-" Or Mid$(StrainSeq(1), A, 1) = "-" Then 'MyValue = 0 Then
                                            If Mid$(StrainSeq(0), A, 1) = "-" Then
                                                'find the end of the deletion
                                                b = A + 1
                                                If A > 1 Then
                                                    Do
                                                        If Mid$(StrainSeq(0), b, 1) <> "-" Then Exit Do
                                                        b = b + 1
                                                        If b > Len(StrainSeq(0)) Then Exit For
                                                    Loop
                                                    If Mid$(StrainSeq(1), A, 1) <> Mid$(StrainSeq(0), b, 1) Then
                                                        CS = 0
                                                        Y = Y - 1
                                                        Exit For
                                                    Else
                                                        A = b
                                                    End If
                                                End If
                                            Else
                                                b = A + 1
                                                If A > 1 Then
                                                    Do
                                                        If Mid$(StrainSeq(1), b, 1) <> "-" Then Exit Do
                                                        b = b + 1
                                                        If b > Len(StrainSeq(0)) Then Exit For
                                                    Loop
                                                    'xxx = Mid$(StrainSeq(0), 2768, 15)
                                                    'yyy = Mid$(StrainSeq(1), 2768, 15)
                                                    If Mid$(StrainSeq(0), A, 1) <> Mid$(StrainSeq(1), b, 1) Then
                                                        CS = 0
                                                        Y = Y - 1
                                                        Exit For
                                                    Else
                                                        A = b
                                                    End If
                                                End If
                                            End If
                                            x = x
                                        Else
                                            'give a small chance of accepting a single nt breakpoint between 2 polymorphic nucleotide sites.
                                            RNum2 = Int((10 * Rnd))
                                            If RNum2 <> 4 Then
                                                CS = 0
                                                Y = Y - 1
                                                Exit For
                                            Else
                                                CS = 0
                                            End If
                                        End If
                                    End If
                                End If
                                CS = 2
                            End If
                        Else
                            CS = 0
                        End If
                    Next A
                    x = x
                Else
                    Y = Y - 1
                End If
                
                
                
            End If
        Next Y
        ReDim TUPos(100)
        ReDim PPos(100)
        'make gaples strings
        For Z = 1 To Len(StrainSeq(0))
            If Mid$(StrainSeq(0), Z, 1) <> "-" Then
                PPos(0) = PPos(0) + 1
                Mid$(Par(0), PPos(0), 1) = Mid$(StrainSeq(0), Z, 1)
            End If
            If Mid$(StrainSeq(1), Z, 1) <> "-" Then
                PPos(1) = PPos(1) + 1
                Mid$(Par(1), PPos(1), 1) = Mid$(StrainSeq(1), Z, 1)
            End If
            For Y = 0 To 100
                If Mid$(TempS(Y), Z, 1) <> "-" Then
                    TUPos(Y) = TUPos(Y) + 1
                    Mid$(TempSU(Y), TUPos(Y), 1) = Mid$(TempS(Y), Z, 1)
                End If
            Next Y
        Next Z
        Par(0) = Trim(Par(0))
        Par(1) = Trim(Par(1))
        For Z = 1 To 100
            TempSU(Z) = Trim(TempSU(Z))
        Next Z
        oDir = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        Open "Cons_Aligned_" + Trim(Str(x - 1)) + "(" + OriginalName(x) + ").fas" For Output As #1
        Print #1, ">" + "parent_1"
        Print #1, StrainSeq(0)
        Print #1, ">" + "parent_2"
        Print #1, StrainSeq(1)
        For Y = 0 To 100
            Print #1, ">" + Trim(Str(Y))
            Print #1, TempS(Y)
        Next Y
        
        Close #1
        Open "Cons_UnAligned_" + Trim(Str(x - 1)) + "(" + OriginalName(x) + ").fas" For Output As #1
        Print #1, ">" + "parent_1"
        Print #1, Par(0)
        Print #1, ">" + "parent_2"
        Print #1, Par(1)
        For Y = 0 To 100
            Print #1, ">" + Trim(Str(Y))
            Print #1, TempSU(Y)
        Next Y
        
        Close #1
        
       
        ChDrive oDir
        ChDir oDir
        
        For Y = 0 To 100
            TempSU(Y) = String(Len(StrainSeq(0)), " ")
        Next Y
        
        'then do the hard shuffle
        ReDim PatchLen(LenSub), DonePos(LenSub)
        PatchNum = -1
        For A = 1 To LenSub
            PatchNum = PatchNum + 1
            If RecMap(DiffPos(A), x) = 1 Then
                For b = A + 1 To LenSub
                    If RecMap(DiffPos(b), x) = 2 Then
                        A = b - 1
                        Exit For
                    End If
                    PatchLen(PatchNum) = PatchLen(PatchNum) + 1
                Next b
                If b = LenSub + 1 Then A = LenSub + 1
            Else
                For b = A + 1 To LenSub
                    If RecMap(DiffPos(b), x) = 1 Then
                        A = b - 1
                        Exit For
                    End If
                    PatchLen(PatchNum) = PatchLen(PatchNum) + 1
                Next b
                If b = LenSub + 1 Then A = LenSub + 1
            End If
        Next A
        DH = PatchNum / 2
        'sort out the ends (if patchnum is even it means that the end patch must be added to the first patch)
        If DH = CLng(DH) Then
            PatchLen(0) = PatchLen(0) + PatchLen(PatchNum)
            PatchNum = PatchNum - 1
        End If
        'first, randomly shuffle the patches
        
        'then randomly start them
        x = x
        For Y = 0 To 100
            XX = PatchLen(3)
            TempS(Y) = StrainSeq(x)
            If Y > 0 Then
                'XX = PatchLen(23)
                If PatchNum > 4 Then
                    For Z = 0 To PatchNum
                        Do
                            MyValue = Int((PatchNum * Rnd))
                            DH = Z / 2
                            If DH <> CLng(DH) Then
                                DH = MyValue / 2
                                
                                If DH <> CLng(DH) Then
                                    Exit Do 'both are odd and can therefore be shuffled
                                End If
                            Else
                                DH = MyValue / 2
                                
                                If DH = CLng(DH) Then
                                    Exit Do 'both are even and can therefore be shuffled
                                    
                                End If
                            End If
                        Loop
                        TempLen = PatchLen(MyValue)
                        PatchLen(MyValue) = PatchLen(Z)
                        PatchLen(Z) = TempLen
                    Next Z
                End If
                
                MyValue = Int((LenSub * Rnd))
                ZZ = 0
                
                State = RecMap(DiffPos(1), x)
                For A = 0 To PatchNum
                    For C = 0 To PatchLen(A)
                        
                        ZZ = ZZ + 1
                        b = MyValue + ZZ
                        If b > LenSub Then b = b - LenSub
                        If State = 1 Then
                            Mid$(TempS(Y), DiffPos(b), 1) = Mid$(StrainSeq(0), DiffPos(b), 1)
                        ElseIf State = 2 Then
                            Mid$(TempS(Y), DiffPos(b), 1) = Mid$(StrainSeq(1), DiffPos(b), 1)
                        Else
                            x = x
                        End If
                    Next C
                    If State = 1 Then
                        State = 2
                    Else
                        State = 1
                    End If
                Next A
                x = x
                'check for unacceptable recmbination breakpoints
                CS = 0
                For A = 1 To Len(StrainSeq(0))
                    If Mid$(TempS(Y), A, 1) <> Mid$(StrainSeq(0), A, 1) Or Mid$(TempS(Y), A, 1) <> Mid$(StrainSeq(1), A, 1) Then
                        If Mid$(TempS(Y), A, 1) = Mid$(StrainSeq(0), A, 1) Then
                            If CS = 2 Then
                                
                                If MyValue = 0 And x = 12345 Then
                                    x = x
                                Else
                                
                                    If Mid$(StrainSeq(0), A, 1) = "-" Or Mid$(StrainSeq(1), A, 1) = "-" Then 'MyValue = 0 Then
                                        If Mid$(StrainSeq(0), A, 1) = "-" Then
                                            'find the end of the deletion
                                            b = A + 1
                                            Do
                                                If Mid$(StrainSeq(0), b, 1) <> "-" Then Exit Do
                                                b = b + 1
                                                If b > Len(StrainSeq(0)) Then Exit For
                                            Loop
                                            If Mid$(StrainSeq(1), A, 1) <> Mid$(StrainSeq(0), b, 1) Then
                                                CS = 0
                                                Y = Y - 1
                                                Exit For
                                            Else
                                                A = b
                                            End If
                                        Else
                                            b = A + 1
                                            Do
                                                If Mid$(StrainSeq(1), b, 1) <> "-" Then Exit Do
                                                b = b + 1
                                                If b > Len(StrainSeq(0)) Then Exit For
                                            Loop
                                            If Mid$(StrainSeq(0), A, 1) <> Mid$(StrainSeq(1), b, 1) Then
                                                CS = 0
                                                Y = Y - 1
                                                Exit For
                                            Else
                                                A = b
                                            End If
                                            
                                        End If
                                        x = x
                                    Else
                                        'give a small chance of accepting a single nt breakpoint between 2 polymorphic nucleotide sites.
                                        RNum2 = Int((10 * Rnd))
                                        If RNum2 <> 4 Then
                                            CS = 0
                                            Y = Y - 1
                                            Exit For
                                        Else
                                            CS = 0
                                        End If
                                    End If
                                End If
                            End If
                            CS = 1
                        Else
                            
                            If CS = 1 Then
                                
                                
                                If MyValue = 0 And x = 12345 Then
                                    x = x
                                Else
                                
                                    If Mid$(StrainSeq(0), A, 1) = "-" Or Mid$(StrainSeq(1), A, 1) = "-" Then 'MyValue = 0 Then
                                        If Mid$(StrainSeq(0), A, 1) = "-" Then
                                            'find the end of the deletion
                                            b = A + 1
                                            If A > 1 Then
                                                Do
                                                    If Mid$(StrainSeq(0), b, 1) <> "-" Then Exit Do
                                                    b = b + 1
                                                    If b > Len(StrainSeq(0)) Then Exit For
                                                Loop
                                                If Mid$(StrainSeq(1), A, 1) <> Mid$(StrainSeq(0), b, 1) Then
                                                    CS = 0
                                                    Y = Y - 1
                                                    Exit For
                                                Else
                                                    A = b
                                                End If
                                            End If
                                        Else
                                            b = A + 1
                                            If A > 1 Then
                                                Do
                                                    If Mid$(StrainSeq(1), b, 1) <> "-" Then Exit Do
                                                    b = b + 1
                                                    If b > Len(StrainSeq(0)) Then Exit For
                                                Loop
                                                'xxx = Mid$(StrainSeq(0), 2768, 15)
                                                'yyy = Mid$(StrainSeq(1), 2768, 15)
                                                If Mid$(StrainSeq(0), A, 1) <> Mid$(StrainSeq(1), b, 1) Then
                                                    CS = 0
                                                    Y = Y - 1
                                                    Exit For
                                                Else
                                                    A = b
                                                End If
                                            End If
                                        End If
                                        x = x
                                    Else
                                        'give a small chance of accepting a single nt breakpoint between 2 polymorphic nucleotide sites.
                                        RNum2 = Int((10 * Rnd))
                                        If RNum2 <> 4 Then
                                            CS = 0
                                            Y = Y - 1
                                            Exit For
                                        Else
                                            CS = 0
                                        End If
                                    End If
                                End If
                            End If
                            CS = 2
                        End If
                    Else
                        CS = 0
                    End If
                Next A
            End If
            
            
            
        Next Y
        
        ReDim TUPos(100)
        
        'make gaples strings
        For Z = 1 To Len(StrainSeq(0))
            
            For Y = 0 To 100
                If Mid$(TempS(Y), Z, 1) <> "-" Then
                    TUPos(Y) = TUPos(Y) + 1
                    Mid$(TempSU(Y), TUPos(Y), 1) = Mid$(TempS(Y), Z, 1)
                End If
            Next Y
        Next Z
        
        For Z = 1 To 100
            TempSU(Z) = Trim(TempSU(Z))
        Next Z
        
        oDir = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        Open "NonCons_Aligned_" + Trim(Str(x - 1)) + "(" + OriginalName(x) + ").fas" For Output As #1
        Print #1, ">" + "parent_1"
        Print #1, StrainSeq(0)
        Print #1, ">" + "parent_2"
        Print #1, StrainSeq(1)
        For Y = 0 To 100
            Print #1, ">" + Trim(Str(Y))
            Print #1, TempS(Y)
        Next Y
        Close #1
        
        
        
        
        Open "NonCons_UnAligned_" + Trim(Str(x - 1)) + "(" + OriginalName(x) + ").fas" For Output As #1
        Print #1, ">" + "parent_1"
        Print #1, Par(0)
        Print #1, ">" + "parent_2"
        Print #1, Par(1)
        For Y = 0 To 100
            Print #1, ">" + Trim(Str(Y))
            Print #1, TempSU(Y)
        Next Y
        
        oz = 0
        OY = 0
        oa = 0
        For H = 0 To 100
        
            Z = 0 '127
            Y = 0 '404
            A = 0
            '491
            For g = 1 To Len(StrainSeq(0))
                If SeqNum(g, 0) <> SeqNum(g, 1) Then
            
                    If Mid$(TempS(H), g, 1) = Mid$(StrainSeq(0), g, 1) Then
                        Z = Z + 1
                    ElseIf Mid$(TempS(H), g, 1) = Mid$(StrainSeq(1), g, 1) Then
                        Y = Y + 1
                    Else
                        A = A + 1
                    End If
                     
                End If
            Next g
            
            XX = Z + Y
            If H = 0 Then
                oz = Z
                OY = Y
                oa = A
            End If
            If oz <> Z Or OY <> Y Or A <> oa Then
                x = x
            End If
            x = x
        Next H
        
        
        Close #1
        
        ChDrive oDir
        ChDir oDir
       
        Form1.ProgressBar1.Value = (x / NextNo) * 100
        Call UpdateF2Prog
    End If
Next x
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
x = x
End Sub
Public Sub CeliaStuff()
Dim NumX As Long, NumY As Long, NeutData() As Long, Crap As String, XNames() As String, Ynames() As String, XMat() As Double, YMat() As Double, FName As String
FName = "CAP ID80.csv"
NumX = 6
NumY = 188
ChDir App.Path

ReDim NeutData(NumX, NumY), XNames(NumX), Ynames(NumY), XMat(NumX, NumX), YMat(NumY, NumY)
Open FName For Input As #1
'Line Input #1, Crap
For x = 0 To NumX
    Input #1, XNames(x)
    x = x
Next x
For Y = 1 To NumY
    Input #1, Ynames(Y)
    x = x
    For x = 1 To NumX
        Input #1, NeutData(x, Y)
        x = x
    Next x
Next Y
Close #1

For x = 1 To NumX - 1
    For Z = x + 1 To NumX
        For Y = 1 To NumY
            XMat(x, Z) = XMat(x, Z) + Abs(NeutData(x, Y) - NeutData(Z, Y))
        Next Y
        XMat(Z, x) = XMat(x, Z)
    Next Z
Next x

For x = 1 To NumY - 1
    For Z = x + 1 To NumY
        For Y = 1 To NumX
            YMat(x, Z) = YMat(x, Z) + Abs(NeutData(Y, x) - NeutData(Y, Z))
        Next Y
        YMat(Z, x) = YMat(x, Z)
    Next Z
Next x


Open FName + "xmatrix.csv" For Output As #1
Dim OutString As String
OutString = ""
For x = 1 To NumX
    OutString = OutString + "," + XNames(x)
Next x
Print #1, OutString
For x = 1 To NumX
    OutString = XNames(x)
    For Y = 1 To NumX
        OutString = OutString + "," + Trim(Str(XMat(x, Y)))
    Next Y
    Print #1, OutString
Next x

Close #1
Open FName + "ymatrix.csv" For Output As #1
OutString = ""
For x = 1 To NumY
    OutString = OutString + "," + Ynames(x)
Next x
Print #1, OutString
For x = 1 To NumY
    OutString = Ynames(x)
    For Y = 1 To NumY
        OutString = OutString + "," + Trim(Str(YMat(x, Y)))
    Next Y
    Print #1, OutString
Next x

Close #1

End Sub
Public Sub CalcPSim(II As Double, OI As Double, BPos As Long, Epos As Long, DS As Long, MiS As Long, MaS As Long, RecSeq As Long, PAVal As Long)
Dim Acnt As Long, x As Long
If NextNo = -1 Then Exit Sub

If UBound(MissingData, 2) < MiS Then
    ReDim Preserve MissingData(Len(StrainSeq(0)), MiS)
End If

Call ModSeqNum(0, 0, 0)
' For x = 0 To UBound(Daught, 2)
'        If Daught(1, x) <> 0 Then
'            x = x
'        End If
'    Next x
'    x = x
If XoverList(RecSeq, PAVal).OutsideFlag = 0 Or XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
    If DS <= UBound(SeqNum, 2) And MiS <= UBound(SeqNum, 2) Then
        If BPos < Epos Then
            For x = BPos To Epos
                If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                    
                    If SeqNum(x, MiS) <> 46 And MissingData(x, MiS) <> 1 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                            II = II + 1
                        End If
                    End If
                End If
            Next x
            If II = 0 Then 'relax the missingdata condition
                Acnt = 0
                II = 0
                For x = BPos To Epos
                    If SeqNum(x, DS) <> 46 Then
                        If SeqNum(x, MiS) <> 46 Then
                            Acnt = Acnt + 1
                            If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                                II = II + 1
                            End If
                        End If
                    End If
                Next x
            End If
            x = x
        Else
            
            For x = 1 To Epos
                If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                    If SeqNum(x, MiS) <> 46 And MissingData(x, MiS) <> 1 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                            II = II + 1
                        End If
                    End If
                End If
            Next x
            For x = BPos To Len(StrainSeq(0))
                If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                    If SeqNum(x, MiS) <> 46 And MissingData(x, MiS) <> 1 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                            II = II + 1
                        End If
                    End If
                End If
            Next x
            If II = 0 Then 'relax the missingdata condition
                Acnt = 0
                II = 0
                For x = 1 To Epos
                    If SeqNum(x, DS) <> 46 Then
                        If SeqNum(x, MiS) <> 46 Then
                            Acnt = Acnt + 1
                            If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                                II = II + 1
                            End If
                        End If
                    End If
                Next x
                For x = BPos To Len(StrainSeq(0))
                    If SeqNum(x, DS) <> 46 Then
                        If SeqNum(x, MiS) <> 46 Then
                            Acnt = Acnt + 1
                            If SeqNum(x, MiS) <> SeqNum(x, DS) Then
                                II = II + 1
                            End If
                        End If
                    End If
                Next x
            End If
        End If
    End If
    If Acnt > 0 Then
        II = CLng((1 - (II / Acnt)) * 1000) / 10
    Else
        II = 0
    End If
End If
If XoverList(RecSeq, PAVal).OutsideFlag = 0 Or XoverList(RecSeq, PAVal).OutsideFlag = 2 Then
    OI = 0
    Acnt = 0
    If DS <= UBound(SeqNum, 2) And MaS <= UBound(SeqNum, 2) Then
        If BPos < Epos Then
        
            For x = 1 To BPos - 1
                
                If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                    If SeqNum(x, MaS) <> 46 And MissingData(x, MaS) <> 1 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                            OI = OI + 1
                        End If
                    End If
                End If
                
            Next x
    
            For x = Epos + 1 To Len(StrainSeq(0))
                If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                    If SeqNum(x, MaS) <> 46 And MissingData(x, MaS) <> 1 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                            OI = OI + 1
                        End If
                    End If
                End If
            Next x
        
            If OI = 0 Then 'relax the missingdata condition
                OI = 0
                Acnt = 0
                For x = 1 To BPos - 1
                    If SeqNum(x, DS) <> 46 Then
                        If SeqNum(x, MaS) <> 46 Then
                            Acnt = Acnt + 1
                            If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                                OI = OI + 1
                            End If
                        End If
                    End If
                Next x
            
                For x = Epos + 1 To Len(StrainSeq(0))
                    If SeqNum(x, DS) <> 46 Then
                        If SeqNum(x, MaS) <> 46 Then
                            Acnt = Acnt + 1
                            If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                                OI = OI + 1
                            End If
                        End If
                    End If
                Next x
            End If
        
     Else
        For x = Epos + 1 To BPos - 1
            If SeqNum(x, DS) <> 46 And MissingData(x, DS) <> 1 Then
                If SeqNum(x, MaS) <> 46 And MissingData(x, MaS) <> 1 Then
                    Acnt = Acnt + 1
                    If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                        OI = OI + 1
                    End If
                End If
            End If
        Next x
         If OI = 0 Then 'relax the missingdata condition
            OI = 0
            Acnt = 0
            For x = Epos + 1 To BPos - 1
                If SeqNum(x, DS) <> 46 Then
                    If SeqNum(x, MaS) <> 46 Then
                        Acnt = Acnt + 1
                        If SeqNum(x, MaS) <> SeqNum(x, DS) Then
                            OI = OI + 1
                        End If
                    End If
                End If
            Next x
        End If
    End If
    End If
    If Acnt > 0 Then
        OI = CInt((1 - (OI / Acnt)) * 1000) / 10
    Else
        OI = 1000000000
    End If
End If


End Sub
Public Sub PADREML(TreeName As String, OutFlag)
'OL
Dim TempName() As String, oBSTreeStrat As Long, FString As String
ReDim TempName(NextNo)
oBSTreeStrat = 5 'change to bstreestrat to allow other tree drawing methods
For x = 0 To NextNo
    TempName(x) = OriginalName(x)
    Do
        Pos = InStr(1, TempName(x), ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), " ", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
        
    Loop
    Do
        Pos = InStr(1, TempName(x), "(", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), ")", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), ":", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), "[", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), "]", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), ";", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), ".", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
    Do
        Pos = InStr(1, TempName(x), "_", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TempName(x), Pos, 1) = "-"
        Else
            Exit Do
        End If
    Loop
Next x
oNextno = NextNo
Dim TempName2() As String

oDir = CurDir
ChDrive App.Path
ChDir App.Path
If oBSTreeStrat = 5 Then
    Call SaveAlign("infile.fas", 1, TempName(), 7)
Else
    Call SaveAlign("infile.phy", 1, TempName(), 7)
End If
tNextno = NextNo
ReDim TempName2(NextNo)
ReDim Preserve OriginalName(NextNo)
For x = 0 To NextNo
    TempName2(x) = OriginalName(x)
    OriginalName(x) = TempName(x)
Next x




Dim OutString As String
If DebuggingFlag < 2 Then On Error Resume Next
Open "dnadist.bat" For Output As #1
If oBSTreeStrat < 3 Then  'i.e. use phyml3
    OutString = ""
    OutString = "PhyML_3.0_win32.exe -i infile.phy "
    
    If x = x Then ' for now just do no branch tests
    'BSupTest = -1
        OutString = OutString + " -b 0"
    Else
        If BSupTest = 0 And TBSReps <= 1 Then
          OutString = OutString + " -b 0"
        ElseIf BSupTest = 0 Then
          OutString = OutString + " -b " + Trim(Str(TBSReps))
        ElseIf BSupTest = 1 Then 'approximate lr test returning aLRT stats
          OutString = OutString + " -b -1"
        ElseIf BSupTest = 2 Then  'approximate lr test returning chi square based stats
          OutString = OutString + " -b -2"
        ElseIf BSupTest = 3 Then 'sh-like branch support test
          OutString = OutString + " -b -3"
        End If
    End If
    'Substitution model
    If TPModel = 0 Then
          OutString = OutString + " -m JC69"
    ElseIf TPModel = 1 Then
          OutString = OutString + " -m K80"
    ElseIf TPModel = 6 Then
          OutString = OutString + " -m HKY85"
    ElseIf TPModel = 2 Then
          OutString = OutString + " -m F81"
    ElseIf TPModel = 3 Then
          OutString = OutString + " -m F84"
    ElseIf TPModel = 4 Then
          OutString = OutString + " -m TN93"
    ElseIf TPModel = 5 Then
          OutString = OutString + " -m GTR"
    End If
    'tvrat
    If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
          If TPTVRat > 0 Then
                OutString = OutString + " -t " + Trim(Str(TPTVRat * 2))
          Else
                OutString = OutString + "-t e "
          End If
    ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
      OutString = OutString + "-t 1.0"
    End If
    
    'proportion invariable sites
    If TPInvSites < 1 Then
      OutString = OutString + " -v " + Trim(Str(TPInvSites))
    Else
      OutString = OutString + " -v e "
    End If
    
    'number rate categories
     OutString = OutString + " -c " + Trim(Str(TPGamma))
    'gamma correction
     'If TPGamma > 1 Then
    If TPAlpha = 0 Then
        OutString = OutString + " -a e " ' " 1.0"
    Else
        OutString = OutString + " -a " + Trim(Str(TPAlpha))
    End If
    'obstreestrat = 0
    If oBSTreeStrat = 0 Then
        OutString = OutString + " -s NNI "
    ElseIf oBSTreeStrat = 1 Then
        OutString = OutString + " -s SPR "
    ElseIf oBSTreeStrat = 2 Then
        OutString = OutString + " -s BEST "
    End If
    
    OutString = OutString + " --no_memory_check"
    Print #1, OutString
    'Print #1, "del treefile"
        
    'Print #1, "rename infile.phy_phyml_tree.txt treefile "
    BatIndex = 4
ElseIf oBSTreeStrat = 3 Then  'phyml1
            
    OutString = "phyml_win32.exe infile.phy 0 s 1"
  ' BS reps
    If TBSReps <= 1 Then
      OutString = OutString + " 0"
    Else
      OutString = OutString + " " + "0" 'Trim(Str(TBSReps))
    End If
    'Substitution model
    
    If TPModel = 0 Then
          OutString = OutString + " K2P"
    ElseIf TPModel = 1 Then
          OutString = OutString + " K2P"
    ElseIf TPModel = 6 Then
          OutString = OutString + " HKY"
    ElseIf TPModel = 2 Then
          OutString = OutString + " F81"
    ElseIf TPModel = 3 Then
          OutString = OutString + " F84"
    ElseIf TPModel = 4 Then
          OutString = OutString + " TN93"
    ElseIf TPModel = 5 Then
          OutString = OutString + " GTR"
    End If
    'tvrat
    If TPModel <> 0 And TPModel <> 2 And TPModel <> 5 Then
          If TPTVRat > 0 Then
                OutString = OutString + Str(TPTVRat * 2)
          Else
                OutString = OutString + " e"
          End If
    ElseIf TPModel = 0 Or TPModel = 2 Or TPModel = 5 Then
      OutString = OutString + " 1.0"
    End If
    'proportion invariable sites
    If TPInvSites < 1 Then
      OutString = OutString + Str(TPInvSites)
    Else
      OutString = OutString + " e"
    End If
    'number rate categories
     OutString = OutString + Str(TPGamma)
    'gamma correction
     'If TPGamma > 1 Then
          If TPAlpha = 0 Then
              OutString = OutString + " e" ' " 1.0"
          Else
              OutString = OutString + Str(TPAlpha)
          End If
     'End If
    'starting tree
    OutString = OutString + " BIONJ y y"
    Print #1, OutString
    'Print #1, "del treefile"
        
    'Print #1, "rename infile.phy_phyml_tree.txt treefile "
    BatIndex = 4
ElseIf oBSTreeStrat = 5 Then 'FastTree
    OutString = "FastTree -gtr -nt -nosupport -pseudo infile.fas > treefile" '-nosupport-pseudo
    'BatIndex = 65
    PrF = 7
    Print #1, OutString
ElseIf oBSTreeStrat = 4 Then 'RAxML
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "RAxML_info.treefile"
    KillFile "RAxML_parsimonyTree.treefile"
    KillFile "RAxML_log.treefile"
    KillFile "RAxML_result.treefile"
    KillFile "RAxML_bestTree.treefile"
    KillFile "RAxML_bootstrap.treefile"
    On Error GoTo 0
    OutString = "raxmlHPC -s infile -p 1234.phy -n treefile -m GTRCAT"
    'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 4"
    
    'only max parsimony tree
    'Outstring = "raxmlHPC-PTHREADS -s infile.phy -n treefile -m GTRCAT -T 2"
    
    Print #1, OutString
    'Print #1, "del treefile"
        
    'Print #1, "rename infile.phy_phyml_tree.txt treefile "
    BatIndex = 53
End If

Close #1

On Error GoTo 0

XX = TempName(9)
'Call GetCommandOutput(Outstring, 6, True, True)
SS = Abs(GetTickCount)
If oBSTreeStrat = 4 Then
    ShellAndClose "dnadist.bat", 0
ElseIf oBSTreeStrat = 5 Then
    Dummy = GetCommandOutput("dnadist.bat", PrF, True, True)
Else
    Dummy = GetCommandOutput("dnadist.bat", 6, True, True)
End If
Form1.SSPanel1.Caption = "Making PADRE network"
Form2.SSPanel3.Caption = Form1.SSPanel1.Caption

EE = Abs(GetTickCount)
TT = EE - SS
x = x
Dim Treebyte() As Byte, Getstring As String
If oBSTreeStrat < 4 Then
    Call ReadTreeFile(NextNo, 0, 0, "infile.phy_phyml_tree.txt", Getstring, Treebyte())
ElseIf oBSTreeStrat = 4 Then
    Call ReadTreeFile(NextNo, 0, 0, "RAxML_bestTree.treefile", Getstring, Treebyte())
    If FileLen("RAxML_bestTree.treefile") = 0 Then
        'X = X
        Call ReadTreeFile(NextNo, 0, 0, "RAxML_parsimonyTree.treefile", Getstring, Treebyte())
        x = x
    End If
ElseIf oBSTreeStrat = 5 Then
    Call ReadTreeFile(NextNo, 0, 0, "treefile", Getstring, Treebyte())
End If

F2TreeIndex = 3
CTF = 2
Call ReplaceNames(TempName(), NextNo, Getstring)
For x = 0 To NextNo
    XX = TempName(x)
Next x

If OutFlag = 1 Then


    For x = 0 To NextNo
        OriginalName(x) = TempName2(x)
    Next x
    ChDrive oDir
    ChDir oDir
    NextNo = oNextno
    Open TreeName For Output As #1
    Print #1, Getstring
    Close #1
    Exit Sub
End If
Open "treein.tre" For Output As #1
Print #1, Getstring
Close #1
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "coordinates.txt"

Open "padre.bat" For Output As #1
Print #1, "java -jar padre2.jar -r r -m m -s s -i treein.tre -o n"
'Print #1, "java -jar padre2.jar -r m -i treein.tre -o n"
'java -jar padre2.jar -r m -i treein.tre -o n

Close #1
On Error GoTo 0

ShellAndClose "padre.bat", 0
Dim EdgeNo As Long, VertexNo As Long, XXX As String
'Close #1
Open "coordinates.txt" For Binary As #1
XXX = String(LOF(1), " ")
Get #1, 1, XXX
Close #1

Open "coordinates2.txt" For Output As #1
Do
    Pos = InStr(1, XXX, Chr(10), vbBinaryCompare)
    If Pos = 0 Then Exit Do
    Mid$(XXX, Pos, 1) = Chr(13)

Loop
Print #1, XXX
Close #1
Open "coordinates2.txt" For Input As #1
Input #1, EdgeNo
Input #1, VertexNo
ReDim MartVertex(1, VertexNo), MartEdge(3, EdgeNo), MartString(EdgeNo)

For x = 1 To EdgeNo
    For Y = 0 To 3
        Input #1, MartEdge(Y, x)
        
    Next Y
Next x

For x = 1 To VertexNo
    For Y = 0 To 1
        Input #1, MartVertex(Y, x)
        
    Next Y
    Input #1, MartString(x)
    
Next x


Close #1

MaxX = 0
MaxY = 0

For x = 1 To EdgeNo
    'For Y = 0 To 3
        If MartEdge(0, x) > MaxX Then MaxX = MartEdge(0, x)
        If MartEdge(2, x) > MaxX Then MaxX = MartEdge(2, x)
        If MartEdge(1, x) > MaxY Then MaxY = MartEdge(1, x)
        If MartEdge(3, x) > MaxY Then MaxY = MartEdge(2, x)
   ' Next Y
Next x
For x = 1 To VertexNo
    
        If MartVertex(0, x) > MaxX Then MaxX = MartVertex(0, x)
        If MartVertex(1, x) > MaxY Then MaxY = MartVertex(1, x)
   
Next x


'dim inPic As PictureBox

xDim = Form2.Picture2(3).ScaleWidth
ydim = Form2.Picture2(3).ScaleHeight

XOff = xDim / 20
YOff = ydim / 20

xDim = xDim - xDim / 10
ydim = ydim - ydim / 10

XAdj = xDim / MaxX
YAdj = ydim / MaxY
Dim Pict As Long, Pnt As POINTAPI
Form2.Picture2(3).Picture = LoadPicture()

Form2.Picture2(3).ForeColor = RGB(196, 196, 196)


Dim ArcFlag As Byte
For x = 1 To EdgeNo
    'does this edge correspond with a vertix
    For Y = 1 To VertexNo
        
        ArcFlag = 0
        If MartVertex(0, Y) = MartEdge(0, x) And MartVertex(1, Y) = MartEdge(1, x) And Left(MartString(Y), 1) <> "S" Then
            
            ArcFlag = 1
            Exit For
        
            
        End If
    Next Y
    If ArcFlag = 0 Then
        
        Form2.Picture2(3).ForeColor = RGB(0, 0, 0)
        Pict = Form2.Picture2(3).hdc
        Dummy = MoveToEx(Pict, XOff + MartEdge(0, x) * XAdj, YOff + MartEdge(1, x) * YAdj, Pnt)
        Dummy = LineTo(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(1, x) * YAdj)
        Dummy = LineTo(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(3, x) * YAdj)
        x = x
    Else
        Pict = Form2.Picture2(3).hdc
        Form2.Picture2(3).ForeColor = RGB(196, 196, 196)
        If MartEdge(1, x) < MartEdge(3, x) Then
            If MartEdge(0, x) > MartEdge(2, x) Then
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj))
            Else
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj), (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj))
            End If
        Else
         
            If MartEdge(0, x) > MartEdge(2, x) Then
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj), (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj))
            Else
                
                Dummy = Arc(Pict, (XOff + MartEdge(2, x) * XAdj), YOff + MartEdge(1, x) * YAdj, XOff + (MartEdge(2, x) + (MartEdge(0, x) - MartEdge(2, x)) * 2) * XAdj, YOff + (MartEdge(1, x) + (MartEdge(3, x) - MartEdge(1, x)) * 2) * YAdj, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), (XOff + MartEdge(2, x) * XAdj), (YOff + MartEdge(3, x) * YAdj))
            End If
            x = x
         ' Form2.Picture2(3).ForeColor = RGB(196, 0, 0)
         ' Dummy = MoveToEx(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), Pnt)
         ' Dummy = LineTo(Pict, (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        'X = X
            Dummy = SetPixelV(Pict, (XOff + MartEdge(0, x) * XAdj), (YOff + MartEdge(1, x) * YAdj), RGB(255, 0, 0))
           Dummy = SetPixelV(Pict, XOff + MartEdge(2, x) * XAdj, YOff + MartEdge(3, x) * YAdj, RGB(0, 0, 255))
           x = x
        End If
        'Dummy = SetPixelV(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), RGB(255, 0, 0))
        'Dummy = SetPixelV(Pict, xoff + MartEdge(2, X) * XAdj, YOff + MartEdge(3, X) * YAdj, RGB(0, 0, 255))
        'Dummy = SetPixelV(Pict, (xoff + (MartEdge(2, X) + (MartEdge(0, X) - MartEdge(2, X)) / 4) * XAdj), (YOff + (MartEdge(1, X) - (MartEdge(1, X) - MartEdge(3, X)) / 4) * YAdj), RGB(0, 255, 0))
        'Pict = Form2.Picture2(3).hdc
        'Form2.Picture2(3).ForeColor = RGB(196, 196, 196)
        'Dummy = Arc(Pict, (xoff + MartEdge(2, X) * XAdj), YOff + MartEdge(1, X) * YAdj, xoff + (MartEdge(0, X)) * XAdj, YOff + (MartEdge(3, X)) * YAdj, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        'Dummy = MoveToEx(Pict, (xoff + MartEdge(0, X) * XAdj), (YOff + MartEdge(1, X) * YAdj), Pnt)
        'Dummy = LineTo(Pict, (xoff + MartEdge(2, X) * XAdj), (YOff + MartEdge(3, X) * YAdj))
        x = x
    End If
   
    
    x = x
Next x

Form2.Picture2(3).ForeColor = 0

For x = 1 To VertexNo
    If Left(MartString(x), 1) = "S" Then
        
        'work out the angle relative to the line
        If x = 12345 Then 'use this for the radial tree
            For Y = 1 To EdgeNo
                If MartVertex(0, x) = MartEdge(0, Y) And MartVertex(1, x) = MartEdge(1, Y) Then
                    x = x
                    If MartEdge(1, Y) <> MartEdge(3, Y) Then
                        chx = (MartEdge(0, Y) - MartEdge(2, Y)) / (MartEdge(1, Y) - MartEdge(3, Y))
                    
                        x = x
                        NX = 8 * (chx / (Abs(chx) + 1))
                        NY = 8 * (1 / (Abs(chx) + 1))
                    Else
                        NX = 8
                        NY = 0
                    End If
                    If MartEdge(0, Y) > MartEdge(2, Y) Then
                        NX = Abs(NX)
                    Else
                        NX = Abs(NX) * -1
                    End If
                    If MartEdge(1, Y) > MartEdge(3, Y) Then
                        NY = Abs(NY)
                    Else
                        NY = Abs(NY) * -1
                    End If
                    NX = NX - 3
                    NY = NY - 4
                    x = x
                    Exit For
                End If
            
            Next Y
            Dummy = TextOut(Pict, XOff + MartVertex(0, x) * XAdj + NX, YOff + MartVertex(1, x) * YAdj + NY, Right(MartString(x), Len(MartString(x)) - 1), Len(Right(MartString(x), Len(MartString(x)) - 1)))
        Else
            NX = 5
            NY = -6
            Dummy = TextOut(Pict, XOff + MartVertex(0, x) * XAdj + NX, YOff + MartVertex(1, x) * YAdj + NY, Right(MartString(x), Len(MartString(x)) - 1), Len(Right(MartString(x), Len(MartString(x)) - 1)))
        End If
        Form2.Picture2(3).Refresh
    Else
        'Form2.Picture2(3).PSet (xoff + MartVertex(0, X) * XAdj, YOff + MartVertex(1, X) * YAdj), RGB(255, 0, 0)
    
    End If
Next x
x = x
Form1.SSPanel1.Caption = ""
Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
For x = 0 To NextNo
    OriginalName(x) = TempName2(x)
Next x


ChDrive oDir
ChDir oDir
NextNo = oNextno
    
  NextNo = oNextno
End Sub
Public Sub LoadSHAPEV4(FName As String)


Dim Temp As String
On Error Resume Next
XX = 0
XX = Len(StrainSeq(0))

On Error GoTo 0
If XX = 0 Then
    MsgBox ("You need to load an alignment file first")
    Exit Sub

End If
'TypeSeqNumber = 5




If x = x Then 'use this for the SHAPE data
    SHAPECO = 10000
     'change this to 10 to use all shape scores
    
    ReDim SHAPEScores(Len(StrainSeq(0)) * 2)
    'Open "SHAPE.csv" For Input As #1
    'Open "SHAPEMedian75FG.csv" For Input As #1
    Open FName For Input As #1
    Pos = 0
    GoOn = 0
    Do While Not EOF(1)
        Input #1, Temp
        If LCase(Temp) = "[siteset]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[site set]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[sitelist]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[site list]" Then GoOn = 1: Exit Do
        
    Loop
    If GoOn = 0 Then
        MsgBox ("I could not read site-list data from this file")
        Exit Sub
    End If
    
    
    
    Do While Not EOF(1)
        Pos = Pos + 1
        
        If Pos > UBound(SHAPEScores, 1) Then
            MsgBox ("The number of sites in the siteset is larger than that in the alignment.  You need to make sure that the numbers match exactly")
            Close #1
            Exit Sub
        End If
        
        
        Input #1, SHAPEScores(Pos)
'        If SHAPEScores(Pos) > 10000 Then
'            X = X
'        ElseIf SHAPEScores(Pos) < 0 Then
'            SHAPEScores(Pos) = 0
'        End If
    Loop
    Close #1
    'look for consecutive numbers (the user may have numbered the sites)
    'check oddnumbers
    oddevenflag = -1
    Dim tSS() As Single
    For x = 1 To UBound(SHAPEScores, 1) - 2 Step 2
        If SHAPEScores(x) + 1 <> SHAPEScores(x + 2) Then
            Exit For
        End If
    Next x
    If x > UBound(SHAPEScores, 1) / 2 Then
    'check if its even numbers
        For x = 2 To UBound(SHAPEScores, 1) - 2 Step 2
            If SHAPEScores(x) + 1 <> SHAPEScores(x + 2) Then
                Exit For
            End If
        Next x
        If x > UBound(SHAPEScores, 1) / 2 Then
            
        Else
            ReDim tSS(Len(StrainSeq(0)) * 2)
       
            For x = 2 To UBound(SHAPEScores, 1)
                tSS(SHAPEScores(x)) = SHAPEScores(x - 1)
            Next x
            ReDim SHAPEScores(Len(StrainSeq(0)) * 2)
            For x = 1 To UBound(tSS)
                SHAPEScores(x) = tSS(x)
            Next x
            
            Pos = Len(StrainSeq(0))
        End If
        
    Else
        oddevenflag = 1 'the odd numbers are positions and shapescore needs to be "repacked"
        
        ReDim tSS(Len(StrainSeq(0)) * 2)
       
        For x = 1 To UBound(SHAPEScores, 1) - 1
            tSS(SHAPEScores(x)) = SHAPEScores(x + 1)
        Next x
        ReDim SHAPEScores(Len(StrainSeq(0)) * 2)
        For x = 1 To UBound(tSS)
            SHAPEScores(x) = tSS(x)
        Next x
        
        Pos = Len(StrainSeq(0))
    End If
    x = x
    
    
     If Pos < Len(StrainSeq(0)) Then
        'Response = MsgBox("Are the coordinates in this file alignment coordinates (i.e. I do not need to first map these to the alignment - which is usually going to be longer than any of the individual sequences in the alignment because of inserted gap characters)?", vbYesNo, "Coordinate information")
          
        Response = MsgBox("The number of sites in the siteset is less than that in the alignment. Is this siteset based on one of the sequences in the alignment?", vbYesNo)
        If Response <> 6 Then
            MsgBox ("Either load a site set with the exact number of sites as those in the alignment, or load a siteset specific to one of the sequenecs in the alignment.")
            Exit Sub
        Else
                OP = Screen.MousePointer
                Screen.MousePointer = 1
                NoTypeSeqFlag = 0
                OX = Form7.Left
                OY = Form7.Top
                Form7.Left = Screen.Width / 2 - Form7.Width / 2
                Form7.Top = Screen.Height / 2 - Form7.Height / 2
                Form7.ScaleMode = 3
                Form7.Caption = "Select Sequence"
                Form7.Label1(0) = "Which sequence?"
                Form7.Label1(0).Top = 20
                Form7.Label1(0).Left = 5
                Form7.Text1(0).Visible = False
                Form7.Text1(1).Visible = False
                Form7.Label1(1).Visible = False
                Form7.Command1(0).Visible = False
                Form7.Command1(1).Visible = False
                Form7.Label1(0).Visible = True
                Form7.Combo1.Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
                Form7.Combo1.Top = Form7.Label1(0).Top - 4
                Form7.Combo1.Width = 200
                Form7.Combo1.Clear
                Z = 0
                Dim TraceZ() As Long
                ReDim TraceZ(Len(StrainSeq(0)))
                Dim OS1 As Long, SSB As Long
                For x = 0 To PermNextno
                    
    
                    If SeqSpacesInFileFlag = 1 Then
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                       
                        OS1 = x * (Len(StrainSeq(0)) + 3)
                        Open "SSFile" + UFTag For Binary As #FF
                        
                        Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                        
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    Else
                        SSB = SeqSpaces(Len(StrainSeq(0)), x)
                        'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                    End If
        
                    If Decompress(Len(StrainSeq(0))) - SSB = Pos Then
                        Form7.Combo1.AddItem OriginalName(x)
                        TraceZ(Z) = x
                        Z = Z + 1
                    End If
                Next x
                
                If Z = 0 Then
                    MsgBox ("there are no sequences in the alignment with the same number of nucleotides as that in the site-set.")
                    Exit Sub
                
                End If
                
                Form7.Combo1.ListIndex = 0
                Form7.Combo1.Visible = True
                OTypeSeq = TypeSeqNumber
                TypeSeqNumber = -1
                Form7.Visible = True
                Do
                    'Form7.Refresh
                    
                    Form7.Combo1.Width = 200
                    DoEvents
                    If TypeSeqNumber <> -1 Then Exit Do
                    Sleep (500)
                    Form7.ZOrder
                    If Form7.Visible = False Then
                        Close #1
                        Exit Sub
                    End If
                Loop
                TypeSeqNumber = TraceZ(TypeSeqNumber)
                For x = Len(StrainSeq(0)) To 0 Step -1
                    If SeqSpacesInFileFlag = 1 Then
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                       
                        OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                        Open "SSFile" + UFTag For Binary As #FF
                        
                        Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                        
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    Else
                        SSB = SeqSpaces(x, TypeSeq)
                        'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                    End If
                    SHAPEScores(x) = SHAPEScores(x - SSB)
                Next x
                
                Form7.Visible = False
                Form7.Left = OX
                Form7.Top = OY
                RelSeq = TypeSeqNumber
                TypeSeqNumber = OTypeSeq
                Screen.MousePointer = OP
        
        End If
        
        Close #1
        
    End If
Else ' use this when the shape data is replaced with similarity data.
        ReDim SHAPEScores(Len(StrainSeq(0)))
        'Open "ID.csv" For Input As #1 'my similarity scores
        Open "IDEt.csv" For Input As #1 'etiennes - similarity scores
        SHAPECO = 1 - IDCO
        For x = 1 To Len(StrainSeq(0))
            Input #1, Temp
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = TypeSeqNumber * (Len(StrainSeq(0)) + 3)
                Open "SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(x, TypeSeqNumber)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            SHAPEScores((x - SSB)) = (1 - Temp)
        Next x
        Close #1
End If


SHAPEFlag = 1
End Sub
Public Sub LoadSHAPE(FName As String)


Dim Temp As String
If DebuggingFlag < 2 Then On Error Resume Next
XX = 0
XX = Len(StrainSeq(0))

On Error GoTo 0
If XX = 0 Then
    MsgBox ("You need to load an alignment file first")
    Exit Sub

End If
'TypeSeqNumber = 5




If x = x Then 'use this for the SHAPE data
    SHAPECO = 10000
     'change this to 10 to use all shape scores
    
    ReDim SHAPEScores(Len(StrainSeq(0)))
    'Open "SHAPE.csv" For Input As #1
    'Open "SHAPEMedian75FG.csv" For Input As #1
    Open FName For Input As #1
    Pos = 0
    GoOn = 0
    Do While Not EOF(1)
        Input #1, Temp
        If LCase(Temp) = "[siteset]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[site set]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[sitelist]" Then GoOn = 1: Exit Do
        If LCase(Temp) = "[site list]" Then GoOn = 1: Exit Do
        
    Loop
    If GoOn = 0 Then
        MsgBox ("I could not read site-list data from this file")
        Exit Sub
    End If
    
    
    
    Do While Not EOF(1)
        Pos = Pos + 1
        
        If Pos > UBound(SHAPEScores, 1) Then
            MsgBox ("The number of sites in the siteset is larger than that in the alignment.  You need to make sure that the numbers match exactly")
            Close #1
            Exit Sub
        End If
        
        Input #1, PosN
        Input #1, SHAPEScores(PosN)
        If SHAPEScores(Pos) > 10000 Then
            x = x
        ElseIf SHAPEScores(Pos) < 0 Then
            SHAPEScores(Pos) = 0
        End If
    Loop
    Close #1
     If Pos < Len(StrainSeq(0)) Then
        'Response = MsgBox("Are the coordinates in this file alignment coordinates (i.e. I do not need to first map these to the alignment - which is usually going to be longer than any of the individual sequences in the alignment because of inserted gap characters)?", vbYesNo, "Coordinate information")
          
        Response = MsgBox("The number of sites in the siteset is less than that in the alignment. Is this siteset based on one of the sequences in the alignment?", vbYesNo)
        If Response <> 6 Then
            MsgBox ("Either load a site set with the exact number of sites as those in the alignment, or load a siteset specific to one of the sequenecs in the alignment.")
            Exit Sub
        Else
                OP = Screen.MousePointer
                Screen.MousePointer = 1
                NoTypeSeqFlag = 0
                OX = Form7.Left
                OY = Form7.Top
                Form7.Left = Screen.Width / 2 - Form7.Width / 2
                Form7.Top = Screen.Height / 2 - Form7.Height / 2
                Form7.ScaleMode = 3
                Form7.Caption = "Select Sequence"
                Form7.Label1(0) = "Which sequence?"
                Form7.Label1(0).Top = 20
                Form7.Label1(0).Left = 5
                Form7.Text1(0).Visible = False
                Form7.Text1(1).Visible = False
                Form7.Label1(1).Visible = False
                Form7.Command1(0).Visible = False
                Form7.Command1(1).Visible = False
                Form7.Label1(0).Visible = True
                Form7.Combo1.Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
                Form7.Combo1.Top = Form7.Label1(0).Top - 4
                Form7.Combo1.Width = 200
                Form7.Combo1.Clear
                Z = 0
                Dim TraceZ() As Long
                ReDim TraceZ(Len(StrainSeq(0)))
                Dim OS1 As Long, SSB As Long
                For x = 0 To PermNextno
                    
    
                    If SeqSpacesInFileFlag = 1 Then
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                       
                        OS1 = x * (Len(StrainSeq(0)) + 3)
                        Open "RDP5SSFile" + UFTag For Binary As #FF
                        
                        Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                        
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    Else
                        SSB = SeqSpaces(Len(StrainSeq(0)), x)
                        'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                    End If
        
                    If Decompress(Len(StrainSeq(0))) - SSB = Pos Then
                        Form7.Combo1.AddItem OriginalName(x)
                        TraceZ(Z) = x
                        Z = Z + 1
                    End If
                Next x
                
                If Z = 0 Then
                    MsgBox ("there are no sequences in the alignment with the same number of nucleotides as that in the site-set.")
                    Exit Sub
                
                End If
                
                Form7.Combo1.ListIndex = 0
                Form7.Combo1.Visible = True
                OTypeSeq = TypeSeqNumber
                TypeSeqNumber = -1
                Form7.Visible = True
                Do
                    'Form7.Refresh
                    
                    Form7.Combo1.Width = 200
                    DoEvents 'xxxxxxxxxxxxxxxxpotentially dangerous
                    If TypeSeqNumber <> -1 Then Exit Do
                    Sleep (500)
                    Form7.ZOrder
                    If Form7.Visible = False Then
                        Close #1
                        Exit Sub
                    End If
                Loop
                TypeSeqNumber = TraceZ(TypeSeqNumber)
                For x = Len(StrainSeq(0)) To 0 Step -1
                    If SeqSpacesInFileFlag = 1 Then
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                       
                        OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                        Open "RDP5SSFile" + UFTag For Binary As #FF
                        
                        Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                        
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    Else
                        SSB = SeqSpaces(x, TypeSeq)
                        'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                    End If
                    SHAPEScores(x) = SHAPEScores(x - SSB)
                Next x
                
                Form7.Visible = False
                Form7.Left = OX
                Form7.Top = OY
                RelSeq = TypeSeqNumber
                TypeSeqNumber = OTypeSeq
                Screen.MousePointer = OP
        
        End If
        
        Close #1
        
    End If
Else ' use this when the shape data is replaced with similarity data.
        ReDim SHAPEScores(Len(StrainSeq(0)))
        'Open "ID.csv" For Input As #1 'my similarity scores
        Open "IDEt.csv" For Input As #1 'etiennes - similarity scores
        SHAPECO = 1 - IDCO
        For x = 1 To Len(StrainSeq(0))
            Input #1, Temp
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = TypeSeqNumber * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(x, TypeSeqNumber)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            SHAPEScores((x - SSB)) = (1 - Temp)
        Next x
        Close #1
End If


SHAPEFlag = 1
End Sub

Public Sub LoadInteractions(FName As String)


Dim Temp As String
If DebuggingFlag < 2 Then On Error Resume Next
XX = 0
XX = Len(StrainSeq(0))

On Error GoTo 0
If XX = 0 Then
    MsgBox ("You need to load an alignment file first")
    Exit Sub

End If
'TypeSeqNumber = 5


ReDim InteractList(4, 100)
InteractListLen = -1
If x = x Then 'use this for the SHAPE data
    
     'change this to 10 to use all shape scores
    
    'ReDim SHAPEScores(Len(StrainSeq(0)))
    'Open "SHAPE.csv" For Input As #1
    'Open "SHAPEMedian75FG.csv" For Input As #1
    Open FName For Input As #1
    Pos = 0
    GoOn = 0
    Do While Not EOF(1)
        Input #1, Temp
        If Left(LCase(Temp), 9) = "[interact" Then GoOn = 1: Exit Do
       
        
    Loop
    If GoOn = 0 Then
        MsgBox ("I could not read site-list data from this file")
        Close #1
        Exit Sub
    End If
    
    
    
    Do While Not EOF(1)
        InteractListLen = InteractListLen + 1
        If InteractListLen > UBound(InteractList, 2) Then
            ReDim Preserve InteractList(4, UBound(InteractList, 2) + 100)
        End If
        
        
        
        Input #1, InteractList(0, InteractListLen)
        Input #1, InteractList(1, InteractListLen)
        Input #1, InteractList(2, InteractListLen)
        Input #1, InteractList(3, InteractListLen)
        
        
        
        x = x
    Loop
    Close #1
     
Else ' use this when the shape data is replaced with similarity data.
        
End If

If InteractListLen >= 0 Then
    INTERACTFlag = 1
End If
End Sub

Public Sub SHAPERegression()
Dim Regressions() As Double, Pos As Double, OutRegress() As Double, Rcounter As Long, NumInRegress() As Long
ReDim Regressions(1, 10000), OutRegress(34, 1, 10000)
oDir = CurDir
ChDir App.Path
ChDrive App.Path
Open "SHAPEMedian75FG.csv" For Input As #1

For x = 0 To 10000
    Regressions(0, x) = -1000
    Regressions(1, x) = -1000
Next x
Do While Not EOF(1)
    Input #1, Pos
    Input #1, Regressions(0, Pos)
    Input #1, Pos
    If Pos >= 0 Then
        Input #1, Regressions(1, Pos)
    Else
        Input #1, Pos
    End If
    x = x
Loop
Close #1
Rcounter = -1
ReDim NumInRegress(34)
For x = 0 To 10000
    If Regressions(0, x) <> -1000 And Regressions(1, x) <> -1000 Then
        Rcounter = Rcounter + 1
        If Rcounter > 34 Then
            Rcounter = 0
        End If
        NumInRegress(Rcounter) = NumInRegress(Rcounter) + 1
        OutRegress(Rcounter, 0, NumInRegress(Rcounter)) = Regressions(0, x)
        OutRegress(Rcounter, 1, NumInRegress(Rcounter)) = Regressions(1, x)
    End If
Next x
Dim LSHAPE As Long
For Y = 37 To 10000
    If Regressions(0, Y) = -1000 Then
        LSHAPE = Y - 1
        Exit For
    End If

Next Y
x = x
Dim NS As Long, Z As Long, RealVal As Double, TotVal As Double, BetterThan As Long, THit As Long
Dim PermNo As Long
PermNo = 10000
Rnd (-BSRndNumSeed)
BetterThan = 0
For Y = 0 To PermNo
    TotVal = 0
    THit = 0
    If Y > 0 Then
        Do
            NS = Int((9000 * Rnd) + 1)    ' Generate random value between 1 and 6.
            If Regressions(0, NS) <> -1000 Then
                Exit Do
            End If
        Loop
    Else
        NS = 0
    End If
    'If Regressions(0, NS) <> -1000 Then
        For x = 37 To LSHAPE
            Z = x + NS
            If Z > LSHAPE Then
                Z = Z - LSHAPE + 36
            End If
            If Regressions(0, Z) <> -1000 And Regressions(1, x) <> -1000 Then
                If Regressions(1, x) < -3# Then
                    TotVal = TotVal + Regressions(0, Z)
                    THit = THit + 1
                End If
            End If
        Next x
        If Y = 0 Then
            RealVal = TotVal
        Else
            If TotVal < RealVal Then
                BetterThan = BetterThan + 1
            End If
        End If
    'End If
Next Y
Dim PVal As Double

PVal = BetterThan / PermNo '3.0 cutoff = 0.011, 2.0 cutoff = 0.037, 1.303 = 0.288
x = x
Dim OutString As String
Open "NewRegression.csv" For Output As #1
For x = 1 To NumInRegress(0)
    OutString = ""
    For Y = 0 To 34
        OutString = OutString + Trim(Str(OutRegress(Y, 0, x))) + "," + Trim(Str(OutRegress(Y, 1, x))) + ","
    Next Y
    Print #1, OutString
Next x
Close #1


ChDir oDir
ChDrive oDir
End Sub
Public Sub ReadCoords2(CoordsFile As String)
'this simply reads in a bunch of numbers that correspond with the boundaries of "genes" (they could be anything - structured vs unstructured, low similarity vs high similarity etc
Dim RelSeq As Long, OTypeSeq As Long, Genes As Long, oDir As String, TypeSeq As Long, Pos As Long, FrameX As Long, StartG As Long, EndG As Long, Temp As String
Dim oCap As String, AVID() As Double, CurTot() As Long, CurValid() As Long, CurID() As Double, A As Long, b As Long, TCount As Long, VCount As Double, ACFlag As Byte, SP As Long, EP As Long

If NextNo = 0 Then
    MsgBox ("You need to first open either an alignment file or a .rdp project file")
    Exit Sub
End If
ReDim AVID(Len(StrainSeq(0))), CurTot(NextNo, NextNo), CurValid(NextNo, NextNo), CurID(NextNo, NextNo)


        
        ReDim GeneList(100), ColBump(100)
        TypeSeq = NextNo 'this is hxb2 in matteo negronis dataset
        Genes = 0
        Open CoordsFile For Input As #1
        FrameX = 0
        Response = MsgBox("Are the coordinates in this file alignment coordinates (i.e. I do not need to first map these to the alignment - which is usually going to be longer than any of the individual sequences in the alignment because of inserted gap characters)?", vbYesNo, "Coordinate information")
            
        If Response = 6 Then 'yes
            ACFlag = 1
        Else 'no
            ACFlag = 0
            Response = MsgBox("Are the coordinates in this file specific to one of the sequences in the alignment?", vbYesNo, "Coordinate information")
            If Response = 6 Then
                OP = Screen.MousePointer
                Screen.MousePointer = 1
                NoTypeSeqFlag = 0
                OX = Form7.Left
                OY = Form7.Top
                Form7.Left = Screen.Width / 2 - Form7.Width / 2
                Form7.Top = Screen.Height / 2 - Form7.Height / 2
                Form7.ScaleMode = 3
                Form7.Caption = "Select Sequence"
                Form7.Label1(0) = "Which sequence?"
                Form7.Label1(0).Top = 20
                Form7.Label1(0).Left = 5
                Form7.Text1(0).Visible = False
                Form7.Text1(1).Visible = False
                Form7.Label1(1).Visible = False
                Form7.Command1(0).Visible = False
                Form7.Command1(1).Visible = False
                Form7.Label1(0).Visible = True
                Form7.Combo1.Left = Form7.Label1(0).Left + Form7.Label1(0).Width + 5
                Form7.Combo1.Top = Form7.Label1(0).Top - 4
                Form7.Combo1.Width = 200
                Form7.Combo1.Clear
                For x = 0 To PermNextno
                    Form7.Combo1.AddItem OriginalName(x)
                Next x
                Form7.Combo1.ListIndex = 0
                Form7.Combo1.Visible = True
                OTypeSeq = TypeSeqNumber
                TypeSeqNumber = -1
                Form7.Visible = True
                Do
                    'Form7.Refresh
                    
                    Form7.Combo1.Width = 200
                    DoEvents 'xxxxxxxxxxxxxxxxxxxxxxxxxxxpotentially dangerous
                    If TypeSeqNumber <> -1 Then Exit Do
                    Sleep (500)
                    Form7.ZOrder
                    If Form7.Visible = False Then
                        Close #1
                        Exit Sub
                    End If
                Loop
                Form7.Visible = False
                Form7.Left = OX
                Form7.Top = OY
                RelSeq = TypeSeqNumber
                TypeSeqNumber = OTypeSeq
                Screen.MousePointer = OP
            Else
                ACFlag = 1
            End If
        End If
        
        Do While Not EOF(1)
            
            FrameX = FrameX + 1
            If FrameX = 4 Then FrameX = 1
            Input #1, Temp
            If Left$(Temp, 1) <> "[" And Temp <> "" Then
                Genes = Genes + 1
                If Genes > UBound(GeneList, 1) Then
                    ReDim Preserve GeneList(Genes + 100)
                End If
                GeneList(Genes).Name = Temp
                Input #1, SP
                Input #1, EP
                
                Do
                    If SP > Len(StrainSeq(0)) Then
                        SP = SP - Len(StrainSeq(0))
                    Else
                        Exit Do
                    End If
                Loop
                Do
                    If EP > Len(StrainSeq(0)) Then
                        EP = EP - Len(StrainSeq(0))
                    Else
                        Exit Do
                    End If
                Loop
                
                If EP > Len(StrainSeq(0)) Then EP = Len(StrainSeq(0))
                GeneList(Genes).ExonNumber = 1
                GeneList(Genes).Frame = FrameX
                GeneList(Genes).IntronFlag = 0
                GeneList(Genes).Orientation = 1
                GeneList(Genes).Product = GeneList(Genes).Name
                Pos = 0
                If ACFlag = 1 Then
                    GeneList(Genes).StartInAlign = SP
                    GeneList(Genes).EndInAlign = EP
                    Pos = 0
                    
                    For x = 1 To SP
                        If SeqNum(x, 1) = 46 Then
                            Pos = Pos + 1
                            
                        End If
                        
                    Next x
                    GeneList(Genes).Start = SP - Pos
                    
                    Pos = 0
                    For x = 1 To EP
                        If SeqNum(x, 1) = 46 Then
                            Pos = Pos + 1
                            
                        End If
                        
                    Next x
                    GeneList(Genes).End = EP - Pos
                    x = x
                Else
                    GeneList(Genes).Start = SP
                    GeneList(Genes).End = EP
                    Pos = 0
                    For x = 1 To Len(StrainSeq(0))
                        If SeqNum(x, RelSeq) <> 46 Then
                            Pos = Pos + 1
                            If Pos = SP Then
                                GeneList(Genes).StartInAlign = x
                                Exit For
                            End If
                        End If
                        
                    Next x
                    Pos = 0
                    For x = 1 To Len(StrainSeq(0))
                        If SeqNum(x, RelSeq) <> 46 Then
                            Pos = Pos + 1
                            If Pos = EP Then
                                GeneList(Genes).EndInAlign = x
                                Exit For
                            End If
                        End If
                        
                    Next x
                    x = x
                End If
            End If
        Loop
        If Genes > 0 And GeneList(Genes).Start = GeneList(Genes).End Then Genes = Genes - 1
        GeneNumber = Genes
         
    ReDim ORFWin(3, Len(StrainSeq(0)))
    'Call DrawORFs
        ORFFlag = 1
        Call DrawORFs
        Form1.Picture4.ScaleMode = 3
        Form1.Picture4.DrawMode = 13
        Picture11ScaleMode = 3
        Form1.Picture19.DrawMode = 13
        DontDoH1Inc = 1
        OnlyDoPositionIndicator = 1
        OnlyDoPosBar = 1
        If Form1.HScroll1.Value > Form1.HScroll1.Min Then
            Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
        Else
            If Form1.HScroll1.Value < Form1.HScroll1.Max Then
                Form1.HScroll1.Value = Form1.HScroll1.Value + 1
                Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            End If
        End If
        OnlyDoPositionIndicator = 0
        OnlyDoPosBar = 0
        DontDoH1Inc = 0
        Close #1
       


End Sub
